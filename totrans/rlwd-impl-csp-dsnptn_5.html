<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor089"/>5</h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Wrangling Problem Code by Applying Behavioral Patterns</h1>
<p>Do you want to have some fun that doesn’t involve code for once? Next time you find yourself in a tall building with an elevator, get with three or four friends and ride to the top floor. Here’s the fun part: have everyone in your group face the back of the elevator. As other people get on the elevator, they will almost always follow your lead and face the rear. This is because human behavior follows patterns! There are entire fields of study devoted to this fact, including psychology, sociology, and the applied fields of marketing and human relations.</p>
<p>Software is a human invention, so it should come as no surprise that software can be made to follow behavioral patterns too. Behavioral patterns are patterns that deal with algorithms implemented within your classes and how those classes interact and share responsibilities for executing those algorithms.</p>
<p>As our story continues, Kitty and Phoebe will be facing challenges that will require them to learn and implement four of the most popular behavioral patterns: </p>
<ul>
<li><strong class="bold">The Command pattern</strong></li>
<li><strong class="bold">The Iterator pattern</strong></li>
<li><strong class="bold">The Observer pattern</strong></li>
<li><strong class="bold">The Strategy pattern</strong></li>
</ul>
<p>As you ride along with them on their journey, you will learn how to diagram and implement the four most popular behavioral patterns using the <strong class="bold">C#</strong> language.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Technical requirements</h1>
<p>Throughout this book, I assume you know how to create new C# projects in your favorite <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>), so I won’t spend any time on the mechanics of setting up and running projects in the chapters themselves. There is a short tutorial on the three most popular IDEs in <a href="B18605_Appendix_1.xhtml#_idTextAnchor178"><em class="italic">Appendix 1</em></a> of this book. Should you decide to follow along, you’ll need the following:</p>
<ul>
<li>A computer running the <strong class="bold">Windows</strong> operating system. I’m using <strong class="bold">Windows 10</strong>. Since the projects are simple command-line projects, I’m pretty sure everything here would also work on a <strong class="bold">Mac</strong> or <strong class="bold">Linux</strong>, but I haven’t tested the projects on those operating systems.</li>
<li>A supported IDE such as <strong class="bold">Visual Studio</strong>, <strong class="bold">JetBrains Rider</strong>, or <strong class="bold">Visual Studio Code</strong> with C# extensions. I’m using <strong class="bold">Rider 2021.3.3</strong>.</li>
<li>Some versions of the the <strong class="bold">.NET SDK</strong>. Again, the projects are simple enough that our code shouldn’t be reliant on any particular version. I happen to be using the <strong class="bold">.NET Core 6 SDK</strong>, and my code’s syntax may reflect that.</li>
</ul>
<p>You can find the completed project files for this chapter on GitHub at <a href="https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-5">https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-5</a>.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Meanwhile, back at the bicycle factory</h1>
<p><em class="italic">“W00t!”</em> Phoebe exclaimed. Kitty was startled and amazed. Her sister had somehow managed to pronounce the hacker slang word while intimating excitement in such a way that Kitty could hear the zeros that replaced the phonetics of the double-o. <em class="italic">“What?”</em> Kitty inquired. Phoebe didn’t answer right away, so Kitty looked up and found Phoebe dancing in circles. Phoebe was clad in dirty coveralls and had her hair pulled back in a ponytail. The sight of a dancing Phoebe was not unusual. Kitty realized there was a line of 10 robotic arms bolted to the floor. The arms were mimicking Phoebe’s dance moves to the best of their limited ability.  </p>
<p>The unchoreographed ballet of arms was unimpressive by the standards of the Vaganova academy. However, within the context of a hand-built robotic factory created by two fourth-year college students in an abandoned warehouse, it was an astonishing achievement. <em class="italic">“That’s amazing!”</em> Kitty laughed. The sisters held hands and danced in circles, which almost caused a large collision as the robots attempted their emulation. They stopped dancing and laughed again. <em class="italic">“So, we’re done?”</em> Kitty asked. <em class="italic">“No. Right now, they just mimic what they see,”</em> Phoebe replied. <em class="italic">“What do you mean by see? Vision was never a part of our specification,”</em> Kitty pointed out. <em class="italic">“I know,”</em> said Phoebe. <em class="italic">“I found one of Boomer’s old Xbox’s in a crate upstairs. It had a Kinect attached to it, so I dusted it off and connected it to our test client program.”</em> Boomer is Kitty and Phoebe’s cousin. He is a year older than Kitty and graduated from the University of Las Vegas last year. He went to college on an eSports scholarship and is now a pro. Naturally, he always had the best gaming gear.</p>
<p>Kitty remembered that Kinect was a camera system Microsoft sold years earlier as part of its Xbox console game platform. It provided a rudimentary computer vision system that was capable of recognizing the shape of a human body. There had been games based on the idea that you could move in front of the camera and the characters in your game would act according to how they  “saw” you move. Naturally, being a Microsoft technology, the SDKs were readily available for C#.</p>
<p><em class="italic">“What a neat idea!”</em> Kitty exclaimed. Phoebe breathlessly continued, <em class="italic">“So, we have a good object structure from our work with Creational patterns and we also have the skeleton of a working system in place because of our structural patterns.”</em> Kitty countered, <em class="italic">“True, but we have not done much with the actual command and control system that drives the robots. The robots can function on their own with our test programs. They can even make bicycle parts by themselves."</em> Phoebe finished Kitty’s thought in a way only sisters can do: <em class="italic">“What they can’t do is work together! I did some more reading last night. It turns out there is a whole collection of patterns that will enable the robots to work together. They </em><em class="italic"><a id="_idIndexMarker333"/></em><em class="italic">are called Behavioral patterns! I think we can use them to control a lot of our systems and orchestrate the robots so that they may work together.”</em> Phoebe walked to the whiteboard and explained the next steps needed to code a control system for the necessary robotics.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>The Command pattern</h1>
<p>At this point, Phoebe has designed two different models of the robotic arm. One set of arms was large and bolted to the floor. These<a id="_idIndexMarker334"/> arms were stationary. The second set of arms was mounted on tracks and could move. These were mainly used for moving the parts, materials, and partially finished bicycles around to different stations. Once at a station, the larger arms would do most of the real work.</p>
<p>The larger arms that were bolted to the floor had interchangeable attachments that allowed them to perform different tasks. Phoebe designed this behavior based on the Decorator pattern. Remember, a decorator allows you to add new behavior to an existing class without you having to modify it directly. This is done by creating a new class that wraps around the structure of the original class, then adds the additional behavior. In this case, the decorators are physical hardware. Phoebe marveled at the patterns. She understood how working with the patterns might be considered a design philosophy as much as a <a id="_idIndexMarker335"/>software engineering practice. Phoebe remembered that patterns were devised by architects of the physical world at a time when software engineering was only done by scientists in top-secret military labs.</p>
<p>Each of the large stationary robotic arms could affix a different attachment for welding or another for buffing and polishing. Each arm could be programmed to take a handoff of materials brought by the smaller, mobile track-mounted robots.</p>
<p>Phoebe drew out her idea for Kitty, explaining how she could model a command for the necessary robotics in a way that was flexible. </p>
<p><em class="italic">“Think of it this way, Kitty,”</em> Phoebe began. <em class="italic">“When we order clothes and shoes online, we pick out the clothes we want to buy. We decide which dresses went want, as well as their color and size. Then, we tell the store where we’d like the clothes to be shipped. Finally, we give the retailer the payment details and a way to contact us if there are questions or problems. The order is a structure that holds all of that information. That’s what I want to do here. I want a pattern where I can send a command. The command should contain everything that the robot needs to know so that it can do its job. The command shouldn’t be tightly coupled to the robot’s control API. In effect, I should be able to send a command to any piece of hardware we have. It isn’t specific to any one robot, or even the attachment it’s using at the time.”</em></p>
<p><em class="italic">“I see,”</em> said Kitty. <em class="italic">“So, the order that contains all the information for the clothes we want to buy could just as easily be sent to any store in the world. We are the senders of the command. We compile the information and send it to a receiver. The receiver isn’t unique to a single store and that receiver could be anything equipped to receive our command. We’re packaging up everything needed to complete an order or a command and it’s up to the receiver to act on it.”</em></p>
<p><em class="italic">“You’ve got it, sis!”</em> Phoebe beamed. They were excited to get started. Phoebe brought up a diagram she had found online that showed the pattern in its generic form, as shown here:</p>
<div><div><img alt="Figure 5.1 – The Command pattern. " height="664" src="img/B18605_Figure_5.1.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The Command pattern.</p>
<p>Let’s review the different parts of the pattern, which have been numbered appropriately:</p>
<ol>
<li>A <code>Sender</code> object is responsible <a id="_idIndexMarker336"/>for invoking a request. For example, when Phoebe orders a dress online, the website is gathering the necessary information and is responsible for sending the order.</li>
<li>The <code>ICommand</code> interface defines a single method that’s used to execute a command. The sender doesn’t create the command. Instead, it receives it in the constructor, or it can be set as a property.</li>
<li>The <code>Receiver</code> class contains business logic and performs the actual work. The shop that receives the online order is the receiver when Phoebe orders online. The business logic might be different from store to store. Each might have a different process for the way the order is picked, pulled, settled, then shipped. The logic is up to the receiver. It receives the command that contains what it needs to perform the logic independently from the sender.</li>
<li>Concrete command classes implement the <code>ICommand</code> interface, but also contain a reference to the receiver that will execute the command, along with any properties or parameters needed to execute the command.</li>
<li>The client instantiates the<a id="_idIndexMarker337"/> concrete command class (<strong class="bold">4</strong>) and passes in or sets any parameters or properties needed by the command, including an instance of the receiver.</li>
</ol>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Applying the Command pattern</h2>
<p>Phoebe drew her pattern idea while <a id="_idIndexMarker338"/>adapting what she had learned from the generic example. The following is her drawing:</p>
<div><div><img alt="Figure 5.2 – Phoebe’s drawing of the Command pattern. " height="850" src="img/B18605_Figure_5.2.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Phoebe’s drawing of the Command pattern.</p>
<p>Kitty studied the diagram for a few minutes. Phoebe watched her closely. Kitty always got a look on her face before an idea clicked. After a minute, there it was. <em class="italic">“I got this!”</em> Kitty said as she walked to her corner of the warehouse and she started to work. After a few hours, she produced the<a id="_idIndexMarker339"/> implementation of the Command pattern. You can review this in the <code>CommandExample</code> project in this chapter’s code, which can be found in this book’s GitHub repository.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Coding the Command pattern</h2>
<p>Kitty started by<a id="_idIndexMarker340"/> creating the <code>ICommand</code> interface:</p>
<pre class="source-code">public interface ICommand
{
    public void Execute();
}</pre>
<p>Next, she made a concrete command that implements this interface:</p>
<pre class="source-code">public class BuildFrameCommand : ICommand
{
    private AssemblyLineReceiver _assemblyLineReceiver;</pre>
<p>Remember, a command object has everything a receiver needs to execute the intent, except the business logic. If you remember Phoebe’s explanation, it even includes a <code>private</code> field to hold the receiver itself. A command is self-contained. In addition to the receiver, it needs the information on the bicycle that the command is responsible for building. Kitty added a project reference to <code>BumbleBikesLibrary</code>, which we covered in <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Getting Creative with Creational Patterns</em>. We extended the library to include the <code>IPaintableBicycle</code> interface that was created using the Bridge pattern in <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Getting Creative with Creational Patterns</em>. As a reminder, always use an interface wherever you can. Concrete objects should come into play as late as possible. This keeps your design flexible and honors <strong class="bold">SOLID</strong> principles:</p>
<pre class="source-code">    private IPaintableBicycle _bicycle;</pre>
<p>Next comes a constructor where we pass in the receiver and <code>IPaintableBicycle</code>:</p>
<pre class="source-code">    public BuildFrameCommand(AssemblyLineReceiver 
        assemblyLineReceiver, IPaintableBicycle bicycle)
    {
        _assemblyLineReceiver = assemblyLineReceiver;
        _bicycle = bicycle;
    }</pre>
<p>Lastly, we have the <code>Execute()</code> method, which is required by the <code>ICommand</code> interface. All it does is run the business logic contained within the receiver:</p>
<pre class="source-code">    public void Execute()
    {
        _assemblyLineReceiver.DoBusinessLogic(_bicycle);
    }
}</pre>
<p>The <code>BuildFrameCommand </code> class is <a id="_idIndexMarker341"/>done. Now, we need a sender. As mentioned previously, there isn’t much going on in the sender. All it needs is a command, which Kitty specified as <code>ICommand</code>, and a method to execute the command, which Kitty has specified as <code>DoCommand()</code>. The <code>DoCommand()</code> method executes the command. This seems a little counterintuitive; you’d think the receiver executes the command. It does, but not directly. If you coded it to execute more directly, you’d likely be tightly coupling the sender, receiver, and command logic together, which is exactly what we want to avoid:</p>
<pre class="source-code">public class Sender
{
    private ICommand _command;
    public Sender(ICommand command)
    {
        _command = command;
    }
    public void DoCommand()
    {
        _command.Execute();
    }
}</pre>
<p>Kitty finishes up with the receiver, which she calls <code>AssemblyLineReceiver</code>. The idea behind this class is that it acts as a master control for the whole assembly line. This is a major part of the orchestration that the girls are trying to achieve.</p>
<p>The <code>AssemblyLineReceiver</code> class needs a project reference to the work we did with the Façade pattern in <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Getting Creative with Creational Patterns</em>. As you may recall, the Façade pattern allows us to present a myriad of complicated APIs as a single, easy-to-use point of contact. In this case, the APIs for the robotics came from the manufacturers. The microcontrollers for the different<a id="_idIndexMarker342"/> robot arm attachments (the welder, the buffer, and the grabber) all came from different manufacturers with different APIs. In <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Getting Creative with Creational Patterns</em>, Kitty and Phoebe wrote a Façade pattern to make this easier to use and to insulate them from repercussions inflicted by future changes to the third-party code, which will evolve independently of the business requirements of Bumble Bike’s manufacturing process.</p>
<p>The Façade pattern also contained an encapsulation of how the line of floor-mounted robots should work. The girls have <a id="_idIndexMarker343"/>opted to use <code>struct</code> common to the gaming industry, to represent the spatial layout of their assembly line. The quaternion struct can be found in the <code>System.Numerics</code> library of the .NET framework.</p>
<p>The first part of the <code>AssemblyLineReceiver</code> class just sets up what we need to use for the façade:</p>
<pre class="source-code">public class AssemblyLineReceiver
{
    private readonly RobotArmFacade _robotArmFacade;
    private const int NumberOfAssemblyStations = 20;
    private const float ConsistentY = 52.0f;
    private const float ConsistentZ = 128.0f;
    private const float ConsistentW = 90.0f;
    private readonly Quaternion[] _assemblyStations;</pre>
<p>Quaternions are a complicated concept. I’m not selling short your intelligence; I’m paraphrasing the documentation for Unity 3D, a popular video game framework written in C#. In video game work with Unity, you can’t swing a virtual cat without hitting a quaternion. The position and angle of the virtual cat would be defined using a quaternion. The Unity documentation straight-up tells you that quaternions are an advanced mathematical concept. The short version is that a quaternion is a combination of three points in space represented as <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em>, along with a rotational vector represented as <em class="italic">W</em>. Since we don’t need to get into the guts of quaternions in a book on patterns, we have simplified the layout of the assembly line by deciding it is a straight line. As such, only one coordinate in the quaternion is different from station to station, and for us, that is the <em class="italic">X</em> coordinate. The remainder can be held constant at a standard height (<em class="italic">Y</em>) and a standard<a id="_idIndexMarker344"/> depth (<em class="italic">Z</em>) within the confines of the factory floor. We will also hold the rotation constant at 90 degrees for the sake of simplicity. To summarize, to represent where a robot sits on the assembly line, we have four coordinates (<em class="italic">X</em>, <em class="italic">Y</em>, <em class="italic">Z</em>, and <em class="italic">W</em>) but we keep three constant. Only <em class="italic">X</em> varies as you move from one end of the assembly line to the other.</p>
<p>The location of each assembly for the stations is held in an array of quaternions. 10 arms can service 20 stations. In the receiver’s constructor, we set up our façade, along with the locations of each station, by populating the <code>_assemblyStations</code> arrays with 20 quaternions:</p>
<pre class="source-code">    public AssemblyLineReceiver(RobotArmFacade 
        robotArmFacade)
    {
        _robotArmFacade = robotArmFacade;
        _assemblyStations = new Quaternion
            [NumberOfAssemblyStations];
        
        for (var i = 0; i &lt; NumberOfAssemblyStations; i++)
        {
            var xPosition = i * 25.0f;
            _assemblyStations[i] = new Quaternion
                (xPosition, ConsistentY, ConsistentZ, 
                    ConsistentW);
        }
    }</pre>
<p>That was a lot of setup, but it is also a nice example of how patterns can be combined. They are all pieces of the bigger puzzle. Next, we will look at the interesting part: the code that performs the <a id="_idIndexMarker345"/>business logic. This is going to look familiar.</p>
<p>The girls had this code in their test <code>Program.cs</code> file in the <code>FacadeExample</code> code we saw back in <a href="B18605_04.xhtml#_idTextAnchor078"><em class="italic">Chapter 4</em></a><em class="italic">, Fortify Your Code with Structural Patterns</em>. The logic itself isn’t really important. In this case, it’s a set of steps to move a bicycle frame from station to station as it is assembled and painted. The key takeaway is that this is where the actual business logic lives. It is kept separate from the sender. In our earlier example, store owners would not want Phoebe telling them how best to pick, pack, and ship the dress she selected. The business logic is not driven by the sender. Likewise, we don’t want the logic in the command itself. The command represents everything needed to perform the logic. It’s the order, not the store workers, executing the order.</p>
<p>In Kitty’s program, the <code>DoBusinessLogic</code> method takes the <code>IPaintableBicycle</code> object (essentially the order for the bicycle) and uses the façade to manipulate the robots to manufacture the bicycle:</p>
<pre class="source-code">    public void DoBusinessLogic(IPaintableBicycle bicycle)
    {
        // Now let's follow an abbreviated imaginary 
        // assembly of a bicycle frame by controlling a robot 
        // arm.
        // grabber gets the frame parts and takes them to 
        // station 1
        _robotArmFacade.ActiveAttachment = 
            ArmAttachments.Grabber;
        _robotArmFacade.MoveTo(_assemblyStations[0]);
        _robotArmFacade.Actuate();
        _robotArmFacade.MoveTo(_assemblyStations[1]);
… see the rest in the sample code.</pre>
<p>Let’s move on to the last<a id="_idIndexMarker346"/> part, which is the client.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Testing the Command pattern’s code</h2>
<p>Rather than showing you<a id="_idIndexMarker347"/> all of Kitty’s client code, which is extensive and complex, I’ll just show you her simple test program for the logic found in <code>Program.cs</code> in the sample code.</p>
<p>Remember, it is the client’s job to create the command. In this example, Phoebe’s job, as the customer, is to pick out a dress online, specify its color, and give her payment and shipping details. Here, the client is specifying what type of bicycle to build and draws on the Bridge pattern. It can also specify the paint job. Here, we’re going with a simple black paint job that is standard for our mountain bike:</p>
<pre class="source-code">var blackPaintJob = new BlackPaintJob();
var standardMountainBike = new PaintableMountainBike
    (blackPaintJob);</pre>
<p>We need access to the control logic for the robot arm façade:</p>
<pre class="source-code">var robotArmFacade = new RobotArmFacade(new 
    WelderAttachmentApi(), new BuffingApi(), new 
        GrabbingApi());</pre>
<p>We must create a command and pass in the data needed to complete the command:</p>
<pre class="source-code">var cmd = new BuildFrameCommand(new AssemblyLineReceiver
    (robotArmFacade), standardMountainBike);</pre>
<p>Finally, we must make a sender object and set everything in motion by calling the <code>DoCommand</code> method on the sender. As promised, the sender initiates the action, but it doesn’t perform any action itself. When Phoebe chooses a dress online, she submits the order. It is the receiver that does the work:</p>
<pre class="source-code">var sender = new Sender(cmd);
sender.DoCommand();</pre>
<p>The Command pattern is one<a id="_idIndexMarker348"/> of the most useful and popular of all the patterns we’ll discuss. The <em class="italic">GoF</em> book, along with many others, discusses how it can be applied to the user interface layer of a desktop or web application. Commands within a UI can be created and sent to other parts of the program from several different parts of the UI. An easy example of this is when you save a file – you typically have a <strong class="bold">File</strong> menu option in your program. You likely also have a menu bar with a <strong class="bold">Save</strong> button, and a key combination such as <em class="italic">Ctrl</em>/<em class="italic">Command</em> + <em class="italic">S</em>. Those are all senders. The Command pattern allows you to encapsulate the receiver logic in one place.</p>
<p>You can use the Command pattern any time you have logic to perform an action and you want to isolate it from tightly coupling to anything that may want to call that logic. The giving, receiving, and execution of commands in the real world is a pattern familiar to anyone who has been a parent giving a command and their child executing it. The command is initiated by a sender and executed by a receiver. The chain of events represents a pattern of behavior we all understand and recognize.</p>
<p>A full bicycle order would, in reality, comprise many of these commands. Here, we have built the frame and painted it. Kitty will build the rest of the logic needed to control the assembly process using commands, so we’ll leave her to do that while we explore more patterns.</p>
<p>Next, we’ll address another fundamental concept in C#: collections. While discussing collections, we’ll focus on a pattern you have used many times maybe without even knowing it was a pattern: the Iterator pattern.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>The Iterator pattern</h1>
<p>Things were going well for Kitty as she worked on the control system, making liberal use of the Command pattern. Then, she<a id="_idIndexMarker349"/> hit something of a roadblock. Kitty’s command receiver logic was just taking bicycle orders from the customer ordering systems, such as direct sales, and the dealerships. The requests were processed in the order they were received. Due to this, Kitty and Phoebe noticed a slowdown. While the algorithms in <code>AssemblyLineReceiver</code> were optimized to efficiently produce bicycles, Kitty failed to consider the painting process.</p>
<p>The costliest part of the painting process in terms of time and money was setting everything up to paint a bicycle. This was very easy earlier when each bicycle was only allowed to be built in one color. Now, Bumble Bikes supports custom paint jobs. The sisters were losing time and money on custom jobs because the paint equipment had to be thoroughly cleaned and reset when a custom order was placed. The paint system would have to mix the colors requested, apply them to the custom order, and then reset to a more common color such as red or black. This was happening many times per day, so when a custom job request was received, it held up all the other bicycles behind it. Phoebe pointed out that when her father had done printing work many years ago, he would group his jobs based on ink color requirements to minimize the number of times he had to clean and re-ink the press. The sisters needed to group their orders by paint job type so that they could do all the custom work in batches and only need to clean and reset once per day. They could have adjusted customer expectations concerning delivery dates on custom paint requests, but that isn’t an abnormal retail situation. Kitty needed to figure out how to group the paint orders efficiently and flexibly.</p>
<p>Kitty’s first thought was to incorporate <code>foreach</code> loop. While it is neat, it could be a problem at the scale she hoped her software might one day require.</p>
<p>In C# work, <code>foreach</code> loops against collections and allows you to iterate over its elements – that is, you can process each item in the collection, one at a time. Collections in C# are strongly typed, meaning every object in the collection, such as a <code>List</code>, is of the same type. The incoming orders for bicycles were stored in a database and loaded into a <code>List&lt;BicycleOrder&gt;</code> in batches throughout the day. The code for the <code>BicycleOrder</code> class looks like this:</p>
<pre class="source-code">public class BicycleOrder
{
    public Customer Customer { get; set; }
    public IPaintableBicycle Bicycle { get; set; }
    public BicycleOrder(Customer customer, 
        IPaintableBicycle bicycle)
    {
        Customer = customer;
        Bicycle = bicycle;
    }
}</pre>
<p>The standard iterator that’s used by C# in the <code>foreach</code> loop is what returns the orders in the order they were added. This is<a id="_idIndexMarker350"/> to say, they operate <code>foreach</code> loop processes. What Kitty needed was an iterator that gave her all the regular paint job orders first, and the custom paint jobs last. In short, she needed a custom iterator. Iterators in C# follow the Iterator pattern. This should hardly be surprising, though you may not have known it was a pattern at play. The Iterator pattern is shown graphically using UML in the following diagram:</p>
<div><div><img alt="Figure 5.3 – A custom iterator follows the Iterator pattern, which is partly already implemented for you in C#. " height="1020" src="img/B18605_Figure_5.3_New.jpg" width="1567"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – A custom iterator follows the Iterator pattern, which is partly already implemented for you in C#.</p>
<p>Let’s review the different parts of the pattern, which have been numbered appropriately:</p>
<ol>
<li value="1">The <code>IEnumerator</code> interface is part of the .NET framework, so this time, you won’t need to make it from scratch. The interface requires one property, <code>Current</code>, which returns the <a id="_idIndexMarker352"/>current element in the iteration. The required <code>MoveNext()</code> method is the mechanism used to advance the iteration to the next element.</li>
<li><code>IEnumerable</code> is another interface that comes with C#, so again, you don’t need to create it. It requires a method, <code>GetEnumerator()</code>, which is what provides an instance of our custom enumerator.</li>
<li>A concrete iterator that implements the <code>IEnumerator</code> interface will have the collection in a <code>private</code> field with the class. Collections, and by extension iterators, work using generics, as indicated by <code>&lt;T&gt;</code>. This means they can adapt to any type, including any classes you create. The class has a constructor that takes a concrete collection. By this, we mean the collection you intend to iterate that was implemented in <code>ConcreteCollection</code>.</li>
<li>A concrete collection.</li>
</ol>
<p>As described, a standard iterator<a id="_idIndexMarker353"/> just gives you a way to work through a collection. Every collection in C# – and there are many – has a common iterator that steps through the collection in order. Any time your business logic requires your iteration to be anything besides FIFO, it is best to encapsulate the algorithm in a custom iterator. We have reached one of those times. Maybe your iterator will have a novel algorithm for moving through the collection. A contrived example might be to have an iterator that only iterates on odd or even elements in the collection. Maybe you need an iterator that iterates strings in alphabetical order. Kitty’s problem is a real-world one – she needs the collection to be filtered and sorted based on paint requirements before a normal iteration. </p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Applying the Iterator pattern</h2>
<p>Let’s look at how Kitty applied the<a id="_idIndexMarker354"/> pattern, as shown in the following diagram. Please note that <code>IEnumerable</code> and <code>IEnumerator</code> are part of the .NET framework and do not require actual implementation:</p>
<div><div><img alt="Figure 5.4 – Kitty’s implementation of the Iterator pattern. " height="1004" src="img/B18605_Figure_5.4.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Kitty’s implementation of the Iterator pattern.</p>
<p>Iterators always have the same parts. Our concrete collection is called <code>OrderCollection</code>, which ultimately implements the C# <code>IEnumerable</code> interface via an abstract class called <code>IteratorAggregate</code>. The concrete iterator is a class called <code>PaintJobIterator</code>, which inherits from an abstract base class that will implement the requirements of<a id="_idIndexMarker355"/> the interface. The <code>PaintJobIterator</code> class contains the logic that will sort the collection based on the type of paint job. The custom jobs will be done last so that we can get our standard order bicycles shipped right away. Our customers are okay with waiting an extra day for their custom paint jobs, so those are done last.</p>
<p>The <code>OrderCollection</code> and <code>PaintJobIterator</code> classes inherit from the <code>IteratorAggregate</code> and <code>Iterator</code> base classes, respectively. These classes are just abstract classes that implement the respective interfaces. They are useful if you intend to create more than one custom iterator within your project.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Coding the Iterator pattern</h2>
<p>We’ve seen the <a id="_idIndexMarker356"/>code for the <code>BicycleOrder</code> class already. This contains a reference to another class called <code>Customer</code>, which is pretty much what you’d expect. Kitty used the <code>MailAddress</code> class from <code>System.Net.Mail</code>. Everything else is just strings:</p>
<pre class="source-code">public class Customer
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string CompanyName { get; set; }
    public MailAddress Email { get; set; }
    public string ShippingAddress { get; set; }
    public string ShippingCity { get; set; }
    public string ShippingState { get; set; }
    public string ShippingZipCode { get; set; }
    
}</pre>
<p>Remember that the <code>IEnumerator</code> and <code>IEnumerable</code> interfaces are part of the .NET framework from <code>System.Collections</code>, so we don’t code those. However, Kitty did opt to make abstract classes for them. The first is in the <code>Iterator.cs</code> file:</p>
<pre class="source-code">public abstract class Iterator : IEnumerator
{
    object IEnumerator.Current =&gt; Current();
    public abstract int Key();
    public abstract bool MoveNext();
    public abstract void Reset();
    protected abstract object Current();
}</pre>
<p>This is just an abstract class that implements the <code>IEnumerator</code> interface. Kitty has another for the <code>IEnumerable</code> interface in the <code>IteratorAggregate.cs</code> file. One method is required to comply with that interface:</p>
<pre class="source-code">public abstract class IteratorAggregate : IEnumerable
{
    public abstract IEnumerator GetEnumerator();
}</pre>
<p>So far, this is just boilerplate<a id="_idIndexMarker357"/> code. Now, let’s move on to the good parts. The first part is the customized collection Kitty called <code>OrdersCollection</code>. This is just a wrapper around a <code>List&lt;BicycleOrder&gt;</code>:</p>
<pre class="source-code">public class OrdersCollection : IteratorAggregate
{
    public List&lt;BicycleOrder&gt; Orders { get; set; }</pre>
<p>A simple parameterless constructor ensures we start with an empty list:</p>
<pre class="source-code">    public OrdersCollection()
    {
        Orders = new List&lt;BicycleOrder&gt;();
    }</pre>
<p>Here, we have a simple pass-through to the <code>Add</code> method of <code>List</code>. Pop quiz: does this look like another pattern we’ve covered already? Maybe the Decorator pattern?</p>
<pre class="source-code">    public void AddOrder(BicycleOrder order)
    {
        Orders.Add(order);
    }</pre>
<p>Here’s the magical part. When we implement our collection, we need the <code>GetEnumerator</code> method to return our custom iterator, which we haven’t written yet. We are overriding the abstract method in the abstract <code>IteratorAggregate</code> class mentioned earlier and we are returning <code>PaintOrderIterator</code>, as shown here:</p>
<pre class="source-code">    public override IEnumerator GetEnumerator()
    {
        return new PaintOrderIterator(this);
    }
}</pre>
<p>Finally, we have the heart of this pattern – the actual iterator itself:</p>
<pre class="source-code">public class PaintOrderIterator : Iterator
{</pre>
<p>Most of the contents in this <a id="_idIndexMarker358"/>class are implementations of the requirements expressed in the <code>IEnumerator</code> interface, which we express in the abstract <code>Iterator</code> class we saw earlier. First, we can see a <code>private</code> field that holds a reference to the <code>OrdersCollection</code> class we just saw:</p>
<pre class="source-code">    private readonly OrdersCollection _orders;</pre>
<p>As the iterator moves through the collection, we need to track its position:</p>
<pre class="source-code">    private int _position;</pre>
<p>A constructor takes in <code>OrdersCollection</code> and sets the <code>private</code> field, as well as the initial position. The initial position starts at <code>-1</code> because we haven’t begun iterating yet and if we set it to <code>0</code>, we’d be indicating an actual position in the collection:</p>
<pre class="source-code">    public PaintOrderIterator(OrdersCollection orders)
    {
        _orders = SeparateCustomPaintJobOrders(orders);
        _position = -1;
    }</pre>
<p>We may need a way to get the private <code>_position</code> field. We’ll use a read-only <code>Key()</code> method for this:</p>
<pre class="source-code">    public override int Key()
    {
        return _position;
    }</pre>
<p>The iterator is invoked via a <code>foreach</code> loop, which invokes the <code>MoveNext()</code> method to move the iteration<a id="_idIndexMarker359"/> forward until it reaches the end of the collection:</p>
<pre class="source-code">    public override bool MoveNext()
    {
        var updatedPosition = _position + 1;
        if (updatedPosition &lt; 0 || updatedPosition &gt;= 
            _orders.Orders.Count) return false;
        _position = updatedPosition;
        return true;
    }</pre>
<p>The interface requires that have a way to reset the iterator position back to the beginning of the collection:</p>
<pre class="source-code">    public override void Reset()
    {
        _position = 0;
    }</pre>
<p><code>Current()</code> gives us the current iteration’s object in the collection. Don’t confuse this with the <code>Key()</code> method we saw a minute ago. <code>Key()</code> gives you the numeric index or the position, whereas <code>Current()</code> gives you the contents at the key’s position:</p>
<pre class="source-code">    protected override object Current()
    {
        return _orders.Orders[_position];
    }</pre>
<p>Here’s our customization. All we’re doing here is reordering the collection before the iteration takes place. Kitty <a id="_idIndexMarker360"/>made two lists. One will hold <code>BicycleOrder</code> objects, where the class in the <code>PaintJob</code> property is a standard paint job, while the other will hold the custom paint job orders. When we have separated them, it is simply a matter of recombining the list with the custom jobs at the end:</p>
<pre class="source-code">    private OrdersCollection SeparateCustomPaintJobOrders 
        (OrdersCollection orders)
    {
        var customPaintJobOrders = new List
            &lt;BicycleOrder&gt;();
        var standardPaintJobOrders = new List
            &lt;BicycleOrder&gt;();
        foreach (var order in orders.Orders)
        {
            var paintJob = order.Bicycle.PaintJob;</pre>
<p>If you remember when we built this during our coverage of the Bridge pattern, standard one-color paint jobs are expressed with the <code>IPaintJob</code> interface. Then again, so are custom paint jobs. Our custom paint job was defined in the <code>CustomGradientPaintJob</code> class, which is a different implementation of <code>IPaintJob</code>. Kitty used an abstract class in between the <code>IPaintJob</code> interface and the actual implementation. The intermediary class is called <code>CustomGradientPaintJob</code>, which means we can detect the base class of the paint job and act accordingly: </p>
<pre class="source-code">            bool isCustom = paintJob.GetType().IsSubclassOf
                (typeof(CustomGradientPaintJob));
            if(isCustom)
            {
                customPaintJobOrders.Add(order);
            }
            else
            {
                standardPaintJobOrders.Add(order);
            }
        }</pre>
<p>Now that we have a list of regular<a id="_idIndexMarker361"/> paint orders and a list of custom paint orders, we can replace the contents of the original <code>orders</code> list:</p>
<pre class="source-code">        orders.Orders.Clear();</pre>
<p>Then, we can add the standard orders back in:</p>
<pre class="source-code">        orders.Orders.AddRange(standardPaintJobOrders);</pre>
<p>This is followed by the custom paint orders:</p>
<pre class="source-code">        orders.Orders.AddRange(customPaintJobOrders);
        return orders;
    }
}</pre>
<p>Done! Now, all Kitty needs is a quick program to test with in <code>Program.cs</code>. When I say <em class="italic">quick</em>, it’s a few lines long because we need to create all the parts in the test program, including the customer, the bikes, the order list, and the custom iterator via a <code>foreach</code> loop. Remember that we’re pulling in some classes from different packages. The <code>Customer</code> class uses <code>System.Net.Mail</code>, which is part of the .NET framework. The bicycles are going to be from <code>BumbleBikesLibrary.PaintableBicycles</code>, while the paint jobs are going<a id="_idIndexMarker362"/> to be from <code>BumbleBikesLibrary.PaintableBicycle.CommonPaintJobs</code>:</p>
<pre class="source-code">using System.Net.Mail;
using BumbleBikesLibrary.PaintableBicycle;
using BumbleBikesLibrary.PaintableBicycle.CommonPaintJobs;
using IteratorExample;</pre>
<p>An iterator needs something to iterate, so let’s make our empty <code>OrdersCollection</code> class:</p>
<pre class="source-code">var orders = new OrdersCollection();</pre>
<p>Now, we need a customer. In real life, there would be several, but for our example, we’ll just use one:</p>
<pre class="source-code">var dealership = new Customer
{
    FirstName = "John",
    LastName = "Galt",
    CompanyName = "Atlas Cycling",
    Email = new MailAddress("johngalt@whois.com"),
    ShippingAddress = "123 Singleton Drive",
    ShippingCity = "Dallas",
    ShippingState = "Tx",
    ShippingZipCode = "75248"
};</pre>
<p>Now, we need bicycles to put in the orders. Let’s not waste time and make one with a custom paint job! This way, we know there’s one at the front of the list. When the iterator reorders the list, all these should be at the end:</p>
<pre class="source-code">var amarilloPeacockPaintjob = new 
     AmarilloPeacockPaintJob();
var bicycle0 = new PaintableMountainBike
    (amarilloPeacockPaintjob);</pre>
<p>Once you have a bicycle with a paint job and a customer, you can make an order and add it to the <code>orders</code> list:</p>
<pre class="source-code">var order0 = new BicycleOrder(dealership, bicycle0);
orders.AddOrder(order0);</pre>
<p>Next, let’s do the same thing with<a id="_idIndexMarker363"/> some standard paint jobs that will wind up at the front of the list when we iterate. First, let’s add a turquoise cruiser bike:</p>
<pre class="source-code">var turquoisePaintJob = new BluePaintJob();
var bicycle1 = new PaintableCruiser(turquoisePaintJob);
var order1 = new BicycleOrder(dealership, bicycle1);
orders.AddOrder(order1);</pre>
<p>How about a white road bike?</p>
<pre class="source-code">var whitePaintJob = new WhitePaintJob();
var bicycle2 = new PaintableRoadBike(whitePaintJob);
var order2 = new BicycleOrder(dealership, bicycle2);
orders.AddOrder(order2);</pre>
<p>To keep things interesting, let’s add another custom bike. This time, we’ll add a recumbent model with a custom gradient paint job:</p>
<pre class="source-code">var bicycle3 = new PaintableRecumbent
    (amarilloPeacockPaintjob);
var order3 = new BicycleOrder(dealership, bicycle3);
orders.AddOrder(order3);</pre>
<p>Here’s a standard red road bike:</p>
<pre class="source-code">var redPaintJob = new RedPaintJob();
var bicycle4 = new PaintableRoadBike(redPaintJob);
var order4 = new BicycleOrder(dealership, bicycle4);
orders.AddOrder(order4);</pre>
<p>That should be enough for a <a id="_idIndexMarker364"/>meaningful test. </p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Trying out the new iterator</h2>
<p>Now, let’s try out our iterator. If all goes <a id="_idIndexMarker365"/>well, this should look exactly like any of the iterations you see in C#:</p>
<pre class="source-code">foreach (BicycleOrder order in orders)
{
    Console.WriteLine(order.Bicycle.PaintJob.Name);
}</pre>
<p>The <code>foreach</code> loop is almost anti-climactic, isn’t it? That’s how we know we did a good job. You can’t tell that our custom iterator is any different from any of the common iterators that ship with C# or .NET. The regular <code>foreach</code> loop contains the mechanism to pull out our custom iterator and use it to move through the collection via the <code>MoveNext()</code> and <code>Current</code> methods we have in our concrete classes. When Kitty runs the test program, she can see what we’d hoped for:</p>
<div><div><img alt="Figure 5.5 – Kitty’s test run of her custom iterator. " height="353" src="img/B18605_Figure_5.5.jpg" width="1126"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Kitty’s test run of her custom iterator.</p>
<p>As Kitty learned, the Iterator pattern is one of the most important patterns in our daily work. It isn’t very complex, despite having a few different parts. You can use this pattern any time you need to process any kind of collection in a manner other than the standard FIFO processing order.</p>
<p>You should always be <a id="_idIndexMarker366"/>watching for chances to use this pattern. <em class="italic">Watching</em>… Hey, that reminds me of our next pattern!</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>The Observer pattern</h1>
<p>Our worst fear is becoming a reality. Bumble<a id="_idIndexMarker367"/> Bikes has become so popular that Kitty and Phoebe are starting to have logistics problems. <em class="italic">“Don’t get me wrong,”</em> Phoebe said. <em class="italic">“This is a good problem to have. We could be more profitable if we could optimize our shipping costs. The hardest part is the first mile. How can we be more efficient at getting our bikes to a national shipper’s depot?”</em> Kitty arranged a <strong class="bold">Zoom</strong> call with <em class="italic">ExFed</em>, a small business owner who provides packing and shipping support as a service. Cathy, the <em class="italic">ExFed</em> representative near Phoebe’s factory in Dallas, and John, the representative based in Alpine, where Kitty’s factory was located, listened carefully to Bumble Bikes’ predicament.</p>
<p><em class="italic">“The key to a good logistics workflow,”</em> Cathy said, <em class="italic">“is to make sure every time a truck leaves your factory, it’s full of bikes. When the truck comes back, it should be full of raw materials for the next batch of bikes.”</em> The girls had not considered the second part of what Cathy had explained. John concurred. The four worked out some details on the call after Phoebe had explained how her automated factory worked.</p>
<p><em class="italic">“You’ve already got a signal going to your raw materials supplier that tells them when you consume the materials to make a bike,”</em> John pointed out. Cathy picked up on his train of thought and completed it. <em class="italic">“Right – all we’d need to do is get a signal to our systems that lets us know when you have a truckload of bicycles for us to pick up. Our trucks can take the bicycles to the national shipper’s depot where they ship out like any other freight.”</em></p>
<p>Phoebe said, <em class="italic">“No problem! We’ll just add another decorator class to our bicycle object.”</em> John and Cathy stared blankly<a id="_idIndexMarker368"/> at their respective cameras. <em class="italic">“Phoebe! They don’t speak </em><em class="italic">nerd as we do!”</em> Kitty chided. <em class="italic">“Besides, that won’t work. The raw material usage is reported for every bicycle. We don’t want to send a pickup signal for every bicycle. That would be inefficient.”</em></p>
<p><em class="italic">“It would,”</em> John said. <em class="italic">“If you did that, you’d risk us leaving with a half-loaded truck. Based on the dimensions of your packaging, we need at least 10 bicycles in every load to make our service cost-effective.”</em></p>
<p><em class="italic">“What we need,”</em> Kitty began, <em class="italic">“is something that sends a signal when there are at least 10 bicycles ready to be picked up.”</em></p>
<p><em class="italic">“Right,”</em> said Cathy. <em class="italic">“You need to have someone at the end of the assembly line count the bicycles and when they get 10, click a button on our website. After that, it will take about 30 minutes to get the truck to your dock.”</em></p>
<p>Phoebe rolled her eyes imperceptibly. Her sister smirked. Think about all those <em class="italic">normal</em> people in the world who don’t speak nerd, and don’t understand software automation. What difficult and unfulfilled lives they must lead! Phoebe and Kitty knew they were going to find a way to automate their supply requests.</p>
<p><em class="italic">“But during that delay,”</em> continued Phoebe, <em class="italic">“we’ve probably made another 5 to 10 bicycles. Is that a problem?”</em></p>
<p><em class="italic">“No,”</em> said John. <em class="italic">“We need just a minimum of 10.”</em></p>
<p>John and Cathy dropped off the call with a list of to-dos and a virtual handshake deal to handle Bumble Bikes’ first-mile logistics. Kitty and Phoebe stayed on Zoom and continued brainstorming. <em class="italic">“Cathy said we needed someone to count bicycles as they come off the assembly line. I don’t want to pay someone to just sit around and observe.”</em></p>
<p><em class="italic">“That’s it! Kitty, you’re a genius!”</em> Phoebe exclaimed. Kitty beamed quizzically. She wasn’t sure what she’d done to merit this rare moment of sisterly praise.</p>
<p>Phoebe realized this situation was calling for the <strong class="bold">Observer pattern</strong>. Cathy had envisioned a person observing the process and reacting when the bicycle count reached a minimum of 10 bicycles. To automate this, the girls will have to write software that can <em class="italic">observe</em> the production process<a id="_idIndexMarker369"/> and generate a signal to the logistics company when the requisite bicycle inventory has been reached. A generic diagram of the Observer pattern is as follows:</p>
<div><div><img alt="Figure 5.6 – The Observer pattern " height="911" src="img/B18605_Figure_5.6.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The Observer pattern</p>
<p>There are two basic parts to the Observer pattern – a <strong class="bold">subject</strong> and one or more <strong class="bold">observers</strong>. Let’s review the different parts of the pattern, which have been numbered appropriately:</p>
<ol>
<li value="1">An interface describes the method requirement of the observer. This interface defines a public <code>Update()</code> method. <code>Update()</code> is called whenever the observer “sees” something interesting happen in the object it is observing.</li>
<li>Our concrete observer contains the implementation logic for the behavior that happens when the observer “sees” some interesting change in the subject’s state.</li>
<li>The subject is doing some useful piece of work and maintains its state while the observer waits. Note that the observers are contained inside a collection within the subject. Also, note that<a id="_idIndexMarker370"/> the <code>state</code> property is <code>private</code>. We’ll need some way to let the observers know something interesting happened. For this, we have a function called <code>Notify()</code>. When a triggering condition takes place, the <code>Notify()</code> method can iterate over each attached observer and call its <code>Update()</code> method.</li>
<li>The whole process is invoked by some larger program we’ll call <em class="italic">the client</em>.</li>
</ol>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Applying the Observer pattern</h2>
<p>Kitty brings up Zoom’s whiteboard <a id="_idIndexMarker371"/>and they collaborate on their implementation of the Observer pattern that will solve this problem, as shown in the following diagram:</p>
<div><div><img alt="Figure 5.7 – Phoebe and Kitty’s implementation of the Observer pattern that can signal ExFed’s trucks to pick up an order of bicycles. " height="622" src="img/B18605_Figure_5.7.jpg" width="898"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Phoebe and Kitty’s implementation of the Observer pattern that can signal ExFed’s trucks to pick up an order of bicycles.</p>
<p>This one is pretty simple – we need a subject and an observer. The girls used an interface, <code>ILogisticsObserver</code>, to prevent tight coupling between the <code>LogisticsSubject</code> class and the concrete observer class called <code>ExFedObserver</code>. </p>
<p>Once they had drawn the diagram, they each opened their favorite IDE, which contains a collaborative coding feature. This <a id="_idIndexMarker372"/>means the girls can code together as though they were sitting next to each other.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Coding the Observer pattern</h2>
<p>Phoebe makes short<a id="_idIndexMarker373"/> work of the <code>ILogisticsObserver</code> interface:</p>
<pre class="source-code">public interface ILogisticsObserver
{
    public void SchedulePickup();
}</pre>
<p>Kitty follows up with a concrete observer that consumes Phoebe’s interface:</p>
<pre class="source-code">public class ExFedObserver : ILogisticsObserver
{
    public void SchedulePickup()
    {
        Console.WriteLine("ExFed has been notified that a 
            shipment is ready for pick up.");
    }
}</pre>
<p>I left out the actual API call because Kitty and Phoebe were worried that I might accidentally reveal their API key. As we all know, only amateurs check API keys into GitHub, and the code won’t work without it, so I put it in a <code>Console.WriteLine</code> statement as a substitute.</p>
<p>The <code>LogisticsSubject</code> class is where the real action lies. It’s a little longer, so the girls work on it together:</p>
<pre class="source-code">public class LogisticsSubject
{</pre>
<p>Kitty adds a <code>List&lt;ILogisticsObserver&gt;</code> field to hold all the observers. She follows that with a typical<a id="_idIndexMarker374"/> constructor, which initializes the field:</p>
<pre class="source-code">    private readonly List&lt;ILogisticsObserver&gt; 
        _logisticsObservers;
    public LogisticsSubject()
    {
        _logisticsObservers = new 
            List&lt;ILogisticsObserver&gt;();
    }</pre>
<p>Phoebe adds an <code>Attach</code> method that allows us to add one or more observers, which are objects that conform to the <code>ILogisticObserver</code> interface:</p>
<pre class="source-code">    public void Attach(ILogisticsObserver observer)
    {
        _logisticsObservers.Add(observer);
        PrintObserversCount();
    }</pre>
<p>Likewise, she also adds a method that can remove the observer from the list:</p>
<pre class="source-code">    public void Detach(ILogisticsObserver observer)
    {
        _logisticsObservers.Remove(observer);
        PrintObserversCount();
    }</pre>
<p>Kitty realizes their testing will be easier if they have a way to see the observers in the list, so she adds a quick method to <a id="_idIndexMarker375"/>provide some output for the initial runs. The method simply prints the number of observers stored within the private <code>_logisticsObservers</code> field:</p>
<pre class="source-code">    private void PrintObserversCount()
    {
        switch (_logisticsObservers.Count)
        {
            case &lt; 1:
                Console.WriteLine("There are no 
                    observers.");
                break;
            case 1:
                Console.WriteLine("There is 1 observer");
                break;
            default:
                Console.WriteLine("There are " + 
                    _logisticsObservers.Count + " 
                        observers.");
                break;
        }
    }</pre>
<p>Lastly, we need to notify our observers. The generic UML diagram specified a <code>Notify()</code> method. We called ours <code>NotifyPickupAvailable()</code>. It simply iterates through the observers and calls the <code>SchedulePickup()</code> method on each one in the list:</p>
<pre class="source-code">    public void NotifyPickupAvailable()
    {
        foreach (var observer in _logisticsObservers)
        {
            observer.SchedulePickup();
        }
    }
}</pre>
<p>Following her sister’s lead, Phoebe writes <a id="_idIndexMarker376"/>the test program in <code>Program.cs</code>. First, she creates an instance of <code>LogisticsSubject</code>:</p>
<pre class="source-code">var logisticsSubject = new LogisticsSubject();</pre>
<p>Then, she makes the observer and attaches it to the subject:</p>
<pre class="source-code">var exFed = new ExFedObserver();
logisticsObserver.Attach(exFed);</pre>
<p>Next, let’s simulate making 100 bikes. Each time we have 10, we’ll send a notification:</p>
<pre class="source-code">var pickupOrder = new List&lt;Bicycle&gt;();
for (var i = 0; i &lt; 99; i++)
{
    var bike = new MountainBike();</pre>
<p>Here, Phoebe is just simulating a passage of time in an attempt to keep it a real simulation. She wishes her robots could build a bike in 3 seconds. After the delay, she writes out the bike with the <code>ToString</code> method and adds the bike to the <code>pickupOrder</code> list:</p>
<pre class="source-code">    Thread.Sleep(3000);
    Console.WriteLine(bike.ToString());
    pickupOrder.Add(bike);</pre>
<p>Our observer logic checks whether we have enough bikes. If so, it triggers the <code>NotifyPickupAvailable()</code> method, which loops through all the observers and calls their <code>SchedulePickup()</code> methods:</p>
<pre class="source-code">    if (pickupOrder.Count &gt; 9)
    {
        logisticsSubject.NotifyPickupAvailable();</pre>
<p>In the real world, 30 minutes would pass before a truck arrived at Bumble Bikes to take their inventory. However, no one wants to simulate that, so we’ll simply pretend we did and clear out the order:</p>
<pre class="source-code">        pickupOrder.Clear();
    }
}</pre>
<p>When we are done making<a id="_idIndexMarker377"/> bikes for the day, we can detach. Phoebe understands the importance of work-life balance for her factory robots:</p>
<pre class="source-code">logisticsSubject.Detach(exFed);</pre>
<p>As the girls’ software operation saw more and more patterns in use, the number of problems left to solve was dwindling rapidly. They were moving into the phase you’ll see in every software project, where the work shifts from developing new code to maintaining it. Usually, about this time, the senior developers start to get bored because all the big problems have been solved. Those developers must now make a choice: stick with the project or find another project with new challenges. That’s what happens in most software shops. Surely Phoebe, being the brilliant owner of a bicycle manufacturing startup, would never succumb to the temptations fostered by monotony?</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>The Strategy pattern</h1>
<p><em class="italic">“I’m BORED!”</em> Phoebe yelled across the<a id="_idIndexMarker378"/> room at her sister. Kitty had come up from Alpine to go over some spreadsheets with Lexi, the head of accounting for Bumble Bikes. Phoebe and Lexi had been friends for many years, so when Phoebe had the chance to recruit her, she took it. Lexi, who was used to Phoebe’s peculiarities, smiled at Kitty, folded her laptop, and said, <em class="italic">“I’ll have this done for you tomorrow.” </em></p>
<p>As Lexi left the office, Phoebe flopped upside down on the couch, flipping through channels on the TV with the sound off. She wound up on channel 52,381, which was <em class="italic">The Bike Channel</em>. Bumble Bikes advertised heavily on this channel, and at that moment, a talking head was reviewing bike computers. A <strong class="bold">bike computer</strong> is an electronic device that reports your speed and distance traveled. Fancy models can keep track of your cadence, which is the pace at which you pedal. Some even track your heart rate and the electrical wattage <a id="_idIndexMarker379"/>produced by the effort a rider imposes on the pedals.</p>
<p>Phoebe’s face was starting to turn red. She had been upside down too long and blood had rushed to her head. She flopped the rest of the way over and revealed that look she got when she had a million-dollar idea.</p>
<p>Her sister could see it without even looking at her. <em class="italic">“What?”</em> Kitty asked.</p>
<p>Phoebe stared at the ceiling a little longer, her eyes flitting back and forth. She was inventing something in her mind. Kitty looked up and could see the wheels turning in Phoebe’s head.</p>
<p><em class="italic">“Bike computers!”</em> Phoebe yelled at last. <em class="italic">“Why are they so boring? I mean really! All they do is tell jocks how great they are. Who needs a computer for that?”</em> It was an odd statement, but coming from Phoebe, it rated at most a 4 on a scale from 1 being something such as a pizza order to 10, which might be a non-sequitur completion of an engineering problem she’d given up on privately a week prior.</p>
<p><em class="italic">“What if a bike computer did something cool, like what we have with our car computers? Sure, it would be track speed, distance, wattage, and whatever jocks pay for in a bike computer. but It would also have navigation routes, trail, and road conditions. This is information a rider would want to know and have so that they can complete their next epic ride,”</em> Phoebe blurted. This was usually the part where Phoebe ran to her lab and ordered a stack of pizzas and fizzy water. Then, she would disappear for a few days. The sister’s recent success gave the girls the ability to move their labs to their respective factories. Phoebe’s lab had a bathroom and a bed that stretched between the far wall and what looked like a <em class="italic">Van de Graaff</em> generator. <em class="italic">“Why does she need that?”</em> Kitty thought silently. She’d long since given up asking out loud. The bed, covered in pizza boxes from previous engineering adventures, appeared to have never been slept in.</p>
<p>Kitty didn’t respond to her sister’s question concerning the use of a bike computer. She knew it was a question that wasn’t meant to be answered. When Kitty came in the next morning, she noticed a stack of discarded pizza boxes and empty cans of fizzy water littered throughout the office. A small black box was mounted to a handlebar assembly on Phoebe’s workbench. Phoebe was asleep in her lab.</p>
<p>Curious, Kitty fiddled with the buttons on the box’s apparent interface. Phoebe had made a small computer with some sensors attached. Kitty was able to find the navigation feature that had <a id="_idIndexMarker380"/>captured Phoebe’s imagination. It was crudely designed, but functional. <em class="italic">“Hey, sis,”</em> Phoebe muttered sleepily. <em class="italic">“It’s not working yet. I’m stuck on the navigation.”</em> Phoebe’s head flopped back down on the pillow. Kitty continued fiddling with the navigation. She saw the problem: the UI on the navigation allowed you to pick from several kinds of terrains. You could search for routes on paved roads, gravel trails, or mountain trails. However, the search results consistently showed only paved roads. It was easy to figure out why.</p>
<p>Phoebe was leveraging well-known GPS APIs to compute her route. Naturally, these were favoring paved roads. Phoebe was able to create a façade for the API and a decorator that slightly altered the default behavior so that the API stayed away from recommending busy highways, even when they were the most direct route.</p>
<p>For the next few hours, Kitty researched alternative mapping APIs that would focus more on the roads less traveled and gave preference to those inaccessible to cars. She found that each time she added different APIs and pathfinding algorithms, her code started to become complex. She could easily see the beginnings of a big ball of mud on her growing plate of spaghetti.</p>
<p>After some refactoring and some thinking, she settled upon a strategy that should work. Spoiler alert: <em class="italic">strategy</em> is the name of the pattern she used. This pattern is easy to explain because the pattern means the same thing as the word <em class="italic">pattern</em> means in plain English. If you’re trying to achieve a complicated objective, you create a strategy. In software engineering, the Strategy pattern refers to working with a set of algorithms flexibly and interchangeably. An <em class="italic">algorithm</em> is simply a set of steps you can follow to solve a problem that gives a consistent result within a reasonable amount of time. If you were to create an algorithm to create a peanut butter and jelly sandwich, the steps would be simple:</p>
<ol>
<li value="1">Put two slices of bread on a plate.</li>
<li>Open the peanut butter.</li>
<li>Using a dull knife, spread peanut butter on one side of one slice of bread.</li>
<li>Close the peanut butter jar.</li>
<li>Open the jelly.</li>
<li>Using a different dull knife (don’t you hate it when someone uses the same knife and gets peanut butter in your jelly?), spread some jelly on one side of the second slide of bread.</li>
<li>Close the jelly jar.</li>
<li>Place the first slice of bread on top of the second so that the peanut butter and jelly meet between the slices of bread.</li>
</ol>
<p>That’s an algorithm. If you<a id="_idIndexMarker381"/> follow that algorithm, I can guarantee that you’ll always wind up with a peanut butter and jelly sandwich. This algorithm can be completed in a few minutes, which to me, is a reasonable amount of time. I could easily make a second algorithm to make a turkey sandwich, and another to make a cheese sandwich. If I encapsulate each algorithm using a common interface, I can choose a sandwich-making strategy based on what kind of sandwich I desire.</p>
<p>Kitty has a situation where she needs an algorithm to get from point A to point B. She needs three different strategies, which are coded as three different algorithms. The first algorithm will find a path strictly on paved roads. The second will try to make use of gravel or unpaved roads. The third will find a path with no roads at all, but that is otherwise passable on a bicycle. She needs these routes from A to B to follow a common interface, and she needs the algorithms themselves to follow a common interface so that she can swap them as appropriate.</p>
<p>We can express this with UML, as shown in the following diagram:</p>
<div><div><img alt="Figure 5.8 – The Strategy pattern. " height="805" src="img/B18605_Figure_5.8_New.jpg" width="1644"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The Strategy pattern.</p>
<p>Let’s review the different parts <a id="_idIndexMarker382"/>of the pattern, which have been numbered appropriately:</p>
<ol>
<li value="1">The <code>IStrategy</code> interface defines a method that implements your algorithm. In our case, it will be called <code>Run</code>, and we can pass in any data the algorithm may need, such as the geospatial coordinates of your starting and ending locations.</li>
<li>A concrete strategy object that implements the <code>IStrategy</code> interface will implement your algorithm.</li>
<li>A context object holds the strategy and can execute it with some method. We have called ours <code>DoBehavior()</code>.</li>
</ol>
<p>The key here is that all the algorithms follow the <code>IStrategy</code> interface. This means I can pass any algorithm contained in a concrete strategy object containing a <code>Run</code> method to invoke the algorithm. At this point, the algorithms are interchangeable.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Applying the Strategy pattern</h2>
<p>Kitty comes up with a<a id="_idIndexMarker383"/> diagram for her implementation, as shown here:</p>
<div><div><img alt="Figure 5.9 – Kitty’s drawing of their implementation of the Strategy pattern. " height="1046" src="img/B18605_Figure_5.9.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Kitty’s drawing of their implementation of the Strategy pattern.</p>
<p>Kitty looked over at Phoebe who was in a deep sleep. Maybe with the Strategy pattern, she could fix up this software before she wakes up. </p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Coding the Strategy pattern</h2>
<p>Phoebe already had the data structures at the bottom of the diagram. She had typed <code>INavigationRoute</code>:</p>
<pre class="source-code">public interface INavigationRoute
{
    public string RouteDetails { get; set; }
}</pre>
<p>She also had a concrete <code>NavigationRoute</code> class. Unfortunately, Karina, the attorney representing Bumble Bikes, will not <a id="_idIndexMarker384"/>allow me to show this part of the code. That’s okay. We’re here for the pattern. Neither the interface nor the class is part of the pattern. They’re just structures used in the implementation. In place of Kitty’s highly proprietary data structure, I’ll give you a simple string:</p>
<pre class="source-code">public class NavigationRoute : INavigationRoute
{
    public string RouteDetails { get; set; }
}</pre>
<p>Let’s move on to the code that is part of the strategy. We’ll start with the <code>INavigationStrategy</code> interface. This interface is used to conform your algorithms to a common structure so that they can become interchangeable:</p>
<pre class="source-code">public interface InavigationStrategy
{
    public InavigationRoute FindRoute(string parameters);
}</pre>
<p>As mentioned previously, Kitty needs three concrete implementations. The first is for finding routes on paved roads. Phoebe had this one working, so Kitty simply refactored it to fit the interface:</p>
<pre class="source-code">public class RoadNavigationStrategy : INavigationStrategy
{
    public INavigationRoute FindRoute(string parameters)
    {
        // This is where your amazing algorithm goes.  But 
        // since this is a book on patterns and not 
        // algorithms...
        return new NavigationRoute
        {
            RouteDetails = "I'm a road route."
        };
    }
}</pre>
<p>Then, Kitty created an algorithm to<a id="_idIndexMarker385"/> find gravel road routes:</p>
<pre class="source-code">public class GravelNavigationStrategy : INavigationStrategy
{
    public INavigationRoute FindRoute(string parameters)
    {
        // This is where your amazing algorithm goes.  But 
        // since this is a book on patterns and not 
        // algorithms...
        return new NavigationRoute
        {
            RouteDetails = "I'm a gravel route."
        };
    }
}</pre>
<p>At this point, I predict you will not be surprised by the third implementation:</p>
<pre class="source-code">public class MountainNavigationStrategy : 
    INavigationStrategy
{
    public INavigationRoute FindRoute(string parameters)
    {
        // This is where your amazing algorithm goes.  But 
        // since this is a book on patterns and not 
        // algorithms...
        return new NavigationRoute
        {
            RouteDetails = "I'm a mountain route."
        };
    }
    
}</pre>
<p>The only thing left is<a id="_idIndexMarker386"/> the <code>NavigationContext</code> class:</p>
<pre class="source-code">public class NavigationContext
{</pre>
<p>Kitty used a simple property to hold her navigation strategy. Naturally, she declared the interface, not a concrete object:</p>
<pre class="source-code">    public INavigationStrategy NavigationStrategy { get; 
        set; }</pre>
<p>Next is a standard constructor. She set the default to a road navigation strategy since that is the default for Phoebe’s device:</p>
<pre class="source-code">    public NavigationContext()
    {
        NavigationStrategy = new RoadNavigationStrategy();
    }</pre>
<p>Finally, we have a method to<a id="_idIndexMarker387"/> start the algorithms on finding the path we’re looking for based on the current strategy in the <code>NavigationStrategy</code> property:</p>
<pre class="source-code">    public void StartNavigation()
    {</pre>
<p>There was a lot of cool business logic here. Eventually, Kitty generates the route using the strategy:</p>
<pre class="source-code">        var route = NavigationStrategy.FindRoute
            ("parameters go here");
        Console.WriteLine(route.RouteDetails);
    }
}</pre>
<p>Honestly, this is the most innovative set of algorithms I have ever seen. Too bad the lawyers got involved. However, we did get to see the pattern, which turned out to be very simple compared to some of the more complicated patterns we’ve seen.</p>
<p>The Strategy pattern is used when you need to be able to choose from a set of related algorithms all aimed at a common objective. Whether it’s making sandwiches or devising a novel set of interchangeable geospatial pathfinding algorithms, using a Strategy pattern will help keep your code maintainable and easy to read. Kitty can easily add more algorithms as she thinks of them, without breaking any of the existing strategies.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Summary</h1>
<p>Behavioral patterns work with algorithms in ways that keep your software manageable. In this chapter, we looked at four very useful and popular patterns that can be employed to solve a variety of design problems.</p>
<p>The Command pattern can be used to isolate instructions from the objects responsible for executing them. This is one of the most common causes of the antipatterns we discussed in <a href="B18605_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">There’s a Big Ball of Mud on Your Plate of Spaghetti</em>. Tightly coupling logic with concrete structures yields software that is brittle and prone to grow in complexity. The Command pattern will help you avoid this trap.</p>
<p>The Iterator pattern is used any time you need to iterate over a collection in some manner not handled by the standard .NET iterator. This pattern works with a collection and starts with the first item before iterating in a straight line to the last. This can take the form of manipulating the collection before processing, or it might be a novel way of moving through the collection to meet a business requirement. Some of the basic building blocks for this pattern are built into the .NET framework within the <code>System.Collections</code> namespace. Before building an iterator, you should check if one already exists.</p>
<p>The Observer pattern consists of a subject and one or more observers. The subject notifies the observers of a particular trigger condition within the subject’s state. The Observer pattern is widely used with a myriad of applications. Many software developers who have used event listeners have seen and understand the power of this technique. </p>
<p>The last pattern we discovered was the Strategy pattern. We use the Strategy pattern any time we have a set of algorithms with a common purpose. The Strategy pattern works by conforming the algorithms to a common interface that is injected into a context. Then, the algorithms can be used interchangeably as business needs require.</p>
<p>In the next chapter, a fateful turn of events will force Kitty and Phoebe to enlist the help of a stranger. Bumble Bikes began as a passion project and turned into a business venture, but it will quickly become a humanitarian outreach. Too few software developers, engineers, and architects understand they have a superpower that can change the world. The stakes are high, and Kitty and Phoebe are stretched too thin. They need someone who understands SOLID principles and patterns to head up a very important project. Will this understated stranger be up to the task? Would you be?</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">Which pattern is used to make algorithms with a common purpose interchangeable within a context?</li>
<li>Which pattern is used to encapsulate and send instructions to a receiver, while avoiding tight coupling between the data needed to execute the instruction and the logic that executes the instruction?</li>
<li>Which pattern involves a <em class="italic">subject</em> and an <em class="italic">observer</em>? Please note that if you miss this question, it will go on your permanent record.</li>
<li>Which pattern is used to process collections in a way other than FIFO?</li>
<li>What two interfaces from the .NET framework are useful when implementing the Iterator pattern?</li>
</ol>
</div>
<div><div><img alt="" height="1001" src="img/part-3-version-2.jpg" width="1239"/>
</div>
</div>
</div>


<div><div><h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Part 3: Designing New Projects Using Patterns</h1>
<p>Having learned about some patterns, let’s take a look at the design process. So far, we’ve been making things up as we go along. How much easier would things be, and how many problems could we avoid, if we took a step back first and designed our project with patterns and UML instead of diving into the code? This section works through a new project from this perspective. We will design the new project purely as a set of diagrams first in <a href="B18605_06.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>, <em class="italic">Step Away from the IDE! Designing with Patterns Before you Code</em>. Then, we will implement the project in <a href="B18605_07.xhtml#_idTextAnchor136"><em class="italic">Chapter 7</em></a>,  <em class="italic">Nothing Left but the Typing: Implementing the Wheelchair Project</em>. The final chapter wraps up the book and aims to show you there are more patterns out there. In fact, they’re everywhere!  There are development patterns beyond the usual Gang of Four sets and even more beyond the realm of <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>). You’ll even learn the documentation process for creating and publishing your very own patterns! I’ve included an appendix at the end to review the basic concepts in case you’re new to C#, OOP, or UML.</p>
<p>This part covers the following chapters:</p>
<ul>
<li><a href="B18605_06.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>, <em class="italic">Step Away from the IDE! Designing with Patterns Before You Code</em></li>
<li><a href="B18605_07.xhtml#_idTextAnchor136"><em class="italic">Chapter 7</em></a>, <em class="italic">Nothing Left but the Typing: Implementing the Wheelchair Project</em></li>
<li><a href="B18605_08.xhtml#_idTextAnchor152"><em class="italic">Chapter 8</em></a>, <em class="italic">Now You Know Some Patterns. What Next?</em></li>
<li><a href="B18605_Appendix_1.xhtml#_idTextAnchor178"><em class="italic">Appendix 1</em></a>, <em class="italic">A Brief Review of OOP Principles in C#</em></li>
<li><a href="B18605_Appendix_2.xhtml#_idTextAnchor204"><em class="italic">Appendix 2</em></a>, <em class="italic">A Primer on the Unified Modeling Language</em></li>
</ul>
</div>
</div>
</body></html>