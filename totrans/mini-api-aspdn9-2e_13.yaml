- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices for Minimal API Resiliency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any software system, minimal APIs can be built in many ways. By carefully
    choosing and applying different patterns and following some set practices, an
    application can be greatly enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: There are several good reasons to build patterns into the design of your minimal
    API, the first being readability. Since most of us are part of a team and may
    have other developers to delegate or hand over code, making it as accessible as
    possible is paramount. By ensuring that your endpoints are tidy, that code is
    as *self-documenting* as possible, and that the naming conventions are consistent,
    it will be relatively straightforward for another developer to support the maintenance
    of an API project.
  prefs: []
  type: TYPE_NORMAL
- en: Next is scalability. If the volume of requests grows, so will the need to optimize
    an application. Consistency and good design make meeting demands simple. Whether
    adding a load balancer to manage traffic flow or changing the data storage method,
    it is essential to design APIs in such a way that modifications to the system—whether
    adding or removing components—do not break functionality across the application.away
    parts of the system does not break functionality across the application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, security is equally important. By following best security practices
    such as encryption at rest and in transit, password hashing and salting, and scoped
    access, sensitive data can be managed securely, reducing the risk of a breach
    and the ensuing legal challenges that present themselves as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, achieving these goals depends on applying practices that concern
    the way a code base is structured for readability, the way unexpected and fatal
    scenarios are dealt with in error handling, and the considerations applied from
    a cybersecurity perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s realize some of these benefits in your minimal API projects by exploring
    some design practices and coding conventions that can improve the quality of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics :'
  prefs: []
  type: TYPE_NORMAL
- en: Code organization and structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get into it!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 or the latest version of Visual Studio code is recommended
    to run the code from this chapter. The code examples for this chapter are available
    in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: One of the examples uses code from *Chapters 9* and *12* , both of which have
    a dependency on Entity Framework Core. It is recommended that you complete those
    chapters before this one.
  prefs: []
  type: TYPE_NORMAL
- en: Code organization and structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most important thing to understand about organizing and structuring
    code in any system is that there is no one correct way to do it. While there are
    some widely accepted structural patterns, this can be quite a personal topic,
    as a structure must serve the maintainer. However, as we have previously confirmed,
    most minimal API systems in a commercial or open-source setting will have multiple
    maintainers, so a consistent structure will make it as easy as possible for developers
    to collaborate on the code base.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore two examples of ways that a project can be organized, both sharing
    one key theme – modularity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** is the practice of organizing and structuring your code into
    smaller, self-contained, and reusable units or modules. Let’s break down some
    of the benefits of this practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns** : By grouping together code containing similar functionality,
    we create contexts within the code base that mirror the business domains they
    serve. For example, code that is solely based on the context of managing users
    is separate from code that is solely based on managing products. Establishing
    clear boundaries between these contexts ensures that dependencies are minimized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability** : Adopting a modular design allows you to create components
    such as the ones we explored in this book – for example, services and middleware.
    In a system where separation of concerns is the aim, having reusable components
    can help bridge contexts as necessary in a way that reduces the creation of dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of maintenance** : Modules can be developed and tested independently
    of each other, making parallel development between multiple developers easier.
    Modularization also supports the open-closed principle, which states, “ *Software
    entities (classes, modules, functions, etc.) should be open for extension, but
    closed* *for modification.* ”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that, in an ideal world, whenever we want to extend our minimal API
    with new functionality, we *do* not need to change the existing code base to enable
    the change.
  prefs: []
  type: TYPE_NORMAL
- en: Effective organization of code is often dominated by architectural design patterns.
    While this is certainly important, simply reorganizing the folder structure of
    a project goes a long way to making code readable and simpler to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore some example folder structures.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring folder structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, simple consideration of the way a project’s folders are arranged
    within a project can significantly improve the readability and maintainability
    of a minimal API. We’re looking for a consistent system to lay out classes and
    interfaces. Let’s look at some specific folder structures that we can apply to
    our projects to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Feature-based modular structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this structure, the minimal API project is organized by features, with each
    feature having its own folder, containing everything related to that feature,
    regardless of what kind of component is used. Here’s an example of such a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this structure, the developer is expected to adopt a feature-based mindset.
    For example, if you want to add an endpoint relating to user management, you would
    head to a folder based on users rather than one dedicated to endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, folder structures can be a personal and
    somewhat polarizing topic. Some may not prefer to mix component types under the
    banner of a feature set, while others enjoy the domain-based nature of this structure
    and are less concerned with what kind of component acts within each domain.
  prefs: []
  type: TYPE_NORMAL
- en: Layered modular structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This structure is the one I prefer personally because I tend to think about
    the type of component before I think about the feature or business domain. In
    a layered modular structure, the project is first grouped by components (e.g.,
    endpoints and services) and then further broken down into business modules/features.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are like me and tend to think about the kind of class or file that I
    am looking to create or edit before I think about the domain in which it lives,
    this folder structure will work better for you. However, it’s important to note
    that while this kind of structure prioritizes component types when creating folders,
    there is still a dedicated **Domain** folder that exists to hold entity models
    and **Data Transfer Objects** ( **DTO** s), which describe the business domain.
    Here is an example of a layered modular file structure in a minimal API project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve explored some simple examples of how folders can be structured
    within a minimal API project, let’s look at some repeatable patterns that can
    be adopted when structuring a project’s code. These patterns are referred to as
    *design patterns* , and like folder structure, there is debate around which patterns
    constitute best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is not designed to tell you which patterns are the best; rather, it
    is designed to give you some guidance on how you can structure your code consistently
    to create a consistent API system. Here are some example patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **factory pattern** is designed to create objects without specifying the exact
    class of object that will be created. Earlier, I mentioned the open/closed principle,
    and factory patterns help minimal APIs adhere to this principle by closing the
    code for modification while making it open for extension.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example use case in which you want to create logs in different
    locations. One location is via a database, and another is in a text file.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, you may want to add more log sources, such as a Webhook or third-party
    API. A factory could help you retrieve the correct logger for your use case while
    making it simple to add new loggers without changing the old ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how we can improve logging by implementing a factory
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an interface called **ILogger** , which will be implemented by
    all loggers, regardless of the specific log they execute when saving a log to
    their respective source. **ILogger** is an interface that will represent an object
    that implements logic for the purposes of writing logs to different sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create two classes that each implement **ILogger** . One of the classes,
    **FileLogger** , will be used to log to a file, and another, **DatabaseLogger**
    , will log to a database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These classes may have different names, but they are both an **ILogger** object
    meaning that they must implement the **Log()** method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Furthermore, we can create a function that returns **ILogger** , as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we created a **LoggerFactory** class with a function that returns
    the relevant logger class, depending on the contents of a string that was entered
    by the caller. If the **loggerType** parameter is not valid, an exception is thrown,
    allowing the error to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit to this is that to add another logger, we simply create a new
    class that implements **ILogger** before adding a new entry to the **switch**
    statement in **CreateLogger()** . We haven’t had to introduce any breaking changes
    to extend the types of loggers that are supported in the API.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern creates an abstraction layer for data access logic, providing a
    more general API to access data from a database for the minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the book, we explored Entity Framework Core to access data from a
    database. Simply by using Entity Framework Core, your code already uses a repository
    pattern because it provides an implementation of the repository pattern that utilizes
    the built-in **DBContext** .
  prefs: []
  type: TYPE_NORMAL
- en: However, it is still worth implementing a custom repository pattern to handle
    data so that you further generalize the solution, meaning that Entity Framework
    Core could be swapped out of the minimal API application without affecting the
    overall data access logic.
  prefs: []
  type: TYPE_NORMAL
- en: To create a repository pattern on top of Entity Framework Core, we can simply
    create a class for each entity in the database. Each repository class receives
    the Entity Framework context via dependency injection, and then the generic **Create,
    Read, Update, Delete** ( **CRUD** ) operations for this entity can be added. Following
    this, each repository can be also registered for dependency injection for use
    elsewhere in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, **EmployeeRepository** reflects the available data
    operations available for an employee entity. As described, the Entity Framework
    context is injected as the data access layer to be used within the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Going forward, if a decision is made to replace Entity Framework Core, the only
    thing that needs to change is the repository. The consumers of the repository
    would not be affected because the methods and functions they call within the repository
    would maintain their original signatures, despite their underlying logic changing.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Strategy pattern** allows us to define a family of algorithms, each one
    represented by a class. This pattern is very powerful in situations where there
    are multiple ways of executing an operation, as you can seamlessly switch between
    them in a dynamic fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example involving a minimal API endpoint that calculates how
    much annual leave an employee has. In this example, there are different ways to
    calculate leave based on various factors, such as which country the employee is
    in, whether they are in their probationary period, and how many years they have
    served at the company.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example outline of the logic to calculate leave (not related to
    any specific labor laws in any country!):'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the employee is in their probationary period, the following applies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum amount of leave awarded is 10 days
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the employee is based in the United Kingdom, they get an extra three days
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the employee is not on probation, the following applies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum amount of leave awarded is 16 days
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the employee is based in the United Kingdom, they get an extra three days
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For each year of service, an extra day is awarded
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of factors in play here, but to start with, we can narrow down
    the operations required to calculate leave based on whether the employee is or
    is not on probation. This means we have two strategies to calculate leave, which
    we can switch to automatically. How do we achieve this?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create an interface to represent a strategy. It stipulates that we
    require a **CalculateLeaveAllowance()** function taking a parameter of type **Employee**
    and returning an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll create **ProbationaryAnnualLeaveStrategy** , which implements the
    interface. Within this class, **CalculateLeaveAllowance** will encapsulate the
    logic to calculate the total leave available for a probationary employee:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, the same can be done for an employee who is not on probation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The two strategies should be registered for dependency injection in **Program.cs**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, an endpoint can be created to calculate the annual leave for a given
    **Employee** ID. Within the endpoint, we create the strategy based on whether
    or not the employee is on probation. We then retrieve **Employee** using the ID
    sent by the client and call the **CalculateLeaveAllowance()** function to get
    the result. This way, the appropriate strategy is automatically used to execute
    the correct logic, based on the data that was sent by the client in the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By separating logic into individual strategies, the Strategy pattern allows
    minimal APIs to conform to the open/closed principle. It does that by allowing
    us to extend the code base with new functionality, rather than alter the existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: It also offers self-containment, meaning that ways of performing similar tasks
    do not cross-contaminate each other, which reduces the potential for bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns alone do not make a resilient system. Resiliency is achieved
    through a good understanding of where and how errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: Years of service property required
  prefs: []
  type: TYPE_NORMAL
- en: The example in this section will work with the original **Employee** object
    used in [*Chapter 9*](B20968_09.xhtml#_idTextAnchor143) if you add an **int**
    property, called **YearsOfService** . We assume that you will have done this before
    attempting to follow this strategy pattern example.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s move on to explore good practices around error handling
    in minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to the topic of error handling and resilience, the first is the
    method and the second is the outcome. By implementing effective error handling,
    we achieve resilience.
  prefs: []
  type: TYPE_NORMAL
- en: So, while using **try/catch** across the code base is important, a standardized
    manner of handling errors at the top level is still critical. For a minimal API,
    middleware is an effective way to handle errors from the top level. Let’s explore
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes that you read [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094)
    or that you already have an in-depth understanding of how to write middleware
    in ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing middleware ensures that we have a global solution to error handling
    in a minimal API. Think of it as a giant **try/catch** that wraps around all of
    your minimal API’s endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: As we explored middleware extensively in [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094)
    , we do not need to go through the specifics of how middleware is built, so we
    shall dive straight into an example of an error-handling middleware class, as
    shown in the upcoming code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a class for the middleware, along with a constructor and an
    **InvokeAsync** method that can be used to initiate the middleware’s logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, we can add a method that takes in the current **HttpContext**
    to handle any detected errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that this middleware example for error handling could easily
    replace the similar error handling example in [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094)
    .
  prefs: []
  type: TYPE_NORMAL
- en: This middleware will catch an exception thrown higher up in the request pipeline,
    ensuring that the error is returned to the requesting client via **HttpContext**
    . This ensures a consistent error response to the client regardless of the endpoint
    that was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will be aware from earlier in the book, middleware, such as services
    for dependency injection, must be registered in **Program.cs** . Register this
    middleware class as the first piece of middleware to be registered, and then create
    an example endpoint that throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should find that not only the message from the exception is returned but
    also a generic message, consistently, like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another practice that should be consistent when developing any API is that of
    secure development. Let’s explore some good security practices that you can apply
    when authorizing requests to your minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two critical areas of security within a minimal API – authentication
    and authorization. Regardless of their differences, the attitude toward their
    implementation should be largely the same – *don’t roll* *your own* .
  prefs: []
  type: TYPE_NORMAL
- en: This mantra serves as a warning that a proven security framework will usually
    be safer than one you devise yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first look at the difference between authentication and authorization,
    as well as how you can achieve a good degree of security using the well-known
    technology **JSON Web** **Tokens** ( **JWTs** ).
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Authentication** verifies the identity of users or systems accessing your
    API. It allows you to allow only legitimate requests to enter a system.'
  prefs: []
  type: TYPE_NORMAL
- en: JWTs are widely used for their stateless authentication capabilities in minimal
    APIs. Users authenticate once and receive a token, which is included in subsequent
    requests to access protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Authorization** is a means of checking to see whether an authenticated user
    is accessing resources within their specific permissions. In JWT, these permissions
    are known as **claims** .'
  prefs: []
  type: TYPE_NORMAL
- en: 'A claim can be the name of a resource or type of user, or it can be a role.
    Either way, JWT has built-in functionality to define and validate claims against
    specific endpoints in a minimal API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with this authorization framework, we first need to add the
    **Microsoft.AspNetCore.Authentication.JwtBearer** NuGet package. Do this via the
    NuGet Package Manager Console, accessible via **Tools** | **NuGet Package Manager**
    | **Package** **Manager Console** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then need to ensure that **Program.cs** has the relevant namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'JWT can be implemented as a middleware, so it should first be set up in **Program.cs**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This registration specifies how your tokens are validated. Next, we need to
    provide a means of generating a token. We can do this by creating a dedicated
    API endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, now that we have a means of creating a JWT token, we can create an
    endpoint that requires it. Let’s again create a simple **GET** endpoint, but this
    time, we add an **[Authorize]** attribute and chain **RequireAuthorization()**
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test this, we can make a **GET** request to this endpoint and add the returned
    JWT token as a bearer token. With an example JWT token, the header would look
    something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ASP.NET core will then authenticate the request, based on the validation parameters
    you specified when you registered the JWT middleware.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Taking this further, if we wanted to create a more restricted endpoint, which
    can only be accessed by users with the role claim, **Admin** , we can add a parameter
    to the **[** **Authorize]** attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using JWT tokens, our minimal APIs are provided with protection against unauthorized
    activity. However, this alone will not guarantee that authorized use is not abused.
  prefs: []
  type: TYPE_NORMAL
- en: In truth, it is impossible to guarantee this, but an extra step you can take
    to ensure that a minimal API is not abused is to limit the number of requests
    that can be made during a specified period. This practice is called **rate limiting**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By controlling the number of requests a client can make to your minimal API
    within a specific timeframe, rate limiting can help prevent a system from being
    overwhelmed by too many requests, whether the requests are legitimate or not.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore a simple example of rate limiting in an ASP.NET core minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the **AspNetCoreRateLimit** package from NuGet via the Package Manager
    Console. You can open this in Visual Studio by clicking **Tools** | **Manage NuGet
    Packages** | **Package Manager Console** . This will open the console, in which
    you can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add rate limiting (along with memory caching) via **Program.cs** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will limit all endpoints to a maximum of 100 requests per
    minute, per IP address. If the limit is exceeded, the client will receive a **429
    Too Many** **Requests** response.
  prefs: []
  type: TYPE_NORMAL
- en: To try this example out, change the maximum number of requests per minute to
    **2** and see what the results look like.
  prefs: []
  type: TYPE_NORMAL
- en: AspNetCoreRateLimit versus Microsoft.AspNetCore.RateLimiting
  prefs: []
  type: TYPE_NORMAL
- en: There is another option for rate limiting besides **AspNetCoreRateLimit** ,
    shown in the preceding example. **Microsoft.AspNetCore.RateLimiting** can also
    be used to manage the rate of allowed requests. **AspNetCoreRateLimit** is a third-party
    library, while **Microsoft.AspNetCore.RateLimiting** is built-in middleware. For
    configuration, **AspNetCoreRateLimit** uses JSON or programmatic configuration,
    whereas **Microsoft.AspNetCore.RateLimiting** uses programmatic configuration
    with **RateLimiterOptions** .
  prefs: []
  type: TYPE_NORMAL
- en: '**AspNetCoreRateLimit** offers more flexibility with different strategies and
    distributed rate limiting, while **Microsoft.AspNetCore.RateLimiting** focuses
    on built-in algorithms and endpoint-specific policies.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only scratched the surface of the practices that can be implemented to
    improve resilience in minimal APIs, but the examples we have explored are a good
    starting point to improve their design. Let’s recap the practices that we’ve seen
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started by observing the justification for implementing effective design
    practices – namely, for an increase in resiliency from a maintained scalability
    and security perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at folder structures, with personal preferences discussed and
    a couple of folder structure examples outlined for use in a fresh project.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored three design patterns in the form of factory, repository, and
    strategy, providing a solid foundation to arrange minimal API code in a scalable
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we briefly reviewed an example of how middleware can act as a “global
    catch,” standardizing the way error responses are returned to a client, before
    finally exploring some simple ways of authenticating requests and limiting the
    rate at which they can be processed.
  prefs: []
  type: TYPE_NORMAL
- en: We’re moving closer to the end of the book, which means we will need to learn
    how to manage a minimal API that is deployed and active in a user base. With that
    in mind, the next chapter will cover the things we need to consider most when
    making our minimal API available to the wider world – testing, deployment, and
    documentation.
  prefs: []
  type: TYPE_NORMAL
