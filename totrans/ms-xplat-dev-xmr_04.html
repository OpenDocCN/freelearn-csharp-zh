<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Local Data Management</h1></div></div></div><p>In this chapter, you will find patterns and techniques to efficiently use, manage, and roam data on mobile devices. It also investigates SQLite database creation and usage strategies. The chapter is divided into the following sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data in mobile applications</li><li class="listitem" style="list-style-type: disc">Application data</li><li class="listitem" style="list-style-type: disc">Local filesystem</li><li class="listitem" style="list-style-type: disc">Data roaming</li><li class="listitem" style="list-style-type: disc">SQLite</li><li class="listitem" style="list-style-type: disc">Patterns and best practices</li><li class="listitem" style="list-style-type: disc">Backup/roaming</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Data in mobile applications</h1></div></div></div><p>The term "data" can<a class="indexterm" id="id170"/> refer to different types of information and storage locations in mobile app development. It can be used to describe a volatile state that is created and destroyed each time a view in the application is used, or it might refer to persisted settings and configuration information that are required to run the application, or even the <a class="indexterm" id="id171"/>data stored in the local filesystem. Each type of data is created and persisted or destroyed throughout the lifecycle of the application or a view in the application. We can talk about four distinct groups for this discussion.</p><p>Each data type is stored and accessed from different locations and each location has its own unique restriction and access models.</p><div><img alt="Data in mobile applications" src="img/B04693_04_01.jpg"/><div><p>Data type storage locations</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>State</h2></div></div></div><p>Mobile<a class="indexterm" id="id172"/> applications are generally <em>stateful</em>. Transient data that is used to visualize items on the UI or the data created by the user of the application falls into this category. The purpose of state is to maintain a consistent app experience across sessions, devices, and/or process lifecycle. Application settings or the current state of the view is a good example for this category.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>App data</h2></div></div></div><p>App data <a class="indexterm" id="id173"/>generally refers to the data that is essential for the execution of the application. This data is created, stored, and managed by the application itself. It can be structured data storage or it might be the cached version of online application resources. This type of data can be raw, in the form of a SQLite database, or stored by other facilities on the current device by the current application.</p><p>App data stored in different locations can survive through different stages of an application lifecycle.</p><div><img alt="App data" src="img/B04693_04_02.jpg"/><div><p>App data lifecycle</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Local files</h2></div></div></div><p>Local files <a class="indexterm" id="id174"/>are the stored items in the local filesystem. These files are generally created outside the lifecycle and/or scope of the application and are only made use of by the application. For instance, a photo taken by the user can later on be used by the mail client app as an attachment item.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>External data</h2></div></div></div><p>External data <a class="indexterm" id="id175"/>can be described as the combination of all the other data sources that are used by the application during runtime. This can include network or web resources.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Application data</h1></div></div></div><p>Application data<a class="indexterm" id="id176"/> makes up the core of the data storage on Xamarin platforms and Windows Runtime. This data is specific to your application. It lives and eventually dies with it, and in most cases it is not relevant or even accessible by other applications running on the same device or even by the user who is using the application (at least directly).</p><p>The application has unrestricted access to application data, or so-called isolated storage, without having to ask for permission from the user or add a declaration and can (in most cases) write, read, and query items in this storage according to the type of the application data location.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Installation directory</h2></div></div></div><p>The installation directory<a class="indexterm" id="id177"/> is the innermost part of the accessible<a class="indexterm" id="id178"/> data storages and is the most intimate location for the application. Access to this location by the application is unrestricted but read-only. The access models on iOS, Android, and Windows Runtime vary greatly.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Android</h3></div></div></div><p>For <a class="indexterm" id="id179"/>Xamarin.Android applications, the installation directory essentially refers to the compressed Android package (the <code class="literal">.apk</code> file), and the defined subdivisions are just abstractions of folders packaged and added to the manifest during the compilation. The installation directory and subfolders can be accessed in various ways.</p><div><img alt="Android" src="img/B04693_04_03.jpg"/><div><p>Android package and the project tree</p></div></div><p>The most important location in the installation directory for Android apps is the <code class="literal">Resources</code> folder. Resources can be generalized as the UI-related items that will be used to render the views of the application. One of the resource types that can be included in the application package is the <code class="literal">drawable</code> type. Drawable resources are image resources and can exist in alternate flavors for different conditions and devices that the application runs on (see <a class="link" href="ch09.html" title="Chapter 9. Reusable UI Patterns">Chapter 9</a>, <em>Reusable UI Patterns</em>). In order for the compiler to include the resources in the application package, the build action of each item in this folder has to be set to <code class="literal">AndroidResource</code>.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>It is important to mention that Android packages do not allow filenames to contain uppercase characters, and yet Xamarin developers can include these types of files in their projects. Xamarin.Android deals with this by renaming the resources during compilation (for example, see the <code class="literal">XamarinLogo.png</code> file in the <code class="literal">drawable</code> folder).</p></div></div><p>Programmatically, they <a class="indexterm" id="id180"/>can be accessed using the generated <code class="literal">Resource</code> class to get the assigned resource ID and the <code class="literal">Resources</code> static class that provides access methods, or by using the <code class="literal">android.resource://</code> protocol and the resource identifier (or the package name together with the resource name). However, in most scenarios, using only the assigned id to use the resources with UI controls will suffice. The code is as follows:</p><div><pre class="programlisting">var myImageResourceId = Resource.Drawable.XamarinLogo;

var myImageView = (ImageView) FindViewById(Resource.Id.MyImageView);

// Set the Image resource using the id.
myImageView.SetImageResource(myImageResourceId);

// OR:

// Retrieving the resource itself and then assigning it.
Drawable myImageResource = Resources.GetDrawable(myImageResourceId);
myImageView.SetImageDrawable(myImageResource);</pre></div><p>In the declarative UI (layouts), the drawable resources folder can be accessed with the alias <code class="literal">@drawable</code>. Similarly, string resources can be accessed with <code class="literal">@string</code>. The code is as follows:</p><div><pre class="programlisting">&lt;ImageView android:src="img/xamarinlogo" 
           android:layout_width="wrap_content" 
           android:layout_height="match_parent" /&gt;</pre></div><p>Another important location in the installation directory is the <code class="literal">Assets</code> folder. The <code class="literal">Assets</code> folder is used for any raw assets that you want deployed together with your application (other than the <code class="literal">Resources</code> folder) and not to be processed by the compiler or the runtime. Assets can be retrieved with the <code class="literal">AssetManager</code> class, and the <code class="literal">Assets</code> property in the <code class="literal">Activity</code> class can be used to access the <code class="literal">AssetManager</code> class. The code is as follows:</p><div><pre class="programlisting">Task.Run(async () =&gt;
{
    using (var dataPackageStream = Assets.Open("Data.csv"))
    using (var streamReader = new StreamReader(dataPackageStream))
    {
        var content = await streamReader.ReadToEndAsync();
        // TODO: Do something with the comma separated content.
    }
});</pre></div><p>Other<a class="indexterm" id="id181"/> resource types in the installation location, such as layouts, raw, and string resources can also be accessed in the described manner using the abstraction provided by Android runtime.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>iOS</h3></div></div></div><p>The<a class="indexterm" id="id182"/> building units of an iOS application, such as executable code and associated resources, are contained in a so-called <a class="indexterm" id="id183"/>
<strong>bundle</strong>. A bundle is part of the application sandbox and the path to the bundle is determined by the operating system during installation.</p><p>Similar to Android applications, iOS application projects can also include compiled image resources (bundle resources). These items are then accessed using the abstraction layer provided by the runtime.</p><p>For instance, in order to access an image resource from the bundle directory, you would need to call the <code class="literal">FromFile</code> method on the <code class="literal">UIImage</code> class:</p><div><pre class="programlisting">var image = UIImage.FromFile("XamarinLogo.png");

//
// OR making a roundtrip (get the path, read the file, create // image
// Similar to /data/Containers/Bundle/Application/&lt;id&gt;/XamarinMasteriOS.app/XamarinLogo.png
var imagePath = NSBundle.MainBundle.GetUrlForResource("XamarinLogo", "png").Path;
var fileContent = System.IO.File.ReadAllBytes(imagePath);

var secondImage = UIImage.LoadFromData(NSData.FromArray(fileContent));</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Similar to the access model in Android applications, the bundle container is read-only and should not be modified. The simple reason for this is that iOS application bundles are signed by the publisher key and any change in the bundle container would invalidate the package signature.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Local storage</h2></div></div></div><p>There is a both in the second part as well. Android <a class="indexterm" id="id184"/>and iOS runtimes provide different storage facilities for <a class="indexterm" id="id185"/>application data both in the form of structured data and raw content files.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Android</h3></div></div></div><p>On the <a class="indexterm" id="id186"/>Android platform, <strong>Shared Preferences</strong><a class="indexterm" id="id187"/> and <strong>Internal Storage</strong> are<a class="indexterm" id="id188"/> the two local storage options. Both of these<a class="indexterm" id="id189"/> options <a class="indexterm" id="id190"/>have different access models and your applications have read/write access to these locations.</p><p>Using <code class="literal">SharedPreferences</code> is the most basic way of storing data on the Android platform. This class provides a simple persistent dictionary implementation that allows the application to create, modify, and retrieve primitive data types (that is, <code class="literal">boolean</code>, <code class="literal">float</code>, <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">string</code>, and <code class="literal">string_array</code>) and their associated key. The size on these values is only restricted by the data type itself.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>As the name suggests, <code class="literal">SharedPreferences</code> is generally used to store configuration options selected by the user and is persisted across user sessions. There is also a base activity implementation, <code class="literal">PreferenceActivity</code>, to easily create and reuse a view for user preferences that makes use of the <code class="literal">SharedPreferences</code> for the application.</p></div></div><p>The usage pattern for <code class="literal">SharedPreferences</code> class is straightforward. In order to use the default preferences for the activity or a custom preference file, the <code class="literal">Activity</code> class provides specialized methods:</p><div><pre class="programlisting">// Retrieve an object for accessing private to this activity
ISharedPreferences myPreferences = GetPreferences(FileCreationMode.Private);

// Retrieve and hold the contents of the preference file 'MyCustomPreferences'
ISharedPreferences myCustomPreferences = GetSharedPreferences("MyCustomPreferences", FileCreationMode.Private);</pre></div><p>After the retrieve call, the preference file is created according to the <code class="literal">FileCreationMode</code> class selected if it did not exist already. To get the value of a preference entry, you can use one of the get methods provided by the class. The code is as follows:</p><div><pre class="programlisting">var myStringValue = myCustomPreferences.GetString("MyStringValue", string.Empty);
var myIntValue = myCustomPreferences.GetInt("MyIntValue", default(int));</pre></div><p>To edit<a class="indexterm" id="id191"/> the values, the <code class="literal">Editor</code> class for the <code class="literal">SharedPreferences</code> class can be used. The code is as follows:</p><div><pre class="programlisting">ISharedPreferencesEditor myEditor = myCustomPreferences.Edit();
myEditor.PutString("MyStringValue", myStringValue);
myEditor.PutInt("MyIntValue", myIntValue);

// Apply the current changes from the editor back 
// to the Singleton SharedPreferences class
myEditor.Apply();

// OR
// Commit the changes to the singleton instance 
// AND the disk immediately
myEditor.Commit();</pre></div><p><strong>Internal Storage</strong><a class="indexterm" id="id192"/> is the dedicated storage for your application. The application is free to create and retrieve any type of file (and folder) in this directory.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p><code class="literal">FileCreationMode</code> is <a class="indexterm" id="id193"/>an access modifier used in Android runtime to define the access type and permission levels of a file.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Append</strong>: If the <a class="indexterm" id="id194"/>file already exists, then write data to the end of the existing file instead of erasing. This is to be used with <code class="literal">Android.Content.Context.OpenFileOutput</code>.</li><li class="listitem" style="list-style-type: disc"><strong>EnableWriteAheadLogging</strong>: When<a class="indexterm" id="id195"/> this database's open flag is set, the database is opened with write-ahead logging enabled by default.</li><li class="listitem" style="list-style-type: disc"><strong>MultiProcess</strong>: legacy<a class="indexterm" id="id196"/> behavior in and before Gingerbread (Android 2.3) and is implied when targeting such releases. For applications targeting higher SDK versions, it must be set explicitly. When used together with <code class="literal">SharedPreferences</code>, the file on disk will be checked for modifications even if the shared preferences instance is already loaded in this process. This behavior is desired when the application has multiple processes accessing the same file.</li><li class="listitem" style="list-style-type: disc"><strong>Private</strong>: This is the <a class="indexterm" id="id197"/>default file creation mode where the created file can only be accessed by the calling application (or all applications sharing the same user ID).</li><li class="listitem" style="list-style-type: disc"><strong>WorldReadable/WorldWritable</strong>: Both <a class="indexterm" id="id198"/>deprecated in API level 17 for security vulnerabilities, they can pose to enable file access to application files.</li></ul></div></div></div><p>Files in<a class="indexterm" id="id199"/> this folder, without any manifest declaration, can be accessed with the designated methods on the application context or by using the Xamarin/Mono implementation of IO methods. The code is as follows:</p><div><pre class="programlisting">// Creating a file in the application internal storage root
using(var fileStreamInRootPath = this.OpenFileOutput("FileInRootPath", FileCreationMode.Private))
using (var streamWriter = new StreamWriter(fileStreamInRootPath))
{
    streamWriter.Write("Hello World!");
}

//
// Reading the contents of the file
using(var fileStreamInRootPath = this.OpenFileInput("FileInRootPath"))
using (var streamReader = new StreamReader(fileStreamInRootPath))
{
    var stringContent = streamReader.ReadToEnd();
}

// Getting the file path.
// e.g.: /data/data/Xamarin.Master.Android/files/FileInRootPath
var filePath = FilesDir.AbsolutePath + "/" + "FileInRootPath";

// Using the Xamarin (Mono) implementation.
System.IO.File.AppendAllText(filePath, "\r\nAdditional Content");
var allText = System.IO.File.ReadAllText(filePath);</pre></div><p>In addition to basic CRUD operations, you can also create additional folders and enumerate files and folders.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>iOS</h3></div></div></div><p>The<a class="indexterm" id="id200"/> simplest data storage option on iOS applications are the property lists. (the <code class="literal">.plist</code> files). These files are designed to be used for relatively small amounts of data that can be represented with primitive data types. They can be defined as dictionaries or arrays that are serialized and persisted in XML format.</p><p>You can read and write to a property list directly using the associated classes (<code class="literal">NSArray</code> and <code class="literal">NSDictionary</code>). For instance, a simple implementation that creates and reads a property list would look similar to the following code (with additional diagnostic entries):</p><div><pre class="programlisting">myNSDictionary.WriteToFile(dictionaryPath, true);

Debug.WriteLine("File Contents:");
var fileContents = System.IO.File.ReadAllText(dictionaryPath);
Debug.WriteLine(fileContents);

var myNewNSDictionary = NSDictionary.FromFile(dictionaryPath);

Debug.WriteLine("Values read from plist:");
foreach (var key in myNewNSDictionary.Keys)
{
    var keyValue = myNewNSDictionary[key];
    Debug.WriteLine(string.Format("Value for the key '{0}' is '{1}'", key, keyValue));
}</pre></div><p>The<a class="indexterm" id="id201"/> output from the preceding implementation would look like this:</p><div><pre class="programlisting">
<strong>File Contents:</strong>
<strong>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</strong>
<strong>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</strong>
<strong>&lt;plist version="1.0"&gt;</strong>
<strong>&lt;dict&gt;</strong>
<strong>       &lt;key&gt;firstKey&lt;/key&gt;</strong>
<strong>       &lt;string&gt;firstValue&lt;/string&gt;</strong>
<strong>       &lt;key&gt;secondKey&lt;/key&gt;</strong>
<strong>       &lt;string&gt;secondValue&lt;/string&gt;</strong>
<strong>       &lt;key&gt;thirdKey&lt;/key&gt;</strong>
<strong>       &lt;integer&gt;8&lt;/integer&gt;</strong>
<strong>&lt;/dict&gt;</strong>
<strong>&lt;/plist&gt;</strong>
<strong>Values read from plist:</strong>
<strong>Value for the key 'firstKey' is 'firstValue'</strong>
<strong>Value for the key 'secondKey' is 'secondValue'</strong>
<strong>Value for the key 'thirdKey' is '8'</strong>
</pre></div><p>When it comes to the local file storage, the iOS filesystem reserves several locations for applications; each of these locations have a specific purpose from the application's perspective.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Documents/</code>: The <code class="literal">Documents</code> library is generally designated for user-generated content. This folder should be used if the contents of the files are to be exposed to the user. Contents of this folder are backed up by iTunes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Documents/Inbox</code>: The <code class="literal">Inbox</code> folder is where files that are requested to be opened by the application are kept. An application can read and delete these files; it does not have privileges to modify these documents.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Library/</code>: The <code class="literal">Library</code> folder is the root directory for the files that you don't want to expose to the user. Applications can create files and additional folders in this directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Library/Application Support</code>: This subdirectory in the library folder is generally used to contain files managed by your application, such as configuration files, templates, saved data, and purchases. Contents destined for this folder should be placed in a custom subdirectory with the bundle identifier or company ID of your app.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Library/Caches</code>: The <code class="literal">Caches</code> folder is used for non-essential, application created files.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Library/Preferences</code>: App-specific preferences are stored in this folder. However, access to this folder should be done through the preferences API.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tmp/</code>: The <code class="literal">tmp</code> folder is another location for non-essential temporary files.</li></ul></div><p>Access to <a class="indexterm" id="id202"/>these library locations is possible using the <code class="literal">System.IO</code> namespace and associated classes.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Temporary storage</h2></div></div></div><p>Temporary storage<a class="indexterm" id="id203"/> and/or the cache directory is another location that the application does not need any specific permission. This is where non-essential files can be saved by the application to decrease network or processing time. The persistence of these folders is not guaranteed by the operating system.</p><p>In both Android and iOS systems, designated cache and/or temp locations are accessed through the context properties and the CRUD operations can be performed using the <code class="literal">System.IO</code> namespace and the related classes.</p><p>On Android, the cache directory can be accessed with the <code class="literal">CacheDir</code> property on the context:</p><div><pre class="programlisting">// Path similar to /data/data/Xamarin.Master.Android/cache
var cacheFilePath = this.CacheDir.AbsolutePath + "/" + "CacheFile";

// Writing to the file
System.IO.File.AppendAllLines(cacheFilePath, new[] { "Cached Content" });
            
// Reading the file
var cachedContent = System.IO.File.ReadAllText(cacheFilePath);</pre></div><p>On iOS, there <a class="indexterm" id="id204"/>are two separate locations for temporary files (<code class="literal">/temp/</code>) and cache files (<code class="literal">Library/Caches/</code>). Cache files are persisted for longer than the temporary data, but they still might be deleted by the system to free up disk space. The code is as follows:</p><div><pre class="programlisting">// getting the root application sandbox path
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
// paths to caches and temporary files directories.var cache = Path.Combine(documents, "..", "Library", "Caches");
var tmp = Path.Combine(documents, "..", "tmp");</pre></div><p>Neither of these directories are backed up or synchronized to iCloud.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Local filesystem</h1></div></div></div><p>On iOS, applications <a class="indexterm" id="id205"/>cannot programmatically access files external to the application sandbox (for example, an iOS application cannot programmatically navigate to the user's picture directory and pick a file). The bridge between the local filesystem and the iOS app's sandbox was limited to the image picker controller until iOS 8. iOS 8 introduces the new document picker controller and document provider API. In this interaction model, the application implementing the document provider extension creates the document picker UI and the host application uses this provided UI to let the user select the documents to be used in the host application execution (similar to the file open picker and provider capability on the Windows Runtime platform).</p><div><img alt="Local filesystem" src="img/B04693_04_04.jpg"/><div><p>UIImagePickerController</p></div></div><p>For Android, on<a class="indexterm" id="id206"/> top of the local file storage that is only app-specific, applications have access to two other locations: public and private external storage (depending on the hardware). External storage in this context refers to SD card storage, which is not available on iOS systems. On Android runtime, applications can have access to the root path (OS root path) and iterate through public folders.</p><p>Let's have a look at the returned paths for some of the internal and external paths on an Android filesystem:</p><div><pre class="programlisting">Trace.WriteLine(Environment.RootDirectory, "FileSystem");
Trace.WriteLine(Environment.DataDirectory, "FileSystem");

Trace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryDownloads).AbsolutePath, "FileSystem");
Trace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryDocuments).AbsolutePath, "FileSystem");

// Call with GetExternalFilesDir
Trace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryMovies).AbsolutePath, "FileSystem");
Trace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryMusic).AbsolutePath, "FileSystem");
Trace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryPictures).AbsolutePath, "FileSystem");

Trace.WriteLine(Environment.GetExternalStoragePublicDirectory(Environment.DirectoryMovies).AbsolutePath, "FileSystem");
Trace.WriteLine(Environment.GetExternalStoragePublicDirectory(Environment.DirectoryMusic).AbsolutePath, "FileSystem");
Trace.WriteLine(Environment.GetExternalStoragePublicDirectory(Environment.DirectoryPictures).AbsolutePath, "FileSystem");

Trace.WriteLine(Environment.DownloadCacheDirectory, "FileSystem");
Trace.WriteLine(Environment.ExternalStorageDirectory, "FileSystem");</pre></div><p>The output to <a class="indexterm" id="id207"/>these calls identifies the app-specific and public locations:</p><div><pre class="programlisting">I/mono-stdout(10079): FileSystem: /system
I/mono-stdout(10079): FileSystem: /data
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Download
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Documents
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Movies
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Music
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Pictures
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Movies
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Music
I/mono-stdout(10079): FileSystem: /storage/emulated/0/Pictures
I/mono-stdout(10079): FileSystem: /cache
I/mono-stdout(10079): FileSystem: /storage/emulated/0</pre></div><p>In spite of the fact that Android developers have access to a vast set of options for storage access methods, they are required to implement their own file picker dialogs or use interfaces provided by other installed applications (Android runtime also offers a provider-consumer type of file sharing implementation between applications).</p><div><img alt="Local filesystem" src="img/B04693_04_05.jpg"/><div><p>A sample file browser implementation (Xamarin recipes)</p></div></div><p>If there <a class="indexterm" id="id208"/>is an application that, by default, handles the file dialogs (the activity that can handle <code class="literal">ActionGetContent</code> intent), it can be invoked with an intent and the result can be accessed through the <code class="literal">OnActivityResult</code> callback method.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>SQLite</h1></div></div></div><p>SQLite <a class="indexterm" id="id209"/>database implementations provide a relational persisted data structure in mobile application projects. Unlike the general server/client model that is used by relational databases, SQLite is a local database implementation and the data is stored in application local storage. Both Xamarin.iOS and Xamarin.Android application projects can include a SQLite database and associated implementations.</p><p>In order to use SQLite, developers are to choose to between the cross-platform implementation of ADO.Net, where the SQL queries are supposed to be created and included as plain text, or use the linq-2-entities access model of the SQLite.Net portable class library. It is available as a NuGet package and a component.</p><div><img alt="SQLite" src="img/B04693_04_06.jpg"/><div><p>SQLite.Net PCL</p></div></div><p>For the <a class="indexterm" id="id210"/>following demonstration, we will use the asynchronous version of the SQLite.Net library.</p><p>Implementation of the SQLite data access layer with SQLite.Net generally follows a code first database programming paradigm. In this pattern, developers first define their data model by creating entity classes and defining the data structure using the provided attributes. The code is as follows:</p><div><pre class="programlisting">public class LocationInfo
{
    [PrimaryKey, AutoIncrement]
    public int LocationInfoId { get; set; }

    public string Name { get; set; }

    public double Latitude { get; set; }

    public double Longitude { get; set; }
}</pre></div><p>Once the data model implementation is finished, we can start creating the SQLite access methods.</p><p>In order to<a class="indexterm" id="id211"/> create a SQLite connection, first an application storage location has to be defined for the database file. The code is as follows:</p><div><pre class="programlisting">public TravelContext(string sqlitePath, ISQLitePlatform platform)
{
    var connectionString = new SQLiteConnectionString(sqlitePath, false);
    var connectionWithLock = new SQLiteConnectionWithLock(platform, connectionString);
    m_SqliteConnection = new SQLiteAsyncConnection(() =&gt; connectionWithLock);

    // OR with non-async connection
    //var connection = new SQLiteConnection(platform, sqlitePath);
}</pre></div><p>In this implementation, <code class="literal">ISQLitePlatform</code> provides the much needed abstraction for the platform-specific APIs.</p><p>After the SQLite connection is ready for use, we can implement the data tables' access and creation methods. The code is as follows:</p><div><pre class="programlisting">private void InitTablesAsync()
{
    var tasks = new List&lt;Task&lt;CreateTablesResult&gt;&gt;();

    tasks.Add(m_SqliteConnection.CreateTableAsync&lt;LocationInfo&gt;());
    tasks.Add(m_SqliteConnection.CreateTableAsync&lt;City&gt;());
    tasks.Add(m_SqliteConnection.CreateTableAsync&lt;Landmark&gt;());
    tasks.Add(m_SqliteConnection.CreateTableAsync&lt;Comment&gt;());

    // OR
    //var initTask = m_SqliteConnection.CreateTablesAsync&lt;LocationInfo, City, Landmark, Comment&gt;();

    var initTask = Task.WhenAll(tasks);
    initTask.ConfigureAwait(false);
}</pre></div><p>We can now expose the tables through public properties in our data context, so the upper layers can execute queries against these tables. The code is as follows:</p><div><pre class="programlisting">var dbPath = Path.Combine(this.FilesDir.Path, "myTravelDb.db3");

// TODO: Use Dependency Injection
var platform = new SQLitePlatformAndroid();

var myDbContext = new TravelContext(dbPath, platform);

var landmarksInCityTask = await myDbContext.Landmarks
    .Where(item =&gt; item.CityId == cityId).ToListAsync();</pre></div><p>It is possible<a class="indexterm" id="id212"/> to extend the data model with entity relations and cascade operations. There are also available extensions for the SQLite.Net PCL library for lazy loading and child-related operations.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Patterns and best practices</h1></div></div></div><p>In this <a class="indexterm" id="id213"/>section, we will have a look at two common patterns that are common to mobile applications and how to implement these usage scenarios in a platform agnostic manner.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Application preferences</h2></div></div></div><p>Application preferences <a class="indexterm" id="id214"/>is a common scenario in mobile applications. In order to use the previously described property list on iOS and <code class="literal">SharedPreferences</code> on Android, a common dictionary interface is often the most appropriate approach. The interface would then be inherited on platform-specific projects and can be injected into the common library.</p><p>For a simple demonstration, we can define a simple interface that will retrieve and save string values. The code is as follows:</p><div><pre class="programlisting">public interface ISettingsProvider
{
    string this[string key] { get; set; }
}</pre></div><p>The implementation on the Android side would use a simple dictionary using a shared preference implementation. The code is as follows:</p><div><pre class="programlisting">public class SettingsProvider : ISettingsProvider
{
    private readonly ISharedPreferences m_SharedPreferences;

    public SettingsProvider(string name = "default")
    {
        // Retrieve and hold the contents of the preference file'
        m_SharedPreferences = Application.Context.GetSharedPreferences(name, FileCreationMode.Private);
    }

    public string this[string key]
    {
        get
        {
            if (m_SharedPreferences.Contains(key))
                m_SharedPreferences.GetString(key, string.Empty);
            return string.Empty;
        }
        set
        {
            var editor = m_SharedPreferences.Edit();
            editor.PutString(key, value);
            editor.Apply();
        }
    }
}</pre></div><p>On the iOS side, the<a class="indexterm" id="id215"/> implementation would use an <code class="literal">NSMutableDictionary</code> class to facilitate the preferences being edited by the user. The code is as follows:</p><div><pre class="programlisting">public string this[string key]
{
    get
    {
        if (m_MyNSMutableDictionary.ContainsKey(new NSString(key)))
        {
            return MyNSMutableDictionary [key].ToString();
        }

        return string.Empty;
    }
    set
    {
        MyNSMutableDictionary [key] = new NSString(value);
        MyNSMutableDictionary.WriteToFile(GetPropertyListPath(), true);
    }
}</pre></div><p>Now that the persisted dictionary has been implemented on both platforms, we can include the application settings as a singleton to be used with a dependency injection.</p><p>This implementation <a class="indexterm" id="id216"/>can be extended using the Settings API on the iOS platform and using the preferences views (<code class="literal">PreferencesFragment</code> and <code class="literal">PreferencesActivity</code>) on the Android platform to create a more native-looking implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>File picker</h2></div></div></div><p>In a<a class="indexterm" id="id217"/> cross-platform application project, if we are following an MVVM pattern, the view-model should reside in a shared project or a PCL so that the business logic can be shared between the apps. However, if we have a requirement to pick a file for processing, the method implementation should reside in the view itself since the platform-specific project that holds the view has access to platform features. Although it would be moving the business logic to the UI components, the work has to be done by the view.</p><p>You can, however, delegate the responsibility of the view model to the view without compromising the MVVM implementation. The delegation process can be executed through <strong>Inversion of Control</strong> (<strong>IOC</strong>) into the interface that defines the file picking operation.</p><p>To demonstrate this usage, we will use an interface called <code class="literal">IFilePickerService</code>. In this example, we just want to let the user pick a file and return the resulting file path back to the view-model and maybe the model. The code is as follows:</p><div><pre class="programlisting">public interface IFilePickerService
{
    Task&lt;string&gt; PickFileAsync();
}</pre></div><p>We will use this interface in the view-model to call for the view to execute the logic. The code is as follows:</p><div><pre class="programlisting">return new MvxCommand(() =&gt;
{
    m_FilePickerService.PickFileAsync()
        .ContinueWith(task =&gt;
        {
            Debug.WriteLine("File Picked:" + task.Result);
        });
});</pre></div><p>For Android implementation, we will be using the default file manager application that supports the respective intent type. We need to convert intent execution and the callback call on the <code class="literal">OnActivityResult</code> class into an asynchronous implementation. In order to do this, we will be using a task completion source. The code is as follows:</p><div><pre class="programlisting">private TaskCompletionSource&lt;string&gt; m_PickFileCompletionSource;</pre></div><p>The private<a class="indexterm" id="id218"/> variable will be initialized every time the intent is called and the result will be set in the callback method. With this pattern in mind, the interface method implementation would look similar to this:</p><div><pre class="programlisting">public Task&lt;string&gt; PickFileAsync()
{
    m_PickFileCompletionSource = new TaskCompletionSource&lt;string&gt;();

    Intent intent = new Intent();
    intent.SetType("*/*");
    intent.SetAction(Intent.ActionGetContent);
    intent.AddCategory(Intent.CategoryOpenable);

    try
    {
        StartActivityForResult(intent, 0);
    }
    catch(ActivityNotFoundException ex)
    {
        throw new InvalidOperationException("Could not find a file manager");
    }

    return m_PickFileCompletionSource.Task;
}</pre></div><p>Finally, the callback method implementation would be just setting the result on the <code class="literal">TaskCompletionSource</code> class. The code is as follows:</p><div><pre class="programlisting">protected override void OnActivityResult(int requestCode, Result resultCode, Intent data)
{
    base.OnActivityResult(requestCode, resultCode, data);

    if (resultCode == Result.Ok)
    {
        m_PickFileCompletionSource.TrySetResult(data.Data.Path);
    }
    else if(resultCode == Result.Canceled)
    {
        m_PickFileCompletionSource.SetCanceled();
    }
}</pre></div><p>Now that we have the <code class="literal">IFilePickerService</code> interface created, at least on the Android side, we have <a class="indexterm" id="id219"/>to register the type with the dependency injection provider we are using, and then we can rely on it to resolve the type in the view-model initialization. (We will be using the MVVMCross framework in this example.)</p><p>The code is as follows:</p><div><pre class="programlisting">public MainView()
{
    Mvx.RegisterType&lt;IFilePickerService&gt;(()=&gt;this);
}</pre></div><p>The resulting application would execute the pick file command and open up the file browser, returning the file path back to the view model. If the user cancels the file selection, the task would throw an exception notifying that the operation has been cancelled.</p><div><img alt="File picker" src="img/B04693_04_07.jpg"/><div><p>Default file browser</p></div></div><p>For the iOS side of the story, our job is a little easier:</p><div><pre class="programlisting">public Task&lt;string&gt; PickFileAsync()
{
    var taskCompletionSource = new TaskCompletionSource&lt;string&gt;();

    var documentTypes = new string[] { UTType.PNG, UTType.Image, UTType.BMP };

    var filePicker = new UIDocumentPickerViewController(documentTypes, UIDocumentPickerMode.Open);

    EventHandler&lt;UIDocumentPickedEventArgs&gt; documentPickedHandler = (sender, args) =&gt;
    {
        taskCompletionSource.SetResult(args.Url.Path);
    };

    filePicker.DidPickDocument += documentPickedHandler;

    return taskCompletionSource.Task;
}</pre></div><p>With this<a class="indexterm" id="id220"/> completed, we just need to register the type and we finally have a cross-platform implementation of a command relying on the dependency injected, platform-specific methods.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Backup/Roaming</h1></div></div></div><p>Xamarin target <a class="indexterm" id="id221"/>platforms both offer cloud sync and backup mechanisms. While the Android backup strategy is more of an async background process where backup and restore operations have to be initiated by the calling application, the iOS and iCloud roaming strategy provides seamless integration to the filesystem.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Android and Backup API</h2></div></div></div><p>Android Backup API<a class="indexterm" id="id222"/> and Google-provided backup transport services provide an easily accessible way for application developers to back up and restore application data to remote cloud storage. It is possible to restore data after a factory reset or one device to another using the APIs provided by the <code class="literal">BackupManager</code>.</p><p>Backup operations are executed by the <code class="literal">BackupManager</code> in Android runtime and operations related to the application data are delegated to the <code class="literal">BackupAgent</code> registered in the application manifest. It is important to remember the fact that your application has to be registered in the Android Backup Service. It is crucial to include the backup service key that you receive from the registration in the package manifest.</p><p>In order to create a <code class="literal">BackupAgent</code>, you must implement the <code class="literal">OnBackup</code> and <code class="literal">OnRestore</code> methods of the <code class="literal">BackupAgent</code> abstract class. In these methods, the old and new states of your data are served in the form of <code class="literal">ParcelFileDescriptor</code> (file metadata that can be used to access the actual file). In the restore method, you also receive the application version that might be helpful if the data structure has changed between application updates.</p><p>Another way to create an agent is to use the existing agent template (<code class="literal">BackupAgentHelper</code>) and use the existing helper classes to back up and restore certain subsets of your application data.</p><p>For instance, the <code class="literal">SharedPreferencesBackupHelper</code> class is a generic implementation of a backup <a class="indexterm" id="id223"/>operator on <code class="literal">SharedPreferences</code> files that are used by your application. The preferences groups for the application can be passed onto the helper and the helper class can deal with the backup logic implementation.</p><p>Another helper class is the <code class="literal">FileBackupHelper</code> class that can be used to back up and restore application files.</p><p>In order to demonstrate the Backup API and a usual backup scenario, we can create a backup agent that will trace out the backup events and method executions. The implementation class should derive from the <code class="literal">BackupAgentHelper</code> class:</p><div><pre class="programlisting">public class PreferencesBackupService : BackupAgentHelper
{
    // TODO: Override the methods we might need
}</pre></div><p>To include this backup agent in our application, we can either edit the application manifest or use the <code class="literal">ApplicationAttribute</code> attribute in the assembly info. Both <code class="literal">AssemblyInfo.cs</code> and <code class="literal">AndroidManifest.xml</code> can be found under the <code class="literal">Properties</code> project folder.</p><div><img alt="Android and Backup API" src="img/B04693_04_08.jpg"/><div><p>Application manifest and AssemblyInfo</p></div></div><p>Using <a class="indexterm" id="id224"/>the <code class="literal">ApplicationManifest.xml</code> file, let's add the backup agent and backup services key:</p><div><pre class="programlisting">&lt;application android:label="Xamarin.Master.Android" 
             android:icon="@drawable/Icon" 
             android:backupAgent="PreferencesBackupService"&gt;
  &lt;meta-data android:name="com.google.android.backup.api-key"  
             android:value="..." /&gt;
&lt;/application&gt;</pre></div><p>The preceding application manifest entry is how it would look if we were dealing with Java class libraries, not Xamarin and the JNI Bridge. In fact, this registration would throw an error as soon as a backup request is received. The code is as follows:</p><div><pre class="programlisting">
<strong>09-22 18:28:33.647 E/ActivityThread(32153): Agent threw during creation: java.lang.ClassNotFoundException: Didn't find class "Xamarin.Master.Android.PreferencesBackupService" on path: DexPathList[[zip file "/data/app/Xamarin.Master.Android-1.apk"],nativeLibraryDirectories=[/data/app-lib/Xamarin.Master.Android-1, /system/lib]]</strong>
</pre></div><p>To <a class="indexterm" id="id225"/>register the <code class="literal">PreferencesBackupService</code> class with the Android runtime, we need to add an identifier for the type itself. Since we are not using a namespace qualifier in the manifest declaration, we can register the class in the application default namespace:</p><div><pre class="programlisting">[Register("Xamarin.Master.Android.PreferencesBackupService")]
public class PreferencesBackupService : BackupAgentHelper </pre></div><p>If we were to use the <code class="literal">Application</code> attribute to register our backup agent without the application manifest entries, the attributes would look similar to the following using the <code class="literal">AssemblyInfo.cs</code> file:</p><div><pre class="programlisting">[assembly: Application(AllowBackup = true, BackupAgent = typeof(PreferencesBackupService))]
[assembly: MetaData("com.google.android.backup.api_key", Value = "...")]</pre></div><p>In this case, the <strong>android callable wrapper</strong> (<strong>ACW</strong>) is created with the default naming convention for our backup agent and inserted into the application manifest, so we didn't need to register our class additionally. The generated entry for the application manifest contains the MD5 hash of the pair namespace and the containing assembly:</p><div><pre class="programlisting">
<strong>md5d06a1058f86cf8319abb1555c0b54fbf.PreferencesBackupService</strong>
</pre></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>If you are developing with Visual Studio and running your application on Emulator, you can see the generated MD5 values for the Android exposed classes in the <code class="literal">&lt;projectdir&gt;\obj\&lt;buildconfig&gt;\android\src</code> directory.</p><div><img alt="Android and Backup API" src="img/B04693_04_09.jpg"/><div><p>Android source directory</p></div></div></div></div><p>Once the <a class="indexterm" id="id226"/>registration is complete, we can override a couple of methods in the agent class to get the trace information. The code is as follows:</p><div><pre class="programlisting">public override void OnCreate()
{
    var preferencesHelper = new SharedPreferencesBackupHelper(this, "ApplicationSettings");
    AddHelper("ApplicationPreferences", preferencesHelper);

    Debug.WriteLine("PreferencesBackupService was created", "BackUp");

    base.OnCreate();
}</pre></div><p>You can now open an Android Adb Console and use the following commands to trigger a backup request:</p><div><pre class="programlisting">
<strong>adb shell bmgr enable true</strong>
<strong>adb shell bmgr run</strong>
</pre></div><p>Once your data segments change, you can use the <code class="literal">DataChanged</code> method of the <code class="literal">BackupManager</code> class and use it to request restore operations. (Restore operations are, under normal circumstances, scheduled and performed by Android backup services, so the app does not need to explicitly call it.)</p><p>The code <a class="indexterm" id="id227"/>is as follows:</p><div><pre class="programlisting">BackupManager backupManager = new BackupManager(this);

// Notifying the backup manager about data changes
backupManager.DataChanged();

// Using an implementations of RestoreObserver class to request restore
backupManager.RequestRestore(new MyRestoreObserver());</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>iOS and ubiquitous storage</h2></div></div></div><p>In order to use<a class="indexterm" id="id228"/> iCloud features in your iOS applications, they must be configured in the <em>Apple Provisioning Portal</em> and the project manifest.</p><p>In the provisioning portal, while creating the App ID, iCloud must be selected as one of the enabled services. Then, using the <code class="literal">&lt;TeamID&gt;.&lt;BundeID&gt;</code> format, the container identifier must be inserted into the <code class="literal">Entitlements.plist</code> file. The keys that have to be edited are as follows:</p><div><pre class="programlisting">
<strong>com.apple.developer.ubiquity-kvstore-identifier</strong>
<strong>com.apple.developer.ubiquity-container-identifiers</strong>
</pre></div><p>On iOS, the simplest synchronization mechanism provided is for primitive data types in the form of key/value pairs. This is used for simple user preferences or application required values that need to be synchronized between separate clients. The total size of a key/value pair cannot exceed 64 kilobytes, while the maximum value size is 64 kB and key size is 64 bytes.</p><p>The synchronizing context can be accessed through the <code class="literal">NSUbiquitousKeyValueStore</code> class. The code is as follows:</p><div><pre class="programlisting">/// &lt;summary&gt;
/// Synchronizes local values to the cloud
/// &lt;/summary&gt;
private void SyncUpSettings()
{
    var store = NSUbiquitousKeyValueStore.DefaultStore;
    //
    // Can use designated set functions for different value types
    // string, bool, NSData, NSDictionary, NSObject[], long, double
    store.SetString("myStringValue", "New String Value");
    store.SetLong("myLongValue", 1234);
    store.SetBool("myBoolValue", true);
    store.Synchronize();
}</pre></div><p>Using the <a class="indexterm" id="id229"/>same store, you can access the values:</p><div><pre class="programlisting">/// &lt;summary&gt;
/// Gets the values from synchronized local storage
/// &lt;/summary&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private Dictionary&lt;string,object&gt; GetValues()
{
    var results = new Dictionary&lt;string,object&gt;();
    var store = NSUbiquitousKeyValueStore.DefaultStore;

    //
    // Getting the synchronized LOCAL values
    results.Add("myStringValue",store.GetString("myStringValue"));
    results.Add("myLongValue", store.GetLong("myLongValue"));
    results.Add("myBoolValue", store.GetBool("myBoolValue"));

    return results;
}</pre></div><p>The synchronization process does not happen right after the synchronize method is invoked. The process is initiated according to iCloud's own schedule; up-sync generally happens within 5 seconds, while the only way to exactly know when the down-sync occurs is by adding an <code class="literal">Observer</code> delegate to the <code class="literal">NSUbiquitousKeyValueStore</code> events.</p><p>The code is as follows:</p><div><pre class="programlisting">NSNotificationCenter.DefaultCenter.AddObserver(
    NSUbiquitousKeyValueStore.DidChangeExternallyNotification, (notification) =&gt;
    {
        NSDictionary userInfo = notification.UserInfo;

        // NInt: 0-ServerChange, 1-InitialSyncChange, 
        // 2-QuotaViolationChange
        NSNumber reasonNumber = (NSNumber) userInfo.ObjectForKey(NSUbiquitousKeyValueStore.ChangeReasonKey);

        // NSString[] You can used the changed items list to sync only those values
        NSArray changedKeys = (NSArray) userInfo.ObjectForKey(NSUbiquitousKeyValueStore.ChangedKeysKey);

        // OR get the latest values from synchronized local storage
        var latestValues = GetValues();
    });</pre></div><p>For <a class="indexterm" id="id230"/>synchronized files, the implementation is a little more complicated. While backup and restore scenarios are automatically handled by the iOS application and iTunes, for keeping a synchronized file storage, developers need to implement the <code class="literal">UIDocument</code> class to prepare type of documents that needs to be synced between devices.</p><p>The <code class="literal">UbiquityContainer</code> directory is managed by the so-called daemons to coordinate the synchronization and modifications of the files on the iCloud context. In order not to cause concurrency problems and interfere with the daemon processing, the files in question need to be accessed and modified with the <code class="literal">NSFilePresenter</code> and <code class="literal">NSFileCoordinator</code> classes.</p><p>The easiest way to use the presenters and coordinators for file operations is to implement the <code class="literal">UIDocument</code> base class. There are two virtual methods that need to be implemented to read data and write data to documents.</p><p>Let's assume that we want to keep a synchronized context for serialized entity data for our application. First, we need to declare our class as inheriting and implementing the required constructor from the <code class="literal">UIDocument</code> class. The code is as follows:</p><div><pre class="programlisting">public class EntityDocument&lt;T&gt; : UIDocument
{
    public EntityDocument(NSUrl url)
        : base(url)
    {
        m_Type = typeof(T);
    }</pre></div><p>We then need to implement the two virtual methods. The following load method defined just deserializes the data from the cloud into the entity defined in the generic class type definition. The code is as follows:</p><div><pre class="programlisting">/// &lt;summary&gt;
/// Content down-sync'd from the cloud
/// &lt;/summary&gt;
public override bool LoadFromContents(NSObject contents, string typeName, out NSError outError)
{
    // TODO: Implement a try/catch block to return (if any) errors as well as negative result (i.e. return false).
    outError = null;

    if (contents != null)
    {
        var serializedData = NSString.FromData((NSData)contents, NSStringEncoding.UTF8);
        m_Entity = JsonConvert.DeserializeObject&lt;T&gt;(serializedData);
    }

    // LoadFromContents called when an update occurs
    NSNotificationCenter.DefaultCenter.PostNotificationName(string.Format("{0}DocumentModified",m_Type.Name), this);

    return true;
}</pre></div><p>Finally, we can<a class="indexterm" id="id231"/> implement the save method that will serialize the object and serve the stream to be saved in the ubiquitous container. The code is as follows:</p><div><pre class="programlisting">/// &lt;summary&gt;
/// Content to up-sync to the cloud
/// &lt;/summary&gt;
public override NSObject ContentsForType(string typeName, out NSError outError)
{
    // TODO: Implement a try/catch block to return (if any) errors as well as negative result (i.e. return false).
    outError = null;

    if (m_Entity != null)
    {
        var serializedData = JsonConvert.SerializeObject(m_Entity);

        NSData docData = new NSString(serializedData).Encode(NSStringEncoding.UTF8);

        return docData;
    }

    return null;
}</pre></div><p>In order to be able to use this implementation with an example class, named <code class="literal">LocationInfo</code>, we <a class="indexterm" id="id232"/>can first implement a load file procedure (we are using a single file query for each location loaded, but this can be extended using queries like <code class="literal">ENDSWITH</code> or <code class="literal">CONTAINS</code>). The code is as follows:</p><div><pre class="programlisting">private void GetLocationsInfo(string locationName)
{
    var locationDataQuery = new NSMetadataQuery();
    locationDataQuery.SearchScopes = new NSObject[] {NSMetadataQuery.UbiquitousDocumentsScope};

    locationDataQuery.Predicate = NSPredicate.FromFormat(string.Format("{0} == %@",
        NSMetadataQuery.ItemFSNameKey), new NSString(locationName + "Data.txt"));

    NSNotificationCenter.DefaultCenter.AddObserver(this, new Selector("locationLoaded:"),
      NSMetadataQuery.DidFinishGatheringNotification, locationDataQuery);

    locationDataQuery.StartQuery();
}</pre></div><p>Once the query returns, we can expand the object into the data needed. The code is as follows:</p><div><pre class="programlisting">[Export("locationLoaded:")]
private void DidFinishGatheringHandler(NSNotification notification)
{
    var locationQuery = (NSMetadataQuery) notification.Object;
    locationQuery.DisableUpdates();
    locationQuery.StopQuery();
    NSNotificationCenter.DefaultCenter.RemoveObserver(this, NSMetadataQuery.DidFinishGatheringNotification, locationQuery);

    LoadLocationInfo(locationQuery);

    // listen for notifications that the document was modified via the // server 
    NSNotificationCenter.DefaultCenter.AddObserver(this, new Selector("itemReloaded:"),
      new NSString("LocationInfoDocumentModified"),
      null);

}</pre></div><p>The <code class="literal">LoadLocationInfo</code> function in the example would simply try to open the file and deal with the loaded data. The code is as follows:</p><div><pre class="programlisting">private void LoadLocationInfo(NSMetadataQuery locationDataQuery)
{
    if (locationDataQuery.ResultCount == 1)
    {
        NSMetadataItem item = (NSMetadataItem) locationDataQuery.ResultAtIndex(0);
        var url = (NSUrl)item.ValueForAttribute(NSMetadataQuery.ItemURLKey);
        m_LocationData = new EntityDocument&lt;LocationInfo&gt;(url);
        m_LocationData.Open((success) =&gt;
        {
            if (success)
            {
                var info = m_LocationData.Entity;
                // TODO: Do something with the location info loaded
            }
            else
                Console.WriteLine("failed to open iCloud           document");
        });
    }
}</pre></div><p>Notice that <a class="indexterm" id="id233"/>we are also subscribing to the data changed event with the notification name we defined in the <code class="literal">EntityDocument&lt;T&gt;</code> class (<code class="literal">string.Format("{0}DocumentModified", m_Type.Name</code> ). The reload implementation is simply gathering the object from the notification itself. The code is as follows:</p><div><pre class="programlisting">[Export("itemReloaded:")]
private void DataReloadedHandler(NSNotification notification)
{
    var locationData = (EntityDocument&lt;LocationInfo&gt;) notification.Object;
    var entityData = locationData.Entity;
    // TODO: Do something with the location info loaded.
}</pre></div><p>For saving and synchronizing the data, we just need to assign the new data and update the change count on the <code class="literal">UIDocument</code> class. The code is as follows:</p><div><pre class="programlisting">private void SyncLocationDataChanges(LocationInfo info)
{
    m_LocationData.Entity = info;
    m_LocationData.UpdateChangeCount(UIDocumentChangeKind.Done); 

}</pre></div><p>This topic will be discussed further in <a class="link" href="ch05.html" title="Chapter 5. Networking">Chapter 5</a>, <em>Networking</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we discussed some of the local storage containers and access strategies. In both of the Xamarin platforms, with the additional option to back up and synchronize the data to the cloud, developers can create a consistent user interface as well as stateful mobile applications.</p><p>In the next chapter, we will discuss the network connectivity options and how to use connected data together with local storage options provided with the target Xamarin platforms.</p></div></body></html>