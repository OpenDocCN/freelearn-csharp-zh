<html><head></head><body>
		<div id="_idContainer183">
			<h1 id="_idParaDest-249"><em class="italic"><a id="_idTextAnchor254"/>Chapter 14</em>: Multi-Threaded Programming</h1>
			<p>In this chapter, you will learn about <strong class="bold">multi-threaded programming</strong>. You will learn what threads are and about background and foreground threads. Then, you will learn how to pass data into threads before you run them. You will also learn how to pause, interrupt, destroy, schedule, and cancel threads.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li><strong class="bold">Understanding threads and threading</strong>: This section covers the life cycle of threads.</li>
				<li><strong class="bold">Creating threads with and without parameters</strong>: This section provides examples of thread creation with and without parameters.</li>
				<li><strong class="bold">Pausing and interrupting threads</strong>: This section covers how to pause and interrupt threads.</li>
				<li><strong class="bold">Destroying and canceling threads</strong>: This section covers destroying and canceling threads.</li>
				<li><strong class="bold">Scheduling threads</strong>: This section covers how to schedule threads.</li>
				<li><strong class="bold">Thread synchronization and locks</strong>: This section covers how to synchronize threads, protect resources, and prevent deadlocks and race conditions.</li>
			</ul>
			<p>By the end of this chapter, you will have gained the following skills:</p>
			<ul>
				<li>You will understand threads and threading.</li>
				<li>You will be able to create threads with and without parameters.</li>
				<li>You will be able to pause and interrupt threads.</li>
				<li>You will be able to destroy and cancel threads.</li>
				<li>You will be able to schedule threads.</li>
			</ul>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor255"/>Technical requirements</h1>
			<p>To ensure that you benefit from this chapter, you should have the following requirements: </p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>The book’s source code from the following link: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14</a>.</li>
			</ul>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor256"/>Understanding threads and threading</h1>
			<p>In this section, we will understand<a id="_idIndexMarker1405"/> the life cycle of threads. Threads in C# have a life cycle as follows:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B16617_Figure_14.1.jpg" alt="Figure 14.1 – The thread life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – The thread life cycle</p>
			<p>When started, threads enter the <strong class="bold">running</strong> state. When running<a id="_idIndexMarker1406"/> a thread, there is a possibility it will enter a <strong class="bold">wait</strong>, <strong class="bold">sleep</strong>, <strong class="bold">join</strong>, <strong class="bold">stop</strong>, or <strong class="bold">suspended</strong> state. A thread<a id="_idIndexMarker1407"/> is suspended by calling the <strong class="source-inline">Suspend</strong> method, and calling the <strong class="source-inline">Resume</strong> method resumes a thread.</p>
			<p>When the <strong class="source-inline">Monitor.Wait(object obj)</strong> method is called, the thread enters the <strong class="source-inline">wait</strong> state. A waiting thread will continue when the <strong class="source-inline">Monitor.Pulse(object obj)</strong> method is called, and you can make threads sleep by calling the <strong class="source-inline">Thread.Sleep(int millisecondsTimeout)</strong> method.</p>
			<p>When you call the <strong class="source-inline">Thread.Join()</strong> method, it causes<a id="_idIndexMarker1408"/> the thread to enter the <strong class="source-inline">wait</strong> state. The waiting thread will then continue once the dependent threads have completed running. If any dependent threads are canceled, the thread is aborted and enters the <strong class="source-inline">stop</strong> state. Once a thread has been completed or canceled, you cannot restart it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">SYSLIB0006</strong> compile-time warning will be raised by projects that target .NET 5 or higher if they call any of the <strong class="source-inline">Thread.Abort</strong> APIs. Microsoft recommends that you abort the <strong class="source-inline">running</strong> unit of work using <strong class="source-inline">CancellationToken</strong> instead. The <strong class="source-inline">Thread.Abort</strong> APIs are now obsolete.</p>
			<p>In the next section, we will look at creating background and foreground threads with and without parameters.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor257"/>Creating threads and using parameters</h1>
			<p>In this section, we look<a id="_idIndexMarker1409"/> at the creation of<a id="_idIndexMarker1410"/> threads. First, we will see<a id="_idIndexMarker1411"/> how to create parameterless threads<a id="_idIndexMarker1412"/> in the foreground and the background. Let’s define both foreground and background threads as follows:</p>
			<ul>
				<li><strong class="bold">Foreground threads</strong>: By default, threads run in the<a id="_idIndexMarker1413"/> foreground. A process will continue to run if, at least, one foreground thread is running. Should the <strong class="source-inline">Main</strong> method be complete and the foreground thread is still running, the process will remain active until the foreground thread terminates.</li>
				<li><strong class="bold">Background threads</strong>: Background threads are created in the same<a id="_idIndexMarker1414"/> way as foreground threads. The main difference is that you must explicitly set the thread to run in the background.</li>
			</ul>
			<p>The following code shows how to create and run a foreground thread:</p>
			<pre class="source-code">var foregroundThread = new Thread(methodName);</pre>
			<pre class="source-code">foregroundThread.Start();</pre>
			<p>To create<a id="_idIndexMarker1415"/> and run<a id="_idIndexMarker1416"/> a background<a id="_idIndexMarker1417"/> thread, you run the following<a id="_idIndexMarker1418"/> code:</p>
			<pre class="source-code">var backgroundThread = new Thread(methodName);</pre>
			<pre class="source-code">backgroundThread.IsBackground = true;</pre>
			<pre class="source-code">backgroundThread.Start();</pre>
			<p>Both versions of the code that generates foreground and background threads, that you have just seen, create threads without using parameters. The following code shows you how to create a thread using parameters:</p>
			<pre class="source-code">static void ThreadCreationWithParameters()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    int result = 0;</pre>
			<pre class="source-code">    Thread thread = new Thread(() =&gt; { result = Add(1, 2); );</pre>
			<pre class="source-code">    thread.Start();</pre>
			<pre class="source-code">    thread.Join();</pre>
			<pre class="source-code">    Console.WriteLine($"The addition of 1 plus 2 is </pre>
			<pre class="source-code">        {result}." + $"");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">static int Add(int a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>As you can see<a id="_idIndexMarker1419"/> in the preceding<a id="_idIndexMarker1420"/> code, the thread<a id="_idIndexMarker1421"/> is used to sum two numbers<a id="_idIndexMarker1422"/> and return the result. The thread calls the <strong class="source-inline">Add</strong> method and passes the two integers to be added. Both the method call and the result are placed within an anonymous function passed into the thread’s constructor.</p>
			<p>Creating multiple threads can be costly on performance. The performance of multiple-thread creation can be improved by using thread pools. Thread pools improve performance in multi-threaded applications by limiting the number of threads that should be created and managed.</p>
			<p>When a new thread is created using a thread pool, it is kept there until it is needed. When required, the thread will run and complete its task. Once the task is completed, the thread will return to the thread pool for later reuse.</p>
			<p>You can create a thread in a thread pool as follows:</p>
			<pre class="source-code">ThreadPool</pre>
			<pre class="source-code">     .QueueUserWorkItem(</pre>
			<pre class="source-code">         new WaitCallback(ThreadPoolWorkerMethod)</pre>
			<pre class="source-code">     );</pre>
			<p>The thing to note when using a thread pool is that when first used, they have no history, but over time, they tune themselves to improve thread pool performance. For applications that use a large number of threads and put a heavy load on the CPU, it is possible that they will encounter a high startup cost. Threads have to be created and made available to the thread pool. This can cause the thread pool to have to wait until those threads are made available. A performance tweak you can make at startup is to set the minimum number of threads. The following code shows how to set the minimum number of threads:</p>
			<pre class="source-code">const int WorkerThreads = 12;</pre>
			<pre class="source-code">const int CompletionPortThreads = 12;</pre>
			<pre class="source-code">ThreadPool.SetMinThreads(WorkerThreads, </pre>
			<pre class="source-code">    CompletionPortThreads);</pre>
			<p>The <strong class="source-inline">WorkerThreads</strong> value is the minimum number of worker threads created on demand by the <strong class="source-inline">ThreadPool</strong>. The <strong class="source-inline">CompletionPortThreads</strong> value is the number of asynchronous I/O threads created on demand by the <strong class="source-inline">ThreadPool</strong>.</p>
			<p>In addition to setting<a id="_idIndexMarker1423"/> the minimum<a id="_idIndexMarker1424"/> number of threads, you<a id="_idIndexMarker1425"/> can set the maximum<a id="_idIndexMarker1426"/> number of threads as follows:</p>
			<pre class="source-code">const int WorkerThreads = 12;</pre>
			<pre class="source-code">const int CompletionPortThreads = 12;</pre>
			<pre class="source-code">ThreadPool.SetMaxThreads(WorkerThreads, CompletionPortThreads);</pre>
			<p>In order for these settings to help with application performance, you need to set them correctly. Otherwise, you can end up creating too many threads and overscheduling tasks. This will reduce performance by increasing context switching, which will put more load on the CPU. The <strong class="source-inline">ThreadPool</strong> is intelligent enough to switch to an algorithm that will reduce the amount of work the CPU has to do once it gathers a history.</p>
			<p>Before settings these values, it is a good idea to use performance monitoring to monitor the thread usage and context switching of your application. You can use performance counters tracing using the Contextual Visualizer, which is discussed in the following chapter. You can also use the <strong class="source-inline">ThreadPool.GetMaxThreads</strong> and <strong class="source-inline">ThreadPool.GetMinThreads</strong> methods to help you analyze the optimal values for setting the minimum and maximum numbers of worker threads and completion port threads.</p>
			<p>You can also set a thread’s priority. However, you have to be very careful about setting a thread priority as it can have a negative impact on other threads and other applications. Setting threads to a higher priority can starve lower priority threads, resulting in them rarely running.</p>
			<p>Only when a fast response is required for an event, such as an exception, should you consider changing thread priority to a high value. When race conditions are encountered, you can legitimately lower a thread’s priority. Threads that do not run for a while because of their lower priority will run at some point. This is because the dynamic priority of a thread is increased by Windows the longer it goes without running.</p>
			<p>If you do change the priority of a thread, its priority will be reset on entry back into the pool. However, a thread may be used for several tasks. In this case, the thread will not return to the pool until these tasks are completed. If the priority is set incorrectly, then this can degrade both application performance and system-wide performance.</p>
			<p>We now understand<a id="_idIndexMarker1427"/> how to create<a id="_idIndexMarker1428"/> and run threads. Let’s turn<a id="_idIndexMarker1429"/> our attention to pausing<a id="_idIndexMarker1430"/> and interrupting threads.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor258"/>Pausing and interrupting threads</h1>
			<p>In this section, we will look at pausing<a id="_idIndexMarker1431"/> and interrupting threads. An example of why you would<a id="_idIndexMarker1432"/> need to pause or interrupt a thread is if the code running is a debugger. If a thread is executing and it hits a breakpoint, it would need to be paused.</p>
			<p>The most common way to pause/delay a thread is to call <strong class="source-inline">Thread.Sleep(millisecondsDuration)</strong>, but this may freeze the main thread and your users may think your program has stopped working, leading them to terminate it.</p>
			<p>A better way to delay a thread is to let <strong class="source-inline">Task.Delay(TimeSpan)</strong> run in the background. This will allow the thread to work in the background and prevent the delayed thread from stopping the main thread from doing its work.</p>
			<p>The following code shows how to delay a thread:</p>
			<pre class="source-code">static void Main(string[] args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">     Console.WriteLine($"Current Time: {DateTime.Now}");</pre>
			<pre class="source-code">     var delay = Task.Delay(TimeSpan.FromSeconds(5));</pre>
			<pre class="source-code">     var duration = 0;</pre>
			<pre class="source-code">     while (!delay.IsCompleted)</pre>
			<pre class="source-code">     {</pre>
			<pre class="source-code">         duration++;</pre>
			<pre class="source-code">         Thread.Sleep(TimeSpan.FromSeconds(5));</pre>
			<pre class="source-code">         Console.WriteLine($"Slept for {seconds} seconds");</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">     Console.WriteLine($"Delay End:{DateTime.Now} after </pre>
			<pre class="source-code">         {duration} seconds");</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>We create the task with a time delay of five seconds. The loop keeps running until the time delay has been completed.</p>
			<p>The <strong class="source-inline">Interrupt</strong> method is called to interrupt<a id="_idIndexMarker1433"/> a thread that is in a blocked state of <strong class="source-inline">wait</strong>, <strong class="source-inline">sleep</strong>, or <strong class="source-inline">join</strong>. When the method<a id="_idIndexMarker1434"/> is called, <strong class="source-inline">ThreadInterruptedException</strong> is raised. This exception is not raised when calling the <strong class="source-inline">Interrupt</strong> method on a thread not in a blocked state.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor259"/>Destroying and canceling threads</h1>
			<p>Aborting threads is not a good idea as you<a id="_idIndexMarker1435"/> don’t always know<a id="_idIndexMarker1436"/> the state of a thread. It can be made worse if the thread is part of a static constructor. Using <strong class="source-inline">Thread.Abort</strong> to abort a thread is one of the main reasons for application crashes. The <strong class="source-inline">Thread.Abort</strong> APIs are now obsolete. So, you are encouraged to use the cooperative cancellation pattern to periodically<a id="_idTextAnchor260"/> check for cancellations using <strong class="source-inline">CancellationToken</strong>.</p>
			<p>Under normal circumstances, when a thread is aborted, it is destroyed. The cancellation of a thread also destroys the thread. Let’s write some sample code that demonstrates the usage of <strong class="source-inline">CancellationToken</strong> to cancel a synchronous operation when it times out, as follows:</p>
			<ol>
				<li>Start a new .NET 6 console application and call it CH14_Multithreading.</li>
				<li>In the <em class="italic">Program.cs</em> file of the <em class="italic">CH14_Multithreading</em> project, add<a id="_idIndexMarker1437"/> the following<a id="_idIndexMarker1438"/> method:<p class="source-code">static bool TryCallWithTimeout&lt;TResult&gt;(</p><p class="source-code">      Func&lt;CancellationToken, TResult&gt; function,</p><p class="source-code">      TimeSpan timeout,</p><p class="source-code">      out TResult result</p><p class="source-code">)</p><p class="source-code">{</p><p class="source-code">     var cancellationTokentSource = </p><p class="source-code">         new CancellationTokenSource(timeout);</p><p class="source-code">     try</p><p class="source-code">     {</p><p class="source-code">         result = </p><p class="source-code">         function(cancellationTokentSource.Token);</p><p class="source-code">         return true;</p><p class="source-code">     }</p><p class="source-code">     catch (TaskCanceledException)</p><p class="source-code">     {</p><p class="source-code">     }</p><p class="source-code">     finally</p><p class="source-code">     {</p><p class="source-code">         cancellationTokentSource.Dispose();</p><p class="source-code">     }</p><p class="source-code">     result = default;</p><p class="source-code">     return false;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method receives<a id="_idIndexMarker1439"/> a method to execute<a id="_idIndexMarker1440"/> over a specified timeout period and returns a result. <strong class="source-inline">SleepyMethod</strong> is executed, but if it exceeds the timeout value, then <strong class="source-inline">TaskCanceledException</strong> is raised and then <strong class="source-inline">CancellationTokenSource</strong> is disposed of.</p>
			<ol>
				<li value="3">Add the <strong class="source-inline">SleepyMethod</strong> code as follows:<p class="source-code">static int SleepyMethod(CancellationToken ct)</p><p class="source-code">{</p><p class="source-code">    for (var i = 0; i &lt; 10; i++)</p><p class="source-code">    {</p><p class="source-code">        Thread.Sleep(TimeSpan.FromMilliseconds(500));</p><p class="source-code">        if (ct.IsCancellationRequested) { throw new </p><p class="source-code">            TaskCanceledException(); }</p><p class="source-code">    }</p><p class="source-code">    return 1234567890;</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">SleepMethod</strong> accepts <strong class="source-inline">CancellationToken</strong> as a<a id="_idIndexMarker1441"/> parameter. It then loops<a id="_idIndexMarker1442"/> ten times. During each iteration, it sleeps for half a second. Then, it checks to see whether cancellation has been requested. If cancellation has been requested, then <strong class="source-inline">TaskCanceledException</strong> is raised. Otherwise, the value of the method is returned.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">SynchronousThreadCancelation</strong> method as follows:<p class="source-code">static void SyncrhonousThreadCancelation()</p><p class="source-code">{</p><p class="source-code">     TimeSpan timeoutTimeSpan = TimeSpan</p><p class="source-code">         .FromMilliseconds(750);</p><p class="source-code">     bool callResult = TryCallWithTimeout(</p><p class="source-code">         SleepyMethod,</p><p class="source-code">         timeoutTimeSpan,</p><p class="source-code">         out int result</p><p class="source-code">     );</p><p class="source-code">     Console.WriteLine($"SleepyMethod() {</p><p class="source-code">         (callResult ? "Executed" : "Cancelled" )</p><p class="source-code">     }");</p><p class="source-code">}</p></li>
			</ol>
			<p>This method creates a timeout<a id="_idIndexMarker1443"/> value of three-quarters of a second. It then calls<a id="_idIndexMarker1444"/> the <strong class="source-inline">TryCallWithTimeout</strong> method, which returns a Boolean value. The parameters passed into the <strong class="source-inline">TryCallWithTimeout</strong> method are the following:</p>
			<ul>
				<li><strong class="source-inline">SleepyMethod</strong>: The name of the method to be executed</li>
				<li><strong class="source-inline">timoutTimeSpan</strong>: The duration the method is to run for before it times out</li>
				<li><strong class="source-inline">result</strong>: Contains the result of <strong class="source-inline">CancellationToken</strong></li>
			</ul>
			<p>Once the call has been made, the name of the called method and its call result are sent to the console. In this code, we are not writing the result to the console window, but you can modify the code to do so.</p>
			<ol>
				<li value="5">At the top of the class, update the code as follows:<p class="source-code">SyncrhonousThreadCancelation();</p></li>
			</ol>
			<p>The preceding code calls our method and is an example of the cancellation of a synchronous operation.</p>
			<ol>
				<li value="6">Run the preceding code and the result should look something like the following:</li>
			</ol>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B16617_Figure_14.2.jpg" alt="Figure 14.2 – Console output for our program showing that the thread was canceled&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 – Console output for our program showing that the thread was canceled</p>
			<p>This concludes the topic<a id="_idIndexMarker1445"/> of canceling<a id="_idIndexMarker1446"/> and destroying threads. Let’s now look at scheduling threads.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor261"/>Scheduling threads</h1>
			<p>The <strong class="source-inline">Thread.Start</strong> method<a id="_idIndexMarker1447"/> schedules a <strong class="source-inline">Thread</strong> to start. You can overload this method with different parameters. We will look at two examples in this section. The first example will call the <strong class="source-inline">Thread.Start()</strong> method without passing any parameters, and the second will call <strong class="source-inline">Thread.Start(object)</strong>.</p>
			<p>We will now write the code as follows:</p>
			<ol>
				<li value="1">Add a class called <strong class="source-inline">Job</strong> as follows: <p class="source-code">internal class Job</p><p class="source-code">{</p><p class="source-code">     public void Execute()</p><p class="source-code">     {</p><p class="source-code">         Console.WriteLine(</p><p class="source-code">             "Execute() method execute.");</p><p class="source-code">     }</p><p class="source-code">     public void PrintMessage(object message)</p><p class="source-code">     {</p><p class="source-code">         Console.WriteLine($"Message: {message}");</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class provides two methods<a id="_idIndexMarker1448"/> that will be used in our <strong class="source-inline">Thread</strong> scheduling examples. The <strong class="source-inline">Execute</strong> method is used with the parameterless <strong class="source-inline">Thread.Start</strong> method, and the <strong class="source-inline">PrintMessage</strong> function is used with the <strong class="source-inline">Thread.Start</strong> method that takes parameters.</p>
			<ol>
				<li value="2">In the <strong class="source-inline">Program.cs</strong> class, add the <strong class="source-inline">SheduleThreadWithoutParameters</strong> method as follows:<p class="source-code">static void ScheduleThreadWithoutParameters()</p><p class="source-code">{</p><p class="source-code">     Job job = new();</p><p class="source-code">     Thread thread = </p><p class="source-code">         new Thread(new ThreadStart(job.Execute));</p><p class="source-code">     thread.Start();</p><p class="source-code">}</p></li>
			</ol>
			<p>In the preceding code, we create a new instance of the <strong class="source-inline">Job</strong> class. Then, we create a new <strong class="source-inline">Thread</strong> passing a new <strong class="source-inline">ThreadStart</strong> instance into its constructor. Into the <strong class="source-inline">ThreadStart</strong> constructor, we pass <strong class="source-inline">object.method</strong> that we wish to execute, and then we start the thread.</p>
			<ol>
				<li value="3">Add the <strong class="source-inline">ScheduleThreadWithParameters</strong> method as follows:<p class="source-code">static void ScheduleThreadWithParameters()</p><p class="source-code">{</p><p class="source-code">     Job job = new();</p><p class="source-code">     var thread1 = new Thread(</p><p class="source-code">         new ParameterizedThreadStart(</p><p class="source-code">             job.PrintMessage</p><p class="source-code">         )</p><p class="source-code">     );</p><p class="source-code">     var thread2 = new Thread(</p><p class="source-code">         new ParameterizedThreadStart(</p><p class="source-code">             job.PrintMessage</p><p class="source-code">         )</p><p class="source-code">     );</p><p class="source-code">    thread1.Start("Hello, world!");</p><p class="source-code">    thread2.Start("Goodbye, world!");</p><p class="source-code">}</p></li>
			</ol>
			<p>In the preceding code, we created<a id="_idIndexMarker1449"/> a new <strong class="source-inline">Job</strong> instance and two threads by calling the <strong class="source-inline">ParameterizedThreadStart</strong> class for each thread to execute a parameterized method on an object. We then start each of the threads.</p>
			<ol>
				<li value="4">Add a call to each of the methods at the top of the class and then run the preceding code. Your console should look like the following:</li>
			</ol>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B16617_Figure_14.3.jpg" alt="14.3 – Our parameterized thread output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">14.3 – Our parameterized thread output</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor262"/>Thread synchronization and locking</h1>
			<p>When using multiple threads in an application, you have<a id="_idIndexMarker1450"/> to consider thread synchronization<a id="_idIndexMarker1451"/> and locking. If you don’t, you can end up with race conditions and deadlocks. There are several ways to synchronize threads. You can use interlocked methods and synchronization objects, such as <strong class="source-inline">Monitor</strong>, <strong class="source-inline">Semaphore</strong>, and <strong class="source-inline">ManualResetEvent</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152"><em class="italic">Chapter 8</em></a>, <em class="italic">Threading and Concurrency</em>, in the <em class="italic">Clean Code in C#</em> book, we provide a detailed discussion on threads covering using threads, thread safety, parallel threads using semaphores, thread synchronization and preventing deadlocks, and race conditions.</p>
			<p>To synchronize your code, you can use a lock object as follows:</p>
			<pre class="source-code">internal class LockMutexExample</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public object _lockObject = new();</pre>
			<pre class="source-code">public void UsingLockObject()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">lock(_lockObject)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">// Perform your unsafe code here.</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>When the locked code is entered, all of the other threads are barred from accessing the locked code. The only downside to this is that you can end up with a deadlock. This can be overcome by using a mutex as follows:</p>
			<pre class="source-code">internal class LockMutextExample</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    private static readonly Mutex _mutex = new();</pre>
			<pre class="source-code">    public void UsingMutext()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">      try</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          _mutex.WaitOne();</pre>
			<pre class="source-code">          // ... Do work here ...</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">       finally</pre>
			<pre class="source-code">       {</pre>
			<pre class="source-code">           _mutex.ReleaseMutex();</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The preceding code<a id="_idIndexMarker1452"/> declares a <strong class="source-inline">Mutex</strong> class-level<a id="_idIndexMarker1453"/> variable. The code that needs protecting is then wrapped in a <strong class="source-inline">try/catch</strong> block. The current thread is blocked by the <strong class="source-inline">WaitOne()</strong> method until the wait handle receives a signal. <strong class="source-inline">True</strong> is then returned from the <strong class="source-inline">WaitOne()</strong> method upon a <strong class="source-inline">Mutex</strong> being signaled. The <strong class="source-inline">Mutex</strong> is then owned by the calling thread that can access protected resources. Once the protected resources are finished, the <strong class="source-inline">Mutex</strong> is released by calling <strong class="source-inline">ReleaseMutext()</strong>. Always call the <strong class="source-inline">ReleaseMutext()</strong> method in the final block to prevent resources from remaining locked if an exception is encountered.</p>
			<p>Race conditions happen when the same resource is accessed by multiple threads that produce different outcomes based on their timings. A race condition can be avoided by using code such as the following:</p>
			<pre class="source-code">Task</pre>
			<pre class="source-code">    .Run(() =&gt; Method1())</pre>
			<pre class="source-code">    .ContinueWith(task =&gt; Method2())</pre>
			<pre class="source-code">    .Wait();</pre>
			<p>The <strong class="source-inline">Task</strong> runs <strong class="source-inline">Method1()</strong> and then continues with <strong class="source-inline">Method2()</strong>. We then <strong class="source-inline">Wait()</strong> for the <strong class="source-inline">Task</strong> to complete its execution of <strong class="source-inline">Method1()</strong> and <strong class="source-inline">Method2()</strong> before continuing.</p>
			<p>That concludes our look at multi-threaded<a id="_idIndexMarker1454"/> programming. As you can see, there is not much<a id="_idIndexMarker1455"/> to scheduling threads. Let’s summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor263"/>Summary</h1>
			<p>In this chapter, we have come to an understanding of threads and the thread life cycle. We built some sample code that shows how to create threads with and without parameters. We also looked at running threads in the foreground and background.</p>
			<p>Next, we looked at pausing and interrupting threads. Then, we moved on to destroying and canceling threads. You no longer use <strong class="source-inline">Thread.Abort</strong> in your code. <strong class="source-inline">Thread.Abort</strong> has been responsible for applications crashing at runtime. Instead, you use cancellation tokens. Canceling threads also destroys them. </p>
			<p>We looked at scheduling threads with and without parameters. In the next chapter, we will be looking at parallel programming. </p>
			<p>Finally, we looked at thread synchronization and locking using lock objects and mutexes and learned how to avoid deadlocks and race conditions.</p>
			<p>It is now time to answer some questions to see how well you have retained the knowledge in this chapter. Once you have completed the questions, the <em class="italic">Further reading</em> section provides some external sources to further your knowledge on threads and multi-threaded programming.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor264"/>Questions</h1>
			<ol>
				<li value="1">What states can a thread be in?</li>
				<li>Which part of the <strong class="source-inline">Thread.Abort</strong> API do you use to terminate a thread?</li>
				<li>Which two locations can a thread be executed in?</li>
				<li>What is the correct way to terminate a thread?</li>
				<li>What method is used to schedule a thread?</li>
			</ol>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor265"/>Further reading</h1>
			<ul>
				<li>Managing and implementing multi-threading: <a href="https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process&#13;">https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process</a></li>
				<li>Pausing and interrupting threads: <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads&#13;">https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads</a></li>
				<li>How to terminate a thread in C#: <a href="https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/&#13;">https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/</a></li>
				<li>How to destroy threads in C#: <a href="https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash">https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash</a></li>
				<li>How to schedule threads in C#: <a href="https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20">https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20</a></li>
				<li>Understanding threads and the threading process: <a href="https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process&#13;">https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process</a></li>
				<li>How to pause code execution in C#: <a href="https://csharpsage.com/c-delay/ ">https://csharpsage.com/c-delay/</a></li>
				<li>Pausing and interrupting threads: <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads">https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads</a></li>
			</ul>
		</div>
	</body></html>