- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying the Open-Closed Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The open-closed principle is credited to Bertrand Meyer, after its appearance
    in his 1988 book, *Object-Oriented Software Construction* ([https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction](https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction)).
    This book describes the following principles that we can apply to our software:'
  prefs: []
  type: TYPE_NORMAL
- en: A type is open if it can be extended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type is closed when it is available to other types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose we have a class called **Shape** that has a method called **area**,
    which in turn calculates the area of the shape. We want to be able to add new
    shapes to our program without modifying the **Shape** class, so we make the **Shape**
    class open for extension.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we create a new class called **Triangle** that inherits from **Shape**
    and overrides the **area** method to calculate the area of a triangle. We can
    also create a **Rectangle** class and any other new shapes we want.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever we need to calculate the area of a shape, we can simply create
    a new instance of the appropriate shape class and call its **area** method. Because
    the **Shape** class is closed for modification, we don’t need to modify it every
    time we add a new shape to our program.
  prefs: []
  type: TYPE_NORMAL
- en: Classes in C# are, by default, open for extension. We can inherit from any classes
    that are not sealed and add new meanings to them. But the base class we’re inheriting
    from should be closed, meaning that there shouldn’t be a need for any change in
    the base type for the new type to work.
  prefs: []
  type: TYPE_NORMAL
- en: This helps us to design our code for extensibility and keep responsibilities
    in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a step back, we can apply some of this at the system level. What if we
    could simply expand on our systems, without the need to add configurations at
    the heart of a type for it to know about the additions?
  prefs: []
  type: TYPE_NORMAL
- en: This type of thinking is the type we used earlier in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types Using Reflection*, with the **ICommand** interface and
    its implementations. The two commands we added were not known by any parts of
    the system, but by implementing the **ICommand** interface, we could see both
    types through an introspective of our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the open-closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating type discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating the discovery of instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking up with the service collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A practical use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will understand how you can set your code and
    projects up for success in order to make them more flexible and extensible, and
    how to create code that welcomes changes and additions without having to perform
    open-heart surgery on your code every time.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter11](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter11))
    and it builds on the **Fundamentals** code, which can be found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the open-closed principle
  prefs: []
  type: TYPE_NORMAL
- en: In a world with ever-changing and growing requirements, newly discovered business
    opportunities, or even pivots for your business, it’s not very helpful if your
    software has to go through triple-bypass surgery for changes to be made. At the
    heart of an agile mindset sits the ability to be nimble and react to change in
    a timely fashion. From a business perspective, this is a type of elasticity that
    is very useful. The goal is to be cost-effective when changes come in. In projects
    or product developments that I’ve been part of, I’ve often noticed that this translates
    into an ad hoc mindset, and often a total disregard for writing code in a way
    that makes it possible to let the code have longevity and be understood by developers.
  prefs: []
  type: TYPE_NORMAL
- en: The initial phase of development, the exciting part of getting to the first
    version of a software product, is where we set the tone for the code future of
    the code base. In most cases, however, this only represents a small fraction of
    the lifecycle of the code. This is why I believe we should focus much more on
    how we can set ourselves up for success in the maintenance of code.
  prefs: []
  type: TYPE_NORMAL
- en: A very common idea I often also encounter is the strong belief that just getting
    the first version out the door is key and that after that, we can start fixing
    all the things we weren’t proud of originally, such as all the shortcuts we had
    to take because we thought we didn’t have time to do it *properly*. Chasing a
    **Minimum Viable Product** (**MVP**) is a very popular approach. The chase is
    driven by a desire to deliver products to the market and learn from them. Unfortunately,
    in my experience, we often don’t get to create a viable product at all, but rather
    prototypes that prove what we want to build. They might feel like products on
    the surface, but they lack a proper foundation to stand on. From a non-technical
    viewpoint, it feels like this is exactly what the developers wanted, and that
    they want you to move on. And who can blame them? Customers who start using these
    products might also feel like they are using a product, but they have no idea
    what’s going on under the surface. Pretty soon after getting the first version
    out there, the business, customers, and end users will come back with new things
    they’d like the software to do. I’ve yet to see a business prioritize fixing the
    foundation at this point. When this is combined with reported shortcomings or
    concrete faults in the software, you end up sprinting toward new goals. The excitement
    you had getting the first version out goes away, and the work becomes a chore.
  prefs: []
  type: TYPE_NORMAL
- en: We did the business a huge disservice by not putting design-based thinking into
    our code, which would have set the business up for success. The code might be
    in a worse state than it could’ve been, making it hard to make all these changes.
    This often leads to less satisfied developers, who might ultimately decide to
    leave in the hope that their next place of work will offer them a better working
    environment for writing better code.
  prefs: []
  type: TYPE_NORMAL
- en: Where am I going with all this? I do believe it is possible to deliver actual
    MVPs, lower the amount of technical debt in the code base dramatically, and make
    it possible to iterate on the MVP to deliver more, faster, and more accurately
    with a strong foundation. I’m pretty sure businesses would rather have the latter
    – something that won’t die a slow death the second it hits the market.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of enabling this sits one of my favorite principles: **the open-closed
    principle**. As I mentioned previously, I see it as a strategic mindset: not just
    a tactical approach to writing classes, but a system-level method. How can we
    make sure we can just drop code in at any time, extending the capabilities of
    our software, with the confidence that it won’t break the existing system? If
    we can avoid having to modify existing code to accomplish our new objectives,
    we lower the risk of regressions in our software dramatically.'
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage the building blocks we’ve built so far in this book to accomplish
    this and improve on them to make them more friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating type discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about Types Using
    Reflection*, we introduced a class called **Types**, which encapsulates the logic
    used in finding types. This is a very powerful construct for enabling software
    to be extensible. We can make it a little bit better and build a construct on
    top of it that simplifies its use.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Types** class, we have a method called **FindMultiple()**, which allows
    us to find types that implement a specific type. A small improvement on this would
    be to allow us to represent the different types we want implementations of by
    taking a dependency in a constructor of a specific type that describes this.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the implementation of this in the **Fundamentals** part of the repository
    mentioned in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept is basically to have the type represented as an interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The interface takes a generic type that describes the type whose implementations
    you’re interested in. It then says it is an enumerable of **Type**, which makes
    it possible for you to iterate over it directly. The generic constraint of **class**
    is there to limit the scope of the types you can work with, since it wouldn’t
    be useful to allow primitive types such as **int**, which aren’t inheritable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the interface is straightforward and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code takes **ITypes** as dependencies, as it will use it to actually find
    the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering types is one thing, and this makes the approach a little bit nicer
    by making the code more readable and clearer. But this only gives you the type.
    A more common method is to get not only the type but also its instances.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating the discovery of instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another encapsulation we can perform, which is probably more suited to our current
    scenario, is to find the implementations and then get their instances directly.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the implementation of this in the **Fundamentals** part of the repository,
    in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept is basically to represent the code similarly to the case in which
    **IImplementationsOf<T>** is used as the interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The interface in the code uses the generic parameter to determine the types
    for which it can provide instances. It then implements **IEnumerable<T>**, making
    it possible to enumerate its instances directly and get instances of the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the interface is straightforward and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code leverages **ITypes** and, as with **ImplementationsOf<T>**, it uses
    the **FindMultiple()** method to find the actual types. Since it will discover
    types it does not know anything about and, consequently, it does not know how
    to instantiate them if they don’t have a default constructor without arguments,
    it needs support in order to do this. To this end, it leverages the **IServiceProvider**
    instance found in .NET. **IServiceProvider** is what gets set up when using the
    .NET dependency injection system. The **GetEnumerator()** implementation then
    iterates the types and provides the instance by calling the **GetService()** method
    on **IServiceProvider**.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the implementation asks **IServiceProvider** only when enumerated
    instead of just doing this in the constructor. The reason for this is that you
    don’t want to run the risk of something taking a dependency on **IInstancesOf<T>**
    that has a longer lifecycle than the implementations. For instance, if a class
    using **IInstancesOf<T>** is a **singleton**, all the instances in the class using
    it are themselves singletons.
  prefs: []
  type: TYPE_NORMAL
- en: The only caveat is that when calling **GetService()** for types that do not
    have a concrete registration on **IServiceProvider**, you’ll get **null**. This
    is not very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking up with the service collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we’re leveraging **ServiceProvider** to create instances, and since its
    default behavior is to have everything explicitly registered with it, it might
    not have a registration for the concrete type we asked.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over Configuration*,
    you did an implementation for discovering the relationship between interfaces
    and implementations according to a convention. We can extend this thinking and
    say that it should be possible to resolve classes themselves according to their
    type.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we leverage more reflection metadata to filter out the different
    types we are not interested in.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over Configuration*,
    you created something called **Service** **CollectionExtensions**. We want to
    make use of this here as well, but we also want to add some additional functionality.
    Move the file into the shared **Fundamentals** project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **ServiceCollectionExtensions** class and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the **ITypes** system and filters down types by ignoring **static**
    classes, as they can’t be instantiated. In addition, it also ignores interfaces
    and abstract types for the same reason. It then ignores any types that are already
    registered in the **services** collection. Any type that is left is then registered.
    If the type has the **[Singleton]** attribute, it registers as a singleton; otherwise,
    it uses a **transient** lifecycle, meaning you’ll get a new instance every time
    you ask for one.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we’re getting ready to apply what we have in a more practical
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Practical use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build something that leverages the new form of discovery but, more importantly,
    shows the concept of an elastic growing system that does not require changes at
    the core for new features to be added.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the concept of compliance, which is a very common scenario in
    software. We looked into GDPR in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types Using Reflection*, and [*Chapter 5*](B19418_05.xhtml#_idTextAnchor083),
    *Leveraging Attributes*. GDPR is just one type of compliance with which it is
    important to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to create a system in which the core “engine” does not know about
    the different types of compliance metadata that can exist and instead provides
    extensibility points, where developers can just add new compliance metadata types
    as they’re needed.
  prefs: []
  type: TYPE_NORMAL
- en: We want the engine to be generalized and accessible to everyone. Following the
    GitHub repository mentioned in *Technical requirements*, you’ll find that there
    is a **Fundamentals** project. All the code listed here can be found there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a record that represents the type of metadata that
    leverages the **ConceptAs<>** base record found in **Fundamentals**. Add a file
    called **ComplianceMetadataType.cs** and make it look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces a **record** instance inheriting **ConceptAs<>** and makes
    the value inside it a **Guid** instance. It then adds a well-known type for **personally
    identifiable information**, or **PII** for short. The type also adds implicit
    operators for converting from a **string** representation of a **Guid** instance,
    as well as directly from a **Guid** instance.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **ConceptAs<>** type is explained in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types* *Using Reflection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want a type that will represent the actual metadata. Add a file called
    **ComplianceMetadata.cs** and make it look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code represents the metadata as a reference to the type of metadata, followed
    by a **Details** string.
  prefs: []
  type: TYPE_NORMAL
- en: In order for us to be able to discover the metadata, we need something that
    can provide this metadata. We represent this as an interface that is discoverable
    for us on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **ICanProvideComplianceMetadataForType.cs** and make it look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code represents a provider that decides whether it’s capable of providing
    using the **CanProvide()** method, followed by a method for actually providing
    the metadata. The key to the extensibility lies with this pattern, which enables
    us to drop in any implementations that can be called for any type, and the implementation
    itself decides whether it can provide the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Since **ICanProvideComplianceMetadataForType** is only focused on providing
    metadata for **Type**, we need another provider for the properties of a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **ICanProvideComplianceMetadataForProperty.cs** and make
    it look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As with **ICanProvideComplianceMetadataForType**, you’ll see that **ICanProvideComplianceMetadataForProperty**
    has the **CanProvide()** method and a **Provide()** method; the only difference
    is that it is focused on **PropertyInfo**.
  prefs: []
  type: TYPE_NORMAL
- en: With the discoverable interfaces in place, we can start to build the engine
    that discovers these things and combines them into something that can be leveraged
    as a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining the contract for the compliance engine by adding an
    interface for it. Add a file called **IComplianceMetadataResolver.cs** and make
    it look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code adds methods for asking whether **Type** or **PropertyInfo** has metadata
    associated with it and getting the associated metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Helping the developer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s good practice to be clear on whether calling code skips calling the **Has*()**
    methods and goes directly for the **Get*()** method, and whether there is no metadata.
    If there is no metadata, the **Get*()** methods can’t really do anything except
    throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **NoComplianceMetadataForType.cs** and make it look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code represents an exception with a clear name and a clear message saying
    that the type does not have any metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do the same for the properties without metadata. Add a file called **NoCompliance**
    **MetadataForProperty.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As with **NoComplianceMetadataForType**, the **NoComplianceMetadataForProperty**
    exception is clear, as suggested by its exception name and message, as to which
    properties do not have metadata associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can create the implementation of the **IComplianceMetadataResolver**
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **ComplianceMetadataResolver.cs** and make it look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code makes use of **IInstancesOf<>** for both the **ICanProvideComplianceMeta**
    **dataForType** provider type and the **ICanProvideComplianceMetadataForProperty**
    provider type. It collects all these and creates instances of them in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It might not be desirable to keep the instances around, as in the case presented
    here. This is entirely up to the implementation. In this use case, it is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to implement the methods from the interface. Add the following
    code to the end of the **ComplianceMetadataResolver** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code uses **_typeProviders** discovered in the constructor to determine
    whether the type given to it is something for which the provider can provide metadata.
    If it can, it will return true; if not, it will return false. The **GetMetadataFor()**
    method checks whether it can provide; if it can’t, it will throw the **NoComplianceMetadataForType**
    exception. If it can, it will filter down to the providers that can provide and
    then ask them to provide. It then combines all the metadata into one collection.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You now want to do the same for the properties. Add the following code to the
    end of the **ComplianceMetadataResolver** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As for types, the code asks **_propertyProviders** whether they can provide
    and then uses this to filter for the properties using the **GetMetadataFor()**
    method. The same behavior as that of the types throwing an exception will occur
    if there is no metadata when it is requested.
  prefs: []
  type: TYPE_NORMAL
- en: With the engine in place, we now need to make use of it and create the first
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In **Fundamentals**, you should already have an attribute called **PersonalIdentifiable**
    **InformationAttribute**. You now want to create a provider that can provide metadata
    for this on a property level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **PersonalIdentifiableInformationMetadataProvider.cs** in
    a sub-folder called **GDPR**, in the **Compliance** folder, inside **Fundamentals**,
    and make it look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code looks for **PersonalIdentifiableInformationAttribute** in the property
    given; if it’s present in the property or the declaring type, it can provide **ComplianceMetadata**.
    This method provides **ComplianceMetadata** if it is present and uses **ReasonForCollecting**
    for the details.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GDPR infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With your first GDPR provider in place, you can start to create a system that
    leverages it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create a folder, called **Chapter11**, at the root of your repository.
    Change into this folder in your command-line interface and create a new console
    project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re going to make use of the Microsoft hosting model to get the .NET default
    service provider without spinning up a web application. To achieve this, you’ll
    need the package called **Microsoft.Extensions.Hosting**. In the terminal, you’ll
    add the reference by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing you’ll need to do is to reference the **Fundamentals** project.
    In the terminal, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can start modeling a simple domain model for a patient system. Start
    by adding a file called **JournalEntry.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code adds a type that represents an entry in a patient’s journal with a
    title and a content property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **Patient.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code adds a definition of a patient with their first name, last name, and
    social security number, as well as all the journal entries for the patient. For
    the personal information, metadata is used in the form of **[PersonalIdentifiableInformation]**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Program.cs** file and make it look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up a generic host builder, registers **Types** as a singleton,
    and then leverages **AddBindingsByConvention()**, which you created in [*Chapter
    10*](B19418_10.xhtml#_idTextAnchor162), *Convention over Configuration*, to hook
    up the services by convention. It then calls the **AddSelfBinding()**, which you
    introduced earlier in this chapter. It ends by building the host instance.
  prefs: []
  type: TYPE_NORMAL
- en: With the host instance, we get the **Services** property, which is the build
    service provider. You use this to get an instance of **IComplianceMetadataResolver**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the end of **Program.cs**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code uses **IComplianceMetadataResolver** to get the metadata for the types.
    In your case, for now, it’s hardcoded to **Patient**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the metadata from the properties, add the following code at the end
    of **Program.cs**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code loops through the properties of **typeToCheck** and then prints out
    any details on the metadata from the properties. It also looks for any properties
    that have a generic argument and happen to implement **IEnumerable<>**, and it
    prints out any metadata associated with the item type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running your program should give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding more providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the engine in place, you can now start adding to it by simply dropping
    in new providers. Let’s add one for **JournalEntry**. Add a file called **JournalEntryMetadataProvider.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the **JournalEntry** type to decide whether it can provide or
    not. Every **JournalEntry** should be treated specially as that holds critical
    information that shouldn’t be shared. The **Provide()** method creates a new entry
    with a unique identifier for the **JournalEntry** type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the program should now give you more information; notice the journal
    entries that have been added to your output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To continue to add things to your system, let’s add something that lets you
    mark a type as **confidential**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **ConfidentialAttribute.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The attribute is targeting classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need a provider that can provide metadata for the new attribute.
    Add a file called **ConfidentialMetadataProvider.cs** and make it look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The provider looks for **ConfidentialAttribute** to decide whether it can provide.
    If it can, the **Provide()** method creates a new instance of **ComplianceMetadata**
    with a unique identifier for the type it represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Patient.cs** file and add the **[Confidential]** attribute in front
    of the **Patient** class, making the class look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program now should give you an output that includes the type-level
    information at the very top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You’ve now created a system that is flexible and extensible. You don’t have
    to go into the “engine” to perform any changes to introduce new capabilities.
    This is a powerful feature and a trait of a healthy system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building software that is **evergreen** is hard. Software that stands the test
    of time, does not lose its maintainability, and has the ability to allow development
    of new capabilities in a reasonable time frame is even harder. Keeping the time
    it takes to develop new business value close to constant is what we’re aiming
    for. This makes it much easier for businesses to determine the impact of new functionalities.
    It also makes this impact more predictable for developers.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, there are techniques, patterns, practices, and principles that
    can help. Thinking in extensible terms and designing the code to not become locked
    down is key, in my opinion. In this way, most of the time, it’s possible to focus
    on additions, rather than having to perform open-heart surgery just to add new
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to look at combining what we looked at in this
    chapter with what you started doing with conventions in [*Chapter 10*](B19418_10.xhtml#_idTextAnchor162),
    *Convention over Configuration*. Conventions can take many forms, and they can
    help you go beyond the inheritance model of C# and .NET.
  prefs: []
  type: TYPE_NORMAL
