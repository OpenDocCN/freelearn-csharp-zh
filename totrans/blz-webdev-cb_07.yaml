- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Validating User Input Forms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入表单
- en: In this chapter, we explore the essential aspect of ensuring the accuracy and
    integrity of data submitted through forms in Blazor applications. With effective
    validation, you’ll prevent erroneous data entry and enhance user interactions
    and application security. Throughout this chapter, we will explore a comprehensive
    range of techniques and strategies you can employ while validating user inputs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了确保通过Blazor应用程序中的表单提交的数据准确性和完整性的基本方面。通过有效的验证，你可以防止错误的数据输入，并增强用户交互和应用程序安全性。在本章中，我们将探讨你在验证用户输入时可以采用的一系列技术和策略。
- en: We begin with the fundamental process of adding validation to a form, setting
    the stage for more complex validation scenarios. You will learn how Blazor handles
    basic validation scenarios and how you can extend them to meet specific domain
    needs. After that, we explore the use of data annotations for form validation.
    You’ll uncover how to simplify form validation using built-in annotations and
    how to leverage them to enforce rules and constraints directly on data models,
    reducing boilerplate code. Right after, you will see how to implement custom validation
    attributes, which provide the flexibility to address unique business requirements.
    Then, we address the validation of complex data models, ensuring that data integrity
    is maintained even in intricate scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从向表单添加验证的基本流程开始，为更复杂的验证场景奠定基础。你将学习Blazor如何处理基本的验证场景，以及如何扩展它们以满足特定的领域需求。之后，我们将探讨使用数据注释进行表单验证的方法。你将发现如何使用内置注释简化表单验证，以及如何利用它们直接在数据模型上强制执行规则和约束，从而减少样板代码。紧接着，你将看到如何实现自定义验证属性，这些属性提供了处理独特业务需求的灵活性。然后，我们将讨论复杂数据模型的验证，确保即使在复杂场景中也能保持数据完整性。
- en: At the end of the chapter, we focus on improving the user experience of your
    forms. We cover the styling of validation messages and modernizing validation
    summaries. Good styling makes validation messages clear and more aligned with
    the application’s design, while toasts offer a dynamic way to alert users about
    issues without disrupting their workflow. Lastly, we explore how to dynamically
    control form actions based on validation results, ensuring that users can only
    submit forms in a valid state, thereby avoiding unnecessary submissions and server
    load.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们专注于提高表单的用户体验。我们涵盖了验证消息的风格化和验证摘要的现代化。良好的风格使验证消息清晰并与应用程序的设计更一致，而提示信息提供了一种动态的方式来提醒用户问题，而不会打断他们的工作流程。最后，我们探讨了如何根据验证结果动态控制表单操作，确保用户只能在有效状态下提交表单，从而避免不必要的提交和服务器负载。
- en: By the end of this chapter, you’ll know how to implement effective validation
    strategies in your Blazor applications, ensuring correct user inputs and enhancing
    the usability and reliability of your application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何在Blazor应用程序中实现有效的验证策略，确保正确的用户输入，并提高应用程序的可用性和可靠性。
- en: 'Here’s the list of recipes we’re going to cover in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱列表：
- en: Adding validation to a form
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向表单添加验证
- en: Leveraging data annotations for form validation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用数据注释进行表单验证
- en: Implementing custom validation attributes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义验证属性
- en: Validating complex data models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证复杂的数据模型
- en: Styling validation messages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风格化验证消息
- en: Displaying a toast when validation fails
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当验证失败时显示提示信息
- en: Enabling the submit option based on the form state
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据表单状态启用提交选项
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, recipes build on each other, so you can follow the entire
    journey within the same directory. However, for clarity and easier initial setup,
    at the beginning of each recipe, you will find instructions on what working directory
    to create and which files are required to execute the task at hand. But before
    diving in, make sure you have all the basic tools for Blazor development:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱是相互关联的，因此你可以在同一目录中跟随整个旅程。然而，为了清晰和更容易的初始设置，在每个食谱的开始，你将找到有关创建哪个工作目录以及需要哪些文件来执行当前任务的说明。但在深入之前，请确保你拥有所有Blazor开发的基本工具：
- en: A modern IDE (that supports Blazor development)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持Blazor开发的现代IDE
- en: A modern web browser (that supports WebAssembly)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持WebAssembly的现代网络浏览器
- en: Browser dev tools (which can be a part of the modern browser already)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器开发工具（可能已经是现代浏览器的一部分）
- en: A Blazor project (where you’ll write your code)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Blazor 项目（你将在其中编写代码）
- en: In the *Validating complex data models* recipe, we utilize the **Microsoft.AspNetCore.Components.DataAnnotations.Validation**
    NuGet package, which is not pre-installed by default, so you might as well add
    it to your project now. Keep in mind that the validation package is still in preview,
    so you’ll have to include prerelease packages in the NuGet feed in your IDE.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Validating complex data models**食谱中，我们使用了**Microsoft.AspNetCore.Components.DataAnnotations.Validation**
    NuGet包，该包默认未预安装，因此你现在可以将其添加到项目中。请注意，验证包仍在预览中，因此你必须在IDE中的NuGet源中包含预发布包。
- en: 'You can find all the code written in this chapter and code samples on GitHub
    at:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中编写的所有代码和代码示例：
- en: '[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07)'
- en: Adding validation to a form
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向表单添加验证
- en: In this recipe, we’ll explore the basics of user input validation in Blazor.
    Validation is critical for preventing errors and security vulnerabilities, maintaining
    data consistency, and enhancing the user experience. The Blazor community has
    created various NuGet packages for handling input validation, offering a range
    of features and configurations. However, Blazor provides extensive built-in support
    for validating forms and displaying validation results in a user-friendly manner.
    The native functionalities are lightweight and integrate directly with Blazor’s
    data binding and UI features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探讨Blazor中用户输入验证的基础。验证对于防止错误和安全漏洞、维护数据一致性以及提升用户体验至关重要。Blazor社区已经创建了各种NuGet包来处理输入验证，提供了一系列功能和配置。然而，Blazor提供了广泛的内置支持，用于以用户友好的方式验证表单并显示验证结果。原生功能轻量级，并直接与Blazor的数据绑定和UI功能集成。
- en: Let’s implement a small event creation form, where a user must provide the event
    name. We will also display a validation message when the event name is empty.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个小型事件创建表单，用户必须提供事件名称。我们还将显示当事件名称为空时的验证消息。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we add the first, basic validation to a form, create a **Chapter07**
    / **Recipe01** directory – this will be your working directory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向表单添加第一个、基本的验证之前，创建一个**Chapter07** / **Recipe01**目录——这将是你的工作目录。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to add a simple validation to a form:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤向表单添加简单的验证：
- en: 'Create an **Event** class with a **Name** property – we will use it as a form
    model:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有**名称**属性的**Event**类——我们将将其用作表单模型：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a routable **EventManager** component that implements the **IDisposable**
    interface. You will see compilation errors now, but we will resolve them later:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可路由的**EventManager**组件，该组件实现了**IDisposable**接口。你现在将看到编译错误，但我们将在稍后解决它们：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the **@code** block of **EventManager** , declare an **Event** model to
    serve as the backing model for the form:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventManager**的**@code**块中，声明一个**Event**模型作为表单的后备模型：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Below the **Model** parameter declaration, introduce the **Context** and **Store**
    variables for the form’s state management:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**模型**参数声明下方，引入用于表单状态管理的**上下文**和**存储**变量：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Still within the **@code** block, implement a **Save()** placeholder method
    to simulate form submission:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，实现一个**Save()**占位符方法来模拟表单提交：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alongside **Save()** , implement a **ValidateForm()** method, with a signature
    matching the response of a **EventHandler** validation, which checks whether the
    **Model.Name** property has a valid value:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Save()**旁边，实现一个**ValidateForm()**方法，其签名与**EventHandler**验证的响应相匹配，该验证检查**Model.Name**属性是否有有效的值：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Continuing in the **@code** block, override the **OnInitialized()** life cycle
    method to initialize the **Model** instance if needed and set up both the form
    context and the validation message container:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**@code**块中继续，重写**OnInitialized()**生命周期方法以初始化**Model**实例（如果需要）并设置表单上下文以及验证消息容器：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finalize the **@code** block by implementing the **Dispose()** method to adhere
    to the **IDisposable** requirement and unsubscribe from the validation event handler:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现**Dispose()**方法来最终化**@code**块，以符合**IDisposable**要求并取消订阅验证事件处理程序：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the **EventManager** markup, include an **EditForm** component, attaching
    **Context** to the appropriate parameter and linking the **Save()** method to
    handle the form submission:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EventManager** 标记中，包含一个 **EditForm** 组件，将 **Context** 附加到适当的参数，并将 **Save()**
    方法链接到处理表单提交：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside **EditForm** , add an **InputText** component and bind it to the **Model.Name**
    property. Alongside **InputText** , add a **ValidationMessage** component to display
    validation errors for the attached property:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EditForm** 内部，添加一个 **InputText** 组件并将其绑定到 **Model.Name** 属性。与 **InputText**
    一起，添加一个 **ValidationMessage** 组件来显示附加属性的验证错误：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, complete **EditForm** by adding a submit button below the form fields:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在表单字段下方添加提交按钮来**完成 EditForm**：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create a simple **Event** class with a single **Name** property.
    We will use **Event** as a model for our form. Next, in *step 2* , we create a
    routable **EventManager** component, not specifying any render mode, which leads
    Blazor to default to static server-side mode. As form validation is event driven,
    **EventManager** must implement the **IDisposable** interface, which we apply
    using the **@implements** directive. You will see compilation errors now, but
    we will resolve them later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们创建一个具有单个 **Name** 属性的简单 **Event** 类。我们将使用 **Event** 作为表单的模型。接下来，在
    *步骤 2* 中，我们创建一个可路由的 **EventManager** 组件，不指定任何渲染模式，这导致 Blazor 默认使用静态服务器端模式。由于表单验证是事件驱动的，**EventManager**
    必须实现 **IDisposable** 接口，我们使用 **@implements** 指令来实现。现在你会看到编译错误，但我们将在稍后解决它们。
- en: 'Moving to *step 3* , within the **@code** block of **EventManager** , we utilize
    the **Event** class to declare the **Model** parameter, tagging it with the **SupplyParameterFromForm**
    attribute to enable an automatic binding with the form. In *step 4* , we introduce
    two form-backing variables: **EditContext** and **ValidationMessageStore** . The
    **EditContext** instance tracks changes to form inputs and manages the validation
    state, while **ValidationMessageStore** holds and displays validation messages,
    simplifying the validation process.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 *步骤 3*，在 **EventManager** 的 **@code** 块中，我们使用 **Event** 类声明 **Model** 参数，并使用
    **SupplyParameterFromForm** 属性标记它，以启用与表单的自动绑定。在 *步骤 4* 中，我们引入两个表单支持变量：**EditContext**
    和 **ValidationMessageStore**。**EditContext** 实例跟踪表单输入的更改并管理验证状态，而 **ValidationMessageStore**
    存储并显示验证消息，简化了验证过程。
- en: Proceeding to *step 5* , we implement a **Save()** placeholder method. Data
    persistence isn’t the focus of this chapter, so we log a brief message to the
    console to simulate a save operation. In *step 6* , we implement the **ValidateForm()**
    method with a signature that matches the validation handler required by **EditForm**
    . Whenever Blazor invokes **ValidateForm()** , we first clear any messages in
    **Store** to handle multiple validation attempts smoothly. Then, we check whether
    the user provided the **Model.Name** property; if not, we add a **You must provide
    a name.** message to **Store** and identify the invalid property with a delegate,
    **() => Model.Name** . Under the hood, Blazor breaks down this delegate into the
    object ( **Model** ) and the property path string ( **Name** ) to efficiently
    track and manage validation and error association.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 进行到 *步骤 5*，我们实现一个 **Save()** 占位符方法。数据持久性不是本章的重点，所以我们向控制台记录一条简短的消息来模拟保存操作。在 *步骤
    6* 中，我们实现一个与 **EditForm** 所需的验证处理程序签名匹配的 **ValidateForm()** 方法。每当 Blazor 调用 **ValidateForm()**
    时，我们首先清除 **Store** 中的任何消息，以平滑处理多次验证尝试。然后，我们检查用户是否提供了 **Model.Name** 属性；如果没有，我们向
    **Store** 添加一条 **您必须提供一个名称。** 消息，并使用委托 **() => Model.Name** 识别无效属性。在底层，Blazor
    将此委托分解为对象（**Model**）和属性路径字符串（**Name**），以有效地跟踪和管理验证和错误关联。
- en: In *step 7* , we override the **OnInitialized()** life cycle method to set up
    the form’s underlying logic. We resolve the **Model** value, supporting the pattern
    for the parameter with the **SupplyParameterFromForm** attribute. We then initialize
    **Context** with the **Model** object and subscribe **ValidateForm()** to the
    **OnValidationRequested** event handler that **Context** exposes. With that, Blazor
    will automatically invoke **ValidateForm()** every time the user submits the form.
    Finally, we initialize **Store** by passing **Context** , so the validation container
    can access the **Model** fields. In *step 8* , we wrap up the **@code** block
    by implementing the **Dispose()** method, adhering to the **IDisposable** pattern.
    Within **Dispose()** , we safely unsubscribe **ValidateForm()** from the validation
    trigger of **Context** to prevent potential memory leaks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 7* 中，我们重写了 **OnInitialized()** 生命周期方法来设置表单的底层逻辑。我们解析了 **Model** 值，支持带有
    **SupplyParameterFromForm** 属性的参数模式。然后，我们使用 **Model** 对象初始化 **Context** 并将 **ValidateForm()**
    订阅到 **Context** 提供的 **OnValidationRequested** 事件处理器。这样，Blazor 将会自动在用户提交表单时调用 **ValidateForm()**。最后，我们通过传递
    **Context** 来初始化 **Store**，这样验证容器就可以访问 **Model** 的字段。在 *步骤 8* 中，我们通过实现 **Dispose()**
    方法来结束 **@code** 块，遵循 **IDisposable** 模式。在 **Dispose()** 中，我们安全地取消订阅 **ValidateForm()**
    从 **Context** 的验证触发器，以防止潜在的内存泄漏。
- en: Having the backend logic in place, we proceed to the **EventManager** markup.
    In *step 9* , we add an **EditForm** component, but instead of attaching the backing
    **Model** instance directly, we attach **Context** to the **EditContext** parameter.
    Blazor will not allow attaching both **Model** and **EditContext** since **Context**
    already encompasses an instance of **Model** . We also use the **OnValidSubmit**
    callback rather than the standard **OnSubmit** . Blazor invokes **OnValidSumbit**
    only when all validations pass successfully, making it ideal for our needs. In
    *step 10* , within **EditForm** , we place an **InputText** component and bind
    it to the **Model.Name** property, enabling the user to provide the required event
    name. Alongside **InputText** , we position a **ValidationMessage** component
    that displays validation messages for the specific form field. As **ValidationMessage**
    requires a delegate to retrieve messages from the container, we leverage the same
    delegate we used in **ValidateForm()** for seeding a validation message into **Store**
    . Finally, in *step 11* , we complete the form implementation by adding a submit
    button.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端逻辑就绪后，我们继续进行 **EventManager** 标记。在 *步骤 9* 中，我们添加了一个 **EditForm** 组件，但不是直接将后端
    **Model** 实例附加到它，而是将 **Context** 附加到 **EditContext** 参数。Blazor 不允许同时附加 **Model**
    和 **EditContext**，因为 **Context** 已经包含了一个 **Model** 的实例。我们还使用 **OnValidSubmit**
    回调而不是标准的 **OnSubmit**。Blazor 仅在所有验证成功通过时调用 **OnValidSumbit**，这使得它非常适合我们的需求。在 *步骤
    10* 中，在 **EditForm** 内部，我们放置了一个 **InputText** 组件并将其绑定到 **Model.Name** 属性，使用户能够提供所需的事件名称。在
    **InputText** 旁边，我们放置了一个 **ValidationMessage** 组件，用于显示特定表单字段的验证信息。由于 **ValidationMessage**
    需要一个委托来从容器中检索消息，我们利用在 **ValidateForm()** 中使用的同一个委托来将验证信息种子到 **Store** 中。最后，在 *步骤
    11* 中，我们通过添加提交按钮来完成表单的实现。
- en: When the user submits the form, Blazor triggers the **OnValidationRequested**
    event handler first. If validation results in errors, the **Save()** method is
    not activated, ensuring that only valid data is processed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交表单时，Blazor 首先触发 **OnValidationRequested** 事件处理器。如果验证结果有错误，则不会激活 **Save()**
    方法，确保只处理有效数据。
- en: 'Here’s what the validation error looks like in our form:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在表单中看到的验证错误的样子：
- en: '![Figure 7.1: Validation message when user submits the form without providing
    the name](img/B22020_07_1.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：用户提交表单未提供名称时的验证信息](img/B22020_07_1.jpg)'
- en: 'Figure 7.1: Validation message when user submits the form without providing
    the name'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：用户提交表单未提供名称时的验证信息
- en: There’s more…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With the **ValidationMessage** component, we can control where Blazor renders
    validation messages for each field, providing granular feedback directly next
    to individual form elements. However, you might want to display a consolidated
    validation summary rather than scattered messages. That’s where the **ValidationSummary**
    component comes in handy. The **ValidationSummary** component gathers and displays
    all validation messages within one container. You can see such summaries at the
    top or bottom of the forms or even as part of a validation popup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**ValidationMessage**组件，我们可以控制Blazor渲染每个字段的验证消息的位置，提供直接位于单个表单元素旁边的细粒度反馈。然而，你可能希望显示一个综合的验证摘要而不是分散的消息。这就是**ValidationSummary**组件派上用场的地方。**ValidationSummary**组件收集并显示一个容器内的所有验证消息。你可以在表单的顶部或底部看到这样的摘要，甚至可以作为验证弹出窗口的一部分。
- en: 'To implement a summary in our form, we only need to replace **ValidationMessage**
    with **ValidationSummary** and add a **DataAnnotationsValidator** component within
    the form:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的形式中实现摘要，我们只需要将**ValidationMessage**替换为**ValidationSummary**，并在表单内添加一个**DataAnnotationsValidator**组件：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We must embed **DataAnnotationsValidator** as it triggers the population and
    re-render of **ValidationSummary** . Without the validator, will get the red input
    styling, indicating that the value provided is invalid, but no message explaining
    why.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须嵌入**DataAnnotationsValidator**，因为它会触发**ValidationSummary**的填充和重新渲染。如果没有验证器，将会得到红色的输入样式，表示提供的值无效，但没有解释原因的消息。
- en: We explore **DataAnnotationsValidator** further in the next recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一道菜中进一步探讨**DataAnnotationsValidator**。
- en: Leveraging data annotations for form validation
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用数据注释进行表单验证
- en: In this recipe, we explore the role of **data annotations** in streamlining
    and enhancing the validation processes in a form in Blazor. Data annotations are
    attributes applied directly to model properties that enable a declarative way
    of specifying validation rules. By implementing data annotations, you can significantly
    simplify the validation logic and encapsulate it within the model rather than
    coupling it with any specific form. Such separation ensures that validation is
    consistently enforced across different parts of your application regardless of
    the context in which you use the model. Blazor has a built-in **DataAnnotationsValidator**
    component that seamlessly integrates data annotations into a form. **DataAnnotationsValidator**
    checks the data annotations applied to the model and produces validation results
    without additional coding.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这道菜中，我们探讨了数据注释在简化并增强Blazor表单验证过程中的作用。数据注释是直接应用于模型属性的属性，它允许以声明式的方式指定验证规则。通过实现数据注释，你可以显著简化验证逻辑，并将其封装在模型中，而不是将其与任何特定的表单耦合。这种分离确保了验证在应用程序的不同部分中始终如一地强制执行，无论你在什么上下文中使用模型。Blazor有一个内置的**DataAnnotationsValidator**组件，它无缝地将数据注释集成到表单中。**DataAnnotationsValidator**检查应用于模型的属性的数据注释，并产生验证结果，而无需额外的编码。
- en: Let’s convert an explicit validation logic in a form into data annotations and
    leverage Blazor’s native support to handle validation efficiently.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将表单中的显式验证逻辑转换为数据注释，并利用Blazor的本地支持来高效地处理验证。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we encapsulate the validation logic into a separate component:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将验证逻辑封装到单独的组件之前：
- en: Create a **Chapter07** / **Recipe02** directory – this will be your working
    directory
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**Chapter07** / **Recipe02**目录——这将是你的工作目录
- en: Copy **EventManager** and **Event** from the *Adding validation to a form* recipe
    or from the **Chapter07** / **Recipe01** directory in the GitHub repository
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*添加验证到表单*配方或从GitHub仓库中的**Chapter07** / **Recipe01**目录复制**EventManager**和**Event**。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to leverage data annotations for model validation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤利用数据注释进行模型验证：
- en: 'Navigate to the **Event** class and decorate the **Name** property with the
    **Required** attribute with a user-friendly error message. You must reference
    a **System.ComponentModel.DataAnnotations** namespace, but your IDE might include
    it automatically:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Event**类，并使用带有用户友好错误消息的**Required**属性装饰**Name**属性。你必须引用**System.ComponentModel.DataAnnotations**命名空间，但你的IDE可能会自动包含它：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Move to the **EventManager** component and remove the **IDisposable** declaration
    from the top of the file. You should have only a route declaration left.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到**EventManager**组件，并从文件顶部删除**IDisposable**声明。你应该只剩下一个路由声明。
- en: 'In the **EventManager** markup, locate **EditForm** and embed the **DataAnnotationsValidator**
    component just below the submission button:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EventManager** 的标记中，找到 **EditForm** 并将 **DataAnnotationsValidator** 组件嵌入到提交按钮下方：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Jump to the **@code** block of **EventManager** and do some cleanup:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到 **EventManager** 的 **@code** 块并做一些清理：
- en: Remove the subscription to the **OnValidationRequested** event handler from
    the **OnInitialized()** method implementation
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 **OnInitialized()** 方法的实现中移除对 **OnValidationRequested** 事件处理器的订阅
- en: Remove the **Dispose()** and **ValidateForm()** methods entirely
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全移除 **Dispose()** 和 **ValidateForm()** 方法
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we enhance the **Event** class by implementing data annotations
    to enforce input validation. We decorate the **Name** property with the **Required**
    attribute to ensure a user always provides that value. Data annotations also accept
    the **ErrorMessage** parameter, where we can pass in a user-friendly validation
    message, so we extend the **Required** attribute with the **You must provide a
    name.** error message.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们通过实现数据注释来增强 **Event** 类，以强制执行输入验证。我们用 **Required** 属性装饰 **Name**
    属性，以确保用户始终提供该值。数据注释还接受 **ErrorMessage** 参数，我们可以传递一个用户友好的验证消息，因此我们扩展了 **Required**
    属性，并添加了 **您必须提供一个名称** 的错误消息。
- en: In *step 2* , we move to the **EventManager** component. With data annotations
    in place, we no longer need explicit event handling. Consequently, we remove the
    **IDisposable** declaration from the top of the **EventManager** file. In *step
    3* , we enhance the **EventManager** markup and embed the **DataAnnotationsValidator**
    component at the end of **EditForm** , just below the submission button. **DataAnnotationsValidator**
    operates seamlessly within the form, carrying no distinct markup and relying on
    the cascading **EditContext** for validation operations. We placed **DataAnnotationsValidator**
    at the end of the form, but you can put it anywhere as long as it’s within the
    **EditForm** tags. In *step 4* , we update the **@code** block of **EventManager**
    . With data annotations now managing validation, we can simplify the component
    code by removing most of the previously necessary validation logic. We remove
    the **OnValidationRequested** subscription within the **OnInitialized()** method,
    as **DataAnnotationsValidator** now automatically monitors the validation state.
    Following this, we also eliminate the **ValidateForm()** method, as the management
    of the validation message store and error messages has shifted to **DataAnnotationsValidator**
    as well. Lastly, we remove the **Dispose()** method because **EventManager** no
    longer implements the **IDisposable** interface or listens to any events.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们转向 **EventManager** 组件。由于已经设置了数据注释，我们不再需要显式的事件处理。因此，我们从 **EventManager**
    文件的顶部移除 **IDisposable** 声明。在 *步骤 3* 中，我们增强了 **EventManager** 的标记，并在 **EditForm**
    的末尾嵌入 **DataAnnotationsValidator** 组件，紧挨着提交按钮。**DataAnnotationsValidator** 在表单中无缝运行，不带任何特定的标记，并依赖于级联的
    **EditContext** 进行验证操作。我们将 **DataAnnotationsValidator** 放在表单的末尾，但只要它在 **EditForm**
    标签内，您可以将它放在任何位置。在 *步骤 4* 中，我们更新了 **EventManager** 的 **@code** 块。由于数据注释现在管理验证，我们可以通过移除大部分之前必要的验证逻辑来简化组件代码。我们在
    **OnInitialized()** 方法中移除了 **OnValidationRequested** 订阅，因为 **DataAnnotationsValidator**
    现在自动监控验证状态。随后，我们也消除了 **ValidateForm()** 方法，因为验证消息存储和错误消息的管理也已转移到 **DataAnnotationsValidator**。最后，我们移除了
    **Dispose()** 方法，因为 **EventManager** 不再实现 **IDisposable** 接口或监听任何事件。
- en: With these few adjustments, we achieve the same validation scope as in the *Adding
    validation to a form* recipe but with significantly less code!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些少量调整，我们达到了与 *向表单添加验证* 菜谱中相同的验证范围，但代码量显著减少！
- en: There’s more…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With **DataAnnotationsValidator** in place, Blazor can perform two types of
    validation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **DataAnnotationsValidator** 的支持下，Blazor 可以执行两种类型的验证：
- en: The first type is **full-model validation** – Blazor executes when the user
    submits the form. This validation occurs when you click the **Save** button on
    the **EventManager** form. It involves checking every validation rule across all
    fields in the model, ensuring that all data meets the specified criteria before
    the form is processed. As we’re working in the SSR render mode, which has inherently
    limited interactivity, only full-model validation is supported.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种类型是 **全模型验证** – 当用户提交表单时，Blazor 执行。这种验证发生在您点击 **EventManager** 表单上的 **保存**
    按钮时。它涉及检查模型中所有字段的每个验证规则，确保在处理表单之前所有数据都符合指定的标准。由于我们正在使用具有固有有限交互性的 SSR 渲染模式，因此只支持全模型验证。
- en: However, should you opt to render **EventManager** in an interactive mode, **DataAnnotationsValidator**
    can execute another layer of validation – **field validation** . Blazor triggers
    field validation when the user moves the focus away from an individual form field,
    displaying immediate feedback on the input provided in that specific field.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果您选择以交互式模式渲染**EventManager**，**DataAnnotationsValidator**可以执行另一层验证——**字段验证**。当用户将焦点从单个表单字段移开时，Blazor会触发字段验证，并立即显示该特定字段中提供的输入的反馈。
- en: Implementing custom validation attributes
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义验证属性
- en: In this recipe, we dive into the flexibility of customizing validation attributes.
    While built-in data annotations simplify validation logic, they cover only the
    most commonly used validation rules. You might find yourself missing the coverage
    for your specific needs. Fortunately, you can implement custom data validation
    attributes with unique rules beyond the standard validations provided by .NET.
    Additionally, Blazor’s native **DataAnnotationsValidator** component seamlessly
    integrates with any custom attributes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将深入了解自定义验证属性的灵活性。虽然内置的数据注释简化了验证逻辑，但它们仅覆盖了最常用的验证规则。您可能会发现自己缺少针对特定需求的覆盖。幸运的是，您可以使用独特的规则实现自定义数据验证属性，这些规则超出了.NET提供的标准验证。此外，Blazor的本地**DataAnnotationsValidator**组件可以无缝集成任何自定义属性。
- en: Let’s implement an event name validation attribute that checks whether the user
    provided the event name and scans for any forbidden keywords.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个事件名称验证属性，该属性检查用户是否提供了事件名称，并扫描任何禁止的关键字。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we implement a custom validation attribute, do the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现自定义验证属性之前，请执行以下操作：
- en: Create a **Chapter07** / **Recipe03** directory – this will be your working
    directory
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter07** / **Recipe03**目录——这将成为您的工作目录
- en: Copy **EventManager** and **Event** from the *Leveraging data annotations for
    form validation* recipe or from the **Chapter07** / **Recipe02** directory in
    the GitHub repository
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“利用数据注释进行表单验证”菜谱或从GitHub仓库中的**Chapter07** / **Recipe02**目录复制**EventManager**和**Event**。
- en: How to do it…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these instructions to implement a custom validation attribute:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明实现自定义验证属性：
- en: 'Create a new **EventNameValidationAttribute** class that inherits from a **ValidationAttribute**
    class. You must reference the **System.ComponentModel.DataAnnotations** assembly,
    but your IDE might include it automatically:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**EventNameValidationAttribute**类，该类继承自**ValidationAttribute**类。您必须引用**System.ComponentModel.DataAnnotations**程序集，但您的IDE可能自动包含它：
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the **EventNameValidationAttribute** class, declare a private variable,
    **_forbidden** , and initialize it with the **event** value:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventNameValidationAttribute**类内部，声明一个私有变量**_forbidden**，并用**event**值初始化它：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Below the **_forbidden** variable, implement a **Failure()** method that accepts
    **message** and **member** parameters and returns an instance of **ValidationResult**
    :'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**_forbidden**变量下方，实现一个**Failure()**方法，该方法接受**message**和**member**参数，并返回一个**ValidationResult**实例：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Complete the implementation of **EventNameValidationAttribute** by overriding
    the **IsValid()** method, which returns a **ValidationResult** object. Return
    the result of **Failure()** invocation if the incoming **value** was not provided
    or it contains the **_forbidden** keyword. Otherwise, return the default **ValidationResult.Success**
    :'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重写**IsValid()**方法完成**EventNameValidationAttribute**的实现，该方法返回一个**ValidationResult**对象。如果传入的**value**未提供或包含**_forbidden**关键字，则返回**Failure()**调用的结果。否则，返回默认的**ValidationResult.Success**：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Navigate to the **Event** class and update the decoration of the **Name** property
    by replacing the existing **Required** attribute with the newly implemented **EventNameValidation**
    attribute:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Event**类，并通过用新实现的**EventNameValidation**属性替换现有的**Required**属性来更新**Name**属性的装饰：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we create an **EventNameValidationAttribute** class, inheriting
    from **ValidationAttribute** . The **ValidationAttribute** class is a base class
    for validation attributes, providing a framework for implementing custom validation
    rules in .NET applications. It allows for defining specific conditions that data
    must meet before being processed further. In *step 2* , we declare a **_forbidden**
    variable within our custom validation attribute class to store the forbidden keyword
    to check against the input value. In *step 3* , we implement a **Failure()** method
    that accepts the **message** and **member** parameters. **Failure()** creates
    and returns an instance of **ValidationResult** , representing a failure in validation.
    The **member** parameter allows associating the error message with specific fields,
    enhancing the clarity of feedback provided to the user.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们创建了一个**EventNameValidationAttribute**类，继承自**ValidationAttribute**。**ValidationAttribute**类是验证属性的基类，为在.NET应用程序中实现自定义验证规则提供了一个框架。它允许定义数据在进一步处理之前必须满足的特定条件。在*步骤
    2*中，我们在自定义验证属性类中声明了一个**_forbidden**变量，用于存储要检查的禁止关键字。在*步骤 3*中，我们实现了一个接受**message**和**member**参数的**Failure()**方法。**Failure()**创建并返回一个**ValidationResult**实例，表示验证失败。**member**参数允许将错误消息与特定字段关联，从而增强提供给用户的反馈的清晰度。
- en: In *step 4* , we implement the custom validation logic by overriding the **IsValid()**
    method from the **ValidationAttribute** class. Blazor triggers **IsValid()** when
    it validates the form model. We choose to override the overload that returns a
    **ValidationResult** object rather than a simple **bool** , as we want to provide
    detailed feedback on validation issues. We first convert the incoming **value**
    to a **text** variable. If **text** doesn’t carry a meaningful value, we call
    the **Failure()** method to return a validation error with the message **You must
    provide a name.** . But **Failure()** also requires providing a **member** name.
    The **IsValid()** method accepts another parameter of type **ValidationContext**
    , which provides context about the validation operation, including **MemberName**
    identifying the validated field. With **MemberName** , we can conform to the **Failure()**
    method signature. We then check whether **text** contains the **_forbidden** keyword,
    ignoring case and culture differences. If the forbidden keyword is found, we invoke
    **Failure()** again with the message **You mustn’t use the ‘event’ keyword.**
    . Lastly, if all checks pass successfully, we return **ValidationResult.Success**
    – a success indicator encapsulated inside the **ValidationResult** class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，我们通过重写来自**ValidationAttribute**类的**IsValid()**方法来实现自定义验证逻辑。当Blazor验证表单模型时，它会触发**IsValid()**方法。我们选择重写返回**ValidationResult**对象的重载，而不是简单的**bool**，因为我们希望提供有关验证问题的详细反馈。我们首先将传入的**value**转换为**text**变量。如果**text**不包含有意义的值，我们调用**Failure()**方法返回一个包含消息**您必须提供名称。**的验证错误。但**Failure()**还需要提供**member**名称。**IsValid()**方法接受另一个类型为**ValidationContext**的参数，它提供了有关验证操作的上下文信息，包括**MemberName**标识验证的字段。有了**MemberName**，我们可以符合**Failure()**方法的签名。然后我们检查**text**是否包含**_forbidden**关键字，忽略大小写和文化差异。如果找到禁止的关键字，我们再次调用**Failure()**，并带有消息**您不能使用‘event’关键字。**。最后，如果所有检查都成功通过，我们返回**ValidationResult.Success**
    - 一个封装在**ValidationResult**类中的成功指示符。
- en: In *step 5* , we navigate to the **Event** class and replace the existing **Required**
    attribute on the **Name** property with our newly created **EventNameValidation**
    attribute. Thanks to code generators and the C# and Blazor compilers, we can reference
    custom attributes using the class name without the **Attribute** suffix.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，我们导航到**Event**类，并将**Name**属性上现有的**Required**属性替换为我们新创建的**EventNameValidation**属性。多亏了代码生成器和C#以及Blazor编译器，我们可以使用类名而不是**Attribute**后缀来引用自定义属性。
- en: 'Now, we validate not only whether the user provides the event name but also
    whether they use the forbidden keyword:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅验证用户是否提供了事件名称，还验证他们是否使用了禁止的关键字：
- en: '![Figure 7.2: Validation message when user submits a value containing a forbidden
    keyword](img/B22020_07_2.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：用户提交包含禁止关键字的值时的验证消息](img/B22020_07_2.jpg)'
- en: 'Figure 7.2: Validation message when user submits a value containing a forbidden
    keyword'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：用户提交包含禁止关键字的值时的验证消息
- en: There’s more…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When building multilingual applications, you might need to translate user-friendly
    error messages. Additionally, with continuous delivery trends, you may need to
    conditionally enable validation rules based on feature flags or application settings.
    You will require access to the dependency injection container to support such
    advanced scenarios. While in a class based on **ValidationAttribute** , you can
    reach dependency injection through the **ValidationContext** parameter, which
    encapsulates the behavior of **IServiceProvider** and exposes all the standard
    dependency injection methods available in .NET.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建多语言应用程序时，你可能需要翻译用户友好的错误消息。此外，随着持续交付趋势的发展，你可能需要根据功能标志或应用程序设置有条件地启用验证规则。你需要访问依赖注入容器以支持这样的高级场景。在基于
    **ValidationAttribute** 的类中，你可以通过 **ValidationContext** 参数访问依赖注入，该参数封装了 **IServiceProvider**
    的行为，并公开了 .NET 中所有标准依赖注入方法。
- en: 'For example, assuming that you’ve registered an **Api** service in the service
    container, you can inject this dependency within your attribute in the following
    way:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在服务容器中注册了一个 **Api** 服务，你可以在以下方式中注入这个依赖项到你的属性中：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We override the **IsValid()** method, inherited from the **ValidationAttribute**
    class, and we get an instance of **ValidationContext** . As **ValidationContext**
    implements the **IServiceProvider** interface, we leverage the built-in generic
    **GetRequiredService()** extension method to retrieve an instance of our **Api**
    service.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了从 **ValidationAttribute** 类继承而来的 **IsValid()** 方法，并获取了一个 **ValidationContext**
    实例。由于 **ValidationContext** 实现了 **IServiceProvider** 接口，我们利用内置的泛型 **GetRequiredService()**
    扩展方法来检索我们的 **Api** 服务实例。
- en: It’s important to note that custom validation attributes in .NET do not support
    asynchronous validation. This limitation is crucial to consider when designing
    your validation strategy to ensure performance and user experience are not adversely
    affected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在 .NET 中自定义验证属性不支持异步验证。在设计验证策略时，考虑这一限制至关重要，以确保性能和用户体验不受负面影响。
- en: Validating complex data models
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证复杂数据模型
- en: In this recipe, we tackle the validation of complex forms and data models. Having
    well-structured and modularized code makes the code base easier to maintain and
    reduces the likelihood of errors by clearly defining and isolating each component’s
    responsibilities. In forms, complex models segment the data into manageable parts,
    each with its validation logic, making it easier to maintain the overall form’s
    state and ensuring each segment adheres to specific business rules. The **Microsoft.AspNetCore.Components.DataAnnotations.Validation**
    package, although experimental, exposes Blazor-native validators and offers enhanced
    data annotations that integrate smoothly with complex models.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们处理复杂表单和数据模型的验证。拥有结构良好和模块化的代码使得代码库更容易维护，并通过明确定义和隔离每个组件的责任来降低出错的可能性。在表单中，复杂模型将数据分割成可管理的部分，每个部分都有其验证逻辑，这使得维护整个表单的状态更容易，并确保每个部分都遵循特定的业务规则。虽然
    **Microsoft.AspNetCore.Components.DataAnnotations.Validation** 包是实验性的，但它公开了 Blazor
    原生的验证器，并提供了与复杂模型无缝集成的增强数据注释。
- en: Let’s extend the event creation form to include a nested object that encapsulates
    details about the event location.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展事件创建表单，以包含一个封装事件位置详细信息的嵌套对象。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we set up nested, complex model validation, do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置嵌套的复杂模型验证之前，执行以下操作：
- en: Create a **Chapter07** / **Recipe04** directory – this will be your working
    directory
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter07** / **Recipe04** 目录 – 这将是你的工作目录。
- en: Copy **EventManager** , **Event** , and **EventNameValidationAttribute** from
    the *Implementing custom validation attributes* recipe or from the **Chapter07**
    / **Recipe03** directory in the GitHub repository
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *实现自定义验证属性* 菜谱或从 GitHub 仓库中的 **Chapter07** / **Recipe03** 目录复制 **EventManager**、**Event**
    和 **EventNameValidationAttribute**。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to enable validation of the nested model:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤启用嵌套模型的验证：
- en: 'Add a reference to the **Microsoft.AspNetCore.Components.DataAnnotations.Validation**
    package to your project file:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件中添加对 **Microsoft.AspNetCore.Components.DataAnnotations.Validation** 包的引用：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new **EventLocation** class and define two properties within it –
    **Venue** and **Capacity** :'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **EventLocation** 类，并在其中定义两个属性 – **Venue** 和 **Capacity** ：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Apply the **Required** attribute to the **Venue** property and include a meaningful
    error message when a user leaves the field blank:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Required**属性应用于**Venue**属性，并在用户留空字段时包含一个有意义的错误信息：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the **Capacity** property, decorate it with both the **Required** and **Range**
    attributes and provide a meaningful error message to ensure the user inputs only
    valid capacity values:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Capacity**属性，使用**Required**和**Range**属性进行装饰，并提供一个有意义的错误信息，以确保用户只输入有效的容量值：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Navigate to the **Event** class and add a new **Location** property. Decorate
    **Location** with a **ValidateComplexType** attribute:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Event**类，并添加一个新的**Location**属性。使用**ValidateComplexType**属性装饰**Location**：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the **EventManager** component, locate **EditForm** within the markup.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventManager**组件中，在标记中定位**EditForm**。
- en: 'Inside **EditForm** , directly below the input field for **Name** , add a new
    paragraph with an **InputText** component bound to the **Model.Location.Venue**
    property:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EditForm**中，在**Name**输入字段下方直接添加一个新段落，包含一个绑定到**Model.Location.Venue**属性的**InputText**组件：
- en: '[PRE25]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Below the **Venue** input field, add another paragraph containing an **InputNumber**
    component bound to the **Model.Location.Capacity** property:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Venue**输入字段下方，添加另一个包含绑定到**Model.Location.Capacity**属性的**InputNumber**组件的段落：
- en: '[PRE26]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Still within **EditForm** , replace the existing **ValidationMessage** for
    the **Model.Name** property with **ValidationSummary** :'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**EditForm**中，将现有的**Model.Name**属性的**ValidationMessage**替换为**ValidationSummary**：
- en: '[PRE27]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, swap out the **DataAnnotationsValidator** component for **ObjectGraphDataAnnotationsValidator**
    :'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**DataAnnotationsValidator**组件替换为**ObjectGraphDataAnnotationsValidator**：
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we open the **csproj** file of our project and add a reference
    to the **Microsoft.AspNetCore.Components.DataAnnotations.Validation** package
    that contains all the extensions required for seamless validation of complex,
    nested data models.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们打开我们项目的**csproj**文件，并添加对包含所有必需扩展以实现复杂、嵌套数据模型无缝验证的**Microsoft.AspNetCore.Components.DataAnnotations.Validation**包的引用。
- en: Next, in *step 2* , we create a new **EventLocation** class with the **Venue**
    and **Capacity** properties, representing event location details. In *step 3*
    , we decorate the **Venue** property with a **Required** attribute to ensure that
    users cannot submit the form without filling in the venue description. Should
    they forget to enter a **Venue** value, they will see a **You must provide a venue.**
    validation message to guide them. In *step 4* , we add validation to the **Capacity**
    property by applying both the **Required** and **Range** attributes. We enforce
    that users fill the capacity value and that it falls within a specified range
    (1 to 1,000). Users will receive a **Capacity must be between 1 and 1000.** error
    message if they enter a value outside the declared range.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*步骤 2*中，我们创建一个新的**EventLocation**类，包含**Venue**和**Capacity**属性，表示活动位置详情。在*步骤
    3*中，我们使用**Required**属性装饰**Venue**属性，以确保用户在提交表单前必须填写场地描述。如果他们忘记输入**Venue**值，他们将看到一个**您必须提供场地**的验证消息来引导他们。在*步骤
    4*中，我们通过应用**Required**和**Range**属性对**Capacity**属性添加验证。我们强制用户填写容量值，并确保它位于指定的范围内（1到1,000）。如果用户输入超出声明范围的值，他们将收到**容量必须在1到1000之间**的错误消息。
- en: For *step 5* , we turn to the **Event** class and extend it with a new property
    – **Location** , of type **EventLocation** . To ensure Blazor understands that
    this property represents a complex type requiring nested validation, we decorate
    it with the **ValidateComplexType** attribute. **ValidateComplexType** comes with
    the **Microsoft.AspNetCore.Components.DataAnnotations.Validation** package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*步骤 5*，我们转向**Event**类，并扩展它以添加一个新的属性——**Location**，类型为**EventLocation**。为了确保Blazor理解这个属性代表一个需要嵌套验证的复杂类型，我们使用**ValidateComplexType**属性进行装饰。**ValidateComplexType**包含在**Microsoft.AspNetCore.Components.DataAnnotations.Validation**包中。
- en: In *step 6* , we proceed to the **EventManager** component and locate the existing
    **EditForm** within the markup. We will extend the form to include fields for
    entering the event location details. In *step 7* , we embed a new paragraph just
    below the **Name** field where we insert an **InputText** component bound to **Model.Location.Venue**
    to allow users to input the venue details. In *step 8* , we add another paragraph,
    this time incorporating an **InputNumber** component bound to **Model.Location.Capacity**
    to allow users to specify the spots available in a given venue. In *step 9* ,
    aiming to streamline the display of validation messages, we replace the **ValidationMessage**
    component previously dedicated to the **Name** property with a **ValidationSummary**
    instance. The **ValidationSummary** component consolidates all form validation
    messages into one area. Finally, in *step 10* , we enhance our validation setup
    by replacing the standard **DataAnnotationsValidator** with **ObjectGraphDataAnnotationsValidator**
    . The **ObjectGraphDataAnnotationsValidator** component is an advanced component
    capable of validating nested object graphs, allowing Blazor to trigger validation
    on every part of our complex **Event** model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 6* 中，我们进入 **EventManager** 组件，并在标记中找到现有的 **EditForm**。我们将扩展表单以包含输入事件位置详情的字段。在
    *步骤 7* 中，我们在 **Name** 字段下方嵌入一个新的段落，在那里插入一个绑定到 **Model.Location.Venue** 的 **InputText**
    组件，以允许用户输入场地详情。在 *步骤 8* 中，我们添加另一个段落，这次包含一个绑定到 **Model.Location.Capacity** 的 **InputNumber**
    组件，以允许用户指定特定场地的可用位置。在 *步骤 9* 中，为了简化验证消息的显示，我们将之前专门用于 **Name** 属性的 **ValidationMessage**
    组件替换为 **ValidationSummary** 实例。**ValidationSummary** 组件将所有表单验证消息合并到一个区域。最后，在 *步骤
    10* 中，我们通过将标准的 **DataAnnotationsValidator** 替换为 **ObjectGraphDataAnnotationsValidator**
    来增强我们的验证设置。**ObjectGraphDataAnnotationsValidator** 组件是一个高级组件，能够验证嵌套的对象图，允许 Blazor
    在我们复杂的 **Event** 模型的每个部分触发验证。
- en: There’s more…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'When working with Blazor’s built-in input components, you get an additional
    layer of flexibility. Any default input component, inheriting from the **InputBase**
    class, such as the **InputNumber** component we’ve used in this recipe, automatically
    intercepts any unmatched parameters and attaches them directly to the underlying
    HTML **input** element as attributes. With that, you can easily enhance the **InputNumber**
    component used for **Model.Location.Capacity** by declaring **min** and **max**
    attributes and disallowing users from manually increasing or decreasing the value
    beyond the specified range:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Blazor 的内置输入组件时，你将获得额外的灵活性。任何默认输入组件，如我们在这个菜谱中使用的 **InputNumber** 组件，它继承自
    **InputBase** 类，会自动拦截任何不匹配的参数，并将它们直接作为属性附加到底层的 HTML **input** 元素上。有了这个功能，你可以轻松地通过声明
    **min** 和 **max** 属性并禁止用户手动增加或减少值超出指定范围来增强用于 **Model.Location.Capacity** 的 **InputNumber**
    组件：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By adding **min** and **max** attributes to the **InputNumber** component in
    the form and declaring their values to **1** and **1000** , respectively, we ensure
    users won’t be able to reduce the value in the input below **1** nor increment
    it above **1000** . They can still type an invalid value by hand, but they’ll
    trigger validation on the model properties. Following that example, you can leverage
    any other HTML input attributes you’re familiar with.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在表单中的 **InputNumber** 组件上添加 **min** 和 **max** 属性，并将它们的值分别声明为 **1** 和 **1000**，我们确保用户无法将输入值降低到
    **1** 以下或增加到 **1000** 以上。他们仍然可以手动输入一个无效的值，但它们会在模型属性上触发验证。按照这个例子，你可以利用你熟悉的任何其他
    HTML 输入属性。
- en: Styling validation messages
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式验证消息
- en: In this recipe, we explore the styling of form validation in Blazor. You’ve
    probably noticed in previous recipes that Blazor automatically applies validation
    classes to form fields during validation. Default validation CSS classes align
    with default Bootstrap styles, where invalid fields get a red accent and valid
    ones get a green accent. While the default settings increase the delivery velocity,
    in most cases, you will still have to customize the visual feedback to suit your
    application branding or functional requirements. Fortunately, Blazor allows customizing
    styling and classes appended to fields upon validation. This customization maintains
    the integrity of your application’s modular and loosely coupled architecture,
    ensuring that enhancements do not compromise the maintainability of your code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们探讨了 Blazor 中表单验证的样式。你可能已经注意到，在之前的菜谱中，Blazor 在验证过程中会自动将验证类应用到表单字段上。默认验证
    CSS 类与默认 Bootstrap 样式相匹配，无效字段会得到红色强调，有效字段会得到绿色强调。虽然默认设置提高了交付速度，但在大多数情况下，你仍然需要自定义视觉反馈以适应你的应用程序品牌或功能需求。幸运的是，Blazor
    允许自定义在验证字段时附加的样式和类。这种自定义保持了应用程序模块化和松散耦合架构的完整性，确保增强不会损害代码的可维护性。
- en: Let’s implement a custom validation class provider, making Blazor mark missing
    labels in red while missing location capacity in yellow.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个自定义验证类提供者，使 Blazor 在红色中标记缺失的标签，在黄色中标记缺失的位置容量。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before implementing a custom validation class provider, do the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现自定义验证类提供者之前，请执行以下操作：
- en: Create a **Chapter07** / **Recipe05** directory – this will be your working
    directory
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter07** / **Recipe05** 目录 - 这将是你的工作目录。
- en: Copy **Event** , **EventLocation** , **EventManager** , and **EventNameValidationAttribute**
    from the *Validating complex data models* recipe or from the **Chapter07** / **Recipe04**
    directory in the GitHub repository
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *Validating complex data models* 菜谱或从 GitHub 仓库中的 **Chapter07** / **Recipe04**
    目录复制 **Event**、**EventLocation**、**EventManager** 和 **EventNameValidationAttribute**。
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following steps to add a custom validation class provider:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以添加自定义验证类提供者：
- en: Add a new **EventManager.razor.css** file to the working directory. Your IDE
    might automatically nest that CSS file under **EventManager.razor** .
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作目录中添加一个新的 **EventManager.razor.css** 文件。你的 IDE 可能会自动将此 CSS 文件嵌套在 **EventManager.razor**
    之下。
- en: 'Within **EventManager.razor.css** , define an **invalid-warning** style class
    that adds an orange outline to any element we apply it to:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EventManager.razor.css** 中，定义一个 **invalid-warning** 样式类，为应用此类的任何元素添加橙色轮廓：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new **TypeValidationClassProvider** class, inheriting from **FieldCssClassProvider**
    available under the **Microsoft.AspNetCore.Components.Forms** namespace:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **TypeValidationClassProvider** 类，从 **Microsoft.AspNetCore.Components.Forms**
    命名空间下的 **FieldCssClassProvider** 继承：
- en: '[PRE31]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In **TypeValidationClassProvider** , declare a private **_capacity** field
    holding the name of the **Capacity** property from the **EventLocation** class:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **TypeValidationClassProvider** 中，声明一个私有的 **_capacity** 字段，该字段包含来自 **EventLocation**
    类的 **Capacity** 属性的名称：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To finalize the implementation of **TypeValidationClassProvider** , override
    the **GetFieldCssClass()** method and implement logic to return the **invalid-warning**
    class when the current field’s value is invalid and corresponds to the **_capacity**
    property; otherwise, fall back to the **base** implementation:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要最终实现 **TypeValidationClassProvider**，重写 **GetFieldCssClass()** 方法并实现逻辑，当当前字段的值无效且对应于
    **_capacity** 属性时返回 **invalid-warning** 类；否则，回退到 **base** 实现：
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Navigate to the **EventManager** component and find the **OnInitialized()**
    method. After the existing setup, use the **SetFieldCssClassProvider()** extension
    method of **EditContext** and attach **TypeValidationClassProvider** to **Context**
    :'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **EventManager** 组件，找到 **OnInitialized()** 方法。在现有设置之后，使用 **EditContext**
    的 **SetFieldCssClassProvider()** 扩展方法将 **TypeValidationClassProvider** 附加到 **Context**：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 1* , we add a new CSS file to our working directory, specifically naming
    it **EventManager.razor.css** to adhere to the CSS isolation requirements and
    match the name of the component it will style. In Blazor, **CSS isolation** allows
    styles defined in a component-specific CSS file to affect only that component,
    preventing styles from leaking. If you enable the file nesting in your IDE, you
    will see isolated CSS files wrapped under the parent component file. In *step
    2* , within **EventManager.razor.css** , we introduce a **.invalid-warning** class,
    which applies an orange outline to fields we attach it to. We use the **::deep**
    combinator to ensure that styling penetrates DOM-like encapsulations and affects
    nested components.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们在工作目录中添加一个新的 CSS 文件，具体命名为**EventManager.razor.css**，以符合 CSS 隔离要求，并匹配将要为其添加样式的组件名称。在
    Blazor 中，**CSS 隔离**允许在特定组件的 CSS 文件中定义的样式只影响该组件，防止样式泄露。如果你在 IDE 中启用了文件嵌套，你会看到隔离的
    CSS 文件被包裹在父组件文件之下。在**步骤 2**中，在**EventManager.razor.css**中，我们引入了一个**.invalid-warning**类，它将橙色轮廓应用于我们附加到其上的字段。我们使用**::deep**组合符来确保样式能够穿透类似
    DOM 的封装并影响嵌套组件。
- en: In *step 3* , we initiate our custom validation class provider by creating a
    new **TypeValidationClassProvider** class, which inherits from **FieldCssClassProvider**
    . The **FieldCssClassProvider** class provides the necessary API to customize
    CSS classes that Blazor applies based on field validation states. In *step 4*
    , we persist the name of the **Capacity** field in a **_capacity** variable within
    **TypeValidationClassProvider** . By declaring it as **private** and **static**
    , we ensure that this value remains unchanged and consumes minimal memory throughout
    the application’s life cycle, effectively becoming a singleton instance. In *step
    5* , we complete our custom provider by overriding the **GetFieldCssClass()**
    method, which Blazor calls whenever it needs to determine the appropriate CSS
    class based on the validation state of a field. In our implementation, we first
    check whether the field’s current state is valid and its name matches the **_capacity**
    value. If the field is invalid and refers to the capacity, we return **invalid-warning**
    , instructing Blazor to apply the orange outline to highlight the error. Otherwise,
    we default to the base implementation by returning the result of the **base.GetFieldCssClass()**
    call, preserving standard behavior for other fields.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 3**中，我们通过创建一个新的**TypeValidationClassProvider**类来初始化我们的自定义验证类提供者，该类继承自**FieldCssClassProvider**。**FieldCssClassProvider**类提供了必要的
    API 来自定义 Blazor 根据字段验证状态应用的 CSS 类。在**步骤 4**中，我们在**TypeValidationClassProvider**中持久化**Capacity**字段的名称到一个名为**_capacity**的变量中。通过将其声明为**private**和**static**，我们确保这个值在整个应用程序的生命周期中保持不变，并消耗最少的内存，从而有效地成为一个单例实例。在**步骤
    5**中，我们通过重写**GetFieldCssClass()**方法来完成我们的自定义提供者，Blazor 在需要根据字段的验证状态确定适当的 CSS 类时调用此方法。在我们的实现中，我们首先检查字段的当前状态是否有效，并且其名称是否与**_capacity**值匹配。如果字段无效并且引用的是容量，我们返回**invalid-warning**，指示
    Blazor 应用橙色轮廓以突出显示错误。否则，我们默认返回基实现，通过返回**base.GetFieldCssClass()**调用的结果，保留其他字段的常规行为。
- en: Finally, in *step 6* , we jump to the **EventManager** component and locate
    the overridden **OnInitialized()** life cycle method, where we initialize the
    **Context** variable. After the initial configurations, we utilize the **SetFieldCssClassProvider()**
    extension method of **EditContext** to configure **Context** to employ our **TypeValidationClassProvider**
    for resolving CSS classes based on field validation. Our custom styling logic
    is now in place.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在**步骤 6**中，我们跳转到**EventManager**组件并定位到重写的**OnInitialized()**生命周期方法，在那里我们初始化**Context**变量。在初始配置之后，我们利用**EditContext**的**SetFieldCssClassProvider()**扩展方法来配置**Context**，使其使用我们的**TypeValidationClassProvider**来根据字段验证解决
    CSS 类。我们的自定义样式逻辑现在已经就绪。
- en: There’s more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: We’ve implemented a custom CSS validation class and leveraged the CSS isolation
    feature that Blazor offers. However, if you have already integrated a CSS framework
    into your application, you can simply use the validation classes the framework
    provides instead of creating custom ones.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个自定义 CSS 验证类，并利用了 Blazor 提供的 CSS 隔离功能。然而，如果你已经将 CSS 框架集成到你的应用程序中，你可以简单地使用框架提供的验证类，而不是创建自定义的类。
- en: 'Bootstrap, being the most common CSS framework to date, offers **border** and
    **border-warning** CSS classes, which you can use to highlight invalid input fields.
    Navigate to **TypeValidationClassProvider** and update the **GetFieldCssClass()**
    implementation as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 作为目前最常用的 CSS 框架，提供了 **border** 和 **border-warning** CSS 类，您可以使用这些类来突出显示无效的输入字段。导航到
    **TypeValidationClassProvider** 并更新 **GetFieldCssClass()** 实现如下：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The custom validation logic remains intact – we still check whether the validation
    context is valid and whether the validated field refers to the capacity. However,
    when the custom validation fails, instead of returning the custom warning class,
    we leverage the **border border-warning** classes combination and effectively
    delegate the styling to Bootstrap.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义验证逻辑保持不变——我们仍然检查验证上下文是否有效以及验证的字段是否引用容量。然而，当自定义验证失败时，我们不是返回自定义警告类，而是利用 **border
    border-warning** 类的组合，并将样式委托给 Bootstrap。
- en: Displaying a toast when validation fails
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证失败时显示 toast
- en: In this recipe, we explore how to enhance form validation feedback with a custom
    display of validation errors. Blazor’s **ValidationSummary** component provides
    a straightforward way to collect and display all validation messages from a form
    in a single container, typically rendered as a simple **div** . While functional,
    this default presentation might not always align with a desired user experience
    or the aesthetic standards of your application. You can replace the standard **ValidationSummary**
    component with a custom implementation to make validation messages more engaging
    and fit seamlessly with the broader notification strategy of your application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们探讨了如何通过自定义显示验证错误来增强表单验证反馈。Blazor 的 **ValidationSummary** 组件提供了一个简单的方法来收集和显示表单中的所有验证消息，通常在一个简单的
    **div** 中渲染。虽然功能性强，但这种默认的展示可能并不总是符合期望的用户体验或应用程序的美学标准。您可以用自定义实现替换标准 **ValidationSummary**
    组件，使验证消息更具吸引力，并与应用程序更广泛的通知策略无缝结合。
- en: Let’s implement a custom component that displays validation errors inside a
    default Bootstrap toast, making a more modern version of **ValidationSummary**
    .
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个自定义组件，该组件在默认的 Bootstrap toast 中显示验证错误，从而创建一个更现代版本的 **ValidationSummary**。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before diving into the implementation of a custom validation summary, do the
    following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现自定义验证摘要之前，请执行以下操作：
- en: Create a **Chapter07** / **Recipe06** directory – this will be your working
    directory
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter07** / **Recipe06** 目录——这将是你的工作目录
- en: Copy **Event** , **EventLocation** , **EventManager** , **EventNameValidationAttribute**
    , and **TypeValidationClassProvider** from the *Styling validation messages* recipe
    or from the **Chapter07** / **Recipe05** directory in the GitHub repository
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *Styling validation messages* 菜单或从 GitHub 仓库中的 **Chapter07** / **Recipe05**
    目录复制 **Event**、**EventLocation**、**EventManager**、**EventNameValidationAttribute**
    和 **TypeValidationClassProvider**。
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to introduce a custom validation summary:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤引入自定义验证摘要：
- en: 'Create a **ValidationToast** component that implements the **IDisposable**
    interface:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现 **IDisposable** 接口的 **ValidationToast** 组件：
- en: '[PRE36]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside the **@code** block of the **ValidationToast** component, declare a
    **CascadingParameter** parameter of type **EditContext** and an **IsDisplayed**
    property:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ValidationToast** 组件的 **@code** 块内部，声明一个类型为 **EditContext** 的 **CascadingParameter**
    参数和一个 **IsDisplayed** 属性：
- en: '[PRE37]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Still within the **@code** block, implement a **Rerender()** method, matching
    the signature of a subscriber of an **EventHandler<ValidationStateChangedEventArgs>**
    handler:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **@code** 块内部，实现一个 **Rerender()** 方法，该方法与 **EventHandler<ValidationStateChangedEventArgs>**
    处理程序的订阅者签名相匹配：
- en: '[PRE38]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside **Rerender()** , set the **IsDisplayed** property based on whether there
    are any validation messages in **Context** and invoke the **StateHasChanged()**
    to trigger a UI refresh:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Rerender()** 内部，根据 **Context** 中是否有任何验证消息来设置 **IsDisplayed** 属性，并调用 **StateHasChanged()**
    以触发 UI 刷新：
- en: '[PRE39]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Below **Rerender()** , override the **OnInitialized()** life cycle method and
    subscribe to the **OnValidationStateChanged** event of **EditContext** :'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Rerender()** 下方，重写 **OnInitialized()** 生命周期方法并订阅 **EditContext** 的 **OnValidationStateChanged**
    事件：
- en: '[PRE40]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Complete the **@code** block by implementing the **Dispose()** method and unsubscribe
    from the **OnValidationStateChanged** event:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现 **Dispose()** 方法并在 **OnValidationStateChanged** 事件上取消订阅来完成 **@code** 块：
- en: '[PRE41]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the **ValidationToast** markup, below the **@implements** directive, include
    a fast-return clause to prevent any markup rendering based on the **IsDisplayed**
    value:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ValidationToast**标记中，在**@implements**指令下方包含一个快速返回语句，以防止根据**IsDisplayed**值进行任何标记渲染：
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Below the fast-return clause, construct a frame of a default Bootstrap toast
    notification:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在快速返回语句下方，构建一个默认的Bootstrap toast通知的框架：
- en: '[PRE43]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Within the toast area, add an empty header for aesthetics, and in the toast
    body, implement logic to dynamically render the list of validation messages retrieved
    from **EditContext** :'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在toast区域中，添加一个空标题以增强美观，并在toast正文中实现逻辑以动态渲染从**EditContext**检索到的验证消息列表：
- en: '[PRE44]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Navigate to the **EventManager** component, above the form submit button, and
    remove the existing **ValidationSummary** paragraph. Replace it with an instance
    of the new **ValidationToast** component:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到表单提交按钮上方的**EventManager**组件，并移除现有的**ValidationSummary**段落。用新的**ValidationToast**组件实例替换它：
- en: '[PRE45]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create a new **ValidationToast** component that implements
    the **IDisposable** interface to ensure a proper resource clean-up as we will
    work with an event handler.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们创建了一个新的**ValidationToast**组件，该组件实现了**IDisposable**接口以确保在处理事件处理程序时进行适当的资源清理。
- en: From *step 2* , we work on the **@code** block of the **ValidationToast** component.
    We declare a **CascadingParameter** parameter of type **EditContext** to gain
    access to the parent form’s context. We also declare an **IsDisplayed** property,
    which will help us control the visibility of the toast based on validation results.
    In *step 3* , we initialize a **Rerender** method, accepting the **sender** parameter
    and **args** of type **ValidationStateChangedEventArgs** , so we can subscribe
    it later to a matching **EventHandler** . In *step 4* , we implement the **Rerender**
    logic, where we determine whether there are any validation messages in the **Context**
    instance and set the **IsDisplayed** property, indicating that there are errors
    to display. We then invoke **StateHasChanged()** to prompt Blazor to refresh the
    UI and reflect the updated state. In *step 5* , we override the **OnInitialized()**
    life cycle method to subscribe the **Rerender()** method to the **OnValidationStateChanged**
    event of **EditContext** . Blazor will execute **Rerender()** every time the form’s
    validation state changes, allowing our toast notification to update reactively.
    In *step 6* , we implement the **Dispose()** method, where we unsubscribe from
    the **OnValidationStateChanged** event, ensuring that **ValidationToast** does
    not continue to react to events after it has been removed from the UI, thus preventing
    memory leaks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从**步骤 2**开始，我们处理**ValidationToast**组件的**@code**块。我们声明一个类型为**EditContext**的**CascadingParameter**参数，以便访问父表单的上下文。我们还声明了一个**IsDisplayed**属性，这将帮助我们根据验证结果控制toast的可见性。在**步骤
    3**中，我们初始化一个接受**sender**参数和**args**类型为**ValidationStateChangedEventArgs**的**Rerender**方法，以便我们稍后将其订阅到匹配的**EventHandler**。在**步骤
    4**中，我们实现**Rerender**逻辑，其中我们确定**Context**实例中是否有任何验证消息，并设置**IsDisplayed**属性，表示有错误需要显示。然后我们调用**StateHasChanged()**来提示Blazor刷新UI并反映更新的状态。在**步骤
    5**中，我们重写**OnInitialized()**生命周期方法，将**Rerender()**方法订阅到**EditContext**的**OnValidationStateChanged**事件。每当表单的验证状态发生变化时，Blazor将执行**Rerender()**，允许我们的toast通知进行响应式更新。在**步骤
    6**中，我们实现**Dispose()**方法，其中我们取消订阅**OnValidationStateChanged**事件，确保在从UI中移除**ValidationToast**后，它不会继续对事件做出反应，从而防止内存泄漏。
- en: In *step 7* , we focus on the markup of **ValidationToast** . We start below
    the **@implements** directive with a fast-return clause, based on the **IsDisplayed**
    value, which instructs Blazor to immediately exit the rendering process when there
    are no validation messages. In *step 8* , we construct a visual frame using default
    Bootstrap classes to create a toast notification. As it’s standard Bootstrap code,
    we won’t analyze it deeply. Shortly, we position the frame fixed at the bottom
    end of the viewport, ensuring that it is visible but non-intrusive. We also make
    the toast red to clearly indicate that there’s a problem. In *step 9* , we implement
    the toast area. We add an empty header for visual balance and a body where we
    iterate over the result of the **Context.GetValidationMessages()** call and dynamically
    render each validation message.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们关注**ValidationToast**的标记。我们从**@implements**指令下方开始，使用基于**IsDisplayed**值的快速返回语句，该语句指示Blazor在没有验证信息时立即退出渲染过程。在*步骤8*中，我们使用默认的Bootstrap类构建一个视觉框架，以创建Toast通知。由于这是标准的Bootstrap代码，我们不会深入分析它。简而言之，我们将框架固定在视口的底部末端，确保其可见但不会干扰。我们还使Toast显示为红色，以清楚地表明存在问题。在*步骤9*中，我们实现了Toast区域。我们添加了一个空标题以实现视觉平衡，并在主体中迭代**Context.GetValidationMessages()**调用的结果，动态渲染每个验证信息。
- en: Lastly, in *step 10* , we jump to the **EventManager** component. Here, we remove
    the existing **ValidationSummary** paragraph and replace it with the new **ValidationToast**
    component, which now handles the display of validation messages in a more interactive
    and visually engaging manner.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤10*中，我们跳转到**EventManager**组件。在这里，我们移除了现有的**ValidationSummary**段落，并用新的**ValidationToast**组件替换它，现在它以更互动和视觉上吸引人的方式处理验证信息的显示。
- en: 'We arrive at a still simple but more modern validation summary that our users
    will appreciate:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个仍然简单但更现代的验证摘要，我们的用户会喜欢的：
- en: '![Figure 7.3: Toast notification replacing a standard validation summary container](img/B22020_07_3.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：Toast通知替换标准验证摘要容器](img/B22020_07_3.jpg)'
- en: 'Figure 7.3: Toast notification replacing a standard validation summary container'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：Toast通知替换标准验证摘要容器
- en: Enabling a submit option based on the form state
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据表单状态启用提交选项
- en: In this recipe, we dive into a strategy to enhance the user experience by dynamically
    controlling the state of the form’s submit button. We use forms not only when
    creating a new object but also when modifying an existing one as well. It makes
    sense that we would prevent the form submission when a user didn’t make any changes
    or if some input is invalid. Having that feature in place, we improve the user
    experience, conserve memory usage, and reduce unnecessary server requests.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们深入探讨了一种通过动态控制表单提交按钮的状态来提升用户体验的策略。我们不仅在创建新对象时使用表单，在修改现有对象时也使用表单。当用户没有做出任何更改或某些输入无效时，阻止表单提交是有意义的。有了这个功能，我们提升了用户体验，节省了内存使用，并减少了不必要的服务器请求。
- en: Let’s enhance a form with a mechanism that enables form saving only when there
    have been changes to the form data and all inputs are valid.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个机制增强表单，该机制只允许在表单数据发生变化且所有输入都有效时保存表单。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before making the form submit button react to the form state, do the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在使表单提交按钮对表单状态做出反应之前，请执行以下操作：
- en: Create a **Chapter07** / **Recipe07** directory – this will be your working
    directory
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter07** / **Recipe07**目录 - 这将是你的工作目录
- en: Copy **Event** , **EventLocation** , **EventManager** , **EventNameValidationAttribute**
    , **TypeValidationClassProvider** , and **ValidationToast** from the *Displaying
    toast when validation fails* recipe or from the **Chapter07** / **Recipe06** directory
    in the GitHub repository
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*显示验证失败时的Toast*菜谱或从GitHub仓库中的**Chapter07** / **Recipe06**目录复制**Event**、**EventLocation**、**EventManager**、**EventNameValidationAttribute**、**TypeValidationClassProvider**和**ValidationToast**。
- en: How to do it…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to make the form submit button reactive to the form state:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使表单提交按钮对表单状态做出反应：
- en: 'Navigate to the **EventManager** component and update it to implement the **IDisposable**
    interface and to render mode in **InteractiveWebAssembly** :'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**EventManager**组件，并更新它以实现**IDisposable**接口，并在**InteractiveWebAssembly**模式下渲染：
- en: '[PRE46]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Within the **@code** block of **EventManager** , introduce an **IsSubmittable**
    variable of type **bool** :'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventManager**的**@code**块中，引入一个类型为**bool**的**IsSubmittable**变量：
- en: '[PRE47]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Still in the **@code** block, add a **FieldChanged()** method that conforms
    to the **EventHandler<FieldChangedEventArgs>** response pattern and resolve the
    form’s current state into the **IsSubmittable** variable:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **@code** 块中，添加一个符合 **EventHandler<FieldChangedEventArgs>** 响应模式的 **FieldChanged()**
    方法，并将表单的当前状态解析到 **IsSubmittable** 变量中：
- en: '[PRE48]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the **OnInitialized()** method, initiate a default value for the **Model**
    instance to simulate a data-editing scenario:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **OnInitialized()** 方法中，为 **Model** 实例初始化一个默认值以模拟数据编辑场景：
- en: '[PRE49]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'At the end of the **OnInitialized()** method, subscribe the **FieldChanged()**
    method to the **OnFieldChanged** event, exposed by the **EditContext** API:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **OnInitialized()** 方法的末尾，将 **FieldChanged()** 方法订阅到由 **EditContext** API
    提供的 **OnFieldChanged** 事件：
- en: '[PRE50]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Complete the **IDisposable** implementation by adding a **Dispose()** method
    at the end of the **@code** block and unsubscribe **FieldChanged()** from the
    **OnFieldChanged** handler:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **@code** 块的末尾添加一个 **Dispose()** 方法来完成 **IDisposable** 的实现，并从 **OnFieldChanged**
    处理器中取消订阅 **FieldChanged()**：
- en: '[PRE51]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Switch to the **EventManager** markup and locate the submit button. Set the
    button’s **disabled** attribute to the negated value of the **IsSubmittable**
    variable:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 **EventManager** 标记，找到提交按钮。将按钮的 **disabled** 属性设置为 **IsSubmittable** 变量的否定值：
- en: '[PRE52]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we start by enhancing the interactivity of our form located in
    **EventManager** . We configure **EventManager** to render in an **InteractiveWebAssembly**
    mode, enabling component interactivity, and we declare that it will implement
    the **IDisposable** interface allowing a custom cleanup implementation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们首先增强位于 **EventManager** 中的表单的交互性。我们配置 **EventManager** 以 **InteractiveWebAssembly**
    模式渲染，启用组件交互性，并声明它将实现 **IDisposable** 接口，允许自定义清理实现。
- en: In *step 2* , we move to the **@code** block of **EventManager** and declare
    an **IsSubmittable** variable that we will leverage in managing the state of the
    form’s submit button. In *step 3* , we implement a **FieldChanged()** method that
    takes the **sender** and **args** parameters of type **FieldChangedEventArgs**
    . Inside **FieldChanged()** , we utilize the **EditContext** API through the **Context**
    instance to dynamically evaluate the form’s state. We set the **IsSubmittable**
    variable by checking whether all form fields are valid, using **Context.Validate()**
    , and the form was modified, using **Context.IsModified()** . Given that this
    operation can affect the state of the form’s submit button, we call **StateHasChanged()**
    to notify Blazor that the UI might need updating.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们转向 **EventManager** 的 **@code** 块，并声明一个 **IsSubmittable** 变量，我们将利用它来管理表单提交按钮的状态。在
    *步骤 3* 中，我们实现一个 **FieldChanged()** 方法，该方法接受类型为 **FieldChangedEventArgs** 的 **sender**
    和 **args** 参数。在 **FieldChanged()** 内部，我们通过 **Context** 实例利用 **EditContext** API
    动态评估表单的状态。我们通过检查所有表单字段是否有效，使用 **Context.Validate()** ，以及表单是否已修改，使用 **Context.IsModified()**
    来设置 **IsSubmittable** 变量。鉴于此操作可能会影响表单提交按钮的状态，我们调用 **StateHasChanged()** 来通知 Blazor
    UI 可能需要更新。
- en: In *step 4* , we adjust how **EventManager** initializes. Instead of resetting
    the **Model** object to a new instance, we simulate editing an existing model
    by setting initial properties, reflecting a typical data-editing scenario. In
    *step 5* , as part of the initialization process, we also subscribe **FieldChanged()**
    to the **Context.OnFieldChanged** event handler. Blazor triggers **OnFieldChanged**
    whenever the form field’s value changes, ensuring our form responds to every edit.
    In *step 6* , we finalize the **IDisposable** implementation. We implement the
    **Dispose()** method, where we unsubscribe **FieldChanged()** from the **OnFieldChanged**
    event handler to prevent memory leaks and ensure that the **EventManager** component
    is disposed of gracefully when it is no longer needed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们调整了 **EventManager** 的初始化方式。我们不是将 **Model** 对象重置为新实例，而是通过设置初始属性来模拟编辑现有模型，这反映了典型的数据编辑场景。在
    *步骤 5* 中，作为初始化过程的一部分，我们还订阅 **FieldChanged()** 到 **Context.OnFieldChanged** 事件处理器。每当表单字段值发生变化时，Blazor
    会触发 **OnFieldChanged**，确保我们的表单对每次编辑做出响应。在 *步骤 6* 中，我们最终完成 **IDisposable** 的实现。我们实现
    **Dispose()** 方法，其中我们取消订阅 **FieldChanged()** 从 **OnFieldChanged** 事件处理器，以防止内存泄漏并确保当不再需要时，**EventManager**
    组件能够优雅地被销毁。
- en: In *step 7* , we jump to the **EventManager** markup to reflect our backend
    logic in the UI. We locate the form’s submit button and attach a **disabled**
    attribute, setting its value to the **IsSubmittable** negation. Whenever the user
    changes focus between fields in the form, we will recalculate the value of **IsSubmittable**
    – and since **IsSubmittable** indicates whether the user made changes and the
    form is in a valid state, negating this value determines when the submit button
    should be disabled, preventing unnecessary submission until all conditions for
    a valid and modified form are met.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 7*中，我们跳转到**EventManager**标记以在UI中反映我们的后端逻辑。我们定位到表单的提交按钮，并附加一个**disabled**属性，将其值设置为**IsSubmittable**的否定。每当用户在表单的字段之间更改焦点时，我们将重新计算**IsSubmittable**的值——由于**IsSubmittable**指示用户是否进行了更改以及表单是否处于有效状态，否定这个值决定了何时应禁用提交按钮，防止在满足有效和修改表单的所有条件之前进行不必要的提交。
- en: There’s more…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**EditContext** in Blazor plays a crucial role in managing form states and
    validations but has some limitations. One significant caveat is that it does not
    track the initial state of model properties. **EditContext** monitors changes
    to input fields, marking them as modified when their values change. However, if
    the user reverts a field’s value to its original state, **EditContext** still
    considers it modified. This behavior can lead to scenarios where forms may incorrectly
    allow submission or display validation states because they do not recognize that
    the field value has returned to its initial state.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor中，**EditContext**在管理表单状态和验证方面发挥着至关重要的作用，但有一些限制。一个重要的注意事项是它不跟踪模型属性的初始状态。**EditContext**监视输入字段的更改，当它们的值发生变化时将其标记为已修改。然而，如果用户将字段的值还原到其原始状态，**EditContext**仍然认为它已被修改。这种行为可能导致表单可能错误地允许提交或显示验证状态，因为它们没有认识到字段值已返回到初始状态。
- en: To address this limitation and refine the behavior of form modifications, you
    must implement an equality comparer, inheriting from **IEqualityComparer<T>**
    to customize how equality for reference types is determined. Having an explicit
    comparison logic, we can persist the initial value of the model in an **_initialModel**
    variable and replace the standard **Context.IsModified()** check with an **_initialModel
    != Model** evaluation. Blazor will disable the submit button when the user’s input
    returns to the initial values, ensuring that the form is only submittable with
    actual changes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个限制并细化表单修改的行为，你必须实现一个等价比较器，从**IEqualityComparer<T>**继承以自定义引用类型如何确定等价性。拥有明确的比较逻辑后，我们可以在**_initialModel**变量中持久化模型的初始值，并将标准的**Context.IsModified()**检查替换为**_initialModel
    != Model**评估。当用户的输入返回到初始值时，Blazor将禁用提交按钮，确保表单只有在实际更改的情况下才可提交。
