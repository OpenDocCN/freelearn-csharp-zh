- en: Chapter 4. Parallel LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。并行LINQ
- en: 'In this chapter, we are going to cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a basic parallel query
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的并行查询
- en: Preserving order in parallel LINQ
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行LINQ中保持顺序
- en: Forcing parallel execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制并行执行
- en: Limiting parallelism in a query
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制查询中的并行性
- en: Processing query results
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理查询结果
- en: Specifying merge options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定合并选项
- en: Range projection with parallel LINQ
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行LINQ进行范围投影
- en: Handling exceptions in parallel LINQ
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行LINQ中处理异常
- en: Cancelling a parallel LINQ query
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消并行LINQ查询
- en: Performing reduction operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行归约操作
- en: Creating a custom partitioner
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义分区器
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Language Integrated Query** (**LINQ**) offers developers syntax for performing
    queries on collection of data. Using LINQ you can traverse, filter, sort, and
    return projected sets of items. When you use LINQ to objects, all of the items
    in your data collection are processed sequentially by a single thread.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）为开发人员提供了在数据集合上执行查询的语法。使用LINQ，您可以遍历、过滤、排序并返回项目投影集合。当您使用LINQ
    to objects时，您的数据集合中的所有项目都由单个线程顺序处理。'
- en: Parallel LINQ is a parallel implementation of LINQ to objects, which can turn
    your sequential queries into parallel queries, potentially improving performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并行LINQ是LINQ to objects的并行实现，可以将你的顺序查询转换为并行查询，从而可能提高性能。
- en: Internally, parallel LINQ uses tasks queued to default `TaskScheduler` to extend
    the processing of the source collection's items across available processors, so
    that multiple items are processed concurrently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，并行LINQ使用排队到默认`TaskScheduler`的任务来扩展源集合项的处理，以便多个项可以并发处理。
- en: In this chapter, we are going to see how parallel LINQ can potentially improve
    query performance for large collections of items, or for long compute-bound processing
    of items.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何通过并行LINQ潜在地提高大量项目集合或对项目进行长时间计算绑定处理的查询性能。
- en: Creating a basic parallel query
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的并行查询
- en: In this recipe, we will take a look at creating a basic parallel query by using
    the `AsParallel` method of the `System.Linq.ParallelEnumerable` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过使用`System.Linq.ParallelEnumerable`类的`AsParallel`方法来查看如何创建一个基本的并行查询。
- en: We are going to create a `Console` application that initializes a collection
    of employees, and then queries the employee collection looking for a specific
    job title.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Console`应用程序，初始化员工集合，然后查询员工集合以查找特定的职位名称。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Now, let's go to Visual Studio and start creating some parallel LINQ queries.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到Visual Studio并开始创建一些并行LINQ查询。
- en: Start a new project using the **C# Console Application** project template and
    assign `SimplePLINQ` as the **Solution name**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将**解决方案名称**设置为`SimplePLINQ`。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`Program`类的顶部：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we need to create an `Employee` class just below the `Program` Class.
    Create an `Employee` class definition with `Id`, `Title`, `FirstName`, and `LastName`
    properties.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`Program`类下方创建一个`Employee`类。创建一个具有`Id`、`Title`、`FirstName`和`LastName`属性的`Employee`类定义。
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, in the `Main` method of the `Program` class, let's create and initialize
    an array of `employees`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Program`类的`Main`方法中，让我们创建并初始化一个`employees`数组。
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we will create a parallel LINQ query that selects all employees where
    their title is `Developer`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个并行LINQ查询，选择所有标题为`Developer`的员工。
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_04_01.png.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何做…](img/0225OT_04_01.png.jpg)
- en: How it works…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The small collection of employees we created for this example is too small to
    benefit from parallelizing the query, but the key thing to notice in the example
    is the use of the `AsParallel extension` method which binds the query to parallel
    LINQ, and specifies that the rest of the query should be parallelized if possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个示例创建的员工集合太小，无法从并行查询中受益，但在这个例子中需要注意的关键点是使用`AsParallel`扩展方法将查询绑定到并行LINQ，并指定如果可能的话，查询的其余部分应该并行化。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `System.Linq.ParallelEnumerable` class implements all of the parallel LINQ
    functionality, and exposes parallel versions of `Select`, `Single`, `Skip`, `OrderBy`,
    and so on. All of these methods are extension methods that extend `ParallelQuery<TSource>`.
    The `AsParallel` extension method converts your sequential query based on `IEnumerable<T>`
    to a parallel query based on `ParallelQuery<T>`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Linq.ParallelEnumerable` 类实现了所有并行 LINQ 功能，并公开了 `Select`、`Single`、`Skip`、`OrderBy`
    等的并行版本。所有这些方法都是扩展方法，扩展了 `ParallelQuery<TSource>`。`AsParallel` 扩展方法将基于 `IEnumerable<T>`
    的顺序查询转换为基于 `ParallelQuery<T>` 的并行查询。'
- en: Preserving order in parallel LINQ
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并行 LINQ 中保持顺序
- en: By default, PLINQ does not preserve the order out of a source collection. Because
    PLINQ processes items in a data collection concurrently using multiple threads,
    the items are returned unordered. This is by design, because maintaining the original
    ordering of a sequence adds overhead, and in most cases, that overhead may not
    be necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PLINQ 不保留源集合中的顺序。因为 PLINQ 使用多个线程并发处理数据集合中的项目，所以项目是无序返回的。这是设计上的，因为维护序列的原始顺序会增加开销，而在大多数情况下，这种开销可能不是必要的。
- en: However, when you need to preserve order, PLINQ provides a simple way to accomplish
    it. In this recipe, we are going to create a `Console` application that creates
    two collections of numbers, performs an ordered query on one collection, and the
    default unordered query on the other collection, and looks at the results.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你需要保持顺序时，PLINQ 提供了一种简单的方法来实现它。在这个示例中，我们将创建一个 `Console` 应用程序，创建两个数字集合，对一个集合执行有序查询，对另一个集合执行默认的无序查询，并查看结果。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's open up Visual Studio and see how to preserve order on parallel LINQ queries.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 Visual Studio，看看如何在并行 LINQ 查询中保持顺序。
- en: Start a new project using the **C# Console Application** project template, and
    assign `PreserveOrder` as the **Solution name**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板启动一个新项目，并将 `PreserveOrder` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's start off by creating a `UnorderedQuery` method just below the `Main`
    method of the `Program` class. This method will query a large range of integers
    for numbers that are evenly divisible by 5, and will take the first 10 of those
    numbers as the result.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `Program` 类的 `Main` 方法下方创建一个 `UnorderedQuery` 方法开始。此方法将查询一个大的整数范围，寻找能被
    5 整除的数字，并将这些数字中的前 10 个作为结果。
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next we need to create our `OrderedQuery` method which will perform the same
    query as the previous step, except it will use the `AsOrdered` extension method
    to preserve the original order.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的 `OrderedQuery` 方法，它将执行与上一步相同的查询，但它将使用 `AsOrdered` 扩展方法来保持原始顺序。
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's add some code to the `Main` method of the `Program` class to create
    your source lists of numbers and to call each of the methods.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们向 `Program` 类的 `Main` 方法中添加一些代码，以创建你的数字源列表并调用每个方法。
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_02.png.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到如下截图所示的结果：![如何实现…](img/0225OT_04_02.png.jpg)
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you need to have parallel LINQ, preserve the order of items as they are processed,
    then you can call the `AsOrdered` method of the `ParallelEnumerable` class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要并行 LINQ，在处理项目时保持它们的顺序，那么你可以调用 `ParallelEnumerable` 类的 `AsOrdered` 方法。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you call this method, the threads spawned for the query will process the
    items of a collection in groups, then the groups are merged back together preserving
    order but hurting performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用此方法时，为查询生成的线程将按组处理集合中的项目，然后将这些组合并在一起，保持顺序但影响性能。
- en: The operators `Distinct`, `Intersect`, `Union`, `Join`, `Except`, `GroupBy`,
    `GroupJoin`, and `ToLookup` produce unordered operations. If you need to enforce
    ordering after one of these operations, you just need to call the `AsOrdered`
    method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Distinct`、`Intersect`、`Union`、`Join`、`Except`、`GroupBy`、`GroupJoin` 和 `ToLookup`
    运算符产生无序操作。如果你需要在这些操作之后强制排序，只需调用 `AsOrdered` 方法。'
- en: Conversely, the operators `OrderBy`, `OrderByDescending`, `ThenBy`, and `ThenByDescending`
    produce ordered operations. If you need to go back to unordered processing and
    improve performance, PLINQ provides a `AsUnordered` method you can call.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`OrderBy`、`OrderByDescending`、`ThenBy` 和 `ThenByDescending` 运算符产生有序操作。如果你需要回到无序处理并提高性能，PLINQ
    提供了一个可以调用的 `AsUnordered` 方法。
- en: Forcing parallel execution
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制并行执行
- en: Parallel LINQ looks for opportunities to parallelize a query, but not all queries
    run faster in parallel. For example, a query that contains a single delegate that
    does only a little bit of work will usually run faster sequentially, because the
    overhead of parallelizing outweighs the benefits gained from parallelizing it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 并行LINQ寻找并行化查询的机会，但并非所有查询并行运行都会更快。例如，包含单个仅做少量工作的代理的查询通常按顺序运行会更快，因为并行化的开销超过了并行化所获得的收益。
- en: For the most part, parallel LINQ does a really good job of determining what
    should be parallelized and what should run sequentially, based on its examination
    of the shape of the query. However, the algorithm it uses is not perfect, and
    you might need to instruct PLINQ to run your query in parallel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，并行LINQ在确定应该并行化什么以及应该顺序运行什么方面做得很好，这是基于它对查询形状的检查。然而，它使用的算法并不完美，你可能需要指示PLINQ并行运行你的查询。
- en: In this recipe, we will build a `Console` application that creates a query which
    PLINQ will determine whether it needs to be executed sequentially. We will then
    force the query to run in parallel using the `WithExecutionMode` method. Finally,
    we will capture the time it takes for both queries to run and compare the results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个`Console`应用程序，创建一个查询，PLINQ将确定它是否需要按顺序执行。然后我们将使用`WithExecutionMode`方法强制查询并行运行。最后，我们将捕获两个查询的运行时间并比较结果。
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Now, let's see how to force a PLINQ query to execute in parallel.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何强制PLINQ查询并行执行。
- en: Start a new project using the **C# Console Application** project template, and
    assign `ForceParallelism` as the **Solution name**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C# Console Application**项目模板启动一个新的项目，并将`ForceParallelism`分配为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`Program`类的顶部：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, let's create a method in your `Program` class called `NoForcedParallelism`
    that creates a PLINQ query with a small delegate of work that PLINQ will evaluate
    and determine what needs to be executed sequentially.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在你的`Program`类中创建一个名为`NoForcedParallelism`的方法，该方法创建一个PLINQ查询，其中包含PLINQ将评估的小型代理工作，并确定需要按顺序执行的内容。
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let's create a method in the `Program` class called `ForcedParallism`
    which runs the same query, but forces PLINQ to execute it in parallel by calling
    the `WithExecutionMode` method and passing it a `ParallelExecutionMode.ForceParallelism`
    enumeration.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Program`类中创建一个名为`ForcedParallism`的方法，该方法运行相同的查询，但通过调用`WithExecutionMode`方法并传递`ParallelExecutionMode.ForceParallelism`枚举来强制PLINQ并行执行它。
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will finish up by adding some code to the `Main` method to create `stopWatch`
    to capture the timing of the two methods, then run the methods and compare the
    results.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`Main`方法中添加一些代码来创建`stopWatch`以捕获两个方法的计时，然后运行这些方法并比较结果。
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_03.png.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你应该会看到以下截图所示的输出：![如何做…](img/0225OT_04_03.png.jpg)
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we can see that PLINQ wrongly decided that the query would run
    faster sequentially. When we forced the query to run in parallel, the performance
    improvement was significant.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们可以看到PLINQ错误地决定查询按顺序运行会更快。当我们强制查询并行运行时，性能提升是显著的。
- en: We instructed PLINQ not to fall back to sequential execution when it detects
    certain query shapes by calling the `WithExecutionMode` method of `System.Linq.ParallelQuery`,
    and passing it `ParallelExecutionMode.ForceParallelism` enumeration value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`System.Linq.ParallelQuery`的`WithExecutionMode`方法，并传递`ParallelExecutionMode.ForceParallelism`枚举值，指示PLINQ在检测到某些查询形状时不要回退到顺序执行。
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why did PLINQ determine that the query should be executed sequentially in the
    first place? It is mainly a factor to determine the shape of the query which has
    a single delegate of work. It also has to do with this query using the `positional
    Select` operator. Positional-related operators may require `ForceParallelism`
    in PLINQ that includes `positional Select`, `positional Where`, `positional SelectMany`,
    `Take`, `Skip`, `TakeWhile`, and `SkipWhile`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么PLINQ最初就决定该查询应该按顺序执行？这主要是一个决定查询形状的因素，该形状只有一个工作代理。这也与该查询使用`positional Select`运算符有关。与位置相关的运算符可能需要在PLINQ中包含`positional
    Select`、`positional Where`、`positional SelectMany`、`Take`、`Skip`、`TakeWhile`和`SkipWhile`的`ForceParallelism`。
- en: Limiting parallelism in a query
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在查询中限制并行性
- en: By default, parallel LINQ will try to take advantage of all of the processor
    cores offered by your CPU. Usually, this is what you want. However, there could
    be situations where you want to limit the number of threads used to run queries
    and keep some cores available for other work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，并行LINQ会尝试利用CPU提供的所有处理器核心。通常，这是你想要的。然而，可能存在你想要限制用于运行查询的线程数，并保留一些核心用于其他工作的情况。
- en: In this recipe, we are going to create a query that uses the `WithDegreeOfParallelism`
    method to explicitly set the number of threads that a parallel query uses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个查询，该查询使用`WithDegreeOfParallelism`方法显式设置并行查询使用的线程数。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's see how to limit the degree of parallelism of a query.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何限制查询的并行度。
- en: Start a new project using the **C# Console Application** project template, and
    assign `LimitParallelism` as the **Solution name**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`LimitParallelism`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program`类的顶部添加以下`using`指令：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's add a PLINQ query to the `Main` method of the `Program` class that works
    the processors. For now, we will use the `WithExecutionMode` method to force the
    query to run in parallel, but will not set a limit on the parallelization.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Program`类的`Main`方法中添加一个PLINQ查询，使其工作在处理器上。目前，我们将使用`WithExecutionMode`方法强制查询并行运行，但不会设置并行化的限制。
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you have a multi-core processor on your machine, start up the **Task Manager**,
    click on the **Performance** tab, and watch CPU usage. In Visual Studio 2012,
    press *F5* to run the project. You should see processor usage as shown in the
    following screenshot:![How to do it…](img/0225OT_04_04.png.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你机器上有多核处理器，启动**任务管理器**，点击**性能**选项卡，并观察CPU使用情况。在Visual Studio 2012中，按*F5*键运行项目。你应该会看到如下截图所示的处理器使用情况：![如何操作…](img/0225OT_04_04.png.jpg)
- en: Now let's edit the PLINQ query to call the `WithDegreeOfParallelism` method
    to limit the number of processor cores used. You might want to change the value
    you pass into the method to be a number that is relevant to the number of processor
    cores available to you. You can specify a number greater than the number of processor
    cores available on your machine, but this will likely lead to more context switching.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编辑PLINQ查询，调用`WithDegreeOfParallelism`方法来限制使用的处理器核心数。你可能想要将传递给方法的值更改为与你可用的处理器核心数相关的数字。你可以指定一个大于你机器上处理器核心数的数字，但这可能会导致更多的上下文切换。
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now start up the **Task Manager** again, click on the **Performance** tab, and
    watch CPU usage. In Visual Studio 2012, press *F5* to run the project. You should
    see reduced processor usage. Note that the threads created will not necessarily
    spend all of their time on a single core, but the overall usage will go down.![How
    to do it…](img/0225OT_04_05.png.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次启动**任务管理器**，点击**性能**选项卡，并观察CPU使用情况。在Visual Studio 2012中，按*F5*键运行项目。你应该会看到处理器使用量减少。请注意，创建的线程不一定会在单个核心上花费所有时间，但总体使用量会下降。![如何操作…](img/0225OT_04_05.png.jpg)
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `WithDegreeOfParallelism` method probably isn't something that you will
    use very often. You might want to use it in situations where you need to leave
    some CPU time available to perform other tasks. You could also pass a number that
    is greater than the number of cores on your machine, in cases where the query
    will be performing synchronous I/O, because the threads will be blocking.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithDegreeOfParallelism` 方法可能不是你经常需要使用的方法。你可能希望在需要留出一些CPU时间来执行其他任务的情况下使用它。你也可以传递一个大于你机器上核心数的数字，在这种情况下，查询将执行同步I/O，因为线程将会阻塞。'
- en: Setting the degree of parallelism is simply a matter of calling the method and
    passing in the number of threads you want PLINQ to use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设置并行度仅仅是调用该方法并传递你想要PLINQ使用的线程数。
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The default value of the `WithDegreeOfParallism` method is the processor count
    of your machine.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithDegreeOfParallism`方法的默认值是你的机器的处理器数量。'
- en: Processing query results
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理查询结果
- en: One of the nice features of parallel LINQ is that it collates the results from
    a parallelized query into a single output sequence. Often though, all your program
    does with the query's output data is run a function over each element using a
    `foreach` loop or similar. In such cases, particularly in cases where you don't
    care about the order in which elements are processed, you can improve performance
    by using the ParallelEnumerable's `ForAll` method to process the results in parallel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 LINQ 的一个很好的特性是它将并行化查询的结果收集到一个单一的输出序列中。然而，通常你的程序对查询的输出数据所做的只是使用 `foreach`
    循环或类似的方法对每个元素运行一个函数。在这种情况下，尤其是在你不在乎元素处理顺序的情况下，你可以通过使用 ParallelEnumerable 的 `ForAll`
    方法来并行处理结果来提高性能。
- en: In this recipe, we will perform a query on a range of numbers, and then use
    `ParallelForAll` to iterate over the results in parallel, calculating the square
    of each number.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将对数字范围执行查询，然后使用 `ParallelForAll` 并行迭代结果，计算每个数字的平方。
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's open up Visual Studio and see how to process the results of a parallel
    query.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开 Visual Studio，看看如何处理并行查询的结果。
- en: Start a new project using the **C# Console Application** project template, and
    assign `ProcessResults` as the **Solution name**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板启动一个新的项目，并将 `ProcessResults` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, in the `Main` method of the `Program` class, let's create a concurrent
    collection of integers to hold the result of our calculation, and generate a range
    of numbers for the query.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `Program` 类的 `Main` 方法中，让我们创建一个并发整数集合来保存我们计算的结果，并为查询生成一个数字范围。
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, just below the previous lines, create a PLINQ query that queries the first
    100 numbers that are evenly divisible by 5 out of the source range.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在上一行代码的下方，创建一个 PLINQ 查询，查询从源范围中均匀可被 5 整除的前 100 个数字。
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now let's call the `ParallelEnumerable.ForAll` method to process our query results
    in parallel. We are just going to calculate the square of each number and add
    the result to our collection.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `ParallelEnumerable.ForAll` 方法来并行处理我们的查询结果。我们只是将要计算每个数字的平方并将结果添加到我们的集合中。
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, let's loop through the collection and print the results to `Console`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们遍历集合并将结果打印到 `Console`。
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_06.png.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到如下截图所示的输出：![如何操作…](img/0225OT_04_06.png.jpg)
- en: How it works…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we are using `ParallelEnumerable.ForAll<TSource>` to iterate
    through and process the results of our query in parallel. The `ForAll` method
    runs a delegate over every output element of a `ParallelQuery`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `ParallelEnumerable.ForAll<TSource>` 来并行迭代并处理我们的查询结果。`ForAll` 方法在
    `ParallelQuery` 的每个输出元素上运行一个委托。
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `ForAll` method hooks right into parallel LINQ's internals, bypassing the
    steps of collating, and enumerating the results which can save considerable processing
    time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForAll` 方法直接连接到并行 LINQ 的内部，绕过了收集和枚举结果的过程，这可以节省相当多的处理时间。'
- en: You might wonder why we used the `ForAll` method to calculate the square of
    our results and add them to the collection; just to use a sequential `foreach`
    loop to write the results to `Console`. Besides the obvious answer that this is
    just a simple example, you wouldn't want to write to `Console` inside a `ForAll`
    method because .NET serializes all access to `Console`, and would force the whole
    thing to run sequentially.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们使用 `ForAll` 方法来计算结果的平方并将它们添加到集合中；只是为了使用顺序的 `foreach` 循环将结果写入 `Console`。除了显而易见的答案这只是个简单的例子之外，你不会想在
    `ForAll` 方法中写入 `Console`，因为 .NET 会序列化对 `Console` 的所有访问，并强制整个操作按顺序执行。
- en: Specifying merge options
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定合并选项
- en: When parallel LINQ executes a query, it partitions the source data and assigns
    each partition to a separate thread. If the results are consumed by a single thread,
    such as a `foreach` loop, then the results from each partition must be merged
    back into one result set. The kind of merge that is performed depends on the operators
    used in the query. For operators that produce ordered results, the results from
    all the threads are completely buffered before being merged back together. Your
    application's consuming thread might have to wait for a while before seeing the
    final result. If you don't care about order, or want to use a different buffering
    scheme to improve results, your query can use the `WithMergeOptions` extension
    method to provide a hint to PLINQ about how you would like the results to be buffered.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当并行 LINQ 执行查询时，它会将源数据分区并将每个分区分配给一个单独的线程。如果结果由单个线程消费，例如 `foreach` 循环，那么每个分区的结果必须合并回一个结果集。所执行的合并类型取决于查询中使用的运算符。对于产生有序结果的运算符，所有线程的结果在合并回之前完全缓冲。您的应用程序的消耗线程可能需要等待一段时间才能看到最终结果。如果您不关心顺序，或者想使用不同的缓冲方案来提高结果，则查询可以使用
    `WithMergeOptions` 扩展方法向 PLINQ 提供一个提示，说明您希望如何缓冲结果。
- en: In this recipe, we will query some numbers out of a range, and loop through
    the results using a couple of different buffering options, and observe the effects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将从范围中查询一些数字，并使用几种不同的缓冲选项遍历结果，并观察其效果。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's take a look at how to specify the merge option of a PLINQ query.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何指定 PLINQ 查询的合并选项。
- en: Start a new project using the **C# Console Application** project template, and
    assign `MergeOptions` as the **Solution name**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板启动一个新项目，并将 `MergeOptions` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's start by creating our source number range in the `Main` method of the
    `Program` class.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `Program` 类的 `Main` 方法中创建我们的源数字范围开始。
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now let's create a PLINQ query to select the numbers in the range that are evenly
    divisible by 5, and use the `WithMergeOption` method to specify fully buffered
    merging of the results.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 PLINQ 查询以选择范围内能被 5 整除的数字，并使用 `WithMergeOption` 方法指定完全缓冲合并结果。
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, let's use a `foreach` loop to iterate through the results and print them
    to `Console`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `foreach` 循环遍历结果并将它们打印到 `Console`。
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In Visual Studio 2012, press *F5* to run the project. Notice the **Ordered Results**
    shown in the following screenshot:![How to do it…](img/0225OT_04_07.png.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。注意以下截图所示的 **有序结果**：![如何操作…](img/0225OT_04_07.png.jpg)
- en: Now let's use the `WithMergeOption` method to specify no buffering for the results.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `WithMergeOption` 方法指定不进行结果缓冲。
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In Visual Studio 2012, press *F5* to run the project. Notice the unordered results
    in the following screenshot:![How to do it…](img/0225OT_04_08.png.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。注意以下截图中的无序结果：![如何操作…](img/0225OT_04_08.png.jpg)
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The `WithMergeOptions` method takes the `ParallelMergeOptions` enumeration
    as a parameter. You can specify one of the following options for how the query
    output is yielded and when the results can be consumed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithMergeOptions` 方法接受 `ParallelMergeOptions` 枚举作为参数。您可以指定以下选项之一，以指定查询输出何时产生以及何时可以消费结果：'
- en: '**Not Buffered**: Each processed element of the query is returned from each
    thread as soon as it is produced. If the `AsOrdered` operator is present, ordering
    is preserved, but if `AsOrdered` is not present, then the results are yielded
    as soon as they are available. This option yields the fastest results.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不缓冲**：查询的每个处理元素一旦产生，就从每个线程返回。如果存在 `AsOrdered` 运算符，则保留排序，如果没有 `AsOrdered`
    运算符，则结果一旦可用就提交。此选项提供最快的速度。'
- en: '**Auto Buffered**: The elements are collected into a buffer and periodically
    yielded to the consuming thread. This is a middle ground approach to buffering.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动缓冲**：元素被收集到缓冲区中，并定期提交给消耗线程。这是一种中间缓冲方法。'
- en: '**Fully Buffered**: All of the elements are collected in a buffer before any
    elements are yielded to the consuming thread.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全缓冲**：在向消耗线程提交任何元素之前，所有元素都收集到缓冲区中。'
- en: When you use `WithMergeOptions`, you are giving PLINQ a hint about the buffering
    scheme you want it to use. If a particular query cannot support the requested
    option, your request will be ignored.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`WithMergeOptions`时，你正在向PLINQ提供有关它想要使用的缓冲方案的提示。如果特定的查询不支持请求的选项，你的请求将被忽略。
- en: Range projection with parallel LINQ
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行LINQ进行范围投影
- en: While using sequential LINQ, it is very common to use range projection to obtain
    a range of values. Parallel LINQ provides us with a way to do this too. If you
    need to generate a very large range of numbers which do not necessarily need to
    be in sequence, you can use the `Range` method of `ParallelEnumerable` to create
    the sequence.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用顺序LINQ时，使用范围投影来获取值范围是非常常见的。并行LINQ为我们提供了这样做的方法。如果你需要生成一个非常大的范围，这些数字不需要按顺序排列，你可以使用`ParallelEnumerable`的`Range`方法来创建序列。
- en: In this short recipe, we will use `ParallelEnumerable.Range` to generate some
    numbers over a very large range.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的菜谱中，我们将使用`ParallelEnumerable.Range`生成一个非常大范围内的数字。
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's go to Visual Studio and see how to use parallel LINQ to generate
    a range of numbers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去Visual Studio看看如何使用并行LINQ生成数字范围。
- en: Start a new project using the **C# Console Application** project template, and
    assign `RangeProjection` as the **Solution name**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将`Solution name`设置为`RangeProjection`。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`Program`类的顶部：
- en: '[PRE31]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, in the `Main` method, let's use `ParallelEnumerable.Range` to create
    a range of numbers between 1 and 1000 that are divisible by 5.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Main`方法中，让我们使用`ParallelEnumerable.Range`创建一个介于1到1000之间，且能被5整除的数字范围。
- en: '[PRE32]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now let's just loop through the results to display them to the `Console` and
    wait for user input before exiting.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们遍历结果以将它们显示到`Console`，并在退出前等待用户输入。
- en: '[PRE33]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_09.png.jpg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何操作…](img/0225OT_04_09.png.jpg)
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The code for this recipe is fairly easy to understand. One important point to
    note is that the implicit cast to `ParallelQuery<int>` creates a parallel execution
    instead of a sequential one, and there is no particular ordering of the numbers
    in the result.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的代码相当容易理解。一个需要注意的重要点是，隐式转换为`ParallelQuery<int>`会创建并行执行而不是顺序执行，并且结果中的数字没有特定的顺序。
- en: Of course, order can be preserved by calling `AsOrdered` on the query, but if
    ordering is important to you, just generate the range using sequential LINQ projection,
    and avoid the overhead of parallel execution.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以通过在查询上调用`AsOrdered`来保留顺序，但如果顺序对你很重要，只需使用顺序LINQ投影生成范围，并避免并行执行的开销。
- en: Handling exceptions in parallel LINQ
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并行LINQ中处理异常
- en: Handling exceptions in parallel LINQ is not much different from handling exceptions
    in tasks, continuation, or anywhere else in your parallel code. You need to use
    `try`/`catch` and make sure to catch `AggregateException`. With parallel LINQ,
    the really important part is to use the try/catch around where you enumerate or
    use your results.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行LINQ中处理异常与在任务、延续或你的并行代码的任何其他地方处理异常没有太大区别。你需要使用`try`/`catch`并确保捕获`AggregateException`。对于并行LINQ，真正重要的是在使用结果进行枚举或使用时使用try/catch。
- en: In this recipe, we are going to create a simple parallel LINQ query that returns
    a list of employees and throws `InvalidOperationException`, which we will handle
    when we iterate through the results.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个简单的并行LINQ查询，该查询返回员工列表并抛出`InvalidOperationException`，我们将在遍历结果时处理它。
- en: Getting ready…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime `Exception` is thrown, and
    intercepts the `Exception` before it gets to our handler.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要关闭Visual Studio 2012异常助手。异常助手会在运行时`Exception`抛出时出现，并在它到达我们的处理器之前拦截`Exception`。
- en: To turn off the Exception Assistant, go to the **Debug** menu and click on **Exception**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，转到**调试**菜单并点击**异常**。
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_04_10.png.jpg)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**公共语言运行时异常**旁边的**用户未处理**复选框。![准备工作…](img/0225OT_04_10.png.jpg)
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's take a look at how to handle exceptions in a parallel LINQ query.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何处理并行 LINQ 查询中的异常。
- en: Start a new project using the **C# Console Application** project template, and
    assign `HandleExceptions` as the **Solution name**.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板启动一个新的项目，并将 `HandleExceptions` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到您的 `Program` 类顶部：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, let''s create an `Employee` class. Add the following class definition
    to your `Program.cs` file, just below the `Program` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 `Employee` 类。将以下类定义添加到您的 `Program.cs` 文件中，位于 `Program` 类下方：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, in the `Main` method of the `Program` class, let's create and initialize
    an array of `employees`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Program` 类的 `Main` 方法中，让我们创建并初始化一个 `employees` 数组。
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, create a PLINQ query that selects all employees and throws `InvalidOperationException`
    when it encounters an `employee Id` that is greater than `15`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 PLINQ 查询，该查询选择所有员工，并在遇到大于 `15` 的 `employee Id` 时抛出 `InvalidOperationException`。
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, let's create a `try`/`catch` block. In the `try` block, create a `foreach`
    loop to iterate through the results. In the `catch` block, you need to handle
    `AggregateException` and display the `Exception` to `Console`. Finish up by waiting
    for user input before exiting the program.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个 `try`/`catch` 块。在 `try` 块中，创建一个 `foreach` 循环来遍历结果。在 `catch` 块中，您需要处理
    `AggregateException` 并将 `Exception` 显示到 `Console`。完成程序退出前的用户输入等待。
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_11.png.jpg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。您应该看到以下截图所示的输出：![如何做到这一点…](img/0225OT_04_11.png.jpg)
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see, the steps for handling exceptions that occur in a parallel LINQ
    query are very consistent with handling exceptions that occur in other parts of
    our parallel code. Any `Exception` that occurs will be added to the `InnerExceptions`
    collection of an `AggregateException`. So, we need to be ready to catch `AggregateException`
    and examine the individual `Exception` items in the `InnerExceptions` collection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理并行 LINQ 查询中发生的异常的步骤与其他部分并行代码中处理异常的步骤非常一致。任何发生的 `Exception` 都将被添加到 `AggregateException`
    的 `InnerExceptions` 集合中。因此，我们需要准备好捕获 `AggregateException` 并检查 `InnerExceptions`
    集合中的单个 `Exception` 项目。
- en: In this recipe, we just placed a `try`/`catch` block around the loop that iterates
    through our results, and handled `AggregateException` in the `catch` block.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只是在遍历结果的循环周围放置了一个 `try`/`catch` 块，并在 `catch` 块中处理 `AggregateException`。
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Cancelling a parallel LINQ query
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消并行 LINQ 查询
- en: Like tasks and continuations, parallel LINQ queries are cancelled by using `CancellationToken`
    which you obtain from `CancellationTokenSource`. A minor difference in cancelling
    a parallel LINQ query is in how you register a `CancellationToken` with the `WithCancellation(tokenSource.Token)`
    extension method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与任务和延续一样，并行 LINQ 查询通过使用从 `CancellationTokenSource` 获得的 `CancellationToken` 来取消。取消并行
    LINQ 查询的一个小差异在于如何使用 `WithCancellation(tokenSource.Token)` 扩展方法注册 `CancellationToken`。
- en: In this recipe, we are going to create a cancellable parallel query that selects
    the square of numbers from a large range of random numbers. We are then going
    to create a separate task to cancel the query from.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个可取消的并行查询，该查询从一大范围随机数中选择数字的平方。然后，我们将创建一个单独的任务来取消查询。
- en: Getting ready…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime `Exception` is thrown and intercepts
    the `Exception` before it gets to our handler.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要关闭 Visual Studio 2012 的异常助手。异常助手会在抛出运行时 `Exception` 时出现，并在它到达我们的处理器之前拦截
    `Exception`。
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exception**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，请转到 **调试** 菜单并选择 **异常**。
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_04_10.png.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中 **公共语言运行时异常** 旁边的 **用户未处理的** 复选框。![准备中…](img/0225OT_04_10.png.jpg)
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Now, let's take a look at how to cancel a parallel LINQ query.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何取消一个并行 LINQ 查询。
- en: Start a new project using the **C# Console Application** project template and
    assign `CancelQuery` as the **Solution name**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板启动一个新的项目，并将 `CancelQuery` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到您的 `Program` 类顶部：
- en: '[PRE40]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, let's add some code to the `Main` method of the `Program` class to create
    our `CancellationTokenSource` object. We also need to initialize a large range
    of random numbers that will be the source for the query.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向`Program`类的`Main`方法中添加一些代码来创建我们的`CancellationTokenSource`对象。我们还需要初始化一个大量随机数字的范围，这些数字将是查询的来源。
- en: '[PRE41]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next, let's create a parallel LINQ query that uses the `WithCancellation` extension
    method to accept a cancellation token and uses the `Math.Pow` method to select
    the square of each number.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个使用`WithCancellation`扩展方法接受取消令牌并使用`Math.Pow`方法选择每个数字的平方的并行LINQ查询。
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now let's create a task that will sleep for 1 second to give the query time
    to start, and then it will call the `CancellationTokenSource.Cancel` method to
    cancel the token.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个任务，该任务将暂停1秒以给查询启动时间，然后它将调用`CancellationTokenSource.Cancel`方法来取消令牌。
- en: '[PRE43]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, let's create a `try` block and a couple of `catch` blocks. The `try`
    block will just contain a `foreach` loop, to loop through the results of the query.
    The first `catch` block needs to catch `OperationCancelledException` and display
    a message to `Console`. The second `catch` block needs to catch `AggregateException`
    and display all `InnerException` messages to the `Console`. Lastly, let's wait
    for user input before exiting.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个`try`块和几个`catch`块。`try`块将只包含一个`foreach`循环，用于遍历查询的结果。第一个`catch`块需要捕获`OperationCancelledException`并向`Console`显示消息。第二个`catch`块需要捕获`AggregateException`并向`Console`显示所有`InnerException`消息。最后，让我们在退出之前等待用户输入。
- en: '[PRE44]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_12.png.jpg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何做…](img/0225OT_04_12.png.jpg)
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We used two separate `catch` blocks in this recipe because the parallel LINQ
    framework does not roll `OperationCanceledExceptions` into `AggregateException`;
    the `OperationCanceledException` must be handled in a separate `catch` block or
    it will be left unhandled.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了两个独立的`catch`块，因为并行LINQ框架不会将`OperationCanceledExceptions`合并到`AggregateException`中；`OperationCanceledException`必须在单独的`catch`块中处理，否则它将不会被处理。
- en: 'If you have one or more delegates, throw `OperationCanceledException` by using
    `CancellationToken`, but don''t throw any other exception. Then, parallel LINQ
    will just throw a single `OperationCanceledException` rather than `System.AggregateException`.
    However, if a delegate throws `OperationCanceledException` and another delegate
    throws another `Exception` type, then both exceptions will be rolled into `AggregateException`.
    So, whenever you create a PLINQ query using the `WithCancellation` extension method,
    it is recommended that you create two `catch` blocks: one for `OperationCancelledException`
    and one for `AggregateException`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个或多个委托，请使用`CancellationToken`抛出`OperationCanceledException`，但不要抛出任何其他异常。然后，并行LINQ将只抛出一个`OperationCanceledException`而不是`System.AggregateException`。然而，如果一个委托抛出`OperationCanceledException`而另一个委托抛出另一种`Exception`类型的异常，那么这两个异常都将合并到`AggregateException`中。因此，每次你使用`WithCancellation`扩展方法创建PLINQ查询时，建议你创建两个`catch`块：一个用于`OperationCancelledException`，另一个用于`AggregateException`。
- en: Performing reduction operations
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行归约操作
- en: Like sequential LINQ, parallel LINQ provides many common aggregation operations
    such as sum, average, min, and max. It is pretty easy to perform aggregate operations
    by using one of LINQs extension methods.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 就像顺序LINQ一样，并行LINQ提供了许多常见的聚合操作，如求和、平均值、最小值和最大值。通过使用LINQ的扩展方法之一执行聚合操作非常简单。
- en: Sometimes, however, we need to perform a custom aggregation of our source data,
    either because we need to perform a calculation that isn't provided in one of
    the standard aggregation extension methods, or because we need to apply custom
    logic to the calculation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们需要对源数据进行自定义聚合，要么是因为我们需要执行标准聚合扩展方法中未提供的计算，要么是因为我们需要对计算应用自定义逻辑。
- en: For such cases, parallel LINQ provides us with a `aggregate` method which can
    apply a custom accumulator function in parallel over a sequence of data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类情况，并行LINQ为我们提供了一个`aggregate`方法，可以在数据序列上并行应用自定义累加函数。
- en: In this recipe, we are going to create a custom aggregation operation that calculates
    the average of a large range of numbers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个自定义聚合操作，用于计算大量数字的平均值。
- en: How to do it…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Now, let's see how to perform custom aggregation with PLINQ.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用PLINQ执行自定义聚合。
- en: Start a new project using the **C# Console Application** project template, and
    assign `Average` as the **Solution name**.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板启动一个新的项目，并将 `Average` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的顶部添加以下 `using` 指令：
- en: '[PRE45]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, let's add some code to the `Main` method to create a range of random
    numbers.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在 `Main` 方法中添加一些代码来创建一个随机数字的范围。
- en: '[PRE46]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now let's create a PLINQ query that calls the `Aggregate` extension method of
    `ParallelEnumerable` passing delegate to calculate the average to the `intermediateReduceFunc`,
    `finalReduceFunc`, and `resultSelector` parameters. Display the results to `Console`
    and wait for user input before exiting.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 PLINQ 查询，调用 `ParallelEnumerable` 的 `Aggregate` 扩展方法，将计算平均值的委托传递给
    `intermediateReduceFunc`、`finalReduceFunc` 和 `resultSelector` 参数。将结果显示到 `Console`，并在退出前等待用户输入。
- en: '[PRE47]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finish up by displaying the results to the `Console` and waiting for the user
    input before exiting.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将结果显示到 `Console` 并在退出前等待用户输入。
- en: '[PRE48]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_13.png.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到以下截图所示的输出：![如何操作…](img/0225OT_04_13.png.jpg)
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: An aggregation operation is an operation that iterates over a sequence of input
    data elements, maintaining an accumulator that contains an intermediate result.
    At each step, a reduction function takes the current element and accumulator value
    as inputs, and yields a value that will overwrite the accumulator. The final accumulator
    value is the result of the computation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合操作是一种迭代输入数据元素序列的操作，维护一个包含中间结果的累加器。在每一步，一个归约函数将当前元素和累加器值作为输入，并产生一个将覆盖累加器的值。最终的累加器值是计算的结果。
- en: 'The `ParallelEnumerable` class provides several overloads of the `aggregate`
    extension method. We are using the following overload:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelEnumerable` 类提供了 `aggregate` 扩展方法的几个重载。我们使用以下重载：'
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `seedFactory` function returns the initial accumulator value. The `updateAccumularorFunc`
    parameter is an `accumulator` function to be invoked on each element in a partition.
    The `combineAccumulatorsFunc` parameter is an `accumulator` function to be invoked
    on the yielded accumulator result from each partition. Finally, the `resultSelector`
    parameter is a function to transform the final accumulator value into the result
    value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`seedFactory` 函数返回初始累加器值。`updateAccumularorFunc` 参数是一个在分区中的每个元素上被调用的累加器函数。`combineAccumulatorsFunc`
    参数是一个在从每个分区产生的累加器结果上被调用的累加器函数。最后，`resultSelector` 参数是一个将最终累加器值转换为结果值的函数。'
- en: We have provided our own delegate for each of these function parameters.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这些函数参数中的每一个都提供了一个自己的委托。
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Creating a custom partitioner
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义分区器
- en: To parallelize an operation on a data source, one of the essential steps is
    to partition the source into multiple sections that can be accessed concurrently
    by multiple threads. Parallel LINQ provides default partitioners that work quite
    well for most parallel queries. However, for more advanced scenarios, you can
    also create your own partitioner.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要并行化对数据源的操作，一个基本步骤是将源分区成多个部分，以便多个线程可以并发访问。Parallel LINQ 提供了适用于大多数并行查询的默认分区器。然而，对于更高级的场景，你也可以创建自己的分区器。
- en: For the recipe, we will create a custom static partitioner which will split
    our data source into a variable number of partitioned chunks. The exact number
    of partitions will be specified by TPL itself, and will be made available to our
    custom partitioner by overriding the `Partitioner<T>` method. We will then test
    the performance of a query that uses default partitioning against the performance
    of a query using our custom partitioner.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将创建一个自定义静态分区器，它将把我们的数据源分割成可变数量的分区块。确切的分区数将由 TPL 本身指定，并通过重写 `Partitioner<T>`
    方法提供给我们的自定义分区器。然后，我们将测试使用默认分区和我们的自定义分区器进行查询的性能。
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's take a look at how to partition data for a parallel query.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为并行查询分区数据。
- en: Start a new project using the **C# Console Application** project template, and
    assign `CustomPartitioner` as the **Solution name**.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板启动一个新的项目，并将 `CustomPartitioner` 作为 **解决方案名称**。
- en: Add a new class the project and name it `CustomPartitioner.cs`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新类，并将其命名为 `CustomPartitioner.cs`。
- en: 'Add the following `using` directives to the top of your `CustomPartitioner`
    class:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`CustomPartitioner`类的顶部添加以下`using`指令：
- en: '[PRE51]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Apply a generic type parameter to the `CustomPartitioner` class, and declare
    `Partitioner<T>` as its base class. Optionally, mark the class visibility as internal.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将泛型类型参数应用到`CustomPartitioner`类上，并将`Partitioner<T>`声明为其基类。可选地，将类的可见性标记为内部。
- en: '[PRE52]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Create a private source field of type array of `T` and initialize the source
    data with the `Class` constructor.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个私有的源字段，类型为数组`T`，并使用`Class`构造函数初始化源数据。
- en: '[PRE53]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Override the `SupportsDynamicPartitions` property of the base class to return
    `false`. This partitioner can only allocate partitions statically.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖基类的`SupportsDynamicPartitions`属性，返回`false`。这个分区器只能静态分配分区。
- en: '[PRE54]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Add a `GetItems` method that returns `IEnumerator<T>` for the items in the source.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`GetItems`方法，它返回源中的`IEnumerator<T>`。
- en: '[PRE55]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finish up the `CustomPartitioner` class by overriding the `GetPartitions` method
    of the base class. This method will return `List<IEnumerable<T>>` which is a list
    of our partitioned data.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过覆盖基类的`GetPartitions`方法来完成`CustomPartitioner`类的实现。这个方法将返回`List<IEnumerable<T>>`，这是我们分区数据的一个列表。
- en: '[PRE56]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'That''s it for the `CustomPartitioner` class. Now let''s go to the `Program`
    class:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`CustomPartitioner`类就到这里。现在让我们转到`Program`类：
- en: 'Add the following `using` directives to the top of the class:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部添加以下`using`指令：
- en: '[PRE57]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the `Main` method of the `Program` class add some code to create a large
    array of random numbers that we will use for the source of our query. Also, create
    a `stopWatch` object, which we will use to capture our performance numbers.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法中添加一些代码来创建一个大型随机数字数组，我们将使用它作为查询的源。同时，创建一个`stopWatch`对象，我们将用它来捕获性能数据。
- en: '[PRE58]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, let's start `stopWatch` and run a query against the source data to select
    the square of each number. This query uses default partitioning.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们开始`stopWatch`并针对源数据运行一个查询，以选择每个数字的平方。这个查询使用默认分区。
- en: '[PRE59]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, let's reset `stopWatch`, run the query with our custom partitioner,
    display the results, and wait for user input before exiting.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们重置`stopWatch`，使用我们自定义的分区器运行查询，显示结果，并在退出前等待用户输入。
- en: '[PRE60]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_14.png.jpg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你应该会看到以下截图所示的输出：![如何操作…](img/0225OT_04_14.png.jpg)
- en: How it works…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In some cases, it might be worthwhile to create your own partitioner, but for
    the most part, the default partitioning works pretty well.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，创建自己的分区器可能是有价值的，但大部分情况下，默认的分区效果相当不错。
- en: To create a basic custom partitioner, derive a class from `Partitioner<TSource>`
    which is located in `System.Collections.Concurrent`, and override a couple of
    virtual methods and a virtual property getter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基本的自定义分区器，从`System.Collections.Concurrent`中的`Partitioner<TSource>`派生一个类，并重写几个虚拟方法和一个虚拟属性获取器。
- en: We provided an override for the `SupportsDynamicPartitions` property to indicate
    that our simple custom partitioner only supports static partitions by returning
    `true`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`SupportsDynamicPartitions`属性提供了一个覆盖，以表明我们的简单自定义分区器只支持静态分区，通过返回`true`。
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If we had indicated that this partitioner does support dynamic partitions, we
    would want to provide an override for the `GetDynamicPartitions` method, which
    can be called instead of `GetPartitions` for dynamic partitioners.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们表明这个分区器支持动态分区，我们就会想要提供一个对`GetDynamicPartitions`方法的覆盖，这个方法可以用来代替`GetPartitions`方法用于动态分区器。
- en: In our case, we just had to provide an override for `GetPartitions`. This method
    returns `IList(IEnumerator(TSource))` which represents our actual partitioned
    data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只需要提供一个对`GetPartitions`方法的覆盖。这个方法返回`IList<IEnumerator<TSource>>`，它代表我们的实际分区数据。
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Lastly, we provided a `GetItems` method which is a helper that `GetPartitions`
    uses to get an enumerator for the items in our source data.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供了一个`GetItems`方法，这是一个辅助方法，`GetPartitions`使用它来获取源数据中项的枚举器。
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
