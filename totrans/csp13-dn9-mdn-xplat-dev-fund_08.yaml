- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Working with Common .NET Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作常见的 .NET 类型
- en: This chapter is about some common types that are included with .NET. These include
    types for manipulating numbers, text, and collections; improving working with
    spans, indexes, and ranges; and, in an optional online-only section, working with
    network resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些包含在 .NET 中的常见类型。这些类型包括用于操作数字、文本和集合的类型；改进对 spans、indexes 和 ranges 的处理；以及在可选的在线部分，处理网络资源。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Working with numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数字
- en: Working with text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作文本
- en: Pattern matching with regular expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式进行模式匹配
- en: Storing multiple objects in collections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集合中存储多个对象
- en: Working with spans, indexes, and ranges
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作 spans、indexes 和 ranges
- en: Working with numbers
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数字
- en: 'One of the most common types of data is numbers. The most common types in .NET
    for working with numbers are shown in *Table 8.1*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的数据类型之一是数字。在 .NET 中用于操作数字的最常见类型如 *表 8.1* 所示：
- en: '| **Namespace** | **Example types** | **Description** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间** | **示例类型** | **描述** |'
- en: '| `System` | `SByte`, `Int16`, `Int32`, `Int64`, `Int128` | Integers; that
    is, zero, and positive and negative whole numbers. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `SByte`, `Int16`, `Int32`, `Int64`, `Int128` | 整数；即零和正负整数。 |'
- en: '| `System` | `Byte`, `UInt16`, `UInt32`, `UInt64`, `UInt128` | Cardinals; that
    is, zero and positive whole numbers. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `Byte`, `UInt16`, `UInt32`, `UInt64`, `UInt128` | 基数；即零和正整数。 |'
- en: '| `System` | `Half`, `Single`, `Double` | Reals; that is, floating-point numbers.
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `Half`, `Single`, `Double` | 实数；即浮点数。 |'
- en: '| `System` | `Decimal` | Accurate reals; that is, for use in science, engineering,
    or financial scenarios. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `Decimal` | 准确的实数；即用于科学、工程或金融场景。 |'
- en: '| `System.Numerics` | `BigInteger`, `Complex`, `Quaternion` | Arbitrarily large
    integers, complex numbers, and quaternion numbers. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `System.Numerics` | `BigInteger`, `Complex`, `Quaternion` | 随意大的整数、复数和四元数。
    |'
- en: 'Table 8.1: Common .NET number types'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1：常见的 .NET 数字类型
- en: .NET has had the 32-bit `float` and 64-bit `double` types since .NET Framework
    1.0 was released in 2002\. The IEEE 754 specification also defines a 16-bit floating-point
    standard. Machine learning and other algorithms would benefit from this smaller,
    lower-precision number type; so, Microsoft introduced the `System.Half` type with
    .NET 5 and later. Currently, the C# language does not define a `half` alias, so
    you must use the .NET type `System.Half`. This might change in the future.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 2002 年 .NET Framework 1.0 发布以来，.NET 就有了 32 位的 `float` 和 64 位的 `double` 类型。IEEE
    754 规范还定义了一个 16 位的浮点数标准。机器学习和其他算法将受益于这种更小、精度更低的数字类型；因此，Microsoft 在 .NET 5 及以后的版本中引入了
    `System.Half` 类型。目前，C# 语言没有定义 `half` 别名，所以你必须使用 .NET 类型 `System.Half`。这可能在将来会改变。
- en: '`System.Int128` and `System.UInt128` were introduced with .NET 7, and they
    too do not yet have a C# alias keyword.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Int128` 和 `System.UInt128` 是在 .NET 7 中引入的，它们也没有 C# 别名关键字。'
- en: Working with big integers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作大整数
- en: The largest whole number that can be stored in .NET types that have a C# alias
    is about eighteen and a half quintillion, stored in an unsigned 64-bit integer
    using `ulong`. But what if you need to store numbers larger than that?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以存储在 .NET 类型中的最大整数是大约十八亿五千万，使用无符号 64 位整数 `ulong` 存储。但如果你需要存储比这更大的数字怎么办？
- en: 'Let’s explore numerics:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索数值：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新项目，如下面的列表所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `WorkingWithNumbers`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WorkingWithNumbers`
- en: 'Solution file and folder: `Chapter08`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter08`
- en: In the project file, add an element to statically and globally import the `System.Console`
    class.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加一个元素以静态和全局导入 `System.Console` 类。
- en: 'In `Program.cs`, delete the existing statements and then add a statement to
    import `System.Numerics`, as shown in the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后添加一个语句来导入 `System.Numerics`，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add statements to output the maximum value of the `ulong` type, and a number
    with 30 digits using `BigInteger`, as shown in the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以输出 `ulong` 类型的最大值，以及使用 `BigInteger` 的 30 位数字，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `width` constant with the value `40` in the format code means “right-align
    40 characters,” so both numbers are lined up to the right-hand edge. The `N0`
    means “use a thousand separators and zero decimal places.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`BigInteger` can represent integer values of nearly unlimited length. However,
    in reality, this is constrained by factors like available memory and computation
    time. Some APIs can also fail if the value produced is excessively large. Therefore,
    in .NET 9 and later, a maximum length for `BigInteger` has been enforced, limiting
    it to `(2^31) - 1` bits (approximately 2.14 billion bits). This translates to
    about 256 MB and approximately 646.5 million digits. This limit ensures APIs remain
    reliable and consistent while still supporting numbers far larger than most practical
    needs.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying big integers
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you multiply two 32-bit integers, the result can exceed the range of a
    32-bit integer. For instance, the maximum value of a 32-bit integer (`int`) is
    2,147,483,647\. If you multiply this by another large integer, the result can
    exceed this limit, causing an overflow and potentially resulting in incorrect
    calculations if only 32 bits are used to store the result.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Since the earliest versions of .NET, the `System.Math` class has a `BigMul`
    method that performs a multiplication of two 32-bit integers and returns the full
    64-bit result as a `long`. This method is necessary because multiplying two 32-bit
    integers using the * operator can result in a 64-bit integer, which might overflow
    the typical 32-bit integer type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 5, `BigMul` has gained overloads to multiply two signed or unsigned
    `long` values. In .NET 9 and later, the number types themselves, like `int` and
    `long` and `uint` and `ulong`, now gain `BigMul` methods to multiply their values
    and return the results in the next largest type. For example, `long.BigMul` returns
    a `System.Int128`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at how to multiply big integers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to multiply some big integers using old and
    new methods, as shown in the following code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Working with complex numbers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex number can be expressed as *a + bi*, where *a* and *b* are real numbers
    and *i* is an imaginary unit, where *i*² *= −1*. If the real part *a* is zero,
    it is a purely imaginary number. If the imaginary part *b* is zero, it is a real
    number.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers have practical applications in many **science, technology,
    engineering, and mathematics** (**STEM**) fields of study. They are added by separately
    adding the real and imaginary parts of the summands; consider this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s explore complex numbers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add two complex numbers, as shown in the
    following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '.NET 6 and earlier used a different default format for complex numbers: `(4,
    2) added to (3, 7) is (7, 9)`. In .NET 7 and later, the default format was changed
    to use angle brackets and semi-colons because some cultures use round brackets
    to indicate negative numbers and use commas for decimal numbers. At the time of
    writing, the official documentation has not been updated to use the new format,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.numerics.complex.tostring](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.complex.tostring).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6及更早版本使用不同的默认复数格式：`(4, 2)` 加上 `(3, 7)` 是 `(7, 9)`。在 .NET 7及以后版本中，默认格式已更改为使用尖括号和分号，因为某些文化使用圆括号表示负数，并使用逗号表示小数。在撰写本文时，官方文档尚未更新以使用新格式，如下列链接所示：[https://learn.microsoft.com/en-us/dotnet/api/system.numerics.complex.tostring](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.complex.tostring)。
- en: Working with tensors
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与张量一起工作
- en: Tensors are a fundamental data structure in **artificial** **intelligence**
    (**AI**). You can think of them as specialized multidimensional arrays.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 张量是 **人工智能**（**AI**）中的基本数据结构。你可以把它们看作是专门的多维数组。
- en: Tensors are used to represent and encode various forms of data, including text
    sequences (tokens), images, videos, and audio. Tensors perform computations on
    high-dimensional data with optimal efficiency and store weight information and
    intermediate calculations within neural networks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 张量用于表示和编码各种形式的数据，包括文本序列（标记）、图像、视频和音频。张量以最优效率对高维数据进行计算，并在神经网络中存储权重信息和中间计算。
- en: .NET 9 introduced a new `Tensor<T>` type that enables efficient interoperation
    with AI libraries, such as ML.NET, TorchSharp, and ONNX Runtime, and minimizes
    data copying where possible. It simplifies data manipulation through intuitive
    indexing and slicing operations, ensuring ease of use and efficiency.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9引入了一个新的 `Tensor<T>` 类型，它使与AI库（如ML.NET、TorchSharp和ONNX Runtime）的高效交互成为可能，并在可能的情况下最小化数据复制。它通过直观的索引和切片操作简化了数据操作，确保易用性和效率。
- en: Generating random numbers for games and similar apps
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为游戏和类似应用程序生成随机数
- en: 'In scenarios that don’t need truly random numbers like games, you can create
    an instance of the `Random` class, as shown in the following code example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要真正随机数的情况，如游戏中，你可以创建一个 `Random` 类的实例，如下面的代码示例所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Random` has a constructor with a parameter for specifying a seed value used
    to initialize its pseudo-random number generator, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random` 有一个构造函数，用于指定用于初始化其伪随机数生成器的种子值，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you learned in *Chapter 2*, *Speaking C#*, parameter names should use *camel
    case*. The developer who defined the constructor for the `Random` class broke
    this convention. The parameter name should be `seed`, not `Seed`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 *第2章* *讲C#* 中所学，参数名称应使用 *驼峰命名法*。定义 `Random` 类构造函数的开发者打破了这一惯例。参数名称应该是 `seed`，而不是
    `Seed`。
- en: '**Good practice**: Shared seed values act as a secret key; so, if you use the
    same random number generation algorithm with the same seed value in two applications,
    then they can generate the same “random” sequences of numbers. Sometimes this
    is necessary, for example, when synchronizing a GPS receiver with a satellite,
    or when a game needs to randomly generate the same level. But usually, you want
    to keep your seed secret.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：共享的种子值充当密钥；因此，如果你在两个应用程序中使用相同的随机数生成算法和相同的种子值，那么它们可以生成相同的“随机”数字序列。有时这是必要的，例如，当同步GPS接收器与卫星时，或者当游戏需要随机生成相同关卡时。但通常，你希望保持你的种子值保密。'
- en: Generating random numbers with the Random class
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `Random` 类生成随机数
- en: To avoid allocating more memory than necessary, .NET 6 introduced a shared static
    instance of `Random` that you can access instead of creating your own.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免分配比必要的更多内存，.NET 6引入了一个共享的静态 `Random` 实例，你可以访问它而不是创建自己的实例。
- en: 'The `Random` class has commonly used methods for generating random numbers,
    as described in the following list:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random` 类有常用的生成随机数的方法，如下列所示：'
- en: '`Next`: This method returns a random `int` (whole number) and it takes two
    parameters, `minValue` and `maxValue`, but `maxValue` is not the maximum value
    that the method returns! It is an *exclusive upper bound*, meaning `maxValue`
    is one more than the maximum value returned. Use the `NextInt64` method to return
    a `long` integer.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Next`：此方法返回一个随机`int`（整数），它接受两个参数，`minValue`和`maxValue`，但`maxValue`不是方法返回的最大值！它是一个**排他性上限**，意味着`maxValue`比返回的最大值多1。使用`NextInt64`方法返回一个`long`整数。'
- en: '`NextDouble`: This method returns a number that is greater than or equal to
    `0.0` and less than and never equal to `1.0`. Use the `NextSingle` method to return
    a `float`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NextDouble`：此方法返回一个大于或等于`0.0`且小于且从不等于`1.0`的数字。使用`NextSingle`方法返回一个`float`。'
- en: '`NextBytes`: This method populates an array of any size with random `byte`
    (`0` to `255`) values. It is common to format `byte` values as hexadecimal, for
    example, `00` to `FF`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NextBytes`：此方法使用随机`byte`（`0`到`255`）值填充任何大小的数组。通常将`byte`值格式化为十六进制，例如，`00`到`FF`。'
- en: 'Let’s see some examples of generating pseudo-random numbers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些生成伪随机数的示例：
- en: 'In `Program.cs`, add statements to access the shared `Random` instance, and
    then call its methods to generate random numbers, as shown in the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以访问共享的`Random`实例，然后调用其方法来生成随机数，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In scenarios that do need truly random numbers, like cryptography, there are
    specialized types for that, like `RandomNumberGenerator`. I cover this and other
    cryptographic types in the companion book, *Tools and Skills for .NET 8*, in a
    chapter titled *Protecting Data and Apps Using Cryptography*, published in July
    2024.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在确实需要真正随机数的情况下，例如在密码学中，有专门的数据类型，比如`RandomNumberGenerator`。我在配套书籍《.NET 8 工具与技能》中涵盖了这一点以及其他密码学类型，在标题为《使用密码学保护数据和应用程序》的章节中进行了介绍，该章节于2024年7月出版。
- en: New random methods in .NET 8 and later
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 8及以后版本的新随机方法
- en: '.NET 8 introduced two new `Random` methods, as described in the following list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8引入了两个新的`Random`方法，如下列所示：
- en: '`GetItems<T>`: This method is passed an array or read-only span of any type
    `T` of choices and the number of items you want to generate, and then it returns
    that number of items randomly selected from the choices.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetItems<T>`：此方法接受一个类型为`T`的数组或只读span的选择，以及您想要生成的项目数量，然后从选择中随机返回这些数量的项目。'
- en: '`Shuffle<T>`: This method is passed an array or span of any type `T` and the
    order of items is randomized.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shuffle<T>`：此方法接受一个类型为`T`的数组或span，并随机化项目的顺序。'
- en: 'Let’s see an example of each:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个示例：
- en: 'In `Program.cs`, add statements to access the shared `Random` instance, and
    then call its methods to generate random numbers, as shown in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以访问共享的`Random`实例，然后调用其方法来生成随机数，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Generating GUIDs
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成GUID
- en: A **globally unique identifier (GUID)** is a 128-bit text string that represents
    a unique value for identification. As a developer, you will need to generate GUIDs
    when a unique reference is needed to identify information. Traditionally, database
    and computer systems may have used an incrementing integer value, but a GUID is
    more likely to avoid conflicts in multi-tasking systems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局唯一标识符（GUID）**是一个128位的文本字符串，它代表一个用于标识的唯一值。作为开发者，当需要生成用于标识信息的唯一引用时，您将需要生成GUID。传统上，数据库和计算机系统可能使用递增的整数值，但GUID更有可能在多任务系统中避免冲突。'
- en: The `System.Guid` type is a value type (`struct`) that represents a GUID value.
    It has `Parse` and `TryParse` methods to take an existing GUID value represented
    as a `string` and convert it into the `Guid` type. It has a `NewGuid` method to
    generate a new value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Guid`类型是一个值类型（`struct`），它表示GUID值。它有`Parse`和`TryParse`方法，可以将表示为`string`的现有GUID值转换为`Guid`类型。它有一个`NewGuid`方法来生成新的值。'
- en: 'The `NewGuid` method implements version 4 of the **universally unique identifiers
    (UUIDs)** specification. You can learn about the UUID specification at the following
    link: [https://datatracker.ietf.org/doc/rfc9562/](https://datatracker.ietf.org/doc/rfc9562/).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewGuid`方法实现了**通用唯一标识符（UUID）**规范的第四版。您可以在以下链接中了解UUID规范：[https://datatracker.ietf.org/doc/rfc9562/](https://datatracker.ietf.org/doc/rfc9562/)。'
- en: .NET 9 introduced support for version 7 of the UUID specification, which allows
    you to control the first 48-bit timestamp millisecond ticks since Unix Epoch so
    that you can create sortable GUIDs. This is much better for unique IDs for databases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down an example value: `0191a398-12ec-7d5e-a8d3-8a629eae8be1`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The first 48 bits are a timestamp in hexadecimal: `0191a39812ec`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0191a398`: The first 32 bits represent the high part of the timestamp.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`12ec`: The next 16 bits continue the timestamp.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next 12 bits are a version and variant in hexadecimal: `7d5e`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `7` indicates that this is a version 7 UUID.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining three digits (`d5e`) combine parts of the timestamp and the variant,
    which is used to identify the layout of the UUID.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final 68 bits are a random section in hexadecimal: `a8d3-8a629eae8be1`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures the uniqueness of the GUID.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how we can generate GUID values and output them:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to output the value of an empty `Guid`, generate
    a new random `Guid` and then output its value, and finally output each individual
    byte of the random `Guid` value, as shown in the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the code, view the result, and note that the first parts of the three GUID
    values (`0191a398-12ec` and so on) are sortable because they are based on the
    same `DateTimeOffset` value, as shown in the following output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The EF Core team has a proposal to enable the use of version 7 GUIDs in your
    data models. You can learn more about that idea at the following link: [https://github.com/dotnet/efcore/issues/34158](https://github.com/dotnet/efcore/issues/34158).'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with text
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the other most common types of data for variables is text. The most
    common types in .NET for working with text are shown in *Table 8.2*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Type** | **Description** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Char` | Storage for a single text character |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `System` | `String` | Storage for multiple text characters |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `System.Text` | `StringBuilder` | Efficiently manipulates strings |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `System.Text.RegularExpressions` | `Regex` | Efficiently pattern-matches
    strings |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: 'Table 8.2: Common .NET types for working with text'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Getting the length of a string
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore some common tasks when working with text; for example, sometimes
    you need to find out the length of a piece of text stored in a `string` variable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithText` to the `Chapter08` solution.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithText` project, in `Program.cs`, delete the existing statements
    and then add statements to define a variable to store the name of the city, London,
    and then write its name and length to the console, as shown in the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Getting the characters of a string
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` class uses an array of `char` internally to store the text. It
    also has an indexer, which means that we can use the array syntax to read its
    characters. Array indexes start at 0, so the third character will be at index
    2.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类内部使用 `char` 数组来存储文本。它还有一个索引器，这意味着我们可以使用数组语法来读取其字符。数组索引从 0 开始，因此第三个字符将在索引
    2 处。'
- en: 'Let’s see this in action:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个动作：
- en: 'Add a statement to write the characters at the first and fourth positions in
    the `string` variable, as shown in the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句写入 `string` 变量中的第一个和第四个位置的字符，如下所示：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Splitting a string
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割字符串
- en: 'Sometimes, you need to split some text wherever there is a character, such
    as a comma:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要将文本分割成任意字符，例如逗号：
- en: 'Add statements to define a single `string` variable containing comma-separated
    city names, then use the `Split` method and specify that you want to treat commas
    as the separator, and then enumerate the returned array of `string` values, as
    shown in the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句定义一个包含以逗号分隔的城市名称的单一 `string` 变量，然后使用 `Split` 方法并指定你想要将逗号作为分隔符，然后枚举返回的 `string`
    值数组，如下所示：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Later in this chapter, you will learn how to handle more complex string-splitting
    scenarios using a regular expression.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将学习如何使用正则表达式处理更复杂的字符串分割场景。
- en: Getting part of a string
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取字符串的一部分
- en: 'Sometimes, you need to get part of some text. The `IndexOf` method has nine
    overloads that return the index position of a specified `char` or `string` within
    a `string`. The `Substring` method has two overloads, as shown in the following
    list:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要获取文本的一部分。`IndexOf` 方法有九种重载，可以返回指定 `char` 或 `string` 在 `string` 中的索引位置。`Substring`
    方法有两种重载，如下所示：
- en: '`Substring(startIndex, length)`: This returns part of a string starting at
    `startIndex` and containing the next `length` characters.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Substring(startIndex, length)`: 这将返回从 `startIndex` 开始并包含下一个 `length` 个字符的字符串部分。'
- en: '`Substring(startIndex)`: This returns part of a string starting at `startIndex`
    and containing all characters up to the end of the string.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Substring(startIndex)`: 这将返回从 `startIndex` 开始并包含直到字符串末尾的所有字符的字符串部分。'
- en: 'Let’s explore a simple example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子：
- en: 'Add statements to store a person’s full name in a `string` variable with a
    space character between the first and last names, find the position of the space,
    and then extract the first name and last name as two parts so that they can be
    recombined in a different order, as shown in the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句将一个人的全名存储在一个以空格字符分隔的 `string` 变量中，第一个和最后一个名字之间，找到空格的位置，然后提取名字和姓氏作为两部分，以便它们可以以不同的顺序重新组合，如下所示：
- en: '[PRE22]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE23]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the format of the initial full name was different, for example, `"LastName,
    FirstName"`, then the code would need to be different. As an optional exercise,
    try writing some statements that would change the input `"Shore, Alan"` into `"Alan
    Shore"`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始全名的格式不同，例如 `"LastName, FirstName"`，则代码需要不同。作为一个可选练习，尝试编写一些语句，将输入 `"Shore,
    Alan"` 转换为 `"Alan Shore"`。
- en: Checking a string for content
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查字符串内容
- en: 'Sometimes, you need to check whether a piece of text starts or ends with some
    characters or contains some characters. You can achieve this with methods named
    `StartsWith`, `EndsWith`, and `Contains`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要检查一段文本是否以某些字符开始或结束，或者是否包含某些字符。你可以使用名为 `StartsWith`、`EndsWith` 和 `Contains`
    的方法来实现这一点：
- en: 'Add statements to store a `string` value and then check if it starts with or
    contains a couple of different `char` values, as shown in the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句存储一个 `string` 值，然后检查它是否以或包含几个不同的 `char` 值，如下所示：
- en: '[PRE24]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Good practice**: `StartsWith`, `EndsWith`, and `Contains` can be passed a
    `string` or `char` value. The single quotes indicate a `char` value in the preceding
    code. Searching for a `char` like `''M''` is more efficient than searching for
    a `string` value like `"M"`.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：`StartsWith`、`EndsWith` 和 `Contains` 可以传递 `string` 或 `char` 值。单引号表示前述代码中的
    `char` 值。搜索类似 `''M''` 的 `char` 比搜索类似 `"M"` 的 `string` 值更高效。'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Comparing string values
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较字符串值
- en: Two common tasks with string values are sorting (aka collating) and comparing.
    For example, when a user enters their username or password, you need to compare
    what they entered with what is stored.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 两个常见的字符串值任务是排序（也称为整理）和比较。例如，当用户输入他们的用户名或密码时，你需要比较他们输入的内容与存储的内容。
- en: The `string` class implements the `IComparable` interface, meaning that you
    can easily compare two string values using the `CompareTo` instance method and
    it will return `-1`, `0`, or `1` depending on if the value is “less than,” “equal
    to,” or “greater than” the other. You saw an example of this when you implemented
    the `IComparable` interface for the `Person` class in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类实现了`IComparable`接口，这意味着你可以通过使用`CompareTo`实例方法轻松比较两个字符串值，它将返回`-1`、`0`或`1`，具体取决于值是“小于”、“等于”还是“大于”另一个。当你为`Person`类实现`IComparable`接口时，你看到了这个例子，如*第6章*，*实现接口和继承类*。'
- en: 'However, the lower or upper casing of characters can affect ordering, and the
    ordering rules for text are culture-dependent. For example, double-L is treated
    as a single character in traditional Spanish, as shown in *Table 8.3*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，字符的大小写可能会影响排序，文本的排序规则是文化相关的。例如，在传统的西班牙语中，双L被视为一个字符，如*表8.3*所示：
- en: '| **Culture** | **Description** | **Example string values** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **文化** | **描述** | **示例字符串值** |'
- en: '| Spanish | In 1994, the Royal Spanish Academy issued a new alphabetization
    rule to treat LL and CH as Latin alphabetic characters instead of separate individual
    characters. | Modern: `llegar` comes before `lugar`. Traditional: `llegar` comes
    after `lugar`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 西班牙语 | 在1994年，西班牙皇家学院发布了一条新的字母排序规则，将LL和CH视为拉丁字母字符，而不是单独的字符。| 现代：`llegar`排在`lugar`之前。传统：`llegar`排在`lugar`之后。|'
- en: '| Swedish | In 2006, the Swedish Academy issued a new rule. Before 2006, V
    and W were the same character. Since 2006, they have been treated as separate
    characters. | Swedish words mostly only use V. Loanwords (words taken from other
    languages) that contain W can now keep those Ws instead of replacing the Ws with
    Vs. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 瑞典语 | 在2006年，瑞典学院发布了一条新规则。在2006年之前，V和W是同一个字符。自2006年以来，它们被视为不同的字符。| 瑞典语单词大多只使用V。包含W的借词（从其他语言借来的单词）现在可以保留那些W，而不是用Vs替换W。|'
- en: '| German | Phonebook ordering is different than dictionary ordering, for example,
    umlauts are sorted as combinations of letters. | `Müller` and `Mueller` in phonebook
    ordering are the same name. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 德语 | 电话簿排序与字典排序不同，例如，重音符号被视为字母的组合。| 在电话簿排序中，`Müller`和`Mueller`是同一个名字。|'
- en: '| German | The character `ß` is sorted as `SS`. This is a common issue with
    addresses since the word for `street` is `Straße`. | `Straße` and `Strasse` have
    the same meaning. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 德语 | 字符`ß`被排序为`SS`。这是地址中常见的问题，因为“街道”这个词是`Straße`。| `Straße`和`Strasse`有相同的意思。|'
- en: 'Table 8.3: Examples of ordering rules in European languages'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.3：欧洲语言排序规则示例
- en: For consistency and performance, you sometimes want to make comparisons in a
    culture-invariant way. It is therefore better to use the `static` method `Compare`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性和性能，有时你想以文化不变的方式进行比较。因此，最好使用`static`方法`Compare`。
- en: 'Let’s see some examples:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: 'At the top of `Program.cs`, import the namespace for working with cultures
    and enable special characters like the Euro currency symbol, as shown in the following
    code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，导入用于处理文化的命名空间，并启用特殊字符，如欧元货币符号，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `Program.cs`, define some text variables and compare them in different cultures,
    as shown in the following code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，定义一些文本变量，并在不同的文化中进行比较，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the code, view the result, and note that a lowercase “a” is “less than”
    (`-1`) an uppercase “A,” so the comparison returns -1\. But we can either set
    an option to ignore case, or even better, do a culture- and case-invariant comparison
    to treat the two string values as equal (`0`), as shown in the following output:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意小写字母“a”是“小于”（`-1`）大写字母“A”，所以比较返回-1。但我们可以设置一个选项来忽略大小写，或者更好的是，进行文化和大小写不变的比较，将两个字符串值视为相等（`0`），如下面的输出所示：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**More Information**: You can learn more about `string` comparisons at the
    following link: [https://learn.microsoft.com/en-us/globalization/locale/sorting-and-string-comparison](https://learn.microsoft.com/en-us/globalization/locale/sorting-and-string-comparison).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于`string`比较的信息：[https://learn.microsoft.com/en-us/globalization/locale/sorting-and-string-comparison](https://learn.microsoft.com/en-us/globalization/locale/sorting-and-string-comparison)。'
- en: Joining, formatting, and other string members
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接、格式化和其他字符串成员
- en: 'There are many other `string` members, as shown in *Table 8.4*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如*表8.4*所示，还有很多其他的`string`成员：
- en: '| **Member** | **Description** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **成员** | **描述** |'
- en: '| `Trim`, `TrimStart`, `TrimEnd` | These methods trim whitespace characters
    such as space, tab, and carriage return from the start and/or end. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `Trim`, `TrimStart`, `TrimEnd` | 这些方法从开始和/或结束处删除空白字符，如空格、制表符和回车符。 |'
- en: '| `ToUpper`, `ToLower` | These convert all the characters into uppercase or
    lowercase. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `ToUpper`, `ToLower` | 这些将所有字符转换为大写或小写。 |'
- en: '| `Insert`, `Remove` | These methods insert or remove some text. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `Insert`, `Remove` | 这些方法用于插入或删除一些文本。 |'
- en: '| `Replace` | This replaces some text with other text. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `Replace` | 这将一些文本替换为其他文本。 |'
- en: '| `string.Empty` | This can be used instead of allocating memory each time
    you use a literal string value using an empty pair of double quotes (`""`). |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `string.Empty` | 这可以用来代替每次使用空的双引号(`""`)分配内存的文本字面量字符串值。 |'
- en: '| `string.Concat` | This concatenates two string variables. The `+` operator
    does the equivalent when used between string operands. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `string.Concat` | 这将两个字符串变量连接起来。当在字符串操作数之间使用时，`+`运算符执行等效操作。 |'
- en: '| `string.Join` | This concatenates one or more string variables with a character
    in between each one. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `string.Join` | 这将一个或多个字符串变量连接起来，每个字符串之间用一个字符隔开。 |'
- en: '| `string.IsNullOrEmpty` | This checks whether a string variable is null or
    empty. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `string.IsNullOrEmpty` | 这用于检查一个字符串变量是否为null或空。 |'
- en: '| `string.IsNullOrWhiteSpace` | This checks whether a string variable is null
    or whitespace; that is, a mix of any number of horizontal and vertical spacing
    characters, for example, tab, space, carriage return, line feed, and so on. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `string.IsNullOrWhiteSpace` | 这用于检查一个字符串变量是否为null或空白；也就是说，是任意数量的水平或垂直间隔字符的混合，例如，制表符、空格、回车、换行等。
    |'
- en: '| `string.Format` | An alternative method to string interpolation for outputting
    formatted string values, which uses positioned instead of named parameters. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `string.Format` | 这是一个用于输出格式化字符串值的替代方法，它使用位置参数而不是命名参数进行字符串插值。'
- en: 'Table 8.4: Joining, formatting, and other string members'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4：连接、格式化和其他字符串成员
- en: Some of the preceding methods are `static` methods. This means that the method
    can only be called from the type, not from a variable instance. In the preceding
    table, I indicated the static methods by prefixing them with `string.`, as in
    `string.Format`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的某些方法是`static`方法。这意味着该方法只能从类型调用，而不能从变量实例调用。在前面的表中，我通过在方法前加上`string.`前缀来指示静态方法，例如`string.Format`。
- en: 'Let’s explore some of these methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些这些方法：
- en: 'Add statements to take an array of `string` values and combine them back together
    into a single `string` variable with separators using the `Join` method, as shown
    in the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Join`方法添加语句来接收一个`string`值数组，并使用分隔符将它们组合回单个`string`变量，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add statements to use positioned parameters and interpolated `string` formatting
    syntax to output the same three variables twice, as shown in the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以使用位置参数和插值`string`格式化语法来输出相同的三个变量两次，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Some code editors, like Rider, will warn you about boxing operations. These
    are slow but not a problem in this scenario. To avoid boxing, call `ToString`
    on `price` and `when`.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些代码编辑器，如Rider，会警告你关于装箱操作。这些操作虽然慢，但在这种情况下并不是问题。为了避免装箱，请在`price`和`when`上调用`ToString`方法。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE32]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that we could have simplified the second statement because `Console.WriteLine`
    supports the same format code as `string.Format`, as shown in the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以简化第二个语句，因为`Console.WriteLine`支持与`string.Format`相同的格式代码，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Building strings efficiently
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效构建字符串
- en: You can concatenate two strings to make a new `string` using the `String.Concat`
    method or simply by using the `+` operator. But both choices are bad practices
    when combining more than a few values because .NET must create a completely new
    `string` in memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`String.Concat`方法或简单地使用`+`运算符将两个字符串连接起来以创建一个新的`string`。但是，当组合超过几个值时，这两种选择都是不好的做法，因为.NET必须在内存中创建一个全新的`string`。
- en: This might not be noticeable if you are only adding two `string` values, but
    if you concatenate inside a loop with many iterations, it can have a significant
    negative impact on performance and memory use. You can concatenate `string` variables
    more efficiently using the `StringBuilder` type.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只添加两个 `string` 值，这可能不会引起注意，但如果你在循环中多次连接字符串，它可能会对性能和内存使用产生显著的负面影响。你可以使用 `StringBuilder`
    类型更有效地连接 `string` 变量。
- en: 'I have written an online-only section for the companion book, *Apps and Services
    with .NET 8*, about performance benchmarking using `string` concatenations as
    the main example. You can optionally complete the section and its practical coding
    tasks at the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我为配套书籍 *Apps and Services with .NET 8* 编写了一个仅在网络上可用的部分，关于使用 `string` 连接作为主要示例的性能基准测试。你可以选择在以下链接完成该部分及其实际编码任务：[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md)。
- en: '**More information**: You can see examples of using `StringBuilder` at the
    following link: [https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder#examples](https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder#examples).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中看到使用 `StringBuilder` 的示例：[https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder#examples](https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder#examples)。'
- en: Working with characters
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理字符
- en: 'Sometimes, you need to work with individual characters. The `System.Char` type
    (aka `char`) has some useful methods, as shown in *Table 8.5*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要处理单个字符。`System.Char` 类型（也称为 `char`）有一些有用的方法，如下表 8.5 所示：
- en: '| **Method** | **Description** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `char.IsDigit(char)`, `char.IsDigit(string, int)` | Returns `true` if the
    character is a decimal digit. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `char.IsDigit(char)`, `char.IsDigit(string, int)` | 如果字符是十进制数字，则返回 `true`。
    |'
- en: '| `char.IsLetter(char)`, `char.IsLetter(string, int)` | Returns `true` if the
    character is a letter. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `char.IsLetter(char)`, `char.IsLetter(string, int)` | 如果字符是字母，则返回 `true`。
    |'
- en: '| `char.IsLower(char)`, `char.IsLower(string, int)` | Returns `true` if the
    character is a lowercase letter. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `char.IsLower(char)`, `char.IsLower(string, int)` | 如果字符是小写字母，则返回 `true`。
    |'
- en: '| `char.IsUpper(char)`, `char.IsUpper(string, int)` | Returns `true` if the
    character is an uppercase letter. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `char.IsUpper(char)`, `char.IsUpper(string, int)` | 如果字符是大写字母，则返回 `true`。
    |'
- en: '| `char.IsSeparator(char)`, `char.IsSeparator(string, int)` | Returns `true`
    if the character is a separator. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `char.IsSeparator(char)`, `char.IsSeparator(string, int)` | 如果字符是分隔符，则返回
    `true`。 |'
- en: '| `char.IsSymbol(char)`, `char.IsSymbol(string, int)` | Returns `true` if the
    character is a symbol. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `char.IsSymbol(char)`, `char.IsSymbol(string, int)` | 如果字符是符号，则返回 `true`。
    |'
- en: '| `char.IsWhiteSpace(char)`, `char.IsWhiteSpace(string, int)` | Returns `true`
    if the character is whitespace like a space or tab. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `char.IsWhiteSpace(char)`, `char.IsWhiteSpace(string, int)` | 如果字符是空白字符，如空格或制表符，则返回
    `true`。 |'
- en: 'Table 8.5: Methods for working with characters'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.5：处理字符的方法
- en: Searching in strings
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串中的搜索
- en: '.NET 8 introduced the `SearchValues` type, which implements an optimized method
    for searching for sets of characters or bytes within spans. For example, `SearchValues`
    helps to find the first instance of a vowel in a text value, as shown in the following
    code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 引入了 `SearchValues` 类型，该类型实现了一种在 spans 中搜索字符或字节集合的优化方法。例如，`SearchValues`
    有助于在文本值中找到第一个元音实例，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first vowel in the text `Fred` is at index position 2, as shown in the
    following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 文本 `Fred` 中的第一个元音位于索引位置 2，如下面的输出所示：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In .NET 9 or later, `SearchValues` now supports searching for substrings as
    well as searching for characters within a larger string, as shown in the following
    code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 9 或更高版本中，`SearchValues` 现在不仅支持搜索子字符串，还支持在较长的字符串中搜索字符，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first name from the list of Andor characters starts at index position 55,
    as shown in the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Andor 字符列表中的第一个名字从索引位置 55 开始，如下面的输出所示：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pattern matching with regular expressions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式进行模式匹配
- en: Regular expressions are useful for validating input from the user. They are
    very powerful and can get very complicated. Almost all programming languages have
    support for regular expressions and use a common set of special characters to
    define them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对于验证用户输入非常有用。它们非常强大，也可能变得非常复杂。几乎所有的编程语言都支持正则表达式，并使用一组常见的特殊字符来定义它们。
- en: 'Let’s try out some example regular expressions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些示例正则表达式：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithRegularExpressions` to the `Chapter08` solution.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器添加一个名为`WorkingWithRegularExpressions`的新**控制台应用程序**/`console`项目到`Chapter08`解决方案中。
- en: 'In `Program.cs`, delete the existing statements and then import the following
    namespace:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后导入以下命名空间：
- en: '[PRE38]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Checking for digits entered as text
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查作为文本输入的数字
- en: 'We will start by implementing the common example of validating number input:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现验证数字输入的常见示例：
- en: 'In `Program.cs`, add statements to prompt the user to enter their age and then
    check that it is valid using a regular expression that looks for a digit character,
    as shown in the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句提示用户输入他们的年龄，然后使用查找数字字符的正则表达式来检查其有效性，如下所示：
- en: '[PRE39]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note the following about the code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于代码的说明：
- en: The `@` character switches off the ability to use escape characters in the `string`.
    Escape characters are prefixed with a backslash. For example, `\t` means a tab
    and `\n` means a new line. When writing regular expressions, we need to disable
    this feature. To paraphrase the television show *The West Wing*, “Let backslash
    be backslash.”
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@`字符关闭了在`string`中使用转义字符的能力。转义字符以反斜杠为前缀。例如，`\t`表示制表符，`\n`表示换行符。在编写正则表达式时，我们需要禁用此功能。用电视剧《白宫风云》的话来说，“让反斜杠回归反斜杠。”'
- en: Once escape characters are disabled with `@`, then they can be interpreted by
    a regular expression. For example, `\d` means digit. You will learn about more
    regular expression symbols that are prefixed with a backslash later in this topic.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦使用`@`禁用转义字符，它们就可以被正则表达式解释。例如，`\d`表示数字。你将在本主题的后面学习到更多以反斜杠为前缀的正则表达式符号。
- en: 'Run the code, enter a whole number, such as `34`, for the age, and view the
    result, as shown in the following output:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入一个整数，例如`34`作为年龄，并查看以下输出结果：
- en: '[PRE40]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the code again, enter `carrots`, and view the result, as shown in the following
    output:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，输入`carrots`，并查看以下输出结果：
- en: '[PRE41]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the code again, enter `bob30smith`, and view the result, as shown in the
    following output:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，输入`bob30smith`，并查看以下输出结果：
- en: '[PRE42]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The regular expression we used is `\d`, which means *one digit*. However, it
    does not specify what can be entered before and after that one digit. This regular
    expression could be described in English as “Enter any characters you want as
    long as you enter at least one digit character.”
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的正则表达式是`\d`，它表示*一个数字*。然而，它并没有指定在这个数字前后可以输入什么。这个正则表达式可以用英语描述为：“输入任何你想要的字符，只要至少输入一个数字字符。”
- en: In regular expressions, you indicate the start of some input with the caret
    `^` symbol and the end of some input with the dollar `$` symbol. Let’s use these
    symbols to indicate that we expect nothing else between the start and end of the
    input except for a digit.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，你使用插入符`^`符号来指示输入的开始，使用美元符`$`来指示输入的结束。让我们使用这些符号来表示我们期望输入的开始和结束之间除了一个数字之外没有其他任何内容。
- en: 'Add a `^` and a `$` to change the regular expression to `^\d$`, as shown highlighted
    in the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`^`和一个`$`将正则表达式更改为`^\d$`，如下所示（高亮显示）：
- en: '[PRE43]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run the code again and note that it rejects any input except a single digit.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码并注意它拒绝除单个数字之外的所有输入。
- en: 'Add a `+` after the `\d` expression to modify the meaning to one or more digits,
    as shown highlighted in the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`\d`表达式后添加一个`+`来修改其含义为“一个或多个数字”，如下所示（高亮显示）：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run the code again and note the regular expression only allows zero or positive
    whole numbers of any length.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码并注意正则表达式只允许零个或多个任意长度的整数。
- en: Regular expression performance improvements
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式性能改进
- en: The .NET types for working with regular expressions are used throughout the
    .NET platform and many of the apps built with it. As such, they have a significant
    impact on performance. However, until .NET 5, they had not received much optimization
    attention from Microsoft.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理正则表达式的.NET类型在整个.NET平台以及许多使用它构建的应用程序中都被使用。因此，它们对性能有重大影响。然而，直到.NET 5，它们都没有得到微软太多的优化关注。
- en: With .NET 5 and later, the types in the `System.Text.RegularExpressions` namespace
    have rewritten implementations to squeeze out maximum performance. Common regular
    expression benchmarks using methods like `IsMatch` are now five times faster.
    The best thing is you do not have to change your code to get the benefits!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5 及更高版本中，`System.Text.RegularExpressions` 命名空间中的类型已重写实现以挤出最大性能。使用 `IsMatch`
    等方法进行的常见正则表达式基准测试现在快五倍。最好的是，你不需要更改代码就能获得这些好处！
- en: With .NET 7 and later, the `IsMatch` method of the `Regex` class now has an
    overload for a `ReadOnlySpan<char>` as its input, which gives even better performance.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 及更高版本中，`Regex` 类的 `IsMatch` 方法现在有一个针对 `ReadOnlySpan<char>` 的重载，作为其输入，这提供了更好的性能。
- en: Understanding the syntax of a regular expression
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解正则表达式的语法
- en: 'Some common symbols that you can use in regular expressions are shown in *Table
    8.6*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在正则表达式中使用的某些常见符号在 *表8.6* 中显示：
- en: '| **Symbol** | **Meaning** | **Symbol** | **Meaning** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** | **符号** | **含义** |'
- en: '| `^` | Start of input | `$` | End of input |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 输入的开始 | `$` | 输入的结束 |'
- en: '| `\d` | A single digit | `\D` | A single *non*-digit |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 单个数字 | `\D` | 单个 *非*数字 |'
- en: '| `\s` | Whitespace | `\S` | *Non*-whitespace |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空白字符 | `\S` | *非*空白字符 |'
- en: '| `\w` | Word characters | `\W` | *Non*-word characters |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 单词字符 | `\W` | *非*单词字符 |'
- en: '| `[A-Za-z0-9]` | Range(s) of characters | `\^` | ^ (caret) character |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Za-z0-9]` | 字符范围 | `\^` | ^ (上箭头) 字符 |'
- en: '| `[aeiou]` | Set of characters | `[^aeiou]` | *Not* in a set of characters
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `[aeiou]` | 字符集合 | `[^aeiou]` | *不在*字符集合中 |'
- en: '| `.` | Any single character | `\.` | . (dot) character |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 任意单个字符 | `\.` | . (点) 字符 |'
- en: 'Table 8.6: Common regular expression symbols'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.6：常见的正则表达式符号
- en: 'In addition, some common regular expression quantifiers that affect the previous
    symbols in a regular expression are shown in *Table 8.7*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些影响正则表达式中先前符号的常见正则表达式量词在 *表8.7* 中显示：
- en: '| **Symbol** | **Meaning** | **Symbol** | **Meaning** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** | **符号** | **含义** |'
- en: '| `+` | One or more | `?` | One or none |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 一个或多个 | `?` | 一个或没有 |'
- en: '| `{3}` | Exactly three | `{3,5}` | Three to five |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `{3}` | 精确三个 | `{3,5}` | 三个到五个 |'
- en: '| `{3,}` | At least three | `{,3}` | Up to three |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `{3,}` | 至少三个 | `{,3}` | 最多三个 |'
- en: 'Table 8.7: Common regular expression quantifiers'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.7：常见的正则表达式量词
- en: Examples of regular expressions
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式示例
- en: 'Some examples of regular expressions with a description of their meaning are
    shown in *Table 8.8*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些正则表达式的示例及其含义的描述在 *表8.8* 中显示：
- en: '| **Expression** | **Meaning** |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **含义** |'
- en: '| `\d` | A single digit somewhere in the input |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 输入中某处的单个数字 |'
- en: '| `a` | The character “a” somewhere in the input |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 输入中某处的字符“a” |'
- en: '| `Bob` | The word “Bob” somewhere in the input |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `Bob` | 输入中某处的单词“Bob” |'
- en: '| `^Bob` | The word “Bob” at the start of the input |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `^Bob` | 输入开头的单词“Bob” |'
- en: '| `Bob$` | The word “Bob” at the end of the input |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `Bob$` | 输入末尾的单词“Bob” |'
- en: '| `^\d{2}$` | Exactly two digits |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `^\d{2}$` | 精确两个数字 |'
- en: '| `^[0-9]{2}$` | Exactly two digits |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `^[0-9]{2}$` | 精确两个数字 |'
- en: '| `^[A-Z]{4,}$` | At least four uppercase English letters in the ASCII character
    set only |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Z]{4,}$` | 仅ASCII字符集中至少有四个大写英文字母 |'
- en: '| `^[A-Za-z]{4,}$` | At least four upper or lowercase English letters in the
    ASCII character set only |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Za-z]{4,}$` | 仅ASCII字符集中至少有四个大写或小写英文字母 |'
- en: '| `^[A-Z]{2}\d{3}$` | Two uppercase English letters in the ASCII character
    set and three digits only |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Z]{2}\d{3}$` | 仅ASCII字符集中的两个大写英文字母和三个数字 |'
- en: '| `^[A-Za-z\u00c0-\u017e]+$` | At least one uppercase or lowercase English
    letter in the ASCII character set or European letters in the Unicode character
    set, as shown in the following list:`ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝ``Þßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸŽž`
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Za-z\u00c0-\u017e]+$` | 至少有一个ASCII字符集中的大写或小写英文字母或Unicode字符集中的欧洲字母，如下所示：`ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝ``Þßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸŽž`
    |'
- en: '| `^d.g$` | The letter `d`, then any character, and then the letter `g`, so
    it would match both `dig` and `dog` or any single character between the `d` and
    `g` |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `^d.g$` | 字母 `d`，然后是任意字符，然后是字母 `g`，因此它可以匹配 `dig` 和 `dog` 或 `d` 和 `g` 之间的任意单个字符
    |'
- en: '| `^d\.g$` | The letter `d`, then a dot `.`, and then the letter `g`, so it
    would match `d.g` only |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `^d\.g$` | 字母 `d`，然后是一个点 `.`，然后是字母 `g`，因此它只会匹配 `d.g` |'
- en: 'Table 8.8: Examples of regular expressions with descriptions of their meaning'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.8：带有其含义描述的正则表达式示例
- en: '**Good practice**: Use regular expressions to validate input from the user.
    The same regular expressions can be reused in other languages, such as JavaScript
    and Python.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用正则表达式验证用户输入。相同的正则表达式可以在其他语言中重用，例如JavaScript和Python。'
- en: 'A handy website for building and testing regular expressions can be found at
    the following link: [https://regex101.com/](https://regex101.com/).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下链接找到一个方便的网站来构建和测试正则表达式：[https://regex101.com/](https://regex101.com/)。
- en: Splitting a complex comma-separated string
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割复杂的以逗号分隔的字符串
- en: Earlier in this chapter, you learned how to split a simple comma-separated string
    variable. But what about the following example of film titles?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你学习了如何分割一个简单的以逗号分隔的字符串变量。但关于以下电影标题的例子又该如何处理呢？
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `string` value uses double quotes around each film title. We can use these
    to identify whether we need to split on a comma (or not). The `Split` method is
    not powerful enough, so we can use a regular expression instead.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`值在每个电影标题周围使用双引号。我们可以使用这些引号来识别我们是否需要在逗号（或不是）上分割。`Split`方法不够强大，因此我们可以使用正则表达式。'
- en: '**Good practice**: You can read a fuller explanation in the Stack Overflow
    article that inspired this task at the following link: [https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：你可以在以下链接中阅读关于这个任务的Stack Overflow文章的更完整解释：[https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv)。'
- en: 'To include double quotes inside a `string` value, we prefix them with a backslash,
    or we could use the raw string literal feature in C# 11 or later:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`string`值中包含双引号，我们在它们前面加上反斜杠，或者我们可以在C# 11或更高版本中使用原始字符串字面量功能。
- en: 'Add statements to store a complex comma-separated `string` variable, and then
    split it in a dumb way using the `Split` method, as shown in the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以存储一个复杂的以逗号分隔的`string`变量，然后使用`Split`方法以愚蠢的方式分割它，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add statements to define a regular expression to split and write the film titles
    in a smart way, as shown in the following code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义一个正则表达式来智能地分割并写入电影标题，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In a later section, you will see how you can get a source generator to auto-generate
    XML comments for a regular expression to explain how it works. This is really
    useful for regular expressions that you might have copied from a website.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，你将看到如何获取一个源生成器来自动生成用于正则表达式的XML注释，以解释其工作原理。这对于你可能从网站上复制过来的正则表达式来说非常有用。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE48]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Activating regular expression syntax coloring
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活正则表达式语法着色
- en: 'If you use Visual Studio as your code editor, then you probably noticed that
    when passing a `string` value to the `Regex` constructor, you see color syntax
    highlighting, as shown in *Figure 8.1*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio作为代码编辑器，那么你可能已经注意到，当将`string`值传递给`Regex`构造函数时，你会看到颜色语法高亮显示，如*图8.1*所示：
- en: '![](img/B22322_08_01.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_08_01.png)'
- en: 'Figure 8.1: Regular expression color syntax highlighting when using the Regex
    constructor'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：使用Regex构造函数时正则表达式颜色语法高亮显示
- en: 'This would be a good time to remind print book readers, who will only see the
    preceding figure in grayscale, that they can see all figures in full color as
    a PDF at the following link: [https://packt.link/gbp/9781837635870](https://packt.link/gbp/9781837635870).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是提醒打印书籍读者的大好时机，他们只能看到前面的灰度图，他们可以在以下链接中看到所有图的全彩PDF：[https://packt.link/gbp/9781837635870](https://packt.link/gbp/9781837635870)。
- en: 'Why does this `string` get syntax coloring for regular expressions when most
    `string` values do not? Let’s find out:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个`string`在大多数`string`值中不会进行语法着色，而它会呢？让我们找出答案：
- en: 'Right-click on the `new` constructor, select **Go To Implementation**, and
    note the `string` parameter named `pattern` is decorated with an attribute named
    `StringSyntax` that has the `string` constant `Regex` value passed to it, as shown
    highlighted in the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`new`构造函数，选择**转到实现**，注意名为`pattern`的`string`参数被一个名为`StringSyntax`的属性装饰，该属性传递了具有`Regex`常量值的`string`，如下面的代码所示，高亮显示：
- en: '[PRE49]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Right-click on the `StringSyntax` attribute, select **Go To Implementation**,
    and note there are 12 recognized `string` syntax formats that you can choose from
    as well as `Regex`, as shown in the following partial code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`StringSyntax`属性，选择**转到实现**，注意有12种已识别的`string`语法格式可供选择，以及`Regex`，如下面的部分代码所示：
- en: '[PRE50]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `WorkingWithRegularExpressions` project, add a new class file named
    `Program.Strings.cs`, delete any existing statements, and then define some `string`
    constants in a partial `Program` class, as shown in the following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithRegularExpressions` 项目中，添加一个名为 `Program.Strings.cs` 的新类文件，删除任何现有语句，然后在部分
    `Program` 类中定义一些 `string` 常量，如下所示：
- en: '[PRE51]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the two `string` constants do not have any color syntax highlighting
    yet.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个 `string` 常量还没有任何颜色语法高亮。
- en: 'In `Program.cs`, replace the literal `string` with the `string` constant for
    the digits-only regular expression, as shown highlighted in the following code:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，将字面量 `string` 替换为仅包含数字的正则表达式的 `string` 常量，如下所示，代码中已高亮显示：
- en: '[PRE52]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In `Program.cs`, replace the literal `string` with the `string` constant for
    the comma-separator regular expression, as shown highlighted in the following
    code:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，将字面量 `string` 替换为逗号分隔的正则表达式的 `string` 常量，如下所示，代码中已高亮显示：
- en: '[PRE53]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Run the `WorkingWithRegularExpressions` project and confirm that the regular
    expression behavior is as before.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `WorkingWithRegularExpressions` 项目并确认正则表达式的行为与之前相同。
- en: 'In `Program.Strings.cs`, import the namespace for the `[StringSyntax]` attribute
    and then decorate both `string` constants with it, as shown highlighted in the
    following code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Strings.cs` 文件中，导入 `[StringSyntax]` 属性的命名空间，然后将其装饰在两个 `string` 常量上，如下所示，代码中已高亮显示：
- en: '[PRE54]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `Program.Strings.cs`, add another `string` constant for formatting a date,
    as shown in the following code:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Strings.cs` 文件中，添加另一个用于格式化日期的 `string` 常量，如下所示：
- en: '[PRE55]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Click inside the empty string, type the letter `d`, and note the IntelliSense
    explanation, as shown in *Figure 8.2*:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空字符串中单击，输入字母 `d`，并注意 IntelliSense 说明，如图 8.2 所示：
- en: '![](img/B22322_08_02.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_08_02.png)'
- en: 'Figure 8.2: IntelliSense activated due to the StringSyntax attribute'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：由于 StringSyntax 属性激活的 IntelliSense
- en: 'Finish entering the date format and as you type, note the IntelliSense value:
    `dddd, d MMMM yyyy`.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成输入日期格式，并随着您输入，注意 IntelliSense 值：`dddd, d MMMM yyyy`。
- en: 'Inside, at the end of the `DigitsOnlyText` string literal, enter `\`, and note
    the IntelliSense to help you write a valid regular expression, as shown in *Figure
    8.3*:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部，在 `DigitsOnlyText` 字面量字符串的末尾输入 `\`，并注意 IntelliSense 帮助您编写有效的正则表达式，如图 8.3
    所示：
- en: '![](img/B22322_08_03.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_08_03.png)'
- en: 'Figure 8.3: IntelliSense for writing a regular expression'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：编写正则表达式的 IntelliSense
- en: Delete the `\` that you entered to trigger IntelliSense.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除您输入的 `\` 以触发 IntelliSense。
- en: The `[StringSyntax]` attribute is a feature introduced in .NET 7\. It depends
    on your code editor whether it is recognized. The .NET BCL has more than 350 parameters,
    properties, and fields that are now decorated with this attribute.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`[StringSyntax]` 属性是在 .NET 7 中引入的功能。它是否被识别取决于您的代码编辑器。.NET BCL 现在有超过 350 个参数、属性和字段被这个属性装饰。'
- en: Improving regular expression performance with source generators
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用源生成器提高正则表达式性能
- en: When you pass a string literal or string constant to the constructor of `Regex`,
    the class parses the string and transforms it into an internal tree structure
    that represents the expression in an optimized way that can be executed efficiently
    by a regular expression interpreter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将字符串字面量或字符串常量传递给 `Regex` 构造函数时，该类会解析字符串并将其转换为内部树结构，以优化方式表示表达式，以便正则表达式解释器可以高效地执行。
- en: 'You can also compile regular expressions by specifying `RegexOptions`, as in
    the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过指定 `RegexOptions` 来编译正则表达式，如下所示：
- en: '[PRE56]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Unfortunately, compiling has the negative effect of slowing down the initial
    creation of the regular expression. After creating the tree structure that would
    then be executed by the interpreter, the compiler then must convert the tree into
    IL code, and then that IL code needs to be JIT compiled into native code. If you’re
    only running the regular expression a few times, it is not worth compiling it,
    which is why it is not the default behavior. If you’re running the regular expression
    more than a few times, for example, because it will be used to validate the URL
    for every incoming HTTP request to a website, then it is worth compiling. But
    even then, you should only use compilation if you must use .NET 6 or earlier.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，编译会有负面影响，会减慢正则表达式初始创建的速度。在创建出将被解释器执行的树结构之后，编译器必须将树转换为IL代码，然后该IL代码需要被JIT编译成原生代码。如果你只运行正则表达式几次，那么编译它并不值得，这也是为什么它不是默认行为的原因。如果你运行正则表达式超过几次，例如，因为它将被用来验证网站每个传入的HTTP请求的URL，那么编译它是有意义的。但即使如此，你也应该只在必须使用.NET
    6或更早版本的情况下使用编译。
- en: .NET 7 introduced a source generator for regular expressions that recognizes
    if you decorate a partial method that returns `Regex` with the `[GeneratedRegex]`
    attribute. It generates an implementation of that method that implements the logic
    for the regular expression. .NET 9 allows you to use partial properties, which
    have a more natural syntax.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 7引入了一个用于正则表达式的源生成器，它可以识别你是否使用`[GeneratedRegex]`属性装饰了一个返回`Regex`的部分方法。它生成一个实现该方法的实现，该实现实现了正则表达式的逻辑。.NET
    9允许你使用部分属性，它具有更自然的语法。
- en: 'Let’s see this in action:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际效果：
- en: 'In the `WorkingWithRegularExpressions` project, add a new class file named
    `Program.Regexs.cs` and modify its content to define some `partial` properties,
    as shown in the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithRegularExpressions`项目中，添加一个名为`Program.Regexs.cs`的新类文件，并修改其内容以定义一些`partial`属性，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In `Program.cs`, replace the `new` constructor with a call to the `partial`
    method that returns the digits-only regular expression, as shown highlighted in
    the following code:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，将`new`构造函数替换为调用返回仅数字的正则表达式的`partial`方法，如下面高亮显示的代码所示：
- en: '[PRE58]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `Program.cs`, replace the new constructor with a call to the `partial` method
    that returns the comma-separator regular expression, as shown highlighted in the
    following code:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，将新的构造函数替换为调用返回逗号分隔正则表达式的`partial`方法，如下面高亮显示的代码所示：
- en: '[PRE59]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Hover your mouse pointer over the `partial` methods and note the tooltip describes
    the behavior of the regular expression, as shown in *Figure 8.4*:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在`partial`方法上，注意工具提示描述了正则表达式的行为，如图*图8.4*所示：
- en: '![](img/B22322_08_04.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_08_04.png)'
- en: 'Figure 8.4: Tooltip for a partial method shows a description of the regular
    expression'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：部分方法的工具提示显示了正则表达式的描述
- en: 'Right-click the `DigitsOnly` `partial` method, select **Go To Definition**,
    and note that you can review the implementation of the auto-generated partial
    methods, as shown in *Figure 8.5*:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`DigitsOnly` `partial`方法，选择**转到定义**，并注意你可以查看自动生成的部分方法的实现，如图*图8.5*所示：
- en: '![](img/B22322_08_05.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_08_05.png)'
- en: 'Figure 8.5: The auto-generated source code for the regular expression'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：正则表达式的自动生成源代码
- en: Run the project and confirm that the functionality is the same as before.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并确认功能与之前相同。
- en: 'You can learn more about the improvements to regular expressions with .NET
    7 at the following link: [https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7](https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于.NET 7对正则表达式改进的信息：[https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7](https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7)。
- en: Storing multiple objects in collections
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合中存储多个对象
- en: Another of the most common types of data is collections. If you need to store
    multiple values in a variable, then you can use a collection.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种最常见的数据类型是集合。如果你需要在一个变量中存储多个值，那么你可以使用集合。
- en: A collection is a data structure in memory that can manage multiple items in
    different ways, although all collections have some shared functionality.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是在内存中可以以不同方式管理多个项的数据结构，尽管所有集合都有一些共享的功能。
- en: 'The most common types in .NET for working with collections are shown in *Table
    8.9*:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中用于处理集合的最常见类型如表*表8.9*所示：
- en: '| **Namespace** | **Example types** | **Description** |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间** | **示例类型** | **描述** |'
- en: '| `System .Collections` | `IEnumerable`,`IEnumerable<T>` | Interfaces and base
    classes used by collections. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `System .Collections` | `IEnumerable`,`IEnumerable<T>` | 集合使用的接口和基类。|'
- en: '| `System .Collections .Generic` | `List<T>`,`Dictionary<T>`,`Queue<T>`,`Stack<T>`
    | Introduced in C# 2.0 with .NET Framework 2.0\. These collections allow you to
    specify the type you want to store using a generic type parameter (which is safer,
    faster, and more efficient). |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `System .Collections .Generic` | `List<T>`,`Dictionary<T>`,`Queue<T>`,`Stack<T>`
    | 在 C# 2.0 和 .NET Framework 2.0 中引入。这些集合允许你使用泛型类型参数指定你想要存储的类型（这更安全、更快、更高效）。|'
- en: '| `System .Collections .Concurrent` | `BlockingCollection`,`ConcurrentDictionary`,`ConcurrentQueue`
    | These collections are safe to use in multithreaded scenarios. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `System .Collections .Concurrent` | `BlockingCollection`,`ConcurrentDictionary`,`ConcurrentQueue`
    | 这些集合在多线程场景中是安全的。|'
- en: '| `System .Collections .Immutable` | `ImmutableArray`,`ImmutableDictionary`,`ImmutableList`,`ImmutableQueue`
    | Designed for scenarios where the contents of the original collection will never
    change, although they can create modified collections as a new instance. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `System .Collections .Immutable` | `ImmutableArray`,`ImmutableDictionary`,`ImmutableList`,`ImmutableQueue`
    | 设计用于原始集合的内容永远不会更改的场景，尽管它们可以创建作为新实例的修改后的集合。|'
- en: 'Table 8.9: Common .NET collection types'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.9：常见的 .NET 集合类型
- en: Common features of all collections
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有集合的共同特性
- en: 'All collections implement the `ICollection` interface; this means that they
    must have a `Count` property to tell you how many objects are in them, and three
    other members, as shown in the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都实现了 `ICollection` 接口；这意味着它们必须有一个 `Count` 属性来告诉你它们中有多少对象，以及三个其他成员，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For example, if we had a collection named `passengers`, we could do this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个名为 `passengers` 的集合，我们可以这样做：
- en: '[PRE61]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you have probably surmised, `CopyTo` copies the collection to an array. `IsSynchronized`
    and `SyncRoot` are used in multithreading scenarios, so I do not cover them in
    this book.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能推测的那样，`CopyTo` 将集合复制到数组中。`IsSynchronized` 和 `SyncRoot` 用于多线程场景，因此我在这本书中没有涵盖它们。
- en: 'All collections implement the `IEnumerable` interface, which means that they
    can be iterated using the `foreach` statement. They must have a `GetEnumerator`
    method that returns an object that implements `IEnumerator`; this means that the
    returned `object` must have `MoveNext` and `Reset` methods for navigating through
    the collection and a `Current` property containing the current item in the collection,
    as shown in the following code:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都实现了 `IEnumerable` 接口，这意味着它们可以使用 `foreach` 语句进行迭代。它们必须有一个 `GetEnumerator`
    方法，该方法返回一个实现 `IEnumerator` 的对象；这意味着返回的 `object` 必须有 `MoveNext` 和 `Reset` 方法来遍历集合，以及一个包含集合中当前项目的
    `Current` 属性，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For example, to perform an action on each object in the `passengers` collection,
    we could write the following code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要对 `passengers` 集合中的每个对象执行操作，我们可以编写以下代码：
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As well as the `object`-based collection interface, there is also a generic
    collection interface, where the generic type defines the type stored in the collection.
    It has additional members like `IsReadOnly`, `Add`, `Clear`, `Contains`, and `Remove`,
    as shown in the following code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于 `object` 的集合接口之外，还有一个泛型集合接口，其中泛型类型定义了集合中存储的类型。它具有额外的成员，如 `IsReadOnly`、`Add`、`Clear`、`Contains`
    和 `Remove`，如下面的代码所示：
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Working with lists
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与列表一起工作
- en: 'Lists, that is, a type that implements `IList<T>`, are **ordered collections**,
    with an `int` index to show the position of an item within the list, as shown
    in the following code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，即实现 `IList<T>` 的类型，是**有序集合**，有一个 `int` 索引来显示项目在列表中的位置，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `[DefaultMember]` attribute allows you to specify which member is accessed
    by default when no member name is specified. To make `IndexOf` the default member,
    you would use `[DefaultMember("IndexOf")]`. To specify the indexer, you use `[DefaultMember("Item")]`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`[DefaultMember]` 属性允许你在未指定成员名称时指定哪个成员被默认访问。要将 `IndexOf` 设置为默认成员，你可以使用 `[DefaultMember("IndexOf")]`。要指定索引器，你使用
    `[DefaultMember("Item")]`。'
- en: '`IList<T>` derives from `ICollection<T>`, so it has a `Count` property, and
    an `Add` method to put an item at the end of the collection, as well as an `Insert`
    method to put an item in the list at a specified position, and `RemoveAt` to remove
    an item at a specified position.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList<T>` 从 `ICollection<T>` 派生，因此它有一个 `Count` 属性，一个将项目添加到集合末尾的 `Add` 方法，以及一个将项目插入到列表中指定位置的
    `Insert` 方法，还有一个从指定位置删除项目的 `RemoveAt` 方法。'
- en: 'Lists are a good choice when you want to manually control the order of items
    in a collection. Each item in a list has a unique index (or position) that is
    automatically assigned. Items can be any type defined by `T` and items can be
    duplicated. Indexes are `int` types and start from `0`, so the first item in a
    list is at index `0`, as shown in *Table 8.10*:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要手动控制集合中项目的顺序时，列表是一个不错的选择。列表中的每个项目都有一个唯一的索引（或位置），它是自动分配的。项目可以是`T`定义的任何类型，并且项目可以重复。索引是`int`类型，从`0`开始，因此列表中的第一个项目位于索引`0`，如*表8.10*所示：
- en: '| **Index** | **Item** |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| **索引** | **项目** |'
- en: '| 0 | London |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 伦敦 |'
- en: '| 1 | Paris |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 巴黎 |'
- en: '| 2 | London |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 伦敦 |'
- en: '| 3 | Sydney |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 悉尼 |'
- en: 'Table 8.10: Cities in a list with indexes'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.10：具有索引的列表中的城市
- en: 'If a new item (for example, Santiago) is inserted between London and Sydney,
    then the index of Sydney is automatically incremented. Therefore, you must be
    aware that an item’s index can change after inserting or removing items, as shown
    in *Table 8.11*:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在伦敦和悉尼之间插入一个新的项目（例如，圣地亚哥），那么悉尼的索引将自动增加。因此，你必须意识到在插入或删除项目后，项目的索引可能会发生变化，如*表8.11*所示：
- en: '| **Index** | **Item** |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| **索引** | **项目** |'
- en: '| 0 | London |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 伦敦 |'
- en: '| 1 | Paris |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 巴黎 |'
- en: '| 2 | London |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 伦敦 |'
- en: '| 3 | Santiago |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 圣地亚哥 |'
- en: '| 4 | Sydney |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 悉尼 |'
- en: 'Table 8.11: Cities list after an item is inserted'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.11：插入项目后的城市列表
- en: '**Good practice**: Some developers can get into the poor habit of using `List<T>`
    and other collections when an array would be better. Use arrays instead of collections
    if the data will not change size after instantiation. You should also use lists
    initially while you are adding and removing items, but then convert them into
    an array once you are done with manipulating the items.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：一些开发者可能会养成在应该使用数组时使用`List<T>`和其他集合的坏习惯。如果数据在实例化后不会改变大小，请使用数组而不是集合。在你添加和删除项目时，也应该最初使用列表，但一旦你完成对项目的操作，就将其转换为数组。'
- en: 'Let’s explore lists:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索列表：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithCollections` to the `Chapter08` solution.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器将一个新的**控制台应用程序**/ `console` 项目命名为`WorkingWithCollections`添加到`Chapter08`解决方案中。
- en: Add a new class file named `Program.Helpers.cs`.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Program.Helpers.cs`的新类文件。
- en: 'In `Program.Helpers.cs`, define a partial `Program` class with a generic method
    to output a collection of `T` values with a title, as shown in the following code:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Helpers.cs`中，定义一个部分`Program`类，其中包含一个泛型方法，用于输出带有标题的`T`值集合，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In `Program.cs`, delete the existing statements and then add some statements
    to illustrate some of the common ways of defining and working with lists, as shown
    in the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后添加一些语句来展示一些定义和操作列表的常见方法，如下面的代码所示：
- en: '[PRE67]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE68]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Good practice**: LINQ has extension methods named `All()` and `Count()` that
    work like the `List<T>` class `TrueForAll()` method and `Count` property respectively.
    You will generally achieve better performance by using methods provided by a class
    rather than the more general LINQ methods.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：LINQ有名为`All()`和`Count()`的扩展方法，分别像`List<T>`类的`TrueForAll()`方法和`Count`属性一样工作。通常，使用类提供的方法而不是更通用的LINQ方法可以获得更好的性能。'
- en: Working with dictionaries
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字典
- en: Dictionaries are a good choice when each **value** (or object) has a unique
    sub-value (or a made-up value) that can be used as a **key** to quickly find a
    value in the collection later. The key must be unique. For example, if you are
    storing a list of people, you could choose to use a government-issued identity
    number as the key. Dictionaries are called **hashmaps** in other languages like
    Python and Java.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个**值**（或对象）都有一个唯一的子值（或一个虚构的值）可以用作**键**来快速在集合中查找值时，字典是一个不错的选择。键必须是唯一的。例如，如果你正在存储人员列表，你可以选择使用政府颁发的身份证号码作为键。在其他语言如Python和Java中，字典被称为**哈希表**。
- en: Think of the key as being like an index entry in a real-world dictionary. It
    allows you to quickly find the definition of a word because the words (in other
    words, keys) are kept sorted; if we know we’re looking for the definition of *manatee*,
    we will jump to the middle of the dictionary to start looking, because the letter
    *m* is in the middle of the alphabet.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将键想象成现实世界字典中的索引条目。它允许你快速找到单词的定义，因为单词（换句话说，键）是按顺序排列的；如果我们知道我们正在寻找*海牛*的定义，我们将跳到字典的中间开始查找，因为字母*m*在字母表的中间。
- en: 'Dictionaries in programming are similarly smart when looking something up.
    They must implement the interface `IDictionary<TKey, TValue>`, as shown in the
    following code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，字典在查找内容时同样智能。它们必须实现`IDictionary<TKey, TValue>`接口，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Items in a dictionary are instances of the `struct`, aka the value type, `KeyValuePair<TKey,
    TValue>`, where `TKey` is the type of the key and `TValue` is the type of the
    value, as shown in the following code:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的项目是`struct`类型的实例，也称为值类型`KeyValuePair<TKey, TValue>`，其中`TKey`是键的类型，`TValue`是值的类型，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'An example `Dictionary<string, Person>` uses a `string` as the key and a `Person`
    instance as the value. `Dictionary<string, string>` uses `string` values for both,
    as shown in *Table 8.12*:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Dictionary<string, Person>`示例使用`string`作为键，`Person`实例作为值。`Dictionary<string,
    string>`使用`string`作为两个值，如下表8.12所示：
- en: '| **Key** | **Value** |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **值** |'
- en: '| BSA | Bob Smith |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| BSA | Bob Smith |'
- en: '| MW | Max Williams |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| MW | Max Williams |'
- en: '| BSB | Bob Smith |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| BSB | Bob Smith |'
- en: '| AM | Amir Mohammed |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| AM | Amir Mohammed |'
- en: 'Table 8.12: Dictionary with keys and values'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.12：具有键和值的字典
- en: 'Let’s explore dictionaries:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索字典：
- en: 'At the top of `Program.cs`, define an alias for the `Dictionary<TKey, TValue>`
    class, where `TKey` and `TValue` are both `string`, as shown in the following
    code:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，为`Dictionary<TKey, TValue>`类定义一个别名，其中`TKey`和`TValue`都是`string`，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In `Program.cs`, add some statements to illustrate some of the common ways
    of working with dictionaries, for example, looking up word definitions, as shown
    in the following code:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加一些语句来展示一些与字典一起工作的常见方式，例如查找单词定义，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The trailing commas after the third item is added to the dictionary are optional
    and the compiler will not complain about them. This is convenient so that you
    can change the order of the three items without having to delete and add commas
    in the right places.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中添加到第三个项目的尾随逗号是可选的，编译器不会对此提出异议。这样做很方便，这样你就可以在不删除和添加逗号的情况下更改三个项目的顺序。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE73]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In *Chapter 11*, *Querying and Manipulating Data Using LINQ*, you will learn
    how to create dictionaries and lookups from existing data sources, like tables
    in a database, using LINQ methods, like `ToDictionary` and `ToLookup`. This is
    much more common than manually adding items to a dictionary, as shown in this
    section.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中，你将学习如何使用LINQ方法，如`ToDictionary`和`ToLookup`，从现有数据源创建字典和查找，例如数据库中的表。这比手动向字典中添加项目更为常见，如本节所示。
- en: Sets, stacks, and queues
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合、栈和队列
- en: '**Sets** are a good choice when you want to perform set operations between
    two collections. For example, you may have two collections of city names, and
    you want to know which names appear in both sets (known as the *intersect* between
    the sets). Items in a set must be unique.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是在你想要在两个集合之间执行集合操作时的一个好选择。例如，你可能有两个城市名称的集合，并且想知道哪些名称同时出现在两个集合中（称为集合的*交集*）。集合中的元素必须是唯一的。'
- en: 'Common set methods are shown in *Table 8.13*:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 常见集合方法如表8.13所示：
- en: '| **Method** | **Description** |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Add` | If the item does not already exist in the set, then it is added.
    This returns `true` if the item was added, and `false` if it was already in the
    set. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `Add` | 如果项目尚未存在于集合中，则将其添加。如果项目已添加，则返回`true`，如果项目已在集合中，则返回`false`。|'
- en: '| `ExceptWith` | This removes the items in the set passed as the parameter
    from the set. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `ExceptWith` | 这将从参数传递的集合中删除项目。|'
- en: '| `IntersectWith` | This removes the items not in the set passed as the parameter
    and in the set. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `IntersectWith` | 这将从参数传递的集合和集合中删除不在集合中的项目。|'
- en: '| `IsProperSubsetOf`, `IsProperSupersetOf`, `IsSubsetOf`, `IsSupersetOf` |
    A subset is a set whose items are all in the other set. A proper subset is a set
    whose items are all in the other set but there is at least one item in the other
    set that is not in the set. A superset is a set that contains all the items in
    the other set. A proper superset is a set that contains all the items in the other
    set and at least one more not in the other set. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `IsProperSubsetOf`, `IsProperSupersetOf`, `IsSubsetOf`, `IsSupersetOf` |
    子集是一个包含其他集合中所有元素的集合。真子集是一个包含其他集合中所有元素但至少有一个元素不在该集合中的集合。超集是一个包含其他集合中所有元素的集合。真超集是一个包含其他集合中所有元素并且至少有一个元素不在其他集合中的集合。|'
- en: '| `Overlaps` | The set and the other set share at least one common item. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `Overlaps` | 该集合与另一个集合至少共享一个共同的项目。|'
- en: '| `SetEquals` | The set and the other set contain exactly the same items. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `SetEquals` | 该集合与另一个集合包含完全相同的项。|'
- en: '| `SymmetricExceptWith` | This removes the items not in the set passed as the
    parameter from the set and adds any that are missing. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `SymmetricExceptWith` | 这将从集合中移除作为参数传递的集合中不存在的项，并添加任何缺失的项。|'
- en: '| `UnionWith` | This adds any items in the set passed as the parameter to the
    set that are not already in the set. |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `UnionWith` | 这会将作为参数传递给集合的任何不在集合中的项添加到集合中。|'
- en: 'Table 8.13: Set methods'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.13：集合方法
- en: 'Let’s explore example code for sets:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索集合的示例代码：
- en: 'In `Program.cs`, add some statements to add items to a set, as shown in the
    following code:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一些语句来向集合中添加项，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE75]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You will see more set operations in *Chapter 11*, *Querying and Manipulating
    Data Using LINQ*.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第11章中看到更多的集合操作，*查询和操作数据使用LINQ*。
- en: '**Stacks** are a good choice when you want to implement **last-in, first-out**
    (**LIFO**) behavior. With a stack, you can only directly access or remove the
    one item at the top of the stack, although you can enumerate to read through the
    whole stack of items. You cannot, for example, directly access the second item
    in a stack.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**是当你想要实现**后进先出**（**LIFO**）行为时的一个不错的选择。使用栈，你只能直接访问或移除栈顶的一个项，尽管你可以枚举来读取整个栈中的项。例如，你不能直接访问栈中的第二个项。'
- en: For example, word processors use a stack to remember the sequence of actions
    you have recently performed, and then, when you press *Ctrl* + *Z*, it will undo
    the last action in the stack, and then the next-to-last action, and so on.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，文字处理器使用栈来记住你最近执行的操作序列，然后，当你按下*Ctrl* + *Z*时，它将撤销栈中的最后一个操作，然后是倒数第二个操作，依此类推。
- en: '**Queues** are a good choice when you want to implement **first-in, first-out**
    (**FIFO**) behavior. With a queue, you can only directly access or remove the
    item at the front of the queue, although you can enumerate to read through the
    whole queue of items. You cannot, for example, directly access the second item
    in a queue.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是当你想要实现**先进先出**（**FIFO**）行为时的一个不错的选择。使用队列，你只能直接访问或移除队列前端的项，尽管你可以枚举来读取整个队列中的项。例如，你不能直接访问队列中的第二个项。'
- en: For example, background processes use a queue to process work items in the order
    that they arrive, just like people standing in line at the post office.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，后台进程使用队列按到达顺序处理工作项，就像人们在邮局排队一样。
- en: .NET 6 introduced the `PriorityQueue`, where each item in the queue has a priority
    value assigned, as well as its position in the queue.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 引入了`PriorityQueue`，其中队列中的每个项都有一个优先级值，以及其在队列中的位置。
- en: 'Let’s explore example code for queues:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索队列的示例代码：
- en: 'In `Program.cs`, add some statements to illustrate some of the common ways
    of working with queues, for example, handling customers in a queue for coffee,
    as shown in the following code:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一些语句来展示一些与队列一起工作的常见方式，例如处理咖啡店中的排队顾客，如下面的代码所示：
- en: '[PRE76]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE77]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In `Program.Helpers.cs`, in the partial `Program` class, add a static method
    named `OutputPQ`, as shown in the following code:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Helpers.cs`中，在部分`Program`类中，添加一个名为`OutputPQ`的静态方法，如下面的代码所示：
- en: '[PRE78]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that the `OutputPQ` method is generic. You can specify the two types used
    in the tuples that are passed in as `collection`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`OutputPQ`方法是一个泛型方法。你可以指定作为`collection`传入的元组中使用的两个类型。
- en: 'In `Program.cs`, add some statements to illustrate some of the common ways
    of working with priority queues, as shown in the following code:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一些语句来展示一些与优先队列一起工作的常见方式，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE80]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: .NET 9 introduced a `Remove` method to `PriorityQueue`. The method performs
    a linear-time scan through each element in the heap, removing the first occurrence
    that matches the specified element parameter. If there are duplicate entries,
    the method removes one of them in a non-deterministic manner, without considering
    any priority.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9 引入了一个`Remove`方法到`PriorityQueue`。该方法在堆中的每个元素上执行线性时间扫描，移除与指定元素参数匹配的第一个出现。如果有重复条目，该方法将以非确定性的方式移除其中一个，而不考虑任何优先级。
- en: Collection add and remove methods
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合添加和移除方法
- en: 'Each collection has a different set of methods to “add” and “remove” items,
    as shown in *Table 8.14*:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都有不同的方法来“添加”和“移除”项目，如表8.14所示：
- en: '| **Collection** | **“Add” methods** | **“Remove” methods** | **Description**
    |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| **集合** | **“添加”方法** | **“移除”方法** | **描述** |'
- en: '| `List` | `Add`, `Insert` | `Remove`, `RemoveAt` | Lists are ordered so items
    have an integer index position. `Add` will add a new item at the end of the list.
    `Insert` will add a new item at the index position specified. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| `List` | `Add`, `Insert` | `Remove`, `RemoveAt` | 列表是有序的，因此项目具有整数索引位置。`Add`将在列表末尾添加新项目。`Insert`将在指定的索引位置添加新项目。|'
- en: '| `Dictionary` | `Add` | `Remove` | Dictionaries are not ordered so items do
    not have integer index positions. You can check if a key has been used by calling
    the `ContainsKey` method. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| `Dictionary` | `Add` | `Remove` | 字典是无序的，因此项目没有整数索引位置。您可以通过调用`ContainsKey`方法来检查是否使用了键。|'
- en: '| `Stack` | `Push` | `Pop` | Stacks always add a new item at the top of the
    stack using the `Push` method. The first item is at the bottom. Items are always
    removed from the top of the stack using the `Pop` method. Call the `Peek` method
    to see this value without removing it. Stacks are LIFO. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `Stack` | `Push` | `Pop` | 栈始终使用`Push`方法在栈顶添加新项目。第一个项目位于栈底。始终使用`Pop`方法从栈顶移除项目。调用`Peek`方法可以查看此值而不移除它。栈是LIFO（后进先出）。|'
- en: '| `Queue` | `Enqueue` | `Dequeue` | Queues always add a new item at the end
    of the queue using the `Enqueue` method. The first item is at the front of the
    queue. Items are always removed from the front of the queue using the `Dequeue`
    method. Call the `Peek` method to see this value without removing it. Queues are
    FIFO. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `Queue` | `Enqueue` | `Dequeue` | 队列始终使用`Enqueue`方法在队列末尾添加新项目。第一个项目位于队列前端。始终使用`Dequeue`方法从队列前端移除项目。调用`Peek`方法可以查看此值而不移除它。队列是FIFO（先进先出）。|'
- en: 'Table 8.14: Collection “add” and “remove” methods'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.14：集合“添加”和“移除”方法
- en: Sorting collections
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序集合
- en: A `List<T>` class can be sorted by manually calling its `Sort` method (but remember
    that the indexes of each item will change). Manually sorting a list of `string`
    values or other built-in types will work without extra effort on your part, but
    if you create a collection of your own type, then that type must implement an
    interface named `IComparable`. You learned how to do this in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类可以通过手动调用其`Sort`方法进行排序（但请记住，每个项目的索引将发生变化）。手动对字符串值或其他内置类型的列表进行排序不需要您额外努力，但如果您创建了自己的类型集合，那么该类型必须实现名为`IComparable`的接口。您在*第6章*，*实现接口和继承类*中学到了如何做到这一点。'
- en: A `Stack<T>` or `Queue<T>` collection cannot be sorted because you wouldn’t
    usually want that functionality; for example, you would probably never sort a
    queue of guests checking into a hotel. But sometimes, you might want to sort a
    dictionary or a set.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack<T>`或`Queue<T>`集合无法排序，因为您通常不希望有这种功能；例如，您可能永远不会对酒店入住的客人队列进行排序。但有时，您可能想要对字典或集合进行排序。'
- en: Sometimes, it would be useful to have an automatically sorted collection, that
    is, one that maintains the items in a sorted order as you add and remove them.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，拥有一个自动排序的集合会很有用，即一个在添加和移除项目时保持排序顺序的集合。
- en: There are multiple auto-sorting collections to choose from. The differences
    between these sorted collections are often subtle but can have an impact on the
    memory requirements and performance of your application, so it is worth putting
    effort into picking the most appropriate option for your requirements.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 可供选择的自动排序集合有多种。这些排序集合之间的差异通常很微妙，但可能会影响您应用程序的内存需求和性能，因此值得花精力选择最适合您需求的选项。
- en: Since the early days of .NET, the `OrderedDictionary` type has supported this,
    but it was non-generic, with keys and values typed as `System.Object`. .NET 9
    introduces the long-awaited `OrderedDictionary<TKey, TValue>` collection, offering
    an efficient and generic solution for these scenarios.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 自从.NET的早期版本以来，`OrderedDictionary`类型就支持这一点，但它不是泛型的，键和值的数据类型为`System.Object`。.NET
    9引入了备受期待的`OrderedDictionary<TKey, TValue>`集合，为这些场景提供了一个高效且泛型的解决方案。
- en: 'Some other common auto-sorting collections are shown in *Table 8.15*:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他常见的自动排序集合如表8.15所示：
- en: '| **Collection** | **Description** |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| **集合** | **描述** |'
- en: '| `SortedDictionary<TKey, TValue>` | This represents a collection of key-value
    pairs that are sorted by key. Internally, it maintains a binary tree for items.
    |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
- en: '| `SortedList<TKey, TValue>` | This represents a collection of key-value pairs
    that are sorted by key. The name is misleading because this is not a list. Compared
    to `SortedDictionary<TKey, TValue>`, retrieval performance is similar, it uses
    less memory, and insert and remove operations are slower for unsorted data. If
    it is populated from sorted data, then it is faster. Internally, it maintains
    a sorted array with a binary search to find elements. |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
- en: '| `SortedSet<T>` | This represents a collection of unique objects that are
    maintained in a sorted order. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
- en: 'Table 8.15: Common auto-sorting collections'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Specialized collections
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few other collections for special situations.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Collections.BitArray` collection manages a compact array of bit
    values, which are represented as Booleans, where `true` indicates that the bit
    is on (value is 1) and `false` indicates that the bit is off (value is 0).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Collections.Generics.LinkedList<T>` collection represents a doubly
    linked list where every item has a reference to its previous and next items. They
    provide better performance compared to `List<T>` for scenarios where you will
    frequently insert and remove items from the middle of the list. In a `LinkedList<T>`,
    the items do not have to be rearranged in memory.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Read-only, immutable, and frozen collections
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we looked at the generic collection interface, we saw that it has a property
    named `IsReadOnly`. This is useful when we want to pass a collection to a method
    but not allow it to make changes.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might define a method as shown in the following code:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Generic collections, like `List<T>` and `Dictionary<TKey, TValue>`, have an
    `AsReadOnly` method to create a `ReadOnlyCollection<T>` that references the original
    collection. Although the `ReadOnlyCollection<T>` has to have an `Add` and a `Remove`
    method because it implements `ICollection<T>`, it throws a `NotImplementedException`
    to prevent changes.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: If the original collection has items added or removed, the `ReadOnlyCollection<T>`
    will see those changes. You can think of a `ReadOnlyCollection<T>` as a protected
    view of a collection.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can make sure a collection is read-only:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithCollections` project, in `Program.Helpers.cs`, add a method
    that should only be given a read-only dictionary with `string` for the type of
    key and value, but the naughty method tries to call `Add`, as shown in the following
    code:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note the type of parameter is `IDictionary<TKey, TValue>`. Using an interface
    provides more flexibility because we can pass either a `Dictionary<TKey, TValue>`,
    a `ReadOnlyDictionary<TKey, TValue>`, or anything else that implements that interface.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to pass the `keywords` dictionary to this naughty
    method, as shown in the following code:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run the code, view the result, and note that the naughty method was able to
    add a new key-value pair, so the count has incremented, as shown in the following
    output:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意这次，淘气的方法能够添加一个新的键值对，所以计数增加了，如下所示输出：
- en: '[PRE84]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In `Program.cs`, comment out the `UseDictionary` statement, and then add a
    statement to pass the dictionary converted into a read-only collection, as shown
    in the following code:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉 `UseDictionary` 语句，然后添加一个语句将转换后的字典传递给只读集合，如下所示代码：
- en: '[PRE85]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Run the code, view the result, and note that this time, the method was not
    able to add an item, so the count is the same, as shown in the following output:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意这次，方法无法添加项目，所以计数没有变化，如下所示输出：
- en: '[PRE86]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'At the top of `Program.cs`, import the `System.Collections.Immutable` namespace,
    as shown in the following code:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的顶部，导入 `System.Collections.Immutable` 命名空间，如下所示代码：
- en: '[PRE87]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In `Program.cs`, comment out the `AsReadOnly` statement and then add a statement
    to pass the keywords converted into an immutable dictionary, as shown highlighted
    in the following code:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉 `AsReadOnly` 语句，然后添加一个语句将转换后的关键字转换为不可变字典，如下所示代码高亮显示：
- en: '[PRE88]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Run the code, view the result, and note that this time, the method was also
    not able to add a default value, so the count is the same – it is the same behavior
    as using a read-only collection, so what’s the point of immutable collections?
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意这次，方法也无法添加默认值，所以计数没有变化——这与使用只读集合的行为相同，那么不可变集合有什么用呢？
- en: If you import the `System.Collections.Immutable` namespace, then any collection
    that implements `IEnumerable<T>` is given six extension methods to convert it
    into an immutable collection, like a list, dictionary, set, and so on.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入 `System.Collections.Immutable` 命名空间，那么任何实现 `IEnumerable<T>` 的集合都将获得六个扩展方法来将其转换为不可变集合，如列表、字典、集合等。
- en: Although the immutable collection will have a method named `Add`, it does not
    add an item to the original immutable collection! Instead, it returns a new immutable
    collection with the new item in it. The original immutable collection still only
    has the original items in it.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不可变集合将有一个名为 `Add` 的方法，但它不会将项目添加到原始不可变集合中！相反，它返回一个新的包含新项目的不可变集合。原始不可变集合仍然只包含原始项目。
- en: 'Let’s see an example:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: 'In `Program.cs`, add statements to convert the keywords dictionary into an
    immutable dictionary, and then add a new keyword definition to it by randomly
    generating GUID values, as shown in the following code:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句将关键字字典转换为不可变字典，然后通过随机生成GUID值向其中添加新的关键字定义，如下所示代码：
- en: '[PRE89]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the code, view the result, and note that the immutable keywords dictionary
    does not get modified when you call the `Add` method on it; instead, it returns
    a new dictionary with all the existing keywords plus the newly added keyword,
    as shown in the following output:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意不可变关键字字典在调用其上的 `Add` 方法时不会被修改；相反，它返回一个新的字典，包含所有现有关键字加上新添加的关键字，如下所示输出：
- en: '[PRE90]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Newly added items will not always appear at the top of the dictionary, as shown
    in the output above. Internally, the order is defined by the hash of the key.
    This is why dictionaries are sometimes called hash tables.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的项目并不总是出现在字典的顶部，如上输出所示。内部，顺序是由键的哈希值定义的。这就是为什么字典有时被称为哈希表。
- en: '**Good practice**: To improve performance, many applications store a shared
    copy of commonly accessed objects in a central cache. To safely allow multiple
    threads to work with those objects knowing they won’t change, you should make
    them immutable or use a concurrent collection type, which you can read about at
    the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent).'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为了提高性能，许多应用程序在中央缓存中存储常用对象的共享副本。为了安全地允许多个线程使用这些对象，并知道它们不会改变，你应该使它们不可变或使用并发集合类型，你可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent)。'
- en: The generic collections have some potential performance issues related to how
    they are designed.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型集合在设计上存在一些潜在的性能问题。
- en: First, being generic, the types of items or types used for keys and values for
    a dictionary have a big effect on performance, depending on what they are. Since
    they could be any type, the .NET team cannot optimize the algorithm. `string`
    and `int` types are the most used in real life. If the .NET team could rely on
    those always being the types used, then they could greatly improve performance.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于是泛型的，字典中项的类型或用于键和值的类型对性能有很大影响，具体取决于它们是什么。由于它们可以是任何类型，.NET 团队无法优化算法。在现实生活中，`string`
    和 `int` 类型是最常用的。如果 .NET 团队能够依赖这些类型始终被使用，那么他们可以大大提高性能。
- en: Second, collections are dynamic, meaning that new items can be added, and existing
    items can be removed at any time. Even more optimizations could be made if the
    .NET team knew that no more changes would be made to the collection.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，集合是动态的，这意味着可以在任何时候添加新项，也可以删除现有项。如果 .NET 团队知道集合将不再进行更改，那么可以进行更多的优化。
- en: '.NET 8 introduced a new concept: frozen collections. Hmmm, we already have
    immutable collections, so what is different about frozen collections? Are they
    delicious like ice cream? The idea is that 95% of the time, a collection is populated
    and then never changed. So, if we could optimize them at the time of creation,
    then those optimizations could be made, adding some time and effort upfront, but
    then after that, performance for reading the collection could be greatly improved.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 引入了一个新概念：冻结集合。嗯，我们已经有不可变集合了，那么冻结集合有什么不同呢？它们像冰淇淋一样美味吗？想法是，95% 的时间，集合被填充后就不会再改变。所以，如果我们能在创建时优化它们，那么这些优化就可以实现，这需要一些前期的时间和精力，但之后，读取集合的性能可以得到显著提高。
- en: 'In .NET 8, there are only two frozen collections: `FrozenDictionary<TKey, TValue>`
    and `FrozenSet<T>`. More may come in future versions of .NET, but these are the
    two most common scenarios that would benefit from the frozen concept.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 中，只有两种冻结集合：`FrozenDictionary<TKey, TValue>` 和 `FrozenSet<T>`。未来版本的
    .NET 可能会有更多，但这些都是最常见且能从冻结概念中受益的场景。
- en: 'Let’s go:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'At the top of `Program.cs`, import the `System.Collections.Frozen` namespace,
    as shown in the following code:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的顶部，导入 `System.Collections.Frozen` 命名空间，如下所示：
- en: '[PRE91]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'At the bottom of `Program.cs`, add statements to convert the keywords dictionary
    into a frozen dictionary, output its items, and then look up the definition of
    `long`, as shown in the following code:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的底部，添加语句将关键字字典转换为冻结字典，输出其项，然后查找 `long` 的定义，如下所示：
- en: '[PRE92]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE93]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'What the `Add` method does depends on the type, as summarized in the following
    list:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add` 方法的行为取决于类型，以下列表进行了总结：'
- en: '`List<T>`: This adds a new item to the end of the existing list.'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>`: 这会在现有列表的末尾添加一个新项。'
- en: '`Dictionary<TKey, TValue>`: This adds a new item to the existing dictionary
    in a position determined by its internal structure.'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>`: 这会在由其内部结构确定的位位置向现有字典中添加一个新项。'
- en: '`ReadOnlyCollection<T>`: This throws a not-supported exception.'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOnlyCollection<T>`: 这会抛出一个不支持异常。'
- en: '`ImmutableList<T>`: This returns a new list with the new item in it. This does
    not affect the original list.'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImmutableList<T>`: 这会返回一个新的列表，其中包含新项。这不会影响原始列表。'
- en: '`ImmutableDictionary<TKey, TValue>`: This returns a new dictionary with the
    new item in it. This does not affect the original dictionary.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImmutableDictionary<TKey, TValue>`: 这会返回一个新的字典，其中包含新项。这不会影响原始字典。'
- en: '`FrozenDictionary<TKey, TValue>`: This does not exist.'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrozenDictionary<TKey, TValue>`: 这不存在。'
- en: '**More information**: The documentation for frozen collections is found at
    the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen](https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen).'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：有关冻结集合的文档可以在以下链接找到：[https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen](https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen).'
- en: You’ve seen that you can create read-only lists and dictionaries, but what about
    sets? In .NET 9, there is now a `ReadOnlySet<T>` to address this.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到你可以创建只读列表和字典，但集合呢？在 .NET 9 中，现在有一个 `ReadOnlySet<T>` 来解决这个问题。
- en: Initializing collections using collection expressions
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合表达式初始化集合
- en: Introduced with C# 12 is a new consistent syntax for initializing arrays, collections,
    and span variables.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: C# 12 引入了一种新的初始化数组、集合和 span 变量的统一语法。
- en: 'With C# 11 and earlier, you would have to declare and initialize an array,
    collection, or span of `int` values using the following code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 11及之前版本中，您必须使用以下代码声明并初始化一个`int`值的数组、集合或跨度：
- en: '[PRE94]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Starting with C# 12, you can now consistently use square brackets, and the
    compiler will do the right thing, as shown in the following code:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 12开始，您现在可以一致地使用方括号，编译器将执行正确的事，如下面的代码所示：
- en: '[PRE95]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '**More information**: You can learn more about collection expressions at the
    following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions).'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于集合表达式的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions)。'
- en: 'Collection expressions do not work with all collections. For example, they
    do not work with dictionaries or multidimensional arrays. The documentation lists
    the types that a collection expression can be converted to: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#conversions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#conversions).'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表达式不适用于所有集合。例如，它们不适用于字典或多维数组。文档列出了集合表达式可以转换的类型：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#conversions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#conversions)。
- en: Using the spread element
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用展开元素
- en: The **spread element** `..` can be prefixed before any expression that can be
    enumerated to evaluate it in a collection expression. For example, any type that
    can be enumerated using `foreach`, like an array or collection, can be evaluated
    using the spread element.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 展开元素`..`可以加在任何可枚举的表达式之前，以便在集合表达式中对其进行评估。例如，任何可以使用`foreach`枚举的类型，如数组或集合，都可以使用展开元素进行评估。
- en: The use of the spread element `..` in a collection expression replaces its argument
    with the elements from that collection. You can combine spread elements with individual
    elements in a collection expression.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合表达式中使用展开元素`..`将它的参数替换为该集合中的元素。您可以将展开元素与集合表达式中的单个元素组合使用。
- en: Microsoft official documentation uses both the **spread element** and **spread
    operator** to refer to the same language feature. I prefer the element because
    it is used in collection expressions to represent an element within the defined
    collection.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 微软官方文档同时使用**展开元素**和**展开运算符**来指代同一语言特性。我更喜欢元素，因为它在集合表达式中用于表示定义的集合内的元素。
- en: 'Let’s see an example of using the spread element, as shown in the following
    code:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码示例看看如何使用展开元素：
- en: '[PRE96]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The output would be:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE97]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**More information**: You can learn more about the spread element at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions#spread-element](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions#spread-element).'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于展开元素的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions#spread-element](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions#spread-element)。'
- en: '**Warning!** Be careful not to confuse the spread element `..` that must be
    applied before an enumerable expression, with the range operator `..` that is
    used to define a `Range`. You will learn about ranges in the next major section
    in this chapter, *Working with spans, indexes, and ranges*. There is a discussion
    about the design decision around the spread element at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#drawbacks](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#drawbacks).'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**请注意不要混淆必须应用于可枚举表达式之前的展开元素`..`与用于定义`Range`的范围运算符`..`。您将在本章下一节中学习关于范围的内容，*处理跨度、索引和范围*。关于展开元素的设计决策的讨论可以在以下链接中找到：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#drawbacks](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#drawbacks)。'
- en: Good practice with collections
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的良好实践
- en: Let’s end this section about collections by reviewing some good practices that
    you should follow when working with collections.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回顾一些你应该遵循的良好实践来结束关于集合的这一部分。
- en: Presizing collections
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预先调整集合大小
- en: Since .NET 1.1, types like `StringBuilder` have had a method named `EnsureCapacity`
    that can presize its internal storage array to the expected final size of the
    `string`. This improves performance because it does not have to repeatedly increment
    the size of the array as more characters are appended.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 自从.NET 1.1以来，像`StringBuilder`这样的类型就有一个名为`EnsureCapacity`的方法，可以将内部存储数组预先调整为`string`预期最终大小的数组。这提高了性能，因为它不需要在追加更多字符时反复增加数组的大小。
- en: Since .NET Core 2.1, types like `Dictionary<T>` and `HashSet<T>` have also had
    `EnsureCapacity`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 自从.NET Core 2.1以来，像`Dictionary<T>`和`HashSet<T>`这样的类型也拥有了`EnsureCapacity`。
- en: 'In .NET 6 and later, collections like `List<T>`, `Queue<T>`, and `Stack<T>`
    now have an `EnsureCapacity` method too, as shown in the following code:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6及以后的版本中，像`List<T>`、`Queue<T>`和`Stack<T>`这样的集合现在也有一个`EnsureCapacity`方法，如下面的代码所示：
- en: '[PRE98]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Passing collections to methods
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将集合传递给方法
- en: 'Let’s say you need to create a method to process a collection. For maximum
    flexibility, you could declare the input parameter to be `IEnumerable<T>` and
    make the method generic, as shown in the following code:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要创建一个处理集合的方法。为了最大灵活性，你可以声明输入参数为`IEnumerable<T>`并使方法泛型，如下面的代码所示：
- en: '[PRE99]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: I could pass an array, a list, a queue, or a stack, containing any type, like
    `int`, `string`, `Person`, or anything else that implements `IEnumerable<T>`,
    into this method and it will process the items. However, the flexibility to pass
    any collection to this method comes at a performance cost.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将包含任何类型（如`int`、`string`、`Person`或任何实现了`IEnumerable<T>`的其他类型）的数组、列表、队列或堆栈传递到这个方法中，并且它将处理这些项。然而，将任何集合传递到这个方法的灵活性是以性能成本为代价的。
- en: 'One of the performance problems with `IEnumerable<T>` is also one of its benefits:
    deferred execution, also known as lazy loading. Types that implement this interface
    do not have to implement deferred execution, but many do.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`的性能问题之一也是它的一个优点：延迟执行，也称为懒加载。实现此接口的类型不必实现延迟执行，但许多类型确实实现了。'
- en: 'But the worst performance problem with `IEnumerable<T>` is that the iteration
    must allocate an object on the heap. To avoid this memory allocation, you should
    define your method using a concrete type, as shown highlighted in the following
    code:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 但`IEnumerable<T>`最糟糕的性能问题是迭代必须在堆上分配一个对象。为了避免这种内存分配，你应该使用具体类型定义你的方法，如下面高亮显示的代码所示：
- en: '[PRE100]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This will use the `List<T>.Enumerator GetEnumerator()` method, which returns
    a `struct`, instead of the `IEnumerator<T> GetEnumerator()` method, which returns
    a reference type. Your code will be two to three times faster and require less
    memory. As with all recommendations related to performance, you should confirm
    the benefit by running performance tests on your actual code in a product environment.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`List<T>.Enumerator GetEnumerator()`方法，它返回一个`struct`，而不是返回引用类型的`IEnumerator<T>
    GetEnumerator()`方法。你的代码将快两到三倍，并且需要的内存更少。与所有与性能相关的建议一样，你应该通过在实际的产品环境中运行性能测试来确认这种好处。
- en: Returning collections from members
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从成员返回集合
- en: 'Collections are reference types, which means they can be `null`. You might
    define methods or properties that return `null`, as shown in the following code:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是引用类型，这意味着它们可以是`null`。你可能会定义返回`null`的方法或属性，如下面的代码所示：
- en: '[PRE101]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This can cause issues if a developer calls your methods and properties that
    return a collection without checking for `null`, as shown in the following code:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者调用返回集合的方法和属性而没有检查`null`，这可能会导致问题，如下面的代码所示：
- en: '[PRE102]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In your implementations of methods and properties that return collections,
    return an empty collection or array instead of `null`, as shown in the following
    code:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现返回集合的方法和属性时，返回一个空集合或数组，而不是`null`，如下面的代码所示：
- en: '[PRE103]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Working with spans, indexes, and ranges
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与span、索引和范围一起工作
- en: One of Microsoft’s goals with .NET Core 2.1 was to improve performance and resource
    usage. A key .NET feature that enables this is the `Span<T>` type.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在.NET Core 2.1中的一个目标是通过`Span<T>`类型来提高性能和资源使用。
- en: Using memory efficiently using spans
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用span有效地使用内存
- en: When manipulating arrays, you will often create new copies or subsets of existing
    ones so that you can process just the subset. This is not efficient because duplicate
    objects must be created in memory.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作数组时，你通常会创建现有数组的新的副本或子集，以便只处理子集。这并不高效，因为必须在内存中创建重复的对象。
- en: If you need to work with a subset of an array, use a **span** because it is
    like a window into the original array. This is more efficient in terms of memory
    usage and improves performance. Spans only work with arrays, not collections,
    because the memory must be contiguous.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理数组的子集，请使用 **span**，因为它就像原始数组的一个窗口。这在内存使用方面更加高效，并提高了性能。范围仅适用于数组，不适用于集合，因为内存必须是连续的。
- en: 'Before we look at spans in more detail, we need to understand some related
    objects: indexes and ranges.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地查看范围之前，我们需要了解一些相关对象：索引和范围。
- en: Identifying positions with the Index type
  id: totrans-592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引类型识别位置
- en: C# 8 introduced two features for identifying an item’s index position within
    an array and a range of items using two indexes.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 引入了两个特性，用于使用两个索引来识别数组中项的索引位置和项的范围。
- en: 'You learned in the previous section that objects in a list can be accessed
    by passing an integer into their indexer, as shown in the following code:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一个章节中了解到，列表中的对象可以通过传递一个整数到它们的索引器来访问，如下面的代码所示：
- en: '[PRE104]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `Index` value type is a more formal way of identifying a position, and
    supports counting from the end, as shown in the following code:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index` 值类型是识别位置的一种更正式的方式，它支持从末尾开始计数，如下面的代码所示：'
- en: '[PRE105]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Identifying ranges with the Range type
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用范围类型识别范围
- en: 'The `Range` value type uses `Index` values to indicate the start and end of
    its range, using its constructor, C# syntax, or its static methods, as shown in
    the following code:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range` 值类型使用 `Index` 值来指示其范围的起始和结束，使用其构造函数、C# 语法或其静态方法，如下面的代码所示：'
- en: '[PRE106]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Extension methods have been added to `string` values (which internally use an
    array of `char`), `int` arrays, and spans to make ranges easier to work with.
    These extension methods accept a range as a parameter and return a `Span<T>`.
    This makes them very memory-efficient.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为 `string` 值（内部使用 `char` 数组）、`int` 数组和范围添加了扩展方法，以便更容易地处理范围。这些扩展方法接受一个范围作为参数，并返回一个
    `Span<T>`。这使得它们非常节省内存。
- en: '**Warning!** The range operator `..` (introduced with C# 8) and the spread
    element `..` (introduced with C# 12) look identical. Be careful to differentiate
    them when reading code. The range operator should always appear next to an integer,
    either before, after, or both. The spread element should always appear before
    a named variable that is enumerable.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 范围运算符 `..`（随 C# 8 引入）和扩展元素 `..`（随 C# 12 引入）看起来相同。在阅读代码时要小心区分它们。范围运算符应始终出现在整数旁边，无论是之前、之后还是两者都有。扩展元素应始终出现在可枚举的命名变量之前。'
- en: Using indexes, ranges, and spans
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引、范围和范围
- en: 'Let’s explore using indexes and ranges to return spans:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用索引和范围来返回范围：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithRanges` to the `Chapter08` solution.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器，向 `Chapter08` 解决方案中添加一个名为 `WorkingWithRanges` 的新 **Console App**
    / `console` 项目。
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    compare using the `string` type’s `Substring` method with ranges to extract parts
    of someone’s name, as shown in the following code:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后添加语句使用 `string` 类型的 `Substring` 方法与范围来提取某人姓名的部分，如下面的代码所示：
- en: '[PRE107]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE108]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Using spans for efficient text handling
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用范围进行高效的文本处理
- en: One of the common problems with working with text is that copies of `string`
    values are often allocated in memory during processing. It would be more efficient
    to reuse the original values when possible.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文本时，常见的一个问题是 `string` 值的副本在处理过程中经常在内存中分配。如果可能的话，重用原始值将更加高效。
- en: Spans enable this by creating data structures that point to the original parts
    of a string.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 范围通过创建指向字符串原始部分的指针数据结构来实现这一点。
- en: 'For example, consider a `string` value containing integers separated by addition
    symbols that need to be summed up:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个包含整数并用加号分隔的 `string` 值，需要将其求和：
- en: 'With .NET 9 and later, we can now create a span over the `string` value, and
    then use ranges to efficiently divide the integer values and pass them to the
    `int.Parse` method, as shown in the following code:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 9及更高版本中，我们现在可以创建一个跨越`string`值的跨度，然后使用范围来有效地分割整数值并将它们传递给`int.Parse`方法，如下所示代码：
- en: '[PRE109]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If you set a breakpoint in the loop, then note the range object named `r` is
    first `[0..2]`, as shown in *Figure 8.6*, then `{3..5}`, and finally `{6..9}`:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在循环中设置断点，那么请注意名为`r`的范围对象首先为`[0..2]`，如图*8.6*所示，然后为`{3..5}`，最后为`{6..9}`：
- en: '![](img/B22322_08_06.png)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_08_06.png)'
- en: 'Figure 8.6: A span and range used to split a string efficiently'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：用于高效分割字符串的跨度范围
- en: The range values efficiently define windows into the original string without
    allocating new memory resources.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 范围值有效地定义了进入原始字符串的窗口，而不分配新的内存资源。
- en: Practicing and exploring
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring, with deeper research into the topics in this
    chapter.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些动手实践和探索，以及更深入地研究本章的主题来测试你的知识和理解。
- en: Exercise 8.1 – online material
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.1 – 在线材料
- en: Online material could be created by Microsoft or third parties, or extra content
    for this book.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可能由Microsoft或第三方创建，或为本书的额外内容。
- en: Working with network resources
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与网络资源一起工作
- en: 'If you are interested in some low-level types for working with network resources,
    then you can read an online-only section found at the following link:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于一些用于处理网络资源的低级类型，那么你可以阅读以下链接中找到的在线仅有的部分：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch08-network-resources.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch08-network-resources.md)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch08-network-resources.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch08-network-resources.md)'
- en: 'There is a useful online book about networking with .NET by Chris Woodruff
    called *Beyond Boundaries – Networking Programming with C# 12 and .NET 8*, which
    you can find at the following link: [https://csharp-networking.com](https://csharp-networking.com).'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有用的在线书籍，由Chris Woodruff编写，名为*超越边界 – 使用C# 12和.NET 8进行网络编程*，你可以通过以下链接找到：[https://csharp-networking.com](https://csharp-networking.com)。
- en: Collection expressions
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合表达式
- en: 'You can learn more about how to refactor existing code to make the most of
    collection expressions at the following link:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于如何重构现有代码以充分利用集合表达式的信息：
- en: '[https://devblogs.microsoft.com/dotnet/refactor-your-code-with-collection-expressions/](https://devblogs.microsoft.com/dotnet/refactor-your-code-with-collection-expressions/)'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/refactor-your-code-with-collection-expressions/](https://devblogs.microsoft.com/dotnet/refactor-your-code-with-collection-expressions/)'
- en: Exercise 8.2 – practice exercises
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.2 – 练习题
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题深入探讨了本章的主题。
- en: Regular expressions
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'In the `Chapter08` solution, create a console app named `Exercise_RegularExpressions`
    that prompts the user to enter a regular expression and then prompts the user
    to enter some input, and compare the two for a match until the user presses *Esc*,
    as shown in the following output:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在`第08章`解决方案中，创建一个名为`Exercise_RegularExpressions`的控制台应用程序，提示用户输入一个正则表达式，然后提示用户输入一些输入，并比较这两个以匹配，直到用户按下*Esc*，如下所示输出：
- en: '[PRE110]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Extension methods
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展方法
- en: In the `Chapter08` solution, create a class library named `Exercise_NumbersAsWordsLib`
    and projects to test it. It should define extension methods that extend number
    types such as `BigInteger` and `int` with a method named `ToWords` that returns
    a `string` describing the number.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在`第08章`解决方案中，创建一个名为`Exercise_NumbersAsWordsLib`的类库和测试它的项目。它应该定义扩展方法，这些方法通过名为`ToWords`的方法扩展数字类型，如`BigInteger`和`int`，该方法返回一个描述数字的`string`。
- en: For example, `18,000,000` would be eighteen million, and `18,456,002,032,011,000,007`
    would be eighteen quintillion, four hundred and fifty-six quadrillion, two trillion,
    thirty-two billion, eleven million, and seven.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`18,000,000`将是十八百万，而`18,456,002,032,011,000,007`将是十八千兆，四百五十六千兆，两万亿，三十二亿，一千一百万和七。
- en: 'You can read more about names for large numbers at the following link: [https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers).'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于大数命名的内容：[https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers)。
- en: Create projects to test your class library using xUnit and as an interactive
    console app.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目以使用xUnit测试你的类库，并将其作为一个交互式控制台应用程序。
- en: Exercise 8.3 – test your knowledge
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.3 – 测试你的知识
- en: 'Use the web to answer the following questions:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络回答以下问题：
- en: What is the maximum number of characters that can be stored in a `string` variable?
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在 `string` 变量中存储的最大字符数是多少？
- en: When and why should you use a `SecureString` type?
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下以及为什么你应该使用 `SecureString` 类型？
- en: When is it appropriate to use a `StringBuilder` class?
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下使用 `StringBuilder` 类是合适的？
- en: When should you use a `LinkedList<T>` class?
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么情况下使用 `LinkedList<T>` 类？
- en: When should you use a `SortedDictionary<T>` class rather than a `SortedList<T>`
    class?
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么情况下使用 `SortedDictionary<T>` 类而不是 `SortedList<T>` 类？
- en: In a regular expression, what does `$` mean?
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正则表达式中，`$` 代表什么？
- en: In a regular expression, how can you represent digits?
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正则表达式中，如何表示数字？
- en: Why should you *not* use the official standard for email addresses to create
    a regular expression to validate a user’s email address?
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你不应该使用官方电子邮件地址标准来创建一个用于验证用户电子邮件地址的正则表达式？
- en: What characters are output when the following code runs?
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当以下代码运行时，会输出哪些字符？
- en: '[PRE111]'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How could you check that a web service is available before calling it?
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在调用它之前检查一个网络服务是否可用？
- en: Exercise 8.4 – explore topics
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.4 – 探索主题
- en: 'Use the following link to learn more details about the topics covered in this
    chapter:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-8---working-with-common-net-types)'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-8---working-with-common-net-types)'
- en: Summary
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you explored:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您探索了：
- en: Choices for types to store and manipulate numbers.
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和操作数字的类型选择。
- en: Handling text, including using regular expressions for validating input.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文本，包括使用正则表达式验证输入。
- en: Collections to use for storing multiple items.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储多个项目的集合。
- en: Working with indexes, ranges, and spans.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与索引、范围和跨度一起工作。
- en: In the next chapter, we will manage files and streams, encode and decode text,
    and perform serialization.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将管理文件和流，编码和解码文本，以及执行序列化。
- en: Learn more on Discord
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新发布——请扫描下面的二维码：
- en: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
- en: '![](img/QR_Code281224304227278796.png)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code281224304227278796.png)'
- en: Leave a Review!
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您从 Packt Publishing 购买本书——我们希望您喜欢它！您的反馈对我们来说是无价的，它帮助我们改进和成长。一旦您阅读完毕，请花点时间留下亚马逊评论；这只需一分钟，但对像您这样的读者来说意义重大。
- en: Scan the QR or visit the link to receive a free ebook of your choice.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接，以获得您选择的免费电子书。
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
- en: '![A qr code with black squares  Description automatically generated](img/review1.png)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有黑色方块的二维码，描述自动生成](img/review1.png)'
