- en: Chapter 12. Writing Secure Code and Debugging in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will have a look at some examples of being more efficient
    as a developer when it comes to debugging your code. We will also be looking at
    how to write secure code. Writing secure code can be a challenge, but consider
    the following: if part of your code security involves making sure that passwords
    are securely stored, why write that code over and over between projects? Write
    the code once and implement it in every new project you create. The concepts we
    will be looking at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and storing passwords correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `SecureString` in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing sensitive parts of `App.config`/`web.config`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing SQL injection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Diagnostic Tools** and **Historical Debugging**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting conditional breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **PerfTips** to identify bottlenecks in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that many developers tend to miss is the need to write secure code.
    Development deadlines and other project-related pressures cause developers to
    put delivering code above doing it the right way. Many of you might not agree
    with me, but believe me when I say that I have heard the excuse of "We do not
    have budget for this" once too many times. This is usually when the development
    budget has been determined by other stakeholders and the developer not consulted.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a situation where a consultant tells the developer that they have sold
    a system to a customer. That system now needs to be developed. Furthermore, the
    developer is told that they have *x* amount of hours to complete the development.
    A document outlining the requirements is given to the developer and the developer
    is given the go-ahead to begin, and to complete development in the required time.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario is the reality many developers face. You might think that this
    scenario can't possibly exist, or perhaps you are reading this and relate to the
    scenario as being how the process currently works in your company. Whatever the
    case may be, this is something that happens today in software development.
  prefs: []
  type: TYPE_NORMAL
- en: So how do developers combat project suicide? (I call these projects this because
    projects approached like this rarely succeed.) Start by creating reusable code.
    Think of processes you repeat often enough to warrant writing a reusable DLL for.
    Did you know that you can create Visual Studio templates? If you have a standard
    project structure you use, create a template from it and re-use it for each new
    project, thereby speeding up delivery and cutting down on bugs.
  prefs: []
  type: TYPE_NORMAL
- en: A few considerations for project templates are database layers, security layers,
    common validation code (does this data table contain any data), common extension
    methods, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and storing passwords correctly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing I have often seen is badly stored passwords. Just because the password
    is stored in a database on your server, does not make it secure. So what do badly
    stored passwords look like?
  prefs: []
  type: TYPE_NORMAL
- en: '![Encrypting and storing passwords correctly](img/B05391_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Secure passwords stored badly are no longer secure. The passwords in the previous
    screenshot are the actual user passwords. Entering the first password, `^tj_Y4$g1!8LkD`
    at the login screen will give the user access to the system. Passwords should
    be stored securely in the database. In fact, you need to employ salted password
    hashing. You should be able to encrypt the user's password, but never decrypt
    it.
  prefs: []
  type: TYPE_NORMAL
- en: So how do you decrypt the password to match it to the password the user enters
    at the login screen? Well, you don't. You always hash the password the user enters
    at the login screen. If it matches the hash of their real password stored in the
    database, you give them access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQL tables in this recipe are for illustration only and are not written
    to by the code in the recipe. The database can be found in the `_database scripts`
    folder that accompanies the source code for this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class library by right-clicking on your solution, and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_12_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter12`:![How to do it…](img/B05391_12_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which we renamed `Recipes.cs` in order to distinguish the code properly.
    You can, however, rename your class whatever you like if that makes more sense
    to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To rename your class, simply click on the class name in the **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_12_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to confirm a rename of all references to the code
    element **Class1** in the project. Just click **Yes**:![How to do it…](img/B05391_12_49.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following class is added to your `Chapter12` library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `using` statement to your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need to add two properties to the class. These properties will store
    the salt and the hash. Usually you will write these values to the database along
    with the username, but for the purposes of this recipe we will simply add them
    to the static properties. Also add two methods to the class called `RegisterUser()`
    and `ValidateLogin()`. Both methods take as parameters the `username` and `password`
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Starting with the `RegisterUser()` method, here we do a number of things. To
    list the steps in the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We generate a truly random, cryptographically strong salt value using `RNGCryptoServiceProvider`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the salt to the password and hash the salted password using `SHA256`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It doesn't matter if you add the salt before or after the password. Just remember
    to be consistent each time you do it.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Store the salt value and the hash value along with the username in the database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to cut down on code, I have not actually added code to write the hash
    and salt values to the database. I simply added them to the properties created
    earlier. In a real-world situation, you would always write these to the database.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is a very secure way to handle user passwords in your application:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The next method we need to create is the `ValidateLogin()` method. Here we
    take the username and validate that first. If the user entered the username incorrectly,
    do not tell them so. This would alert someone trying to compromise the system
    that they have the wrong username and that as soon as they get a wrong password
    notification, they know that the username is correct. The steps in this method
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the salt and hash values for the entered username from the database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Salt the password the user entered at the login screen with the salt read from
    the database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash the salted password using the same hashing algorithm as when the user registered.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the hash value read from the database to the hash value generated in
    the method. If the two hashes match, then the password is correctly entered and
    the user validated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we never decrypt the password from the database. If you have code
    decrypting user passwords and matching that to the password entered, you need
    to reconsider and rewrite your password logic. A system should never be able to
    decrypt user passwords.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: To test the code, add a reference to the `Chapter12` class in your `CodeSamples`
    project:![How to do it…](img/B05391_12_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because we created a static class, you can add the new `using static` to your
    `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the code by calling the `RegisterUser()` method and pass it the `username`
    and `password` variable. After that, call the `ValidateLogin()` method and see
    whether the password matches the hash. This would obviously not happen at the
    same time in a real production system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you debug the code, you will see the user has been validated:![How to do
    it…](img/B05391_12_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, modify the code slightly and set the `password` variable to something
    else. This will mimic a user entering an incorrect password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you debug the application, you will see that the user is not validated:![How
    to do it…](img/B05391_12_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nowhere in the code did we decrypt the password. In fact, the password is never
    stored anywhere. We always worked with the hash of the password. Here are the
    important points to take away from this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Never use the `Random` class in C# to generate your salt. Always use the `RNGCryptoServiceProvider`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never re-use the same salt in your code. So don't create a constant with your
    salt and use it to salt all the passwords in your system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never tell the user that the password is incorrect if the password didn't match.
    Also, never tell the user that they entered an incorrect username. This prevents
    someone trying to compromise the system from knowing that they got one of the
    two login credentials correct. If either the username or password has been entered
    incorrectly, rather notify the user that their login credentials are incorrect.
    This could mean that either the username or password (or both) have been entered
    incorrectly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't get the passwords from the hash or salt stored in the database. Therefore,
    if the database was compromised, the password data stored within it would not
    be at risk. The encryption of the user's password is a one-way operation, meaning
    that it can never be decrypted. Also important to note is that even if the source
    code was compromised and stolen by someone with malicious intent, you would not
    be able to use the code to decipher the encrypted data in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine the previous methods with a strong password policy (because even in
    2016, there are still users that think using `'l3tm31n'` for a password is good
    enough), and you have a very good password encryption routine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we look at the user access table, the correct way to store user credentials
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The salt and hash are stored alongside the username, and are secure because
    they can't be decrypted to expose the actual password.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you sign up for a service on the Internet and they send you a confirmation
    either via email or text message and display your password in this message in
    plain text, then you should seriously consider closing your account. If a system
    can read your password and send it to you in plain text, then so can anybody else.
    Never use the same password for all your logins.
  prefs: []
  type: TYPE_NORMAL
- en: Using SecureString in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Securing your application against malicious attacks is not an easy task. It
    is the constant struggle between writing secure code while minimizing bugs (which
    hackers usually exploit) and black hats writing more and more sophisticated methods
    to compromise systems and networks. I personally believe that higher learning
    institutions need to teach IT students two things:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use and integrate with a popular ERP system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper software security principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, I believe that secure programming 101 must not simply be a module or
    topic in a given IT course, but a whole course on its own. It needs to be handled
    with the seriousness and respect it deserves and needs to preferably be taught
    by someone that can actually hack a system or network.
  prefs: []
  type: TYPE_NORMAL
- en: White hats teaching students how to compromise systems, exploit vulnerable code,
    and infiltrate networks will make a big difference in changing the way future
    software developers approach programming. It comes down to developers knowing
    what not to do when programming defensively. It is quite possible that some of
    those students might go on to become black hats themselves, but they would have
    done that irrespective of whether they took a class on hacking secure programming
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code might look a little funny in some places. This is because `SecureString`
    is using unmanaged memory to store the sensitive information. Rest assured that
    `SecureString` is well supported and used within the .NET Framework, as can be
    seen from the instantiation of the `SqlCredential` object used in creating connections
    to a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B05391_12_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by adding a new Windows Forms project to your solution:![How to do it…](img/B05391_12_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the project `winformSecure` and click on the **OK** button:![How to do
    it…](img/B05391_12_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Toolbox**, search for the **TextBox** control and add it to your form:![How
    to do it…](img/B05391_12_50.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, add a button control to your form. You can resize this form however
    you like to look more like a login form:![How to do it…](img/B05391_12_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the text box control selected on the Windows Forms, open up the **Properties**
    panel and click on the Events button (it looks like a lightning bolt). In the
    **Key** group, double-click on the **KeyPress** event to create the handler in
    the code behind:![How to do it…](img/B05391_12_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code that is created for you is the **KeyPress** event handler for the
    text box control. This will fire whenever a user presses a key on the keyboard:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in the **Properties** panel, expand the **Behavior** group and change the
    value of **UseSystemPasswordChar** to `true`:![How to do it…](img/B05391_12_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the code behind, add the following `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `SecureString` variable as a global variable to your Windows Forms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then in the `KeyPress` event, append the `KeyChar` value to the `SecureString`
    variable every time the user presses a key. You might want to add code to ignore
    certain key presses, but this is beyond the scope of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then in the **Login** button''s event handler, add the following code to read
    the value from the `SecureString` object. Here we are working with unmanaged memory
    and unmanaged code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your Windows Forms application and type in a password:![How to do it…](img/B05391_12_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click on the **Login** button. You will then see the password you typed
    in displayed in the message box:![How to do it…](img/B05391_12_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It has become almost a habit for many developers to use `System.String` to store
    sensitive information such as passwords. The problem with this approach is that
    `System.String` is immutable. This means that the object created in memory by
    `System.String` can't be changed. If you modify the variable, a new object is
    created in memory. You also cannot determine when the object created by `System.String`
    will be removed from memory during garbage collection. Conversely, by using the
    `SecureString` object, you will encrypt sensitive information and when that object
    is no longer needed, it is deleted from memory. `SecureString` encrypts and decrypts
    your sensitive data in unmanaged memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now I need to be clear regarding one thing here. `SecureString` is by no means
    foolproof. If your system contains a virus with the sole purpose of compromising
    the `SecureString` operations, using it doesn't help much (be sure to use proper
    anti-virus software anyway). At some point during the code execution, the string
    representation of your password (or sensitive information) is visible. Secondly,
    if a hacker somehow found a way to inspect your heap or log your key strokes,
    the password might be visible. The use of `SecureString`, however makes this window
    of opportunity for a hacker much smaller. The window of opportunity reduces because
    there are less attack vectors (points of entry for a hacker), thereby reducing
    your attack surface (sum of all points of attack by a hacker).
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: `SecureString` is there for a reason. As a software
    developer concerned about security, you should be using `SecureString`.'
  prefs: []
  type: TYPE_NORMAL
- en: Securing sensitive parts of App.config/web.config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you will undoubtedly work with sensitive information such as
    passwords. How you handle this information during development is very important.
    In the past, I have received copies of a client's live database to use for testing.
    This does pose a very real security risk for your client.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we keep settings in a `web.config` file (when working with web applications).
    For this example, though, I will be demonstrating a console application that uses
    an `App.config` file. The same logic can be applied to a `web.config` file too.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a console application is the quickest way to demonstrate this recipe.
    If, however, you want to follow along using a web application (and securing a
    `web.config` file), you can do so.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the console application, locate the `App.config` file. This is the file that
    contains the sensitive data:![How to do it…](img/B05391_12_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you open the `App.config` file, you will see that within the `appSettings`
    tag there is a key added called `Secret`. This information should probably not
    be in the `App.config` to start off with. The problem here is that it might be
    checked into your source control. Imagine that on GitHub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To overcome this vulnerability, we need to move the sensitive data out of the
    `App.config` file into another file. To do this, we specify a path to a file that
    will contain the sensitive data we want to remove from the `App.config` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering, why not simply just encrypt the information? Well, that
    is a given really. The reason this value is in plain text is just to demonstrate
    a concept here. You would probably encrypt this value anyway in a real-world situation.
    You would not, however, want this sensitive information sitting on a server in
    a code repository somewhere, even if it is encrypted. Be safe, move it out of
    your solution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you have added the path to the secure file, remove the key containing the
    sensitive information:![How to do it…](img/B05391_12_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the path you specified in the `App.config` file property. Create
    your `secret.config` file and open it up for editing:![How to do it…](img/B05391_12_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this file, repeat the `appSettings` section and add the `Secret` key
    to it. What happens now is that when your console application runs, it reads the
    `appSettings` section in your solution and finds the reference to the secret file.
    It then looks for the secret file and merges it with the `App.config` in your
    solution:![How to do it…](img/B05391_12_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see that this merge works, add a reference to your console application:![How
    to do it…](img/B05391_12_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for and add `System.Configuration` to your references:![How to do it…](img/B05391_12_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you have added the reference, your solution references should look something
    like this:![How to do it…](img/B05391_12_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To the top of your `Program.cs` file, add the following `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to read the `Secret` key setting from your `App.config`
    file. Only this time, it will read the merged file, which is made up of your `App.config`
    and your `secret.config` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your console application and you will see that the sensitive data has been
    read from the `secret.config` file, which was merged with the `App.config` file
    at runtime:![How to do it…](img/B05391_12_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something I need to point out here is that this technique will also work for
    `web.config` files. If you need to remove sensitive information from your configuration
    file, move it to another file so that it doesn't get included in your source control
    check-in or deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing SQL injection attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL injection attacks are a very real problem. There are too many applications
    that still make themselves vulnerable to this kind of attack. If you develop a
    web application or website, you should be vigilant of bad database operations.
    Vulnerable in-line SQL exposes the database to a SQL injection attack. A SQL injection
    attack is where an attacker modifies SQL statements via a web form input box to
    produce a different result than originally intended. This is usually attempted
    on a form where the web application is supposed to access the database to authenticate
    the user login. By not sanitizing the user input, you are exposing your data to
    exploits such as this.
  prefs: []
  type: TYPE_NORMAL
- en: The accepted solution to mitigate SQL injection attacks is to create a parametrized
    stored procedure and call that from your code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create the `CookbookDB` database in your SQL Server before continuing
    this recipe. You will find the script in the `_database scripts` folder in the
    accompanying source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, I am using SQL Server 2012\. The concept is the same if you
    are using an older version of SQL Server. After you have created the `CookbookDB`
    database, you will see that there is a table called `UserDisplayData` under the
    `Tables` folder:![How to do it…](img/B05391_12_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UserDisplayData` table is simply used to illustrate the concept of querying
    using a parameterized stored procedure. It would not have any real benefit in
    a production database, because it only returns a screen name:![How to do it…](img/B05391_12_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a stored procedure to select data from this table for a specific
    ID (user ID). Click on the `Programmability` node to expand it:![How to do it…](img/B05391_12_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click on the `Stored Procedures` node and select **New Stored Procedure…**
    from the context menu:![How to do it…](img/B05391_12_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SQL Server will create the following stored procedure template for you. This
    template consists of a section where you can comment on the particular stored
    procedure, as well as a section to add parameters you might need, and obviously
    a section that you need to add the actual SQL statement to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Give the stored procedure a suitable name that will describe the action or
    intent of the stored procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many people that do prefix their stored procedures, and I'm one of
    those. I like to keep my stored procedures grouped. I therefore name my stored
    procedures in the format *[prefix]_[tablename_or_module]_[stored_procedure_action]*.
    Having said that, I generally avoid using `sp_` as a prefix to my stored procedures.
    There are a lot of opinions on the Internet as to why this is a bad idea. It is
    generally believed that using `sp_` as a stored procedure prefix impacts on performance
    because it is used as the stored procedure prefix in the master database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the purposes of this recipe, I have just kept to a simple name for the stored
    procedure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a parameter for this stored procedure. By doing this, you are telling
    the database that when this stored procedure is called, it will pass through a
    value of type integer that is stored in a parameter caller `@userID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You now define the SQL statement to be used by this stored procedure. We are
    just going to do a straightforward `SELECT` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that my `SELECT` statement contains the specific column names
    instead of a `SELECT * FROM`. Doing a `SELECT *` is considered bad practice. You
    would usually not want to return all the column values from a table. If you want
    all the column values, then it is better to explicitly list the columns by name
    instead of just getting all.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `SELECT *` returns unnecessary columns and increases the overhead on the
    server. This does make a difference in the bigger scheme of things, especially
    when the database starts getting a lot of traffic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The thought of having to type out the column names for a large table is definitely
    not something I would look forward to. You can however use the following tricks
    to make it easy for you to add the column names to your SQL `SELECT` statement.
    You can right-click on the database table and select **Script Table As** to create
    one of several SQL statements. Secondly, you can expand the `Table` node and expand
    the table you wish to write the statement for. You will then see a node called
    `Columns`. Drag the `Columns` node onto the query editor. That will insert all
    the column names into the query editor for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you have completed adding the code to your stored procedure, it will look
    like this:![How to do it…](img/B05391_12_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the stored procedure, you need to click on the **Execute** button.
    Be certain that you have the correct database selected when clicking on the **Execute**
    button:![How to do it…](img/B05391_12_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The stored procedure will then be created under the `Stored Procedures` node
    in SQL Server:![How to do it…](img/B05391_12_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now got to halfway through this task. It is time to construct the code
    that we will use in our application to query the database. We will be adding this
    code directly to the `Program.cs` file of your console application. While this
    code isn't considered best practice (hardcoding the server credentials), it serves
    merely to illustrate the concept of calling a parameterized stored procedure from
    C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start, add the following `using` statement to the top of your console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add the variables to contain the credentials we need to log on to the
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now use `SecureString` to store the password and add it to a `SqlCredential`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For more on `SecureString`, see the *Using SecureString in code* recipe of this
    chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now create a `SqlConnection` object inside a `using` statement. This ensures
    that the SQL connection is closed when the `using` statement moves out of scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `try`, add the following code to open the connection string and
    create a `SqlCommand` object that takes the open connection and name of the stored
    procedure as parameters. You can use the shortcut method of creating the actual
    SQL parameter to pass to the stored procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because I''m just passing a parameter of type integer to the stored procedure,
    I''m not defining a length for this parameter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05391_12_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'If, however, you ever need to define a parameter of type `VarChar(MAX)`, you
    would need to define the size of the parameter type by adding `-1`. Let''s say,
    for example you need to store a student''s essay in the database, the code would
    then look as follows for the `VarChar(MAX)`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we have added our parameter with its value to the `SqlCommand` object,
    we specify a timeout value, execute the `SqlDataReader`, and load it into a `DataTable`.
    The value is then output to the console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After you have added all the code to your console application, the correct
    completed code will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your console application and you will see the display name output to the
    screen:![How to do it…](img/B05391_12_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By creating a parameterized SQL query, the compiler correctly substitutes the
    arguments before running the SQL statement against the database. It will prevent
    malicious data changing your SQL statement in order to exact a malicious result.
    This is because the `SqlCommand` object does not directly insert the parameter
    values into the statement.
  prefs: []
  type: TYPE_NORMAL
- en: To sum it all up, using parameterized stored procedures means no more Little
    Bobby Tables.
  prefs: []
  type: TYPE_NORMAL
- en: Using Diagnostic Tools and Historical Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trusty old bug has been the bane of software developers and engineers for
    more than 140 years. Yes, you read that right. It was in fact Thomas Edison that
    coined the term "bug" in the late 1870s. It appeared in many of his notebook entries
    where he describes for example that the incandescent lightbulb still had many
    "bugs left."
  prefs: []
  type: TYPE_NORMAL
- en: His efforts to debug his inventions are quite legendary. Consider the true grit
    and determination it took for a man already in his mid-sixties to work 112-hour
    working weeks. He and his seven-person team (it is a common misconception that
    there were only six because the seventh member didn't appear in the group photograph)
    became known as the insomnia squad during a 5-week stint that resulted in very
    little sleep.
  prefs: []
  type: TYPE_NORMAL
- en: 'These days, thanks to advances in technology, software developers have a vast
    array of debugging tools (inside and outside of Visual Studio) at their disposal.
    So does debugging really matter? Of course it does. It is part of what we as software
    developers do. If we don''t debug, well, here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: In 2004, the **Electronic Data Systems** (**EDS**) Child Support System in the
    UK overpaid almost 2 million people, underpaying almost a million and resulted
    in billions of dollars in uncollected child support payments. The incompatibility
    between EDS and another system it relied on resulted in taxpayers losing money
    and negatively affecting the lives of so many single parents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial release of Apple Maps in 2012\. Enough said. While bemusing for
    many, I still find myself using Google Maps for turn-by-turn directions when in
    an unfamiliar city or area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Therac-25 radiation therapy machine used electrons to target tumors in patients.
    Unfortunately, a race condition in the software caused the machine to deliver
    lethal overdoses of radiation in several patients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of software bugs affecting the lives of millions of people can be found
    all over the Internet. We're not simply talking about the run-of-the-mill bugs
    either. Sometimes we're faced with seemingly insurmountable issues. It is the
    comfort of knowing how to use some of the tools available that makes the difference
    between a stable application and one that is totally unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of writing this, IntelliTrace is only available in Visual Studio 2015 Enterprise.
    IntelliTrace is, however, not a new feature in Visual Studio. It has evolved over
    time, since Visual Studio 2010, into what we have available today.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First off, go to **Tools** | **Options**:![How to do it…](img/B05391_12_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **IntelliTrace** node and click on **General**. Ensure that **Enable
    IntalliTrace** is checked. Also, make sure that the **IntelliTrace events and
    call information** option is selected. Click on **OK**:![How to do it…](img/B05391_12_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Recipes.cs` file, you might need to add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method called `ErrorInception()` to the `Recipes` class. Also, add the
    code to read the base path and assume that there is a folder called `log`. Do
    not create this folder on your hard drive. We want an exception to be thrown.
    Lastly, add another method called `LogException()` that does nothing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to your `ErrorInception()` method after the full path
    has been determined. Here we are trying to open the log file. This is where the
    exception will occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have added all your code, your code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Program.cs` file, call the `ErrorInception()` method. Right after that,
    do a `Console.ReadLine()` so that our console application will pause there. Do
    not add any breakpoints anywhere to your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start debugging your application. The exception is thrown and the application
    continues running, a condition often experienced with much more complex applications.
    At this point, you would expect a log file to be appended with the fictitious
    data of the app, but nothing happened. It is at this point that you stop your
    application and start adding breakpoints all over your code in a hit and miss-type
    exercise. I say hit and miss because you probably will not know exactly where
    the error is. This is especially true if your code file contains a few thousand
    lines of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well now, with IntelliTrace and Historical Debugging, you just need to click
    on the **Break All** button:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05391_12_41.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Your application is now essentially paused. If you don't see the **Diagnostic
    Tools** window, go to **Debug** and click on **Show Diagnostic Tools** (or *Ctrl*
    + *Alt* + *F2*):![How to do it…](img/B05391_12_40.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio now displays the **Diagnostic Tools** window. Immediately you
    can see that there is a problem indicated by the red diamond icon on the **Events**
    section. In the **Events** tab at the bottom, you can click on the exception:![How
    to do it…](img/B05391_12_42.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doing this expands the exception details, where you can see that the log file
    was not found. Visual Studio, however, goes one step further with Historical Debugging:![How
    to do it…](img/B05391_12_43.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a link at the bottom of the exception details that says **Activate
    Historical Debugging**. Click on this link. This allows you to see the actual
    line of code that caused this exception in the code editor. It also allows you
    to view the history of the application's state in the **Locals** window, call
    stack, and other windows. You now can see the specific line of code that caused
    the exception in your code editor. In the **Locals** window, you can also see
    what the path was that the application used to look for the log file. This kind
    of debugging experience is immensely powerful and allows developers to go straight
    to the source of the error. This leads to increased productivity and better code:![How
    to do it…](img/B05391_12_44.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what is the takeaway here? If you only remember one thing, remember this.
    Once the users of your system lose faith in the abilities and potential of that
    system due to bugs, that confidence is almost impossible to regain. Even if you
    resurrect your system from the ashes, after it was laid low by bugs and other
    issues, to produce a flawless product, your users will not be easily swayed. This
    is because in their mind, the system is buggy.
  prefs: []
  type: TYPE_NORMAL
- en: I once had to take over a system partially developed by a senior developer who
    was leaving the company. She had an excellent specification and a well presented
    prototype shown to the customer. The only problem was that she left the company
    shortly after the system's phase one was implemented. When the bugs came popping
    up, the client naturally asked for her assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Telling the client that the developer (who has been solely responsible for building
    a relationship with the client) has left the company did not bode well to instil
    a sense of confidence. Having a single developer involved was the first mistake
    of this particular project anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, phase two was about to be developed by yours truly, who was also the
    only developer assigned to this client. This had to be done while building on
    top of the buggy phase one. So I was fixing bugs while developing new features
    for the system. Luckily this time round, I had a fantastic project manager called
    Rory Shelton as my wingman. Together we were dumped in the deep end and Rory did
    a fantastic job managing the client's expectations while being totally transparent
    with the client regarding the challenges we were facing.
  prefs: []
  type: TYPE_NORMAL
- en: The users were unfortunately already disillusioned with the provided system
    and didn't trust the software. This trust was never fully regained. If we had
    IntelliTrace and Historical Debugging back in 2007, I definitely would have been
    able to track down the issues in a code base that was unfamiliar to me.
  prefs: []
  type: TYPE_NORMAL
- en: Always debug your software. When you find no more bugs, debug it again. Then
    give the system to my mom (love you mom). You as the developer of that system
    know which buttons to click and what data to enter, and in which order things
    need to happen. My mom doesn't and I can assure you that a user unfamiliar with
    a system can break it quicker than you can brew a fresh cup of coffee.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio provides developers with a very powerful and feature rich set
    of debugging tools. Use them.
  prefs: []
  type: TYPE_NORMAL
- en: Setting conditional breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional breakpoints are another hidden gem when it comes to debugging. These
    allow you to specify one or several conditions. When one of these conditions are
    met, the code will stop at the breakpoint. Using conditional breakpoints is really
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is nothing you specifically need to prepare to use this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code to your `Program.cs` file. We are simply creating a
    list of integers and looping through that list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, place a breakpoint on the `Console.WriteLine(num)` line of code inside
    the loop:![How to do it…](img/B05391_12_45.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the breakpoint and select **Conditions…** from the context menu:![How
    to do it…](img/B05391_12_46.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will now see that Visual Studio opens a **Breakpoint Settings** window.
    Here we specify that the breakpoint needs to be hit only when the value of `num`
    is `9`. You can add several conditions and specify different conditions. The condition
    logic is really flexible:![How to do it…](img/B05391_12_47.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debug your console application. You will see that when the breakpoint is hit,
    the value of `num` is `9`:![How to do it…](img/B05391_12_48.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The condition is evaluated on every loop. When the condition is true, the breakpoint
    will be hit. In the example illustrated in this recipe, the true benefit of a
    conditional breakpoint is somewhat lost because it is a very small list. Consider
    this though. You are binding a data grid. Items on the grid are given specific
    icons based on the status of the item. Your grid contains hundreds of items, because
    this is a hierarchical grid. You identify the primary ID of the item which is
    bound to the grid. This primary ID is then passed to other code logic to determine
    the status, which determines the icon displayed.
  prefs: []
  type: TYPE_NORMAL
- en: To debug and press the *F10* key through hundreds of loops is not productive
    in any event. With conditional breakpoints, you can specify a value for the primary
    ID, and only break when the loop hits that value. You can then go straight to
    the item that is being displayed incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Using PerfTips to identify bottlenecks in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PerfTips are definitely one of my favorite features of Visual Studio 2015\.
    Explaining what they do doesn't do them justice. You have to see them in action.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do not confuse PerfTips with CodeLens. PerfTips is a separate option from CodeLens
    in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PerfTips are enabled by default. But just in case you are not seeing any PerfTips,
    go to **Tools** | **Options**, and expand the **Debugging** node. Under **General**,
    to the bottom of the settings page, you will see an option called **Show elapsed
    time PerfTip while debugging**. Ensure that this option is checked:![How to do
    it…](img/B05391_12_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a few simple methods that mimic long-running tasks. To do this,
    we will just sleep the thread for a couple of seconds. In the `Recipes.cs` file,
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your console application, call the static method `RunFastTask()` and place
    a breakpoint on this line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start debugging your console application. Your breakpoint will stop on the `RunFastTask()`
    method. Hit *F10* to step over this method:![How to do it…](img/B05391_12_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that 11 seconds later, the next line will be highlighted and
    the PerfTip will be displayed. The PerfTip displays the time it took for the previous
    line of code to execute. So the debugger that now sits on the `Thread.Sleep`,
    shows that the `RunFastTask()` method took 11 seconds to complete. The task is
    clearly not very fast:![How to do it…](img/B05391_12_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stepping in to the `RunFastTask()` method, you can place further breakpoints
    and step over them one by one to find the method that is causing the longest delay.
    As you can see, PerfTips allow developers to quickly and easily identify bottlenecks
    in code:![How to do it…](img/B05391_12_39.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many tools on the market that do this and much more, allowing developers
    to view all sorts of code metrics. PerfTips, however, allow you to see issues
    on the fly while you are stepping through your code as per your normal debugging
    tasks. It is, in my opinion, an indispensable debugging tool.
  prefs: []
  type: TYPE_NORMAL
