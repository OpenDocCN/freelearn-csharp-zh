- en: Chapter 3. Optimizing Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common in many applications to leverage all kind of objects that are used
    as data. The types of data can be primitive, object reference, and collection
    types. F# itself has its own unique types, especially collection types.
  prefs: []
  type: TYPE_NORMAL
- en: These types, especially when doing many computing-intensive operations, are
    crucial. Optimizations need not only relate to the location of the value of data
    stored according to the types, but also how we access them can have a big impact
    on overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: The deciding factors determining the best types to use, besides the memory locations,
    can vary. This is why it is quite hard to measure qualitatively. Measuring quantitatively
    can be tricky, although the statistical numbers may be informative.
  prefs: []
  type: TYPE_NORMAL
- en: We shall use the knowledge gained in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement* relating to the
    qualitative understanding of the internals of running F# code (the IL, tooling,
    and the GC) and have quantitative measures (the execution durations using timers
    and unit tests) as a gentle requirement for this chapter and the rest of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge of IL assembly and the fundamentals of .NET GC will help us to
    understand the internal working of .NET and F#'s unique data structures. Then
    we can optimize them by deciding the best use cases and the best types to choose
    for our specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A basic knowledge of .NET 4 BCL types and collections (including those that
    shipped out of band/OOB, such as immutable collections) is needed. There should
    be no easy way of thinking or taking shortcuts when using a type/collection for
    all cases, for example, using .NET advanced collection such as `BindingList<T>`
    explicitly for all collections that are only meant to be read and forwarded instead
    of `IEnumerable<T>` or `List<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides an overview of the available types in F# and the best
    practices to choose, use, and optimize. The data structure optimization is covered
    in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the types to store specific data in F# and their best usages (including
    structs, classes, and records)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices in using F# collections, with a comparison to .NET collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices in choosing an evaluation strategy (lazy or eager)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview and best practices of types in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store a value as data, every value needs to have a type, especially for static
    typed languages such as F#, C#, and VB. Many modern programming languages after
    the year 2000 put emphasis on types as the type of value of the data, instead
    of using the simple term of *data structure*. The types here also mean the types
    that are not just concrete types, but also generic types when used in conjunction
    with concrete types.
  prefs: []
  type: TYPE_NORMAL
- en: Static typing versus dynamic typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# by default has no built-in support for defining and optimizing types to store
    data as dynamic types on top of **Dynamic Language Runtime** (**DLR**). This dynamic
    type support is available in the form of a library from the F# FSSF open source
    project communities, the *FSharp.Interop.Dynamic*. This is available at [https://github.com/fsprojects/FSharp.Interop.Dynamic](https://github.com/fsprojects/FSharp.Interop.Dynamic).
  prefs: []
  type: TYPE_NORMAL
- en: This library is also available as a NuGet package as well.
  prefs: []
  type: TYPE_NORMAL
- en: DLR is basically an extension that runs on top of CLR to provide an infrastructure
    for dynamically typed languages such as Python, Ruby, and JavaScript that have
    no restriction on type definition. This means that any type is typed as dynamic
    in the beginning at the compile time, and the type resolution is resolved at the
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The impact of this dynamic type resolution has decreased performance at the
    initial runtime, as the type has to be resolved at runtime instead of compile
    time. Therefore, the use of dynamic types is not recommended, although F# can
    support dynamic type interoperability by having interop with DLR as demonstrated
    by *FSharp.Interop.Dynamic* library..
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since .NET Framework 4.0 (and CLR 4.0), DLR is included in the framework, and
    not as a separate download anymore. The original DLR repository is hosted in CodePlex,
    but the rest of the DLR development in .NET 4.0 is continued in Microsoft's .NET
    GitHub repo of .NET CLR.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about DLR, visit the following landing page of MSDN at [https://msdn.microsoft.com/en-us/library/dd233052(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd233052(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming languages, it is also implicitly required to have
    static typing because it's also part of the requirements of having a type inference
    feature. Having type inference is very crucial, as functional programming needs
    to be as concise and as close as possible to mathematical function syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: The use of dynamic type is against the common best practices of functional programming
    languages. Types are inferred statically and therefore resolved at compile time.
    Inferring type statically also gives us the ability to compose functions and values
    intuitively without worrying about casting and boxing at runtime. The nature of
    easily composing functions (operations in OOP) is one of the *main traits* (or
    required features) of functional programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static typing has these following advantages over dynamic typing:'
  prefs: []
  type: TYPE_NORMAL
- en: Type resolutions are solved at compile time. All of the inconsistencies of invalid
    value assignments or casts always give compile errors. A compile error is easier
    to fix than a runtime error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the type resolution at the compile time, the compile time is slower
    than the compile time of the dynamic type. Because the type resolution may add
    overheads when compiling, a slower performance is to be expected. Because the
    type resolution itself is in action, this is closely related to the F# compile
    phases of lexing and parsing. The compiler can perform more optimization by having
    incremental compilation as the background process under the infrastructure of
    Visual Studio tooling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static type is also more reasonable to reason about the code, since all of the
    variables and functions have types that flow nicely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having the knowledge of static type gives innovative and useful features such
    as code completion when accessing F# modules and functions, including the function
    parameter's type resolutions and XML summary documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term *code completion* is also called statement completion in Microsoft's
    MSDN Library. It means that when we code in the IDE, the language service will
    provide richer information about the type and its members (properties, function/methods,
    and events) and display it to us.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio since Visual Studio 5.0 has a robust feature called **Intellisense**
    that shows automatically the information about the type as we type `.` (dot) after
    the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This picture of F# code being edited shows Intellisense in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static typing versus dynamic typing](img/image00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Intellisense is active by default, and it is highly recommended to keep the
    setting as active. It adds little overhead on loading type information in the
    background as the compiler runs in the background, but it definitely increases
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although called statement completion by Microsoft, its use is not just for the
    code's statement completion. It is used in a broader sense in statements, class/module
    members including functions/methods, and public/protected/internal properties.
    Intellisense is also helpful in decreasing compiler errors because the full metadata
    becomes available at the frontend, minimizing compiler errors because of incorrect
    type names or syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: The technique of having type resolution at compile time is often called **early
    bound**, compared to the **late bound** nature of dynamic typing solved at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is related to one of the main traits of functional programming: function
    and data are the same first-class citizens of the functional programming language
    itself. To maintain this inseparable concept as a function and data, type inference
    must flow nicely. And type inference explicitly requires that the type must have
    a definition and must have strong type support as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about the traits of functional programming languages, we can
    check out F#''s documentation from MSDN. MSDN has simple but concise definitions
    of the required features of functional programming in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/functions-as-first-class-values-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/functions-as-first-class-values-%5bfsharp%5d)'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will not discuss further the dynamic type support in F# because
    it's not recommended in the sense of the functional programming perspective and
    the performance at runtime. Throughout the rest of this book, we will only focus
    on the static typing of F#.
  prefs: []
  type: TYPE_NORMAL
- en: Quick introduction to types in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Types in F# are basically categorized as two types: types in .NET BCL and types
    that are only available in F#. Although there are types specific to F#, these
    F# types can be used in C#/VB because basically all F# types are implemented on
    top of .NET CLR.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on .NET CLI standard partition I section I.8.2 about value types and
    reference types, the documentation is divided into two kinds of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value type**: The values described by a value type are self-contained (each
    can be understood without reference to other values). It is using one of the basic,
    built-in data types or a user-defined structure. The exception of this built-in
    type is a string; it is reference type. In F#/C#/VB, this value type is also known
    as a structure or struct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference type**: The value denotes the location of another value. The location
    is actually a pointer to a location of a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are four kinds of reference type:'
  prefs: []
  type: TYPE_NORMAL
- en: An object type is a reference type of a self-describing value. Some object types
    (for example, abstract classes) are only a partial description of a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface type is always a partial description of a value, potentially supported
    by many object types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer type is a compile-time description of a value whose representation
    is a machine address of a location. Pointers are divided into managed and unmanaged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in reference types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also support for generic parameterized types built in the fabric of
    CIL/CLR. The notation of a generic type in CIL/CLR is also enriched with covariance/contravariance
    support. It is mandatory for all of static programming languages run on top of
    CIL/CLR to have at least support for basic generic type, although covariance/contravariance
    may not be supported at language level.
  prefs: []
  type: TYPE_NORMAL
- en: By further looking at the CLS rule of CIL/CLR, we shall see that covariance/contravariance
    support is not mandatory. For further information, we can check the CLS rule starting
    at section I.7.3 of CIL/CLR ECMA-335 standard.
  prefs: []
  type: TYPE_NORMAL
- en: Quick overview of generic type support in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# has generic type as the parameterized type support, just as in C#/VB, and
    all have the same concept and similar semantics, although F# goes further by allowing
    type generalizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in F#, to declare a type that has a generic type parameter in
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parameter is used in code, the parameter of the generic type must be
    filled in, such as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In our last example, the generic type becomes specialized as `int`. The `List`
    is a sample of a concrete type that has a generic type as the type parameter.
    This concept is also similar to the semantics in C#/VB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, the types in F# that support the generic type such as
    F# `List`, `Map`, `Set`, and `Array` will use the same notation as F# types in
    the MSDN Library, although the complete compilation name may differ. For example,
    F# `Map` type is known as `FSharpMap` from outside of F#'s scope (when used in
    other languages such as C#/VB).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a unique way in F# to treat generics: the statically resolved
    generic. According to the F# documentation in the MSDN Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Statically resolved generic is a type parameter that is replaced with an
    actual type at compile time instead of at run time. They are preceded by a caret
    (^) symbol."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Using a statically resolved generic type parameter is more efficient than the
    normal generic type, but there is one caveat: it cannot be used on functions or
    methods that are not inline. It is also orthogonal at the normal generic type:
    normal generic type cannot be used on inline functions. The usage of statically
    resolved generics is discussed further in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1
    "Chapter 7. Language Features and Constructs Optimization"), *Language Features
    and Constructs Optimizations*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For official information on the F# statically resolved type, please consult
    the MSDN Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/statically-resolved-type-parameters-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/statically-resolved-type-parameters-%5Bfsharp%5D)'
  prefs: []
  type: TYPE_NORMAL
- en: F# can use the available types in .NET and the types specific to F#. F# has
    its own types because F# has supports for functional programming related types,
    including DU.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation of types in F# is available from MSDN at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-types](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-types)'
  prefs: []
  type: TYPE_NORMAL
- en: The basic summary and syntaxes of F# types are also available at the MSDN Library.
    We are now focusing on the type itself as the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the types in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive types**: These are the same as .NET primitive types such as `Int32`,
    `Boolean`, `Single`, `Double`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit type**: This is equal to `void` in C# and `Nothing` in Visual Basic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: These are special types in F# that describe a type that may contain
    a value or empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structures**: These are the same concept and semantics as `struct` in C#/VB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes**: These are the same concept as `class` in C#/VB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Records**: These are unique in F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discriminated unions**: These are unique in F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F# collections**: such as `Array`, `List`, and `Sequence.` All of F# collections
    are immutable by default, but the implementations of these collections are different
    in semantics from the BCL in .NET as used in C#/VB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: These are specific to the F# function. The F# function is also
    implemented as `FSharpFunc` delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegates**: These delegates support include F#''s own delegates and .NET
    delegates. F# delegates have the same concept as delegate in .NET, but the semantic
    is implemented differently due to F# particular `FSharpFunc` implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes**: These are the same as attributes in .NET BCL, therefore they
    are the same as attributes in C#/VB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will focus on types that are specific to F#, such
    as options, structures (because of the difference in semantics), records, discriminated
    unions, F#'s specific collections, and functions. Class will be discussed as well
    because it's also a F# OOP feature but we are going to focus on the semantic differences
    and the way F# treats classes.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated union (DU) is one of F#'s unique types and a feature that is also
    part of the functional programming language's commonly used types. It is also
    available in Haskell and Scala, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DU is one of the unique feature of types in a functional programming language.
    In fact, DU is quite similar in Haskell's algebraic data types, although Haskell's
    algebraic data types are richer than F#'s DU. Scala uses combinations of traits
    and case classes and is more verbose. But the concept is the same in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Overall runtime strategy of handling data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving further into the optimization of types to store specific data
    structures, we need to know the basic understanding of how the F# types are implemented
    in the resulting (compiled) generated code. The compiler may handle different
    types differently, although there could be compiler-specific optimizations later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to memory storage allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The type of storage in memory to store the data value according to the CLI
    standard specification basically falls into these three storage categories (from
    fastest to slowest):'
  prefs: []
  type: TYPE_NORMAL
- en: Register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Register is the fastest to access, because it does not have memory allocation
    overheads compared to stack and heap. The concept of register is similar to the
    processor's register. This register is not the same as stack and heap; it is related
    to how the value is stored in the code. Usage of register in CLR is translated
    into any of the processor's registers, and depends on the platform used. For example,
    when running on x86/x64 processors, Intel's general purpose register of EAX, EBX,
    ECX, EDX will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nature of stack is **LIFO**, abbreviated from **last in first out**. It
    means that data is stored not in a first come, first served basis, but the last
    one stored is the first one that can be read, as data is stored from the bottom
    to the highest layer of stacked fixed locations. This is why it is simply called
    stack. The analogy can be seen when we wash dishes:'
  prefs: []
  type: TYPE_NORMAL
- en: The first dish is the first stack on the lowest stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second dish is put onto the first stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next one is put on the second stack, and this process is the same for the
    following dishes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To wash the dishes, we have to take the highest stack on the top of the stack
    first before we go to the first one. So the last stack is the first one to be
    washed because the last stack is located at the highest layer. This mechanism
    is the main reason why it is called LIFO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the world of computer science, the act of storing or putting the data onto
    a stack is called *push*, and the act of taking the data out from a stack is called
    *pop*.
  prefs: []
  type: TYPE_NORMAL
- en: The terms push and pop on stack are also the same concept in .NET CLR, and they
    are quite similar in semantics although the implementation detail is *virtualized*
    by the .NET CLR. The actual machine assembly code after AOT or JIT in the Debug
    mode is translated into the related processor's `PUSH` and `POP` instructions.
    In the context of .NET CLR on the x86 (32-bit) or x64 (64-bit) platform, these
    `PUSH` and `POP` instructions will be translated into a one or more calls to machine
    assembly of `PUSH` and `POP`.
  prefs: []
  type: TYPE_NORMAL
- en: The virtualization of data and the operations are important, as .NET CLR has
    its own isolations to help to prevent intentional manual memory allocation of
    pointers, subroutines, and data to be mixed. It is quite common for the virtualization
    to have its own mechanism of disposing unused objects (for example, out of scope
    when a method/function has finished executing) or an object that is explicitly
    disposed. Modern virtualization often has its own garbage collector for these
    unused/disposed objects. The isolations, garbage collections, and the sequence
    of garbage collections (Gen-0, Gen-1, Gen-2) are actually part of the .NET CLR
    memory management, and this is called *managed memory management*. This is the
    reason why the code running on top of CLR is called managed code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of virtualization in CLR is quite similar to the concept of virtualization
    in *Java Virtual Machine* (JVM). The concept of having garbage collection is also
    part of the virtualized environment nature of CLR and JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Details on the raw flow of machine assembly of `PUSH` and `POP` are out of the
    scope of this book, as we are not dealing with machine assembly instructions directly.
    For more information on assembly language, please consult Intel's landing page
    of the software developer manual on Intel processors at [http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates storing or pushing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack](img/image00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting out or popping data from stack is done by accessing the last of the
    data pushed. The operation goes from top (the last pushed) to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of using stack are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks are fast to store, the act of pushing data onto stack is just adding
    data consecutively. It does not require a pointer allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no fragmentation, because the order of filling stack is always contiguous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks take a predefined length of the number of data stored and cannot be allocated
    dynamically. This is intentional, as stack is allocated up front and it is also
    bound to the limits imposed by the processor and the size of memory (RAM).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each stack has a predefined length for each slot of data. Therefore, stack is
    not ideally suited for variable lengths of data such as strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks are often quickly exhausted as most stack size is limited and always
    less than the allocated heap. For example, stack is often used to store the initial
    pointer of recursive function calls, which is why every recursive call means pushing
    a pointer of the location of the initial call. After a function finishes its operations,
    it pops the last pointer to go to the caller. If the recursive calls are too deep,
    the stack is exhausted and this condition is often called *stack overflow*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The stack overflow is usually thrown as a `System.StackOverflowException`.
    Starting with .NET Framework 2.0, we can''t catch `StackOverflowException` directly
    as this is not allowed. The CLR/CIL 2.0 also implies this as well. For more information,
    please consult the `StackOverflowException` documentation at MSDN Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/system.stackoverflowexception(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.stackoverflowexception(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: For the case of recursive function calls, F# has optimized most recursive function
    calls by translating them into a loop in the IL. This loop optimization guarantees
    that the function will not take lots of stack allocations and therefore prevents
    stack overflow caused by deeply nested recursive function calls.
  prefs: []
  type: TYPE_NORMAL
- en: To allocate storage dynamically, the only way is to use heap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term heap is not to be confused with *heap as data structure*. Heap in a
    data structure is rarely used, as it's actually a specialized tree.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heap is simply a pool of large memory; usually it's in a form of virtual memory
    space. It can be allocated and deallocated dynamically on demand. The term allocate
    means the act of reserving a portion of memory. The term deallocate means freeing
    the resource (portion of memory) that was previously allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Heap is used to allocate memory for storing these kind of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsafe methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weak reference methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference unsafe pointers and managed pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices of types for storing and accessing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When discussing best practices of types to use to store data, we must consider
    these conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The form of the value of the data. We can simply define this as the form of
    the data, or the semantics of the data value as the type of the value. The precision
    of the data is also part of the form of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the data is manipulated in the code. Is the data manipulated inside
    a function lambda or not as part of a function lambda? It is also important as
    this is implementation-specific in F# and .NET CLR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the lifetime of the data. This later will define where and how
    the data is stored in the memory, and we will discuss this in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final decision regarding implementation in the generated IL may vary as
    well. This is compiler-specific but it is still closely related to the first point
    about the form and the second point about the lifetime of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of the previous points and the relations between them.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest one to understand is the form of the value of the data. To understand
    more about the form of the value, it is common to approach the form as the type
    of the value. For example, the numeric value, the `Boolean` value, and the `String`
    value. A type must be attached to each value, as this is a basic requirement of
    a static typed language such as F#.
  prefs: []
  type: TYPE_NORMAL
- en: CLR itself implies that all values *must* have defined types, because there
    are explicit type declarations in the IL which must be easily seen. The types
    are usually declared in the return type of the method, the method parameter signatures,
    and the `.locals` section in the IL.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some sample cases of these in the generated IL from F# compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `fact` function in the FSConsole01 in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement* has these type
    declarations for return type, parameter, and each variable used in the function
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The variables are given a local name as `v_0`, `a`, and `v_2` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this IL, the `.maxstack` directive defines how much the stack is allocated.
    The stack is allocated to use five slots of stack to store five values for this
    function to operate.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the stack operations beginning with `IL_0001` to `IL_0004` line segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The operations for those four lines of IL are:'
  prefs: []
  type: TYPE_NORMAL
- en: The IL `ldarg.0` means load argument with index `0` (the first argument/parameter
    of the fact function) onto stack. This means pushing the value of the parameter
    onto stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IL `stloc.0` means the pops value from stack to the local variable. The
    popped value is the value from the previous IL, the `ldarg.0` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IL `ldloc.0` means load the local variable onto stack. This means pushing
    the value of the local variable to stack. The local variable is the index `0`,
    the first local variable declared in the `.locals` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IL `ldc.i4.1` means push value `1` onto stack with the type as `Int32`.
    All of the IL of `ldc.x` means pushing a numerical constant with the desired type,
    whereas the `i4` means `Int32`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more information about these ILs, please consult partition III of ECMA-335
    about the CIL standard. The availability of `ldc.i4.1` IL also means that the
    value must have the type declared explicitly. This is further proof that .NET
    CLR implies static typed, even at the IL level.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of types that are used in F# from the perspective of programming
    language features: primitive types and non-primitive types.'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types are types that are available built-in as language features,
    and they are often types that are the easiest to construct (initialize) and manipulate.
    To maintain a higher compatibility with CLR and .NET BCL, the primitive types
    of F# support all of the primitive types in .NET BCL with the additional F# unique
    primitive type, `unit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The priority order of feature support from the base to the top on F# is:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET CLR (runtime) support
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .NET BCL support (including `BigInteger`, as this is not explicitly supported
    in CLR)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: F# unique types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CLR type support must come first, as all of the primitive types must support
    CLR types first, especially all of the value types in CLR. This mandatory requirement
    is also part of official F# 4.0 Language Specification.
  prefs: []
  type: TYPE_NORMAL
- en: For an official list of F# primitive types, visit the MSDN Library at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/primitive-types-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/primitive-types-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by using the .NET original type name instead of using F# keyword,
    as it's also easier to understand based on the list of primitive types. For example,
    it's easier to use `Int32` as F# int because we might misunderstand *int* as `Int16`
    instead of `Int32`. This is quite common in programming languages, because of
    different implementations of how a language specification defines basic integer
    length. Fortunately, F# int is the same as C# `int` and VB Integer, as they both
    have the same length of 32 bits (4 bytes). But this symmetry might not be the
    same for C++ and other languages, although they may have support running on .NET
    CLR.
  prefs: []
  type: TYPE_NORMAL
- en: If the value is a primitive type that has fixed length and it is also directly
    related to IL types such as `Char`, `SByte`, `Int16`, `Int32`, `Int64`, `Boolean`,
    `Single`, `Double`, or even an unsigned numeric such as `Byte`, `UInt32`, then
    the compiler will mostly store this on stack. `Char`, although it's not a numeric,
    is stored as a numeric.
  prefs: []
  type: TYPE_NORMAL
- en: String does not have a fixed length, and it is also a composite type, because
    it is not a type that is standalone (it is not a type that contains other types).
    It is a type that contains other types as a collection. This is obvious because
    the declaration of `String` class in .NET BCL implements an object that implements
    `IEnumerable<Char>.` Therefore, string is composed as collection of `Char`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the nature of a collection, the length may vary. It is also quite
    normal to assume that a string literal will always vary in length. Therefore,
    string is treated differently from other primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push a string constant value onto stack, the IL instruction is `ldstr`.
    To illustrate this, let''s revisit our `FSConsole01` project. It has as its entry
    point the `main` method. Let''s see the IL of `main`: (`IL_0006` and `IL_000b`
    are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Hello F# world` string is treated as a string constant value, and it is
    pushed by `ldstr` at the beginning. At the end of `main`, before returning `0`
    as the successful running code, it removes the string value from stack using the
    `pop` IL.
  prefs: []
  type: TYPE_NORMAL
- en: This shows that string has its representative in CIL as well. It is typed as
    `string`, mapped to `System.String` in .NET BCL.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, please see partition I section I.8.2.2 of the CIL standard
    (ECMA-335) to check all of the CIL types of .NET BCL primitive type mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Any primitive types, by default are stored in the memory using stack as its
    container storage. It is a bad practice to always assume that all of the uses
    of value typed will always be stored on stack, especially when the code that uses
    the data is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: This is subjective to the internal implementation of F# compiler, but this technique
    is quite common in C#/VB compiler as well. F# has to conform to Common Language
    Specification rules as governed by the CIL standard, not just C#/VB. Therefore,
    it is intuitive by default in the normal code (without any closure that is common
    in lambda functions) that all of the primitive types of CIL will be stored onto
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Any constant string value is always pushed on stack, as shown in the sample
    `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, string can be stored in stack or heap, depending on the actual
    implementation of the code and the use of data manipulated in the code. Any variable
    used in the code can be implemented differently, according to the code. The storage
    location depends on the location of the closure as well.
  prefs: []
  type: TYPE_NORMAL
- en: A *closure* is simply a technique to capture a variable that is scoped outside
    a lambda function. Closure is a very useful feature in many programming languages,
    although it is mostly used when we use lambda functions. The way closure works
    in F# is the same as in C#/VB.
  prefs: []
  type: TYPE_NORMAL
- en: 'F# can be used to treat the function scoped variable to be the reference type
    for the inner function, although the type of the variable is the struct/value
    type. This is also a rule of the restriction of the F#: variable used for the
    closure that is going to be mutated/changed; it must have a reference type on
    its value, whether the type of the variable is a struct or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The line that declares the `count` variable uses the `ref` keyword to define
    that it is not just a passing value; it is also passing references as well.
  prefs: []
  type: TYPE_NORMAL
- en: The use of immutable data captured as closure will be stored on stack, but this
    is actually an implementation detail of F# compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The point regarding the lifetime of the data concerns how long the data in a
    variable is used throughout the flow of the code. It is also related to closure
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully recap and understand the relations of the form of the data and the
    lifetime of the data, these are the rules of treating the data based on the lifetime
    of the data used:'
  prefs: []
  type: TYPE_NORMAL
- en: If the data is used many times as a closure but it is immutable, this can be
    defined as having a short lifetime. The data is stored on stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string constant value is always considered as short-lived data. Therefore,
    it is stored on stack and this is also the main implementation detail of the CIL/CLR
    `ldstr` instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the mutable/immutable variables that are scoped locally in a function/method
    that are not used as a closure will always be stored on stack, because this function/method
    scoped variable is defined to be short-lived. It is only used within the scope
    of the function/method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the value type (struct) is by default stored on stack. There are some special
    cases that the value type will be stored on stack. When the value type is referenced
    within `System.WeakReference<T>`, the value will be stored on heap along with
    the `System.WeakReference<T>` container. Also the use of `ref` when assigning
    the function scoped variable will mostly put the value on heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data as closure is intended as a mutable reference type, it will be stored
    on heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data is part of public properties of a class/record, the data is stored
    on the heap of the container class/record. For example, a `public` property member
    of a class is stored on heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long-lived data is always stored on heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`WeakReference` is useful because we can use it to enforce GC not to do garbage
    collection on the data upon which the type is parameterized. The data is contained
    in this `WeakReference`. Any other type of reference will always be garbage collected
    at any Gen-0 or Gen-1 phase.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `WeakReference` usage, consult the MSDN Library at [https://msdn.microsoft.com/en-us/library/gg712738(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/gg712738(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Based on the rules, it is recommended to use immutable closure instead of mutable,
    especially when it is marked to be a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common best practice still holds: allocating stack is faster than
    allocating data on heap. It is quite obvious that the immutable closure is recommended
    and better than reference typed closure.'
  prefs: []
  type: TYPE_NORMAL
- en: To simply recap, the choice is often choosing between struct and class (including
    record, DU) in F#. All of record, DU are implemented as classes in the IL, and
    therefore they are basically specialized types of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Always know the difference of value type and reference type. But never assume
    that the value type is always stored on stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer value types instead of classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use object pool to contain the most used types and put them in a collection.
    This will prevent GC from always automatically performing garbage collection each
    time the variable is used. But this strategy is not recommended if the variable
    used is mostly short-lived and the intention is mostly for a quick calculation
    that is repeated in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run garbage collection when the code is running idly after processing inputs
    or after ending all of the long running processes. This will increase the efficiency
    of garbage collection to minimize overheads instead of doing GC when the code
    is busy doing computations or even side-effect computations. Although the overhead
    of Gen-0, Gen-1 may impact the memory deallocation and allocation process, having
    garbage collection run on idle times will minimize overheads when the collection
    happens on heavy computations (especially when performing recursive operations
    in parallel).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `WeakReference` for an object that has a tendency to be long lived but used
    frequently to decrease the GC overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an immutable value when capturing the value inside a function lambda. Immutable
    values when captured in lambda are always stored on stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distinction details of the value type and the reference type, and how they
    behave in memory, especially in the stages of garbage collection, are described
    in detail in the CIL/CLR ECMA-335 standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, these F# rules are also applied for C#/VB. Eric Lippert (former developer
    of the C# compiler) has discussed this in a detailed explanation on his MSDN blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/ericlippert/2010/09/30/the-truth-about-value-types/](https://blogs.msdn.microsoft.com/ericlippert/2010/09/30/the-truth-about-value-types/)'
  prefs: []
  type: TYPE_NORMAL
- en: Again, although this is mostly hidden from us as F# developers, these implementation
    details will help us to understand and avoid misconceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The current discussion has different semantics depending on whether or not a
    collection of data is used in the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices in using F# collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The F# types are mostly describing types that are not collection types. F# has
    its own unique collection types as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The F# collection features are mostly implemented as modules, with the namespace
    of `Microsoft.FSharp.Collections`. The following are the F# collection modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Module `Array`: Basic operations on arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `Array2D`: Basic operations on two-dimensional arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `Array3D`: Basic operations on rank 3 arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `Array4D`: Basic operations on rank 4 arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `ComparisonIdentity`: Common notions of comparison identity used with
    sorted data structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `HashIdentity`: Common notions of value identity used with hash tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `List`: Basic operations on lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `Map`: Functional programming operators related to the `Map` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `Seq`: Basic operations on enumerable collections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module `Set`: Functional programming operators related to the `Set` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`, `Map`, and `Set` are unique to F#.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about F# collections, please consult the MSDN Library
    at: [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-collection-types](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-collection-types).'
  prefs: []
  type: TYPE_NORMAL
- en: The page shows the list of types and also the computation complexity or algorithmic
    speed (*big O notation*) of each function of the collection. It is recommended
    that you should pay close attention to the number of computation complexities
    of each function and use them carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Big O notation* is originally coming from the realm of basic computer science.
    It is almost non-trivial in the programming world. But it''s crucial to understanding
    the abstract performance in the terms of computation complexity, as it is always
    having has a direct relation on the overall performance. Simpler computation complexity
    such as *O(1)* or *O(log n)* is always better than *O(n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `tryPick` in `Array`, `List`, and `Seq` is *O(n)* and in `Map`
    it is *O(log N)*. This means the `tryPick` in `Map` is faster when the number
    of elements are very large, such as more than `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas *O(n)* for `1000` elements means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some concrete operations are often quite trivial to spot or to deduce quickly;
    for example, loops that run a definite n number of times are always at least *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: There's no simple way to reduce running times further, unless the loop is executed
    within a parallel flow of a parallel loop. Parallelism is actually also one way
    to have optimization as part of the concurrency support/features of F#. We will
    discuss concurrency further in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#* and [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2
    "Chapter 5. Advanced Concurrency Support in F#"), *Advanced Concurrency Support
    in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about big O, please refer to the MIT computer science course
    overview at [http://web.mit.edu/16.070/www/lecture/big_o.pdf](http://web.mit.edu/16.070/www/lecture/big_o.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: The complexity scales value in terms of big O is better in `Map` than in `Array`,
    `List`, and `Seq`.
  prefs: []
  type: TYPE_NORMAL
- en: The big O notation may break or may not be valid anymore when the code runs
    in parallel because there's no exact guarantee of the number of executions that
    actually happen when the code runs in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting from this chapter, we will enrich our perspective on measuring performance
    by the quantitative and qualitative methods we learned in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement* combined with
    the necessary big O notation, to understand performance optimization in the perspective
    of computation complexity. The use of big O should come after having quantitative
    and qualitative measurements first, as big O often shows no real quantitative
    data when measuring concurrency in action.
  prefs: []
  type: TYPE_NORMAL
- en: But the use of `Map` is not always the best option for all cases. `Map` behaves
    like the .NET `Dictionary`, as it stores elements that have pairs of keys and
    values in it. The semantics of `Map` are different from `Dictionary`, as will
    be explained later.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the conceptual mappings of the F# collection to .NET BCL:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **F#** | **.NET BCL** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq` (sequence) | `IEnumerable<T>` | F# `Seq` is an alias of `IEnumerable<''T>`.
    Therefore it is also valid and safe to use `Seq` for all operations that leverage
    `IEnumerable` and `IEnumerable<''T>,` and they are eagerly evaluated by default.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | `List<T>` | F# `List` is implemented as single linked list. To have
    only immutability parity, .NET BCL has `ReadOnlyCollection<T>` type that is equal
    to the immutability feature.F# `List` is also thread safe. The equivalent of `List<T>`
    that has a thread safe feature in .NET BCL is the `SynchronizedCollection<T>`
    in the System.Collections.Generic namespace, and this collection is not immutable.So
    currently there is no equivalent type of F# `List` in .NET 4/4.5.4.6.1 BCL that
    is both immutable and thread safe. |'
  prefs: []
  type: TYPE_TB
- en: '| `Array` | Implicitly implemented as implementation of `IEnumerable<T>` but
    it is restricted to being a single variant, not a covariant. | F# `Array` is a
    single variant. Both the F# `Array` and .NET BCL `Array` have a fixed length.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` | `Dictionary<TKey,TValue>` | Both `Map` and `Dictionary<TKey,TValue>`
    implement the `IDictionary<TKey,TValue>` interface. Therefore, in the conceptual
    perspective, it is the same but not in the semantic perspective.F# `Map` is just
    immutable by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `Set` | No equal type. | There''s no equal type of `Set` in .NET BCL. The
    `Set` is actually a container of items but the item in the elements of the set
    must be unique. |'
  prefs: []
  type: TYPE_TB
- en: For more information about the .NET BCL collection types, please consult the
    starting page of `System.Collections` at [https://msdn.microsoft.com/en-us/library/mt481475(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/mt481475(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'The F# sequence can create an infinite collection by initializing `Seq` using
    the `seq.initInfinite` function. A sequence will always be evaluated lazily. The
    consequence of this is the efficiency: the operation is applied as necessary to
    regenerate the elements of the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no compiler or runtime trick for this infinite sequence. The F# infinite
    sequence is also available for use in C#/VB.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing F# List to .NET List<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `List` is similar to .NET `List`, because they both have indexes and the
    same methods as well, although the semantics are different.
  prefs: []
  type: TYPE_NORMAL
- en: The `List` is implemented as a single linked list, not as the `List<T>` in .NET
    BCL. This linked list implementation is faster than `List<T>`. The `List` can
    be stored recursively by easily using F# `head::tail` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single linked list means that each element of the list contains a portion
    of property that points to the next element of the list, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing F# List to .NET List<T>](img/image00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: F# `List` is efficient and faster than `List<T>` in a sense that a single linked
    list always guarantees that any operations that access only the head of the list
    are *O(1)*, and element access is *O(n)*. It is ordered that each element can
    have a pointer to the next element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The apparent advantages of F# `List` over .NET `List<T>` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: F# `List` is immutable. It can be considered as a persistent data structure
    when combining with `List`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of a linked list of the F# `List` means that it is efficient when
    combining lists using concatenation, as explained later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has efficient access to the recursive nature of `head::tail`, which can then
    be used in recursive functions. This is common in functional programming languages,
    as the recursive nature is deeply implemented not just on functions, but on data
    structures as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an example of a recursive `head::tail` in a recursive function, let''s
    look at the following sample code from F# MSDN of the F# `List` documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sum` function will call the `sum` function again with the parameter of
    the rest of the elements (`tail`) after the first element (`head`). The recursive
    nature of `head::tail` will continue automatically on the next recursive call
    as the next `head::tail` will contain the list of the resulting previous `head::tail`.
  prefs: []
  type: TYPE_NORMAL
- en: The `head::tail` syntax in the previous code sample can be leveraged to recursively
    access the head and the rest of data on the tail. There is no comparable feature
    for this in C#/VB. If there is any, the implementation would be less efficient
    when `List<T>` is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As linked lists, concatenating F# `List`s are also faster than concatenating
    a .NET `List<T>`. Concatenating between two or more `List` items is done in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `List` that has the total capacity of all `List` items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the source `List` structurally (not referentially).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tail link of the source is linked to the head of the destination list, and
    the rest of the destination lists are copied structurally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process is repeated until all the participant lists have been copied and
    linked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operations do not (visibly) update the structure in place, but instead always
    yield a new updated structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: F# has a convenient operator to concatenate `List`, using the `@` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `list3` will contain the concatenation of `list1` and `list2`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing F# Map to Dictionary<TKey,TValue>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# `Map` is equal to .NET BCL `Dictionary<TKey,TValue>` conceptually because
    they both implement .NET `IDictionary<TKey,TValue>`. But F# `Map` is semantically
    different from `Dictionary<TKey,TValue>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please do not confuse F# `Map` as type with F# `Map` as a module. F# `Map` as
    a module is called `Map`. From outside, it is called by referencing to the namespace
    of `FSharp.Collection.Map` module. The F# `Map` as a type is available from outside
    F#. The name is called `FSharpMap`.
  prefs: []
  type: TYPE_NORMAL
- en: From the performance perspective, it is still faster because of its immutability
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: From the correctness perspective, F# `Map` is enforcing us to be more correct
    because of the constrained key and value of the generic type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the type definition signature of F# `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually translated into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Map` has two generic type parameters: `Key` and `Value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Key` is marked with `EqualityConditionalOnAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Key` is constrained to be derived from the comparison'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value is marked with `EqualityConditionalOnAttribute` and `ComparisonConditionalOnAttribute`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ComparisonConditionalOnAttribute` means that the generic parameter type
    satisfies the generic comparison constraint if and only if the type satisfies
    this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: The `EqualityConditionalOnAttribute` means the generic parameter type satisfies
    the F# equality constraint only if a generic argument also satisfies this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '`Map` has the default constructor that accepts parameter of the comparer and
    the tree is the base collection for bespoke comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: The comparer parameter is constrained implementing `IComparer`. Although F#
    has no support for covariance/contravariance, implementing `IComparer` for the
    comparer parameter means that it is also implicitly covariant. This is quite obvious
    because `IComparer` has the signature of `IComparer<in T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These additional attributes might add a little overhead when doing comparisons
    and equality checks, but are necessary because of these correctness rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Key` must be able to be checked for equality, because the key must be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Value` must be able to be checked for equality and comparison. This is
    also important, as the value must be able to be sorted later (having a sorting
    operation is optional).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The deciding considerations in choosing `Map` or `Dictionary` are:'
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to have a collection that has keys and values but needs immutability,
    use `Map`. The net effect of checking the equality of the values is not bigger
    than the usefulness of immutability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you just want to have a collection that has keys and values without worrying
    about the order of the values and need immutability, use `Map`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you just want to have an immutable implementation of `Dictionary` with sorted
    `Keys`, use `Map` with `Keys` that have been sorted by sorting the map's keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a mutable `Dictionary`, use `Dictionary<TKey,TValue>` instead of
    `Map`. It is better to use `Dictionary<TKey,TValue>` directly for mutable purposes
    than marking a `Map` instance as *mutable*. Marking a `Map` instance value as
    mutable means we are using `Map` but treating it as mutable. This simple hack
    may break interoperability with other languages such as C#/VB, because `Map` is
    supposed to be kept as immutable but the integrity is broken as mutable. The intention
    of correctness is also broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to have a mutable `Dictionary` sorted by keys, use `SortedDictionary`
    instead. It is thread safe, unless you inherit `SortedDictionary` and implement
    your own sorted `Dictionary` because there is no further guarantee that on your
    own custom sorted dictionary, the thread safety will not be violated or overridden.
    Furthermore, referential transparency is not guaranteed to be the same or not
    broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By considering these scenarios, we should use F# `Map` as the main consideration.
    Marking `Map` as mutable to cheat on the mutability is not recommended. This applies
    also to the other collection types such as F#'s `List` and `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a value evaluation strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that F# collections have support for lazy evaluation, not just eager
    evaluation. Almost all of F# collections are lazy, except the operations that
    require modifications on the order of the elements. The collections in F# that
    do not have a lazy feature are F# `Array` and `Set`, as the semantics are similar
    to the .NET BCL array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Collection modules on F# are not all lazily evaluated. The same behavior is
    applied on these modules: `Array`, `List`, and `Sequence`. The F# developer team
    is working hard to end the feature disparity by making relevant functions to be
    available for all modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more complete list of F#''s progress on narrowing feature disparity (focusing
    on what''s new in F# releases) visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/whats-new-in-visual-fsharp](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/whats-new-in-visual-fsharp)'
  prefs: []
  type: TYPE_NORMAL
- en: For example, `map` and `filter` do not require modification of the order of
    the elements; sort (`orderby` in LINQ) and `groupby` require modifications.
  prefs: []
  type: TYPE_NORMAL
- en: The real reasons why we could deduce that all of the operations of the functions
    that modify or reorder the content of a collection make it lazy is almost impossible
    because of the way these operations work, especially when considering operations
    that relate to category theory and relational algebra, subjects borrowed from
    the realm of mathematics. All of the function implementation of map, filter, fold,
    and unfold are actually based on relational algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Category theory deals with how the function compositions work, especially when
    the chaining of functions has to be composable. Relational algebra deals with
    operations of map, reduce, filter, fold, and unfold on a collection of elements.
    Relational algebra and category theory are the foundations of how F# collection
    operations work, and they are quite commonly known in other functional programming
    languages as basic features.
  prefs: []
  type: TYPE_NORMAL
- en: The topics of category theory and relational algebra are beyond the scope of
    this book, although it is recommended to understand the basics of these mathematical
    disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about relational algebra, please check one of this sample course
    from MIT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-830-database-systems-fall-2010/](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-830-database-systems-fall-2010/)'
  prefs: []
  type: TYPE_NORMAL
- en: Category theory is the foundation knowledge of functional constructs composition
    such as Monad and Monoid, and it is also the base theory behind lambda calculus
    and higher order functions. Lambda calculus and higher order functions are part
    of the common functional programming features.
  prefs: []
  type: TYPE_NORMAL
- en: The terms lazy or eager evaluation are based on the evaluation strategies of
    the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation means expressions are only evaluated once and then only if the
    evaluation is actually needed. It is also called on-demand evaluation or deferred
    execution (the operation is deferred to be executed later).
  prefs: []
  type: TYPE_NORMAL
- en: Eager evaluation means expressions are evaluated as soon as the computation
    expression is bound to a variable. F# by default is using eager evaluation for
    any variable assignment, unless the assignment has explicit lazy expressions.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence of having lazy evaluation, the type must be aligned and well
    defined before being lazily evaluated. Otherwise, type casting or invalid argument
    exceptions may occur. This is one of the main reasons why static typing is mandatory
    in functional programming languages such as F#.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, lazy evaluation can be applied on a type and can also be implemented
    as functions on collections such as `Seq` and `List`.
  prefs: []
  type: TYPE_NORMAL
- en: On collection, the resulting collection from the operations that have lazy evaluation
    are executed when the collection is going to be read in iteration, including evaluating
    `head::tail`.
  prefs: []
  type: TYPE_NORMAL
- en: When applied on a type, F# has a `lazy` keyword to denote lazy computation to
    enclose the operation to be lazy. The result is a variable that has an operation
    to be executed and evaluated later when the evaluation to read is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of lazy computation in action when used as standalone type
    (not a collection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we put a debugger breakpoint on the second line, the result is not yet having
    a value and stepping over the line will not execute the `x + 10` operation. After
    stepping over line 3, the result will have a value. This will ensure on-demand
    execution or computation.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when operating on a type, F# will always do eager evaluation unless
    a lazy computation is applied. Using a lazy evaluation on all of operations or
    expressions will increase stack allocation overheads, and these overheads will
    exhaust stacks as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to only apply lazy computation on a type if the expression
    is reused at in many methods, because applying lazy means the operation within
    the lazy computation will only be executed once and then the result will be used
    many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about lazy computation on types, visit the following MSDN
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/lazy-computations-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/lazy-computations-%5Bfsharp%5D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a language construct that implements lazy evaluation implicitly
    as a state machine: using `yield` as an iterator efficiently on a F# `Sequence`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another sample that saves `yield` into a variable is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Internally, `yield` is implemented as a state machine, which lazily computes
    the operation if the sequence is read or iterated. The F# `yield` is similar to
    the C#/VB `yield` although the actual semantics are different. It is similar in
    terms of the state machine based on a common design pattern of iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more internal details of how an iterator works, check Microsoft''s developer
    blog entry written by Raymond Chen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/oldnewthing/20080812-00/?p=21273](https://blogs.msdn.microsoft.com/oldnewthing/20080812-00/?p=21273)'
  prefs: []
  type: TYPE_NORMAL
- en: His blog has a series to describe iterators from an abstract as syntactic sugar
    to the raw implementation, although he describes the yield iterator from the perspective
    of the C# yield iterator specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The use of yield in F# is actually a syntactic sugar that translates into a
    complex state machine as described in Raymond Chen's article. We should not worry
    about the implementation detail of this yield, because next releases of F# may
    change the implementation details of yield.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The yield and lazy are sample features of F# that hide the implementation details
    of the complex machinery of state machine. This will let us focus on what we are
    going to have as the result, instead of worrying about how we compute the result.
    This is often called a declarative instead of purely imperative. The declarative
    aspect of F# does not stop here; many concurrency constructs such as the async
    computation are declarative as well.
  prefs: []
  type: TYPE_NORMAL
- en: Most performance characteristics of lazy evaluation are better than eager evaluation,
    especially when the expression captured and evaluated lazily is used many times.
    The total net effect of using a lazy expression is noticeable, because of the
    execution on demand.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of the F# unique approach as a functional programming language
    is not pure. F# is not doing all the aspects of language constructs lazily. For
    example, not all operations of `Seq` implement lazy evaluation. If we compare
    F# to other pure functional programming languages such as Haskell, Haskell has
    emphasized lazy evaluation on almost all cases, including comprehensive type resolutions,
    collection iterators, and even encapsulating side effects such as I/O lazily.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some disadvantages of having all expressions and functions to be
    lazy:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile times will always slower than eager evaluation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all operations are having lazy evaluation implemented, all of the complex
    state machines must be implemented for each case for all operations. This will
    result in a long compile time, including translating to state machines at the
    IL level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no guarantee that having all expressions and functions as lazily evaluated
    will not exhaust stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The detail of the possibility of scenarios for lazy evaluations is described
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios involving evaluation strategy and memory allocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy evaluation always consumes stack to allocate the metadata, the pointer
    to the expression. The expression evaluated may also be stored on stack if the
    expression is simple and no reference type (for example, usage of string or having
    a value captured in `WeakReference`) is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must consider these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use lazy evaluation whenever possible when doing operations on collections,
    especially when using a collection that only does forward-only features such as
    `Sequence` or `IEnumerable`, including `IEnumerable<T>` as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more complex recursive expressions or computation, lazy evaluation will
    consume stack rapidly, especially when combining complex lazy evaluation within
    recursive functions. Eager evaluation is preferred for this scenario, as the result
    of recursive functions always stored on stack as a stack frame with the last pointer
    of the previous same function call. If the lazy operation inside a recursive function
    is guaranteed to be simple and only calculating value types, then we can use lazy
    evaluation quite safely without consuming too much stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the lazy operation involves a reference type, an overhead of going back
    and forth between allocating stack and heap will always occur and this will result
    in having poor performance in terms of memory consumptions and time consumed during
    roundtrips of memory allocation between stack and heap. GC overhead will always
    occur during this heavy round trip, because GC cannot be guaranteed to collect
    at the right time after a recursive call function is finished and returned to
    its previous recursive function call. At first, stack will always be garbage collected
    first but mixed stack and heap will make GC slower to collect as stack needs to
    detach any references to heap allocation before being popped and garbage collected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our function is used in parallel, any atomic expression inside the function
    should be implemented lazily, as this is more efficient especially when the function
    will be running many times. Unless the function is implemented as a recursive
    function that has lazy operations in parallel it is also consuming stack quite
    rapidly, as described in the second scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid side effects whenever possible. If the lazy evaluation or yield expression
    contains side effects such as I/O, an exception may occur and this is expensive
    in terms of stack trace and stack frame allocation overhead. CPU bound calculation
    is a side effect but this kind of side effect can be ignored, as long as it is
    combined with other concurrency techniques such as parallelism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to avoid lazy evaluation on UI threads. F# and CIL/CLR do
    not allow cross-threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having implementation of async computation workflow inside of a function that
    has lazy evaluation is fine, but we should avoid mixing lazy evaluation with side
    effects based on the fifth point, as usually async may deal with async I/O operations.
    Therefore, the use of eager evaluation when dealing with side effects within async
    computation is recommended. This scenario is one of the subtle scenarios that
    is often not observed well or is badly ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always pay attention to side effects that may occur, even any subtle side effects
    such as having calls to Windows API invocation. Not just exception needs to be
    handled, but there are some dangers of thread blockings or even deadlock when
    side effect computation is in effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation inside a computation workflow or quotation has to be treated
    carefully. There is a possibility that lazy evaluation might decrease performance
    of certain computation workflows such as async, as async itself is a complex state
    machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any cancellation being handled during async computation that has lazy evaluation
    is fine, because a cancellation handles a side effect computation of the context
    switching of an asynchronous operation in a graceful manner as recommended by
    common pattern in .NET TPL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not perform synchronized lock within a lazy computation, as the execution
    context may behave unexpected side effects. A chance of deadlock may occur if
    the lazy computation contains a lock that locks a complex object. Lock is also
    not recommended within normal running F# code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These scenarios may not cover all of the cases of choosing evaluation strategy,
    but they are quite common in implementing functions that combine lazy and eager
    evaluations. Therefore, lazy evaluation is not a single bullet for all kinds of
    performance optimizations in the value evaluation strategy.
  prefs: []
  type: TYPE_NORMAL
- en: More detailed scenarios that may cause unexpected behavior or unexpected results
    when dealing with concurrency, are discussed in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#.*
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures are not just a crucial feature of any programming language,
    they play very important part in our codes, regardless whatever programming language
    we use. Understanding data structures in .NET are also the foundation of any programming
    language that runs on .NET CLR, including F# data structures.
  prefs: []
  type: TYPE_NORMAL
- en: We now not just have enough understanding of F# data structures, but we can
    leverage F# data structures by applying and combining with best practices. The
    best practices that we have covered in this chapter are not just best practices
    of using the existing F# data structures, but we also have best practices of optimizing
    the data structures.
  prefs: []
  type: TYPE_NORMAL
- en: This data structure optimization understanding can be brought into deeper understanding
    of concurrency in F# in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to concurrency in F#*.
  prefs: []
  type: TYPE_NORMAL
