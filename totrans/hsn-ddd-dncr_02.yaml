- en: Language and Context
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言与语境
- en: In the previous chapter, we discussed the importance of language briefly. In
    the software industry, we developed this naïve perception that the only languages
    that matter are programming languages. That's why we often speak complete gibberish
    and our colleagues from other departments, or our customers, have a hard time
    understanding what we're trying to say. This issue is mutual because many lines
    of business have developed their jargon, which other people might not completely
    understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要讨论了语言的重要性。在软件行业中，我们形成了这样的天真观念：只有编程语言才是重要的。这就是为什么我们经常说一些完全不知所云的话，而来自其他部门的同事或我们的客户很难理解我们试图表达的意思。这个问题是相互的，因为许多业务部门都发展了自己的行话，其他人可能不完全理解。
- en: In this chapter, we're going to go deeper into the importance of language and
    go through several examples of mockups and code. We'll also get into the concept
    of language in a context and introduce the Ubiquitous Language, one of the most
    critical aspects of **Domain-Driven Design** (**DDD**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨语言的重要性，并分析几个原型和代码的示例。我们还将探讨语言在特定环境中的概念，并介绍**领域驱动设计**（**DDD**）中最关键的部分之一：通用语言。
- en: 'In this chapter, we''ll go deeper into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨以下主题：
- en: Ubiquitous Language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用语言
- en: Why language is important
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么语言很重要
- en: Making implicit explicit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将隐含的变为显性的
- en: Language in context
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文中的语言
- en: Expressing behavior
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达行为
- en: Ubiquitous Language
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用语言
- en: It isn't a coincidence that the website of Eric Evans, the author of the original
    DDD book, is located at [http://domainlanguage.com](http://domainlanguage.com).
    Fundamental concepts of DDD, such as Ubiquitous Language and Bounded Context,
    are both based on the idea of language. It might sound strange to those who haven't
    spent many years developing software because, for less experienced developers,
    the only language that's important is a programming language. We learn to program
    usually by studying some concepts and applying them to practice using one of the
    programming languages. We think that we can translate a human language into a
    programming language, and this is the essence of our work. There's some degree
    of truth there indeed. However, this is by far not the essential part of the developer's
    daily routine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 埃里克·埃文斯的网站（他是原始DDD书籍的作者）位于[http://domainlanguage.com](http://domainlanguage.com)。DDD的基本概念，如通用语言和边界上下文，都是基于语言的理念。对于那些没有多年软件开发经验的人来说，这听起来可能有些奇怪，因为对于经验不足的开发者来说，唯一重要的语言是编程语言。我们通常通过学习一些概念并将它们应用于使用一种编程语言的实践中来学习编程。我们认为我们可以将人类语言翻译成编程语言，这是我们工作的本质。确实，这里有一些真理。然而，这远非开发者日常工作的本质部分。
- en: 'Two people can understand each other only if they can speak the same language.
    It doesn''t necessarily need to be verbal; it might very well be sign language
    or the language of music. But both interlocutors need to share the same understanding
    of this universal language. Otherwise, there will be trouble. Not only do they
    need to speak the same language, but this language must be in one context. There''s
    a whole book called *American and British English: Divided by a Common Language?*
    by Paul Baker, which describes how different the same language became after being
    split by the ocean for a long enough time.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当两个人能够使用同一种语言进行交流时，他们才能相互理解。这不一定需要是口头语言；它也可能是手语或音乐语言。但双方交流者必须共享对这种通用语言的相同理解。否则，就会出现问题。他们不仅需要说同一种语言，而且这种语言必须处于一个特定的语境中。有一本名为《美国和英国英语：被共同语言分隔？》的书，作者是保罗·贝克，书中描述了同一语言在经过足够长时间的海洋分隔后变得多么不同。
- en: In this section, we'll look deeper into the importance of language and the context
    in which these concepts are crucial for successful software projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨语言的重要性以及这些概念在成功软件项目中至关重要的语境。
- en: Domain language
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域语言
- en: Nearly every industry has developed a particular language that only people from
    that industry fully understand. Some of those words spread out to the world, like
    the automotive world, which enriched our language with terms such as gearbox,
    ignition, combustion engine, and even body shop. The last term is ambiguous when
    being looked at outside of the domain. But as soon as the domain is specified,
    it becomes clear that we don't mean a beauty product boutique, nor a software
    outsourcing company, but a place where car bodies are being repaired after accidents.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个行业都发展了一种只有该行业的人才能完全理解的语言。其中一些词汇已经传播到世界各地，比如汽车行业，它用术语如变速箱、点火、内燃机和甚至车身修理店丰富了我们的语言。最后一个术语在领域之外看时是模糊的。但一旦指定了领域，它就变得清晰了，我们不是指美容产品精品店，也不是指软件外包公司，而是一个在事故后对车身进行修理的地方。
- en: Of course, the automotive industry isn't unique in this sense. Other industries
    have developed their terms, and their language might be much less known and more
    cryptic for outsiders.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，汽车行业在这个意义上并不是独一无二的。其他行业也发展了自己的术语，并且它们的语言可能对外行人来说更为陌生和晦涩。
- en: 'One of the examples of such an industry is, of course, the software industry.
    When two programmers discuss implementation details of some reasonably complex
    systems, non-programmers around them don''t understand much of this conversation
    and usually get bored. Lack of understanding always results in a lack of interest:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的行业例子之一当然是软件行业。当两个程序员讨论一些相对复杂的系统的实现细节时，周围的非程序员对这次对话的理解很少，通常都会感到无聊。缺乏理解总是导致缺乏兴趣：
- en: '![](img/5486bbce-882b-4615-b491-8138cd1743d5.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5486bbce-882b-4615-b491-8138cd1743d5.png)'
- en: The world, as seen by a programmer (based on the original work by Manu Cornet)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员眼中的世界（基于Manu Cornet的原始作品）
- en: The software industry is, in a sense, unique because it tends to serve a variety
    of business problems within any other industry. Almost everything today requires
    or wishes for some degree of automation, and this means software. This also means
    that people from the business will come to their developers or external software
    companies and try to express their problems using their language. When this language
    isn't understood correctly, issues arise.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，软件行业是独特的，因为它倾向于为其他行业中的各种商业问题提供服务。今天几乎每件事都需要或希望有一定程度的自动化，这意味着软件。这也意味着来自商业领域的人会找到他们的开发者或外部软件公司，并试图用他们的语言表达他们的问题。当这种语言没有被正确理解时，问题就会出现。
- en: Functional requirements, written by dedicated professionals who are neither
    business people nor software developers, have been seen as the holy grail of successful
    software. Each time we reach an undesired outcome after the software is delivered
    to an unhappy customer, we blame requirements. We say—next time, we'll write better
    requirements and more detailed specifications and explain what developers need
    to do down to every single small detail. It can quickly become a blame game when
    everyone is pointing fingers to each other and no one is willing to be responsible
    for anything.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由既不是商业人士也不是软件开发者专门撰写的功能需求，曾经被视为成功软件的圣杯。每次软件交付给不满意的客户后，我们都会归咎于需求。我们说——下次，我们会写出更好的需求，更详细的规范，并解释开发者需要做到的每一个细节。当每个人都互相指责，没有人愿意承担责任时，这很快就会变成一场指责游戏。
- en: In addition to the points we were discussing in [Chapter 1](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml),
    *Why Domain-Driven Design? *(in the *What went wrong with requirements?* section),
    one additional aspect is worth mentioning here. It's the language. Requirements
    not only focus on the solution and hide problems, but requirements also tend to
    **translate** business language to more technical language, which is seen as **developer-friendly**.
    In reality, this works more like a broken telephone. The more levels of translation
    that are being added to the transmission line, the less relevant information reaches
    the receiver without being disturbed beyond recognition.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在[第一章](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml)中讨论的点，*为什么是领域驱动设计？*（在*需求出了什么问题？*部分），还有一个额外的方面值得在此提及。那就是语言。需求不仅关注解决方案并隐藏问题，而且需求还倾向于将商业语言翻译成更技术性的语言，这被视为**开发者友好**。实际上，这更像是一个断线电话。在传输线上添加的翻译层级越多，到达接收者的相关信息就越少，而且信息在传递过程中被严重干扰，以至于无法辨认。
- en: One more aspect of such a *translation* is that it slows down communication.
    If developers require more information from the business but are unable to understand
    what the business means when they speak, the involvement of translators becomes
    unavoidable. Usually, these are the same people that write requirements, but not
    always. I've heard enough examples when only people such as enterprise architects
    are allowed to talk to customers; then, they translate their understanding to
    business analysis, who then throw requirements over the wall to poor developers,
    which are then literally lost in translation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“翻译”的另一个方面是它减缓了沟通。如果开发者需要从业务中获得更多信息，但无法理解业务人士说话时的含义，那么翻译者的介入变得不可避免。通常，这些人就是编写需求的人，但并不总是如此。我听到过足够多的例子，只有像企业架构师这样的人才被允许与客户交谈；然后，他们将他们的理解翻译成业务分析，然后把这些需求扔给可怜的开发者，而这些需求在翻译过程中实际上已经丢失了。
- en: That's why understanding the business is significant for people who are working
    to create a good solution for real business problems. Being able to understand
    the business and communicate without a need for translations and translators not
    only shortens the communication time but also substantially improves the quality
    of such communication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，对于致力于为真实商业问题创造良好解决方案的人来说，理解业务非常重要。能够理解业务并且无需翻译和翻译者进行沟通不仅缩短了沟通时间，而且极大地提高了沟通质量。
- en: At the same time, we all know that business people, who usually play the customer
    role for the systems we create, are overall much less available as we would like
    them to be. You might end up having just a few session with people who actually
    possess the crucial information that you must obtain in order to make the system
    do what it should do. Sometimes they are even unwilling to take discussions with
    developers. It might be related to some personal issues, negative experience from
    the past or unconscious fear of looking silly in front of the bund of nerds.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们都知道，作为我们创建的系统客户的商业人士，他们通常比我们希望的要少得多可用。你可能会只有几次与真正掌握你必须获取以使系统按预期工作的重要信息的会议。有时他们甚至不愿意与开发者进行讨论。这可能与某些个人问题、过去的负面经历或无意识地害怕在众多技术宅面前显得愚蠢有关。
- en: In such cases, having a dedicated person, which is trusted by the business and
    speaks their language really helps. Our aim would be to ensure that this person
    is also trusted by the development team. You can call this role as a business
    analyst or a product owner, it doesn't really matter. The best people I know in
    this role are able to speak to everyone in their language, like the high-degree
    translators that work with world leaders behind their backs, being able to translate
    from one language to another without losing the meaning of things. At the same
    time, the best approach is still to avoid such a translation altogether.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有一个受业务信任并且能说他们语言的人是非常有帮助的。我们的目标是要确保这个人也受到开发团队的信任。你可以称这个角色为业务分析师或产品所有者，这并不重要。我所知道在这个角色中做得最好的人能够用他们的语言与所有人交谈，就像那些在幕后与世界领导人一起工作的顶级翻译者一样，能够将一种语言翻译成另一种语言而不丢失事物的含义。同时，最好的方法仍然是完全避免这种翻译。
- en: For example, London City bankers are notorious for hiring developers who have
    already been exposed to banking and have ideally worked in the City before. They
    value their time and want to shorten the time spent on communication and discussions.
    Therefore, someone who has exposure to their language and shows a decent level
    of understanding of their business and their language is valued higher than someone
    else who might be a better developer but needs to be trained and get to know the
    language before really starting to work on real-life tasks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，伦敦市银行家因雇佣那些已经接触过银行业并且理想情况下在伦敦市工作过的发展者而闻名。他们重视时间，希望缩短沟通和讨论所花费的时间。因此，那些了解他们的语言并且对他们的业务和语言有相当理解的人比那些可能更优秀但需要在开始实际工作前接受培训和了解语言的人更受重视。
- en: 'Jargon terms are usually hard to grasp for outsiders since words that are being
    used are often everyday use words, but have an entirely different meaning. Some
    examples from the aforementioned financial domain are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 行业术语通常对外行人来说很难理解，因为所使用的词汇通常是日常用语，但它们有着完全不同的含义。以下是一些来自上述金融领域的例子：
- en: '**Call**: Short for a **call** option*,* this is a demand for payment of lent
    or unpaid capital'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看涨期权**：简称**看涨期权**，这是对借出或未偿还资本支付的要求'
- en: '**Security**: To attest the credit, the right to property, or the ownership
    of stocks or bonds that are related to tradable derivatives, this certificate
    is used'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：为了证明信用、财产权或与可交易衍生品相关的股票或债券的所有权，此证书被使用'
- en: '**Swap**: Among two borrowers, if each of them gain access to the required
    funds or a fixed interest is changed to floating, it''s considered as swap'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**掉期**：在两个借款人之间，如果他们中的每一个都能获得所需的资金，或者固定利率被改为浮动利率，这被视为掉期'
- en: Learning the domain language is crucial to establish effective communication
    between domain experts and developers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 学习领域语言对于在领域专家和开发者之间建立有效的沟通至关重要。
- en: Sample application domain
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样例应用领域
- en: Throughout this book, we'll be developing a sample application to practice our
    gained knowledge and skills. In this section, you'll get an introduction to the
    business domain, and more details will be added later throughout this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将开发一个样例应用来练习我们获得的知识和技能。在本节中，你将了解业务领域，更多细节将在本书的后续部分添加。
- en: The domain that we're going to be working on is selling stuff online for private
    individuals. We'll be building an application to publish classified ads and something
    that might be necessary to support this type of activity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的领域是为个人在线销售物品。我们将构建一个发布分类广告的应用程序以及可能支持此类活动所需的一些东西。
- en: If you aren't familiar with the terminology, think about a bunch of stuff you
    have in your storage room or in the basement, which you would be delighted to
    remove. You can publish a small ad online, and other people might buy things that
    you no longer need. You can also give stuff away for free. Examples of such services
    are websites such as eBay, Craigslist, Gumtree, Marktplaats (the Netherlands),
    and FINN.no (Norway).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对术语不熟悉，想想你储藏室或地下室里的一堆东西，你可能会很高兴把它们清理掉。你可以在网上发布一个小广告，其他人可能会购买你不再需要的东西。你也可以免费赠送物品。这类服务的例子包括eBay、Craigslist、Gumtree、Marktplaats（荷兰）和FINN.no（挪威）等网站。
- en: Making implicit explicit
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将隐含的显式化
- en: When we start working on a new system, we need to learn a lot. We discussed
    the paradox of ignorance in [Chapter 1](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml), *Why
    Domain-Driven Design?*, and you might remember that the highest level of ignorance
    and thereby the lowest level of knowledge is when we make a lot of decisions about
    the future system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始开发一个新系统时，我们需要学习很多东西。我们在[第1章](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml)，“为什么是领域驱动设计？”中讨论了无知悖论，你可能还记得，无知程度最高、知识水平最低的时候是我们对未来的系统做出很多决策的时候。
- en: We not only suffer a lack of knowledge about the business domain we're trying
    to solve problems for—we're also forced to work in an environment with a high
    level of ambiguity. Before we learn about the domain language, we use our understanding,
    which is often based on assumptions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅缺乏对我们试图解决问题的业务领域的知识，我们还被迫在一个高度不确定的环境中工作。在我们学习领域语言之前，我们使用我们的理解，这通常基于假设。
- en: Imagine a situation where you come to a meeting with domain experts at the beginning
    of the project. They try to explain their problem, and you slowly begin to study
    their language and, at some point, you think you got the idea and more or less
    know what to do. Here, it's important to remember what we were going through in
    the previous chapter when we discussed cognitive biases and their influence on
    decision making. The first and the most obvious risk is that **what you see is
    all there is** (**WYSIATI**), or availability heuristics. You apply your limited
    knowledge to past experiences and then get the feeling of understanding. At this
    point, we're usually asked to make estimates and logically we fail, since biases
    play a trick on our minds and give the illusion of understanding.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在项目开始时，你与领域专家开会的情况。他们试图解释他们的问题，而你开始慢慢地学习他们的语言，在某个时刻，你认为你理解了这个想法，大致知道该怎么做。在这里，重要的是要记住我们在上一章讨论认知偏差及其对决策影响时所经历的情况。第一个也是最明显的风险是**你所看到的即是全部**（WYSIATI），或者说是可用性启发式。你将你有限的知识应用于过去的经验，然后产生理解的感觉。在这个时候，我们通常会被要求做出估计，从逻辑上讲，我们会失败，因为偏见在我们的脑海中玩弄了我们，并给了我们理解的错觉。
- en: At such meetings, we often agree on something. Then, everyone leaves the room
    to meet again and maybe discuss some specifications or even prototypes after a
    couple of weeks. Time passes by, we're still in the same room, and no one is pleased
    since, to our mutual dissatisfaction, we find out that we agreed on completely
    different things. Everyone had a picture in mind, and all those pictures were
    different.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的会议上，我们经常达成一致。然后，每个人都离开房间再次开会，可能几周后讨论一些规范或甚至原型。时间过去了，我们还在同一个房间里，没有人满意，因为我们共同的不满，我们发现我们达成了一致，但完全不同的事情。每个人都有一幅图，而这些图都是不同的。
- en: '![](img/da7b2f76-711c-4ca2-a43d-6e035e46b02e.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da7b2f76-711c-4ca2-a43d-6e035e46b02e.jpg)'
- en: We agree on different things if we don't visualize
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不可视化，我们就会就不同的事情达成一致
- en: People spend hours arguing about things they thought are different but are the
    same. People also agree on something that they don't share a common understanding
    about, and this never goes well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 人们花费数小时争论他们认为不同但实际上相同的事情。人们也会就他们没有共同理解的事情达成一致，这从来都不会顺利。
- en: To fix this, we need to remove assumptions. We need to make *implicit* things
    *explicit*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要去除假设。我们需要将*隐含*的东西*明确*出来。
- en: 'Look at this sample form from a real-life HR management system. Here, an employee
    can request sick leave:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个来自现实生活中的HR管理系统的样本表格。在这里，员工可以申请病假：
- en: '![](img/6ab13797-43ea-4757-af5b-b75123d1362b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ab13797-43ea-4757-af5b-b75123d1362b.png)'
- en: Sick leave registration form
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 病假登记表
- en: Here, we can see a typical structure, which is created by a programmer. We could
    even imagine a SQL table where the data that's entered into this form gets stored.
    It most probably has the `StartDate`, `EndDate`, and `HalfDay` columns and the
    employee `id`. Notice that there's a Save button here too, which is very common
    to find in forms like this.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到由程序员创建的典型结构。我们甚至可以想象一个SQL表，其中存储了输入到这个表格中的数据。它很可能有`StartDate`、`EndDate`和`HalfDay`列以及员工的`id`。注意，这里也有一个保存按钮，这在类似这样的表格中非常常见。
- en: 'But despite the fact that this form might look okay, let''s think a little
    bit more about what we see here. After spending a bit of time analyzing this form,
    we could see the following issues:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个表格看起来可能没问题，但让我们再稍微思考一下我们在这里看到的东西。在花了一些时间分析这个表格之后，我们可以看到以下问题：
- en: The Start date is ambiguous. It might be the date when sick leave is registered,
    or it might also be the date when the employee didn't come to work because they
    got sick.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始日期是不明确的。它可能是登记病假的日子，也可能是员工因为生病而没有上班的那天。
- en: The End date is even more ambiguous because it might represent the last day
    of the sick leave, or the day when the employee came back to work.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束日期甚至更加不明确，因为它可能代表病假的最后一天，也可能是员工回来上班的那天。
- en: The Half day might apply to both of those fields, but there's no clear indication
    of what it means.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半天可能适用于这两个领域，但没有明确的说明它意味着什么。
- en: Finally, the Save button gives us no clue about what will happen next. There
    might be just a record in a table, and we need to tell someone to look at it,
    or there might be an approval process that gets started automatically. Does the
    employee need to call or send an email to the line manager after filling out this
    form?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，保存按钮没有给我们任何关于接下来会发生什么的线索。可能只是在表中记录了一条记录，我们需要告诉某人查看它，或者可能有一个自动启动的审批流程。填写完这个表格后，员工需要打电话或发送电子邮件给直线经理吗？
- en: As you can see, even in such a small form with two fields, one checkbox, and
    two buttons, many things are implicit. If we imagine the code behind this form,
    all those implicit and ambiguous concepts could be found there as well. I already
    mentioned a table that has columns that represent those fields in the form. All
    properties in the domain model classes, data model objects, and other code artifacts
    are equally implicit. Everything there demands an explanation, such as *this date
    means the day when an employee came back to work*, and without such an explanation.
    Things like reports could be just plain wrong.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，即使在这样一个只有两个字段、一个复选框和两个按钮的小表格中，也有很多隐含的东西。如果我们想象一下这个表格背后的代码，所有那些隐含和模糊的概念也都会在那里被发现。我已经提到了一个表格，它有代表表格中那些字段的列。在领域模型类、数据模型对象和其他代码工件中的所有属性都是同样隐含的。那里的一切都需要解释，比如 *这个日期意味着员工回来上班的那一天*，如果没有这样的解释，像报告这样的东西可能会完全错误。
- en: 'Compare it with another example, also taken from a real-life HR management
    system, which was made by a competitor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将它与另一个例子进行比较，这个例子也来自现实生活中的HR管理系统，由一个竞争对手制作：
- en: '![](img/8dfa5910-680a-4721-a05f-101c827b3ffa.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8dfa5910-680a-4721-a05f-101c827b3ffa.png)'
- en: The sick leave registration form that makes sense
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那个有意义的病假登记表
- en: 'In this form, the fields make much more sense for regular people who don''t
    need to solve puzzles or read the help to understand what to enter in these fields.
    Things that were made *implicit* in the first sample are *explicit* here. Everything,
    from naming individual fields to calls for actions, has a better meaning. We could
    also imagine that, behind this form, we can find code like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格中，对于不需要解决谜题或阅读帮助来理解这些字段应输入什么内容的普通人来说，字段的意义更加明确。在第一个示例中是隐含的，在这里则是显式的。从命名单个字段到行动呼吁，每一项都有更好的意义。我们也可以想象，在这个表格背后，我们可以找到如下代码：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code expresses the same meaning and terminology as the user interface.
    So, not only will the end user have an easy time filling out this form, but also
    a fellow developer would be happy reading this code, where the intent is clearly
    expressed and all the concepts are explicit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表达了与用户界面相同的含义和术语。因此，不仅最终用户填写这个表格会很容易，而且其他开发者也会很高兴阅读这段代码，因为意图表达得非常清楚，所有概念都是显式的。
- en: Another aspect of making implicit explicit is to create domain concepts that
    are visible in the code. In the preceding code, the `SendSickLeaveForApproval`
    command exhibits a precise domain concept in the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将隐含的变为显性的另一个方面是创建在代码中可见的领域概念。在前面的代码中，`SendSickLeaveForApproval`命令在代码中展示了精确的领域概念。
- en: Domain language for classified ads
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类广告的领域语言
- en: Our developers were discussing the flow of publishing classified ads. They went
    through the creation process and got to the point where the user clicks the Publish
    button. Together, with the domain expert, they discovered that ads couldn't be
    published immediately since an ad could contain malicious content. They decided
    to put in some approval process, which should take place after the user clicks Publish
    and the ad becomes visible on the website.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发者在讨论发布分类广告的流程。他们经历了创建过程，并到达用户点击“发布”按钮的点。与领域专家一起，他们发现广告不能立即发布，因为广告可能包含恶意内容。他们决定添加一个审批流程，这个流程应该在用户点击“发布”并且广告在网站上可见之后进行。
- en: 'Developers quickly decided to create a property for their `ClassifiedAd` domain
    class, called `Status`. It should be an enum, which indicates different stages
    of the review and publication process. It could also be reused later for statuses
    that aren''t yet known. Since they want to have behavior in their domain model,
    they added the `UpdateStatus` method to the class, which looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者迅速决定为他们的领域类`ClassifiedAd`创建一个名为`Status`的属性。它应该是一个枚举类型，表示审查和发布过程的各个阶段。它也可以在以后用于尚未知的其他状态。由于他们希望在领域模型中拥有行为，所以他们向类中添加了`UpdateStatus`方法，其代码如下：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that the method also publishes a domain event, other parts of the system
    can subscribe to this event and do some other vital actions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个方法也发布了一个领域事件，系统的其他部分可以订阅这个事件并执行一些其他重要的操作。
- en: We will spend more time with domain events and commands later in this book.
    For now, the sample code uses domain events in the code to closely resemble events
    and commands we were using in the EventStorming chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分花更多的时间讨论领域事件和命令。目前，示例代码使用领域事件在代码中紧密地模拟我们在事件风暴章节中使用的事件和命令。
- en: 'So, after the user clicks Publish, the following would happen:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在用户点击“发布”后，以下情况会发生：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the review is complete, the ad would be activated, like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 审查完成后，广告将被激活，如下所示：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It might seem acceptable. Our `ClassifiedAd` class is a state machine, where
    instances of this class move from one status to another through the life cycle
    of the ad. However, we already miss the intent. Our language becomes weird—instead
    of saying that we want to *publish* the announcement, we *update the status*.
    Instead of *activating* the ad, we *update the status* again!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是可以接受的。我们的`ClassifiedAd`类是一个状态机，这个类的实例在广告的生命周期中从一个状态移动到另一个状态。然而，我们已经失去了意图。我们的语言变得奇怪——我们不是说要*发布*公告，而是*更新状态*。我们不是*激活*广告，而是再次*更新状态*！
- en: 'Even if it all seems to work after some more behavior is added to the system,
    code like this will start to appear:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在系统添加更多行为之后一切似乎都正常工作，这样的代码也将开始出现：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That isn''t the code we expect to see in such a simple method. It takes too
    much responsibility, and the logical blocks in this method barely relate to each
    other. But things get worse when it gets to the domain event handling:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们期望在这样一个简单方法中看到的代码。它承担了太多的责任，而这个方法中的逻辑块几乎相互之间没有关联。但当涉及到领域事件处理时，情况变得更糟：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The number of flow control operators is growing, and most of the behavior is
    now being driven by status updates, something that, in the beginning, was considered
    to be a small and concise operation on a single property of the domain object.
    The intent of this update operation is dissolved, and each call needs to be carefully
    controlled for side effects. The risk of damaging an existing behavior when adding
    new features is now genuine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制操作符的数量正在增加，现在大部分行为都是由状态更新驱动的，最初这被认为是对领域对象单个属性进行的小而简洁的操作。这个更新操作的意图已经消失，每次调用都需要仔细控制副作用。在添加新功能时，损害现有行为的风险现在是真实的。
- en: Discussions with domain experts also lost some meaning. Instead of using phrases
    such as *if the malicious content is detected, we hide the ad and inform our moderation
    group*, it becomes *and then we query all ads with the status equals* `MaliciousContentDetected`
    *and use the notification service to deliver a message to all users that have
    moderation rights*. The meaning of the language gets lost behind technical gibberish,
    mixed with generalized words such as **status** and **message**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与领域专家的讨论也失去了一些意义。不再是使用诸如“如果检测到恶意内容，我们隐藏广告并通知我们的审核小组”这样的短语，而是变成了“然后我们查询所有状态等于`MaliciousContentDetected`的广告，并使用通知服务向所有拥有审核权限的用户发送消息”。语言的含义在技术术语的混乱中丢失，混合了诸如**状态**和**消息**这样的通用词汇。
- en: 'The team decides to refactor the code and use proper domain language instead.
    So, this is what they came up with:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 团队决定重构代码，并使用适当的领域语言。因此，这是他们提出的方案：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can also refactor the domain event handling to something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以将领域事件处理重构为如下所示：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, to handle cases with malicious content, we can write the new event handler:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了处理包含恶意内容的情况，我们可以编写新的事件处理器：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our small example also shows that the domain language can't be built by making
    a glossary with nouns. A misconception about collecting a lot of nouns in an extensive
    list and calling it a domain language definitely exists. But this isn't a happy
    path, and usually, it leads to something called an anemic model, which is considered
    an anti-pattern. Classes in anemic models only have properties, and properties
    are always named by nouns. But a no less important part of every domain is the
    behavior. Nouns express what the domain operates with, but verbs describe what's
    being done. Without verbs, our domain tends to be a set of magic actions when
    properties change values without any particular reason. But our preceding code
    clearly expresses the domain behavior by introducing verbs as part of the domain
    language. These verbs are precise, show the intent, and describe actions. They're
    used both in imperative style for activities and in the past tense when describing
    the history when we publish domain events from our code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的小例子也表明，领域语言不能仅仅通过制作一个名词列表的词汇表来构建。关于收集大量名词并称之为领域语言的误解确实存在。但这并不是一条幸福的路径，通常它会导致所谓的贫血模型，这被认为是一种反模式。贫血模型中的类只有属性，属性总是用名词命名。但每个领域的一个重要部分是行为。名词表达领域操作的内容，但动词描述正在执行的动作。没有动词，我们的领域在属性值改变时往往变成了一组没有特定原因的魔法动作。但我们的前述代码通过引入动词作为领域语言的一部分，清楚地表达了领域行为。这些动词是精确的，显示了意图，并描述了动作。它们既用于命令式风格的活动中，也用于描述我们发布领域事件时的历史，使用过去时。 '
- en: In the preceding example, we not only improve our code and brought a better
    understanding of what it does and what concepts are being present there, but we
    also discovered some new terms and concepts that our domain model would benefit
    from. We can start using this terminology when talking to domain experts and see
    whether they understand it. Sometimes, they might give developers strange looks,
    trying to understand their excitement because they knew this *new* concept already—its
    part of *their language*, and it was just never expressed in conversations between
    business and development people. Such breakthroughs not only make the code better
    and closer to the actual business model but also improve communication between
    developers and domain experts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不仅改进了代码，并更好地理解了它的功能和其中存在哪些概念，而且还发现了我们的领域模型将从中受益的一些新术语和概念。我们可以开始在与领域专家交谈时使用这些术语，看看他们是否理解。有时，他们可能会对开发者投来奇怪的目光，试图理解他们的兴奋，因为他们已经知道这个**新**概念了——它是他们**语言**的一部分，只是从未在业务和开发人员之间的对话中表达过。这样的突破不仅使代码更好，更接近实际的商业模型，而且也改善了开发者和领域专家之间的沟通。
- en: By making implicit things explicit, not only do we discover missing concepts
    in our code, but we also put them into our domain model. This part is essential
    because the language is used across the whole range of models—business and mental
    models, conceptual and visual models, and domain models in diagrams and code.
    This pattern of using the same concept and, in general, the same language across
    multiple levels of models in the system is called **Ubiquitous Language**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将隐含的事物明确化，我们不仅发现了代码中缺失的概念，而且还将它们纳入我们的领域模型中。这部分是至关重要的，因为这种语言被用于整个模型范围——商业和心智模型、概念和视觉模型，以及图表和代码中的领域模型。在系统的多个模型级别上使用相同的概念和，一般来说，相同的语言的模式被称为**通用语言**。
- en: Language and context
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言与语境
- en: In the introduction of this chapter, we already touched on the topic of linguistic
    differences in the same language. If one language is divided by some boundary,
    be it a geographical, national, or professional area, it starts to split. We used
    British and American English as an example before, but of course, there are more
    examples like this. Dutch language spoken in Belgium is often even referred to
    as a separate language, Flemish because it sounds different, but mainly because,
    for everyday objects and actions, different words are being used. The same can
    be observed for languages that evolve within professional groups where people
    develop jargon, and we've looked at some examples of this too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的引言中，我们已经提到了同一语言中的语言差异问题。如果一种语言被某种边界所分割，无论是地理的、国家的还是专业的，它就开始分裂。我们之前以英国英语和美国英语为例，但当然还有更多类似的例子。在比利时使用的荷兰语甚至经常被称作一种单独的语言，弗拉芒语，因为它听起来不同，但主要是因为在日常物体和动作中，使用了不同的词汇。同样的情况也适用于在专业群体中发展的语言，其中人们形成了行话，我们也已经看到了一些这样的例子。
- en: These examples were presented here to demonstrate how important it is to define
    the precise meaning of words. Avoiding confusion is indeed one of the goals in
    order to find and identify Ubiquitous Language.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子被提出是为了说明定义词语的精确含义是多么重要。避免混淆确实是找到和识别通用语言的目标之一。
- en: It's important to realize that Ubiquitous Language is only valid within a context.
    A different context is defined by a different language. There's a misconception
    that Ubiquitous Language is called *ubiquitous* because it's the single language
    for the whole business, organization, or domain. That isn't the case. It's ubiquitous
    not horizontally, but vertically. Each context might have its own language, but
    all layers in this context share one Ubiquitous Language—meetings with the business,
    models, code, tests, UI concepts, data structures, and so on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到通用语言仅在特定语境内有效。不同的语境由不同的语言定义。有一种误解认为通用语言被称为**通用**是因为它是整个商业、组织或领域的单一语言。事实并非如此。它不是在水平方向上通用，而是在垂直方向上通用。每个语境可能都有自己的语言，但在这个语境中的所有层级都共享一种通用语言——与业务、模型、代码、测试、UI概念、数据结构等的会议。
- en: 'Let''s have a look at the classic example of the term **Product** being used
    in different contexts of the e-commerce domain:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个经典的例子，即术语**产品**在电子商务领域的不同语境中的应用：
- en: '![](img/e5a1c911-2b91-4b71-803c-17884a3d0a61.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a1c911-2b91-4b71-803c-17884a3d0a61.png)'
- en: Product in different contexts
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不同语境中的产品
- en: 'Although we''re operating in the same domain, clearly the term **Product**
    has a somewhat different meaning in each of the identified contexts:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在同一领域运营，但很明显，**产品**这个术语在每个已识别的上下文中的含义都有所不同：
- en: '**Sales**: For the salespeople, product means the sales price and maybe the
    margin. It''s where the company earns money, and other properties of the product
    aren''t that important.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销售**：对于销售人员来说，产品意味着销售价格和可能的利润。这是公司赚钱的地方，产品的其他属性并不那么重要。'
- en: '**Purchasing**: If we buy a product to resell, we''re mostly interested in
    the purchase price, how many items of a given product the supplier has in stock,
    and how fast they can be delivered.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采购**：如果我们购买产品进行转售，我们主要关注的是购买价格，供应商有多少库存的特定产品，以及他们能多快交付。'
- en: '**Inventory**: We''re mainly interested in how many items we have in stock.
    If a specific item is out of stock, this context can keep the estimated date when
    it will be back in stock. Here, we probably also define some internal properties
    of the product, such as the item number.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库存**：我们主要关注的是我们有多少库存商品。如果某个特定商品缺货，这个上下文可以保持估计的补货日期。在这里，我们可能还会定义一些产品的内部属性，例如商品编号。'
- en: '**Warehouse**: It needs to manage the space that''s required to store products,
    so people in this context need to know when product batches arrive when shipments
    to customers take place, how products are packaged, and where they are stored.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：它需要管理存储产品所需的空间，因此在这个上下文中的人需要知道产品批次何时到达，客户发货何时进行，产品如何包装，以及它们存储在哪里。'
- en: As you can see, although we have a popular term, such as **Product**, different
    departments in the same domain or organization really have very little shared
    interest and have more in-depth knowledge in their subset of properties of something
    that otherwise could be considered the same object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管我们有一个流行的术语，比如**产品**，但同一领域或组织中的不同部门实际上很少有共同兴趣，并且对某物（否则可能被视为同一对象）的属性子集有更深入的了解。
- en: Another good example would be the term **policy** in the insurance domain. It's
    a bit less well-known for people that don't work in insurance but, in general,
    we understand that people that sell insurance to us are mostly interested in money
    and in getting new customers. So, for them, the policy means new sales and money. When
    it comes to approvals, if we take vehicle insurance as an example, policy implies
    risk. Even after a policy is sold, there's a chance that the risk assessment department
    could request additional documentation and, after some internal checks, reject
    the policy. And finally, when it comes to the point of handling a claim on the
    existing policy, for the claim handling department, it's a cost since the insurance
    company loses money.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的例子是保险领域的术语**政策**。对于不在保险行业工作的人来说，它可能不太为人所知，但一般来说，我们理解卖给我们保险的人主要对金钱和获取新客户感兴趣。因此，对他们来说，**政策**意味着新的销售和金钱。当涉及到审批时，如果我们以车辆保险为例，政策意味着风险。即使政策已经售出，风险评估部门仍有可能要求额外的文件，并在一些内部检查后拒绝该政策。最后，当涉及到处理现有政策的索赔时，对于索赔处理部门来说，它是一个**成本**，因为保险公司会损失金钱。
- en: Both examples demonstrate that, even for the same domain, there's a different
    context where language changes and sometimes changes significantly. What happens
    if we keep using the same meaning of words across contexts? Well, things become
    much less explicit. The degree of ambiguity increases with each new context that
    we fail to identify and separate. It leads to unclear models and, as a result,
    to obscure code, where we need to clarify what we mean exactly when we use this
    and that word.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子都表明，即使在同一领域，语言也会在不同的上下文中发生变化，有时变化还相当显著。如果我们继续在上下文中使用相同的词义，会发生什么？嗯，事情会变得不那么明确。随着我们未能识别和区分的新上下文的增加，歧义程度也在增加。这导致模型不明确，结果就是代码晦涩难懂，我们需要在用这个词或那个词时明确我们到底想表达什么。
- en: 'Mixing different contexts in one working environment also leads to something
    called **context switching**. In *Quality Software Management: Systems Thinking*, Gerald
    Weinberg suggested that an increasing number of projects that one individual works
    on leads to significant productivity loss due to context switching:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个工作环境中混合不同的上下文也会导致所谓的**上下文切换**。在《质量软件管理：系统思维》一书中，Gerald Weinberg 指出，一个人负责的项目数量越来越多会导致由于上下文切换而造成的显著生产力损失：
- en: '![](img/fd0a33da-1a7f-4740-8a6f-308456ec8392.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd0a33da-1a7f-4740-8a6f-308456ec8392.png)'
- en: Productivity loss due to context switching
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上下文切换造成的生产力损失
- en: Adding one more project to current tasks means 20% productivity loss. Hence,
    when the number of contexts reaches five, the amount of time spent on the actual
    work becomes tremendously low. Most of the time is then spent figuring out in
    which context the current task belongs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前任务中添加一个新项目意味着20%的生产力损失。因此，当上下文数量达到五个时，实际工作花费的时间变得极其低。大多数时间都花在试图弄清楚当前任务属于哪个上下文中。
- en: It's not only valid for the project. You might know from experience that, for
    larger projects where generalization prevails over precision and unambiguity,
    the phenomena of context switching effects the performance just as much. In our
    **product** example, if we were to put all of the properties of different logical
    views of the product in one place, working with such an object would involve some
    additional effort of trying to understand which part of the product we're working
    on at the moment. So, despite this still being one thing, the hidden context switching
    and productivity will suffer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于项目。你可能从经验中知道，对于泛化胜过精确性和明确性的大型项目，上下文切换现象对性能的影响同样巨大。在我们的**产品**示例中，如果我们把产品不同逻辑视图的所有属性都放在一个地方，那么处理这样一个对象将涉及一些额外的努力，试图理解我们目前正在处理产品的哪个部分。因此，尽管这仍然是一件事，但隐藏的上下文切换和生产率会受到影响。
- en: Assuming that centralization and generalization are good things, many software
    systems create so-called God classes, such as `Customer` or `Product`, which contain
    all possible properties for all possible views of a physical object. In addition
    to context switching, there are more downsides to such an approach.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设集中化和泛化是好事，许多软件系统创建了所谓的神级类，例如`Customer`或`Product`，这些类包含了所有可能的属性，以适应物理对象的所有可能视图。除了上下文切换之外，这种方法的缺点还有很多。
- en: One is obviously that not all properties need to have value during a specific
    life cycle of such an object in the system. For example, the phased-out product
    has no features that are related to sales whatsoever. But since we have one class
    for everything, we must assign empty values to all of these properties. Such an
    approach leads to a high degree of confusion since we hardly understand why these
    properties are vacant—either there's a mistake in the system, or this is just
    a typical situation due to the object's state.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个明显的问题是，在系统中的这样一个对象的生命周期中，并非所有属性都需要有值。例如，已经淘汰的产品没有任何与销售相关的特性。但由于我们有一个包含所有内容的类，我们必须为所有这些属性分配空值。这种做法导致高度混乱，因为我们几乎不明白为什么这些属性是空的——要么是系统中的错误，要么这只是由于对象状态而出现的典型情况。
- en: Another issue is that, inevitably, such classes attract a lot of dependencies.
    You've probably seen data models, which sometimes mimic **domain models**, where
    the whole complex system has one large SQL database where tables have many cross-references.
    We could imagine that things such as `Product` can be referenced by `Order`*,*
    `ShoppingCart`*,* `Catalogue`*,* `Invoice`*,* `PurchaseInvoice`*,* `Return`, `CreditNote`,
    and so on. The model becomes tangled and very hard to maintain. Sometimes, it
    gets worse because referential dependencies are sometimes plain wrong. For example,
    it isn't correct to show an updated product description on some order from the
    past. The order should contain a snapshot of the purchased product as it was at
    the moment of purchase.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是不容忽视的，这样的类会吸引大量的依赖。你可能见过数据模型，有时它们模仿**领域模型**，整个复杂系统有一个大型的SQL数据库，其中表有很多交叉引用。我们可以想象，像`Product`这样的东西可以被`Order`、`ShoppingCart`、`Catalogue`、`Invoice`、`PurchaseInvoice`、`Return`、`CreditNote`等引用。模型变得错综复杂，难以维护。有时，情况变得更糟，因为引用依赖有时是明显错误的。例如，在某个过去的订单上显示更新的产品描述是不正确的。订单应该包含购买产品时的快照。
- en: We've identified enough reasons for us to be cautious when it comes to forgetting
    about context when seeking language. Ubiquitous Language is always unambiguous,
    explicit, and context-specific. As soon as you sense or observe that the meanings
    of words start to change between different parts of the system, this should trigger
    an alarm in your head that you are probably crossing context boundaries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了足够的原因，让我们在寻求语言时对忘记上下文保持谨慎。通用语言总是明确、具体和上下文相关的。一旦你感觉到或观察到单词在不同系统部分之间的含义开始变化，这应该在你脑海中触发一个警报，表明你可能正在跨越上下文边界。
- en: '**Context emerges when discussing users**. Developers love to think of people
    as users. This term is so ambiguous that it''s almost guaranteed that we switch
    between different contexts when talking about users.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**在讨论用户时，上下文出现**。开发者喜欢将人们视为用户。这个术语如此含糊，几乎可以保证我们在谈论用户时会切换到不同的上下文。'
- en: 'Getting back to our sample domain, the team developers discussed how their
    users would rate their deals. They thought that it could be useful if people could
    give a rating to each other, helping to build trust in the community. During the
    conversation, some of them noticed that they use the words *user*, *those who
    sell*, *seller*, *those who buy*, and *buyer* interchangeably. When the generic
    term *user* was used, it almost always required clarification: what role this
    user plays at that particular moment. At the same time, when they named their
    users as *buyers* and *sellers*, there was no ambiguity, and no further clarification
    was required.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例领域，团队成员讨论了他们的用户会如何评价他们的交易。他们认为，如果人们可以互相给出评价，这将有助于建立社区信任。在对话中，他们中的一些人注意到他们交替使用 *用户*、*卖家*、*销售者*、*买家*
    和 *购买者* 这些词。当使用通用术语 *用户* 时，几乎总是需要澄清：这个用户在那个特定时刻扮演什么角色。同时，当他们将用户命名为 *买家* 和 *卖家*
    时，没有模糊性，也不需要进一步的澄清。
- en: After noticing this, the group decided that they discovered new elements of
    Ubiquitous Language and started to use these terms. It was a good insight that
    saved them a lot of time when they discussed models and removed ambiguity in code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这一点后，该小组决定他们发现了普遍语言的新元素，并开始使用这些术语。这是一个很好的洞察力，在讨论模型和消除代码中的模糊性时，为他们节省了大量时间。
- en: At the same time, splitting people into *sellers* and *buyers* in the authorization
    part of the system made no sense at all. These were just *users*, and they can
    log in to the system and do some operations, such as update their profile, without
    any clear distinction of whether they're going to sell or buy on the site. It was
    another context when the word *user* wasn't ambiguous and was explicit.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在系统的授权部分将人们分为 *卖家* 和 *买家* 完全没有意义。这些人只是 *用户*，他们可以登录系统并执行一些操作，例如更新他们的个人资料，而无需明确区分他们是否会在网站上买卖。这是另一个当 *用户*
    这个词没有歧义且明确的情况下。
- en: Later, they discovered another distinction for users when they modeled the back
    office system. There, users started to take roles, and again ambiguity was there
    until they identified these roles and began to use terms such as *administrator*, *support
    assistant*, and *reviewer*. A new context was discovered, and a new model emerged
    for that context, which was separated from other contexts by the meanings of words.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，当他们为后台系统建模时，发现了用户之间的另一个区别。在那里，用户开始承担角色，再次出现了模糊性，直到他们确定了这些角色并开始使用诸如 *管理员*、*支持助理*
    和 *审阅者* 等术语。发现了一个新的上下文，并为该上下文出现了一个新的模型，这个模型通过词语的意义与其他上下文区分开来。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the importance of language in system design and
    how precise and unambiguous terminology brings clarity. We also have a shared
    understanding of the domain for business people and developers. We also looked
    at how different industries use the same words to express different concepts and
    what consequences this has on domain modeling.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了语言在系统设计中的重要性以及精确和无歧义术语如何带来清晰性。我们还就业务人员和开发人员对领域有共同的理解进行了探讨。我们还研究了不同行业如何使用相同的词语来表达不同的概念，以及这对领域建模有什么影响。
- en: The code sample in this chapter showed how unclear language could make the implementation
    more complicated and less understandable. By introducing better language to the
    code, we made it much clearer and shorter and more concise. We made some implicit
    concepts more explicit, and it helped to get a better understanding of the business
    and improved the code quality. We also discovered many verbs that became part
    of the language, which is an essential addition to a glossary of nouns that are
    often seen as the only important part of the domain model.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例展示了不清晰的语言如何使实现变得更加复杂和难以理解。通过将更好的语言引入代码，我们使其更加清晰、简短和简洁。我们将一些隐含的概念变得更加明确，这有助于更好地理解业务并提高代码质量。我们还发现了许多成为语言一部分的动词，这对于名词的词汇表是一个重要的补充，而名词通常被视为领域模型唯一重要的部分。
- en: This chapter introduced the term *Ubiquitous Language*, which was coined by
    Eric Evans. We emphasize the fact that the ubiquity of the language isn't in its
    wideness but in its precision, and the fact that it's being used for all artifacts
    of the software development process—from initial discussions, through modeling
    and design, to code and tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了由埃里克·埃文斯提出的术语*通用语言*。我们强调，语言的通用性不在于其广泛性，而在于其精确性，以及它被用于软件开发过程的全部工件——从最初的讨论，经过建模和设计，到代码和测试。
- en: We looked at how words change their meaning between different contexts and how
    context switching can negatively impact productivity. Using our sample domain,
    we went through a couple of examples of how contexts are being discovered during
    the modeling process and in conversations between developers and domain experts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了词语在不同语境中如何改变其含义，以及语境切换如何对生产力产生负面影响。使用我们的样本领域，我们回顾了在建模过程中以及开发者和领域专家之间的对话中，如何发现语境的几个例子。
- en: In the next chapter, we'll explore one of the most popular techniques for domain
    modeling and go through some practical tips on how to organize useful workshops
    between domain experts and developers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨领域建模中最受欢迎的技术之一，并介绍一些在领域专家和开发者之间组织有用研讨会时的实用技巧。
