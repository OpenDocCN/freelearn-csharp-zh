["```cs\nnamespace FSharp.IO.DesignTime \n\n#nowarn \"0025\" \n\nopen System.Reflection \nopen System.IO \nopen Microsoft.FSharp.Core.CompilerServices \nopen ProviderImplementation.ProvidedTypes \n\n[<TypeProvider>] \ntype public KeyStringProvider(config : TypeProviderConfig) as this =  \n    inherit TypeProviderForNamespaces() \n\n    let nameSpace = \"FSharp.IO\" \n    let assembly = Assembly.LoadFrom(config.RuntimeAssembly) \n    let providerType = ProvidedTypeDefinition(assembly, nameSpace,\n        \"SecretKey\", baseType = None, HideObjectMethods = true) \n\n    do \n        providerType.DefineStaticParameters( \n            parameters = [ ProvidedStaticParameter(\"Path\", \n                typeof<string>) ], \n            instantiationFunction = fun typeName [| :? string as path \n              |] -> \n                let t = ProvidedTypeDefinition(assembly, nameSpace,\n                  typeName, baseType = Some typeof<obj>,\n                  HideObjectMethods = true) \n                let fullPath = if Path.IsPathRooted(path) then path  \n                  else Path.Combine(config.ResolutionFolder, path) \n                let content = File.ReadAllText(fullPath) \n                t.AddMember <| ProvidedLiteralField(\"Key\",\n                    typeof<string>, content)\n                t\n            ) \n\n        this.AddNamespace(nameSpace, [ providerType ]) \n\n[<assembly:TypeProviderAssembly()>] \ndo() \n\n```", "```cs\n#r @\"C:\\code\\packtbook\\KeyTypeProvider\\bin\\Debug\\KeyTypeProvider.dll\" \nopen FSharp.IO \nopen System \n\ntype Vault = SecretKey< @\".\\Secret.txt\"> \n\nlet unlock = function \n| Vault.Key -> true \n| _ -> false \n\nwhile Console.ReadLine() |> unlock |> not do \n    printfn \"Go away, Hacker!\" \n\nprintfn \"Please proceed, Master!\" \n\n```", "```cs\nasync { expression } \n\n```", "```cs\n[ for i in 91..100 -> async { return i * i }] // Async<int> list \n|> Async.Parallel // Async<int []> \n|> Async.RunSynchronously // int []  \n\n```", "```cs\nval it : int [] = \n  [|8281; 8464; 8649; 8836; 9025; 9216; 9409; 9604; 9801;\n    10000|] \n\n```", "```cs\n[for i in 91..100 -> i * i] \n\n```", "```cs\nCREATE DATABASE demo --(1) \nGO \n\nUse demo  \nGO  \n\nSET ANSI_NULLS ON \nGO \n\nSET QUOTED_IDENTIFIER ON \nGO \n\nCREATE PROCEDURE dbo.MockQuery --(2) \nAS \nBEGIN \n  SET NOCOUNT ON; \n  WAITFOR DELAY '00:00:01' \n  SELECT 1 \nEND \nGO \n\n```", "```cs\n#I __SOURCE_DIRECTORY__ \n#r @\"../packages/FSharp.Data.SqlClient.1.8.1/lib/net40/FSharp.Data.SqlClient.dll\" \nopen FSharp.Data \nopen System.Diagnostics \n\n[<Literal>] \nlet connStr = @\"Data Source=(localdb)\\ProjectsV12;Initial Catalog=demo;Integrated Security=True\" \n\ntype Mock = SqlCommandProvider<\"exec MockQuery\", connStr> \n\nlet querySync nReq = \n    use cmd = new Mock() \n    seq { \n        for i in 1..nReq do \n            yield (cmd.Execute() |> Seq.head) \n        } |> Seq.sum \n\nlet query _ = \n    use cmd = new Mock() \n    async { \n        let! resp = cmd.AsyncExecute() \n        return (resp |> Seq.head) \n    } \n\nlet queryAsync nReq = \n    [| for i in 1..nReq -> i |] \n    |> Array.map query \n    |> Async.Parallel \n    |> Async.RunSynchronously \n    |> Array.sum \n\nlet timing header f args = \n    let watch = Stopwatch.StartNew() \n    f args |> printfn \"%s %s %d\" header \"result =\" \n    let elapsed = watch.ElapsedMilliseconds \n    watch.Stop() \n    printfn \"%s: %d %s %d %s\" header elapsed \"ms. for\" args       \"requests\" \n\n```", "```cs\n#I __SOURCE_DIRECTORY__ \n#r \"../packages/FSharp.Control.Reactive.3.4.1/lib/net45/FSharp.Control.Reactive.dll\" \n#r \"../packages/Rx-Core.2.2.5/lib/net45/System.Reactive.Core.dll\" \n#r \"../packages/Rx-Interfaces.2.2.5/lib/net45/System.Reactive.Interfaces.dll\" \n#r \"../packages/Rx-Linq.2.2.5/lib/net45/System.Reactive.Linq.dll\" \n\nopen System.Reactive.Subjects \n\ntype PaymentFlowEvent = \n| HeartBeat \n| ACHOrigination \n| GuardOn \n\ntype GuardACHOrigination(flow: Subject<PaymentFlowEvent>, alerter: Subject<string>) = \n    let threshold = 3 \n    let mutable beats = 0 \n    let mutable guardOn = false \n\n    member x.Guard() = \n        beats <- 0 \n        guardOn <- false \n        flow.Subscribe(function \n            | HeartBeat -> if guardOn then beats <- beats + 1; \n                printfn \"Heartbeat processed\"; \n                if beats > threshold && guardOn\n                    then alerter.OnNext \"No timely ACHOrigination\" \n            | ACHOrigination -> beats <- 0; \n                guardOn <- false \n                printfn \"ACHOrigination processed\" \n            | GuardOn -> beats <- 0; guardOn <- true;\n                printfn \"ACHOrigination is guarded\") \n\nlet paymentFlow = new Subject<PaymentFlowEvent>() \nlet alerter = new Subject<string>() \nlet notifier = alerter.Subscribe(fun x -> printfn \"Logged error %s\" x) \n\nignore <| GuardACHOrigination(paymentFlow,alerter).Guard() \n\n```", "```cs\n            #I __SOURCE_DIRECTORY__ \n            #r \n             \"../packages/FSharp.Quotations.Evaluator.1.0.7/lib\n             /net40/FSharp.Quotations.Evaluator.dll\" \n            open FSharp.Quotations.Evaluator \n\n    ```", "```cs\n            let mutable divider = Quotations.Expr.Value (5) \n\n    ```", "```cs\n            let is5Divisor = <@ fun x -> x % %%divider = 0 @> \n               |> QuotationEvaluator.Evaluate \n\n    ```", "```cs\n            is5Divisor 14 // false \n            is5Divisor 15 // true \n\n    ```", "```cs\n            divider <- Quotations.Expr.Value (7) \n\n    ```", "```cs\n            is5Divisor 14 // false \n\n    ```", "```cs\n            let is7Divisor = <@ fun x -> x % %%divider = 0 @> \n               |> QuotationEvaluator.Evaluate \n\n    ```", "```cs\n            is7Divisor 14 // true \n\n    ```", "```cs\n#I __SOURCE_DIRECTORY__ \n#r \"../packages/FSharp Quotations.Evaluator.1.0.7/lib/net40/FSharp.Quotations.Evaluator.dll\" \nopen FSharp.Quotations.Evaluator \nopen System.Collections.Generic \nopen System \n\ntype Adjustment = \n| Absent \n| Premium of TimeSpan * decimal \n| Penalty of TimeSpan * decimal \n\ntype Terms(?premium: Adjustment, ?penalty: Adjustment) = \n    let penalty = defaultArg penalty Absent \n    let premium = defaultArg premium Absent \n\n    member x.Adjust() = \n        match premium,penalty with \n        | Absent,Absent -> None \n        | Absent,Penalty (d,m) -> Some(<@ fun ((date:DateTime),amount) -> if DateTime.UtcNow.Date - date.Date > d then Decimal.Round(amount * (1M + m),2) else amount @> |> QuotationEvaluator.Evaluate) \n        | Premium(d,m),Absent -> Some(<@ fun ((date:DateTime),amount) -> if DateTime.UtcNow.Date - date.Date < d then Decimal.Round(amount * (1M - m),2) else amount @> |> QuotationEvaluator.Evaluate) \n        | Premium(d',m'),Penalty (d,m) -> Some(<@ fun ((date:DateTime),amount) -> \n            if DateTime.UtcNow.Date - date.Date > d then Decimal.Round(amount * (1M + m),2) \n            elif DateTime.UtcNow.Date - date.Date < d' then Decimal.Round(amount * (1M - m'),2) \n            else amount @> |> QuotationEvaluator.Evaluate) \n        | _,_ -> None \n\n```", "```cs\ntype Invoice = { total:decimal ; date:System.DateTime; } \n\n```", "```cs\nlet invoices = [ \n    { total=1005.20M; date=System.DateTime.Today.AddDays(-3.0) } \n    { total=5027.78M; date=System.DateTime.Today.AddDays(-29.0) } \n    { total=51400.49M; date=System.DateTime.Today.AddDays(-36.0) } \n] \n\n```", "```cs\nlet payment (terms: Terms) invoice = let adjust = terms.Adjust() in if adjust.IsSome then (adjust.Value) (invoice.date, invoice.total) else invoice.total \n\n```", "```cs\nlet terms = Terms(penalty=Penalty(TimeSpan.FromDays(31.),0.015M),\n  premium=Premium(TimeSpan.FromDays(5.),0.02M)) \nlet termsA = Terms() \nlet termsB = Terms(Premium(TimeSpan.FromDays(4.),0.02M)) \nlet termsC = Terms(penalty=Penalty(TimeSpan.FromDays(30.),0.02M)) \n\n```"]