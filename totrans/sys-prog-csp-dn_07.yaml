- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Operating System Tango
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Working with Operating* *System Services*'
  prefs: []
  type: TYPE_NORMAL
- en: Computers are complex machines. They can have many different forms, different
    peripherals, and different functions. Yet, a lot of different machines can run
    the same software. As long as the hardware fits in a pretty broad set of boundaries
    (for instance, running a specific CPU architecture), your software does not care
    what the underlying machine looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this all works is that we have abstraction. You hardly ever deal
    with the actual hardware. There are always layers of software to go through, each
    layer adding a level of abstraction. That sounds complicated, but it is a good
    thing. Without this, we would have to rewrite our software for all possible combinations
    of hardware. Imagine a user swapping out an old-style hard drive with spinning
    discs for a more modern, faster SSD. Then, they have to come to you so you can
    recompile your system to accommodate that. I am sure you do not want to spend
    your time on that if possible.
  prefs: []
  type: TYPE_NORMAL
- en: The lowest level of software, the one running closest to the hardware, is the
    **Basic Input/Output System** (**BIOS**). This system interfaces between the actual
    hardware and the levels above. The BIOS knows how to access a particular area
    on a storage medium. It knows how to reach a network card and get the bits and
    bytes to the levels on top of it. It is the gatekeeper to the actual hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In short, the next level of abstraction is the **operating system** (**OS**).
    These days, the difference between the OS and user programs is not very well defined
    anymore. Windows, for instance, is an OS. however, it also comes with many user
    programs, such as a photo viewer and a calculator. However, the OS does come with
    many utilities we, as systems programmers, can use. These utilities or systems
    in the OS help us do tasks without worrying about the little details while still
    being able to run on many different machines. This chapter explains some of the
    more handy utilities Windows offers us.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter looks at some of the services Windows makes available to us. These
    are the items we will learn about in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worker Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Management Instrumentation (WMI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registry and WMI – risks and how to avoid them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also will look at the risks involved and how to minimize them. After all,
    we are probing deep into Windows, and when things go wrong, they usually go wrong
    very badly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the Registry first!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find all the sources and complete samples for all the things we discuss
    here in the GitHub repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: If you, however, want to build the samples from scratch, you need to install
    some NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: For the WMI samples, you need to install the `System.Management` package.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all systems have settings. These settings persist; they are still there
    after a system shutdown, reboot, or whatever reason. The contents of these settings
    vary; they could be anything your system needs. It could be a connection string
    to a database, a location where you can store files, the font used to generate
    reports, and so on. Anything you cannot know in advance while writing the software
    or that a user or system administrator might want to change should be in a separate
    location from your system.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, Windows applications and systems used `[` and `]` characters. The
    key/value data is a line such as `mykey=myvalue`. Each section or data line is
    on a separate line, and that is it.
  prefs: []
  type: TYPE_NORMAL
- en: We placed the INI file in a known location, usually in the same directory as
    the main application files.
  prefs: []
  type: TYPE_NORMAL
- en: These days, we do not use INI files that much anymore. The .NET BCL does not
    have classes for them, although third-party NuGet packages can help you if you
    decide to go with INI files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious alternative for the INI file is the settings file. The settings
    file is usually in a JSON format, making it easy to work with. You can find them
    in the same place we used to put INI files: we usually place them alongside the
    main application.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON allows for a much more complex structure with a hierarchy in your settings.
    JSON is still much readable for humans, just as the INI files were. That might
    be useful if a system administrator needs to change the settings.
  prefs: []
  type: TYPE_NORMAL
- en: However, a JSON file is not always the best way to store settings. There are
    downsides to this approach. One of the alternatives to the file-based settings
    is using the Windows Registry. Allow me to explain what that is and how to use
    that first, and then I will outline both options’ pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Windows Registry?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Registry is a hierarchical database in Windows where systems can read and
    write all sorts of data. The data itself is a collection of key/value pairs. The
    keys are strings; the values can be strings, numeric, or binary.
  prefs: []
  type: TYPE_NORMAL
- en: Binary data in the Windows Registry
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you can store binary data in the Registry. However, that doesn’t mean it
    is a good idea. The theoretical limit is 1 MB per value, but I vigorously recommend
    not doing that. If you only have a couple of bytes, then storing and reading binary
    data is a great idea, but if you want to store larger amounts of data, you are
    better off using a different mechanism. Having large amounts of binary data in
    your Registry might slow down the complete machine, not just your application.
    Microsoft recommends using a maximum of 1 or 2 KB per entry for your binary data.
    Above that, you should move your data away to another location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Registry is organized in a tree-like structure. Each entry can be a key,
    a subkey, or an entry. The entry is the lowest level in the Registry: an entry
    cannot have a sub-entry.'
  prefs: []
  type: TYPE_NORMAL
- en: Maybe I can clarify this by showing you a bit of the Registry on my machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20924_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The Windows Registry'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.1* shows a small part of the Windows Registry on my machine. On
    the left-hand side, you see the tree structure with all the keys; on the right-hand
    side are the contents of the currently selected key. This image shows the settings
    for the colors used in the Control Panel. These are the default settings; you
    can have different settings per user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is one of the big advantages of the Registry: you can store settings per
    user and have the system figure out which to use when. You do not have to deal
    with that.'
  prefs: []
  type: TYPE_NORMAL
- en: There are 5 top-level keys. I explain these in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_CLASSES_ROOT` | This mainly connects files to applications: for instance,
    what application should Windows start if you double-click a file in Explorer?
    |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_CURRENT_CONFIG` | This contains information about the hardware profile
    used by the local computer at startup. |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_CURRENT_USER` | All information about the current users and their preferences
    is stored here. If you change the theme of Windows, this is where it ends up.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_LOCAL_MACHINE` | Contains configuration information particular to this
    computer, as shared by all users. |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_USERS` | Here, you will find all user profiles known on this computer.
    For each user, their preferences and info are stored. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Top-level Registry keys'
  prefs: []
  type: TYPE_NORMAL
- en: I am not being truthful here. Some top-level keys I just mentioned are handy
    shortcuts to other keys. For instance, `HKEY_CURRENT_USER` maps the currently
    logged-in user in `HKEY_USERS`, and `HKEY_CLASSES_ROOT` is a subkey of `HKEY_LOCAL_MACHINE\Software`.
    But these root keys are there to help you. For instance, instead of looking up
    the ID of the current user and then finding that entry in `HKEY_USERS`, you can
    open the `HKEY_CURRENT_USER` key and be assured you get the correct data.
  prefs: []
  type: TYPE_NORMAL
- en: Each top-level key can have sub-keys. Each sub-key can have its own sub-keys.
    In total, you can go to 512 levels deep. Each top-level and sub-level key can
    have one or more key/value data pairs.
  prefs: []
  type: TYPE_NORMAL
- en: This data has a data type. The following table shows the available data types.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Win** **32 type** | **C# type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `REG_NONE` | `None` | No data type |'
  prefs: []
  type: TYPE_TB
- en: '| `REG_SZ` | `String` | A null-terminated string |'
  prefs: []
  type: TYPE_TB
- en: '| `REG_EXPAND_SZ` | `ExpandString` | A string containing unexpanded references
    to environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| `REG_BINARY` | `Binary` | Binary data in any form |'
  prefs: []
  type: TYPE_TB
- en: '| `REG_DWORD` | `Dword` | A 32-bit binary number |'
  prefs: []
  type: TYPE_TB
- en: '| `REG_MULTI_SZ` | `MultiString` | An array of null-terminated strings, terminated
    by a double null character |'
  prefs: []
  type: TYPE_TB
- en: '| `REG_QWORD` | `Qword` | A 64-bit binary number |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `Unknown` | An unsupported registry data type |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.2: .NET Registry data types'
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 7.2*, however, could use a little explanation.'
  prefs: []
  type: TYPE_NORMAL
- en: The Win32 API supports many data types. However, the CLR has fewer of them available.
    The ones we can use are part of an enum called `RegistryValueKind`. These enums
    defined are the ones I list in the C# type column.
  prefs: []
  type: TYPE_NORMAL
- en: The types that are provided should be enough for you. However, sometimes, you
    need to use specialized ones. For instance, the Win32 API supports a datatype
    named `REG_RESOURCE_LIST`. You use this type to store resource-related data. Unfortunately,
    the C# enum does not provide an equivalent for that. In those cases, you can use
    the `Unknown` type.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExpandString` can be pretty valuable. If you want to store information about
    the location of a file, you can use a macro such as `%PATH%`. This macro is the
    current path in your system. However, the path is stored like that string: `%PATH%`.
    If you specify `ExpandString` as the type, the OS translates that string into
    the actual value if you read that data.'
  prefs: []
  type: TYPE_NORMAL
- en: But honestly, you probably use `String`, `Binary`, and `DWord` the most. The
    others are there in case you need them, though.
  prefs: []
  type: TYPE_NORMAL
- en: How to access and store data with the Windows Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing to the Registry, you must first decide where to store that data.
    For instance, if you want to store something specific for the current user, you
    would probably use `HKEY_CURRENT_USER` as your root key. As systems programmers,
    we are more likely to choose a key such as `HKEY_LOCAL_MACHINE` or `HKEY_CURRENT_CONFIG`.
    These locations are independent of the current user, which is a more likely scenario
    for us. But, of course, if your use case warrants it, use any key you want.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Registry is a hierarchical database, you must specify a hierarchy.
    In other words, you must think of a tree-like structure to store your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'I see several subkeys in my machine’s root key: `HKEY_LOCAL_MACHINE`: `HARDWARE`,
    `SAM`, `SECURITY`, `SOFTWARE`, and `SYSTEM`. In the `SOFTWARE` subkey, I see a
    lot of sub-subkeys, many of which are names of software vendors on my machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to write to the Registry, you have to think about this: the location
    does not matter much, but for administrators who are maintaining the machines
    our software runs on, it has to be logical where you put things.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we want to store the first time our software runs on a particular
    machine. If it has never run before, we store the current date-time. If it has
    run before, we retrieve that data: we never change the `first-run` date.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store that information, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `HKEY_LOCAL_MACHINE\SOFTWARE` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subkey called `SystemProgrammers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another subkey called `Usage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the date-time in binary, in a key called `FirstAccess`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, we can only take the last step if that key doesn’t exist yet. If
    it does, the software has run already. In that case, we retrieve the value belonging
    to that key and show that the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what that all looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we create the subkey. If it already exists, we get a reference to it.
    We don’t have to specify each subkey individually; we can give this method the
    whole path. In our case, `Software\SystemsProgrammers\Usage`, which we store in
    the `LocalMachine` root key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we try to read the value belonging to the `FirstAccess` key. If that
    is `null`, we haven’t created it yet. So, we do that by calling `key.SetValue`.
    I specify the type to be `QWord`, but the API is smart enough to figure that out
    by itself: you can omit that if you want to. I like to be clear in my intentions,
    so I specify it anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: If the key does exist, we retrieve it. We have to do some casting from `long`
    before we get to `DateTime`, but after that casting, we can show the results.
  prefs: []
  type: TYPE_NORMAL
- en: Running this sample
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the Registry usually means you have to run with elevated privileges.
    This code only works if you run Visual Studio as Admin. But don’t worry: the OS
    informs you soon enough if you forget that. You cannot write to the Registry on
    this level as a regular user.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to be more careful with the data you store in the Registry, you
    can apply some security. After all, since anybody can open the Registry by using
    the Registry Editor application, you might want to limit access to specific keys.
    Fortunately, the people who designed the Registry thought of the same thing. So,
    they enabled security features on it.
  prefs: []
  type: TYPE_NORMAL
- en: If we want our key to only be accessible to the current user, we can add some
    security info.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our sample code, after creating the key, add the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the name of the current user, which we store in the appropriately
    named `currentUser` variable. We need this to tell the Registry whom we want to
    give access to (or deny access from) our key.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new instance of the `RegistrySecurity` class. Then, we create a
    new `RegistryAccessRule`, giving it the name of the user, and decide we want this
    rule to apply to everything (complete control), that it is not going to be inherited
    by child classes, not propagated to child classes, and that we want to allow this
    user to take complete control (the other option is to deny access).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add the access rule to the security object, which is applied to the
    key. There you go – a secured key!
  prefs: []
  type: TYPE_NORMAL
- en: A word of advice – limit what you store in the Registry
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the Registry is straightforward. However, I want to stress something:
    do not fill out the Registry if you do not need to. Also, if you have an installer
    of your service, make sure that the uninstaller removes all keys you have created.
    A cluttered Registry is one of the best ways to slow down Windows. There is a
    reason companies make money selling Registry cleaner apps. Don’t be one of those
    developers who mess up their users’ Registry!'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Registry is not the only place we can store our values. Sometimes,
    the overhead is just too much and we do need that to achieve our goal. Let’s have
    a look at the difference between using the Registry and using plain JSON settings
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the Windows Registry to JSON settings files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be surprised how easy it is to work with the Registry. With only a
    couple of lines of code, you can store and retrieve the information you need.
    You can easily distinguish between current and other users’ data. Or, more likely
    in our case, you can ensure the data is accessible for all services on the current
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is nothing wrong with having a local file with settings. After
    all, there is a reason Microsoft gives you a `settings.json` file if you create
    a new project. That’s the best way to isolate your settings. The settings you
    use in your application are right next to your executable. Anyone who needs to
    change them can go to that folder and make changes if needed.
  prefs: []
  type: TYPE_NORMAL
- en: What do you choose? Which one do you use when?
  prefs: []
  type: TYPE_NORMAL
- en: Well, let’s compare them.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Windows Registry has a couple of specific features that make it a good
    choice for certain scenarios. This is what they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized storage**: The Registry is centralized and controlled by Windows.
    This location is where people tend to look for settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User and machine-specific settings**: With the Registry, you can have specific
    settings for the current user, all users, the local machine, or everybody. You
    can place your settings in one or more of these locations and have the OS figure
    out when to use which one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security features**: Adding rights or revoking rights is built in the Registry.
    You can specify on a very granular level what users can and cannot do with your
    keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Reading from the Registry can be faster than reading files,
    especially if the data you are working with is small.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for complex types**: The Registry can handle more than just strings
    and numbers. If your use case demands a more exotic data type, chances are the
    Registry has got you covered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local JSON files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JSON files are used a lot. There are several reasons people like this structure.
    Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity and portability**: JSON files are straightforward. They are easy
    to write to and read from. Another bonus is that these files are easy to transfer
    between systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Human readable and editable**: You can easily edit the JSON files: they are
    just text files, and the structure is easily understood.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No dependencies on Windows**: The Registry is Windows only. JSON files are
    everywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control-friendly**: Since JSON files are text, systems such as Git
    can handle and version them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoiding system corruption**: If you mess up the Registry, you risk bringing
    Windows to a complete halt. Or, in a slightly less lousy case, wreak havoc on
    other applications. With JSON files, the worst that could happen is that you render
    your application useless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if your app is Windows only, and you need security and want to benefit from
    centralized, multi-user settings, go for the Registry.
  prefs: []
  type: TYPE_NORMAL
- en: If you value simplicity, cross-platform compatibility, and easy version control,
    local JSON files are a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Just make a decision based on what you need.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, most applications need to have access to settings. You could store
    them in local JSON files or go for the more versatile but slightly more complex
    Registry.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at what the Registry does, how to read data from it, and how
    to write data to it. We compared the Registry to local JSON files, and we can
    now decide when to use which one.
  prefs: []
  type: TYPE_NORMAL
- en: Worker Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all of the samples I gave you are console apps; straightforward but
    aimed at you, the reader, so you can see what happened. However, in real life,
    systems programmers do not need a console to write output or read input. We deal
    with software that talks and listens to other software. Systems software usually
    does not have a user interface. A **console window** is a form of user interface,
    which we do not need.
  prefs: []
  type: TYPE_NORMAL
- en: I will continue to use the console since that is a straightforward way to show
    you what happens, and in those applications, we can focus on the core of what
    I am trying to show you.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the real world, our applications work mainly behind the scenes.
    One of the ways to do that is to build services.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **service** is a standalone application that has no user interface. It does
    the work quietly behind the scenes. It does communicate with the outside world,
    but it does so through one of the many ways described in previous chapters: through
    network connections, files, pipes, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, if you wanted a service, you had to create a **Windows Service**.
    Before you say: “Well, duh, of course,” let me explain that a Windows Service
    is a different type of application and project in Visual Studio. Just as a console
    application differs from a WPF application, a Windows Service is its own type.'
  prefs: []
  type: TYPE_NORMAL
- en: A Windows Service is an application that runs without a user interface. Starting
    and operating them is not something a user does. Windows is responsible for that.
    There are dozens of services running on a Windows machine at all times, controlling
    your system and providing the background services you need.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows a part of the list of services running on my machine.
    As you can see by the scrollbar, this is just a tiny part of the total amount
    of services.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure\uFEFF7.2: Running Windows Services](img/B20924_08_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure7.2: Running Windows Services'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the services have a name, a description, a status, a startup
    type, and a specific kind of user that controls them.
  prefs: []
  type: TYPE_NORMAL
- en: The name and description are self-explanatory. The status can be one of a set
    of possibilities, but in most cases, they are either running or stopped. There
    are other statuses, but you hardly ever see those.
  prefs: []
  type: TYPE_NORMAL
- en: 'The startup type tells us how the service is started. It can be done automatically
    as soon as Windows starts. It can be done automatically but with a delay, so Windows
    waits a bit before starting them. This allows you to have other services up and
    running first. It can also be manual: Windows doesn’t start them at all. There
    are some other options as well. Last, we see the **Log On As** column. This column
    defines under what security principle the service runs. The security principle
    defines what rights the service has.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Services are powerful, and they are still around. However, in Visual
    Studio, you can’t create them anymore. That’s not entirely true but bear with
    me for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The current way to write service-like applications is by using the Worker Service
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Worker Services are the cross-platform equivalent of Windows Services. If you
    run a Worker Service on Windows, you can still benefit from the features of Windows
    Services. That’s why I said it wasn’t entirely true that you cannot create them
    anymore. The CLR has incorporated the Windows Services into the Worker Service.
  prefs: []
  type: TYPE_NORMAL
- en: A Worker Service is much easier to build and debug than a Windows Service. Since
    Windows controls the Windows Service, you had to perform tricks and magic to debug
    them. However, a Worker Service can run like a console application, albeit with
    added benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Docker support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you create a new `Worker Service Project` in Visual Studio, you first get
    the standard dialog asking you about the name of the project, the location of
    the project, and the name of the solution. That is hardly surprising; you get
    that with every type of project. However, if you enter those details and click
    **Next**, you get a different version of the following dialog. For a console application,
    Visual Studio wants to know which version of the runtime you want (and whether
    you want to use top-level statements or not). With a Worker Service, Visual Studio
    asks you whether you want a Docker container. Your screen probably looks like
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF7.3: Extra information needed to create a Worker Service](img/B20924_08_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Extra information needed to create a Worker Service'
  prefs: []
  type: TYPE_NORMAL
- en: If you check the box before **Enable Docker**, you can select the OS you want
    to use. This is usually a choice between Windows and Linux if you have WSL2 installed.
    Visual Studio creates a docker file for you, and you can now run your service
    in a container. Isn’t that awesome?
  prefs: []
  type: TYPE_NORMAL
- en: Developing your services and running them on Docker is extremely powerful. Visual
    Studio allows you to write your source files on your Windows machine, then deploy
    them to a Docker image and spin up a container with your code running. The debugger
    even allows you to debug your service from Visual Studio while running in the
    Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, I shall not be covering that here in this book. That topic warrants
    a book on its own. However, to show you your options, we will write a bare-bones
    worker service and run it on a Docker if you have that installed. If you haven’t,
    that’s also fine: the worker runs the same on Windows as on Linux in a Docker
    container. So, you pick the strategy you think works best for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the Worker Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Visual Studio, you can select Worker Service as a template. If you do that,
    you get asked the question we already discussed: what version of the framework
    do you want, and do you want Docker support? If you do, what OS should it run
    on?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my example, I have enabled Docker support and chosen Linux as the OS. It
    does not matter what you decide to do: the C# code is the same no matter what.'
  prefs: []
  type: TYPE_NORMAL
- en: The bare minimum of a Worker Service has a bit more code than a regular console
    application, but the main files are `Program.cs` and `Worker.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'My application looks like this in the Visual Studio solution window:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF7.4: The layout of the Worker Service in Visual Studio](img/B20924_08_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The layout of the Worker Service in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Program` class is not even that interesting. It contains, next to the
    namespace declaration, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me outline the steps I took to get to these results:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an instance of the `HostApplicationBuilder` class. We do that
    by calling `CreateApplicationBuilder` on the static `Host` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `builder` instance allows us to register classes. That way, we can use
    dependency injection. The template adds one service for us: the `Worker` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we build `host` (of the `IHost` type), and finally, we run it.
  prefs: []
  type: TYPE_NORMAL
- en: The more exciting code is in the `Worker` class. As the name implies, that’s
    where all the work happens. We do not call it a Worker Service for nothing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at that `Worker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want to rename this class, you can do that, of course, as long as you
    also change the registered class in the `Program` class. Also, if you want to
    build multiple classes next to `Worker`, you can also do that. Again, do not forget
    to add them to `builder` in the `Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is going on here?
  prefs: []
  type: TYPE_NORMAL
- en: The base class is `BackgroundService`. This class takes care of all the plumbing.
    It is an abstract class with the `ExecuteAsync(CancellationToken stoppingToken)`
    abstract method. So, you must write that method yourself (or let the template
    do that, as we did here.)
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of our class gets a default instance of `logger` that allows
    us to write things to the console when running. This `logger` is available to
    us through the magic of dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ExecuteAsync` method, we keep looping until `CancellationToken` signals
    we want to stop. In the loop, we output a message and wait for a second before
    going to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this, you will see the output. If you have Docker Desktop running,
    you can also run it on Docker. Just select Docker as what you want to run instead
    of your application. Visual Studio builds the image, deploys it, starts a container,
    and hooks the debugger to allow debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output window of Visual Studio and Docker Desktop itself, you can see
    the results: the output of our loop is printed there.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the lifetime of the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Worker Service is meant to run forever. Well, maybe not forever, but at least
    as long as your machine runs. It is in there in the background, doing its job.
    It might be doing something worthwhile or waiting for incoming messages over a
    file, network, or any other way we discussed. It does its job and then returns
    to waiting for the next assignment.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want to stop the service when it has fulfilled its purpose?
    Let’s rewrite the code a bit. Add a private variable to our Worker Service `call
    _counter` of the `int` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, change the loop in `ExecuteAsync` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After waiting one second, we checked to see whether the loop had been run 10
    times. If it has, we break out of the loop. Then, we print a message to tell you
    it has done so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run it and watch. You notice that it works as expected but that Visual Studio
    does not return to normal: it keeps debugging. However, there is nothing to debug!
    If you break, you see that Visual Studio still executes the call to `Host.Run()`
    in `Program`. Apparently, there is no way out!'
  prefs: []
  type: TYPE_NORMAL
- en: Well, of course, there is. In this case, all we have to do is tell `Host` that
    we want it to stop working. We can do that quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use dependency injection again. One of the services available to us is an
    instance of a class that implements the `IHostApplicationLifetime` interface.
    Let’s add that to the constructor of the `Worker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We get that instance and store it in a local field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `ExecuteAsync` method, just after where we log that we have finished
    the loop, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it. The `Host` instance now gets the message telling
    it to stop working and return to the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up Worker Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Worker Services are excellent if you want a piece of code running in the background
    without any user interface, only meant to be called by other software. Does that
    sound familiar? That is precisely what systems programmers strive for. Worker
    Services are your best bet here. They can do anything you want. They can open
    ports on a TCP connection, watch folders for files, have named pipes to wait for
    data and process it, wait for network connections, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: In short, they are a much better place to do all that work than the console
    applications we have been writing so far. You can still register them as services
    in Windows, so they start up automatically as soon as Windows starts.
  prefs: []
  type: TYPE_NORMAL
- en: The code is simple enough. Ensure your code is initiated from the `Worker` class,
    and you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will stick with the console applications in the rest of this book. Not because
    they are a better way to do systems programming (they are not) but because they
    are so easy and do not get in the way when I am working on explaining new topics.
    But now you know: everything you can do in a console application can (and should)
    be done in a Worker Service. You can deploy your code on Linux machines or Docker
    platforms if it is cross-platform and does not use Windows-only APIs. It is all
    up to you!'
  prefs: []
  type: TYPE_NORMAL
- en: WMI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System programmers work closer to the OS than other, more user-oriented programmers.
    We often need to know more about the state of the OS than others do. We might
    need to keep track of the memory used, the hardware state, and other lower-level
    items. Luckily, Windows allows us to do just that. We can have a window (no pun
    intended) into the engine room, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: WMI is the tool to use. It’s like the Swiss Army knife for managing items in
    Windows. WMI is part of the Windows OS that allows you to access and manipulate
    all sorts of system information and settings. This is Windows only, of course.
    In Linux, there is no built-in, out-of-the-box alternative to WMI. If you want
    to do this on a Linux machine, use external libraries and tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can you do with WMI? You’d better ask, “What can’t you do with WMI?” Let
    me show you some of the more common uses of WMI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring system health**: You can check on CPU load, available memory,
    disk usage, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing hardware and software**: You can get information about installed
    software, manage printers, and even play around with BIOS settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automating tasks**: You can use WMI to automate tasks, such as monitoring
    and restarting a service if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event notifications**: We already saw the possibility of watching a folder
    or a file, but we can do much more. We can get notifications for almost anything
    that happens on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more things you can do with WMI. However, let’s focus on these
    first. Before we begin looking at some samples, you need to install a NuGet package:
    `System.Management` from Microsoft. This package replaces the older `System.Management`
    assembly that was part of the .NET Framework.'
  prefs: []
  type: TYPE_NORMAL
- en: How to use WMI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary way of interacting with Windows is by querying it. The `System.Management`
    NuGet package gives us access to a class named `ManagementObjectSearcher`. This
    class allows us to create queries and run them against Windows. The searcher usually
    returns a collection of `ManagementObject` instances, which you can interact with.
    These `ManagementObject` instances reflect something in your system. This class
    has an indexer, so you can query that object to get the information you are searching.
  prefs: []
  type: TYPE_NORMAL
- en: '`ManagementObjectSearcher` can search over a lot of different types of data
    providers. That means you might have to limit the search by giving it a scope
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: The query itself is a string that starts with `SELECT`. It is just like a database.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful what you do, though; we are opening the hood of the engine and poking
    around in places we are usually not meant to be poking around in. Most of the
    queries run on WMI require elevated privileges. You need to be a local administrator
    to make some changes or see some of the data. That means that all safeguards are
    out of the window. You are on your own. With great power comes great responsibility,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following samples only run on Windows. Visual Studio is smart enough
    to see that: if you follow along, you will see many warnings about that. To be
    specific, you get the `CA1416` warning a lot. This warning says `This call is
    reachable on all platforms. ManagementObjectSearcher is only supported` `on: Windows`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get rid of that, add a pragma to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction tells the compiler not to bother: we know what we are doing.
    Now, the compiler gets out of your way and lets you be responsible for all damages
    that might occur if you still try to run this on Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: But enough of the scaremongering. Before we get into a heated debate on the
    pros and cons of being a local admin, we have to measure the heat a bit. Let’s
    measure the temperature of our CPU!
  prefs: []
  type: TYPE_NORMAL
- en: Reading the CPU temperature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the BIOS implementations allow the system to read the current CPU temperature.
    Other vendors of motherboards might have other ways of reading temperatures in
    the system, one of which might be the CPU. It all depends on the vendor. However,
    if your system supports it, you can easily read the current temperature. You could
    use that information to scale down your work in your system if you notice you
    are making the CPU work too hard. But how do we get that temperature? The code
    is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, I identify the scope of the query. In this case, it is `root\\WMI`. Then,
    I create the query string, where we select everything from the `MCAcpi_ThermalZoneTemperature`
    class. As I said before, this results in a collection of `ManagementObject` instances.
    In this case, the collection consists of one item. This item has an indexer, and
    if we request the `CurrentTemperature` field, we get the current temperature of
    the CPU in tenths of Kelvin. We multiply that result by ten to get to the actual
    Kelvin value and then convert that to degrees Celsius. If you want to go to Fahrenheit,
    be my guest.
  prefs: []
  type: TYPE_NORMAL
- en: As I said, not all vendors supply this option. I use an older laptop from 2018
    quite frequently, but it does not give me this information. I see `ManagementException`
    on that machine when I try to get the results. However, I got the results on my
    beefy desktop machine as expected.
  prefs: []
  type: TYPE_NORMAL
- en: There is another class you can use to query for the temperature. The query for
    that is `SELECT * FROM Win32_TemperatureProbe`, and the scope for that query is
    `root\\CIMV2`.
  prefs: []
  type: TYPE_NORMAL
- en: However, there can be multiple probes in your machine. Some motherboards also
    support measuring the temperature of other components, such as the GPU. To be
    honest, `Win32_TemperatureProbe` is even less commonly implemented than `MCAcpi_ThermalZoneTemperature`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the BIOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The BIOS is the lowest level of abstraction on your machine. This level is where
    all the logic gets translated into voltages fed into the hardware. Wouldn’t it
    be nice to see what is going on there? Well, you can, with the power of WMI!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get some basic information out of the BIOS and display that. Here we
    go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For this example, I have used a different constructor. Instead of passing in
    the scope and query as strings, I construct these two items first using the managed
    `ManagementScope` and `ObjectQuery` wrapper classes. This way of working achieves
    the same result but might be more readable to future developers working on this
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The structure is similar to the previous example. We create an instance of a
    `ManagmentObjectSearchers` class, feed it the scope and query, and then query
    the results. In our example, we get the manufacturer, name, and version.
  prefs: []
  type: TYPE_NORMAL
- en: You can read many more properties from the BIOS, such as the capabilities. These
    describe what hardware is supported on that machine. As a systems programmer,
    you probably can imagine how this could be handy to know.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Windows Update service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed Worker Services earlier in this chapter. However, wouldn’t it be
    nice if we could write software that allows us to monitor the state of those services
    and act upon them if needed? Well, we can with WMI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sample, we look at the status of a generic service: the Windows
    Update service. This service is part of the OS and is responsible for dealing
    with updates: monitoring, downloading, and installing them. Ideally, that service
    should always be up and running. Let’s see what we can do with WMI to achieve
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I do not specify a scope. Windows then assumes the default
    scope of `root\CIMV2`, as we saw before. Generally, it would be best if you used
    a scope. Specifying a scope limits the areas where WMI executes your query, which
    improves the speed tremendously. I just wanted to show you this approach here
    so you know it is an option.
  prefs: []
  type: TYPE_NORMAL
- en: We are looking for a service with the name of `wuauserv`, the Windows Update
    service. If we find it, we get the current state. It should be “running.” If it
    is, we stop it, wait for two seconds and restart it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There you have it: you can now control services inside your code!'
  prefs: []
  type: TYPE_NORMAL
- en: Watching USB devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you might be depending on specific hardware. Let’s assume you are
    reading data from a USB device. Wouldn’t it be nice to be informed when the user
    removes the device? That would prevent embarrassing errors in your code, right?
    Again, we have WMI coming to our aid!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The query tells the system to look at an event called `__InstanceDeletionEvent`.
    This is the event that Windows raises once something is deleted on the computer.
    In this case, we look for something in the list of devices registered in `ISA'Win32_USBHub'`.
    In other words, we want to be notified if a USB device is deleted from the system.
    `WITHIN 2` means we want to check every 2 seconds. So, there might be a delay.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we create a new object. The watcher is a new instance of the `ManagementEventWatcher`
    class. We give it the query, set up a callback in case the event happens, and
    start watching. When we are done, we stop watching again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event handler looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the event occurs, this code gets called. `eventargs` of the `EventArrivedEventArgs`
    type contains much information. Amongst others, it has `TargetInstance` in it.
    `TargetInstance` has all sorts of information we can display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have used another approach: we could have queried the `Win32_DeviceChangedEvent`
    class. That would have been a bit easier, but that gives us less information than
    our current solution. This is typical for WMI: there is usually more than one
    way to get the desired results.'
  prefs: []
  type: TYPE_NORMAL
- en: Play around with it; start the code and unplug several devices from your machine.
    See what happens!
  prefs: []
  type: TYPE_NORMAL
- en: Final words about WMI
  prefs: []
  type: TYPE_NORMAL
- en: 'WMI is very powerful. You can do all sorts of things that are typically unavailable
    to a regular .NET application. However, there are downsides: WMI is highly resource
    intensive. We set the event watcher in the last sample to only run once every
    two seconds to mitigate that a little bit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'WMI is somewhat obscure. You have to figure out the queries yourself; there
    is not much information that teaches you all the available options. Of course,
    the Microsoft documentation has plenty to say about this topic, but it is not
    as straightforward as you might be used to. There is quite a steep learning curve
    if you want to dive into this. That leads to another risk: you can quickly get
    things wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: WMI allows you to interact with lower parts of the system, which can cause catastrophic
    results. Another risk is that it unadvertly displays security-sensitive information.
    So, be careful what you do with it. As always, test what happens if you use this
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are careful, you can do many cool things!
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen some really nice things here. You might be tempted to sprinkle
    a lot of Registry and WMI code over your systems. However, before you do that,
    let’s take a peek into the downsides: there are potential risks we should talk
    about!'
  prefs: []
  type: TYPE_NORMAL
- en: Registry and WMI – risks and how to avoid them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nothing comes for free. That also applies to OS services: there is a price
    to pay. The complexity of the code isn’t too high; I am sure you could follow
    along. No, the price you have to pay lies elsewhere: mistakes can be hard to spot
    and even harder to fix. The risks are pretty high: an error could lead to unpredictable
    behavior of the machine. You could bring down a complete server if you do things
    wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we are all brilliant developers. We do not make mistakes, right?
    However, just in case we have a moment of weakness (we all know that 14 hours
    of developing software in one sitting is not the best idea), I want to tell you
    about the risks and how to avoid them as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: But before I do that, we have a whole chapter ([*Chapter 11*](B20924_12.xhtml#_idTextAnchor237),
    to be exact) about debugging. That’s where we will dive into the nitty gritty
    details of that topic. But here, I want to focus on what might go wrong when working
    with the Registry and WMI.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, the Windows Registry is where the OS and most applications
    running on it store and read their settings. These could range from simple values
    about the user preferences to details about installed peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Making a mistake here could result in an application not working as expected.
    However, it could also result in the machine breaking down completely. So, you’d
    better be careful when dabbling around in the Registry!
  prefs: []
  type: TYPE_NORMAL
- en: There are several steps you can take to mitigate the risks. Let’s go through
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Backup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you start experimenting with the Registry, the best tip I can give you is
    to back up your current settings. You can export and import keys and subkeys in
    the Registry Editor tool (`regedit.exe` in your Windows directory). That means
    you can easily roll back your changes when you make a mistake. If you are doing
    this in your application, you might consider reading your app’s settings and storing
    them before applying changes. Of course, you do not do that when storing simple
    settings, but this might save you when you need it for more threatening situations.
  prefs: []
  type: TYPE_NORMAL
- en: Proper tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the end, the Registry itself is a collection of files on the storage medium
    of your computer. After all, the data needs to be stored somewhere. It is no secret
    where these files are stored. For instance, you can find the `HKEY_LOCAL_USER`
    settings in the `UsrClass.dat` file in the `%UserProfile%\Local Settings\Application
    Data\Microsoft\Windows` folder. However, I would not recommend messing around
    with these files yourself. Use the tools. The aforementioned Registry Editor is
    a great way to read and change settings. If you want to do this in your software,
    use the tools the BCL and the Win32 API give you. If you are curious about what
    happens to the Registry in run time, the free Process Monitor tool from SysInternals
    is invaluable. It can give you a live view of all processes working with the Registry.
    It might surprise you how often the Registry is used!
  prefs: []
  type: TYPE_NORMAL
- en: Keep it minimal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Registry is not meant to store large amounts of data. It is for smaller
    items, such as settings and preferences. Use it wisely: do not store too much
    data there. A good solution would be to have larger amounts of data stored in
    a file and store the location of that file in the Registry in a well-known place.
    This way, you can differentiate between different users (since the Registry keeps
    track of the user and presents you with the correct `HKEY_LOCAL_USER` instance)
    but still have a place to store more data.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging is your friend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loggings is always a great tool when debugging your code, but this is especially
    true when dealing with the Registry. When something goes wrong, logs can be a
    lifesaver. Next to that, logs can help you understand your software’s flow and
    clarify why specific paths in your code were taken. When developing, you can never
    have too many log files. However, you might want to turn down the amount and verbosity
    of your logs when you go into production.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error handling should be a no-brainer. Use try-catch blocks as much as you can.
    Do not catch the generic `Exception` class, but be specific. After all, the *only
    catch the exceptions you can handle* rule is still valid.
  prefs: []
  type: TYPE_NORMAL
- en: Software that works with the Registry might encounter exceptions such as `SecurityException`,
    `IOException`, and `UnauthorizedAccessException`. Be mindful of those. Catch them
    and return your software in a known state before continuing the flow.
  prefs: []
  type: TYPE_NORMAL
- en: Also, please log these instances!
  prefs: []
  type: TYPE_NORMAL
- en: Test in an isolated environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with the more risky areas of the Registry, you might want to do
    that on a different machine than your daily device. You do not need to switch
    to a different machine but can use other techniques. You can quickly deploy a
    **virtual machine** (**VM**) locally or in the cloud. With Azure, making a VM
    and deploying and running your code is extremely easy. If it all works, that’s
    fine. If it doesn’t, all you have to do is delete the VM and try again.
  prefs: []
  type: TYPE_NORMAL
- en: Another good approach is to use Docker. If you switch Docker from Linux containers
    to Windows containers, you can deploy your Worker Services to Docker and then
    work on the isolated, local Registry in that container. If it goes wrong, no harm
    is done. If you also log to a persistent file stored outside the container so
    that it lives on after the container crashes, you can do a post-mortem conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: Potential risks when dealing with WMI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WMI can be very powerful. You can query your system without having to resort
    to the Registry. You can also change settings, start services, configure network
    settings, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: However, WMI is not easy. The documentation is out there, but you must look
    for it and piece it together yourself. However, there are some tips and tricks
    I can give you to get up to speed with WMI and use it to your advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Start with the basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Know your **WMI Query Language** (**WQL**). It is a bit like SQL for the WMI
    system. Since you often pass in the queries to the WMI in strings, you should
    be careful not to make typos. They are notoriously hard to spot. Knowing the syntax
    of WQL can help in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: One often-made mistake is not using the correct namespace when querying the
    system. Although most queries run against the `ROOT\CMIV2` namespace, not all
    do. Make sure you use the correct namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Use the right tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When learning about WMI, you might want to play around with it first. There
    is an almost unknown tool that comes with Windows called `WBEMTest`. You can start
    that by entering that term into the **Search** field in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'This tool is a quick entry into the WMI. The user interface looks like it comes
    straight out of Windows 95, but it is a nice way to investigate WMI. For instance,
    if I want to know more about my BIOS vendor, I can use the code we looked at before
    or enter that in `WBEMTest`. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF7.5: WBEMTest querying the BIOS](img/B20924_08_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: WBEMTest querying the BIOS'
  prefs: []
  type: TYPE_NORMAL
- en: This image shows `WBEMTest` in action. In the top left corner, I connected the
    app to the `ROOT\CMIV2` namespace. Then, I clicked on `SELECT * FROM Win32_BIOS`
    query. I got the results you see in the bottom right window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Powershell is also a great way to interact with WMI before incorporating WMI
    into your system. You can use the `Get-WMIObject` cmdlets to interrogate the system.
    For instance, getting the information about the BIOS results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF7.6: Get-WMIObject in PowerShell](img/B20924_08_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Get-WMIObject in PowerShell'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I can enter `Get-WMIObject`, then pass the name of the object
    I want to interrogate (`Win32_Bios`), and I get all results nicely formatted.
  prefs: []
  type: TYPE_NORMAL
- en: Improve your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tips I gave you for handling the Registry also apply here: catch the right
    exceptions and log as much as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: The most seen exception when working with WMI is `ManagementException`. Of course,
    we also saw queries not supported on specific platforms. Be aware of those issues
    and handle them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is also a great way to debug your WMI code. Log as much as you can during
    development to know what is happening when things go south.
  prefs: []
  type: TYPE_NORMAL
- en: Performance and memory considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As systems programmers, we care deeply about performance and memory usage. WMI
    can significantly slow down your app. Especially when polling too often, you will
    see a degradation of your performance. Avoid frequent polling. You do not need
    to check the temperature every millisecond, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Also, do not forget to dispose of all CLR classes dealing with the WMI properly.
    If handles to those classes remain open too long, you might exhaust the available
    resources. That is a great way to bring your system to a screeching halt. Let’s
    not do that!
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note: WMI relies on the WMI service. Yes, that is a Windows Service.
    If that service is not running, WMI does not work. That will not likely ever happen,
    but that situation might occur. So, if things do not work as you expect, please
    also check that service.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all other tips and tricks I gave you throughout this book also apply.
    There is nothing magical about WMI, Worker Services, and the Registry. It is just
    that they might need a bit more attention to avoid getting into weird situations.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows gives you many tools to use. These tools are deeply integrated into
    the system. Most of them are never used by applications used by users. But for
    us, as systems programmers, this is different. We are working closer to the metal,
    so it is good to know what that metal offers us.
  prefs: []
  type: TYPE_NORMAL
- en: I suggest you play with the Registry Editor and see what hidden gems you can
    find there. Next to that, learn WQL. Many tools offer a nice interface to the
    WMI, but in the end, you will have WQL strings in your application. You might
    as well start to learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, learn Docker. Docker is a great way to package your applications and
    a valuable debugging tool. You can use Docker to isolate your potentially dangerous
    code. If things go wrong, all you need to do is delete the running container and
    start again. Of course, everything we discussed in this chapter is only available
    on Windows, so you must use Windows containers on Docker. When you are sure your
    code works fine, you can use it on real Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at all the tools that Windows give us; tools we can
    use in our code to do things that are hard to do if we had to write everything
    ourselves. We learned about the centralized settings storage mechanism called
    the Registry.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the ways we can query the OS and even the underlying hardware
    through the use of WMI. We talked about how to use them and we talked about how
    to avoid some of the risks involved.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with these skills under our belt, it is time to escape the confinement
    of the single machine and venture into the land of networking. Systems these days
    rarely run in isolation on one machine. They communicate. They talk to each other.
    We should be looking into networking next. So, hook up your dial-up modem and
    follow along for the road down the network protocols!
  prefs: []
  type: TYPE_NORMAL
