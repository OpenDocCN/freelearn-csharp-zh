- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: 'Immersive Realism: Achieving Fullscreen Effects with Post-Processing'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逼真沉浸：使用后处理实现全屏效果
- en: So far, we have created different objects, such as meshes, particles, and lights,
    to alter the visuals of our scene. But if we really want to get that slick, modern
    game look, it’s time to try our hand at some post-processing magic. We can tweak
    the settings of our objects here and there to improve our scene quality, but you
    will always feel that something is missing when comparing it with modern game
    scenes, and the thing that is missing is post-processing effects, that is, any
    effects applied after all the processing of the scene has been completed to enhance
    its visual results. In this chapter, you will learn how to apply effects to the
    final rendered frame, which will alter the look of the overall scene we have been
    creating in previous chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了不同的对象，如网格、粒子、灯光，以改变场景的视觉效果。但如果我们真的想要获得那种光滑、现代的游戏外观，是时候尝试一些后处理魔法了。我们可以调整对象这里的设置来提高场景质量，但当你与现代游戏场景比较时，你总会觉得缺少了什么，而缺少的就是后处理效果，即在整个场景处理完成后应用的效果，以增强其视觉效果。在本章中，你将学习如何将效果应用于最终渲染帧，这将改变我们在前几章中创建的整体场景的外观。
- en: 'In this chapter, we will examine the following image effect concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查以下图像效果概念：
- en: Using post-processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后处理
- en: Using advanced effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级效果
- en: Let’s start by seeing how we can apply post-processing to our scene.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何将后处理应用于我们的场景。
- en: Using post-processing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后处理
- en: '**Post-processing** is a Unity feature that allows us to apply a stack of effects
    (several effects) one on top of the other to alter the final look of an image.
    Each one will affect the finished frame, changing the final image the user sees.
    In *Figure 13.1*, you can see a scene before and after applying image effects.
    You will notice a dramatic difference, but that scene doesn’t have any changes
    in its objects, including lights, particles, and meshes.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**后处理**是Unity的一个功能，允许我们将一系列效果（几个效果）堆叠在一起，以改变图像的最终外观。每一个都会影响最终帧，改变用户看到的最终图像。在*图13.1*中，你可以看到应用图像效果前后的场景。你会注意到一个巨大的差异，但那个场景中的对象没有任何变化，包括灯光、粒子网格。'
- en: 'The effects applied are based on a per-pixel level. Have a look at both the
    scenes here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的效果是基于每个像素级别的。看看这里两个场景：
- en: '![](img/B21361_13_01_PE.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_01_PE.png)'
- en: 'Figure 13.1: A scene without image effects (left) and the same scene with effects
    (right)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：没有图像效果的场景（左）和添加了效果的相同场景（右）
- en: 'In this section, we will discuss the following URP post-processing concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下URP后处理概念：
- en: Setting up a profile
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置配置文件
- en: Using basic effects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本效果
- en: By mastering these URP post-processing concepts, you’ll be able to transform
    your scenes from the ordinary to the extraordinary. Let’s start preparing our
    scene to apply effects, for which we need to set up a profile.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握这些URP后处理概念，你将能够将你的场景从普通转变为非凡。让我们开始准备我们的场景以应用效果，为此我们需要设置一个配置文件。
- en: Setting up a profile
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置配置文件
- en: To start applying effects, we need to create a **profile**, which is an asset
    containing all the effects and settings we want to apply. This is a separate asset
    because we can share the same post-processing profile across different scenes
    and parts of scenes, as we do for the materials. When we refer to parts of scenes,
    we are referring to volumes, which are zones, regions, or areas of the game that
    have certain effects applied. We can define a global area that applies effects
    regardless of the position of the player, or we can apply different effects—for
    example, when we are outdoors or indoors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始应用效果，我们需要创建一个**配置文件**，这是一个包含我们想要应用的所有效果和设置的资产。这是一个独立的资产，因为我们可以在不同的场景和场景的不同部分共享相同的后处理配置文件，就像我们处理材质一样。当我们提到场景的部分时，我们指的是体积，即区域、区域或游戏中的区域，这些区域应用了某些效果。我们可以定义一个全局区域，无论玩家的位置如何都应用效果，或者我们可以应用不同的效果——例如，当我们户外或室内时。
- en: 'In this case, we will use a global volume, one that we will use to apply a
    profile with our first effect, by doing the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个全局体积，我们将使用它来应用一个配置文件和我们的第一个效果，方法如下：
- en: Create a new empty GameObject (**GameObject | Create Empty**) named `PP Volume`
    (Post-Processing Volume).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空GameObject（**GameObject | 创建空**）命名为`PP Volume`（后处理体积）。
- en: Add the **Volume** component to it and make sure **Mode** is set to **Global**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加**体积**组件，并确保**模式**设置为**全局**。
- en: 'Click on the **New** button at the right of the **Profile** setting, which
    will generate a new `Profile` asset with the same name as the GameObject that
    was selected when clicking the button (**PP Volume** **Profile**). Move that asset
    to its own folder, which is recommended for asset organization purposes. The final
    settings are illustrated in the following figure:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**配置文件**设置右侧的**新**按钮，这将生成一个与点击按钮时选择的GameObject同名的新的`Profile`资产（**PP 体积** **配置文件**）。将此资产移动到其自己的文件夹中，这有助于资产组织。最终的设置如下面的图所示：
- en: '![](img/B21361_13_02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_02.png)'
- en: 'Figure 13.2: Volume component'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：体积组件
- en: To test whether the volume is working, let’s add an effect. To do so, click
    the **Add Override** button and select the **Post-Processing | Chromatic Aberration**
    option.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试体积是否工作，让我们添加一个效果。为此，点击**添加覆盖**按钮并选择**后期处理 | 色差**选项。
- en: 'Check the **Intensity** checkbox in the **Chromatic Aberration** effect and
    set the intensity to `0.25`, as illustrated in the following figure:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**色差**效果的**强度**复选框中勾选，并将强度设置为`0.25`，如下面的图所示：
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21361_13_03_PE.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、数字的图片，描述自动生成](img/B21361_13_03_PE.png)'
- en: 'Figure 13.3: Chromatic aberration effect'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：色差效果
- en: Now, watch as the aberration effect subtly tweaks the corners of your image,
    adding a dynamic edge to the scene. Remember to look at this in the **Scene**
    panel; we will make the effect applied to the **Game** view in the next step.
    This is illustrated in the following figure:![](img/B21361_13_04_PE.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，观察色差效果如何微妙地调整图像的角落，为场景添加动态边缘。请记住在**场景**面板中查看这一点；我们将在下一步将效果应用到**游戏**视图中。这如下面的图所示：![图片](img/B21361_13_04_PE.png)
- en: 'Figure 13.4: Chromatic aberration applied to the scene'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.4：场景中应用了色差效果
- en: If you don’t see the effect, make sure that the toggle effects button is on,
    as seen in the following image.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你没有看到效果，请确保切换效果按钮处于开启状态，如下面的图所示。
- en: '![](img/B21361_13_05.png)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_05.png)'
- en: 'Figure 13.5: Scene view effects toggle'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.5：场景视图效果切换
- en: 'Now, if you hit **Play** and see the game from the view of the Main Camera,
    you will see that the effect is not being applied, and that’s because we need
    to check the **Post Processing** checkbox in the **Rendering** section of our
    Main Camera, as illustrated in the following figure:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击**播放**并从主相机的视角看游戏，你会看到效果没有被应用，这是因为我们需要在我们的主相机的**渲染**部分的**后期处理**复选框中勾选，如下面的图所示：
- en: '![](img/B21361_13_06.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_06.png)'
- en: 'Figure 13.6: Enabling post-processing'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：启用后期处理
- en: With our global volume set up, we’ve just unlocked the ability to consistently
    apply effects across the entire scene, no matter where our player roams.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的全球体积设置完成后，我们刚刚解锁了在整个场景中一致应用效果的能力，无论我们的玩家走到哪里。
- en: Now that we have prepared our scene to use post-processing, we can start experimenting
    with different effects. Let’s start with the simplest ones in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为场景准备好了后期处理，我们可以开始尝试不同的效果。让我们在下一节从最简单的效果开始。
- en: Using basic effects
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本效果
- en: Now that we have post-processing in our scene, the only thing needed is to start
    adding effects and set them up until we have the desired look and feel. In order
    to do that, let’s explore several simple effects included in the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在场景中设置了后期处理，我们只需要开始添加效果并设置它们，直到我们得到期望的外观和感觉。为了做到这一点，让我们探索系统包含的几个简单效果。
- en: 'Let’s start with **Chromatic Aberration**, the one we just used, which, as
    with most image effects, tries to replicate a particular real-life effect. All
    game engine rendering systems use a simple mathematical approximation of how human
    vision really works, and because of that, we don’t have some effects that occur
    in the human eye or camera lenses. A real camera lens works by bending light rays
    to point them toward the camera sensors, but that bending is not perfect in some
    lenses (sometimes intentionally), and, hence, you can see distortion, as shown
    in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**色差**开始，这是我们刚刚使用的，就像大多数图像效果一样，它试图复制一个特定的现实生活效果。所有游戏引擎渲染系统都使用一个简单的数学近似来描述人类视觉的真正工作方式，因此，我们没有一些在人类眼睛或相机镜头中发生的效果。真实的相机镜头通过弯曲光线来指向相机传感器，但这种弯曲在某些镜头中并不完美（有时是故意为之），因此，你可以看到扭曲，如下面的截图所示：
- en: '![](img/B21361_13_07_PE.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_07_PE.png)'
- en: 'Figure 13.7: Image without chromatic aberration (top) and the same image with
    chromatic aberration (bottom)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：无色差图像（顶部）和有色差图像（底部）
- en: 'This effect will be one of several that we will add to generate a cinematic
    feeling in our game, simulating the usage of real-life cameras. Of course, this
    effect won’t look nice in every kind of game; maybe a simplistic cartoonish style
    won’t benefit from this one, but you never know: art is subjective, so it’s a
    matter of trial and error.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果将是我们添加的几个效果之一，以在我们的游戏中营造出电影感，模拟现实生活中的相机使用。当然，这个效果并不是在所有类型的游戏中都看起来很好；也许简单的卡通风格不会从这个效果中受益，但你永远不知道：艺术是主观的，所以这是一个试错的问题。
- en: Also, we have exaggerated the intensity a little bit in the previous example
    to make the effect more noticeable, but I would recommend using an intensity of
    `0.25` in this scenario. It is usually recommended to be gentle with the intensity
    of the effects; it’s tempting to have intense effects, but as you will be adding
    lots of them, after a while, the image will become bloated with too many distortions.
    So, try to add several subtle effects instead of a few intense ones. But, again,
    this depends on the target style you are looking for; there are no absolute truths
    here (but common sense still applies).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在前面的例子中稍微夸张了强度，以便使效果更明显，但我建议在这种情况下使用 `0.25` 的强度。通常建议对效果的强度要温和；虽然强烈的视觉效果很有吸引力，但因为你将添加很多效果，所以过一段时间后，图像会因为过多的扭曲而变得膨胀。所以，尝试添加几个微妙的效果而不是几个强烈的效果。但，再次强调，这取决于你寻找的目标风格；这里没有绝对真理（但常识仍然适用）。
- en: Finally, before moving on to discuss other effects, if you are used to using
    other kinds of post-processing effects frameworks, you will notice that this version
    of **Chromatic Aberration** has fewer settings, and that’s because the URP version
    seeks performance, so it will be as simple as possible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在讨论其他效果之前，如果你习惯于使用其他类型的后期处理效果框架，你会注意到这个版本的**色差**设置较少，这是因为 URP 版本追求性能，所以它会尽可能简单。
- en: The next effect we are going to discuss is **Vignette**. This is another camera
    lens imperfection where the image intensity is lost at the edges of the lens.
    This can be applied not only to simulate older cameras but also to draw the attention
    of the user toward the center of the camera—for example, during cinematics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的效果是**晕影**。这是另一种相机镜头不完美的情况，图像强度在镜头边缘丢失。这不仅可以用来自动模拟旧相机，还可以将用户的注意力引向相机的中心——例如，在电影场景中。
- en: 'Also, if you are developing **virtual reality** (**VR**) applications, this
    can be used to reduce motion sickness by reducing the peripheral vision of the
    player. In the following screenshot, you can see an example of vignetting on an
    old camera:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你正在开发**虚拟现实**（**VR**）应用程序，这可以用来通过减少玩家的周边视野来减少运动病。在下面的屏幕截图中，你可以看到一个旧相机的晕影示例：
- en: '![Image result for vignetting](img/B21361_13_08_PE.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片结果](img/B21361_13_08_PE.png)'
- en: 'Figure 13.8: Photo taken with an old camera, with vignetting over the edges'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：使用旧相机拍摄的照片，边缘有晕影
- en: 'Just to try it, let’s apply some vignetting to our scene by doing the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试一下，让我们通过以下步骤在我们的场景中应用一些晕影：
- en: Select the `PP Volume` GameObject.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `PP Volume` 实体对象。
- en: Add the **Postprocessing | Vignette** effect by clicking on the **Add Override**
    button.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **添加覆盖** 按钮添加 **后期处理 | 晕影** 效果。
- en: Check the **Intensity** checkbox and set it to `0.3`, increasing the effect.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **强度** 复选框并将其设置为 `0.3`，以增强效果。
- en: 'Check the **Smoothness** checkbox and set it to `0.5`; this will increase the
    spread of the effect. You can see the result in the following figure:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **平滑度** 复选框并将其设置为 `0.5`；这将增加效果的扩散。你可以在下面的图中看到结果：
- en: '![](img/B21361_13_09_PE.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_09_PE.png)'
- en: 'Figure 13.9: Vignette effect'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9：晕影效果
- en: If you want, you can change the color by checking the **Color** checkbox and
    setting it to another value; in our case, black is okay to reinforce the rainy-day
    environment. Here, I invite you to check other properties, such as **Center**
    and **Rounded**. You can create nice effects just by playing with the values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以通过打开 **颜色** 复选框并设置另一个值来更改颜色；在我们的例子中，黑色可以很好地加强雨天环境。在这里，我邀请你检查其他属性，如 **中心**
    和 **圆角**。你只需调整数值就能创造出很好的效果。
- en: 'Another effect we are going to see is **Motion Blur**, and again, it simulates
    the way the cameras work. A real camera has an exposure time: the time it needs
    to capture photons in an image. When an object moves fast enough, the same object
    is placed in different positions during that brief exposure time, so it will appear
    blurred. In the following screenshot, you can see the effect applied to our scene.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的另一个效果是 **运动模糊**，同样，它模拟了相机的工作方式。真实的相机有一个曝光时间：它需要捕获图像中光子的时间。当一个物体移动得足够快时，在短暂的曝光时间内，同一个物体会放置在不同的位置，因此它会显得模糊。在下面的截图中，你可以看到效果已经应用于我们的场景。
- en: 'In the case of this image, we are moving the camera up and down fast, with
    the following result:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图像的情况下，我们快速上下移动相机，结果如下：
- en: '![](img/B21361_13_10_PE.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10](img/B21361_13_10_PE.png)'
- en: 'Figure 13.10: Motion Blur being applied to our scene'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10：将运动模糊应用于我们的场景
- en: One thing to consider is that this blur will only be applied to the camera movement
    and not the movement of the objects (still camera, moving objects), due to the
    fact that this URP doesn’t support motion vectors yet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一点是，这种模糊效果只会应用于相机移动，而不会应用于物体的移动（静止相机，移动物体），因为目前这个 URP 还不支持运动矢量。
- en: 'In order to use this effect, follow these next steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个效果，请按照以下步骤操作：
- en: Add the **Post-processing | Motion Blur** override with the **Add override**
    button.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **添加覆盖** 按钮添加 **后处理 | 运动模糊** 覆盖。
- en: Check the **Intensity** checkbox and set it to `0.25`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **强度** 复选框并将其设置为 `0.25`。
- en: 'Rotate the camera while looking at the **Game** view (not the **Scene** view).
    You can click and drag the **X** property of **Transform** of the camera (not
    the value—the **X** label), as illustrated in the following screenshot:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看 **游戏** 视图（而不是 **场景** 视图）的同时旋转相机。你可以点击并拖动相机的 **变换** 的 **X** 属性（不是值——**X**
    标签），如图下截图所示：
- en: '![](img/B21361_13_11_PE.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11](img/B21361_13_11_PE.png)'
- en: 'Figure 13.11: Changing rotation'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11：改变旋转
- en: As you can see, this effect cannot be seen in the **Scene** view, as well as
    other effects, so take that into account before concluding the effect is not working.
    Unity does this because it would be very annoying to have that effect while working
    in the scene.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种效果在 **场景** 视图中也看不到，以及其他效果，所以在得出效果不起作用的结论之前请考虑这一点。Unity 这样做是因为在场景中工作时有这种效果会很烦人。
- en: 'Finally, we are going to briefly discuss two simple effects, **Film Grain**
    and **White Balance**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要讨论两个简单效果，**胶片颗粒**和**白平衡**：
- en: 'The first is pretty simple: add it, set the intensity to `1`, and you will
    get the famous grain effect from old movies. You can set **Type** with a different
    number of sizes to make it more subtle or harsh.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步相当简单：添加它，将强度设置为 `1`，你将得到老电影中著名的颗粒效果。你可以通过设置不同的尺寸来调整 **类型**，使其更加微妙或强烈。
- en: The second one, **White Balance** allows you to change the color temperature,
    making colors warmer or cooler depending on how you configure it. In our case,
    we are working in a cold, dark scene, so you can add it and set the temperature
    to `-20` to adjust the appearance just slightly and improve the look and feel
    in this kind of scene.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个，**白平衡**允许你改变色温，根据你的配置使颜色变得更暖或更冷。在我们的案例中，我们正在处理一个寒冷、昏暗的场景，因此你可以添加它并将温度设置为
    `-20`，以略微调整外观并改善这种场景的外观和感觉。
- en: 'When I was learning how to make my own post-processing effects, I remember
    experimenting with a dream-like transition distortion effect. To do so, I used
    the sine mathematical function to calculate the amount of horizontal distortion
    to apply based on the vertical position of the pixels. After doing so, I saw my
    framerate drop heavily, and that was the moment I realized post-processing can
    be expensive. To be fair, it was an old PC, but still, the point holds. Be careful
    about the number of postprocessing effects you add, and learn about each one to
    see how to configure it properly. You can analyze the cost of the GPU with tools
    like PIX, which analyzes the GPU performance of your application: [https://devblogs.microsoft.com/pix/download/](https://devblogs.microsoft.com/pix/download/)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我学习如何制作自己的后处理效果时，我记得曾经尝试过一种梦幻般的过渡扭曲效果。为此，我使用了正弦数学函数来计算基于像素的垂直位置应用的水平扭曲量。这样做之后，我发现我的帧率大幅下降，那一刻我意识到后处理可能会很昂贵。公平地说，那是一台旧电脑，但仍然，这个观点是成立的。注意添加的后处理效果的数目，并了解每个效果，以了解如何正确配置它。你可以使用像
    PIX 这样的工具来分析 GPU 的成本，它分析应用程序的 GPU 性能：[https://devblogs.microsoft.com/pix/download/](https://devblogs.microsoft.com/pix/download/)
- en: Now that we have seen a few of the simple effects, let’s check out a few of
    the remaining ones that are affected by some advanced rendering features.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些简单效果，让我们来看看受一些高级渲染功能影响的剩余效果。
- en: Using advanced effects
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级效果
- en: 'Now we’re stepping up our game with some advanced effects. They’re a notch
    above what we’ve seen before, and a bit trickier, but don’t worry—we’ll guide
    you through them. In this section, we are going to see the following advanced
    effect concepts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在通过一些高级效果提升我们的水平。它们比我们之前看到的要高一个档次，也稍微复杂一些，但不用担心——我们会引导您了解它们。在本节中，我们将看到以下高级效果概念：
- en: High Dynamic Range (HDR) and Depth Map
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高动态范围（HDR）和深度图
- en: Applying advanced effects
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用高级效果
- en: Let’s start by discussing some requirements for some of these effects to work
    properly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一下这些效果正常工作所需的一些要求。
- en: High Dynamic Range (HDR) and depth map
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高动态范围（HDR）和深度图
- en: Remember the Depth Map from our last chapter? Some effects need more than just
    the rendered image; they require extra data like this to really shine. Some effects
    not only work with the rendered image but also need additional data. We can first
    discuss the Depth Map, a concept we discussed in previous chapters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们上一章提到的深度图吗？一些效果不仅需要渲染的图像，还需要像这样的额外数据才能真正发挥作用。有些效果不仅与渲染图像一起工作，还需要额外的数据。我们首先讨论深度图，这是一个我们在前几章讨论过的概念。
- en: 'A Depth Map is an image rendered from the point of view of the camera, but
    instead of generating a final image of the scene, it renders the scene objects’
    depth, rendering the objects in shades of gray. In a Depth Map, the rule is simple:
    the darker the shade, the further away the pixel is from the camera, and the lighter
    it is, the closer it is.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 深度图是从摄像机的视角渲染的图像，但它不是生成场景的最终图像，而是渲染场景对象的深度，以灰色阴影的形式呈现对象。在深度图中，规则很简单：阴影越深，像素离摄像机越远，越浅则越近。
- en: 'In the following screenshot, you can see an example of a Depth Map:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到深度图的一个示例：
- en: '![Image result for depth buffer](img/B21361_13_12_PE.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for depth buffer](img/B21361_13_12_PE.png)'
- en: 'Figure 13.12: Notice how the varying shades of gray depict the distance from
    the camera'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：注意灰色阴影的变化如何描绘出与摄像机的距离
- en: We will see some effects such as **Depth of Field**, which will blur some parts
    of the image based on the distance of the camera, but it can be used for several
    purposes on custom effects (not in the base URP package).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一些效果，例如**景深**，它将根据摄像机的距离模糊图像的某些部分，但可以在自定义效果（不在基础URP包中）的多个用途上使用。
- en: Another concept to discuss here that will alter how colors are treated and,
    hence, how some effects work is **High Dynamic Range** (**HDR**). In older hardware,
    color channels (red, green, and blue) were encoded in a 0 to 1 range, 0 representing
    no intensity and 1 representing full intensity (per channel), so all lighting
    and color calculations were done in that range. That seems okay but doesn’t reflect
    how light actually works. You can see full white (all channels set to 1) in a
    piece of paper being lit by sunlight, and you can see full white when you look
    directly at a light bulb, but even if both light and paper are of the same color,
    the latter will, firstly, irritate the eye after a while and, secondly, have some
    overglow due to an excess of light. The problem here is that the maximum value
    (1) is not enough to represent the most intense color, so if you have a high-intensity
    light and another with even more intensity, both will generate the same color
    (1 in each channel) because calculations cannot go further than 1\. To overcome
    these limitations and capture light more realistically, **HDR Rendering** was
    created.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要讨论的另一个概念将改变颜色的处理方式，从而影响一些效果的工作方式，那就是**高动态范围**（**HDR**）。在旧硬件中，颜色通道（红色、绿色和蓝色）被编码在0到1的范围内，0代表没有强度，1代表全强度（每个通道），因此所有光照和颜色计算都在这个范围内进行。这看起来似乎没问题，但并不反映光的实际工作方式。您可以在被阳光照亮的纸张上看到全白（所有通道都设置为1），您可以直接看灯泡看到全白，但即使光和纸张颜色相同，后者首先会在一段时间后刺激眼睛，其次，由于过多的光线会有一些溢光。这里的问题是最大值（1）不足以表示最强烈的颜色，所以如果您有一个高强度的光源和另一个强度更高的光源，两者都会生成相同的颜色（每个通道都是1），因为计算不能超过1。为了克服这些限制并更真实地捕捉光线，创建了**HDR渲染**。
- en: HDR is a way for colors to exceed the 0 to 1 range, so lighting and effects
    that work based on color intensity have better accuracy in this mode. Unity will
    do the calculations in HDR but the final image will still work using the previous
    color space (0 to 1, or **Low Dynamic Range (LDR**)), so don’t confuse Unity’s
    hdr rendering with the display’s hdr.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: HDR是一种让颜色超出0到1范围的方法，因此基于颜色强度工作的光照和效果在此模式下具有更好的准确性。Unity将在HDR模式下进行计算，但最终图像仍然会使用之前的光栅空间（0到1，或**低动态范围（LDR）**）进行工作，所以不要将Unity的HDR渲染与显示器的HDR混淆。
- en: 'For more information about HDR, check this link: [https://docs.unity3d.com/Manual/HDR.html](https://docs.unity3d.com/Manual/HDR.html)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HDR的更多信息，请查看此链接：[https://docs.unity3d.com/Manual/HDR.html](https://docs.unity3d.com/Manual/HDR.html)
- en: 'To convert the HDR calculations back to LDR, Unity (and also TVs) uses a concept
    called **tonemapping**. You can see an example of an LDR-rendered scene and tonemapping
    being used in an HDR scene in the following screenshots:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将HDR计算转换回LDR时，Unity（以及电视）使用了一个称为**色调映射**的概念。您可以在以下屏幕截图中看到一个LDR渲染的场景示例以及色调映射在HDR场景中的应用：
- en: '![](img/B21361_13_13_PE.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_13_PE.png)'
- en: 'Figure 13.13: An LDR-rendered scene (left) and an HDR scene with corrected
    overbrights using tonemapping (right)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13：LDR渲染的场景（左）和经过色调映射校正过度的HDR场景（右）
- en: Tonemapping is a way to convert colors outside the 0-1 light intensity range
    back inside this range to render them on LDR screens. It basically uses curves
    to determine how each color channel should be mapped back.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 色调映射是一种将超出0-1光强度范围的颜色转换回此范围以在LDR屏幕上渲染的方法。它基本上使用曲线来确定每个颜色通道应该如何映射回。
- en: 'Picture this: you’re stepping out from a dimly lit room into the glaring afternoon
    sun. That momentary blinding effect and gradual adjustment is HDR at work. It’s
    like stepping out into bright sunlight from a dark room; at first, everything
    is too bright, but gradually, your eyes adjust—that’s tonemapping in action. The
    idea here is that calculations are not different when you are inside or outside
    the building; a white wall inside the building will have a color close to 1 intensity,
    while the same white wall outside will have a higher value (due to sunlight).
    The difference is that tonemapping will take the higher-than-1 color back to 1
    when you are outside the building, and maybe it will increase the lighting of
    the wall inside if the whole scene is darker, depending on how you set it. That
    feature is called **auto-exposure**.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：你正从昏暗的房间走出，进入刺眼的午后阳光。那一刻的耀眼效果和逐渐调整就是HDR在起作用。这就像从黑暗的房间走到明亮的阳光下；一开始，一切都很亮，但渐渐地，你的眼睛适应了——这就是色调映射的作用。这里的想法是，无论你在室内还是室外，计算都是一样的；室内的白墙将有接近1的强度颜色，而室外的同一堵白墙将有更高的值（由于阳光）。区别在于，当你在室外时，色调映射会将高于1的颜色调整回1，如果整个场景较暗，它可能会根据你的设置增加墙面的光照。这个功能被称为**自动曝光**。
- en: 'Even if HDR is enabled by default, let’s just see how we can verify if it is
    by doing the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使HDR默认启用，我们也可以通过以下步骤来验证它：
- en: Go to **Edit | Project Settings**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**编辑 | 项目设置**。
- en: Click on the **Graphics** section in the left panel.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中单击**图形**部分。
- en: Click the asset referenced under the **Scriptable Render Pipeline Settings**
    property.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**可脚本渲染管线设置**属性下的引用资产。
- en: Click on the highlighted asset in the **Project** panel. Ensure that this panel
    is visible before clicking the property in the **Graphics** settings. Alternatively,
    you can double-click the asset reference in the **Graphics** settings to select
    it.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中单击突出显示的资产。在单击**图形**设置中的属性之前，请确保此面板是可见的。或者，您可以在**图形**设置中双击资产引用以选择它。
- en: 'Under the **Quality** section, ensure that **HDR** is checked, as illustrated
    in the following screenshot:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**质量**部分下，确保已勾选**HDR**，如图所示：
- en: '![](img/B21361_13_14_PE.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_14_PE.png)'
- en: 'Figure 13.14: Enabling HDR'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：启用HDR
- en: Ensure that the **HDR Rendering** property of the **Camera** component in the
    **Main Camera** GameObject is set to **Use settings from Render Pipeline** to
    ensure the change in the previous steps is respected.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**主相机**游戏对象的**相机**组件的**HDR渲染**属性设置为**使用渲染管线设置**，以确保上一步骤中的更改得到尊重。
- en: Of course, the fact that HDR is togglable means that there are scenarios where
    you don’t want to use it. As you can guess, not all hardware supports HDR, and
    using it incurs a performance overhead, so take that into account. Luckily, most
    effects work with both HDR and LDR color ranges, so if you have HDR enabled but
    the user device doesn’t support it, you won’t get any errors, just different results
    depending on the effect, such as brighter or darker images, or exaggerated effects,
    as we will see in the next section, *Applying advanced effects*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，HDR可切换的事实意味着存在一些你不想使用HDR的场景。正如你所猜想的，并非所有硬件都支持HDR，使用它会导致性能开销，所以请考虑这一点。幸运的是，大多数效果都支持HDR和LDR色彩范围，所以如果你启用了HDR但用户设备不支持，你不会收到任何错误，只是效果根据效果而有所不同，例如图像更亮或更暗，或者夸张的效果，就像我们在下一节*应用高级效果*中将要看到的那样。
- en: Now that we are sure we have HDR enabled, let’s explore some advanced effects
    that use this and depth mapping.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信已经启用了HDR，让我们探索一些使用HDR和深度映射的高级效果。
- en: Applying advanced effects
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用高级效果
- en: Let’s see certain effects that use the previously described techniques, starting
    with the commonly used **Bloom**. This effect emulates the overglow that happens
    around a heavily lit object on a camera lens or even the human eye. In *Figure
    13.15*, you can see the difference between the default version of our scene and
    an exaggerated Bloom version.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用之前描述的技术的一些效果，从常用的**Bloom**开始。此效果模拟了在相机镜头或甚至人眼周围一个强光照射物体上的溢光。在*图13.15*中，你可以看到我们场景的默认版本和夸张的Bloom版本之间的区别。
- en: 'You can observe how the effect is only applied to the brightest areas of our
    scene. Have a look at both effects here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到效果只应用于场景中最亮的部分。看看这两个效果：
- en: '![](img/B21361_13_15_PE.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_15_PE.png)'
- en: 'Figure 13.15: The default scene (left) and the same scene with a high-intensity
    Bloom (right)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15：默认场景（左）和具有高亮度Bloom的相同场景（右）
- en: 'This effect is actually very common and simple, but I consider it advanced
    because the results are drastically affected by HDR. This effect relies on calculating
    the intensity of each pixel’s color to detect areas where it can be applied. In
    LDR, we can have a white object that isn’t overbright, but due to the limitations
    in this color range, Bloom may cause an overglow over it. In HDR, due to its increased
    color range, we can detect if an object is white or if the object is maybe light
    blue but just overbright, generating the illusion that it is white (such as objects
    near a high-intensity lamp). In *Figure 13.16,* you can see the difference between
    our scene with HDR and without it. You will notice that the LDR version will have
    overglow in areas that are not necessarily overbright. The difference may be very
    subtle, but pay attention to the little details to note the difference. And remember,
    I exaggerated the effect here. Have a look at both scenes here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果实际上非常常见且简单，但我认为它是高级的，因为结果会受到HDR的极大影响。此效果依赖于计算每个像素颜色的强度来检测可以应用该效果的区域。在LDR中，我们可以有一个不是过亮的白色物体，但由于此色彩范围的限制，Bloom可能会在其上产生溢光。在HDR中，由于其增加的色彩范围，我们可以检测到物体是否为白色，或者物体可能是浅蓝色但只是过亮，从而产生它是白色的错觉（例如靠近高亮度灯的物体）。在*图13.16*中，你可以看到带有HDR和无HDR的场景之间的区别。你会注意到LDR版本将在不一定过亮的区域产生溢光。差异可能非常微妙，但请注意细节以注意差异。并且记住，我在这里夸张了效果。看看这两个场景：
- en: '![](img/B21361_13_16_PE.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_16_PE.png)'
- en: 'Figure 13.16: Bloom in an LDR scene (left) and Bloom in an HDR scene (right).
    Notice that the Bloom settings were changed to try to approximate them as much
    as possible'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16：LDR场景中的Bloom（左）和HDR场景中的Bloom（右）。注意，Bloom设置被更改以尽可能接近它们
- en: 'For now, let’s stick with the HDR version of the scene. In order to enable
    Bloom, do the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们继续使用场景的HDR版本。为了启用Bloom，请执行以下操作：
- en: Add the **Bloom** override to the profile, as usual.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照惯例，将**Bloom**覆盖添加到配置文件中。
- en: Enable the **Intensity** checkbox by checking it, and set the value to `0.2`.
    This controls how much overglow will be applied.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过勾选复选框启用**强度**选项，并将值设置为`0.2`。这控制了将应用多少溢光。
- en: Enable **Threshold** and set it to `0.7`. This value indicates the minimum intensity
    a color needs to have to be considered for overglow. In our case, our scene is
    somewhat dark, so we need to reduce this value in the **Bloom** effect settings
    to have more pixels included. As usual, those values need to be adjusted to your
    specific scenario.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**阈值**并将其设置为`0.7`。这个值表示颜色需要达到的最小强度，才能被认为是溢光。在我们的案例中，我们的场景有些昏暗，因此我们需要在**光晕**效果设置中降低这个值，以便包含更多的像素。像往常一样，这些值需要根据你的具体场景进行调整。
- en: 'You will notice that the difference is very subtle, but again, remember that
    you will have several effects, so all those little differences will add up. You
    can see both effects in the following screenshots:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到差异非常微妙，但再次提醒，你会拥有几个效果，所以所有这些细微的差异都会累积起来。你可以在以下屏幕截图中看到这两种效果：
- en: '![](img/B21361_13_17_PE.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_17_PE.png)'
- en: 'Figure 13.17: Bloom effect'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17：光晕效果
- en: As usual, it is recommended that you fiddle with other values. Some interesting
    settings I recommend you test are the **Dirt Texture** and **Dirt Intensity**
    values, which will simulate dirty lenses in the overglow area.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，建议你调整其他值。我推荐你测试的一些有趣的设置是**污渍纹理**和**污渍强度**值，这将模拟溢光区域的脏镜头。
- en: Building on our understanding of Depth Maps, let’s explore another popular effect,
    **Depth of Field**. This one relies on the Depth Map we discussed earlier. It
    is not that obvious to the naked eye, but when you focus on an object within your
    sight, the surrounding objects become blurred because they are out of focus. We
    can use this to focus the attention of the player in key moments of gameplay.
    Think of this effect like a camera’s autofocus – it samples the Depth Map to decide
    what should be crisp and what should be blurred, much like focusing on an object
    in photography.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对深度图的理解基础上，让我们探索另一个流行的效果，**景深**。这个效果依赖于我们之前讨论过的深度图。它对肉眼来说并不明显，但当你聚焦于你视野中的某个对象时，周围的物体因为不在焦点上而变得模糊。我们可以利用这一点来在游戏的关键时刻吸引玩家的注意力。想象这个效果就像相机的自动对焦一样——它采样深度图来决定什么应该是清晰的，什么应该是模糊的，就像在摄影中对物体进行对焦一样。
- en: 'In order to use it, do the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，请按照以下步骤操作：
- en: 'Put the camera near a column to try to focus on a specific object, as illustrated
    in the following screenshot:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将摄像机靠近一根柱子，尝试聚焦于一个特定对象，如下面的截图所示：
- en: '![](img/B21361_13_18_PE.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_18_PE.png)'
- en: 'Figure 13.18: Camera positioning'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18：摄像机定位
- en: Add the **Depth of Field** override.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**景深**覆盖。
- en: 'Enable and set the **Mode** setting to **Gaussian**: the cheapest one in terms
    of performance used.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用并设置**模式**设置为**高斯**：在性能方面最经济的选项。
- en: In my case, I have set **Start** to `10` and **End** to `20`, which will make
    the effect start at a distance behind the target object. The **End** setting will
    control how the blur’s intensity will increase, reaching its maximum at a distance
    of `20` meters. Remember to tweak these values to your case.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的案例中，我将**开始**设置为`10`，将**结束**设置为`20`，这将使效果在目标物体后方一定距离开始。**结束**设置将控制模糊强度的增加，在`20`米处达到最大。请记住根据你的情况调整这些值。
- en: 'If you want to exaggerate the effect a little bit, set **Max Radius** to `1.5`.
    The result is shown in the following screenshot:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想稍微夸张一下效果，将**最大半径**设置为`1.5`。结果如下面的截图所示：
- en: '![](img/B21361_13_19_PE.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_13_19_PE.png)'
- en: 'Figure 13.19: Exaggerated effect'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19：夸张效果
- en: Something to consider here is that our game will have a top-down perspective,
    and unlike the first-person camera where you can see distant objects, here, we
    will have objects near enough to not notice the effect, so we can limit the use
    of this effect just for cutscenes in our scenario.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的是，我们的游戏将采用俯视视角，并且与第一人称摄像机不同，你可以看到远处的物体，在这里，我们将有足够近的物体，以至于不会注意到效果，因此我们可以将此效果仅限于我们场景中的过场动画。
- en: 'Now, most of the remaining effects are different ways to alter the actual colors
    of the scene. The idea is that the real color sometimes doesn’t give you the exact
    look and feel you are seeking. You may need the dark zones to be darker to reinforce
    the sensation of a horror ambiance, or you may want to do the opposite: increase
    the dark areas to represent an open scene. It could also be that you want to tint
    the highlights a little bit to get a neon effect if you are creating a futuristic
    game, or perhaps you want a sepia effect temporarily to do a flashback. We have
    a myriad of ways to do this, and in this case, I will use a simple but powerful
    effect called **Shadows Midtones Highlights**.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数剩余的效果都是改变场景实际颜色的不同方式。想法是，实际颜色有时并不能给你你寻求的确切外观和感觉。你可能需要将暗区调得更暗以增强恐怖氛围的感觉，或者你可能想相反：增加暗区以表示一个开阔的场景。也可能你想要将高光稍微着色以获得霓虹效果，如果你正在创建一个未来派游戏，或者你可能想要暂时使用棕褐色效果来做一个闪回。我们有很多种方法来做这件事，在这种情况下，我将使用一个简单但强大的效果，称为**阴影
    中间调 高光**。
- en: 'This effect will apply different color corrections to—well—shadows, midtones,
    and highlights, meaning that we can modify darker, lighter, and medium areas separately.
    Let’s try it by doing the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果将对阴影、中间调和高光应用不同的颜色校正，这意味着我们可以分别修改暗部、亮部和中等区域。让我们通过以下步骤尝试一下：
- en: Add the **Shadow Midtones Highlights** override.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**阴影 中间调 高光**覆盖。
- en: Let’s start doing some testing. Check the three **Shadows**, **Midtones**, and
    **Highlights** checkboxes.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始进行一些测试。检查三个**阴影**、**中间调**和**高光**复选框。
- en: 'Move the **Shadows** and **Midtones** sliders all the way to the left and the
    one for **Highlights** to the right. This will reduce the intensity of shadows
    and midtones and increase the intensity of highlights. We did this so that you
    can see the areas that **Highlights** will alter, based on the intensity. You
    can do the same with the other sliders to check the other two areas. You can see
    the result in the following screenshot:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**阴影**和**中间调**滑块全部移到最左边，将**高光**滑块移到最右边。这将减少阴影和中间调的强度，并增加高光的强度。我们这样做是为了让你可以看到高光将根据强度改变的区域。你可以用其他滑块做同样的操作来检查其他两个区域。你可以在下面的屏幕截图中看到结果：
- en: '![](img/B21361_13_20_PE.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_20_PE.png)'
- en: 'Figure 13.20: Isolating highlights'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.20：隔离高光
- en: 'Also, test moving the white circle at the center of the colored circle to apply
    a little bit of tinting to those areas. Reduce the intensity of the highlights
    by moving the slider a little bit to the left to make the tinting more noticeable.
    You can see the result in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，测试将彩色圆圈中心的白色圆圈移动以对这些区域应用一点着色。通过将滑块稍微向左移动来减少高光的强度，使着色更明显。你可以在下面的屏幕截图中看到结果：
- en: '![](img/B21361_13_21_PE.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_21_PE.png)'
- en: 'Figure 13.21: Tinting highlights'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.21：着色高光
- en: 'By doing this, you can explore how those controls work, but of course, those
    extreme values are useful for some edge cases. In our scene, the settings you
    can see in the following screenshot worked best for me. As always, it is better
    to use subtler values to not distort the original result too much, as illustrated
    here:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样做，你可以探索这些控件是如何工作的，但当然，这些极端值对于某些边缘情况是有用的。在我们的场景中，以下屏幕截图中的设置对我来说效果最好。和往常一样，使用更微妙的值更好，这样不会过度扭曲原始结果，如下所示：
- en: '![](img/B21361_13_22.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_22.png)'
- en: 'Figure 13.22: Subtle changes'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22：细微变化
- en: 'You can see the before-and-after effects in the following screenshots:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的屏幕截图中看到前后效果：
- en: '![](img/B21361_13_23_PE.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_13_23_PE.png)'
- en: 'Figure 13.23: Before-and-after effects'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.23：前后效果
- en: 'If you’re looking for something less complex than HDR, **Split Toning** offers
    a simpler yet effective way to play with shadows and highlights, or **Color Curves**,
    which give you advanced control of how each color channel of the scene will be
    mapped, but the idea is the same: to alter the actual color of the resulting scene
    to apply a specific color ambiance to your scene. If you remember the movie series
    *The Matrix*, when the characters were in the Matrix, everything had subtle green
    tinting, and while outside it, the tinting was blue.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你寻找的比HDR更简单的效果，**分割色调**提供了一种更简单但有效的方法来玩阴影和高光，或者**颜色曲线**，它让你可以更高级地控制场景中每个颜色通道的映射，但想法是相同的：改变最终场景的实际颜色，以给你的场景应用特定的颜色氛围。如果你记得电影系列《黑客帝国》，当角色在矩阵中时，一切都有细微的绿色着色，而在外面时，着色是蓝色。
- en: Remember that the results of using HDR and not using it regarding these effects
    are important, so it is better to decide sooner rather than later whether to use
    HDR, excluding certain target platforms (which may not be important to your target
    audience), or not to use it (using LDR) and have less control over your scene
    lighting levels.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用HDR和不使用HDR对这些效果的结果很重要，因此最好是尽早而不是稍后决定是否使用HDR，排除某些目标平台（这可能对你的目标受众并不重要），或者不使用HDR（使用LDR）并减少对场景光照级别的控制。
- en: Also, take into account that maybe you will need to tweak some objects’ settings,
    such as light intensities and material properties, because sometimes we use post-processing
    to fix graphics errors that may be caused by wrongly set objects, and that’s not
    okay. For example, increasing the `ambient lighting` in our scene will drastically
    change the output of the effects, and we can use that to increase the overall
    brightness instead of using an effect if we find the scene too dark.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑到你可能需要调整一些对象的设置，例如光照强度和材质属性，因为有时我们会使用后期处理来修复由设置错误的对象引起的图形错误，这是不可接受的。例如，增加场景中的`环境光照`将极大地改变效果输出，如果我们发现场景太暗，我们可以利用这一点来提高整体亮度，而不是使用效果。
- en: We’ve now covered a range of image effects. Remember, the idea is not to use
    every single one but to use the ones that you feel are contributing to your scene;
    they are not free in terms of performance (although not that resource-intensive),
    so use them wisely. Also, you can check for the already created profiles to apply
    them to your game and see how little changes can make a huge difference.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了一系列图像效果。记住，理念不是使用每一个，而是使用你认为有助于你场景的效果；它们在性能方面不是免费的（尽管不是那么资源密集），所以要明智地使用。此外，你可以检查已经创建的配置文件，并将它们应用到你的游戏中，看看微小的变化可以带来巨大的差异。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed basic and advanced full screen effects to apply
    in our scene, making it look more realistic in terms of camera lens effects and
    more stylish in terms of color distortions. We also discussed the internals of
    HDR and Depth Maps and how they are important when using those effects, which
    can immediately increase your game’s graphic quality with minimal effort.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在场景中应用的基本和高级全屏效果，使场景在相机镜头效果方面看起来更真实，在色彩扭曲方面更时尚。我们还讨论了HDR和深度图的内部结构以及它们在使用这些效果时的重要性，这些效果可以以最小的努力立即提高你游戏的图形质量。
- en: Now that we have covered most of the common graphics found in Unity systems,
    let’s start looking at how to increase the immersion of our scene by using sounds
    in the next chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了Unity系统中常见的图形效果，接下来让我们看看如何在下一章中通过使用声音来提高场景的沉浸感。
- en: Learn more on Discord
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。提问，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1498477041053909218.png)'
