- en: Chapter 4. Advanced Thread Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue to learn about the `Thread` class and thread
    processing. In the previous chapter, we began discussing the `Thread` class and
    how to create and use threads. Now that we have begun learning about the `Thread`
    class, in this chapter we will take the discussion to the next level. We''ll study
    new ways to keep control over concurrent threads and will continue to improve
    our parallel programming capabilities working with more challenging problems to
    solve. After following the instructions in this chapter, we will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Break down a problem into pieces that can be run concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create highly independent blocks of code to run in multiple threads avoiding
    many concurrency problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use flags in multiple threads for coordination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use techniques to have complete control over asynchronous and synchronous execution
    of threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use techniques to use multithreading in non-thread-safe components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform error handling in a multithreaded application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipelining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipelining is a common design pattern used in multithreaded applications. In
    [Chapter 9](ch09.html "Chapter 9. Pipeline and Producer-consumer Design Patterns"),
    *Pipeline and Producer-consumer Design Patterns*, we will cover this in detail.
    But I wanted to briefly introduce it here, because we will use it in the examples
    in this chapter. Pipelining is a technique to solve a problem using concurrency.
    First, you divide the problem into parts that have to be executed in sequence
    with parts that can be executed in parallel. Then you implement the parallel parts
    using threads or tasks and run them concurrently to improve performance instead
    of running all of the functionality in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have worked with the `BackgroundWorker` component and the `Thread`
    class to create multithreaded applications. Parallel programming allowed us to
    achieve incredible performance enhancements and better UI feedback. How can we
    use threading and the `Thread` class to divide image-processing algorithms into
    many concurrent blocks of code? In this design pattern, we will take a problem,
    divide it into multiple pieces that we can tackle concurrently, and then assemble
    the pieces in the end to a final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 9](ch09.html "Chapter 9. Pipeline and Producer-consumer Design
    Patterns"), *Pipeline and Producer-consumer Design Patterns*, we will learn different
    common design patterns for tackling common problems in a multithreaded approach.
    But without going into too much detail, in this chapter, we will perform a simple
    form of pipelining to accomplish our task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipelining](img/8321EN_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: C# offers many techniques for working with images and bitmaps. However, many
    of them are not thread-safe. We cannot run many concurrent threads changing pixels
    in the same instance of the `Bitmap` (`System.Drawing.Bitmap`) class. Nevertheless,
    as we learned in the previous chapters, in order to apply parallel algorithms,
    we can avoid the problems instead of finding difficult solutions to them by using
    different design patterns such as **pipelining**. We can split the original bitmap
    into a number of completely independent bitmaps. Each thread can work with its
    independent bitmap instance safely. We can develop an algorithm that performs
    image manipulation of bitmap pixels and then, with great performance improvements
    over the single-threaded one, perform this algorithm in parallel on many bitmaps.
    Besides, we can also add code to pause and then restart the threads. The performance
    results will depend upon the number of cores or processors available in the computer
    (which we discussed in [Chapter 1](ch01.html "Chapter 1. Understanding Multiprocessing
    and Multiple Cores"), *Understanding Multiprocessing and Multiple Cores*) in which
    we run the application.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `Thread` class and the pipelining design pattern, we can achieve
    incredible performance improvements, an impressive user experience, and great
    scalability with reasonable programming efforts. The application we will build
    will be scalable to any size bitmap image and will be able to increase performance
    automatically as more core processors are added to the hardware without any coding
    changes!
  prefs: []
  type: TYPE_NORMAL
- en: Explaining pipelining using an image processing application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example in this chapter, we will use a Windows Forms application to
    perform image processing. We can do this in a **Windows Presentation Foundation**
    (**WPF**) application, but I find that doing bitmap and pixel-level manipulation
    is more straightforward in the GDI-based `System.Drawing` library than the WPF-based
    System, Windows Media library. This same application can be redone using the `BitmapImage`
    and `CroppedBitmap` classes using the same core logic.
  prefs: []
  type: TYPE_NORMAL
- en: Image processing on large image files is a good candidate for a multithreaded
    solution because you can break the image into pieces and process each piece concurrently
    and then reassemble the pieces. In this example, we will take a bitmap image from
    NASA, break it into smaller bitmap files, search each bitmap for "old star", and
    then reassemble the bitmaps back into one large bitmap image file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use your parallel programming skills to develop an application that
    has to detect the older stars from huge infrared portraits obtained by NASA''s
    Spitzer Space Telescope. In the following screenshot, you can see a wispy star-forming
    region, called **W5**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explaining pipelining using an image processing application](img/8321EN_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image by NASA/JPL-Caltech/Harvard-Smithsonian CfA
  prefs: []
  type: TYPE_NORMAL
- en: In this portrait, the oldest stars can be seen as blue dots, especially in the
    center of the two hollow cavities. The white knotty areas are where the youngest
    stars are forming.
  prefs: []
  type: TYPE_NORMAL
- en: This image contains some of the best evidence yet for the triggered star formation
    theory. Scientists analyzing the photo have been able to show that the ages of
    the stars become progressively and systematically younger with distance from the
    center of the cavities.
  prefs: []
  type: TYPE_NORMAL
- en: You have to work on a very fast and efficient algorithm for detection of old
    stars, capable of changing the pixel colors of the old stars in the huge image
    to make them more visible to the scientists. They want you to use a fine-tuned,
    multithreading application that is capable of working with as many threads as
    the number of cores available in the computer where the star detection algorithm
    is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do this, we are going to build a new C# application and put the program
    logic into methods to detect old stars in any bitmap and prepare the bitmap input
    for many threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# project using the Windows Application template in Visual Studio.
    Use `OldStarsFinder` as the project's name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code at the beginning of the form class definition
    (as we are going to use the `System.Threading.Thread` and `System.Drawing.Imaging`
    classes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines in the form class definition to declare three new private
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, `CropBitmap`. It will crop the bitmap received
    as a parameter and return the portion of the original defined by the `Rectangle`
    instance, `proRectangle`. This will allow us to split up any large image into
    a set of smaller images. The number in the set will correspond to the number of
    cores in the machine the application is running. This way we can maximize performance
    by using every core simultaneously to process the large image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, `IsOldStar`. It will compare the pixel hue, saturation,
    and brightness to determine if their levels correspond to the typical color range
    offered by an old star in the infrared portraits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following procedure, `ThreadOldStarsFinder`. It will iterate through
    each pixel in the corresponding bitmap for the thread that launches it and count
    the old stars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code required to find and count the potential old stars in any large bitmap
    portrait is now held in named functions and procedures, already prepared for dynamically
    created concurrent threads. We have laid the groundwork to implement this function
    in a Pipeline design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we have to create a `CropBitmap` function? That is because we cannot
    access a single `Bitmap` instance pixel matrix from many different concurrent
    threads. If we do so, we will get an `InvalidOperationException`, as GDI+ is not
    prepared for multithreaded access.
  prefs: []
  type: TYPE_NORMAL
- en: We must split the original `Bitmap` into as many independent portions as the
    number of concurrent threads that will be working on it. The `CropBitmap` function
    will allow us to obtain a specific portion of a `Bitmap` instance and generate
    a list of new `Bitmap` instances (`prloBitmapList`).
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned so far, there are many problems related to multithreaded
    applications and parallel algorithms. Since there are many threads running concurrently,
    we must be very careful when changing the values of variables in different threads.
    The best solution to such concurrency problems is *avoiding them* or preventing
    them via **synchronization mechanisms**. However, synchronization mechanisms have
    to be used very carefully, because they can decrease performance and generate
    too many context switches. Also, using them can introduce potential bugs that
    can be very difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: How can we avoid the concurrency problems? It is very simple. As much as possible,
    we have to make each thread independent of the other concurrent threads working
    in the same global portion of resources. As we will see in later chapters, the
    Task Parallel Library is convenient for defining tasks and then running the tasks
    in parallel. In this case, the processing of each bitmap can be a task.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the original bitmap using the simple `CropBitmap` function avoids
    many conflicts related to concurrency that would have otherwise been very complex
    to troubleshoot. As each thread is going to work with its own bitmap, we are avoiding
    a potentially dangerous problem. This is one of the keys to developing multithreaded
    applications—properly segmenting work into pieces that can run in parallel. Dividing
    the bitmap image is a perfect example.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential problem is counting the total number of old stars detected
    in the huge infrared bitmap portrait. If we used a shared member variable, we
    might have locking problems. If we have many threads concurrently changing the
    same variable value (at the same time), we will have to lock that variable each
    time its value is incremented. Locking a variable implies context switches and
    hence reduced performance. For this reason, we use the `long` list `prliOldStarsCount`.
    There is one counter for each thread, and we will obtain the total sum adding
    the *n* long values (`prliOldStarsCount`) to a new variable (where *n* is the
    number of star finder threads).
  prefs: []
  type: TYPE_NORMAL
- en: This way, we avoid locks as each thread has its own independent counter and
    we achieve a better performance compared to a solution that would use the confusing
    and complex locks.
  prefs: []
  type: TYPE_NORMAL
- en: In order to process an image in many concurrent threads, we must divide it into
    as many independent portions as the number of threads that will be running. As
    we have seen earlier, the `CropBitmap` function offers this utility.
  prefs: []
  type: TYPE_NORMAL
- en: This change in the image processing algorithm has its costs, and is not free.
    In this case, we will be counting stars on a per-pixel basis. However, when we
    must apply other more complex algorithms, we must consider many important additional
    changes to the basic code. We will continue with this topic later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once each image part is processed, we must collect the results and recompose
    the original image with the changes made to its pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the pixels' color compositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The infrared bitmap portrait does not have an exact blue (red = 0, green = 0,
    and blue = 255) color for an old star. There is a complex technique used to determine
    a star's age according to color ranges. This is easy to understand for human beings,
    but difficult for computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is simple to generate an algorithm obtaining the following three
    components of a `Color` (`System.Drawing.Color`) instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hue**: This is obtained by the `GetHue()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saturation**: This is obtained by the `GetSaturation()` method (from 0.01
    to 1.00)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brightness**: This is obtained by the `GetBrightness()` method (from 0.01
    to 1.00)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using these color components, we can apply the following rules to determine
    whether a pixel in the infrared bitmap portrait corresponds to a potential old
    star or not:'
  prefs: []
  type: TYPE_NORMAL
- en: Hue is between 150 and 258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saturation is more than 10% (0.10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brightness is more than 90% (0.90)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to work with hue, saturation, and brightness values than with red,
    green, and blue values in order to determine an old star.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IsOldStar` function receives a `Color` instance as a parameter and returns
    the results of applying the aforementioned rules to its hue, saturation, and brightness,
    as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function is called for each pixel in the infrared bitmap portrait, and
    it returns a `bool` value.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and restarting threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important in a lot of cases to coordinate and wait on threads. Take, for
    example, a pipelining design. Once we start a group of concurrent threads, we
    then need to wait on them all to finish, collate their results, and move onto
    the nonconcurrent section. We need to know when threads finish and what their
    results are, so we can determine how to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to coordinate and wait between threads. In the following
    example, we will show how you can check to see if a thread is still alive and
    processing and then wait on all of the threads to complete their bitmap processing
    work before we continue the rest of the application and reassemble the bitmap
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use the `IsAlive` method to check the thread and then
    pause the main thread with the `Sleep` method for a period of time before checking
    again. This is a common design pattern to coordinate work between threads and
    monitor threads to know when they are finished.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are going to create the UI and make some changes to create multiple
    threads dynamically to process each portion of a bitmap. In order to accomplish
    this, we must share data between the various threads, as we learned in the previous
    chapters. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Stay in the project, `OldStarsFinder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Windows Form, `Form1` (`frmStarsFinder`), in the form designer; add the
    following controls and align them as shown in the following screenshot:![How to
    do it](img/8321EN_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the controls:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One picture box (`picStarsBitmap`) showing one of the infrared portraits obtained
    by NASA's Spitzer Space Telescope (you can find many of them at [www.nasa.gov](http://www.nasa.gov)
    or [http://www.nasa.gov/multimedia/imagegallery/](http://www.nasa.gov/multimedia/imagegallery/)),
    with its `SizeMode` property set to `StretchImage`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One button showing a star and its `Text` property set to `Find old star` (`butFindOldStars`).
    This button will start multiple old stars finder threads.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following lines in the form''s class definition to declare two new
    private variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following procedure, `WaitForThreadsToDie`. It will make the main thread
    sleep in order to wait until the many concurrent threads finish their work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following procedure, `ShowBitmapWithOldStars`. It will rebuild the
    bitmap adding each previously separated portion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event in the button, `butFindOldStars`, and enter the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Old Star Finder** button. After a few seconds (depending on the
    parallel processing capabilities of the computer) in the W5 wispy star-forming
    region, a huge infrared portrait will be shown with its probable old stars in
    pure blue, as shown in the following screenshot:![How to do it](img/8321EN_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Old Star Finder** button, the process executes
    in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: The original image is divided into many independent bitmaps. Each portion will
    be assigned to a different thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many threads are created and then started (executed asynchronously) with a parameter
    so that they know which bitmap belongs to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main thread waits until all the star finder threads finish their work, sleeping
    100 milliseconds in each query of the threads' state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the threads finish their work, the main thread (the only one capable
    of touching the UI) rebuilds the divided bitmap and shows it in the picture box
    control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each thread works in its independent block, without disturbing or interfering
    with the other threads.
  prefs: []
  type: TYPE_NORMAL
- en: The code used to divide the original bitmap dynamically into many smaller bitmaps
    is a bit complex. That is the price we have to pay for the performance enhancement
    and scalability of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line obtains a `Bitmap` instance from the `picStarsBitmap` picture box
    (we begin decoupling the UI, as we cannot touch it from independent threads):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines create the thread list, the `long` numbers list, and the bitmap
    list in order to let them grow dynamically at runtime depending on the number
    of available cores in the computer where the application runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We must create bitmaps corresponding to the the number of cores available. We
    use the rows to select a similar number of rows for each bitmap portion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a variable `liStartRow` of type `int` as the starting row from where
    we will begin cropping the original bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must determine the approximate number of rows for each bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, depending on the number of cores and the original bitmap height, the
    result of this division might not be exact. That is another problem. Therefore,
    we use another `int` variable to calculate the height to be added to each iteration
    to solve that problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the algorithm is simple; for each iteration of `liThreadNumber` do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the height calculated for each bitmap is greater than the height to be added
    (this could happen in the last bitmap portion to be cropped), we reduce this number
    from the height to be added, which is the result of this line in each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Besides, in each iteration, the starting row increases the height calculated
    for each bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of applying this algorithm to the
    infrared portraits obtained by NASA''s Spitzer Space Telescope with four threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using our classic C# programming skills, we can generate smart algorithms to
    split the work into many independent blocks of safe concurrent code. Again, mastering
    the lists is indeed necessary in parallel programming.
  prefs: []
  type: TYPE_NORMAL
- en: Signals between threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help in coordinating the activity between the multiple threads, we can create
    variables accessible to the whole class and hence each thread. Then the threads
    can write to and read from these variables to help them coordinate activity and
    to keep overall track of what is happening between all of the threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use threads with parameters, as we learned in the previous chapters, and
    start them with an asynchronous execution using the following loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Nevertheless, we must wait until the concurrent star finder threads finish their
    work in order to show the final modified bitmap in the UI. We do not want to use
    the `BackgroundWorker` component.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we created the `WaitForThreadsToDie` procedure, which is called
    synchronously by the main application's thread. When this method returns, we can
    safely show the resulting bitmap in the UI because all the threads have finished
    their work. Of course, to achieve the same goal, we can also use the `BackgroundWorker`
    component combined with the threads created as instances of the `Thread` class,
    as we learned in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `WaitForThreadsToDie` procedure is complex because we have to
    check for each created thread and we know the number of threads at runtime, as
    they are dynamically aligned with the number of available cores. We use a `bool`
    flag to determine whether the `while` loop must go on running or not. However,
    in this case, we did not change the value of the flag, but there are other cases
    in which this code pattern could be useful to modify the value of this variable
    used as a flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in the `while` loop (`lbContinue`), we must check for each thread to finish
    its work. We use the well-known `IsAlive` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If one thread is alive, we will exit the `for` loop. If all the threads are
    not alive, `liDeadThreads` will equal the total number of created threads. Hence,
    we will exit the outer loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `break;` statement could be replaced by `lbContinue = false;` and we would
    achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is still a thread running, we call the `Sleep` method for the main
    thread and make it sleep for 100 milliseconds (0.1 seconds), and then reset the
    `liDeadThreads` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The line with the call to the `Sleep` method is indispensable.
  prefs: []
  type: TYPE_NORMAL
- en: Using methods like these, and flags, we can have complete control over independent
    threads, without causing the classic problems related to concurrency and the loss
    of control over the independent threads.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, when the call to the `WaitForThreadsToDie` method returns,
    we can safely show the resulting bitmap in the UI because all the threads have
    finished their work. Hence, we call the `ShowBitmapWithOldStars` procedure.
  prefs: []
  type: TYPE_NORMAL
- en: This method reproduces the work done when dividing the original bitmap into
    several independent portions, but in the reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We repeat the height calculation process explained previously. Then, we must
    create a new bitmap with the whole width and height. This bitmap must hold the
    different portions aligned as they were extracted from the original bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we use the `Bitmap` constructor passing the original bitmap width
    and height as parameters to define its size. Then, we create a `Graphics` instance
    from the `Bitmap` typecast to an `Image` (the `Bitmap` class is a descendant of
    the `Image` class).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the `Graphics` instance, we must draw each bitmap image processed
    by each thread in its corresponding row (`liStartingRow`), which is calculated
    the same way we did when separating the bitmap portions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides, in each iteration, the starting row increases the height calculated
    for each bitmap. Then, we are ready to show the rebuilt bitmap in the picture
    box, `picStarsBitmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Decoupling the UI, we can generate impressive performance improvements changing
    basic linear programming algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of applying this algorithm to the
    infrared portraits obtained by NASA''s Spitzer Space Telescope processed by four
    threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Signals between threads](img/8321EN_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot shows a clear independency achieved by each thread.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application changing the value of the `priProcessorCount` private variable
    from 1 to the number of available cores in your computer, and then compare the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are going to make some changes to the code in order to use the event
    wait handles instead of using a loop to check for the threads that are alive:'
  prefs: []
  type: TYPE_NORMAL
- en: Stay in the project, `OldStarsFinder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the code for `Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the line `[STAThread]` with the following line (before the `Main` method
    declaration):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the code for the Windows Form, `Form1` (`frmStarsFinder`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following private variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the code in the `WaitForThreadsToDie` method with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line of code in the local variables declaration of the `ShowBitmapWithOldStars`
    method, before the line `int liStartRow = 0;` (we must create the array according
    to the number of available cores):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line of code in the thread creation loop in the `ShowBitmapWithOldStars`
    method, before the line `prloThreadList.Add(new Thread(new ParameterizedThreadStart(ThreadOldStarsFinder)));`
    (we must create an `AutoResetEvent` instance with a false initial state for each
    thread):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line of code at the end of the `ThreadOldStarsFinder` method
    (we must signal that the work item has finished):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Old Star Finder** button. After a few seconds (depending on the
    parallel processing capabilities of the computer), the W5 wispy star-forming region
    will be shown in the huge infrared portrait with the probable old stars shown
    in pure blue. You will not notice any changes in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Old Star Finder** button:'
  prefs: []
  type: TYPE_NORMAL
- en: The original image is divided into many independent bitmaps. Each portion will
    be assigned to a different thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many threads and their auto-reset event handlers are created to allow communication
    between the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The threads are started (executed asynchronously) with a parameter so that they
    know which bitmap belongs to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once each thread finishes its work, it signals that the work is done, setting
    the auto-reset event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main thread waits until all the star finder threads finish their work, waiting
    for all the necessary signals from the multiple auto-reset events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the threads finish their work, the main thread (the only one capable
    of touching the UI) rebuilds the divided bitmap and shows it in the picture box
    control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code used to wait for all the threads to finish their work is easier and
    more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Using the AutoResetEvent class to handle signals between threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `AutoResetEvent` instance allows us to notify a waiting thread that an event
    has occurred. It is a subclass of the `WaitHandle` and `EventWaitHandle` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Event wait handles** encapsulate operating-system-specific objects that wait
    for exclusive access to shared resources. Using them, it is easier to wait for
    the threads'' signals to continue working when their jobs are done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to create event wait handles corresponding to the number of
    threads. We do it in the following line, in the `FindOldStarsAndShowResult` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We use an array because the `WaitAll` method receives an array of wait handles
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating each new instance of the `Thread` class, we create a new `AutoResetEvent`
    instance for each thread, with its initial state (a `bool` state) set to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, each independent thread can access its own `AutoResetEvent` instance.
    Once the thread finishes its work, it signals that the job is done calling the
    `Set` method, as shown in the following line, at the end of the `ThreadOldStarsFinder`
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The event wait handle's initial state was `false`; now it is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the WaitHandle class to check for signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the other side, the main UI thread has to wait until all the concurrent star
    finder threads finish their work in order to show the final modified bitmap in
    the UI. Thus, it must wait for all the event handles to have their state set to
    `true`, instead of the initial `false`.
  prefs: []
  type: TYPE_NORMAL
- en: This happens when all the threads have finished their work and have called the
    `Set` method for their corresponding `AutoResetEvent` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check that using a single line of code in the `WaitForThreadsToDie`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `WaitAll` method will monitor all the event handles, waiting for their signals
    to change (the threads' completion). It receives an array of event handles as
    a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We must change the application's threading model to a multithreaded apartment
    in order to be able to use the `WaitHandle.WaitAll` method. If we do not do so,
    the method call will fail and generate an exception. Therefore, we have to replace
    the line `[STAThread]`, before the `Main` method declaration, with `[MTAThread]`.
  prefs: []
  type: TYPE_NORMAL
- en: Joining threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already examined *joining* a thread in the previous chapter. When you
    join a thread, you tell the current thread to wait on the thread, which you are
    joining, to complete. This allows you to coordinate work between two threads.
  prefs: []
  type: TYPE_NORMAL
- en: This was very handy in the example where we wanted to know when one piece is
    complete before we start the next piece.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, let's say we want to examine how the performance changes
    if all of the bitmap processing threads run sequentially instead of concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want all of our bitmap processing threads to run sequentially, then right
    after we start a thread, we will join the thread. This will halt execution of
    the main thread until the bitmap processing thread we just started has finished.
    To do this, change the bottom `for` loop in the `butFindOldStars_Click` event
    handler and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now the `for` loop looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, run the application and click on the **Old Star Finder** button. Comment
    the line out and rerun the application. What do you see?
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the time to process the image and complete the process
    is much slower with the extra line of code versus without the extra line of code.
    As we mentioned previously, this is because we are pausing the main thread each
    time we execute a new thread to process part of the bitmap image. So, we are not
    processing the image concurrently but sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, this is not very practical, but for many problems there
    is a reason why you might want to do this. The main lesson here is that the `Thread`
    class has several ways to control processing, so you, the developer, can have
    complete control over how threads are created, executed, and coordinated. This
    is also why this is referred to as **heavyweight concurrency** because it takes
    extra effort and work by the developer to accomplish the exact behavior that you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: Locking resources to ensure thread-safe data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have chosen to design our application in a manner so that there is
    no need to lock resources to protect them from being "stomped" on by other threads,
    thereby causing race conditions and other unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lock syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code between the brackets is executed in a thread-safe manner and will not
    let other threads operate on the object being locked until the lock execution
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Other threads that try to perform an operation on an object that is locked will
    wait until the lock is freed before they continue their operation on the object.
    This is important to note because it can create "locking" issues where one thread
    is waiting on a resource locked by another thread. This can be self-defeating
    when trying to gain performance improvements with multithreading code if the multiple
    threads are constantly waiting on each other to let go of a resource. This is
    one of the reasons we have designed the code to use a separate list of long values
    to count old stars with one item in the list for each thread instead of one variable
    total that all of the threads update.
  prefs: []
  type: TYPE_NORMAL
- en: On a separate note, when using locks, you need to be careful not to create a
    deadlock situation. This occurs when one thread is waiting on an object locked
    by another thread and that thread is waiting on an object locked by the first
    thread. Hence, each thread is waiting on the other thread and neither can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worthwhile noting that locks are handled differently in between
    C# 3.0 and C# 4.0\. In 3.0, the following is how a lock is translated into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In C# 4.0, it is handled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in C# 4.0, if the lock is not taken on an object, nothing different
    happens to the object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's look at our code and make a simple change to use a single variable
    to hold our old star count. Let's do it with and without the lock and see the
    different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the following to the top of our class in the declaration
    statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, add a label control and set the `Text` property to `Old Stars Count` and
    add a textbox control and set the `Name` property to `tbCount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This variable will hold our old star count and all of the threads will update
    this one variable. You will notice that we are using a string instead of an integer.
    This is because an integer is a base type of the language and not an object. Because
    of this, it is thread-safe by default and does not need to be locked. So, to demonstrate
    our point, we will use a `String` object as a counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `ThreadOldStarsFinder` method, add the following code to the end
    (and inside) of the nested `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from this example, each time one of the processing threads updates
    the count, it will lock the resource, update `prsOldStarsCount`, and then unlock
    it. This protects its integrity but will slow down the overall processing because
    of the extra context switching that the lock will cause.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling with threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss various ways of using the `try..catch` block
    to perform error handling and coordination of multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to write a simple console application that demonstrates
    a typical producer-consumer model. We will also demonstrate using a `try..catch`
    to coordinate activities as well as the join and lock mechanism previously discussed.
    This exercise will cement everything we have learned in this chapter so far.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as we will see in future chapters the producer-consumer design pattern
    is one of the most commonly used design patterns in multithreaded problem solving
    and is used a lot with the Task Parallel Library. It describes a design where
    one thread (or a group of threads) "produces" some output, and a second thread
    (or group of threads) "consumes" that output and performs some logic on it. Typically,
    you will multithread the "production" of some results into a queue, and then will
    multithread the "consumption" of the produced results from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up Visual Studio and create a new project called `ProducerConsumer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create three classes, a `Producer` class, a `Consumer` class, and a `Cell`
    class. The `Producer` class will produce cells, and the consumer class will consume
    cells. In the `Main` method, we will start a producer and a consumer thread and
    then join them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `Program.cs` file so it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's run this console application. In Visual Studio, make sure that you are
    displaying the **Output** window. You can do this by going to the **View** menu
    and selecting **Output**. Once you run the application, you should see something
    like the following in your **Output** window:![How to do it](img/8321EN_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see in our application, we coordinate between the producer and the
    consumer, and using the `try..catch` block and locks, we are able to produce one
    item and then consume that item.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, in this example, we show how synchronization is done using locks and a
    `Monitor` object. The `Pulse` method notifies a thread, which is in the waiting
    queue, of a change in the object's state.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create a `Cell` object that has two methods, `Read` and
    `Write`. Two other objects are created from the `Producer` and `Consumer` classes.
    These objects have a method `ThreadRun` whose job is to call `Cell.Read` and `Cell.Write`.
    The synchronization is done by waiting for "pulses" from the `Monitor` object.
    These pulses will come in the order they are received.
  prefs: []
  type: TYPE_NORMAL
- en: So, first an item is produced (the consumer at this point is waiting for a pulse),
    then a pulse occurs, and then the consumer "consumes" what was produced. Meanwhile
    the producer is waiting for a pulse. This is then repeated until we reach the
    limit we set when we created the `Producer` and `Consumer` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deeper dive into working with the `Thread` class.
    Through our examples, we learned how to coordinate threads in a more advanced
    way. We learned how to use the `try..catch` block, the `Monitor` object, locks,
    `Join`, `IsAlive`, and `Sleep` methods to coordinate activities between threads.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced two common design patterns that we will explore in much more
    detail in the later chapters—the pipelining and the producer-consumer patterns.
    These are commonly used to solve problems in a parallel application. They are
    good ways to segment the work that can be done in parallel from the work that
    cannot be done in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed, this type of parallel programming is called heavyweight
    concurrency because the heavy lifting is done by you, the programmer. You have
    to manage and control the different threads to achieve the behavior you intended.
    You have to track which threads run and when and which threads are waiting and
    why. This does create complexity and work for the programmer but it also allows
    for very tight control of the execution. There are times when this is the best
    way to ensure proper behavior of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in [Chapter 5](ch05.html "Chapter 5. Lightweight Concurrency – Task Parallel
    Library (TPL)"), *Lightweight Concurrency – Task Parallel Library (TPL)*, we will
    start to examine lightweight concurrency and the Task Parallel Library. This allows
    you to let .NET handle some of this coordination for you. It is important that
    you have full understanding of the `Thread` class before moving on to the Task
    library and lightweight concurrency.
  prefs: []
  type: TYPE_NORMAL
