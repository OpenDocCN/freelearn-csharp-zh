- en: 11 Structural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter explores four design patterns from the well-known Gang of Four
    (GoF). We use Structural patterns to build and organize complex object hierarchies
    in a maintainable fashion. They allow us to dynamically add behaviors to existing
    classes, whether we designed the initial system this way or as an afterthought
    that emerges out of necessity later in the program’s lifecycle. Structural patterns
    promote reusability and enhance the overall flexibility of the system.In this
    chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Decorator design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Composite design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Adapter design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Façade design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two patterns help us extend a class dynamically and efficiently manage
    a complex object structure. The last two help us adapt an interface to another
    or shield a complex system with a simple interface.Let's dive into unlocking the
    power of structural patterns!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Decorator design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator Pattern allows us to dynamically add new functionality to an object
    by wrapping it with one or more decorator objects. This pattern follows the Open-Closed
    principle, allowing us to add additional behaviors to an object at runtime without
    modifying its original code. This pattern enables us to separate responsibilities
    into multiple smaller pieces. It is a simple but powerful pattern. In this section,
    we explore how to implement this pattern in the traditional way and how to leverage
    an open-source tool named **Scrutor** to help us create powerful dependency injection-ready
    decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The decorator aims to extend an existing object at runtime without changing
    its code. Moreover, the decorated object should remain unaware of the decoration
    process, making this approach an excellent fit for complex or long-lasting systems
    that necessitate evolution. This pattern fits systems of all sizes.
  prefs: []
  type: TYPE_NORMAL
- en: I often use this pattern to add flexibility and create adaptability to a program
    for next to no cost. In addition, small classes are easier to test, so the Decorator
    pattern adds ease of testability into the mix, making it worth mastering.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Decorator pattern makes it easier to encapsulate responsibilities into multiple
    classes, instead of packing multiple responsibilities inside a single class. Having
    multiple classes with a single responsibility makes the system easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **decorator** class must implement and use the interface the **decorated**
    class implements. Let’s see this step by step, starting with a non-decorated class
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: A class diagram representing the ComponentA class implementing
    the IComponent interface](img/file48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: A class diagram representing the ComponentA class implementing
    the IComponent interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we have the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: A client that calls the `Operation()` method of the `IComponent` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComponentA`, which implements the `IComponent` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This translates into the following sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: A sequence diagram showing a consumer calling the Operation
    method of the ComponentA class](img/file49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: A sequence diagram showing a consumer calling the Operation method
    of the ComponentA class'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, say that we want to add a behavior to `ComponentA`, but only in some cases.
    In other cases, we want to keep the initial behavior. To do so, we could choose
    the Decorator pattern and implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Decorator class diagram](img/file50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Decorator class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of modifying the `ComponentA` class, we created `DecoratorA`, which
    also implements the `IComponent` interface. This way, the `Client` object can
    use an instance of `DecoratorA` instead of `ComponentA` and leverage the new behavior
    without impacting the other consumers of `ComponentA`. Then, to avoid rewriting
    the whole component, an implementation of the `IComponent` interface (say `ComponentA`)
    is injected when creating a new `DecoratorA` instance (constructor injection).
    This new instance is stored in the `component` field and used by the `Operation()`
    method (implicitly using the **Strategy** pattern).We can translate the updated
    sequence like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Decorator sequence diagram](img/file51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Decorator sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, instead of calling `ComponentA` directly, `Client`
    calls `DecoratorA`, which in turn calls `ComponentA`. Finally, `DecoratorA` does
    some postprocessing by calling its private method, `AddBehaviorA()`.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing from the Decorator pattern limits us from doing preprocessing, postprocessing,
    wrapping the decorated class’s call (the `Operation` method in this example) with
    some logic (like an `if` statement or a `try`-`catch`), or all of that combined.
    The use of adding a postprocessing behavior is only an example.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To show you how powerful the Decorator pattern is before we jump into the code,
    know this: we can chain decorators! Since our decorator depends on the interface
    (not the implementation), we could inject another decorator, let’s call it `DecoratorB`,
    inside `DecoratorA` (or vice versa). We could then create a long chain of rules
    that decorate one another, leading to a very powerful yet simple design.Let’s
    take a look at the following class diagram, which represents our chaining example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Decorator class diagram, including two decorators](img/file52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Decorator class diagram, including two decorators'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we created the `DecoratorB` class, which looks very similar to `DecoratorA`
    but has a private `AddBehaviorB()` method instead of `AddBehaviorA()`.
  prefs: []
  type: TYPE_NORMAL
- en: How we implement the decorator logic is irrelevant to the pattern, so I excluded
    the `AddBehaviorA()` method from *Figure 9.3* to show you only the pattern. However,
    I added it to *Figure 9.5* to clarify the idea behind having a second decorator.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s take a look at the sequence diagram for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Sequence diagram of two nested decorators](img/file53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Sequence diagram of two nested decorators'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are beginning to see the power of decorators. In the preceding
    diagram, we can assess that the behaviors of `ComponentA` have been changed twice
    without `Client` knowing about it. All those classes are unaware of the next `IComponent`
    in the chain. They don’t even know that they are being decorated. They only play
    their role in the plan—that’s all.It is also important to note that the decorator’s
    power resides in its dependency on the interface, not on an implementation, making
    it reusable. Based on that fact, we could swap `DecoratorA` and `DecoratorB` to
    invert the order the new behaviors are applied without touching the code itself.
    We could also apply the same decorator (say `DecoratorC`) to multiple `IComponent`
    implementations, like decorating both `DecoratorA` and `DecoratorB`. A decorator
    could even decorate itself.Let’s now dig into some code.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Adding behaviors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s implement the previous example to help visualize the Decorator pattern,
    which adds some arbitrary behaviors. Each `Operation()` method returns a string
    that is then outputted to the response stream. It is not fancy but visually shows
    how the pattern works.First, let’s look at the `IComponent` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IComponent` interface only states that an implementation should have an
    `Operation()` method that returns a `string`.Next, let’s look at the `ComponentA`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Operation()` method of the `ComponentA` class returns a literal string.Now
    that we described the first pieces, let’s look at the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Program.cs` file above, we register `ComponentA` as the implementation
    of `IComponent`, with a singleton lifetime. We then inject an `IComponent` implementation
    when an HTTP request hits the `/` endpoint. The delegate then calls the `Operation()`
    method and outputs the result to the response.At this point, running the application
    results in the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So far, it's pretty simple; the client calls the endpoint, the container injects
    an instance of the `ComponentA` class into the endpoint delegate, then the endpoint
    returns the results of `Operation` method to the client.Next, we add the first
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: DecoratorA
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, we want to modify the response without touching the code of the `ComponentA`
    class. To do so, we chose to create a decorator named `DecoratorA` that wraps
    the `Operation()` result into a `<DecoratorA>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`DecoratorA` implements and depends on the `IComponent` interface. It uses
    the injected `IComponent` implementation in its `Operation()` method and wraps
    its result in an HTML-like (XML) tag.Now that we have a decorator, we need to
    tell the IoC container to send an instance of `DecoratorA` instead of `ComponentA`
    when injecting an `IComponent` interface.`DecoratorA` should decorate `ComponentA`.
    More precisely, the container should inject an instance of the `ComponentA` class
    into the `DecoratorA` class.To achieve this, we could register it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are telling ASP.NET Core to inject an instance of `DecoratorA` that
    decorates an instance of `ComponentA` when injecting an `IComponent` interface.
    When we run the application, we should see the following result in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed a few `new` keywords there, but even though it is not very
    elegant, we can manually create new instances in the composition root without
    jeopardizing our application’s health. We learn how to get rid of some of them
    later with the introduction of Scrutor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, let’s create the second decorator.
  prefs: []
  type: TYPE_NORMAL
- en: DecoratorB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have a decorator, it is time to create a second decorator to demonstrate
    the power of chaining decorators.**Context**: we need another content wrapper
    but don’t want to modify existing classes. To achieve this, we concluded that
    creating a second decorator would be perfect, so we created the following `DecoratorB`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is similar to `DecoratorA`, but the XML tag is `DecoratorB`
    instead. The important part is that the decorator depends on and implements the
    `IComponent` interface and doesn’t depend on a concrete class. This is what gives
    us the flexibility of decorating any `IComponent`, and this is what enables us
    to chain decorators.To complete this example, we need to update our composition
    root like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `DecoratorB` decorates `DecoratorA`, which decorates `ComponentA`. When
    running the application, you see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And voilà! These decorators allowed us to modify the behavior of `ComponentA`
    without impacting the code. However, our composition root is beginning to get
    messy as we instantiate multiple dependencies inside each other, making our application
    harder to maintain. Moreover, the code is becoming harder to read. Furthermore,
    the code would be even harder to read if the decorators were also depending on
    other classes.
  prefs: []
  type: TYPE_NORMAL
- en: We can use decorators to change the behavior or state of an object. We can be
    very creative with decorators; for example, you could create a class that queries
    remote resources over HTTP and then decorate that class with a small component
    that manages a memory cache of the results, limiting the round trip to the remote
    server. You could create another decorator that monitors the time needed to query
    those resources and then log that to Application Insights—so many possibilities.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we eliminate the `new` keywords and clean up our composition root.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Decorator using Scrutor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This update aims to simplify the composition of the system we just created.
    To achieve this, we use **Scrutor**, an open-source library that allows us to
    do just that, among other things.We first need to install the Scrutor NuGet package
    using Visual Studio or the CLI. When using the CLI, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Scrutor is installed, we can use the `Decorate` extension method on the
    `IServiceCollection` to add decorators.By using Scrutor, we can update the following
    messy line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And convert it into these three more elegant lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we registered `ComponentA` as the implementation of
    `IComponent`, with a singleton lifetime, just like the first time.Then, by using
    Scrutor, we told the IoC container to override that first binding and to decorate
    the already registered `IComponent` (`ComponentA`) with an instance of `DecoratorA`
    instead. Then, we overrode the second binding by telling the IoC container to
    return an instance of `DecoratorB` that decorates the last known binding of `IComponent`
    instead (`DecoratorA`).The result is the same as we did previously, but the code
    is now more elegant. On top of that improved readability, this lets the container
    create the instances instead of us using the `new` keyword, adding more flexibility
    and stability to our system.As a reminder, the IoC container serves the equivalent
    of the following `instance` when an `IComponent` interface is requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Why am I talking about elegance and flexibility? This code is a simple example,
    but if we add other dependencies to those classes, it could quickly become a complex
    code block that could become a maintenance nightmare, very hard to read, and have
    manually managed lifetimes. Of course, if the system is simple, you can always
    instantiate the decorators manually without loading an external library.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, keep your code simple. Using Scrutor is one way to achieve
    this. Code simplicity helps in the long run as it is easier to read and follow,
    even for someone else reading it. Consider that someone will most likely read
    your code one day.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moreover, adding any external dependency to a project should be considered carefully.
    Remember that you must keep the dependency up to date, so having too many can
    take maintenance time. The library's author can also stop maintaining it, and
    the library will become outdated. The library may introduce breaking changes forcing
    you to update your code. And so on.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Furthermore, there is the security aspect to consider. Supply chain attacks
    are not uncommon. If you work in a regulated place, you may have to go through
    a cybersecurity vetting process, etc.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Besides those general tips, I’ve been using Scrutor for many years; I find it
    very stable and don’t remember any breaking changes that caused me issues.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To ensure both programs behave the same, with or without Scrutor, let’s explore
    the following integration test that runs for both projects, ensuring their correctness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test sends an HTTP request to one of the applications running
    in memory and compares the server response to the expected value. Since both projects
    should have the same output, we reuse this test in both the `DecoratorPlainStartupTest`
    and `DecoratorScrutorStartupTest` classes. They are empty and only routes the
    test to the correct program. Here’s an example of the Visual Studio Test Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: A Visual Studio Explorer screenshot displaying the Decorator
    integration tests.](img/file54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: A Visual Studio Explorer screenshot displaying the Decorator integration
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also do assembly scanning using Scrutor ([https://adpg.link/xvfS](https://adpg.link/xvfS)),
    which allows you to perform automatic dependency registration. This is outside
    the scope of this chapter, but it is worth looking into. Scrutor allows you to
    use the built-in IoC container for more complex scenarios, postponing the need
    to replace it with a third-party one.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Decorator pattern is one of our toolbox''s simplest yet most powerful design
    patterns. It augments existing classes without modifying them. A decorator is
    an independent block of logic that we can use to create complex and granular object
    trees that fit our needs.We also explored the Scrutor open-source library to assist
    us in registering our decorator with the container.The Decorator pattern helps
    us stay in line with the **SOLID** principles (and vice versa), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: The Decorator pattern suggests creating small classes to add behaviors
    to other classes, segregating responsibilities, and fostering reuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Decorators add behaviors to other classes without modifying them, which
    is literally the definition of the OCP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: By following the ISP, creating decorators for your specific needs should
    be easy. However, implementing the Decorator pattern may become difficult if your
    interfaces are too complex. Having a hard time creating a decorator is a good
    indicator that something is wrong with the design—a code smell. A well-segregated
    interface should be easy to decorate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Depending on abstractions is the key to the Decorator’s power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we explore the Composite pattern, which helps us manage complex objects’
    structures differently than the decorator does.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Composite design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Composite design pattern is another structural GoF pattern that helps us
    manage complex object structures.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal behind the Composite pattern is to create a hierarchical data structure
    where you don’t need to differentiate groups from single components, making the
    traversal and manipulation of the hierarchy easy for its consumers.
  prefs: []
  type: TYPE_NORMAL
- en: You could think of the Composite pattern as a way of building a graph or a tree
    with self-managing nodes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The design is straightforward; we have *components* and *composites*. Both
    implement a common interface that defines the shared operations. The *components*
    are single nodes, while the *composites* are collections of *components*. Let’s
    take a look at a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: Composite class diagram](img/file55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Composite class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, `Client` depends on an `IComponent` interface and
    is unaware of the underlying implementation—it could be an instance of a `Component`
    or a `Composite`; it does not matter. Then, we have two implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Component` represents a single element; a leaf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Composite` represents a collection of `IComponent`. The `Composite` object
    uses its children to manage the hierarchy’s complexity by delegating part of the
    process to them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those three pieces put together create the Composite design pattern. Considering
    that it is possible to add instances of the `Composite` and `Component` classes
    as children of other `Composite` objects, it is possible to create complex, non-linear,
    and self-managed data structures with next to no effort.
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited to one type of component and one type of composite; you
    can create as many implementations of the `IComponent` interface as you need.
    Then, you can even mix and match them to create a non-linear tree.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Project – BookStore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We built a program in the past to support a bookstore. However,
    the store is going so well that our little program is not enough anymore. Our
    fictional company now owns multiple stores. They want to divide those stores into
    sections and manage book sets and single books. After a few minutes of gathering
    information and asking them questions, we realize they can have sets of sets,
    subsections, and think of creating sub-stores, so we need a flexible design.We
    have decided to use the Composite pattern to solve this problem. Here’s our class
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: the BookStore project composite class hierarchy](img/file56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: the BookStore project composite class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the complexity of our class hierarchy and the uncertainty of a project
    in an early stage, we decided that a factory would be adequate to create our class
    hierarchy, showcase our design, and validate it with the customer. Here’s the
    high-level design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: high-level design of the BookStore project](img/file57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: high-level design of the BookStore project'
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to aim for the smallest possible interface to get the ball rolling.
    Since we want to know how many items are available in any part of the store and
    what type of component we are interacting with, we created the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Count` property allows us to calculate how many items are available under
    the corporation, a store, a section, a set, or any other composite component we
    create in the future. The `Type` property forces each component to display its
    type linearly.
  prefs: []
  type: TYPE_NORMAL
- en: We can create such a minimal interface because we are not executing any operations
    on the data structure but counting the elements, then serializing it to JSON.
    The serializer will take care of navigating the class hierarchy for us. In another
    context, the minimal subset of properties might be more than this. For example,
    in this case, we could have added a `Name` property to the interface, but the
    book's name is its title, so I decided not to include it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, let’s create our composite structure, starting with the `Book` class
    (the *Component*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Book` class implements the interface by always returning a count
    of 1 because it is a single book, a leaf in the tree. The `Type` property is also
    hard-coded. As a book, the class requires a title upon construction that it stores
    in the `Title` property (not inherited and only available to `Book` instances).
  prefs: []
  type: TYPE_NORMAL
- en: In a real scenario, we’d have more properties, like the ISBN and author, but
    doing so here would just clutter the example. We are not designing a real bookstore
    but learning about the Composite pattern.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, let’s create our composite component, the `BookComposite` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BookComposite` class implements the following shared features:'
  prefs: []
  type: TYPE_NORMAL
- en: Children management (highlighted in the code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the `Name` property of the composite object and forcing the classes
    inheriting it to set a name upon construction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically finds and sets the `Type` name of its derived class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the number of children (and, implicitly, the children’s children).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing the children through the `Children` property and ensuring consumers
    can’t modify the collection from the outside by returning a `ReadOnlyCollection`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the LINQ `Sum()` extension method in the `children.Sum(child =>` `child.Count());`
    expression allowed us to replace a more complex `for` loop and an accumulator
    variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Adding the `virtual` modifier to the `Type` property allows sub-types to override
    the property in case their type’s name does not reflect the type that should be
    displayed in the program.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, we can start implementing the other classes of our complex composite hierarchy
    and assign a responsibility to each class, showing how flexible the Composite
    pattern is.The following classes inherit from the `BookComposite` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Corporation` class represents the corporation that owns multiple stores.
    However, it is not limited to owning stores; a corporation could own other corporations,
    stores, or any other `IComponent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Store` class represents a bookstore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Section` class represents a section of a bookstore, an aisle, or a category
    of books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Set` class represents a book set, such as a trilogy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These can be composed of any `IComponent`, making this an ultra-flexible data
    structure. Let’s look at the code for these `BookComposite` sub-types, starting
    with the `Corporation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The corporation contributes a CEO to the model because someone has to manage
    the place.Next, we look at the `Store` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On top of the `BookComposite` members, a store has a manager and a location.Now,
    the `Section` class does not add anything, but we can use it as a flexible organizer:namespace
    Composite.Models;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Set` class allows creating the book set upon construction through
    the books parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Composing a set of books upon creation of the instance will be convenient later
    when we assemble the tree.Next, let’s explore the last part of the program that
    helps encapsulate the data structure’s creation: the factory.'
  prefs: []
  type: TYPE_NORMAL
- en: The factory is not part of the Composite pattern, but now that we know what
    a factory is, we can use one to encapsulate the creation logic of our data structure
    and talk about it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The factory interface looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The default concrete implementation of the `ICorporationFactory` interface
    is the `DefaultCorporationFactory` class. It creates a large non-linear data structure
    with sections, subsections, sets, and subsets. This whole structure is defined
    using our composite model in the `DefaultCorporationFactory` class. Due to its
    large size, let’s start with the class’s skeleton and its `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `Create` method, we create the corporation, add two stores,
    then return the result.The `CreateTaleTowersStore` and `CreateEpicNexusStore`
    methods create a store, set their name, address, and manager, and create three
    sections each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Both stores share two sections (have the same books; highlighted code), each
    with a unique section. If we look at the `CreateFictionSection` method, it adds
    an imaginary book and a subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateScienceFictionSection` method adds an invented book and the Star
    Wars book set composed of three trilogies (a set of sets):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we look at this part of the data structure, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: The Fiction section of the Epic Nexus store data](img/file58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: The Fiction section of the Epic Nexus store data'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the big scheme of things, the whole organizational structure, down to the
    section level (without the books and sets), looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11: the composite hierarchy without the books and sets](img/file59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: the composite hierarchy without the books and sets'
  prefs: []
  type: TYPE_NORMAL
- en: I omitted to publish the whole data structure, including the books, as an image
    because it is too large and would be hard to read. Rest assured, the content itself
    is unimportant, and the section we are studying is enough to understand the flexibility
    the composite pattern brings to the design.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As we explore this, we can see how flexible the design is. We can create almost
    any organizational structure we want.Now, let’s look at the `Program.cs` file
    and register our dependencies and an endpoint to query the data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code registers the factory that creates the corporation data
    structure with the container and an endpoint to serve it.When we execute the code,
    we get the full data structure or the corporation. For brevity reasons, the following
    JSON represents the fiction section, excluding the books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `count` fields reflect the total count. In this case, there
    is no book so the count should be 0\. If you run the program and play with the
    preprocessor symbols define in the `DefaultCorporationFactory.cs` file (`ADD_BOOKS`,
    `ADD_SETS`, and `ONLY_FICTION`), you will end up with different number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Composite pattern allowed us to render a complex data structure in a small
    method call. Since each component autonomously handles itself, the Composite pattern
    removes the burden of managing this complexity from the consumer.I encourage you
    to play around with the existing data structure so that you understand the pattern.
    You could also try adding a `Movie` class to manage movies; a bookstore must diversify
    its activities. You could also differentiate movies from books so that customers
    are not confused. The bookstores could have physical and digital books as well.If
    you are still looking for more, try building a new application from scratch and
    use the Composite pattern to create, manage, and display a multi-level menu structure
    or a file system API.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Composite pattern effectively builds, manages, and maintains complex non-linear
    data structures. Its power is primarily in its self-management capabilities. Each
    node, component, or composite is responsible for its own logic, leaving little
    to no work for the composite’s consumers. Of course, a more complex scenario would
    have led to a more complex interface.Using the Composite pattern helps us follow
    the **SOLID** principles in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: It helps divide multiple elements of a complex data structure into small
    classes to split responsibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: By allowing us to “mix and match” different implementations of `IComponent`
    interface, the Composite pattern allows us to extend the data structure without
    impacting the other existing classes. For example, you could create a new class
    that implements `IComponent` and start using it immediately without modifying
    any other component classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: The Composite pattern may violate the ISP when single items implement
    operations that only impact the collections, like the `Add` and `Remove` methods,
    but we have not done this here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The Composite pattern actors depend solely on `IComponent` which invert
    the dependency flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we move to a different type of structural pattern that adapts one interface
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Adapter design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Adapter pattern is another structural design pattern that allows two incompatible
    interfaces to work together without modifying their existing code. This pattern
    introduces a wrapper class called the *Adapter*, which bridges the gap between
    the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Adapter design pattern is applicable when we want to use an existing class,
    but its interface is incompatible with what we want to use it for. Instead of
    refactoring the class, which could introduce bugs or errors in the existing codebase
    or even cascade changes to other parts of the system, we can use an *Adapter*
    class to make the class's interface compatible with the *Target* interface. The
    Adapter pattern is handy when we cannot change the *Adaptee’s* code or do not
    want to change it.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can think of the adapter as a power outlet’s universal adapter; you can
    connect a North American device to a European outlet by connecting it to the adapter
    and then to the power outlet. The Adapter design pattern does precisely that but
    for APIs.Let’s start by looking at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: Adapter class diagram](img/file60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Adapter class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we have the following actors:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ITarget` interface holds the contract we want (or have) to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Adaptee` class represents the concrete component we want to use that does
    not conform to `ITarget.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Adapter` class adapts the `Adaptee` class to the `ITarget` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a second way of implementing the Adapter pattern that implies inheritance.
    If you can go for composition, go for it, but if you need access to `protected`
    methods or other internal states of `Adaptee`, you can go for inheritance instead,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13: Adapter class diagram inheriting the Adaptee](img/file61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Adapter class diagram inheriting the Adaptee'
  prefs: []
  type: TYPE_NORMAL
- en: The actors are the same, but instead of composing the `Adapter` class with the
    `Adaptee` class, the `Adapter` class inherits from the `Adaptee` class. This design
    makes the `Adapter` class become both an `Adaptee` and an `ITarget`.Let’s explore
    how this looks in code.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Greeter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We’ve programmed a highly sophisticated greeting system that we
    want to reuse in a new program. However, its interface does not match the new
    design, and we cannot modify it because other systems use that greeting system.To
    fix this problem, we decided to apply the Adapter pattern. Here is the code of
    the external greeter (`ExternalGreeter`) and the new interface (`IGreeter`) used
    in the new system. This code must not directly modify the `ExternalGreeter` class
    to prevent any breaking changes from occurring in other systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is how the external greeter is adapted to meet the latest requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the actors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IGreeter` interface represents the *Target* and is the interface that we
    must use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ExternalGreeter` class represents the *Adaptee* and is the external component
    that already contains all the logic that someone programmed and tested. That code
    could be in an external assembly or installed from a NuGet package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ExternalGreeterAdapter` class represents the *Adapter* and is where the
    adapter does its job. In this case, the `Greeting` method calls the `GreetByName`
    method of the `ExternalGreeter` class, which implements the greeting logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can call the `Greeting` method and get the result of the `GreetByName`
    call. With this in place, we can reuse the existing logic through the `ExternalGreeterAdapter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We can also test `IGreeter` consumers by mocking the `IGreeter` interface without
    dealing with the `ExternalGreeterAdapter` class.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this case, the “complex logic” is pretty simple, but we are here for the
    Adapter pattern, not for imaginary business logic. Now, let’s take a look at the
    consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we composed our application by registering the `ExternalGreeterAdapter`
    class as a singleton bound to the `IGreeter` interface. We also informed the container
    to provide a single instance of `ExternalGreeter` class whenever requested (in
    this case, we inject it into the `ExternalGreeterAdapter` class).Then, the consumer
    (*Client* in the class diagrams) is the highlighted endpoint where the `IGreeter`
    interface is injected as a parameter. Then, the delegate calls the `Greeting`
    method on that injected instance and outputs the greeting message to the response.The
    following diagram represents what’s happening in this system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: Greeter system sequence diagram](img/file62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Greeter system sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: And voilà! We’ve adapted the `ExternalGreeterAdapter` class to the `IGreeter`
    interface with little effort.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Adapter pattern is another simple pattern that offers flexibility. With
    it, we can use older or non-conforming components without rewriting them. Of course,
    depending on the *Target* and *Adaptee* interfaces, you may need to put more or
    less effort into writing the code of the *Adapter* class.Now, let’s learn how
    the Adapter pattern can help us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: The Adapter pattern has only one responsibility: make an interface work
    with another interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: The Adapter pattern allows us to modify the *Adaptee’s* interface without
    the need to modify its code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Inheritance is not much of a concern regarding the Adapter pattern,
    so this principle does not apply once again. If *Adapter* inherits from *Adaptee*,
    the goal is to change its interface, not its behavior, which should conform to
    the LSP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: We can view the *Adapter* class as a facilitator to the ISP, with the
    *Target* interface as the ultimate destination. The Adapter pattern relies on
    the design of the *Target* interface but doesn''t directly influence it. Per this
    principle, our primary focus should be to design the *Target* interface in a manner
    that abides by the ISP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The Adapter pattern introduces only an implementation of the *Target*
    interface. Even if the *Adapter* depends on a concrete class, it breaks the direct
    dependency on that external component by adapting it to the *Target* interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we explore the last structural pattern of the chapter that teaches foundational
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Façade design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Façade pattern is a structural pattern that simplifies the access to a complex
    system. It is very similar to the Adapter pattern, but it creates a wall (a façade)
    between one or more subsystems. The big difference between the adapter and the
    façade is that instead of adapting an interface to another, the façade simplifies
    the use of a subsystem, typically by using multiple classes of that subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the same idea to shielding one or more programs, but in this case,
    we call the façade a gateway—more on that in *Chapter 19*, *Introduction to Microservices
    Architecture*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Façade pattern is extremely useful and can be adapted to multiple situations.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Façade pattern aims to simplify the use of one or more subsystems by providing
    an interface that is easier to use than the subsystems themselves, shielding the
    consumers from that complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine a system with a multitude of complex classes. Direct interaction between
    the consuming code and these classes can become problematic due to coupling, complexity,
    and low code readability and maintainability. The Facade design pattern offers
    a solution by providing a unified interface to a set of APIs in a subsystem, making
    it easier to use.The Facade class contains references to the objects of the complex
    subsystem and delegates client requests to the appropriate subsystem object. From
    a client''s perspective, it only interacts with a single, simplified interface
    represented by the Facade. Behind the scenes, the Facade coordinates with the
    subsystem''s components to fulfill the client''s request.We could create multiple
    diagrams representing a multitude of subsystems, but let’s keep things simple.
    Remember that you can replace the single subsystem shown in the following diagram
    with as many subsystems as you need to adapt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15: A class diagram representing a Façade object that hides a complex
    subsystem](img/file63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: A class diagram representing a Façade object that hides a complex
    subsystem'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Façade* plays the intermediary between the *Client* and the subsystem,
    simplifying its usage. Let’s see this in action as a sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16: A sequence diagram representing a Façade object that interacts
    with a complex subsystem](img/file64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: A sequence diagram representing a Façade object that interacts
    with a complex subsystem'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, the *Client* calls the *Façade* once, while the *Façade*
    places multiple calls against different classes.There are multiple ways of implementing
    a façade:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opaque façades**: In this form, the `Façade` class is inside the subsystem.
    All other classes of the subsystem have an `internal` visibility modifier. This
    way, only the classes inside the subsystem can interact with the other internal
    classes, forcing the consumers to use the `Façade` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparent façades**: In this form, the classes can have a `public` modifier,
    allowing the consumers to use them directly or to use the `Façade` class. This
    way, we can create the `Façade` class inside or outside the subsystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static façades**: In this form, the `Façade` class is `static`. We can implement
    a static façade as opaque or transparent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend using static façades as a last resort because `static` elements
    limit flexibility and testability.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We look at some code next.
  prefs: []
  type: TYPE_NORMAL
- en: Project – The façades
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we play with the following C# projects:'
  prefs: []
  type: TYPE_NORMAL
- en: The *OpaqueFacadeSubSystem* class library showcases an **opaque façade**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *TransparentFacadeSubSystem* class library showcases a **transparent façade**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Facade* project is a REST API that consumes the façades. It exposes two
    endpoints to access the *OpaqueFacadeSubSystem* project, and two others that target
    the *TransparentFacadeSubSystem* project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the class libraries.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the SOLID principles, adding some interfaces representing the elements
    of the subsystem seemed appropriate. In subsequent chapters, we explore how to
    organize our abstractions to be more reusable, but for now, both abstractions
    and implementations are in the same assembly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Opaque façade
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this assembly, only the façade is public; all the other classes are internal,
    which means they are hidden from the external world. In most cases, this is not
    ideal; hiding everything makes the subsystem less flexible and harder to extend.However,
    you may want to control access to your internal APIs in some scenarios. This may
    be because they are not mature enough and you don’t want any third party to depend
    on them, or for any other reasons you deem appropriate for your specific use case.Let’s
    start by taking a look at the following subsystem code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OpaqueFacade` class is coupled with `ComponentA`, `ComponentB`, and `ComponentC`
    directly. There was no point in extracting any `internal` interfaces since the
    subsystem is not extensible anyway. We could have done this to offer some kind
    of internal flexibility, but in this case, there was no advantage.Besides this
    coupling, `ComponentA`, `ComponentB`, and `ComponentC` define two methods each,
    which return a string describing their source. With that code in place, we can
    observe what is happening and how the final result was composed.`OpaqueFacade`
    also exposes two methods, each composing a different message using the underlying
    subsystem’s components. This is a classic use of a façade; the façade queries
    other objects more or less complicatedly and then does something with the results,
    taking away the caller’s burden of knowing the subsystem.Since the members use
    the `internal` visibility modifier, we can’t directly register the dependencies
    with the IoC container from the program. To solve this problem, the subsystem
    can register its dependencies by adding an extension method. The following extension
    method is accessible by the consuming application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code manually creates the dependencies and adds a binding to the
    `IOpaqueFacade` interface so the system can use it. This hides everything but
    the interface from the consumer.Before exploring the REST API, we look at the
    transparent façade implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent façade
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The transparent façade is the most flexible type of façade and is exceptionally
    suitable for a system that leverages dependency injection. The implementation
    is similar to the opaque façade, but the `public` visibility modifier changes
    how consumers can access the class library elements. For this system, it was worth
    adding interfaces to allow the consumers of the subsystem to extend it when needed.First,
    let’s take a look at the abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The API of this subsystem is the same as the opaque façade. The only difference
    is how we can use and extend the subsystem (from a consumer standpoint). The implementations
    are mostly the same as well, but the classes implement the interfaces and are
    `public`; the highlighted elements represent those changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the use of the subsystem, we create the following extension method
    as a good practice that makes consuming the subsystem easier. Everything that
    we define in that method can be overridden from the composition root (which is
    not the case for the opaque façade):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All the `new` elements are gone and have been replaced by simple dependency
    registration (singleton lifetimes, in this case). These little differences give
    us the tools to reimplement any part of the subsystem if we want to, as we cover
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: We can register bindings in the transparent façade extension method because
    classes and interfaces are `public`. The container needs a public constructor
    to do its work.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the opaque façade, we had to define the constructor of the `OpaqueFacade`
    class as `internal` because the type of its parameters (`ComponentA`, `ComponentB`,
    and `ComponentC`) are internal, making it impossible to leverage the container.
    Changing the visibility modifier of the opaque façade constructor from `internal`
    to `public` would have yielded a *CS0051 Inconsistent accessibility* error.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Besides those differences, the transparent façade plays the same role as the
    opaque façade, outputting the same result.We consume those two façades next.
  prefs: []
  type: TYPE_NORMAL
- en: The program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let’s analyze the consumer, an ASP.NET Core application that forwards
    HTTP requests to the façades and return the result as their response.The first
    step is to register the dependencies like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With these extension methods, the application root is so clean that it is hard
    to know that we registered two subsystems against the IoC container. This is a
    good way of keeping your code organized and clean, especially when you’re building
    class libraries.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that everything has been registered, the second thing we need to do is
    route those HTTP requests to the façades. Let’s take a look at the code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding block, we define four routes. Each route dispatches the request
    to one of the façade’s methods (highlighted code) using the façade that is injected
    in its delegate.If you run the program and navigate to the `/transparent/a` endpoint,
    the page should display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened is located inside the delegates. It uses the injected `ITransparentFacade`
    service and calls its `ExecuteOperationA()` method, and then outputs the `result`
    variable to the response stream.Now, let’s define how `ITransparentFacade` is
    composed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ITransparentFacade` is an instance of `TransparentFacade`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We inject `IComponentA`, `IComponentB`, and `IComponentC` in the `TransparentFacade`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These dependencies are instances of `ComponentA`, `ComponentB`, and `ComponentC`,
    respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visually, the following flow happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17: A representation of the call hierarchy that occurs when the
    consumer executes the ExecuteOperationA method](img/file65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.17: A representation of the call hierarchy that occurs when the consumer
    executes the ExecuteOperationA method'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see the shielding that’s done by the façade
    and how it has made the consumer’s life easier: one call instead of four.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the hardest parts of using dependency injection is its abstractness.
    If you are not sure how all those parts are assembled, add a breakpoint into Visual
    Studio (let’s say, on the `var result = transparentFacade.ExecuteOperationA()`
    line) and run the application in debug mode. From there, **Step Into** each method
    call. That should help you figure out what is happening. Using the debugger to
    find the concrete types and their states can help find details about a system
    or diagnose bugs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To use **Step Into**, you can use the following button or hit **F11**:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Figure 11.18: The Visual Studio Step Into (F11) button](img/file66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: The Visual Studio Step Into (F11) button'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the other endpoints lead to similar results. As a reference, here’s
    the result from the other endpoints.Here’s the result for the `/transparent/b`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the results for the `/opaque/a` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result for the `/opaque/b` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s update some results without changing the component’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility in action
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As discussed, the transparent façade adds more flexibility. Here, we explore
    this flexibility in action.**Context**: We want to change the behavior of the
    `TransparentFacade` class. At the moment, the result of the `transparent/b` endpoint
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate we can extend and change the subsystem without altering the
    it, let’s change the output to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `ComponentB` class provides the first two lines, we must replace
    it with a new implementation of the `IComponentB` interface. Let’s call this class
    `UpdatedComponentB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does exactly what we want. However, we have to tell the
    IoC container about it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program, you should see the desired result!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a dependency for a second time makes the container resolves that dependency,
    thus overriding the first one. However, both registrations remain in the services
    collection; for example, calling `GetServices<IComponentB>()` on `IServiceProvider`
    would return two dependencies. Do not confuse the `GetServices()` and `GetService()`
    methods (plural versus singular); one returns a collection while the other returns
    a single instance. That single instance is always the last that has been registered.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That’s it! We updated the system without modifying it. This is what dependency
    injection can do for you when designing a program around it.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative façade patterns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One alternative would be to create a *hybrid between a transparent façade and
    an opaque façade* by exposing the abstractions using the `public` visibility modifier
    (all of the interfaces) while keeping the implementations hidden under an `internal`
    visibility modifier. This hybrid design offers the right balance between **control
    and flexibility**.Another alternative would be to create *a façade outside of
    the subsystem*. In the previous examples, we created the façades inside the class
    libraries, but this is not mandatory; the façade is just a class that creates
    an accessible wall between your system and one or more subsystems. It should be
    located wherever you see fit. Creating external façades like this would be especially
    useful when you do not control the source code of the subsystem(s), such as if
    you only have access to the binaries. This could also be used to create project-specific
    façades over the same subsystem, giving you extra flexibility without cluttering
    your subsystems with multiple façades, shifting the maintenance cost from the
    subsystems to the client applications that use them.This one is more of a note
    than an alternative: you do not need to create an assembly per subsystem. I did
    it because it helped me explain different concepts in the examples, but you could
    create multiple subsystems in the same assembly. You could even create a single
    assembly that includes all your subsystems, façades, and the client code (all
    in a single project).'
  prefs: []
  type: TYPE_NORMAL
- en: Whether talking about subsystems or REST APIs, layering APIs is an excellent
    way to create low-level functionalities that are atomic but harder to use while
    providing a higher-level API to access them through the façade, leading to a better
    consumer experience.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Façade pattern is handy for simplifying consumers’ lives, allowing us to
    hide subsystems’ implementation details behind a wall. There are multiple flavors
    to it; the two most prominent ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: The **transparent façade**, which increases flexibility by exposing at least
    part of the subsystem(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **opaque façade**, which controls access by hiding most of the subsystem(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s see how the **transparent façade** pattern can help us follow the
    **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: A well-designed **transparent façade** serves this exact purpose by
    providing a cohesive set of functionalities to its consumers by hiding overly
    complex subsystems or internal implementation details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: A well-designed **transparent façade** and its underlying subsystem’s
    components can be extended without direct modification, as we saw in the *Flexibility
    in action* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: By exposing a façade that uses different smaller objects implementing
    small interfaces, we could say that the segregation is done at both the façade
    and the component levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The Façade pattern does not specify anything about interfaces, so it
    is up to the developers to enforce this principle by using other patterns, principles,
    and best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, let’s see how the **opaque façade** pattern can help us follow the
    **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: A well-designed **opaque façade** serves this exact purpose by providing
    a cohesive set of functionalities to its clients by hiding overly complex subsystems
    or internal implementation details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: By hiding the subsystem, the **opaque façade** limits our ability to
    extend it. However, we could implement a **hybrid façade** to help with that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: The **opaque façade** does not help nor diminish our ability to apply
    the ISP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The Façade pattern does not specify anything about interfaces, so it
    is up to the developers to enforce this principle by using other patterns, principles,
    and best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we covered multiple fundamental GoF structural design patterns.
    They help us extend our systems from the outside without modifying the actual
    classes, leading to a higher degree of cohesion by composing our object graph
    dynamically.We started with the Decorator pattern, a powerful tool that allows
    us to dynamically add new functionality to an object without altering its original
    code. Decorators can also be chained, allowing even greater flexibility (decorating
    other decorators). We learned that this pattern adheres to the Open-Closed principle
    and promotes the separation of responsibilities into smaller, manageable pieces.We
    also used an open-source tool named Scrutor that simplifies the decorator pattern
    usage by extending the built-in ASP.NET Core dependency injection system. Then,
    we covered the Composite pattern, which allows us to create complex, non-linear,
    and self-managed data structures with minimal effort. That hierarchical data structure
    where groups and single components are indistinguishable makes the hierarchy''s
    traversal and manipulation easier. We use this pattern to build graphs or trees
    with self-managing nodes.After that, we covered the Adapter pattern, which allows
    two incompatible interfaces to work together without modifying their code. This
    pattern is very helpful when we need to adapt the components of external systems
    that we have no control over, do not want to change, or can’t change.Finally,
    we dug into the Façade pattern, similar to the Adapter pattern, but at the subsystem
    level. It allows us to create a wall in front of one or more subsystems, simplifying
    its usage. It could also be used to hide the implementation details of a subsystem
    from its consumers.The next chapter explores two GoF behavioral design patterns:
    the Template method and the Chain of Responsibility design pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few revision questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the main advantage of the Decorator pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we decorate a decorator with another decorator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary goal of the Composite design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we use the Adapter pattern to migrate an old API to a new system in order
    to adapt its APIs before rewriting it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary responsibility of the Adapter pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the Adapter and the Façade patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main difference between an Opaque façade and a Transparent façade?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about Scrutor, please visit [https://adpg.link/xvfS](https://adpg.link/xvfS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator pattern allows us to dynamically add new functionality to an object
    at runtime without modifying its original code, promoting flexibility, testability,
    and manageability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, we can decorate decorators by depending only on interfaces because they
    are just another implementation of the interface, nothing more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Composite design pattern aims to simplify handling complex structures by
    treating individual and group elements indistinguishably.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, we could use an adapter for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Adapter pattern's primary responsibility is to adapt one interface to work
    with another interface that is incompatible to use directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Adapter and Façade design patterns are almost the same but are applied to
    different scenarios. The Adapter pattern adapts an API to another API, while the
    Façade pattern exposes a unified or simplified API, hiding one or more complex
    subsystems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An Opaque façade hides most of the subsystem (`internal` visibility), controlling
    access to it, while a Transparent façade exposes at least part of the subsystem
    (`public` visibility), increasing flexibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
