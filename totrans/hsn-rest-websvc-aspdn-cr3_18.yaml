- en: Securing Your Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的服务
- en: In the previous chapters, we saw how to exchange data between multiple services
    using an event bus and resilient clients and how to consume messages and run background
    services using ASP.NET Core. This chapter is about securing service data. It covers
    concepts such as SSL, **cross-origin resource sharing** (**CORS**), and HTTP/2,
    and it walks through the implementation of token-based authentication.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用事件总线和弹性客户端在多个服务之间交换数据，以及如何使用 ASP.NET Core 消费消息和运行后台服务。本章是关于保护服务数据。它涵盖了
    SSL、**跨源资源共享**（**CORS**）和 HTTP/2 等概念，并介绍了基于令牌的认证的实现。
- en: 'In more detail, this chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，本章涵盖了以下主题：
- en: A general overview of SSL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL 的一般概述
- en: How to enable CORS in an ASP.NET Core service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 ASP.NET Core 服务中启用 CORS
- en: How to enable HTTPS and HTTP/2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启用 HTTPS 和 HTTP/2
- en: How token-based authentication works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的认证是如何工作的
- en: How to build token-based authentication in ASP.NET Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 ASP.NET Core 中构建基于令牌的认证
- en: By the end of the chapter, you will have a broad understanding of the security
    features provided by ASP.NET Core, and you will be able to implement token-based
    authentication in ASP.NET Core.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将广泛了解 ASP.NET Core 提供的安全功能，并且能够实现基于令牌的认证在 ASP.NET Core 中。
- en: Overview of secure communication
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全通信概述
- en: Security is a crucial aspect of building applications. Web services usually
    expose information to third-party clients and companies; therefore, it is vital
    to avoid leaking data. The security layer of a web service is often a tedious
    part of the development process because it is hard to test and to verify.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是构建应用程序的一个关键方面。Web 服务通常向第三方客户端和公司公开信息；因此，避免数据泄露至关重要。Web 服务的安全层通常是开发过程中的一个繁琐部分，因为它难以测试和验证。
- en: Security is important even for web services that are published in the internal
    network of the company, which, by default, is not accessible from the outside.
    As software engineers, we should do as much as possible to guarantee a strong
    level of security when we release a web service. It is also essential to understand
    that securing a web service is necessary to identify the consumers of your data
    and to prevent overuse of your web service. The next section will start by describing
    HTTPS and how to secure your data using HTTPS in a ASP.NET Core web service.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是发布在公司内部网络中的 Web 服务，安全性也很重要，默认情况下，外部无法访问。作为软件工程师，我们应该尽可能保证在发布 Web 服务时具有强大的安全性。了解保护
    Web 服务是识别数据消费者和防止过度使用 Web 服务的必要条件。下一节将首先描述 HTTPS 以及如何在 ASP.NET Core Web 服务中使用
    HTTPS 保护数据。
- en: Securing data using HTTPS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTPS 保护数据
- en: 'A common practice for attackers is to intercept data exchanged between the
    client and the server. For that reason, it is essential to encrypt communication
    between them to keep the data secure. SSL uses SSL certificates to set up a trusted
    connection between the server company and the client. SSL uses *symmetric* and
    *asymmetric encryption* to encrypt keys used during this communication. Let''s
    see a schema of a typical SSL handshake between client and server:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者常用的一个做法是拦截客户端和服务器之间交换的数据。因此，加密他们之间的通信以保持数据安全至关重要。SSL 使用 SSL 证书在服务器公司和客户端之间建立信任连接。SSL
    使用 *对称* 和 *非对称加密* 加密在此通信过程中使用的密钥。让我们看看客户端和服务器之间典型 SSL 握手的方案：
- en: '![](img/38cf9627-a94f-4c11-a896-59138269b4f8.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38cf9627-a94f-4c11-a896-59138269b4f8.png)'
- en: 'This schema shows the conventional steps of an SSL handshake:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此方案显示了 SSL 握手的传统步骤：
- en: The connection starts with the client that initiates the request. Before the
    start, the server sends an SSL certificate to the client, which ensures that the
    certificate is valid and trustable.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接从发起请求的客户端开始。在开始之前，服务器向客户端发送 SSL 证书，以确保证书有效且可信。
- en: The client proceeds by extracting and encrypting the *public key* included in
    the SSL certificate.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端接着提取并加密 SSL 证书中包含的 *公钥*。
- en: The client sends the encrypted key (private key) to the server, which encodes
    the data and transmits it back to the client.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将加密的密钥（私钥）发送到服务器，服务器对数据进行编码并将数据传输回客户端。
- en: Data communication starts and the encrypted key is used to encrypt and decrypt
    data shared by the client and the server.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据通信开始，加密密钥用于加密和解密客户端和服务器共享的数据。
- en: SSL is the basis of the HTTPS protocol, which is the standard way to transfer
    encrypted data. The following section describes how to set up and enforce HTTPS
    in ASP.NET Core.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SSL是HTTPS协议的基础，是传输加密数据的标准方式。以下部分描述了如何在ASP.NET Core中设置和强制执行HTTPS。
- en: Enforcing HTTPS in ASP.NET Core
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中强制执行HTTPS
- en: HTTPS is enabled by default on ASP.NET Core. The main middleware related to
    the HTTPS protocol is the `HttpsRedirection` middleware class, which enforces
    redirection from HTTP to HTTPS. Therefore, it is possible to call the `UseHttpsRedirection`
    extension method in the `Startup` class in order to enable the middleware.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core默认启用了HTTPS。与HTTPS协议相关的中间件主要是`HttpsRedirection`中间件类，它强制从HTTP重定向到HTTPS。因此，可以在`Startup`类的`Startup`类中调用`UseHttpsRedirection`扩展方法来启用中间件。
- en: 'Let''s see how to enable and force HTTPS in an ASP.NET Core application running
    in a docker container. The first step is to generate a self-signed certificate
    used by the ASP.NET Core application that runs in the container. .NET Core provides
    a global tool that creates a self-signed certificate on your local environment
    called `dotnet-dev-certs`. We can proceed by installing this tool on our local
    environment using the following CLI command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在运行在docker容器中的ASP.NET Core应用程序中启用和强制执行HTTPS。第一步是生成ASP.NET Core应用程序在容器中使用的自签名证书。.NET
    Core提供了一个全局工具，称为`dotnet-dev-certs`，可以在本地环境中创建自签名证书。我们可以通过以下CLI命令在我们的本地环境中安装此工具：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, it is possible to create a new certificate using the `.pfx` format
    in the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以在以下命令中创建一个新的`.pfx`格式的证书：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The aforementioned instruction specifies the export path using the `-ep` option,
    with the `-p` password. Furthermore, it is possible to trust the certificate using
    the `--trust` options.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令使用`-ep`选项指定导出路径，并使用`-p`密码。此外，还可以使用`--trust`选项信任证书。
- en: It is important to note that the `dotnet-dev-certs` tool works only on Windows
    and macOS. In the case of Linux, we should proceed by generating the certificate
    using OpenSSL. The following tutorial ([https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core](https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core))
    provides more information about the creation of an HTTPS certificate using OpenSSL.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`dotnet-dev-certs`工具仅在Windows和macOS上工作。在Linux的情况下，我们应该通过使用OpenSSL生成证书来继续操作。以下教程（[https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core](https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core)）提供了有关使用OpenSSL创建HTTPS证书的更多信息。
- en: 'Once we have created a new certificate file, we can proceed by adjusting the
    `docker-compose.yml` file of the `Catalog.API` and `Cart.API` solutions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了新的证书文件，我们就可以通过调整`Catalog.API`和`Cart.API`解决方案的`docker-compose.yml`文件来继续操作：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The aforementioned `docker-compose.yml` definition declares a `volumes` node
    to create a binding between the local `./certificate/` folder and the `/root/.dotnet/https`
    folder in the instance of the container. Furthermore, we can proceed by adding
    the following variables in the `containers/api.env` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`docker-compose.yml`定义声明了一个`volumes`节点，用于在容器实例中将本地`./certificate/`文件夹与`/root/.dotnet/https`文件夹绑定。此外，我们还可以通过在`containers/api.env`文件中添加以下变量来继续操作：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The file adds two environment variables related to the certificate: `ASPNETCORE_Kestrel__Certificates__Default__Password`
    provides the certificate password, and `ASPNETCORE_Kestrel__Certificates__Default__Path`
    defines its path. The new definition of the `docker-compose.yml` file also exposes
    the `5001` port, and it also adds the `https://*:5001 URL` URL to the pool of
    URLs run by Kestrel. Futhermore, now it is possible to enforce the HTTPS in our
    `Startup` class by adding the following line in the `Configure` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件添加了两个与证书相关的环境变量：`ASPNETCORE_Kestrel__Certificates__Default__Password`提供证书密码，而`ASPNETCORE_Kestrel__Certificates__Default__Path`定义其路径。新的`docker-compose.yml`文件定义还公开了`5001`端口，并且它还向Kestrel运行的URL池中添加了`https://*:5001
    URL` URL。此外，现在我们可以在`Startup`类的`Configure`方法中添加以下行来强制执行HTTPS：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After applying the HTTPS restriction, the client will always be redirected to
    the HTTPS endpoint of the web service for every request.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用HTTPS限制后，客户端在每次请求时都会被重定向到Web服务的HTTPS端点。
- en: HTTP/2 on Kestrel
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kestrel上的HTTP/2
- en: 'ASP.NET Core has supported HTTP/2 on Kestrel since version 2.2.0, and it is
    enabled by default if you are using HTTPS. In addition, another HTTP/2 requirement
    is support for the **Application-Layer Protocol Negotiation** (**ALPN**) protocol.
    The ALPN protocol enhances the handshake process between a client and a server:
    the client lists all the supported protocols, and the server will confirm which
    protocol to use for the HTTP transfer. Moreover, this approach allows an eventual
    fallback to HTTP 1.1 if the client or the server doesn''t support HTTP/2.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core自2.2.0版本起支持Kestrel上的HTTP/2，如果你使用HTTPS，则默认启用。此外，另一个HTTP/2的要求是支持**应用层协议协商**（**ALPN**）协议。ALPN协议增强了客户端和服务器之间的握手过程：客户端列出所有支持的协议，服务器将确认用于HTTP传输的协议。此外，这种方法还允许在客户端或服务器不支持HTTP/2的情况下回退到HTTP
    1.1。
- en: 'As the default configuration, both HTTP 1.1 and HTTP/2 run on the same binding,
    but it is possible to customize and create a dedicated binding for HTTP/2 by extending
    the Kestrel configuration in the `static void Main` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认配置，HTTP 1.1和HTTP/2在相同的绑定上运行，但可以通过在`static void Main`方法中扩展Kestrel配置来自定义并创建一个专门的HTTP/2绑定：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This snippet shows how to set an HTTP/2 binding on port number `5002`. This
    approach forces the HTTP/2 bindings without providing any fallback to HTTP 1.1.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了如何在端口`5002`上设置HTTP/2绑定。这种方法强制使用HTTP/2绑定，而不提供任何回退到HTTP 1.1的选项。
- en: Enabling CORS in ASP.NET Core
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中启用CORS
- en: Another critical aspect of security is to protect our APIs from CORS calls.
    By default, it is not possible to use client-side code to call services that are
    hosted on other domains, because scam websites may use a cross-origin call to
    get sensitive information about users. This security restriction is called *the
    same-origin policy*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性的另一个关键方面是保护我们的API免受CORS调用的攻击。默认情况下，无法使用客户端代码调用托管在其他域上的服务，因为诈骗网站可能使用跨源调用获取有关用户的敏感信息。这种安全限制被称为**同源策略**。
- en: 'The restrictions on the *same-origin policy* act on HTTP calls using the following
    criteria:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对**同源策略**的限制作用于使用以下标准的HTTP调用：
- en: The request is made from a different domain (for example, the site at `example.com`
    calls `api.com`).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求来自不同的域名（例如，位于`example.com`的网站调用`api.com`）。
- en: The request is enabled from a different subdomain (for example, the website
    at `example.com` calls `api.example.com`).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求来自不同的子域名（例如，位于`example.com`的网站调用`api.example.com`）。
- en: The request is made from a different port (for example, the site at `example.com`
    calls `example.com:3001`).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求来自不同的端口（例如，位于`example.com`的网站调用`example.com:3001`）。
- en: The request is made from a different protocol (for example, the `https://example.com`
    site calls `http://example.com`).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求来自不同的协议（例如，`https://example.com`网站调用`http://example.com`）。
- en: CORS provides a way to allow a specific domain to make client-side calls to
    a service hosted within a different domain. This kind of approach becomes very
    useful when we want to enable a customer or a third-party client to call our service
    without restrictions. It is also essential to note that CORS can be enabled to
    allow every domain. This approach must be avoided because it will enable attackers
    to use our API inappropriately.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CORS提供了一种允许特定域名向不同域名托管的服务进行客户端调用的方法。当我们想要允许客户或第三方客户端无限制地调用我们的服务时，这种方法非常有用。还必须注意，CORS可以启用以允许所有域名。这种方法必须避免，因为它将使攻击者能够不当使用我们的API。
- en: 'ASP.NET Core provides an out-of-the-box way to enable CORS*.* The framework
    permits the creation of CORS policies using two approaches: the *middleware approach*
    and the *attributes approach.* As we saw in [Chapter 3](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml),
    *Working with the Middleware Pipeline*, middleware are usually implemented to
    develop cross-cutting logic that covers the whole web service. On the other hand,
    *attributes* are used to apply a restriction on a single action. In the same way,
    this approach is taken for CORS policies.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一个开箱即用的方式来启用CORS。该框架允许使用两种方法创建CORS策略：*中间件方法*和*属性方法*。正如我们在[第3章](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml)中看到的，*与中间件管道一起工作*，中间件通常被实现来开发覆盖整个Web服务的跨切面逻辑。另一方面，*属性*用于对单个操作应用限制。同样，这种方法也用于CORS策略。
- en: Implementing CORS using the middleware approach
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件方法实现CORS
- en: 'The *CORS middleware* approach can be used to enable a specific HTTP domain,
    method, or port to call our service. As with any middleware, it can be defined
    in the `Startup` class of the service, specifically in the `Configure` method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 *CORS 中间件* 方法来启用特定的 HTTP 域、方法或端口调用我们的服务。与任何中间件一样，它可以在服务的 `Startup` 类的 `Configure`
    方法中定义：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `UseCors` middleware extension method accepts an action method to configure
    the different rules. For example, the previous code executes the `AllowAnyOrigin`
    method to allow calls from any website. In the same way, it is possible to define
    more restricting rules on a specific domain, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseCors` 中间件扩展方法接受一个操作方法来配置不同的规则。例如，之前的代码执行了 `AllowAnyOrigin` 方法以允许来自任何网站的调用。同样，可以在特定域上定义更限制性的规则，如下所示：'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, we are blocking all cross-origin requests except those coming
    from the [https://samuele.dev/](https://samuele.dev/) website. A more advanced
    and clean way to define CORS rules is to group them using named policies. It is
    also possible to use the following approach:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们阻止了所有来自[https://samuele.dev/](https://samuele.dev/)网站之外的所有跨源请求。定义 CORS
    规则的更高级和简洁的方法是使用命名策略进行分组。也可以使用以下方法：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The previous code defines a CORS policy with the name `BlogDomainPolicy` using
    the `app.AddCors` construct in the `ConfigureServices` method. Once we have described
    the rules for the policy, we can proceed with using the defined policy in the
    `Configure` method of the `Startup` class using the `app.UseCors` method. It will
    enable us to establish different policies and apply them conditionally in the
    `Startup` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `ConfigureServices` 方法中的 `app.AddCors` 构造定义了一个名为 `BlogDomainPolicy`
    的 CORS 策略。一旦我们描述了策略的规则，我们就可以在 `Startup` 类的 `Configure` 方法中使用 `app.UseCors` 方法来使用定义的策略。这将使我们能够在
    `Startup` 类中建立不同的策略，并条件性地应用它们。
- en: Implementing CORS using the attribute approach
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性方法实现 CORS
- en: 'In some cases, it may be necessary to define specific policies for some routes
    or actions. Therefore, it is possible to apply CORS policies using attributes,
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要为某些路由或操作定义特定的策略。因此，可以使用属性应用 CORS 策略，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, we are restricting the use of the `BlogDomainPolicy` only to
    the `ItemController`. Therefore, all of the routes defined under the controller
    will use the same policy. In the same way, we can add the policy to a specific
    action method in the controller:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们仅将 `BlogDomainPolicy` 的使用限制在 `ItemController` 上。因此，控制器下定义的所有路由都将使用相同的策略。同样，我们可以在控制器中的特定操作方法上添加策略：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In that case, the `GetByIdActionPolicy` will act only on the `GetById` action
    method, while the `BlogDomainPolicy` will act on the whole controller. This approach
    provides a nice level of granularity; furthermore, it provides a way to specify
    policies for a single route of the service. The next section describes the characteristics
    of the token-based authentication approach.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，`GetByIdActionPolicy` 将仅对 `GetById` 操作方法起作用，而 `BlogDomainPolicy` 将作用于整个控制器。这种方法提供了很好的粒度；此外，它提供了一种为服务中的单个路由指定策略的方法。下一节将描述基于令牌的认证方法的特点。
- en: Securing APIs with token-based authentication
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于令牌的认证保护 API
- en: 'Applications have traditionally persisted identity through session cookies,
    relying on session IDs stored on the server-side. This method brings a few significant
    problems and pitfalls: it is *not* *scalable*,because you need a common point
    where you can store sessions and, every time a user is authenticated; the server
    will need to create a new record in a data source. Therefore, this approach may
    become a significant bottleneck for your web service.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序传统上通过会话 cookie 持久化身份，依赖于存储在服务器端的会话 ID。这种方法带来了一些显著的问题和陷阱：它 *不是* *可扩展的*，因为您需要一个共同点来存储会话，并且每次用户进行认证时，服务器都需要在数据源中创建一个新的记录。因此，这种方法可能会成为您的网络服务的瓶颈。
- en: Nowadays, token authentication can be helpful to authenticate and authorize
    users, especially in a distributed system context. The main strength of token-based
    authentication lies in the fact that the consumer asks for a token to an identityservice.
    Next, the client can store the token locally and use it for authentication and
    authorization purposes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于令牌的认证对于验证和授权用户非常有帮助，尤其是在分布式系统环境中。基于令牌的认证的主要优势在于消费者向身份服务请求令牌。接下来，客户端可以本地存储令牌，并用于认证和授权目的。
- en: 'Therefore, token authentication is *stateless* and *designed to be scalable*.
    Let''s have a look at the token-authentication process and how it works, to better
    understand the benefits of this kind of approach:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，令牌认证是无状态的，并且**设计用于可扩展性**。让我们看看令牌认证过程以及它是如何工作的，以便更好地理解这种方法的优点：
- en: '![](img/1ee505ee-009d-4b3e-a04b-4499295d996b.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ee505ee-009d-4b3e-a04b-4499295d996b.png)'
- en: 'This schema describes a typical workflow when implementing token-based authentication.
    The schema describes three entities:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此架构描述了在实现基于令牌的认证时的典型工作流程。该架构描述了三个实体：
- en: The *client* is the application that is trying to access our resources.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**是尝试访问我们资源的应用程序。'
- en: The *identity provider* is the service that, given a username and a password,
    provides an encrypted authentication token.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份提供者**是提供服务的服务，给定用户名和密码，提供加密的认证令牌。'
- en: The *resource provider* is another service called by the *client.* Furthermore*,
    the resource provider* will accept the encrypted authentication token, and it
    will provide the information requested by the *client* if it is authorized.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源提供者**是客户端调用的另一个服务。此外，**资源提供者**将接受加密的认证令牌，并在授权的情况下提供客户端请求的信息。'
- en: Since token-based authentication has a *stateless* approach, the application
    doesn't store the authentication tokens. Therefore, it is essential to note that
    the client must pass the authentication token in every request.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于令牌的认证采用无状态的方法，应用程序不会存储认证令牌。因此，必须注意客户端必须在每次请求中传递认证令牌。
- en: 'Token-based authentication can be implemented in different ways. **JSON Web
    Token** (**JWT**) is a standard, defined in the RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    open directive, which describes a way to represent claims between two parties.
    JWT is defined as a JSON object, which contains the payload, and a signature,
    which encrypts the data in the token. In other words, it provides a way to encrypt
    secure data formatted as JSON through the use of a secret key. The JWT token standard
    has become quite popular in recent years because web services can use it for two
    purposes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的认证可以以不同的方式实现。**JSON Web Token**（**JWT**）是一个标准，定义在RFC 7519（[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)）开放指令中，它描述了在双方之间表示声明的途径。JWT被定义为包含有效载荷和签名的JSON对象，其中签名加密了令牌中的数据。换句话说，它通过使用密钥提供了一种加密以JSON格式安全数据的方法。近年来，JWT令牌标准变得非常流行，因为网络服务可以用它实现两个目的：
- en: '**Authorization**: The web service returns a JWT token to transfer information
    about claims and personal details to signed-in users. Moreover, single sign-on
    features and token authentication features use this technique to transfer data
    to the client.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：网络服务返回JWT令牌以传输有关声明和个人细节的信息给已登录的用户。此外，单点登录功能和令牌认证功能使用这种技术将数据传输到客户端。'
- en: '**Information exchange**: You can use the JWT token standard to prevent data
    exploitation and to certify the authenticity of the data you have received by
    signing it with the provided key.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息交换**：您可以使用JWT令牌标准通过使用提供的密钥对数据进行签名来防止数据被利用，并验证您收到的数据的真实性。'
- en: 'The JWT token anatomy is very similar to the structure of a web request. It
    is composed of three parts: *header*, *payload*, and *signature*. The header part
    contains information about the token type and the signing algorithm used by the
    token:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌的解剖结构非常类似于Web请求的结构。它由三部分组成：*头部*、*载荷*和*签名*。头部部分包含有关令牌类型和令牌使用的签名算法的信息：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In that case, we can deduce that the token uses the *HMAC* *SHA256* algorithm,
    and it is a JWT token type. The *payload* part is the core part of our token,
    and it contains the information to be sent to the user. By default, there is a
    set of predefined information to populate, for example, the `exp` *(expiration
    time)* field. The following JSON is an example of a payload:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们可以推断出该令牌使用的是*HMAC* *SHA256*算法，并且它是一个JWT令牌类型。*载荷*部分是我们令牌的核心部分，它包含要发送给用户的信息。默认情况下，有一组预定义的信息用于填充，例如，`exp`（**过期时间**）字段。以下JSON是一个载荷的示例：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `email` field is a claim for the token. `nbf` stands for **not valid before**,
    and `iat` stands for **issued at**. The three fields represent the time calculated
    since the UNIX epoch.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`邮箱`字段是对令牌的声明。`nbf`代表**在...之前无效**，而`iat`代表**签发于**。这三个字段代表自UNIX纪元以来计算的时间。'
- en: Finally, the *signature* part of the token signs the encoded header and the
    encoded payload with the secret key and the algorithm specified in the header.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，令牌的*签名*部分使用在头部指定的密钥和算法对编码的头部和编码的有效负载进行签名。
- en: 'The resulting encoded token is similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的编码令牌类似于以下内容：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is crucial to note that each point separator (`.`) in the encoded token represents
    an encrypted token, as described earlier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，编码令牌中的每个点分隔符（`.`）代表一个加密令牌，如前所述。
- en: Implementing token-based authentication
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于令牌的认证
- en: In this section, we will see how to perform token-based authentication using
    ASP.NET Core. Going into more detail, we will dig into the development and testing
    of the token-based authentication and learn how to store user data in a database
    using the default identity provider of ASP.NET Core.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用ASP.NET Core执行基于令牌的认证。更详细地说，我们将深入了解基于令牌的认证的开发和测试，并学习如何使用ASP.NET
    Core的默认身份提供者将用户数据存储在数据库中。
- en: Furthermore, we will implement the authentication as part of the *catalog service*
    solution. It is essential to note that, in real-world applications, the authentication
    and the whole identity process have a dedicated service with a separate data store.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将实现身份验证作为*目录服务*解决方案的一部分。需要注意的是，在实际应用中，身份验证和整个身份过程都有一个专门的服务和独立的数据存储。
- en: For demo purposes, we are going to implement the authentication part inside
    the *catalog service*. Please consider keeping the identity part of your application
    in a separate service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将在*目录服务*中实现认证部分。请考虑将您应用程序的身份验证部分保留在单独的服务中。
- en: 'Let''s start by adding the packages we need to develop token-based authentication
    in our `Catalog.Domain` and `Catalog.Infrastructure` projects. Please note that
    these packages are compatible only with the `netcoreapp3.1` framework, therefore,
    you need to change the `TargetFramework` variable in the csproj from `netstandard2.1`
    to `netcoreapp3.1`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们需要的包来开发基于令牌的认证，这些包在`Catalog.Domain`和`Catalog.Infrastructure`项目中。请注意，这些包仅与`netcoreapp3.1`框架兼容，因此您需要将csproj中的`TargetFramework`变量从`netstandard2.1`更改为`netcoreapp3.1`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to define the `User` entity inside the `Catalog.Domain` project:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`Catalog.Domain`项目中定义`User`实体：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `User` entity represents a generic user inside the *domain model* of the
    service. It is important to note that it extends the `IdentityUser` class, which
    provides some additional fields to the entity. The `IdentityUser` class identifies
    a storable user entity. Furthermore, the entity can be used to store data through
    the `Microsoft.AspNetCore.Identity` package.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`实体代表服务*领域模型*中的通用用户。需要注意的是，它扩展了`IdentityUser`类，为实体提供了额外的字段。`IdentityUser`类标识一个可存储的用户实体。此外，该实体可以通过`Microsoft.AspNetCore.Identity`包存储数据。'
- en: 'Let''s proceed by declaring the `IUserRepository` interface in the `Catalog.Domain`
    project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`Catalog.Domain`项目中声明`IUserRepository`接口：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This interface represents an intermediary between the *catalog service* and
    the data layer. Moreover, it can be used to authenticate, register, and retrieve
    `User` entities. The `IUserRepository` acts like a data store for the user data,
    and it also performs user-related operations, such as the sign-up process and
    authentication. It is also important to note that the `AuthenticateAsync` and
    `SignUpAsync` methods return a boolean that indicates whether the corresponding
    operation has succeeded.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口代表了*目录服务*和数据层之间的中介。此外，它可以用于验证、注册和检索`User`实体。`IUserRepository`充当用户数据的数据存储，并执行与用户相关的操作，例如注册过程和身份验证。需要注意的是，`AuthenticateAsync`和`SignUpAsync`方法返回一个布尔值，表示相应的操作是否成功。
- en: Defining the service layer
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义服务层
- en: 'After defining the `User` entity and the `IUserRepository` interface, we can
    proceed with the definition of the service layer in the `Catalog.Domain` project.
    Let''s start by describing the `IUserService` interface:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`User`实体和`IUserRepository`接口之后，我们可以在`Catalog.Domain`项目中继续定义服务层。让我们先描述`IUserService`接口：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The interface defines the methods necessary for the authentication phase. The
    `GetUserAsync` method uses the `GetUserRequest` type to retrieve information related
    to a specific user. The `SignUpAsync` and the `SignInAsync` methods define the
    sign-up and sign-in process: the sign-up operation returns a new `UserResponse`
    instance, which determines the information related to the signed user, and the
    sign-in operation returns the `TokenResponse` instance, which contains the resulting
    token that will be stored by the client. Therefore, let''s proceed by defining
    the request DTOs used by the service interface:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了认证阶段所需的必要方法。`GetUserAsync` 方法使用 `GetUserRequest` 类型检索与特定用户相关的信息。`SignUpAsync`
    和 `SignInAsync` 方法定义了注册和登录过程：注册操作返回一个新的 `UserResponse` 实例，它确定了注册用户的有关信息，而登录操作返回包含结果的
    `TokenResponse` 实例，该实例将包含客户端将存储的令牌。因此，让我们通过定义服务接口使用的请求 DTO 来继续：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For brevity, request classes are represented in a unique snippet. The `GetUserRequest`
    type contains an `Email` field that specifies the email address to retrieve. As
    we will see later in the chapter, the `GetUser` action method of the controller
    will need to be authenticated in order to retrieve the user's data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，请求类以唯一的代码片段表示。`GetUserRequest` 类型包含一个 `Email` 字段，指定要检索的电子邮件地址。正如我们将在本章后面看到的那样，控制器上的
    `GetUser` 动作方法需要认证才能检索用户数据。
- en: The `SignInRequest` type defines the `Email` and the `Password` fields used
    to authenticate the user. Finally, the `SignUpRequest` type also contains the
    `Name` of the user represented by a string. Please note that for demo purposes,
    the code only stores the `Name` of the user. In a real-world application, the
    complexity of the `SignUpRequest` type is likely to increase with more personal
    information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignInRequest` 类型定义了用于认证用户的 `Email` 和 `Password` 字段。最后，`SignUpRequest` 类型也包含用字符串表示的用户
    `Name`。请注意，出于演示目的，代码仅存储用户的 `Name`。在实际应用中，`SignUpRequest` 类型的复杂性可能会随着更多个人信息的增加而增加。'
- en: 'Let''s proceed by also defining the response type used by the `IUserService`
    interface:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义 `IUserService` 接口使用的响应类型：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `UserResponse` type is meant to retrieve all the personal information of
    the user. It is important to note that it obviously omits the `Password` field
    of the entity for security reasons. On the other hand, the `TokenResponse` type
    retrieves the `Token` field containing the JWT token resulting from the authentication
    process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserResponse` 类型旨在检索用户的全部个人信息。需要注意的是，出于安全原因，它显然省略了实体的 `Password` 字段。另一方面，`TokenResponse`
    类型检索包含认证过程产生的 JWT 令牌的 `Token` 字段。'
- en: 'Therefore, we can continue by describing the implementation of `IUserService`
    interface: it will contain the logic related to the generation of the token used
    by ASP.NET Core for authentication, and the get and sign-up operations on user
    entities. The following code illustrates the dependencies in the implementation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以继续描述 `IUserService` 接口的实现：它将包含与 ASP.NET Core 用于认证的令牌生成以及用户实体上的获取和注册操作相关的逻辑。以下代码展示了实现中的依赖关系：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As mentioned previously, the `IUserRepository` interface is used as the main
    entry point to query and perform operations on our data source. `IOption<AuthenticationSettings>`
    type defines the settings needed by the authentication process:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`IUserRepository` 接口用作查询和操作我们数据源的主要入口点。`IOption<AuthenticationSettings>`
    类型定义了认证过程所需的设置：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The class is stored in the `Configurations` folder of the `Catalog.Domain`
    project. The `AuthenticationSettings` class contains the `Secret` field, which
    describes a phrase that is used to encrypt the token''s information, and the `ExpirationDays`
    field provides the number of days before the omitted tokens expire. Furthermore,
    we can proceed by defining the `GetUserAsync` and the `SignUpAsync` methods:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该类存储在 `Catalog.Domain` 项目的 `Configurations` 文件夹中。`AuthenticationSettings` 类包含
    `Secret` 字段，它描述了一个用于加密令牌信息的短语，以及 `ExpirationDays` 字段，它提供了省略的令牌在多少天后过期。此外，我们可以继续定义
    `GetUserAsync` 和 `SignUpAsync` 方法：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `GetUserAsync` method uses the request provided by the high-level layer
    to execute the `GetByEmailAsync` method of the `IUserRepository` interface. It
    also maps the response and retrieves a new instance of the `UserReponse` type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetUserAsync` 方法使用高级层提供的请求来执行 `IUserRepository` 接口的 `GetByEmailAsync` 方法。它还映射响应并检索一个新的
    `UserReponse` 类型实例。'
- en: 'On the other hand, the `SignUpAsync` method initializes a new `User` instance
    with the corresponding values, and it performs the `SignUpAsync` method provided
    by the `IUserRepository` interface. Finally, if the user is created, the `SignUpAsync`
    method retrieves a new `UserResponse` instance. Let''s continue by completing
    the implementation of the `IUserService` by defining the `SignInAsync` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`SignUpAsync` 方法使用相应的值初始化一个新的 `User` 实例，并执行 `IUserRepository` 接口提供的 `SignUpAsync`
    方法。最后，如果用户已创建，`SignUpAsync` 方法检索一个新的 `UserResponse` 实例。让我们继续通过定义 `SignInAsync`
    方法来完成 `IUserService` 的实现：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As a first step, the `SignInAsync` method calls the underlying `AuthenticateAsync`
    method provided by `IUserRepository` by giving the `Email` and the `Password`
    sent by the client. The statement returns a boolean variable that indicates whether
    the user is authenticated. If the user is authenticated, the method retrieves
    a new instance of the `TokenResponse` class by calling the `GenerateSecurityToken`
    method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，`SignInAsync` 方法通过提供客户端发送的 `Email` 和 `Password`，调用由 `IUserRepository`
    提供的底层 `AuthenticateAsync` 方法。该语句返回一个布尔变量，指示用户是否已认证。如果用户已认证，该方法通过调用 `GenerateSecurityToken`
    方法检索 `TokenResponse` 类的新实例。
- en: The `GenerateSecurityToken` method defines a new instance of the `JwtSecurityTokenHandler`
    type, which provides some utilities for generating and creates tokens through
    the use of the `CreateToken` and the `WriteToken` methods.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateSecurityToken` 方法定义了一个新的 `JwtSecurityTokenHandler` 类型的实例，该实例通过使用 `CreateToken`
    和 `WriteToken` 方法提供了一些生成和创建令牌的实用工具。'
- en: Furthermore, it defines a new instance of the `SecurityTokenDescriptor` type,
    which declares the `Expire` time and the `SigningCredentials` fields by signing
    the `Secret` field of the `AuthorizationSettings` instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它定义了一个新的 `SecurityTokenDescriptor` 类型的实例，通过在 `AuthorizationSettings` 实例的
    `Secret` 字段上签名，声明了 `Expire` 时间和 `SigningCredentials` 字段。
- en: Applying authentication on the controller
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制器上应用认证
- en: The next steps consist of registering dependencies in the dependency injection
    engine and in using the resulting dependency, for example, the `IUserService`
    instance, in the controller layer. Therefore, this section focuses on the `Catalog.API`
    and `Catalog.Infrastructure` projects.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤包括在依赖注入引擎中注册依赖项，并在控制器层中使用生成的依赖项，例如 `IUserService` 实例。因此，本节重点介绍了 `Catalog.API`
    和 `Catalog.Infrastructure` 项目。
- en: 'Let''s start by defining a new extension method in the `Catalog.Infrastructure`
    project, which adds the authentication part:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `Catalog.Infrastructure` 项目中定义一个新的扩展方法开始，该方法添加了认证部分：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The core part of the preceding code is the execution of two methods: `AddAuthentication`
    and `AddJwtBearer`. Both extension methods add the middlewares and the services
    used by the authentication process. In more detail, `AddAuthentication` specifies
    `DefaultAuthenticationScheme` and `DefaultChallengeScheme` by applying the JWT
    bearer authentication scheme.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的核心部分是执行两个方法：`AddAuthentication` 和 `AddJwtBearer`。这两个扩展方法都添加了认证过程中使用的中间件和服务。更详细地说，`AddAuthentication`
    通过应用 JWT 携带者认证方案来指定 `DefaultAuthenticationScheme` 和 `DefaultChallengeScheme`。
- en: At the same time, the `AddJwtBearer` method defines the options related to token
    authentication, such as the `TokenValidationParameters` field, which includes
    the `SigningKey` used to validate the token parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`AddJwtBearer` 方法定义了与令牌认证相关的选项，例如 `TokenValidationParameters` 字段，它包括用于验证令牌参数的
    `SigningKey`。
- en: 'Furthermore, the `IssuerSigningKey` must be the same as the key used to generate
    the token. Otherwise, the validation will fail. It is important to note that the
    `ValidateIssuer` and the `ValidateAudience` fields are `false`. Therefore, ASP.NET
    Core will not validate the issuer or the audience URL. Although this approach
    works fine for testing environments, I strongly suggest using the following setup
    for production cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`IssuerSigningKey` 必须与生成令牌时使用的密钥相同。否则，验证将失败。重要的是要注意，`ValidateIssuer` 和 `ValidateAudience`
    字段设置为 `false`。因此，ASP.NET Core 不会验证发行者或受众 URL。尽管这种方法在测试环境中运行良好，但我强烈建议在生产环境中使用以下设置：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the validation of the issuer and the audience will happen; therefore
    it will check that the token issuer and the audience of the token match those
    specified in the configurations. The `AddTokenAuthentication` extension method
    also owns the registration of the `AuthenticationSettings` used by the `UserService`
    class. Therefore, let''s have a look at the `AuthenticationSettings` values defined
    in the `appsettings.json` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将验证发行者和受众；因此，它将检查令牌的发行者和受众是否与配置中指定的相匹配。`AddTokenAuthentication` 扩展方法还拥有
    `UserService` 类使用的 `AuthenticationSettings` 的注册。因此，让我们看看在 `appsettings.json` 文件中定义的
    `AuthenticationSettings` 值：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that, we can proceed by adding the authentication implementation to the
    `Startup` class in the `Catalog.API` project:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过向 `Catalog.API` 项目的 `Startup` 类中添加身份验证实现来继续操作：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Startup` class is the core component that initializes the authentication
    process. In the `ConfigureServices` method, it configures and initializes the
    `AuthorizationSettings` class by reading from the `appsettings.json` file. Next,
    it calls the `AddAuthentication` extension method by passing the `AuthorizationSettings`
    type instance. It is also essential to note that the `Configure` method adds authentication
    middleware by calling the `UseAuthentication` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Startup` 类是初始化身份验证过程的核心理念。在 `ConfigureServices` 方法中，它通过从 `appsettings.json`
    文件中读取来配置和初始化 `AuthorizationSettings` 类。接下来，它通过传递 `AuthorizationSettings` 类型实例调用
    `AddAuthentication` 扩展方法。还必须注意的是，`Configure` 方法通过调用 `UseAuthentication` 方法添加身份验证中间件。'
- en: 'Finally, we can proceed by adding the `UserController` and exposing authentication
    routes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过添加 `UserController` 并公开身份验证路由来继续操作：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code defines the `UserController` class, which exposes authentication
    routes. It is important to note that the whole controller is decorated by using
    the `[Authorize]` attribute, which means that each route is covered by authentication.
    Therefore, to access the routes declared within the controller it is necessary
    to use a valid token in the request. The class defines an action method for each
    operation defined before in the service layer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了 `UserController` 类，该类公开身份验证路由。重要的是要注意，整个控制器都使用 `[Authorize]` 属性进行装饰，这意味着每个路由都受到身份验证的保护。因此，要访问控制器中声明的路由，必须在请求中使用有效的令牌。该类为服务层中定义的每个操作定义了一个动作方法：
- en: The `Get` action method exposes some details regarding the current user, such
    as the `Email` field and the `Name` field. The action method gets user details
    from the incoming token. The token information is represented by accessing the
    `HttpContext.User` property and getting the value of `ClaimType.Email`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get` 动作方法暴露了有关当前用户的一些细节，例如 `Email` 字段和 `Name` 字段。动作方法从传入的令牌中获取用户详情。令牌信息通过访问
    `HttpContext.User` 属性并获取 `ClaimType.Email` 的值来表示。'
- en: The `SignIn` action method is decorated using `[AllowAnonymous]` attribute.
    Furthermore, it is possible to call the action method without being authenticated.
    The action method binds the `request.Email` and `request.Password` fields and
    sends the request object using `IUserService` interface. The action method returns
    the `TokenResponse` with the generated token.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SignIn` 动作方法也使用 `[AllowAnonymous]` 属性进行装饰。此外，还可以在不进行身份验证的情况下调用动作方法。动作方法将 `request.Email`
    和 `request.Password` 字段绑定，并使用 `IUserService` 接口发送请求对象。动作方法返回带有生成令牌的 `TokenResponse`。'
- en: The `SignUp` action method is also decorated using the `[AllowAnonymous]` attribute.
    In that case, the action method registers a new user and returns the `201 Created`
    HTTP code if the operation has success.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SignUp` 动作方法也使用 `[AllowAnonymous]` 属性进行装饰。在这种情况下，动作方法注册一个新用户，如果操作成功，则返回 `201
    Created` HTTP 状态码。'
- en: Our setup is now almost complete. What we need to do is define the last common
    point between the `IUserRepository` interface and the underlying data store. For
    this purpose, we will use again the EF Core framework combined with the `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    package maintained by Microsoft.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的设置几乎完成了。我们需要做的是定义 `IUserRepository` 接口和底层数据存储之间的最后一个共同点。为此，我们将再次使用 EF Core
    框架和由 Microsoft 维护的 `Microsoft.AspNetCore.Identity.EntityFrameworkCore` 包。
- en: Storing data using EF Core
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 存储数据
- en: 'Let''s proceed by implementing the data access layer and create a concrete
    implementation of the `IUserRepository` interface. The `UserRepository` class
    will have to main dependencies, the `SignInManager` and the `UserManager` classes,
    both of which are provided by the `Microsoft.AspNetCore.Identity` package:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现数据访问层，并创建 `IUserRepository` 接口的具体实现。`UserRepository` 类将有两个主要依赖项，即 `SignInManager`
    和 `UserManager` 类，这两个类都由 `Microsoft.AspNetCore.Identity` 包提供：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the resulting code implements the `IUserRepository` interface.
    The class depends on the `SignInManager<User>` and the `UserManager<User>` types.
    These types accept a generic entity class that is a representation of the authentication
    objects. The `SignInManager<T>` generic class provides functionalities with which
    to interact with the user sign-in process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，生成的代码实现了 `IUserRepository` 接口。该类依赖于 `SignInManager<User>` 和 `UserManager<User>`
    类型。这些类型接受一个泛型实体类，该类是认证对象的表示。`SignInManager<T>` 泛型类提供了与用户登录过程交互的功能。
- en: It exposes the `PasswordSignInAsync` method used by the `UserRepository.Authenticate`
    method. On the other hand, the `UserManager<T>` class provides ways to interact
    with users in a persistent store. Furthermore, `UserRepository` uses the `SignUp`
    and the `UserRepository.GetByEmail` method to interact with the database.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它公开了 `PasswordSignInAsync` 方法，该方法由 `UserRepository.Authenticate` 方法使用。另一方面，`UserManager<T>`
    类提供了与持久存储中用户交互的方法。此外，`UserRepository` 使用 `SignUp` 和 `UserRepository.GetByEmail`
    方法与数据库交互。
- en: Declaring the identity database context
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明身份数据库上下文
- en: 'Once we have declared the `IUserRepository` implementation, we can proceed
    by declaring the *identity data context.* The *identity data context* is identified
    by extending the `IdentityDbContext` class. This type of `DbContext` is used by
    EF Core to locate and access the data source used as the persistent user store.
    In order to declare the *identity data context,* it is necessary to extend the
    `CatalogContext` in the following way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了 `IUserRepository` 的实现，我们就可以继续声明 *身份数据上下文*。*身份数据上下文* 通过扩展 `IdentityDbContext`
    类来识别。这种类型的 `DbContext` 由 EF Core 用于定位和访问用作持久用户存储的数据源。为了声明 *身份数据上下文*，有必要以下列方式扩展
    `CatalogContext`：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is essential to note that the `IdentityDbContext` class extends the `DbContext`
    class. Furthermore, every property and behavior present in the `DbContext` class
    is also inherited by the `IdentityDbContext` class. Therefore, it is essential
    to note that the override method, `OnModelCreating`, must also call the base method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`IdentityDbContext` 类扩展了 `DbContext` 类。此外，`DbContext` 类中存在的每个属性和行为也被
    `IdentityDbContext` 类继承。因此，必须注意，重写方法 `OnModelCreating` 也必须调用基方法。
- en: 'To provide a way to store user information using EF Core, it is also necessary
    to add and configure the identity system for the specified `User` type by calling
    the `AddIdentity` extension method. Furthermore, it is also essential to call
    `AddEntityFrameworkStores` and refer to the `CatalogContext` class to add the
    entity framework implementation. The following code is the previously created
    `AddAuthentication` extension method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供使用 EF Core 存储用户信息的方法，还必须通过调用 `AddIdentity` 扩展方法添加和配置指定 `User` 类型的身份系统。此外，还必须调用
    `AddEntityFrameworkStores` 并引用 `CatalogContext` 类以添加实体框架实现。以下代码是之前创建的 `AddAuthentication`
    扩展方法：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we can proceed by initializing `IUserRepository` with its concrete
    implementation. Also, in that case, we will declare the dependency injection resolution
    in the `Startup` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过初始化 `IUserRepository` 的具体实现来继续操作。在这种情况下，我们将在 `Startup` 类中声明依赖注入解析：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the same way, we can register `IUserService` by adding the following row
    to the `AddServices` extension method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过向 `AddServices` 扩展方法添加以下行来注册 `IUserService`：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To sum up, now we have the whole authentication stack in place. The `Catalog.API`
    project exposes the HTTP routes through the `UserController` class. The controller
    depends on the `IUserService` interface, which exposes the operation needed by
    the authentication process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，现在我们已经部署了整个认证栈。`Catalog.API` 项目通过 `UserController` 类公开了 HTTP 路由。该控制器依赖于
    `IUserService` 接口，该接口公开了认证过程所需的操作。
- en: Consequently, the `UserService` class depends on the `IUserRepository` interface,
    which is the main entry point that calls the API exposed by the EF Core framework.
    Therefore, we can now proceed by verifying the authentication logic using some
    tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`UserService` 类依赖于 `IUserRepository` 接口，这是调用 EF Core 框架公开的 API 的主要入口点。因此，我们现在可以通过一些测试来验证认证逻辑。
- en: Testing authentication
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试认证
- en: 'Testing our code is essential at this point: we should check, document, and
    verify the behaviors of our system before running the application in a server
    instance. Furthermore, it is also crucial to test authentication behavior because
    it is a sensitive part of our service.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段测试我们的代码是至关重要的：我们应该在将应用程序运行在服务器实例之前检查、记录并验证我们系统的行为。此外，测试认证行为也非常关键，因为它是我们服务的一个敏感部分。
- en: Since the `UserRepository` implementation is the most low-level part of the
    authentication stack and the first component that relies on EF Core to retrieve,
    update, and authenticate the user, we can keep it isolated and exclude it from
    the testing process by mocking the `IUserRepository` interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `UserRepository` 实现是认证堆栈中最底层的部分，并且是第一个依赖于 EF Core 来检索、更新和验证用户的组件，我们可以将其保持隔离，并通过模拟
    `IUserRepository` 接口来排除它从测试过程中。
- en: Both `SignInManager<T>` and the `UserManager<T>` classes represent a core part
    of our authentication process, and they are part of a third-party package maintained
    by Microsoft. Furthermore, it is not necessary to cover their implementations
    with tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignInManager<T>` 和 `UserManager<T>` 类代表了我们认证过程的核心部分，它们是微软维护的第三方包的一部分。此外，没有必要用测试来覆盖它们的实现。'
- en: 'Let''s start by defining a new `UserContextFactory` in the `Catalog.Fixture`
    project in the `tests` folder:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `tests` 文件夹中的 `Catalog.Fixture` 项目中定义一个新的 `UserContextFactory` 开始：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The factory class exposes an `IUserRepository` instance with some pre-populated
    data and it depends on the `PasswordHasher<T>` generic type, which is used by
    `SignUp` and in the `Authenticate` mock methods declaration to *encode-decode*
    the password by using the `HashPassword` and `VerifyHashedPassword` methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂类公开了一个带有一些预填充数据的 `IUserRepository` 实例，并且它依赖于 `PasswordHasher<T>` 泛型类型，该类型在
    `SignUp` 和 `Authenticate` 模拟方法声明中用于通过 `HashPassword` 和 `VerifyHashedPassword`
    方法来 *编码-解码* 密码。
- en: 'It is important to note that the `IUserRepository` interface is mocked through
    the use of the `GetInMemoryUserManager` method. Furthermore, it uses `List<User>`
    to emulate a data source, and it implements the `AuthenticateAsync`, `GetByEmailAsync`,
    and `SignUpAsync` methods exposed by the `IUserRepository` interface using the
    `Moq` library:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`IUserRepository` 接口是通过使用 `GetInMemoryUserManager` 方法模拟的。此外，它使用 `List<User>`
    来模拟数据源，并使用 `Moq` 库实现了 `IUserRepository` 接口暴露的 `AuthenticateAsync`、`GetByEmailAsync`
    和 `SignUpAsync` 方法：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code returns a mocked `IUserRepository` instance by providing
    a fake behavior for the methods of the interface. Consequently, it is possible
    to verify the `IUserService` class by implementing the following test class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码通过为接口的方法提供模拟行为来返回一个模拟的 `IUserRepository` 实例。因此，我们可以通过实现以下测试类来验证 `IUserService`
    类：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The test class implements two different tests: `signin_with_invalid_user_should_return_a_valid_token_response`
    and `signin_with_valid_user_should_return_a_valid_token_response`. In both cases,
    the tests will use `UserContextFactory` to resolve the dependency of the class.
    We will also use the `Option.Create` method provided by ASP.NET Core to generate
    `AuthenticationSettings` options. In this case, we are testing the entire stack
    that has been implemented in the handler layer.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类实现了两个不同的测试：`signin_with_invalid_user_should_return_a_valid_token_response`
    和 `signin_with_valid_user_should_return_a_valid_token_response`。在两种情况下，测试都将使用
    `UserContextFactory` 来解决类的依赖。我们还将使用 ASP.NET Core 提供的 `Option.Create` 方法来生成 `AuthenticationSettings`
    选项。在这种情况下，我们正在测试在处理层中实现的整体堆栈。
- en: 'It is essential to note that we are excluding the whole underlying part related
    to the management and storage of the users'' information. We can expand the scope
    of our tests by including the controller part. Going into more detail, we can
    implement the test to check the functionalities implemented in the `UserController`
    class. To do that, we will inject a fake `IUserRepository` implementation at `TStartup`
    time, using the `services.Replace` instruction:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们正在排除与用户信息管理和存储相关的整个底层部分。我们可以通过包括控制器部分来扩展测试范围。更详细地说，我们可以实现测试来检查`UserController`类中实现的功能。为此，我们将在`TStartup`时间注入一个假的`IUserRepository`实现，使用`services.Replace`指令：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can act on the `InMemoryApplicationFactory<TStartup>` class to replace the
    `IUserService` with a new instance of the mocked class by initializing the `UsersContextFactory`
    class. After that, it will be possible to test the `UserController` class action
    by resolving the `InMemoryApplicationFactory<TStartup>` factory class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过初始化`UsersContextFactory`类来对`InMemoryApplicationFactory<TStartup>`类进行操作，用模拟类的新的实例替换`IUserService`。之后，将能够通过解析`InMemoryApplicationFactory<TStartup>`工厂类来测试`UserController`类的操作：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous code verifies the routes defined in the `UserController` class,
    and it also performs an integration test by checking the authentication process.
    The `sign_in_should_retrieve_a_token` test method calls the `/api/user/auth` address
    using the HTTP `POST` verb to verify the implementation of the sign-in procedure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码验证了`UserController`类中定义的路由，并且还通过检查认证过程执行了集成测试。`sign_in_should_retrieve_a_token`测试方法使用HTTP
    `POST`动词调用`/api/user/auth`地址来验证登录过程的实现。
- en: 'Additionally, it also validates the operation in case the user''s password
    is wrong. Furthermore, we can also provide more tests to verify the whole process
    of authentication, from the sign-in phase to the call to retrieve the authenticated
    user data:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还验证了在用户密码错误时的操作。此外，我们还可以提供更多测试来验证从登录阶段到检索已认证用户数据的整个认证过程：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Going into more detail, the `get_with_authorized_user_should_retrieve_the_right_user`
    test executes the following operations:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，`get_with_authorized_user_should_retrieve_the_right_user`测试执行以下操作：
- en: It performs a `POST` request to the following route/`auth` in order to authenticate
    the user.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它向以下路由/`auth`执行`POST`请求以认证用户。
- en: It deserializes the result of the `POST` request, and it gets the token field.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它反序列化`POST`请求的结果，并获取令牌字段。
- en: It adds an authentication header by passing the token, and it performs a request
    to the `/api/user` route.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过传递令牌添加一个认证头，并对`/api/user`路由执行请求。
- en: It checks that the result status code is HTTP `200 OK`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查结果状态码是否为HTTP `200 OK`。
- en: 'In this way, we are testing both the `UsersController` class and the underlying
    handlers used in each action method. It is also possible to test the authentication
    process by running the catalog web service using the `docker-compose up --build`
    command. First of all, we need to create a new user by adding some necessary information,
    such as the email and the name of the user:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们正在测试`UsersController`类以及每个操作方法中使用的底层处理程序。通过运行`docker-compose up --build`命令来运行目录网络服务也可以测试认证过程。首先，我们需要通过添加一些必要的信息，如用户的电子邮件和姓名来创建一个新用户：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The previous HTTP call (written as a `curl` call) creates a new user with the
    specified credentials. We can proceed by generating the token using our credentials:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的HTTP调用（以`curl`调用形式编写）使用指定的凭据创建了一个新用户。我们可以通过使用我们的凭据生成令牌来继续操作：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we can continue by calling the secret endpoint using the following
    call:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过以下调用继续调用秘密端点：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The aforementioned `curl` command calls the `https://localhost:5001/api/users/`
    address by passing the token in the `Authorization` header of the request.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`curl`命令通过在请求的`Authorization`头中传递令牌来调用`https://localhost:5001/api/users/`地址。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to secure a web service using some standard
    practices. HTTPS is now a standard and must-have feature if you want to secure
    data. Furthermore, we saw how token-based authentication provides a useful way
    to secure data and information that are exposed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用一些标准实践来保护一个网络服务。HTTPS现在是一个标准和必须具备的功能，如果你想要保护数据。此外，我们还看到了基于令牌的身份验证如何提供一种保护暴露的数据和信息的有用方式。
- en: The topics covered in this chapter provide a way to secure information exposed
    by the web service, and explored the implementation of token-based authentication
    in distributed systems.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题提供了一种确保由网络服务暴露的信息的安全的方法，并探讨了在分布式系统中基于令牌的认证实现。
- en: In the next chapter, we will see how to cache responses in ASP.NET Core and
    look at how a caching mechanism works in general.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何在 ASP.NET Core 中缓存响应，并了解缓存机制的一般工作原理。
