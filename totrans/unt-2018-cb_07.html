<html><head></head><body>
        

                            
                    <h1 class="header-title">Using Cameras</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating the basic scene for this chapter</li>
<li>Creating a picture-in-picture effect</li>
<li>Switching between multiple cameras</li>
<li>Making textures from screen content</li>
<li>Zooming a telescopic camera</li>
<li>Displaying a minimap</li>
<li>Creating an in-game surveillance camera</li>
<li>Working with Unity's multi-purpose camera rig</li>
<li>Using Cinemachine ClearShot to switch cameras to keep the player in shot</li>
<li>Letting the player switch to a Cinemachine FreeLook camera</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>As developers, we should never forget to pay attention to <strong>Cameras</strong>. After all, they are the windows through which our players see our games. In this chapter, we will take a look at interesting ways of using <strong>Cameras</strong> that enhance the player's experience.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>A <strong>Scene</strong> can contain multiple <strong>Cameras</strong>. Often, we have one Main Camera (we're given one by default with a new Scene). For <strong>First-Person</strong> viewpoint games, we control the position and rotation of the <strong>Camera</strong> directly, since it acts as our eyes. In <strong>Third-Personal</strong> viewpoint games, our main <strong>Camera</strong> follows an animated 3D character (usually from above/behind/over the shoulder), and may slowly and smoothly change its position and rotation as if a person were holding the <strong>Camera</strong> and moving to keep us in view.</p>
<p>Perspective <strong>Cameras</strong> have a triangular pyramid-shaped volume of space in front of them, called a <strong>frustrum.</strong> Objects inside this space are projected onto a plane, which determines what we see from the <strong>Camera.</strong> We can control this volume of space by specifying the clipping planes and the field of view. The clipping planes define the minimum and maximum distance objects have to be between to be considered viewable. The field of view is decided by how wide or narrow the pyramid shape is:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/544a4efb-3a80-4b82-bf37-888035c50bbc.png"/></p>
<p>Cameras can be customized in many ways:</p>
<ul>
<li>They can exclude objects on specific layers from rendering</li>
<li>They can be set to render in Orthographic mode (that is, without perspective)</li>
<li>They can have their <strong>Field of View</strong> (<strong>FOV</strong>) manipulated to simulate a wide- or narrow-angle lenses</li>
<li>They can be rendered on top of other cameras or within specific areas of the screen (viewports)</li>
<li>They can be rendered into Textures files</li>
</ul>
<p>The list goes on. The following screenshot illustrates several of these Camera features. The same Scene has a perspective Camera, outputting to a viewport taking up the entire Game screen (from 0,0 to 1,1). On top of this is a second viewport for an Orthographic Camera, showing a 2D top-down view of the same Scene's contents. This viewport is just the top-left quarter of the screen <kbd>(0, 0.5)</kbd> to <kbd>(0.5, 1.0)</kbd>. The "ghost" character is on a layer that is ignored (culled) by the second <strong>Orthographic</strong> Camera:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b4994613-9dc7-41e5-b6ea-45a88357a702.png" style="width:36.58em;height:34.50em;"/></p>
<p><strong>Cameras</strong> have a depth property. This is used by Unity to determine in what sequence <strong>Cameras</strong> are rendered. Unity renders <strong>Cameras</strong> starting with the lowest depth number, and working up to the highest. This is needed to ensure that <strong>Cameras</strong> that are not rendered to fill the whole screen are rendered after <strong>Cameras</strong> that are. You'll see this illustrated in several recipes, including the picture-in-picture recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cinemachine</h1>
                
            
            
                
<p>Developed by Adam Myhill, and now available free as a Unity Package, <strong>Cinemachine</strong> is a powerful automated system for camera control. It offers much to Unity developers, both for <strong>Run-Time</strong> in-game camera control and also cinematic creation for cut scenes or complete animated films. We end this chapter with examples of how to add some <strong>Run-Time</strong> camera controls to your games using <strong>Cinemachine.</strong></p>
<p class="MsoSalutation">At the core of Cinemachine is the concept of a set of Virtual Cameras in a Scene and a Cinemachine Brain component, which decides which virtual camera's properties should be used to control the Scene's <strong>Main Camera</strong>.</p>
<p>Learn more about the history and development of Cinemachine at <a href="http://www.cinemachineimagery.com/">http://www.cinemachineimagery.com/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the basic scene for this chapter</h1>
                
            
            
                
<p>All the recipes in this chapter start off with the same basic scene, featuring a 3D maze, some objects, and a keyboard-controllable 3D character. In this recipe, you'll create a project with such a scene, which can be duplicated and adapted for each recipe that follows.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a8611645-76d7-4231-8804-b8b3bd0d5a96.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity package named <kbd>CamerasChapter.unity</kbd>, containing all the resources needed for this chapter. The package can be found in the <kbd>06_01</kbd> folder.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create the basic scene for this chapter, just follow these steps:</p>
<ol>
<li>Create a new 3D project.</li>
<li>Import the CamerasChapter package into your Unity Project.</li>
<li>In the Project panel, you'll find three Prefabs in the <kbd>Prefabs</kbd> folder (<kbd>maze-floor-walls</kbd>, <kbd>maze-objects</kbd>, <kbd>character-MsLazer</kbd>). Create GameObjects for each of these three Prefabs by dragging the Prefabs from the Project panel into the Hierarchy or Scene panels.</li>
<li>You should now have a maze with a floor, some walls, some <strong>Sphere</strong> objects, a green respawn point, and the keyboard-controllable character-MsLazer 3D character.</li>
<li>Let's attach the Scene's <strong>Main Camera</strong> to the character, so that you'll see this Third Person Controller character all the time as you move it around the maze. Child the Main Camera to <kbd>character-MsLazer</kbd>.</li>
<li>In the Inspector, set the Main Camera Position to (0, 3, -5), and Rotation to (5, 0, 0).</li>
<li>Now, as you use the arrow keys to move the character around the maze, the <strong>Main Camera</strong> should move and rotate automatically with the character, and you should be able to see the back of the character at all times.</li>
<li>Save and run the Scene. As you move the character, the <strong>Main Camera</strong> should move around with the character.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>By cloning Prefabs, you have added a maze and some objects to an empty Scene. You have also added a keyboard-controller character to the Scene.</p>
<p>By childing the <strong>Main Camera</strong> to the character GameObject, the <strong>Main Camera</strong> maintains the same position and rotation relative to the character at all times. Therefore, as the character moves so does the <strong>Main Camera</strong><strong>,</strong> giving a simple, over-the-shoulder type viewpoint for the game action.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a picture-in-picture effect</h1>
                
            
            
                
<p>Having more than one viewport displayed can be useful in many situations. For example, you may want to show simultaneous events going on in different locations, or you may want to have a separate window for hot-seat multiplayer games:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ecea56b2-9da5-463d-bd88-73ca4c01cbd6.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the scene created in the first recipe of this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a picture-in-picture display, just follow these steps:</p>
<ol>
<li>Add a new Camera to the scene named <kbd>Camera-pic-in-pic</kbd>. Choose menu: Create | Camera.</li>
<li>In the Inspector, for the <kbd>Camera</kbd> component, set the Depth property to <kbd>1</kbd>.</li>
<li>Uncheck or remove the camera's Audio Listener component, since there should only be one active Audio Listener in a Scene.</li>
<li>Create a new C# script-class named <kbd>PictureInPicture</kbd>, and add an instance-object as a component to the Camera-pic-in-pic GameObject:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    using UnityEngine;<br/>     public class PictureInPicture : MonoBehaviour {<br/>         public enum HorizontalAlignment {<br/>             Left, Center, Right<br/>         };<br/> <br/>         public enum VerticalAlignment {<br/>             Top, Center, Bottom<br/>         };<br/> <br/>         public HorizontalAlignment horizontalAlignment = HorizontalAlignment.Left;<br/>         public VerticalAlignment verticalAlignment = VerticalAlignment.Top;<br/>         public float widthPercentage = 0.5f;<br/>         public float heightPercentage = 0.5f;<br/>         private Camera camera;<br/> <br/>         void Start(){<br/>             camera = GetComponent&lt;Camera&gt;();<br/>         }<br/> <br/>         void Update() {<br/>             Vector2 origin = CalcOrigin();<br/>             Vector2 size = new Vector2(widthPercentage, heightPercentage);<br/>             Rect newCameraRect = new Rect(origin, size);<br/>             camera.rect = newCameraRect;<br/>         }<br/> <br/> <br/>         private Vector2 CalcOrigin() {<br/>             float originX = 0;<br/>             float originY = 0;<br/> <br/>             switch (horizontalAlignment) {<br/>                 case HorizontalAlignment.Right:<br/>                     originX = 1 - widthPercentage;<br/>                     break;<br/> <br/>                 case HorizontalAlignment.Center:<br/>                     originX = 0.5f - (0.5f * widthPercentage);<br/>                     break;<br/> <br/>                 case HorizontalAlignment.Left:<br/>                 default:<br/>                     originX = 0;<br/>                     break;<br/>             }<br/> <br/>             switch (verticalAlignment) {<br/>                 case VerticalAlignment.Top:<br/>                     originY = 1 - heightPercentage;<br/>                     break;<br/> <br/>                 case VerticalAlignment.Center:<br/>                     originY = 0.5f - (0.5f * heightPercentage);<br/>                     break;<br/> <br/>                 case VerticalAlignment.Bottom:<br/>                 default:<br/>                     originY = 0;<br/>                     break;<br/>             }<br/> <br/>             return  new Vector2(originX, originY);<br/>         }<br/>     }</pre>
<ol start="5">
<li>In the Inspector, change some of the Picture In Picture (Script) parameters: choose top and right for vertical and horizontal alignment. Choose 0.25 for vertical and horizontal percentage.</li>
<li>Play your Scene. In the Game panel, your picture-in-picture Camera's viewport should be visible in the top-left corner of the screen, taking up a quarter (25%) of the screen.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this example, you added a second <strong>Camera</strong> in order to display the scene from a different point of view.</p>
<p>The default Main Camera has the default <kbd>depth</kbd> of <kbd>0</kbd>. You set the depth for our Camera-pic-in-pic to <kbd>1</kbd>, so the <strong>Main Camera</strong> is rendered first, covering the whole Game window, and then our second Camera (picture-in-picture) is rendered last, on top of the Main Camera rendering.</p>
<p>The Picture In Picture script changes the camera's Normalized Viewport Rect, thus resizing and positioning the viewport according to the user's preferences. The four values of Vertical and Horizontal Alignment, plus <kbd>width</kbd> and <kbd>height</kbd> percentage, are used to create a rectangle in the (0,0) - (1.0, 1.0) <strong>normalized</strong> coordinates of the the Game panel. The <kbd>rect</kbd> property of the <strong>Camera</strong> is set to the new rectangle calculated.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The following are some aspects of your picture-in-picture that you could change.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the size and location of the picture-in-picture viewport on the screen</h1>
                
            
            
                
<p>You can change the <strong>size</strong> of the picture-in-picture rectangle by setting the horizontal and vertical percentage values.</p>
<p>The Vertical Alignment and Horizontal Alignment options can be used to change the viewport's vertical and horizontal alignment. Use them to place it where you wish, such as top-left, bottom-right, center-center, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding further contols for depth-of-field and aspect-ratio</h1>
                
            
            
                
<p>You can add additional public variables to the code, and corresponding <strong>Camera</strong> adjustments, for <strong>field-of-view</strong>, <strong>aspect ratio</strong>, and so on:</p>
<pre class="SourceCode">    [Range(20f, 150f)]<br/>     public float verticalFieldOfView = 90f;<br/> <br/>     [Range(0.25f, 2f)]<br/>     public float ascectRatio = 1f;<br/> <br/>     void Update()<br/>     {<br/>         Vector2 origin = CalcOrigin();<br/>         Vector2 size = new Vector2(widthPercentage, heightPercentage);<br/>         Rect newCameraRect = new Rect(origin, size);<br/>         camera.rect = newCameraRect;<br/>         camera.fieldOfView = verticalFieldOfView;<br/>         camera.aspect = ascectRatio;<br/>      }</pre>
<p>The camera field-of-view is how much of the world the camera captures; often, we think of this as how wide or narrow our view is. Learn more at <a href="https://en.wikipedia.org/wiki/Field_of_view">https://en.wikipedia.org/wiki/Field_of_view</a> and  <a href="https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html">https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html</a>.</p>
<p class="mce-root"/>
<p>Camera aspect ratio is the relationship of the width to the height of the rectangle. It is calculated as the width divided by the height. Learn more at <a href="https://docs.unity3d.com/ScriptReference/Camera-aspect.html">https://docs.unity3d.com/ScriptReference/Camera-aspect.html</a> and <a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)">https://en.wikipedia.org/wiki/Aspect_ratio_(image)</a>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Manually changing Camera viewport properties in the Inspector</h1>
                
            
            
                
<p>Once you are happy working with the normalized viewport coordinate system of (0,0) to (1.0, 1.0), you can manually edit <strong>Camera Viewport</strong> settings for the Camera component directly in the Inspector, without having to use any C# script-classes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/82251c09-f35d-442d-af9e-18ef299d4c9b.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The <em>Displaying a minimap</em> recipe in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Switching between multiple cameras</h1>
                
            
            
                
<p>Choosing from a variety of cameras is a common feature in many genres: racing, sports, tycoon/strategy, and many others. In this recipe, you will learn how to give players the ability to choose from many cameras by using their keyboards.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the scene created in the first recipe of this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To implement switchable cameras, follow these steps:</p>
<ol>
<li>Create a new Camera in the Scene named Camera-1 (Create | Camera). Set its position to (<kbd>0,0,0</kbd>). Set the Tag for this Camera to be <strong>MainCamera</strong>.</li>
<li>Duplicate Camera-1, naming the copy Camera-2. Set its Position to (<kbd>0, 0, -15</kbd>), and its Rotation to (<kbd>20, 0, 0</kbd>).</li>
<li>Disable the Camera and AudioListener components for both Camera-1 and Camera-2.</li>
<li>Create an empty GameObject named switchboard (Create | Create Empty).</li>
<li>Create a new C# script-class named <kbd>CameraSwitch</kbd> containing the following, and add an object-instance as a component to the switchboard GameObject:</li>
</ol>
<p> </p>
<pre style="padding-left: 60px">  using UnityEngine;    <br/>  public class CameraSwitch : MonoBehaviour  {<br/>         public Camera[] cameras = new Camera[3];<br/>         public bool changeAudioListener = true;<br/> <br/>         void  Update() {<br/>             if (Input.GetKeyDown("0")) {<br/>                 EnableCamera(cameras[0], true);<br/>                 EnableCamera(cameras[1], false);<br/>                 EnableCamera(cameras[2], false);<br/>             }<br/> <br/>             if (Input.GetKeyDown("1")) {<br/>                 EnableCamera(cameras[0], false);<br/>                 EnableCamera(cameras[1], true);<br/>                 EnableCamera(cameras[2], false);<br/>             }<br/> <br/>             if (Input.GetKeyDown("2")) {<br/>                 EnableCamera(cameras[0], false);<br/>                 EnableCamera(cameras[1], false);<br/>                 EnableCamera(cameras[2], true);<br/>             }<br/>         }<br/> <br/>         private void EnableCamera(Camera cam, bool enabledStatus) {<br/>             cam.enabled = enabledStatus;<br/> <br/>             if(changeAudioListener)<br/>                 cam.GetComponent&lt;AudioListener&gt;().enabled = enabledStatus;<br/>         }<br/>     }</pre>
<ol start="6">
<li>Ensure the switchboard GameObject is selected in the Hierarchy. In the Inspector for the Camera Switch (Script) component, set the size of the <strong>Cameras</strong> array to <kbd>3</kbd>. Then, drag and populate the <strong>Camera</strong> slots with the cameras from the scene, including the <strong>Main Camera </strong>and the child of the MsLazer character:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a7fc2a89-2722-487d-a9b0-95da84fe2dcc.png"/></p>
<ol start="7">
<li>Save and Play the scene. Pressing keys <em>0</em>, <em>1</em>, and <em>2</em> should switch between each of the three <strong>Cameras.</strong></li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Each frame, a test is made for each of the three shortcut key presses (0, 1, or 2). If one of those keys has been pressed, then the corresponding <strong>Camera</strong> is enabled, and the other two <strong>Cameras</strong> are disabled.</p>
<p>If the public Boolean property <kbd>changeAudioListener</kbd> has been checked, then the <kbd>AudioListener</kbd> inside the selected Camera is enabled and the <kbd>AudioListeners</kbd> in the other two Cameras are disabled.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ideas about how you could try adapting this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a single-enabled camera</h1>
                
            
            
                
<p>A different approach to the problem would be keeping all secondary cameras disabled and assigning their position and rotation to the <strong>Main Camera</strong> via a script-class (you would need to make a copy of the <strong>Main Camera</strong> and add it to the list, in case you wanted to save its Transform settings). This is similar to the virtual <strong>Camera</strong> properties applied to the <strong>Main Camera</strong> approach that the <kbd>Cinemachine</kbd> package implements (see the last two recipes in this chapter to learn more about <kbd>Cinemachine</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The Creating an in-game surveillance camera recipe in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making textures from screen content</h1>
                
            
            
                
<p>If you want your game or player to take in-game snapshots and apply them as textures, this recipe will show you how. This can be very useful if you plan to implement an in-game photo gallery or display a snapshot of a key moment at the end of a level (racing games and stunt simulations use this feature a lot). For this particular example, we will take a snapshot of a framed region of the screen and print it in the top-right corner of the display:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fefcf742-7a2f-4b0c-a22e-40be43be685f.png" style="width:34.33em;height:14.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the scene created in the first recipe of this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create textures from screen content, follow these steps:</p>
<ol>
<li>In the Hierarchy, create a new <strong>UI Image</strong> named <strong>Image-frame</strong> by choosing the following from the <strong>Hierarchy</strong> panel menu: Create | UI | Image. Since this is the first UI GameObject to be created in this Scene, new Canvas and <kbd>EventSystem</kbd> GameObjects should be created automatically, and the Image-frame UI should be a child of the Canvas GameObject.</li>
<li>From the Inspector panel, find the Image (Script) component of the frame GameObject and set <kbd>InputFieldBackground</kbd> as its <strong>Source Image</strong>. Also, uncheck the <strong>Fill Center</strong> option.</li>
</ol>
<div><br/>
Sprite <kbd>InputFieldBackground</kbd> comes bundled with Unity, and it's already sliced for resizing purposes.</div>
<ol start="3">
<li>Set the Anchors for Image-frame to: Min (<kbd>0.25</kbd>), (<kbd>0.25</kbd>); Max (<kbd>0.75</kbd>), (<kbd>0.750</kbd>).</li>
<li>Zero the Position (Left: <kbd>0</kbd>, Top: <kbd>0</kbd>, Pos Z: <kbd>0</kbd>) and Size (Width: <kbd>0</kbd>, Height: <kbd>0</kbd>).</li>
<li>The <strong>Image-frame</strong> GameObject should appear in the center of the screen, taking up half the screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e7e24165-9431-4a03-8774-031a77737a57.png"/></p>
<p class="mce-root"/>
<ol start="6">
<li>In the Hierarchy, create a new <strong>UI Raw Image</strong> named <strong>RawImage-Photo</strong> by choosing the following from the <strong>Hierarchy</strong> panel menu: <strong>Create</strong> | <strong>UI</strong> | <strong>RawImage</strong><strong>.</strong> Ensure its <strong>Texture</strong> is <strong>None</strong> for its <strong>Raw Image (Script)</strong> component.</li>
<li>In the <strong>Inspector,</strong> now disable the entire <strong>RawImage-Photo</strong> GameObject.</li>
<li>Set the <strong>Width</strong> and <strong>Height</strong> to <kbd>1</kbd>. Set the Anchors for <strong>RawImage-Photo</strong> to: <strong>Min</strong> (<kbd>0</kbd>), (<kbd>1</kbd>); <strong>Max</strong> (<kbd>0</kbd>), (<kbd>1</kbd>).</li>
<li>Set the <strong>Pivot</strong> to <kbd>(0, 1)</kbd>. And zero the Position by setting <strong>Left</strong> to <kbd>0</kbd>, <strong>Top</strong> to <kbd>0</kbd>, and <strong>Z</strong> to <kbd>0</kbd>.</li>
<li>Create a new C# script-class named <kbd>TextureFromCamera,</kbd> and add an instance-object as a component to the <strong>Main Camera</strong> GameObject (child of <kbd>MsLazer):</kbd></li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/>     using System.Collections;<br/> <br/>     public class TextureFromCamera : MonoBehaviour {<br/>         public GameObject imageFrame;<br/>         public GameObject rawImagePhoto;<br/>         public float ratio = 0.25f;<br/> <br/>         void  LateUpdate ()  {<br/>             if (Input.GetKeyUp(KeyCode.Mouse0))<br/>             {<br/>                 rawImagePhoto.SetActive (false);<br/>                 StartCoroutine(CaptureScreen());<br/>                 rawImagePhoto.SetActive (true);<br/>             }<br/>         }<br/> <br/>         IEnumerator CaptureScreen () {<br/>             RectTransform frameTransform = imageFrame.GetComponent&lt;RectTransform&gt; ();<br/>             Rect framing = frameTransform.rect;<br/>             Vector2 pivot = frameTransform.pivot;<br/>             Vector2 origin = frameTransform.anchorMin;<br/>             origin.x *= Screen.width;<br/>             origin.y *= Screen.height;<br/>             float xOffset = pivot.x * framing.width;<br/>             origin.x += xOffset;<br/>             float yOffset = pivot.y * framing.height;<br/>             origin.y += yOffset;<br/>             framing.x += origin.x;<br/>             framing.y += origin.y;<br/>             Texture2D texture = new Texture2D((int)framing.width, (int)framing.height);<br/> <br/>             yield return new WaitForEndOfFrame();<br/>             texture.ReadPixels(framing, 0, 0);<br/>             texture.Apply();<br/>             Vector3 photoScale = new Vector3 (framing.width * ratio, framing.height * ratio, 1);<br/>             rawImagePhoto.GetComponent&lt;RectTransform&gt; ().localScale = photoScale;<br/>             rawImagePhoto.GetComponent&lt;RawImage&gt;().texture = texture;<br/>         }<br/>     }</pre>
<ol start="11">
<li>In the <strong>Inspector,</strong> find the <strong>Screen Texture</strong> component and populate the Raw Image Photo field with <strong>GameObject</strong><strong>RawImage-Photo;</strong> and the <strong>Image Frame</strong> field with the <strong>Image-frame</strong> GameObject.</li>
<li>Play the <strong>Scene</strong>. Each time you click the mouse, you'll take a snapshot of the screen within the rectangular frame, and the snapshop should be displayed in the top-left of the screen.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, we created a UI frame from which to take a snapshot, and a UI Raw Image at the top-left of the screen, onto which to apply the snapshot textures.</p>
<p>Each frame, the <kbd>LateUpdate()</kbd> method of C# script-class <kbd>TextureFromCamera</kbd> is executed. Each time this happens a test is made to see whether the mouse button has been clicked. If it has, then the UI Raw Image is disabled (so previous snapshots don't appear in new snapshots) and the <kbd>CaptureScreen()</kbd> coroutine method is invoked.</p>
<p>We use <kbd>LateUpdate()</kbd> here to ensure all rendering has been completed before we capture the image.</p>
<p>Coroutine <kbd>CaptureScreen()</kbd> calculates a <kbd>Rect</kbd> area, copies screen pixels from that area, and applies them to a texture to be displayed by the <strong>UI Raw Image</strong> element, which is also resized to fit the texture.</p>
<p class="mce-root"/>
<p>The size of the <kbd>Rect</kbd> is calculated from the screen's dimensions and the frame's Rect Transform settings, particularly its Pivot, Anchors, Width, and Height. The screen pixels are then captured by the <kbd>ReadPixels()</kbd> command and applied to the texture, which is then applied to the Raw Image photo, which is itself resized to fit the desired ratio between the photo size and the original pixels.</p>
<p>The <kbd>CaptureScreen()</kbd> method is a coroutine, which allows it to wait until the end of a frame (<kbd>yield return new WaitForEndOfFrame()</kbd>), before attempting to capture a copy of the image from the <strong>Camera.</strong></p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Apart from displaying the texture as a UI element, you can use it in other ways.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying your texture to a material</h1>
                
            
            
                
<p>You can apply your texture to an existing object's material by adding a line similar to <kbd>GameObject.Find("MyObject").renderer.material.mainTexture</kbd>= texture to the end of the <kbd>CaptureScreen</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using your texture as a screenshot</h1>
                
            
            
                
<p>You can encode your texture as a PNG image file and save it. This is explored in the Unity documentation pages about encoding PNG images: <a href="https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html">https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The Saving screenshots from the game recipe in <a href="">Chapter 10</a>, <em>Working with External Resource Files and Devices</em>, Saving and Loading Data Files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Zooming a telescopic camera</h1>
                
            
            
                
<p>In this recipe, we will create a telescopic camera that zooms in whenever the left mouse button is pressed.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready...</h1>
                
            
            
                
<p>This recipe adds to the scene created in the first recipe of this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a telescopic camera, follow these steps:</p>
<ol>
<li>Create a new C# script-class named <kbd>TelescopicView</kbd>, and add an instance-object as a component to the <strong>Main Camera</strong> (child of <kbd>MsLazer</kbd>):</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">  using UnityEngine;<br/> <br/>     public class TelescopicView : MonoBehaviour {<br/>         public float zoom = 2.0f;<br/>         public float speedIn = 100.0f;<br/>         public float speedOut = 100.0f;<br/>         private float initFov;<br/>         private float currFov;<br/>         private float minFov;<br/>         private float addFov;<br/> <br/>         void Start() {<br/>             initFov = Camera.main.fieldOfView;<br/>             minFov = initFov / zoom;<br/>         }<br/> <br/>         void Update() {<br/>             if (Input.GetKey(KeyCode.Mouse0))<br/>                 ZoomView();<br/>             else<br/>                 ZoomOut();<br/>         }<br/> <br/>         void ZoomView(){<br/>             currFov = Camera.main.fieldOfView;<br/>             addFov = speedIn * Time.deltaTime;<br/> <br/>             if (Mathf.Abs(currFov - minFov) &lt; 0.5f)<br/>                 currFov = minFov;<br/>             else if (currFov - addFov &gt;= minFov)<br/>                 currFov -= addFov;<br/> <br/>             Camera.main.fieldOfView = currFov;<br/>         }<br/> <br/>         void ZoomOut() {<br/>             currFov = Camera.main.fieldOfView;<br/>             addFov = speedOut * Time.deltaTime;<br/> <br/>             if (Mathf.Abs(currFov - initFov) &lt; 0.5f)<br/>                 currFov = initFov;<br/>             else if (currFov + addFov &lt;= initFov)<br/>                 currFov += addFov;<br/> <br/>             Camera.main.fieldOfView = currFov;<br/>         }<br/>     }</pre>
<ol start="2">
<li>Play the level. You should see an animated zooming effect when you click and hold the right mouse button.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The zooming effect is actually caused by changes to the value of the camera's <strong>Field Of View</strong> (<strong>FOV</strong>) property; small values result in closer views of a smaller area, while larger values enlarge the FOV.</p>
<p>The <kbd>TelescopicView</kbd> script-class changes the camera's field of view by reducing it whenever the left mouse button is pressed. It also adds to the FOV value when the right mouse button is not being held, until it reaches its original value.</p>
<p>The zoom limit of the FOV can be deduced from the <kbd>minFov = initFov / zoom</kbd> code. This means that the minimum value of the FOV is equal to its original value divided by the zoom amount. For instance, if our <strong>Camera</strong> originally features an FOV of 60, and we set the <strong>Telescopic View Zoom</strong> amount to <kbd>2.0</kbd>, the minimum FOV allowed will be 60/2 = 30.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a vignette effect when you zoom</h1>
                
            
            
                
<p>Often in games, a visual vignette effect is applied at the same time as camera zooming. Vignetting is when the edges of an image are made less bright or more blurred (often in an oval or circular shape). It used to be an unintended (and often unwanted) effect of older cameras and lenses, but can be purposely applied in games to help the player focus on the content at the center of the screen, and to add a more intense atmosphere at a certain point in the game:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1fbf8906-51a5-4ae8-a2ca-382bb363e4b0.png" style="width:71.17em;height:27.17em;"/></p>
<p>To add a vignette effect, do the following:</p>
<ol>
<li>Open the Asset Store panel, then download and import the free Post-Processing Stack assets published by Unity Technologies.</li>
<li>In the Inspector, select the Main Camera GameObject (child of <strong>MsLazer</strong>). Then, add a Post-Processing Behaviour component. Go to Add Component | Effects | Post-Processing Behaviour.</li>
<li>In the Project panel, create a new Post-Processing Profile file named my-vignette by choosing the following from the Project panel menu: Create | Post-Processing Profile.</li>
<li>With the <kbd>my-vignette</kbd> file selected in the Project panel, in the Inspector, check the my-vignette effect and click it once to reveal its properties. Set its properties as follows:
<ul>
<li>Center: (X: 0.5, Y: 0.5)</li>
<li>Intensity: 0.75</li>
<li>Smoothness: 0.5</li>
<li>Roundness: 1</li>
</ul>
</li>
</ol>
<ol start="5">
<li>With the <strong>Main Camera</strong> selected in the <strong>Inspector,</strong> drag the <kbd>my-vignette</kbd> file from the <strong>Project</strong> panel into the <strong>Inspector</strong> to populate the <strong>Profile</strong> property of the <strong>Post-Processing Behaviour</strong> component.</li>
<li>You should now see the dark, fuzzy vignetting circular effect around the edges of the <strong>Game</strong> panel camera view.</li>
<li>In the <strong>Inspector,</strong> select the <strong>Main Camera</strong> and disable its <strong>Post-Processing Behaviour</strong> component (uncheck the box for this component in the <strong>Inspector).</strong> We'll be enabling this effect in the script only when the zoom effect is switched on.</li>
<li>Add a new using statement at the top of the <kbd>TelescopicView</kbd> script-class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine.PostProcessing;</pre>
<ol start="9">
<li>Add a new private variable to the <kbd>TelescopicView</kbd> script-class:</li>
</ol>
<pre style="padding-left: 60px">private PostProcessingBehaviour postProcessingBehaviour;</pre>
<ol start="10">
<li>Add a statement to get and store a reference to the <strong>Post-Processing Behaviour</strong> component at the end of the <kbd>Start()</kbd> method in the <kbd>TelescopicView</kbd> script-class:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    void Start() {<br/>         initFov = Camera.main.fieldOfView;<br/>         minFov = initFov / zoom;<br/>         postProcessingBehaviour = GetComponent&lt;PostProcessingBehaviour&gt;();<br/>     }</pre>
<ol start="11">
<li>Add statements in the <kbd>Update()</kbd> method of script-class <kbd>TelescopicView,</kbd> to enable the Post-Processing Behaviour when the mouse key is pressed and disable it when not pressed:</li>
</ol>
<pre class="SourceCode">    void Update() {<br/>         if (Input.GetKey(KeyCode.Mouse0)) {<br/>             postProcessingBehaviour.enabled = true;<br/>             ZoomView();<br/>         }<br/>         else {<br/>             ZoomOut();<br/>             postProcessingBehaviour.enabled = false;<br/>         }<br/>     }</pre>
<ol start="12">
<li>Play the Scene. You should see an animated vignette effect, in addition to the zooming, when the mouse button is clicked and held.</li>
</ol>
<p class="mce-root"/>
<p>Learn more about the Vignette effect and the Post-processing Stack in the Unity documentation:</p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/PostProcessing-Vignette.html">https://docs.unity3d.com/Manual/PostProcessing-Vignette.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/PostProcessing-Stack.html">https://docs.unity3d.com/Manual/PostProcessing-Stack.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Going further with version 2 of the Unity Post Processing Stack</h1>
                
            
            
                
<p>At the time of printing, Unity have published an experimental version 2 of their Post Processing Stack.</p>
<p>To add a vignette effect, do the following:</p>
<ol>
<li>Select the <strong>Main Camera</strong> in the <strong>Inspector</strong> (child of <kbd>MsLazer</kbd>). In the <strong>Inspector,</strong> create a new <strong>Layer</strong> named <kbd>PostProcessing,</kbd> and set the <strong>Layer</strong> of the <strong>Main Camera</strong> to <strong>PostProcessing</strong>.</li>
<li>Download the ZIP from the Unity GitHub account at <a href="https://github.com/Unity-Technologies/PostProcessing">https://github.com/Unity-Technologies/PostProcessing</a>.</li>
<li>Then, unzip the folder into your project's Assets folder.</li>
<li>Add a Post-Process Layer component to the <strong>Main Camera</strong>. Do this in the <strong>Inspector</strong> by clicking <strong>Add Component</strong> | <strong>Rendering</strong> | <strong>Post Process Layer</strong>. Set the <strong>Layer</strong> property of this component to <strong>Post Processing</strong>.</li>
<li>Now, add a <strong>Post-process Volume Component</strong> by clicking <strong>Add Component</strong> | <strong>Rendering</strong> | <strong>Post Process Volume</strong>. Check the Is Global property. Create a New profile (click the New button). Then, click the Add Effect... button and choose Vignette from the drop-down menu.</li>
<li>Add a using statement at the top of the <kbd>TelescopicView</kbd> script-class:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">using UnityEngine.Rendering.PostProcessing;</pre>
<ol start="7">
<li>Add two more properties to the <kbd>TelescopicView</kbd> script-class:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">private Vignette vignetteEffect;<br/> public float vMax = 1f;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="8">
<li>Add the following statements to the end of the <kbd>Start()</kbd> method of script-class <kbd>TelescopicView</kbd>, in order to get a reference to the Vignette effect in the Post-Processing Volume component:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    void Start() {<br/>         initFov = Camera.main.fieldOfView;<br/>         minFov = initFov / zoom;<br/> <br/>         PostProcessVolume volume = GetComponent&lt;PostProcessVolume&gt;();<br/>         volume.profile.TryGetSettings&lt;Vignette&gt;(out vignetteEffect);<br/>     }</pre>
<ol start="9">
<li>Add the following statements to the end of the <kbd>Update()</kbd> method of script-class <kbd>TelescopicView,</kbd> in order to update the vignette settings:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">   void Update()<br/>     {<br/>         if (Input.GetKey(KeyCode.Mouse0))<br/>             ZoomView();<br/>         else<br/>             ZoomOut();<br/> <br/>         float currDistance = currFov - initFov;<br/>         float totalDistance = minFov - initFov;<br/>         float vMultiplier = currDistance / totalDistance;<br/> <br/>         float vAmount = vMax * vMultiplier;<br/>         vAmount = Mathf.Clamp(vAmount, 0, vMax);<br/>         vignetteEffect.intensity.Override(vAmount);<br/>     }</pre>
<ol start="10">
<li>Play the Scene. You should see an animated vignette effect, in addition to the zooming, when the mouse button is clicked and held.</li>
</ol>
<p>Learn more about this new version at the following locations:</p>
<ul>
<li>The project Wiki: <a href="https://github.com/Unity-Technologies/PostProcessing/wiki">https://github.com/Unity-Technologies/PostProcessing/wiki</a></li>
<li>Unity GitHub account from which to download it: <a href="https://github.com/Unity-Technologies/PostProcessing">https://github.com/Unity-Technologies/PostProcessing</a></li>
<li>This article about scripting with the Post Processing Stack v2 by Juan Sebastian Munoz Arango: <a href="http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/">http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/</a></li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying a minimap</h1>
                
            
            
                
<p>In many games, a broader view of the scene can be invaluable for navigation and information. Minimaps are great for giving players that extra perspective that they may need when in first- or third-person mode. In this recipe, we'll first create a simple square minimap that appears at the top-right of the screen; then, you'll learn how to make it circular and add a rotating compass effect:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/efbb987f-89dc-4ca1-9e59-f7877904b412.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready...</h1>
                
            
            
                
<p>This recipe adds to the scene created in the first recipe of this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a minimap, follow these steps:</p>
<ol>
<li>From the <strong>Hierarchy</strong> panel, create a new UI Panel object (Create | UI | Panel) named <kbd>Panel-miniMap</kbd>. Since this is the first UI GameObject to be created in this Scene, new Canvas and <kbd>EventSystem</kbd> GameObjects should be created automatically, and the UI Panel should be a child of the Canvas GameObject.</li>
</ol>
<ol start="2">
<li>With the <kbd>Panel-miniMap</kbd> GameObject selected in the <strong>Inspector,</strong> do the following:
<ul>
<li>In the Rect Transform, set the alignment to top-right (click the top-right box while holding down the Shift and Alt keys)</li>
<li>In the Rect Transform, set Width to <kbd>128</kbd> and Height to <kbd>128</kbd></li>
</ul>
</li>
<li>We'll create a Render Texture file to which our minimap Camera will copy its view. In the <strong>Project</strong> panel, create a new Render Texture and name it <kbd>RenderTextureMap.</kbd> In the <strong>Inspector,</strong> ensure its Size is set to 256 x 256.</li>
<li>In the <strong>Inspector,</strong> select GameObject Panel-minimap and add a new child UI Raw Image named <kbd>RawImage-TextureMap</kbd> (Create | UI | Raw Image).</li>
<li>For the UI <kbd>RawImage-TextureMap</kbd> GameObject, populate the Source Image field with the <kbd>RenderTextureMap</kbd> image. This means when our minimap Camera updates its view to the Render Texture, what the <strong>Camera</strong> sees will be automatically displayed in this UI Raw Image.</li>
<li>After ensuring UI Raw <kbd>Image-RenderTextureMap</kbd> is a child of <kbd>Panel-minimap,</kbd> make it fill the whole panel by choosing <strong>Stretch</strong> for both the vertical and horizontal axes in the Rect Transform (while holding down the Shift and Alt keys):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/73bd3b55-b8a7-4901-8055-446295cddd11.png"/></p>
<ol start="7">
<li>From the <strong>Hierarchy</strong> panel, create a new Camera <strong>(</strong><strong>Create</strong> | <strong>Camera</strong><strong>)</strong> and rename it <kbd>Camera-minimap.</kbd> Uncheck (or remove) the camera's <strong>Audio Listener</strong> component, since there should only be one active <strong>Audio Listener</strong> in a <strong>Scene</strong>.</li>
<li>In the Hierarchy child <kbd>Camera-minimap</kbd> to the <kbd>character-MsLazer</kbd> character.  Then, in the <strong>Inspector,</strong> set its properties as follows:
<ul>
<li>Position: <kbd>(0, 10, 0)</kbd></li>
<li>Rotation: <kbd>(90, 0, 0)</kbd></li>
<li>Clear Flags: Depth Only</li>
<li>Projection: Orthographic</li>
<li>Camera: Size: 5 (default)</li>
<li>Depth: 1 (or higher)</li>
<li>Target Texture: RenderTextureMap</li>
</ul>
</li>
</ol>
<ol start="9">
<li>Play the Scene. You should be able to see the square-shaped minimap functioning in the top-right corner of the screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/dc403a8d-3ef3-4efa-b825-fd5a1ea589bb.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The main element of the minimap is a UI Raw Image element <kbd>(RawImage-TextureMap),</kbd> displaying the contents of the Render Texture file named <kbd>RenderTextureMap.</kbd></p>
<p>You created a second Camera in the Scene <kbd>(Camera-minimap),</kbd> and set its Target Texture to the <kbd>RenderTextureMap</kbd> file; this means that the view seen by the Camera updates the contents of <kbd>RenderTextureMap</kbd> each frame, which in turn is then displayed to the user in UI <kbd>RawImage-TextureMap.</kbd></p>
<p><kbd>Camera-minimap</kbd> is an orthographic camera that follows the player's character from a top-down viewpoint. You removed/disabled the <kbd>AudioListener</kbd> component in this new Camera, since there should only be one active <kbd>AudioListener</kbd> in a <strong>Scene,</strong> and there is already one in the default <strong>Main Camera</strong> GameObject.</p>
<p>You childed this new Camera to <kbd>character-MsLazer,</kbd> so it moves with the character. You positioned it 10 units above the character (Y = 10), and you made it point downwards towards the character (X-rotation of 90 degrees).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you want to experiment more with your minimap, read on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a UI Mask to make the minimap circular in shape</h1>
                
            
            
                
<p>One way to make the minimap stand out in the UI is to make it circular. We can do this easily by adding a UI Mask based on a circle:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ab73d37f-e236-40c4-a636-a15489db6f22.png"/></p>
<p>A good way to make the minimap stand out in the UI is to present it as a circular shape, do the following:</p>
<ol>
<li>In the <strong>Project</strong> panel, select the circleMask file in the <kbd>Textures</kbd> folder, and in the <strong>Inspector</strong> ensure the Texture Type is <strong>Sprite</strong> <strong>(2D and UI)</strong>.</li>
</ol>
<p>To change a Texture type to <strong>Sprite (2D and UI)</strong>, select the file in the <strong>Project</strong> panel, then in the <strong>Inspector</strong> change its <strong>Texture Type</strong> to <strong>Sprite (2D and UI)</strong> and click on <strong>Apply</strong> to confirm the changes.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Ensure the <kbd>Panel-miniMap</kbd> GameObject is selected in the <strong>Hierarchy.</strong> In the <strong>Inspector</strong> for the <strong>Image (Script)</strong> component, populate the Source Image field with the circleMask texture, click the Color property, and set the Alpha value to <kbd>255</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/df09b696-695c-4870-92e4-01128de5b044.png"/></p>
<ol start="3">
<li>Now, add a Mask component to <kbd>Panel-miniMap</kbd> in the <strong>Inspector,</strong> by choosing menu: Add Component | UI | Mask. Uncheck the Show Mask Graphic property (it will become invisible).</li>
</ol>
<p>The circle image serves as a mask for the minimap, so that only images inside the <kbd>circleMask</kbd> area will be displayed, resulting in a circular minimap.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hiding player character image at center of minimap and showing triangle marker</h1>
                
            
            
                
<p>With most minimaps, the center of the minimap is the location of the player's character, so we don't need to show the player's character in the minimap. Let's create a Layer named <kbd>Player</kbd> and place <kbd>character-MsLazer</kbd> onto that <strong>Layer.</strong> We can then improve efficiency and reduce visual clutter by creating a <strong>Culling Mask</strong> that ignores the <strong>Player</strong><strong> Layer</strong>. We can display a simple <strong>2D Sprite</strong> in the center of our minimap, pointing upwards, to indicate that our player is always facing upwards relative to what is displayed in the minimap:</p>
<ol>
<li>Create a new User Layer named <kbd>Player</kbd>.</li>
</ol>
<ol start="2">
<li>Select the <kbd>character-MsLaser</kbd> GameObject (the player's character) in the Hierarchy, and set the <strong>Layer</strong> property to <strong>Player</strong> (click Yes in the <strong>Change Children</strong> popup dialog).</li>
<li>With <kbd>Camera-minimap</kbd> selected in the <strong>Hierarchy,</strong> in the <strong>Inspector</strong> for the <strong>Culling Mask</strong> property of the <strong>Camera,</strong> deselect <strong>Layer Player</strong>. This property should now say <strong>Mixed...,</strong> which means that GameObjects on the <strong>Player Layer</strong> will be ignored by our our <kbd>Camera-minimap.</kbd></li>
<li>Let's add a triangle marker 2D image at the center of the <strong>Panel.</strong> Create a new UI Image as a child of <kbd>Panel-minimap;</kbd> rename this <kbd>Image-marker.</kbd> In the <strong>Inspector,</strong> set the Source Image property to Texture asset file <kbd>triangleMarker</kbd>. Click the Set Native Size button.</li>
<li>Run the Scene. Rather than the top-down view of the player's character, you should now see a triangle at the center of the minimap (always pointing upwards):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/326756ab-832b-42b4-a3e7-b3e1bfc1acf9.png"/></p>
<p>Rather than just having a triangle image in the center representing the player, you can create, for example, colored 3D objects that in Orthographic projection look like circles, squares, and so on by using <strong>Layers</strong> further. This involves having a <strong>Layer</strong> for objects to be displayed in the minimap, and another <strong>Layer</strong> (such as <strong>Player)</strong> that will be ignored by the minimap Camera. The Knights Of Unity have published a short tutorial that explains just how to do this kind of thing: <a href="http://blog.theknightsofunity.com/implementing-minimap-unity/">http://blog.theknightsofunity.com/implementing-minimap-unity/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rotating a compass-style image</h1>
                
            
            
                
<p>Sometimes we want a compass-style image around our minimaps, so we can see any differences between the current bearing (forward direction) of our player's character and the direction we were originally facing.</p>
<p>To add a rotating compass-style image around our minimap, do the following:</p>
<ol>
<li>Let's add a compass-style circular image at the center of the Panel (with the letter N pointing upwards). To do this, create a new UI Image as a child of <strong>Panel-minimap;</strong> rename this <strong>Image-compass.</strong> In the <strong>Inspector,</strong> set the <strong>Source Image</strong> property to Texture compass.</li>
<li>Ensure both <strong>Image-compass</strong> and <strong>Image-marker</strong> appear below <strong>RawImage-TextureMap</strong> in the <strong>Hierarchy</strong> of the children of the <kbd>Panel-minimap</kbd> GameObject; this ensures the triangle marker and compass circle images are drawn after the Camera texture (that is, on top of the Camera's view image):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e955c146-8a5e-4163-a5d4-28231ad98d8d.png" style="width:23.25em;height:7.67em;"/></p>
<ol start="3">
<li>Create a C# script-class MiniMap, and add an <kbd>instance-object</kbd> as a component to <kbd>Camera-minimap:</kbd></li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    using UnityEngine;<br/> <br/>     public class MiniMap : MonoBehaviour {<br/>         public GameObject mapUI;<br/>         private Transform target;<br/> <br/>         void Start() {<br/>             target = GameObject.FindGameObjectWithTag("Player").transform;<br/>         }<br/> <br/>         void Update() {<br/>             Vector3 compassAngle = new Vector3();<br/>             compassAngle.z = target.transform.eulerAngles.y;<br/>             mapUI.transform.eulerAngles = compassAngle;<br/>         }<br/>     }</pre>
<ol start="4">
<li>Play the Scene. You should be able to see the minimap functioning in the top-right corner of the screen. As you rotate the player character's orientation, you'll see the "N" north indicator in the circle around the minimap rotate too (but in the opposite direction).</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Every frame, the compass UI Image is rotated to match the rotation of the player's 3D character in the Scene.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making the range of the map larger or smaller</h1>
                
            
            
                
<p>Since our Camera-minimap is Orthographic, changing the height of the <strong>Camera</strong> above the character will make no difference (since distance doesn't change how objects are projected onto an Orthographic camera). However, changing the Size property of the <strong>Camera</strong> component in the <strong>Inspector</strong> will control how large or small an area of the world is projected to the <strong>Camera.</strong></p>
<p>Try increasing the size to 20, and your minimap will show much more of the surrounding maze around your character:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/97c67c73-4b99-466a-be13-68afb82cb79b.png"/></p>
<p>When increasing the range of the minimap, you may wish to make the triangle marker Image in the center of the minimap smaller. You can do this easily by centering its Rect Transform, then setting a smaller Width and Height (such as 16 x 16).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adapting your minimap to other styles</h1>
                
            
            
                
<p>You can easily modify this recipe to make a top-down or isometric view of a racing game circuit map. In the <strong>Inspector,</strong> unchild the <kbd>Camera-minimap</kbd> GameObject; this will prevent it from following any of the <strong>Scene</strong> characters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an in-game surveillance Camera</h1>
                
            
            
                
<p>In the previous recipe, we rendered the output from our minimap <strong>Camera</strong> to a <strong>Render Texture</strong>, and displayed the contents of that image in a <strong>UI Raw Image</strong>. Another example of when we may wish to capture and output the view of a <strong>Camera</strong> at runtime is to simulate an in-game surveillance <strong>Camera,</strong> such as a <strong>Closed-Circuit Television</strong> (<strong>CCTV</strong>) system. In this recipe, we will make use of a <strong>Render Texture</strong> to create an in-game surveillance camera that transmits its video to a 3D monitor elsewhere in the <strong>Scene</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6c449ebd-34e9-48a5-b2e3-4ea3db5c8582.png" style="width:39.00em;height:21.50em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the scene created in the first recipe of this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p>For this recipe, we have also prepared two 3D models (FBX files) needed for the monitor and <kbd>cctv-camera</kbd> objects. These 3D model files can be found in the <kbd>06_07</kbd> folder.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create an in-game surveillance <strong>Camera,</strong> just follow these steps:</p>
<ol>
<li>Import the monitor and <kbd>cctv-camera</kbd> models into your Unity Project.</li>
<li>Create clones of the monitor and <kbd>cctv-camera</kbd> models by dragging them from the <strong>Project</strong> panel into the Hierarchy panel.</li>
<li>In the <strong>Inspector,</strong> set the following properties for the monitor GameObject:
<ul>
<li>Position: (<kbd>-3, 0, 6</kbd>)</li>
<li>Rotation: (<kbd>0, 180, 0</kbd>)</li>
<li>Scale: (<kbd>1,1,1</kbd>)</li>
</ul>
</li>
<li>In the <strong>Inspector,</strong> set the following properties for the <kbd>cctv-camera</kbd> GameObject:
<ul>
<li>Position: (<kbd>-6, 0, 1</kbd>)</li>
<li>Rotation: (<kbd>0, 90, 0</kbd>)</li>
</ul>
</li>
<li>From the <strong>Project</strong> panel, create a new <strong>Render Texture</strong> file and rename it <kbd>screenRenderTexture.</kbd> In the <strong>Inspector,</strong> change its <strong>Size</strong> to <strong>512 x 512</strong>.</li>
<li>Add a new <strong>Camera</strong> to the scene (menu: Create | Camera) named <kbd>Camera-surveillance.</kbd> Child this new GameObject to <kbd>cctv-camera.</kbd> Uncheck (or remove) the camera's <strong>Audio Listener</strong> component, since there should only be one active <strong>Audio Listener</strong> in a Scene.</li>
<li>In the <strong>Inspector,</strong> set the following properties for the <kbd>Camera-surveillance</kbd> GameObject:
<ul>
<li>Position: (<kbd>0, 2, 0</kbd>)</li>
<li>Rotation: (<kbd>0, 0, 0</kbd>)</li>
<li>Clipping Planes: Near: <kbd>0.6</kbd></li>
<li>Target Texture: <kbd>screenRenderTexture</kbd>.</li>
</ul>
</li>
<li>Create a new <strong>Material</strong> named <kbd>m_renderTexture,</kbd> and set its <strong>Albedo Texture</strong> to <kbd>screenRenderTexture.</kbd></li>
<li>In the <strong>Hierarchy,</strong> find the screen child of the monitor GameObject and set its <strong>Mesh Renderer Material</strong> to <kbd>m_renderTexture.</kbd></li>
</ol>
<ol start="10">
<li>Play your Scene. You should be able to see your actions in front of the <kbd>cctc-camera</kbd> displayed in real time on the monitor's screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5ddf90bc-c267-41a4-ab7c-90fc03fb9d0f.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We achieved the final result by using the surveillance camera as a source for the <strong>Render Texture</strong> applied to the screen. The camera was made a child of the camera's 3D model for easier relocation. Also, its <strong>Near Clipping</strong> plane was readjusted in order to avoid displaying parts of the camera's 3D model geometry, and its <strong>Audio Source</strong> component was disabled so that it wouldn't clash with the main camera's component.</p>
<p>Finally, our <strong>Render Texture</strong> was applied to the material of the monitor GameObject.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you want to experiment more with your minimap, read on.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Post-Processing to add a grainy, grayscale effect to the CCTV</h1>
                
            
            
                
<p>A great effect to add for in-game TV systems is grainy (visual noise) grayscale <strong>Post-Processing.</strong> This adds the feel of cheap, old-style CCTV systems, such as might be used for a security system, and to add some kind of menacing film noir effect:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/33ad43ad-f915-4cd8-b998-413dded2a69e.png" style="width:39.42em;height:14.08em;"/></p>
<p>To add a vignette effect, do the following:</p>
<ol>
<li>Open the <strong>Asset Store</strong> panel, then download and import the free <strong>Post-Processing Stack</strong> assets published by Unity Technologies.</li>
<li>In the <strong>Project</strong> panel, create a new <strong>Post-Processing</strong> Profile file by going to Create | Post-Processing Profile. Name this new profile <kbd>film-noir.</kbd></li>
<li>In the <strong>Hierarchy,</strong> select the <kbd>Camera-surveillance</kbd> child of the <kbd>cctv-camera</kbd> GameObject. Add a <strong>Post-Processing Behaviour</strong> component to this <strong>Camera,</strong> by chosing menu: <strong>Add Component</strong> | <strong>Effects</strong> | <strong>Post-Processing</strong> Behaviour.</li>
<li>Drag the <kbd>film-noir</kbd> file from the <strong>Project</strong> panel into the <strong>Inspector</strong> to populate the <strong>Profile</strong> property of the <strong>Post-Processing Behaviour</strong> component.</li>
</ol>
<ol start="5">
<li>In the <strong>Inspector,</strong> set the following properties for the <strong>Post-Processing Profile</strong> <kbd>film-noir</kbd> file:
<ul>
<li>Check the <strong>Color Grading</strong> option, and set Basic: Saturation to zero</li>
<li>Check the <strong>Grain</strong> option, uncheck <strong>Colored,</strong> and set the maximum values for <strong>Intensity (1), Luminescence Contribution (1)</strong>, and <strong>Size (3)</strong>.</li>
</ul>
</li>
<li>Run the Scene.</li>
</ol>
<p>By processing the image generated from the <strong>Camera,</strong> the image in the monitor should now be an old-style grainy, grayscale video feed from <kbd>cctv-camera.</kbd> The image is made grayscale, since color saturation is zero, and a grainy effect has also been applied.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with Unity's multi-purpose camera rig</h1>
                
            
            
                
<p>Unity provides some <strong>Camera</strong> rigs, which can make setting up scenes much faster and help to test out ideas. In this recipe, you'll use a 3rd Person Character and the multi-purpose camera rig from the default Unity asset packages to quickly create a scene with a camera that automatically follows a character as it moves, smoothing rotating behind the character as the character changes direction:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e08f6a53-935c-481e-a1f7-bc370bf474ad.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To work with Unity's multi-purpose camera rig, just follow these steps:</p>
<ol>
<li>Create a new Unity 3D scene.</li>
<li>Import the <strong>Characters</strong> and <strong>Cameras Asset Packages</strong>: use menu: <strong>Assets</strong> | <strong>Import Package ...</strong> | <strong>Cameras &amp; Characters</strong>.</li>
<li>You should now have a <kbd>Standard Assets</kbd> folder in your <strong>Project</strong> panel, containing the <kbd>Cameras</kbd> and <kbd>Characters</kbd> folders (and possibly some others, such as <kbd>CrossPlatformInput</kbd>, <kbd>Editor</kbd>, and so on).</li>
<li>Create a 3D Plane in your <strong>Scene.</strong></li>
<li>Add a clone of the <kbd>ThirdPersonController Prefab</kbd> to your Scene. Do this by dragging the <kbd>ThirdPersonController Prefab</kbd> from the <kbd>Standard Assets</kbd> | <kbd>Characters</kbd> | <kbd>ThirdPersonController</kbd> | <kbd>Prefabs</kbd> folder into the <strong>Scene.</strong></li>
<li>With GameObject <kbd>ThirdPersonController</kbd> selected in the <strong>Hierarchy,</strong> in the <strong>Inspector</strong> tag this GameObject with the <strong>Player</strong> tag.</li>
<li>Add a clone of the <kbd>MultipurposeCameraRig Prefab</kbd> to your Scene. Do this by dragging the <kbd>MultipurposeCameraRig</kbd> Prefab from the <kbd>Standard Assets</kbd> | <kbd>Cameras</kbd> | <kbd>Prefabs</kbd> folder into the Scene.</li>
<li>Disable the <strong>Main</strong> Camera GameObject.</li>
<li>Run the <strong>Scene.</strong> As you move the character around the <strong>Scene,</strong> the <strong>Camera</strong> should smoothly follow behind.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You added a <kbd>ThirdPersonController</kbd> to the Scene and tagged it <strong>Player.</strong> You added a <kbd>MultipurposeCameraRig</kbd> to the <strong>Scene.</strong> The code attached to the camera rig automatically looks for a target GameObject tagged Player, and positions itself to follow from above and behind this GameObject.</p>
<p>You can adjust the speed at which the camera follows and turns by changing the public properties for the <kbd>MultipurposeCameraRig</kbd> in its <strong>Inspector</strong> component <strong>Auto Cam (Script)</strong>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Cinemachine ClearShot to switch cameras to keep the player in shot</h1>
                
            
            
                
<p>A new feature of Unity is the <kbd>Cinemachine</kbd> set of components:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cc0390fe-7d99-4d56-bde8-db64840934c3.png" style="width:41.42em;height:21.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the scene created in the first recipe of this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To use <strong>Cinemachine ClearShot</strong> to switch cameras to keep the player in shot, just follow these steps:</p>
<ol>
<li>Open the scene provided, containing a 3D maze and <kbd>character-MsLazer.</kbd></li>
<li>Un-child the <strong>Main Camera</strong> from <kbd>character-MsLazer,</kbd> since we need this camera free for <kbd>Cinemachine</kbd> to take control of it.</li>
<li>Install the <kbd>Cinemachine</kbd> package using the Unity Package Manager (to get the most up-to-date version).</li>
</ol>
<ol start="4">
<li>Add a <strong>Cinemachine ClearShot</strong> camera GameObject to the scene (menu: <strong>Cinemachine</strong> | <strong>Ceate ClearShot Camera</strong><strong>).</strong> You should see a new GameObject in the Hierarchy named CM Clearshot 1. Set the position of this new GameObject to (0,0,0).</li>
<li>CM Clearshot 1 should have a child GameObject, Cinemachine Virtual Camera CM vcam 1. Set the position of this virtual camera, CM vcam 1, to (10, 4, -10).</li>
<li>You will also see that a Cinemachine Brain component has been added to the <strong>Main Camera,</strong> and in the <strong>Hierarchy</strong> you'll see the Cinemacine Brain icon next to the <strong>Main Camera</strong> name (half gray cog, half red camera):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3287b4cb-90a2-4cbe-a49b-bc22ab98081d.png" style="width:34.92em;height:9.58em;"/></p>
<ol start="7">
<li>Locate the <kbd>mixamorig:neck</kbd> GameObject in the Hierarchy inside character-MsLazer. We'll use this part of <kbd>character-MsLazer</kbd> to be the part that our <kbd>Cinemachine</kbd> cameras will use to orient towards.</li>
<li>Select <strong>CM Clearshot 1</strong>, and in the <strong>Inspector</strong> populate the <strong>Look At</strong> property of the <strong>Cinemachine ClearShot</strong> component with a reference to the <kbd>mixamorig:neck</kbd> GameObject (drag the GameObject from Hierarchy into the property in the <strong>Inspector):</strong></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/045f5ca2-2cdc-4f42-848a-13417bc3fb16.png" style="width:37.67em;height:18.50em;"/></p>
<ol start="9">
<li>Run the <strong>Scene.</strong> As you move <kbd>character-MsLazer</kbd> around the scene, the Main Camera (controlled by the <kbd>Cinemachein</kbd> Brain) should rotate to always look at the character. However, sometimes a wall obscures the view.</li>
<li>Create a second child Virtual Camera by selecting CM Clearshot 1 in the Hierarchy, and then in the Inspector, click the + button for the <strong>Virtual Camera Children</strong> property of the <kbd>Cinemachine</kbd> Clear Shot component. You should see a new virtual camera child named CM vcam 2 has been created. Set the <strong>Position</strong> of CM vcam 2 to (27, 4, -18).</li>
<li>Run the <strong>Scene</strong>. Initially, CM vcam 1 has the best shot, and so this camera's position will be used to direct the <strong>Main Camera</strong>. However, if you move <kbd>character-MsLazer</kbd> along the corridor towards CM vcam 2, <kbd>Cinemachine</kbd> will then switch control to CM vcam 2.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>A Cinemachine Brain component was added to the <strong>Scene.</strong> This takes control of the <strong>Main Camera</strong> and uses properties of one or more <strong>Virtual Cinemachine Camera</strong> to decide what properties to apply to the <strong>Main Camera</strong>. You added a <strong>Cinemachine ClearShot</strong> GameObject, whose purpose is to tell the <strong>Cinemachine Brain</strong> which of its <strong>Virtual Camera</strong> children has the best shot.</p>
<p>You set the <strong>Look At</strong> property of the <kbd>ClearShot</kbd> component to the neck component of <kbd>character-MsLazer;</kbd> the position of this GameObject is used by the <kbd>ClearShot</kbd> component to rank each <strong>Virtual Camera's</strong> quality of shot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We've only just touched the surface of what <strong>Cinemachine</strong> has to offer. Here are some suggestions for how to learn more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity Cinemachine tutorials</h1>
                
            
            
                
<p>In the learn section of the Unity website, you'll find many video tutorials introducing the different animation features of Unity. There is a special category for <strong>Cinemachine</strong> tutorials, which provide a great overview of the features and uses of Cinemachine: <a href="https://unity3d.com/learn/tutorials/s/animation">https://unity3d.com/learn/tutorials/s/animation</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Will Goldstone's ClearShot turtorial</h1>
                
            
            
                
<p>This recipe was inspired by Will Goldstone's ClearShot tutorial, available on YouTube: <a href="https://www.youtube.com/watch?v=kLcdrDljakA">https://www.youtube.com/watch?v=kLcdrDljakA</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adam Myhill's Cinemachine blog posts</h1>
                
            
            
                
<p>Adam Myhill's blog posts (he is the creator of <strong>Cinemachine)</strong> have lots of information and video links about many different Cinemachine features: <a href="https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/">https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Read the installed Cinemachine documentation</h1>
                
            
            
                
<p>Later versions of <strong>Cinemachine (2.1+)</strong> have documentation installed with the package. Display the <strong>Cinemachine</strong> About panel <strong>(Menu:</strong> <strong>Cinemachine</strong> | <strong>About</strong><strong>),</strong> then click the <strong>Documentation</strong> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/545c2654-1926-4021-aa19-c5c37017cb56.png" style="width:37.25em;height:22.42em;"/></p>
<p>You can also find the documentation online at <a href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Letting the player switch to a Cinemachine FreeLook camera</h1>
                
            
            
                
<p>It's always good to give players choices and control in their game experience. In this recipe, we'll set up a mouse-controllable <strong>Cinemachine FreeLook</strong> camera and let the player switch to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To explore Cinemachine, just follow these steps:</p>
<ol>
<li>Ensure the <strong>Default Blend</strong> property of the <strong>Cinemachine Brain</strong> component in the <strong>Main Camera</strong> is set to Ease In Out. This means we'll have a smooth transition when switching between cameras.</li>
<li>Add a <strong>Cinemachine FreeLook</strong> camera GameObject to the scene (menu: <strong>Cinemachine</strong> | <strong>Ceate FreeLook Camera</strong><strong>).</strong> You should see a new GameObject in the <strong>Hierarchy</strong> named <kbd>CM FreeLook 1</kbd>. Set the <strong>Priority</strong> property of the <strong>Cinemachine</strong> <strong>Free Look (Script)</strong> component to zero.</li>
<li>Locate the <kbd>mixamorig:neck</kbd> GameObject in the <strong>Hierarchy</strong> inside <strong>MsLazer.</strong> We'll use this part of the <strong>MsLazer</strong> character to be the part that our <strong>Cinemachine</strong> cameras will use to orient towards and follow at a steady distance.</li>
<li>Select <strong>CM FreeLook 1</strong>, and in the <strong>Inspector</strong> populate the <strong>Look At</strong> and <strong>Follow</strong> properties of the <strong>Cinemachine</strong> <strong>Free Look (Script)</strong> component with a reference to the <kbd>mixamorig:neck</kbd> GameObject (drag the GameObject from Hierarchy into the properties in the <strong>Inspector).</strong></li>
<li>Create a new <kbd>FreeLookSwitcher</kbd> C# Script-class containing the following code, and add an instance-object as a component to the <strong>CM FreeLook 1</strong> GameObject:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    using UnityEngine;<br/>     using Cinemachine;<br/> <br/>     public class FreeLookSwitcher : MonoBehaviour {<br/>         private CinemachineFreeLook cinemachineFreeLook;<br/> <br/>         private void Start() {<br/>             cinemachineFreeLook = GetComponent&lt;CinemachineFreeLook&gt;();<br/>         }<br/> <br/>         void Update ()  {<br/>             if (Input.GetKeyDown("1"))<br/>                 cinemachineFreeLook.Priority = 99;<br/> <br/>             if (Input.GetKeyDown("2"))<br/>                 cinemachineFreeLook.Priority = 0;<br/>         }<br/>     }</pre>
<ol start="6">
<li>Run the <strong>Scene.</strong> When moving around the maze, initially the <strong>Cinemachine ClearShot</strong> cameras will be chosen by the <strong>Cinemachine</strong> Brain. But, pressing the <em>1</em> key will make it switch to the <strong>FreeLook</strong> camera following the player's character. Pressing <em>2</em> will switch back to the <strong>ClearShot</strong> cameras.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You added a <strong>FreeLook Cinemachine</strong> GameObject, but with a priority of zero, so it will be ignored initially. When the <em>1</em> key is pressed, the script increases the <strong>Priority</strong> to <kbd>99</kbd> (much higher than the default 10 of the <strong>ClearShot</strong> cameras), so then the <strong>Cinemachine</strong> Brain will make the <strong>FreeLook</strong> virtual camera control the <strong>Main Camera</strong>. Pressing the <em>2</em> key reduces the <strong>FreeLook</strong> component's <strong>Priority</strong> back to <strong>zero,</strong> so the <strong>ClearShot</strong> cameras will be used again.</p>
<p>There should be a smooth transition from <strong>FreeLook</strong> to <strong>ClearShot</strong> and back again, since you set the <strong>Default Blend</strong> property of the <strong>Cinemachine Brain</strong> component in the <strong>Main Camera</strong> to <strong>Ease In Out</strong>.</p>


            

            
        
    </body></html>