<html><head></head><body><div><div><h1 id="_idParaDest-107"><em class="italic"><a id="_idTextAnchor106"/>Chapter 7</em>: Unity API – Making Choices and Story Progression</h1>
			<p>This chapter begins with reviewing how to add a <code>script</code> component to a game object in Unity. By creating a <code>script</code> component associated with a C# file, code can be written to load the compiled JSON files created by the ink-Unity Integration plugin from ink source files as part of the Unity scene. Next, we will examine how to load an ink story and start to progress through it. We will see how to programmatically make selections of options presented by ink and then how to continue story progression as a result. We will end with an example of a common approach of presenting multiple user interface elements to a player in Unity. A user will be able to click buttons in Unity and guide story progression in a running ink story.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Loading a compiled ink story</li>
				<li>Selecting options programmatically</li>
				<li>Creating a dynamic user interface</li>
			</ul>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Technical requirements</h1>
			<p>The examples used in this chapter, in <code>*.ink</code> files, can be found online on GitHub: <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7</a>.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Loading a compiled ink story</h1>
			<p>In <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink-Unity Integration Plugin</em>, we saw how to<a id="_idIndexMarker246"/> add new ink files to a Unity project. After importing the plugin, new files can be created using the <strong class="bold">Create</strong> menu from the <strong class="bold">Project</strong> window. When an ink source was added, the plugin automatically created a compiled JSON file. As we now move into working with the ink API provided by the plugin, we will use the created JSON files for working with a story.</p>
			<p>The first step for working with code in Unity is to create a <code>GameObject</code>. This is a basic container in Unity. Each <code>GameObject</code> holds at least one component. The different systems in Unity, such as the rendering system (for drawing things on a screen), physics (for detecting whether two things overlap on a screen), and input (for detecting whether a user presses a button) all communicate with these components. When Unity runs a project, it sends data to components matching the system associated with it. For example, to work with data from the input system, an input component is needed.</p>
			<p>To work with code in Unity, a <code>script</code> component is needed. All code added to a Unity project works through being a part of different systems. A <code>script</code> component allows a developer to write code for working with a game object and the different components it contains. Unlike most other components that primarily receive data from different systems, a <code>script</code> component can <em class="italic">script</em> other objects and values. Through code, it can instruct other components to change their values when different events, such as a user clicking on a button, happen.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Creating a script component</h2>
			<p>Any game<a id="_idIndexMarker247"/> object <a id="_idIndexMarker248"/>can have a <code>script</code> component. However, for better organization, it is often useful to create a new <code>GameObject</code> for each type of data, behavior, or task related to a project. This separates each new action or possible event with a <code>GameObject</code> and makes working on the different parts of a larger project much easier:</p>
			<ol>
				<li>Open a new or existing Unity project.</li>
				<li>If not already added, be sure to install the ink-Unity Integration plugin.<p>There are always multiple ways to do things in Unity, and this is also true of creating a new game object. One of the easiest ways to create a new game object is by using the <strong class="bold">GameObject</strong> menu.</p></li>
				<li>Click<a id="_idIndexMarker249"/> on <strong class="bold">GameObject</strong> and then <a id="_idIndexMarker250"/>click on <strong class="bold">Create Empty</strong>.<div><img src="img/Figure_7.1_B17597.jpg" alt="Figure 7.1 – GameObject menu&#13;&#10;" width="260" height="135"/></div><p class="figure-caption">Figure 7.1 – GameObject menu</p></li>
				<li>A new <code>GameObject</code> will be created and added to the <code>GameObject</code> will show its current components in the <code>GameObject</code> is merely a container. Its components do all the work involved with running the project. Even the name of the <code>GameObject</code> is a value contained as part of its components.</p></li>
				<li>To <a id="_idIndexMarker251"/>change the name of the <a id="_idIndexMarker252"/>created <code>GameObject</code>, click on it in the <code>GameObject</code> (the default value) to <code>Ink</code> <code>Story</code>.<div><img src="img/Figure_7.3_B17597.jpg" alt="Figure 7.3 – Ink Story name change in Unity&#13;&#10;" width="645" height="297"/></div><p class="figure-caption">Figure 7.3 – Ink Story name change in Unity</p><p>The newly named <code>Ink</code> <code>Story</code> will be a container for other components related to running an ink story. Changing the name of the game object to <code>Ink</code> <code>Story</code> makes it easier to find it among potentially many other objects in the project and explains its role in the project as well.</p></li>
				<li>With the components of <code>Ink</code> <code>Story</code> shown in the <strong class="bold">Inspector</strong> view, click on <strong class="bold">Add Component</strong>.<div><img src="img/Figure_7.4_B17597.jpg" alt="Figure 7.4 – Component listing in the Add Component menu&#13;&#10;" width="254" height="371"/></div><p class="figure-caption">Figure 7.4 – Component listing in the Add Component menu</p></li>
				<li>In<a id="_idIndexMarker253"/> the<a id="_idIndexMarker254"/> listing, click on <strong class="bold">New script</strong>.<div><img src="img/Figure_7.5_B17597.jpg" alt="Figure 7.5 – New script component creation" width="282" height="269"/></div><p class="figure-caption">Figure 7.5 – New script component creation</p></li>
				<li>Name this new script file <code>inkLoader.cs</code>.<p class="callout-heading">Note </p><p class="callout">Clicking on the <code>script</code> component name does not always allow access to rename the file in Unity. Pressing the down arrow twice on the keyboard will move the selection from the<a id="_idIndexMarker255"/> search<a id="_idIndexMarker256"/> to the title of the file.</p><div><img src="img/Figure_7.6_B17597.jpg" alt="Figure 7.6 – Script renamed InkLoader" width="355" height="344"/></div><p class="figure-caption">Figure 7.6 – Script renamed InkLoader</p></li>
				<li>After renaming the file, click the <strong class="bold">Create and Add</strong> button. A new C# file will be added to the <strong class="bold">Project</strong> window.<div><img src="img/Figure_7.7_B17597.jpg" alt="Figure 7.7 – Assets in Unity with the new InkLoader.cs file&#13;&#10;" width="249" height="196"/></div><p class="figure-caption">Figure 7.7 – Assets in Unity with the new InkLoader.cs file</p></li>
				<li>Double-click on this file to open it in Visual Studio for editing. </li>
			</ol>
			<p>This first section has included a step-by-step process of preparing a Unity project for working with the ink Story API. We have seen how to create a <code>GameObject</code> and add a <code>script</code> component. In <a id="_idIndexMarker257"/>the next section, we will build on this project to begin to work with the Story API added to Unity as part of the <a id="_idIndexMarker258"/>ink-Unity Integration plugin.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Adding the ink Story API</h2>
			<p>Installing <a id="_idIndexMarker259"/>the ink-Unity Integration plugin adds an <a id="_idIndexMarker260"/>additional <code>Ink</code>. It contains, in turn, three other namespaces named <code>Parsed</code>, <code>Runtime</code>, and <code>UnityIntegration</code>, each of which contains classes related to their names. To work with compiled ink JSON files, the <code>Ink</code><code>.Runtime</code> namespace is needed. This tells Unity that it should start with the <code>ink</code> namespace and then find the namespace within it named <code>Runtime</code>:</p>
			<ol>
				<li value="1">In the file opened in the <em class="italic">Creating a script component</em> section, add a new <code>using</code> line after those already there in the created file:<pre>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<code>using</code> keyword tells Unity to include the <code>Ink.Runtime</code> namespace and allow its classes to be used as part of this file.</p></li>
				<li>Next, create a public field called <code>inkJSONAsset</code> and change the <code>Start()</code> method to the following:<pre>public class InkLoader: MonoBehaviour
{
    <code>InkJSONAsset</code> field with the <code>public</code> keyword will allow this value to be changed inside the Unity editor. The addition of the <code>Story</code> class creates a new<a id="_idIndexMarker261"/> ink<a id="_idIndexMarker262"/> story as part of the <code>Runtime</code> namespace. This is known as the <em class="italic">Story API</em> because multiple methods will be used as part of the <code>Story</code> class.</p></li>
				<li>Save the <code>InkLoader.cs</code> file in Visual Studio and return to Unity.</li>
				<li>After a moment, Unity will refresh and reload the changed C# file.</li>
				<li>The final step is to associate an ink JSON file with the created C# file. In the <code>InkStory</code> game object. In the <code>script</code> component, as shown in the following screenshot:<div><img src="img/Figure_7.8_B17597.jpg" alt="Figure 7.8 – New Ink JSON Asset property in the Inspector view&#13;&#10;" width="610" height="147"/></div><p class="figure-caption">Figure 7.8 – New Ink JSON Asset property in the Inspector view</p><p>The property shows the value <code>None (Text Asset)</code>. This means no files are associated with this property. To change this, a compiled JSON file needs to be added.</p><p class="callout-heading">Note </p><p class="callout">An ink JSON file will be needed for the next steps. If one is not created, add a new one by creating an ink file and letting the <strong class="bold">Automatic compile</strong> option create one, or click on an existing ink source file and then click on <strong class="bold">Compile</strong> in the <strong class="bold">Inspector</strong> view to create a new JSON file.</p></li>
				<li>Click on the <strong class="bold">TextAsset</strong> selection<a id="_idIndexMarker263"/> circle next to the<a id="_idIndexMarker264"/> value to open a <strong class="bold">Select TextAsset</strong> window.<div><img src="img/Figure_7.9_B17597.jpg" alt="Figure 7.9 – Select TextAsset window&#13;&#10;" width="301" height="198"/></div><p class="figure-caption">Figure 7.9 – Select TextAsset window</p></li>
				<li>Select an ink-compiled JSON file.<div><img src="img/Figure_7.10_B17597.jpg" alt="Figure 7.10 – Updated Ink JSON Asset property&#13;&#10;" width="701" height="432"/></div><p class="figure-caption">Figure 7.10 – Updated Ink JSON Asset property</p><p>After the value of the <strong class="bold">Ink JSON Asset</strong> property updates, close the <strong class="bold">Select TextAsset</strong> window.</p></li>
				<li>Click on the <strong class="bold">Play</strong> button in the middle of the Unity editor.</li>
			</ol>
			<div><div><img src="img/Figure_7.11_B17597.jpg" alt="Figure 7.11 – Play button in Unity&#13;&#10;" width="216" height="91"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Play button in Unity</p>
			<p>Unity will run the current scene, and nothing will appear to happen. If no errors appear in the <strong class="bold">Console</strong> window, everything<a id="_idIndexMarker265"/> has run correctly. Internally, Unity has loaded the compiled<a id="_idIndexMarker266"/> ink JSON file and is ready to run the ink story.</p>
			<p>Stop the running scene by clicking on the <strong class="bold">Play</strong> button a second time.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Running an ink JSON file</h2>
			<p>ink stories<a id="_idIndexMarker267"/> are run using the <code>Story</code> class and <a id="_idIndexMarker268"/>methods. Loading an ink JSON file is only the first step. The <code>Story</code> class must be told to load one or more <em class="italic">lines</em> of the story at a time.</p>
			<p>When Inky was used to run the ink source file previously, it displayed one line at a time with an empty line between them:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1:</p>
			<pre>This is the start.
And then this happens.</pre>
			<p>When run in Inky, <em class="italic">Example 1</em> creates the following output:</p>
			<div><div><img src="img/Figure_7.12_B17597.jpg" alt="Figure 7.12 – Example 1 output&#13;&#10;" width="451" height="152"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – Example 1 output</p>
			<p>In Inky, the extra lines it created are a result of its own use of the Story API. To replicate this output, we will need to add a new method: <code>Continue()</code>:</p>
			<ol>
				<li value="1">In the same file used as part of the <em class="italic">Adding the ink Story API</em> section, open the file in Inky for editing.</li>
				<li>Change the content of the new ink source file to <em class="italic">Example 1</em> and then save the file in Inky. Do not close Inky after saving the file. Now return to Unity.</li>
				<li>Upon detecting the change in the ink source file, the ink-Unity Integration plugin will automatically re-compile the ink JSON file. Because it was associated with the Ink JSON Asset property as part of the <em class="italic">Adding the ink Story API</em> section, the ink JSON <a id="_idIndexMarker269"/>file will also always be loaded correctly.</li>
				<li>If the <code>InkLoader.cs</code> file is not already open in Visual Studio, double-click on it in the <strong class="bold">Project</strong> window.</li>
				<li>Add the following line to the <code>Start()</code> method:<pre>void Start()
{
Story exampleStory = new Story(InkJSONAsset.text);
<strong class="bold">  Debug.Log(exampleStory.Continue());</strong>
}</pre></li>
				<li>Save the changed <code>inkLoader.cs</code> file and return to Unity.</li>
				<li>Click on the <strong class="bold">Play</strong> button to run the current scene.<p>This time, the <strong class="bold">Console</strong> window will show a message.</p></li>
			</ol>
			<div><div><img src="img/Figure_7.13_B17597.jpg" alt="Figure 7.13 – Console window in Unity&#13;&#10;" width="380" height="124"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – Console window in Unity</p>
			<p>The <code>Debug.Log()</code> method used what was returned by the <code>Continue()</code> method as part of the <code>Story</code> class to display a message in the <strong class="bold">Console</strong> window.</p>
			<p>Each time the <code>Continue()</code> method is called, it loads the next line in an ink story and returns a string representing it. However, the method has an issue: it cannot detect the end of a story. For that, a different property is required.</p>
			<p>Stop<a id="_idIndexMarker270"/> the <a id="_idIndexMarker271"/>running scene by clicking on the <strong class="bold">Play</strong> button again.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Checking whether a story can continue</h2>
			<p>The <code>Continue()</code> method<a id="_idIndexMarker272"/> loads the next line<a id="_idIndexMarker273"/> of a story if it is available. In the code from <em class="italic">Example 1</em>, there are two lines.</p>
			<ol>
				<li value="1">Return to Visual Studio and edit the <code>Ink</code><code>Loader.cs</code> file. Change the <code>Story()</code> method to the following:<pre>void Start()
{
Story exampleStory = new Story(InkJSONAsset.text);
Debug.Log(exampleStory.Continue());
<strong class="bold">Debug.Log(exampleStory.Continue());</strong>
}</pre></li>
				<li>Save the <code>InkLoader.cs</code> file after adding the new line of code. Return to Unity and click on the <strong class="bold">Play</strong> button to play the current scene and updated file.</li>
				<li>The <code>Continue()</code> method and then passed to the <code>Debug.Log()</code> method.</p></li>
				<li>Click on the <strong class="bold">Play</strong> button again in Unity to stop the current scene.</li>
				<li>Return to Visual Studio and edit the <code>InkLoader.cs</code> file. Add the following code to the <code>Start()</code> method:<pre>void Start()
{
Story exampleStory = new Story(InkJSONAsset.text);
Debug.Log(exampleStory.Continue());
Debug.Log(exampleStory.Continue());
<strong class="bold">Debug.Log(exampleStory.Continue());</strong>
}</pre></li>
				<li>Save the updated <code>InkLoader.cs</code> file.</li>
				<li>Return to Unity and play the scene.<p>With the third use of the <code>Continue()</code> method, an error will happen and be displayed in the <strong class="bold">Console</strong> window.</p><div><img src="img/Figure_7.15_B17597.jpg" alt="Figure 7.15 – Continue() error in the Unity console&#13;&#10;" width="1115" height="319"/></div><p class="figure-caption">Figure 7.15 – Continue() error in the Unity console</p></li>
				<li>Click on the <code>Continue()</code> method does not check whether there is another line to load. When there is no more content, it throws an error.</p><p>To fix this<a id="_idIndexMarker275"/> issue, a <a id="_idIndexMarker276"/>property mentioned in the error is needed. The <code>Story</code> class provides the <code>canContinue</code> property for checking whether there is more story content to load. It contains a Boolean value. If there is more content, <code>canContinue</code> will be <code>true</code>. Otherwise, it will be <code>false</code>.</p></li>
				<li>Return to Visual Studio and edit the <code>InkLoader.cs</code> file. Update the <code>Start()</code> method<a id="_idIndexMarker277"/> in the <code>InkLoader.cs</code> file to the following:<pre>void Start()
{
Story exampleStory = new Story(InkJSONAsset.text);
<strong class="bold">while(exampleStory.canContinue)</strong>
<strong class="bold">      {</strong>
<strong class="bold">          Debug.Log(exampleStory.Continue());</strong>
      <strong class="bold">}</strong>
}</pre></li>
				<li>Save the edited <code>InkLoader.cs</code> file in Visual Studio.</li>
				<li>Return to Unity and play the scene again.</li>
			</ol>
			<p>With the use of a <code>while</code> loop, the story will be loaded line by line until there is no content left. Once this happens, the <code>canContinue</code> property is changed to <code>false</code> and the loop ends.</p>
			<div><div><img src="img/Figure_7.16_B17597.jpg" alt="Figure 7.16 – Console window using an updated while loop&#13;&#10;" width="382" height="183"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – Console window using an updated while loop</p>
			<p>The combination of the <code>canContinue</code> property with the <code>Continue()</code> method is a common pattern when using the Story API. More advanced usage patterns may not use a <code>while</code> loop, but<a id="_idIndexMarker278"/> the property and method will <a id="_idIndexMarker279"/>often appear together.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Selecting options programmatically</h1>
			<p>Displaying <a id="_idIndexMarker280"/>only the text of an ink story has limited usefulness. Most advanced ink stories use weaves to present different options. Along with the <code>Continue()</code> method and the <code>canContinue</code> property, the Story API also has another property called <code>currentChoices</code> that contains a list of the options generated by the most recent weave.</p>
			<p>As was demonstrated in the <em class="italic">Checking whether a story can continue</em> section, the <code>canContinue</code> property is affected by the <code>Continue()</code> method. After each line is loaded and returned as a string, the <code>Story</code> class will update the <code>canContinue</code> property if there is more story to load. This is also true of the <code>currentChoice</code> property. When the <code>Continue()</code> method is used, it will load the next line <em class="italic">and</em> any weaves.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Any previously used game objects or C# files created as part of this chapter can safely be deleted. This section will create a new game object and script component, and use different code for working with weaves and options.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Detecting ink choices</h2>
			<p>The first<a id="_idIndexMarker281"/> step to act on a weave is to detect that its choices have been loaded by the <code>currentChoices</code> property. This means both the <code>canContinue</code> property and <code>Continue()</code> method are also needed. The first prevents any issues of trying to load content that may not exist and the second loads the current line and any weaves along the way:</p>
			<ol>
				<li value="1">In a new or existing Unity project with no other game objects using the Story API, create a new, empty <code>GameObject</code>. Name it <code>Ink</code> <code>Choices</code>.<div><img src="img/Figure_7.17_B17597.jpg" alt="Figure 7.17 – ink Choices GameObject&#13;&#10;" width="347" height="151"/></div><p class="figure-caption">Figure 7.17 – ink Choices GameObject</p></li>
				<li>As was shown in the <em class="italic">Creating a script component</em> section, create a new <code>script</code> component <a id="_idIndexMarker282"/>on the <code>Ink</code> <code>Choices</code> game object. Name this new file <code>LoadingChoices.cs</code>.<div><img src="img/Figure_7.18_B17597.jpg" alt="Figure 7.18 – LoadingChoices.cs file in the Assets window" width="285" height="352"/></div><p class="figure-caption">Figure 7.18 – LoadingChoices.cs file in the Assets window</p></li>
				<li>Double-click on the <code>LoadingChoices.cs</code> file in the <strong class="bold">Assets</strong> window to open it for editing in Visual Studio:<pre>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<strong class="bold">using Ink.Runtime;</strong>
public class LoadingChoices : MonoBehaviour
{
    <strong class="bold">public TextAsset InkJSONAsset;</strong>
    void Start()
    {
        <strong class="bold">Story InkStory = new Story(InkJSONAsset.text);</strong>
        <strong class="bold">InkStory.Continue();</strong>
        <strong class="bold">foreach (Choice c in InkStory.currentChoices)</strong>
        <strong class="bold">{</strong>
            <strong class="bold">Debug.Log(c.text);</strong>
        <strong class="bold">}</strong>
    }
}</pre></li>
				<li>Save the file<a id="_idIndexMarker283"/> in Visual Studio and return to Unity.</li>
				<li>Create a new ink file and name (or rename) the file to <code>Example3.ink</code>.<div><img src="img/Figure_7.19_B17597.jpg" alt="Figure 7.19 – Example3.ink file in the Assets window&#13;&#10;" width="484" height="197"/></div><p class="figure-caption">Figure 7.19 – Example3.ink file in the Assets window</p></li>
				<li>Following the instructions in the <em class="italic">Running an ink JSON file</em> section, associate the automatically generated ink JSON file with the <code>Ink</code> <code>Choices</code> game object property.<div><img src="img/Figure_7.20_B17597.jpg" alt="Figure 7.20 – Example3.json file associated with the ink JSON Asset property" width="574" height="355"/></div><p class="figure-caption">Figure 7.20 – Example3.json file associated with the ink JSON Asset property</p></li>
				<li>Open <a id="_idIndexMarker284"/>the <code>Example3.ink</code> file for editing in Inky. Change it to the following:<pre>Sam reached out, not quite touching Juan.
* "Are you just going to leave me?"
* "He didn't mean anything to me!"
* "Can't we just start again?"</pre></li>
				<li>Save the changed <code>Example3.ink</code> file. Return to Unity and run the scene. The <strong class="bold">Console</strong> window in Unity will now show the text content of each option.</li>
			</ol>
			<div><div><img src="img/Figure_7.21_B17597.jpg" alt="Figure 7.21 – Example 3 options in the Console window&#13;&#10;" width="459" height="248"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21 – Example 3 options in the Console window</p>
			<p>The use of the <code>Continue()</code> method loaded not only the first line of <em class="italic">Example 3</em> but also the first weave appearing within the code. The <code>currentChoices</code> property contains a <code>List&lt;Choice&gt;</code> of objects per choice that exists within the weave. Each element of <code>List&lt;Choice&gt;</code> is a <code>Choice</code> object, a special class containing two important properties: <code>index</code> and <code>text</code>.</p>
			<p>Within the <code>foreach</code> loop, the <code>text</code> property of each <code>Choice</code> object is retrieved. This is then passed to the <code>Debug.Log()</code> method. When run, the ink story is loaded. Next, the first line and weave are loaded. Inside the loop, the <code>currentChoices</code> property<a id="_idIndexMarker285"/> is used to retrieve the value of each <code>text</code> property. Each is then shown in the <code>Debug.Log()</code> method.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Making choices using the Unity API</h2>
			<p>Options are<a id="_idIndexMarker286"/> selected by players to continue<a id="_idIndexMarker287"/> a story. Within the ink source code, a choice is created using either the asterisk (<code>*</code>) or the plus symbol (<code>+</code>). When run, the ink runtime code as part of the <code>Story</code> class creates <em class="italic">options</em> from these source code choices. However, to progress in an ink story, a choice must be <em class="italic">made</em>. It must exist in the code and then be presented as an option.</p>
			<p>The <code>Story</code> class provides a method named <code>ChooseChoiceIndex()</code>. This accepts an <em class="italic">index</em> (<code>int</code>) within the range of the current total number of elements in the <code>currentChoices</code> property. Each <code>Choice</code> object within the list of <code>currentChoices</code> has <code>index</code> and <code>text</code> properties. In the <em class="italic">Detecting ink choices</em> section, the <code>text</code> property was used to display the generated option from the ink source file. To <em class="italic">make</em> a choice, its <code>index</code> property is used:</p>
			<ol>
				<li value="1">Double-click on the <code>LoadingChoices.cs</code> file from the <em class="italic">Detecting ink choices</em> section to open it for editing if it is not already open in Visual Studio.</li>
				<li>Update the file to the following:<pre>void Start()
{
Story InkStory = new Story(InkJSONAsset.text);
InkStory.Continue();
<strong class="bold">Choice exampleChoice = InkStory.currentChoices[0];</strong>
<strong class="bold">InkStory.ChooseChoiceIndex(exampleChoice.index);</strong>
<strong class="bold">Debug.Log(InkStory.Continue());</strong>
}</pre></li>
				<li>Save the file in Visual Studio, return to Unity, and run the scene.</li>
			</ol>
			<p>The <code>0</code>) position element<a id="_idIndexMarker288"/> within <a id="_idIndexMarker289"/>the <code>currentChoices</code> property.</p>
			<div><div><img src="img/Figure_7.22_B17597.jpg" alt="Figure 7.22 – Option chosen from Example 3 in the Console window&#13;&#10;" width="452" height="137"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Option chosen from Example 3 in the Console window</p>
			<p>The <code>ChooseChoiceIndex()</code> method selects the first choice within the weave based on the <code>index</code> property of <code>exampleChoice</code>. This is then displayed in the Unity <code>Continue()</code> method.</p>
			<p>To <em class="italic">make</em> choices when using ink and Unity, a combination of things needs to happen in sequence. First, a story must be loaded. Second, at least one line needs to be loaded that also contains a weave. Next, the <code>currentChoices</code> property of the <code>Story</code> class must be used to retrieve the created options for the player. The <code>ChooseChoiceIndex()</code> method then needs to be used with the <code>index</code> property of one of the <code>Choice</code> objects retrieved from the <code>currentChoices</code> property. Finally, the next part of the story needs to be loaded. This additional loading will include the text of the option (if selective output is not used) chosen using the <code>ChooseChoiceIndex()</code> method. The rest of the story can then proceed.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Loading all text until the next weave</h2>
			<p>While useful<a id="_idIndexMarker290"/> for loading story content, the <code>Continue()</code> method must be used multiple times to load each line at a time. As with the code in the <em class="italic">Making choices using the Unity API</em> section, this means it would need to appear across multiple lines of code. Anticipating this problem, the Story API also includes a method named <code>ContinueMaximally()</code>. </p>
			<p>Instead of loading a line at a time, the <code>ContinueMaximally()</code> method loads all content until it encounters a weave. For many projects, this is a preferred method to use when there might be multiple lines of text between weaves or generated by ink internally as a part of the weave itself:</p>
			<ol>
				<li value="1">Create a new ink source file in Unity. Name (or rename) the file to <code>Example4.ink</code>.</li>
				<li>Open <code>Example4.ink</code> for editing in Inky and update it to the following:<pre>You read all the books and convinced your parents into going to the zoo. You just had to know. 
You enter the area containing the snakes and walk up to the glass.
-&gt; snake_house
== snake_house
+ (tap){tap &lt; 2}[Tap the glass and say something {tap &gt; 0: again}]
    {tap &lt;= 1: You tap on the glass in front of you.
      The snake turns slightly toward the noise and
      sticks out its tongue.}
    {tap &gt; 1: No, you finally decide. You cannot talk
      to snakes.}
    -&gt; snake_house
+ [Ignore the snake]
    You regard the coiled snake and then walk out.
    {tap &gt; 1: What were you thinking? Talking to
      snakes is fictional.}
    -&gt; DONE</pre></li>
				<li>Update the <code>Example4.ink</code> file with the content from <em class="italic">Example 4</em>.</li>
				<li>Click on the <code>Example3.json</code> to <code>Example4.json</code>.<div><img src="img/Figure_7.23_B17597.jpg" alt="Figure 7.23 – Updated Example4.json value in the Inspector view&#13;&#10;" width="494" height="308"/></div><p class="figure-caption">Figure 7.23 – Updated Example4.json value in the Inspector view</p></li>
				<li>Double-click on <code>LoadingChoices.cs</code> to open it for editing in Visual Studio.</li>
				<li>Update the file to the following:<pre>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Ink.Runtime;
public class LoadingChoices : MonoBehaviour
{
    public TextAsset InkJSONAsset;
    void Start()
    {
        Story InkStory = new Story(InkJSONAsset.text);
        Debug.Log(InkStory.ContinueMaximally());
        Choice exampleChoice =
        InkStory.currentChoices[0];
        <strong class="bold">Debug.Log(exampleChoice.text);</strong>
        InkStory.ChooseChoiceIndex
          (exampleChoice.index);
        Debug.Log(InkStory.ContinueMaximally());
    }
}</pre></li>
				<li>Save the<a id="_idIndexMarker292"/> changes in Visual Studio, return to Unity, and run the scene.<div><img src="img/Figure_7.24_B17597.jpg" alt="Figure 7.24 – Loaded lines and choice text from Example 4&#13;&#10;" width="1378" height="320"/></div><p class="figure-caption">Figure 7.24 – Loaded lines and choice text from Example 4</p></li>
				<li>Stop the running scene.</li>
			</ol>
			<p>The first usage of the <code>ContinueMaximally()</code> method loaded the first two lines and the weave. Next, the <code>ChooseChoiceIndex()</code> method chose the first option. The second <code>ContinueMaximally()</code> method usage, when paired with the internal divert, then loaded the next line and the weave again. </p>
			<p>When working with looping structures, the <code>ContinueMaximally()</code> method is often better than using the <code>Continue()</code> method. Use of the <code>ContinueMaximally()</code> method will always load all the new text until it encounters the next weave. For loops where text might appear between weaves, a single use of the <code>ContinueMaximally()</code> method would achieve the same effect as multiple calls to the <code>Continue()</code> method to load the same content.</p>
			<p>This topic started with detecting choices in a running ink story with the <code>currentChoices</code> property. We then moved into making choices, both creating them in the ink code and then using the <code>ChooseChoiceIndex()</code> method to pick them. Finally, we saw how the <code>ContinueMaximally()</code> method can be combined with both the <code>currentChoices</code> property and the <code>ChooseChoiceIndex()</code> method. In the next topic, we will expand on these concepts. To create a dynamic interface, we can use our knowledge <a id="_idIndexMarker293"/>of the Story API to associate the <code>GameObjects</code> user interface and create a connection between clicking a button on the screen and progressing an ink story.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Creating a dynamic user interface</h1>
			<p>The <code>Story</code> class <a id="_idIndexMarker294"/>provides multiple methods for loading and progressing a story. However, without a user interface, a player is not able to select between options and see the result. To fix this problem, additional game objects are needed to show text and provide an interface for a user to click on different things.</p>
			<p>To start, a new project is needed. Instead of example code, this will use different user interface objects for working with a user. The project will also need to create a <code>GameObject</code> can become <em class="italic">prefabricated</em> by moving it from the <code>GameObject</code> during runtime.</p>
			<p>The current lines as returned by the <code>ContinueMaximally()</code> method and choices in the <code>currentChoices</code> property can potentially be dynamic while an ink story runs. Combined with a Prefab, C# code can recreate an interface dynamically because of a player clicking on buttons to make choices in a story.</p>
			<p>In this topic, we will move through the steps of creating a dynamic interface by starting with a new Unity project and creating the necessary game objects. Next, we will associate a Prefab with our code. Finally, we will end with a section on putting everything<a id="_idIndexMarker295"/> together and running the combined project.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Creating a new project and game objects</h2>
			<p>Let us now start with creating a new project and game objects:</p>
			<ol>
				<li value="1">Create <a id="_idIndexMarker296"/>a new project in Unity. Name this project <code>The Body</code> and use a 2D template.<div><img src="img/Figure_7.25_B17597.jpg" alt="Figure 7.25 – Unity Hub project creation with the name of The Body" width="1303" height="708"/></div><p class="figure-caption">Figure 7.25 – Unity Hub project creation with the name of The Body</p><p class="callout-heading">Important Note</p><p class="callout">Before doing anything else, install the ink-Unity Integration plugin in the new project using the instructions as part of <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink-Unity Integration Plugin</em>.</p></li>
				<li>Once the project has been created by Unity, add a <code>Canvas</code> game object to the <code>Canvas</code> game object can be accessed by selecting <code>Canvas</code> game object, Unity will automatically add an <code>EventSystem</code> game object.</p></li>
				<li>Click on the <code>Canvas</code> game object. In the <strong class="bold">Inspector</strong> view, click on the <strong class="bold">Add Component</strong> button. Select <strong class="bold">Layout</strong> and then <strong class="bold">Vertical Layout Group</strong>.<div><img src="img/Figure_7.27_B17597.jpg" alt="Figure 7.27 – Vertical Layout Group component selection&#13;&#10;" width="466" height="594"/></div><p class="figure-caption">Figure 7.27 – Vertical Layout Group component selection</p><p>A vertical<a id="_idIndexMarker298"/> layout group will automatically align all other UI game objects within itself in a <em class="italic">vertical</em> pattern.</p></li>
				<li>In the vertical layout group, click on the <strong class="bold">Child Alignment</strong> dropdown and select <strong class="bold">Middle Center</strong>.<div><img src="img/Figure_7.28_B17597.jpg" alt="Figure 7.28 – Vertical Layout Group with Middle Center selected&#13;&#10;" width="855" height="521"/></div><p class="figure-caption">Figure 7.28 – Vertical Layout Group with Middle Center selected</p></li>
				<li>With the <code>Canvas</code> game object selected in the <code>Text</code> game object. <code>Text</code> game objects can be found under <code>Text</code> will be added as a child of the <code>Canvas</code> game object.<div><img src="img/Figure_7.29_B17597.jpg" alt="Figure 7.29 – Added Text game object in the Hierarchy view&#13;&#10;" width="258" height="190"/></div><p class="figure-caption">Figure 7.29 – Added Text game object in the Hierarchy view</p></li>
				<li>With <a id="_idIndexMarker299"/>the <code>Canvas</code> game object selected in the <code>Button</code> game object. <code>Button</code> can be found under <code>Button</code> game object will be added as a child of the <code>Canvas</code> game object.<div><img src="img/Figure_7.30_B17597.jpg" alt="Figure 7.30 – Added Button game object in the Hierarchy view&#13;&#10;" width="336" height="223"/></div><p class="figure-caption">Figure 7.30 – Added Button game object in the Hierarchy view</p></li>
				<li>Select the newly added <code>Button</code> game object, and then click and drag it from the <code>Button</code> in the <strong class="bold">Project</strong> window.<div><img src="img/Figure_7.31_B17597.jpg" alt="Figure 7.31 – Prefab created in the Project window&#13;&#10;" width="285" height="188"/></div><p class="figure-caption">Figure 7.31 – Prefab created in the Project window</p></li>
				<li>After the <code>Button</code> game object icon changes in the <code>Button</code> game object in the <code>Button</code> game object is now a Prefab, it exists as an asset and does not need to exist in the current <strong class="bold">Hierarchy</strong> view. (It will later be instantiated by code.)</li>
			</ol>
			<p>With the project and game objects created, the next item is a <code>script</code> component. This will create the<a id="_idIndexMarker300"/> necessary properties for other files to be associated with running the story.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Associating Prefab and ink JSON files</h2>
			<p>After <a id="_idIndexMarker301"/>creating <a id="_idIndexMarker302"/>the game<a id="_idIndexMarker303"/> objects in the last <a id="_idIndexMarker304"/>section, we will now create a <code>script</code> component, create the necessary properties, and then associate assets with the properties:</p>
			<ol>
				<li value="1">Select the <code>Canvas</code> game object in the <strong class="bold">Hierarchy</strong> view.</li>
				<li>In the <code>script</code> component using the instructions in the <em class="italic">Creating a script component</em> section.</li>
				<li>Name (or rename following creation) this new file <code>InkStory.cs</code>.<div><img src="img/Figure_7.32_B17597.jpg" alt="Figure 7.32 – Created InkStory.cs file&#13;&#10;" width="327" height="188"/></div><p class="figure-caption">Figure 7.32 – Created InkStory.cs file</p></li>
				<li>Double-click on the <code>InkStory.cs</code> file for editing in Visual Studio.</li>
				<li>Update the code to the following:<pre>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<strong class="bold">using Ink.Runtime;</strong>
public class InkStory : MonoBehaviour
{
    <strong class="bold">public TextAsset InkJSONAsset;</strong>
    <strong class="bold">public GameObject prefabButton;</strong>
}</pre></li>
			</ol>
			<p>There <a id="_idIndexMarker305"/>are<a id="_idIndexMarker306"/> three <a id="_idIndexMarker307"/>new additions to the default<a id="_idIndexMarker308"/> code provided by Unity. The first is the inclusion of the <code>Ink.Runtime</code> namespace. This will allow us to work with ink while a story runs. The second two additions are the properties we will be using in the <code>public</code> keyword in C# to create a property we can adjust in the editor:</p>
			<ol>
				<li value="1">Save the file and return to Unity.</li>
				<li>Create a new ink file named (or renamed following creation) <code>TheBody.ink</code>.</li>
				<li>Open the <code>TheBody.ink</code> file in Inky for editing and copy the contents from the file from GitHub.<p class="callout-heading">Note</p><p class="callout">The code for this example, <code>TheBody.ink</code>, can be found on GitHub.</p></li>
				<li>Save the ink source file and return to Unity.<p>The use of the <code>public</code> keyword in <code>InkStory.cs</code> added two new properties to the <code>Canvas</code> game object.</p><div><img src="img/Figure_7.33_B17597.jpg" alt="Figure 7.33 – Properties added in the Inspector view&#13;&#10;" width="525" height="156"/></div><p class="figure-caption">Figure 7.33 – Properties added in the Inspector view</p></li>
				<li>Click<a id="_idIndexMarker309"/> on<a id="_idIndexMarker310"/> the<a id="_idIndexMarker311"/> file selection next to<a id="_idIndexMarker312"/> the <code>Ink</code> <code>JSON Asset</code> property to open the <strong class="bold">Select TextAsset</strong> window.</li>
				<li>Associate the ink JSON file created by the ink-Unity Integration plugin with the <strong class="bold">Ink JSON Asset</strong> property and then close the <strong class="bold">Select TextAsset</strong> window.</li>
				<li>Click on the file selection next to the <code>Button</code> Prefab to open the <strong class="bold">Select GameObject</strong> window. </li>
				<li>Select the <strong class="bold">Assets</strong> tab in the <strong class="bold">Select GameObject</strong> window if it is not open. </li>
				<li>Select the <strong class="bold">Button</strong> Prefab and then close the <strong class="bold">Select GameObject</strong> window.</li>
			</ol>
			<p>The result of associating the ink JSON file with the <code>Button</code> Prefab will be that the code has access to those assets during runtime.</p>
			<div><div><img src="img/Figure_7.34_B17597.jpg" alt="Figure 7.34 – Updated Ink Story component with the ink JSON file and button Prefab values&#13;&#10;" width="678" height="196"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.34 – Updated Ink Story component with the ink JSON file and button Prefab values</p>
			<p>With the file associated with properties of the <code>script</code> component, additional code can now be written. Changing the ink source file, <code>TheBody.ink</code>, and saving the change will automatically update the <code>TheBody.json</code> file. The same is also true of the <code>Button</code> Prefab. It can also be adjusted, and its settings changed. As long as neither asset is renamed, Unity will maintain the association and allow developers to customize their settings independent of the code using them when the scene runs.</p>
			<p>By the end of this section, we will have created a Unity project, its game objects, and associated assets with properties. Before we can run the project, we will need to write more code to dynamically create a user interface based on the content of a running ink story. In the next section, we will write the code to use the Prefab and create a dynamic interface<a id="_idIndexMarker313"/> based <a id="_idIndexMarker314"/>on the <a id="_idIndexMarker315"/>text output <a id="_idIndexMarker316"/>of the <code>ContinueMaximally()</code> method and the <code>currentChoices</code> property.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Making a dynamic user interface</h2>
			<p>The final<a id="_idIndexMarker317"/> series of steps needed before the Unity project can be run is to add more code. We need to incorporate the concepts explained in this chapter covering the use of the <code>ContinueMaximally()</code> method and the <code>currentChoices</code> property. We also need to add an overall loop within the code using the <code>canContinue</code> property to check whether there is more content before progressing the story.</p>
			<p>We begin by adding the properties we will need within the class that will not be used by the Unity editor. We mark these using the <code>private</code> keyword.</p>
			<p>Open <code>InkStory.cs</code> for editing in Visual Studio:</p>
			<pre>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<strong class="bold">using UnityEngine.UI;</strong>
using Ink.Runtime;
public class InkStory : MonoBehaviour
{
    public TextAsset InkJSONAsset;
    public GameObject prefabButton;
    <strong class="bold">private Story inkStory;</strong>
    <strong class="bold">private Text currentLinesText;</strong>
}</pre>
			<p>To work with user interface game objects, another instance of the <code>using</code> keyword is needed. This adds access to classes such as <code>Text</code> and <code>Button</code> used in this file.</p>
			<p>The <code>Story</code> class and the <code>Text</code> game object <code>currentLinesText</code> will be used across methods in this code. To make sure they can be used in this way, they must be properties of the <code>InkStory</code> class and not variables within any method.</p>
			<p>The first thing that must happen is the loading of the ink JSON file. Next, a reference to the <code>Text</code> component is needed. The text will be shown to the user each time they make a choice. This <a id="_idIndexMarker318"/>means the <code>text</code> property of the <code>Text</code> game object will need to be updated. However, as it is a child of <code>Canvas</code>, the <code>GetComponentInChildren()</code> method is needed:</p>
			<pre><strong class="bold">void Start()</strong>
<strong class="bold">{</strong>
<strong class="bold">inkStory = new Story(InkJSONAsset.text);</strong>
<strong class="bold">currentLinesText = GetComponentInChildren&lt;Text&gt;();</strong>
<strong class="bold">}</strong></pre>
			<p>The process of loading the text content and current choices will be used multiple times. This means all the code used as part of the process should be its own method:</p>
			<pre><strong class="bold">void LoadTextAndWeave()</strong>
<strong class="bold">{</strong>
<strong class="bold">if (inkStory.canContinue)</strong>
<strong class="bold">{</strong>
<strong class="bold">currentLinesText.text = inkStory.ContinueMaximally();</strong>
<strong class="bold">foreach (Choice c in inkStory.currentChoices)</strong>
<strong class="bold">{</strong>
<strong class="bold">GameObject cloneButtonGameObject = </strong>
<strong class="bold">  Instantiate(prefabButton, this.transform);</strong>
<strong class="bold">Button cloneButtonButton =</strong>
<strong class="bold">  cloneButtonGameObject.GetComponent&lt;Button&gt;();</strong>
<strong class="bold">cloneButtonButton.onClick.AddListener(delegate</strong>
<strong class="bold">{</strong>
<strong class="bold">inkStory.ChooseChoiceIndex(c.index);</strong>
<strong class="bold">LoadTextAndWeave();</strong>
<strong class="bold">                });</strong>
<strong class="bold">Text cloneButtonText = cloneButtonButton.</strong>
<strong class="bold">  GetComponentInChildren&lt;Text&gt;();</strong>
<strong class="bold">cloneButtonText.text = c.text;</strong>
<strong class="bold">}</strong>
<strong class="bold">}</strong>
<strong class="bold">}</strong></pre>
			<p>In the <a id="_idIndexMarker319"/>new <code>LoadTextAndWeave()</code> method, new text content will be loaded if the <code>canContinue</code> property is true. Using the <code>foreach</code> keyword, new buttons will be added by using the <code>Instantiate()</code> method in Unity. This <em class="italic">instantiates</em> a Prefab as a GameObject during runtime, creating it through code and adding it to the running scene.</p>
			<p>Finally, the <code>AddListener()</code> method is used with the <code>OnClick</code> property of a button in Unity. This adds to a collection of which functions should be notified that a click has happened. The <code>delegate</code> keyword allows a developer to pass a method as an argument to another method. In this case, a short method is created within the same scope as the <code>foreach</code> loop. The <code>index</code> property can thus be used inside this created method.</p>
			<p>Every time the button is clicked, the <code>Story</code> class method <code>ChooseChoiceIndex()</code> will be called with the correct index, and the <code>LoadTextAndWeave()</code> method will be called again, refreshing the value of the <code>currentLinesText</code> method and updating the current buttons shown on the screen:</p>
			<ol>
				<li value="1">To run<a id="_idIndexMarker320"/> the current code, one more change is needed. The <code>LoadTextAndWeave()</code> method needs to be called inside the <code>Start()</code> method:<pre>void Start()
{
inkStory = new Story(InkJSONAsset.text);
currentLinesText = GetComponentInChildren&lt;Text&gt;();
<strong class="bold">LoadTextAndWeave();</strong>
}</pre></li>
				<li>Save the current code in Visual Studio. Return to Unity and run the scene.<p>Immediately, two problems will become evident. First, the default black text on a dark background makes the text impossible to read. Second, only the first few words will be shown.</p><div><img src="img/Figure_7.35_B17597.jpg" alt="Figure 7.35 – The Body project running in Unity" width="350" height="329"/></div><p class="figure-caption">Figure 7.35 – The Body project running in Unity</p></li>
				<li>Click on the <strong class="bold">(Continue.)</strong> button to see two more problems.</li>
			</ol>
			<div><div><img src="img/Figure_7.36_B17597.jpg" alt="Figure 7.36 – Dynamically created buttons in The Body" width="368" height="447"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.36 – Dynamically created buttons in The Body</p>
			<p>The first <a id="_idIndexMarker321"/>problem is that instead of replacing the first button, Unity added two more. This is caused by the second call to the <code>LoadTextAndWeave()</code>method internally. First, the text content and button were loaded. Next, when the <strong class="bold">(Continue.)</strong> button was clicked, it was called again, adding more buttons.</p>
			<p>We can also observe that the buttons are small and hard to read. By default, Unity will assume some values for a <code>Button</code> game object. While adjusting our code, we will also need to change the properties:</p>
			<ol>
				<li value="1">Stop the running scene.</li>
				<li>To start to fix the issue with the text, first, select the <code>Text</code> game object in the <code>160</code> and <code>30</code>. </li>
				<li>Through either clicking and dragging using the <code>800</code> and height of <code>300</code>.<div><img src="img/Figure_7.37_B17597.jpg" alt="Figure 7.37 – The Inspector view in Unity with updated width and height values&#13;&#10;" width="894" height="430"/></div><p class="figure-caption">Figure 7.37 – The Inspector view in Unity with updated width and height values</p></li>
				<li>Click on the <code>14</code> to <code>24</code>. This will make the starting size larger.</li>
				<li>Click on the <code>default</code> to <code>white</code> and then close the <strong class="bold">Color</strong> window.<p>The updated values will now display more text and, with the white on a darker background, increase<a id="_idIndexMarker322"/> its readability.</p><div><img src="img/Figure_7.38_B17597.jpg" alt="Figure 7.38 – Updated Text GameObject component values&#13;&#10;" width="820" height="559"/></div><p class="figure-caption">Figure 7.38 – Updated Text GameObject component values</p></li>
				<li>Click on the <code>Button</code> Prefab in the <strong class="bold">Project</strong> window.</li>
				<li>Like the <code>Text</code> game object, its default width is <code>160</code> and its height is <code>30</code>. Change the width to <code>250</code> and the height to <code>100</code>.<div><img src="img/Figure_7.39_B17597.jpg" alt="Figure 7.39 – Updated button Prefab values&#13;&#10;" width="623" height="259"/></div><p class="figure-caption">Figure 7.39 – Updated button Prefab values</p></li>
				<li>Return to editing <code>InkStory.cs</code> in Visual Studio.</li>
			</ol>
			<p>The fix to the code is a small but important one. Each time the button is clicked, the code will need to destroy the current buttons and then create new ones:</p>
			<ol>
				<li value="1">A new <a id="_idIndexMarker323"/>method is needed for the specific task of destroying <code>Button</code> children:<pre><code>DestroyButtonChildren()</code> method needs to be called as part of the delegate method. Before the content is refreshed, the current buttons need to be destroyed:</p><pre>cloneButtonButton.onClick.AddListener(delegate
{
inkStory.ChooseChoiceIndex(c.index);
<strong class="bold">DestoryButtonChildren();</strong>
LoadTextAndWeave();
});</pre></li>
				<li>Save the updated file in Visual Studio and return to Unity.<p>The <code>DestroyButtonChildren()</code> method looks for a specific <code>tag</code> value. This needs to be added to the <code>Button</code> Prefab.</p></li>
				<li>Select the <code>Button</code> Prefab in the <strong class="bold">Project</strong> window.</li>
				<li>In the <strong class="bold">Inspector</strong> view, click <a id="_idIndexMarker324"/>on the <strong class="bold">Tag</strong> drop-down menu and then the <strong class="bold">Add Tag…</strong> option.<div><img src="img/Figure_7.40_B17597.jpg" alt="Figure 7.40 – Tag drop-down menu in the Unity Inspector view" width="301" height="308"/></div><p class="figure-caption">Figure 7.40 – Tag drop-down menu in the Unity Inspector view</p></li>
				<li>Click on the <strong class="bold">+</strong> icon to add a new tag to the list. In the prompt, use the name <em class="italic">ButtonChoice</em>.<div><img src="img/Figure_7.41_B17597.jpg" alt="Figure 7.41 – New tag name&#13;&#10;" width="499" height="135"/></div><p class="figure-caption">Figure 7.41 – New tag name</p></li>
				<li>Click on <strong class="bold">Save</strong> to create a new tag.</li>
				<li>Click on the <code>Button</code> Prefab in the <code>ButtonChoice</code> tag has been added, it must be selected. </p></li>
				<li>In the <strong class="bold">Tag</strong> dropdown, select <strong class="bold">ButtonChoice</strong>.<div><img src="img/Figure_7.42_B17597.jpg" alt="Figure 7.42 – Added ButtonChoice option to the Tag drop-down menu&#13;&#10;" width="287" height="298"/></div><p class="figure-caption">Figure 7.42 – Added ButtonChoice option to the Tag drop-down menu</p></li>
				<li>Run the <a id="_idIndexMarker325"/>scene. Play through the story by clicking on buttons to make choices and see the result. </li>
				<li>Stop the running scene when done playing the story.</li>
			</ol>
			<p>The changes to the <code>Text</code> game object and code will load the new text and correctly update the choices as the player clicks on the buttons. While consisting of multiple steps, this same approach can be used with most ink JSON files to present text and dynamic buttons <a id="_idIndexMarker326"/>for a player to make different choices and then see the result on the screen.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Summary</h1>
			<p>In this chapter, we worked through the process of adding a <code>script</code> component, associating an ink JSON file with a property, and using methods and properties as part of the <code>Story</code> class to progress a running ink story. We saw how the <code>Continue()</code> method loads one line at a time and the <code>ContinueMaximally()</code> method loads all text until it encounters a weave. When combined with the <code>canContinue</code> property, these methods allow for text content to be loaded from an ink JSON file and prevent any errors when the content runs out. With the <code>currentChoices</code> property, we examined how to use loops, such as those using the <code>foreach</code> keyword. When we used the <code>ChooseChoiceIndex()</code> method, we picked which option among the weave we wanted and progressed through a story using the <code>Continue()</code> or <code>ContinueMaximally()</code> methods again.</p>
			<p>By setting up user interface game objects in Unity, we built a dynamic process to load ink story content, destroy buttons, and then create new ones. Needing to create a <code>Button</code> Prefab, we saw how these could be instantiated by the code while it was running. Adjusting the values of <code>Text</code> and <code>Button</code> game objects, we completed an interface for running an ink JSON file and built a system usable by many other projects working with the same game objects and organization.</p>
			<p>In the next chapter, we continue to use the <code>Story</code> class and its methods. We will examine how to retrieve and update the values of variables in an ink story using C# code. We will also see ways of accessing functions in ink and how to pass data in and out of them. Combined with user interface game objects, we will build an example of how to communicate between the ink runtime and Unity code by using content from ink to create multiple dynamic interfaces in Unity.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between the <code>Continue()</code> and <code>ContinueMaximally()</code> methods in the <code>Story</code> class?</li>
				<li>What type of data does the <code>ChooseChoiceIndex()</code> method in the <code>Story</code> class expect?</li>
				<li>How is the <code>canContinue</code> property used with the <code>Continue()</code> and <code>ContinueMaximally()</code> methods in the <code>Story</code> class?</li>
				<li>What is a Prefab in Unity?</li>
				<li>What type of object is found in the <code>currentChoices</code> list property of the <code>Story</code> class?</li>
			</ol>
		</div>
	</div></body></html>