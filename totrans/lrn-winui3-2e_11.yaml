- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging WinUI Applications with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good debugging skills are essential for developers. While .NET developers need
    to know how to use features including breakpoints and the **Output** and **Immediate**
    windows, WinUI project debugging adds another set of tools and techniques to master.
    There are issues that can arise in the UI layer with data binding, layout, and
    resources. You will learn how to use **Live Visual Tree** and **Live Property
    Explorer** and how to discover data binding errors with Visual Studio’s **XAML
    Binding** **Failures** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to debug WinUI applications and work with breakpoints in ViewModels and
    service classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to debug data binding failures by leveraging the **XAML Binding Failures**
    window in Visual Studio and avoid common problems when binding to collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the **Live Visual Tree** window in Visual Studio to find layout problems
    in your XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover and use **Live Property Explorer** to get and set data in your XAML
    elements at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be comfortable with debugging common problems
    typically encountered by WinUI developers while developing applications. You’ll
    be able to use these skills while building applications with other XAML frameworks,
    such as .NET MAUI, WPF, and UWP, too.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 version 1809 (build 17763) or newer or Windows 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2022 or later with the .NET Desktop Development workload configured
    for Windows App SDK development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available on GitHub at this URL: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several fundamental areas of debugging WinUI applications that we
    will be covering in this section. Some of these techniques are applicable to debugging
    other types of .NET applications, whereas others are specific to XAML and WinUI
    development. Throughout the book, we’ve run our projects with Visual Studio, which
    is an example of a local debugging session. We will explore other ways to debug
    local applications as well as remote applications.
  prefs: []
  type: TYPE_NORMAL
- en: Simple mistakes in XAML markup are not always apparent when we’re writing it,
    and this kind of problem is not detected by the compiler. In this section, we
    will see how to detect and avoid XAML markup issues and how to adhere to best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by taking a closer look at debugging local applications.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging local applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the **Ch11-MyMediaCollection** project from GitHub and compile it to make
    sure you have downloaded all the referenced NuGet packages. This is the WinUI
    3 project that we’ve been building throughout the previous chapters. Run the application
    to make sure everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have experience in developing and debugging WPF or UWP applications,
    you’re probably familiar with **XAML Designer** in Visual Studio. There is no
    designer support for WinUI 3 applications at this time. It’s unclear if or when
    this feature will be added. There is some discussion on GitHub about this topic
    here: [https://github.com/microsoft/microsoft-ui-xaml/issues/5917](https://github.com/microsoft/microsoft-ui-xaml/issues/5917).
    As one of the comments in the issue suggests, you can try to work around this
    limitation by leveraging **XAML Hot Reload** in Visual Studio to make changes
    to the XAML file while debugging. While there are some limitations to this approach
    (see [https://github.com/microsoft/microsoft-ui-xaml/issues/7043](https://github.com/microsoft/microsoft-ui-xaml/issues/7043)),
    most simple XAML changes will be reflected in the running app when saving. For
    more information about XAML Hot Reload, see the Microsoft Learn documentation:
    [https://learn.microsoft.com/visualstudio/xaml-tools/xaml-hot-reload](https://learn.microsoft.com/visualstudio/xaml-tools/xaml-hot-reload).'
  prefs: []
  type: TYPE_NORMAL
- en: For our first walk-through, let’s look at how to debug a local application installed
    on your PC.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a locally installed application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have been running and debugging our Visual Studio solutions throughout this
    book. Now we will see how you can debug an application that you have already installed
    in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have previously run several projects while reading this book. Unless you
    uninstalled them, each should appear as an installed app package that you can
    debug. Let’s start with the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by selecting **Debug** | **Other Debug Targets** | **Debug Installed
    App Package** in Visual Studio. The **Debug Installed App Package** window will
    appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The Debug Installed App Package window](img/B20908_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The Debug Installed App Package window
  prefs: []
  type: TYPE_NORMAL
- en: This window will show all the installed packages on your Windows PC. Some names
    will be familiar, such as **Microsoft.WindowsTerminal**, **Fluent XAML Theme Editor**,
    or **Microsoft Defender**. Others will only be listed by their application ID.
    You can select some of these other applications to debug, but without debug symbols,
    you won’t be able to hit any breakpoints or step through the code. Let’s find
    one of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: If you have debugged the `MyMediaCollection`. The **MyMediaCollection** application
    will appear in the search results. If you do not see it, make sure you have run
    the application from Visual Studio at least once. This step is necessary to package
    and deploy the application to Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select it and click **Start**. The application will run, and Visual Studio will
    start debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don’t want to start debugging immediately, you can select the **Do not
    launch, but debug my code when it starts** checkbox. Now, Visual Studio will start
    debugging when you start the application from the **Start** menu or any other
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another way to start debugging an installed local application is by attaching
    it to a running application:'
  prefs: []
  type: TYPE_NORMAL
- en: First, run the app from the **Start** menu, and in Visual Studio, go to **Debug**
    | **Attach** **to Process**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `ApplicationFrameHost.exe` process with the title that matches the application
    you want to debug. This is the process that hosts every packaged WinUI and UWP
    application on Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Attaching to a running process to debug a packaged application](img/B20908_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Attaching to a running process to debug a packaged application
  prefs: []
  type: TYPE_NORMAL
- en: Click **Attach** and begin debugging as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are different ways to start a debugging session on a local application,
    but what if you want to debug your application running on another machine? Let’s
    examine those options next.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging remote applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many reasons why you might want to debug an application on a remote
    machine. Sometimes you can only reproduce an error on one device. Perhaps there
    is an issue that only occurs on a specific device type or screen size. If you
    were working with a UWP project, there are some devices, such as Xbox, where you
    have to use remote debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting any remote debugging session, ensure that the target device
    has **developer mode** enabled. For more information about activating developer
    mode, you can read this Microsoft Docs article: [https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development](https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug a remote installed application, you will use Visual Studio’s **Debug
    Installed App Package** window again:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the window from **Debug** | **Other Debug Targets** | **Debug Installed**
    **App Package**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change **Connection Type** to **Remote Machine**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Debugging an application package on a remote machine](img/B20908_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Debugging an application package on a remote machine
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Change** button in the **Connection Type** section to open the **Remote**
    **Connections** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visual Studio will attempt to discover other Windows devices and list them
    in the **Auto Detected** section. If you see the device you want, select it to
    continue. If the device you want to debug isn’t shown, enter its IP address in
    the **Address** field in the **Manual Configuration** section and click **Select**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Enter a manually configured remote connection for debugging](img/B20908_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Enter a manually configured remote connection for debugging
  prefs: []
  type: TYPE_NORMAL
- en: When you return to the previous window, you can select the application to debug
    from the list of installed app packages on the selected device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Start** to begin debugging, just as we did with the locally installed
    application in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These techniques will allow you to connect to other Windows machines. For UWP
    applications, this includes other device types, such as Xbox, HoloLens, Surface
    Hub, and Windows IoT devices. Debugging options and resources can also be accessed
    from the **Debug** tab of the project’s **Properties** page. Select **Open debug
    launch profiles UI** to open the **Launch** **Profiles** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – The Launch Profiles window in Visual Studio](img/B20908_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – The Launch Profiles window in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Let’s shift gears and examine some common mistakes that can cause rendering
    issues in your application’s UI.
  prefs: []
  type: TYPE_NORMAL
- en: Common XAML layout mistakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many kinds of mistakes that XAML developers can make while coding
    the UI. Some of them won’t be caught by the compiler. If you have a syntax error
    or an invalid `x:Bind` expression, these will fail while compiling, but many other
    issues will not.
  prefs: []
  type: TYPE_NORMAL
- en: The first source of common XAML layout mistakes we will explore is the `Grid`
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Grid layout issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some mistakes related to the `Grid` control revolve around its rows and columns.
    Forgetting to set `Grid.Row` or `Grid.Column` on child controls leads to overlapping
    or obscured elements at runtime. Similar issues can be seen when setting these
    values incorrectly or when working with `Grid.RowSpan` and `Grid.ColumnSpan`.
    One mistake that’s not always immediately apparent is setting `Grid.Row` or `Grid.Column`
    to a value that’s beyond the defined number of rows or columns.
  prefs: []
  type: TYPE_NORMAL
- en: Open `Grid.Row` attribute from the `Border` control containing the `Button`
    controls at the bottom of the page. If you run the application, you will see the
    buttons move to the top of the page and overlap the controls in the header area.
  prefs: []
  type: TYPE_NORMAL
- en: Now restore the `Grid.Row` attribute but change the value to `5`. If this were
    the last row in the grid, everything would look fine even though `Grid` only has
    four rows. Since `5` is greater than the number of available rows, the control
    is added to the last row in `Grid`. However, because we have `InfoBar` below the
    buttons in the fourth row, the buttons and the `InfoBar` overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Problems when applying style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XAML `Style` resources are another common source of unintentional UI changes.
    When creating `Style` in `Resource`, you should be aware of how it will be applied
    to controls within the scope of that `Resource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Page.Resources` section. This is where we created three `Style` elements
    for the current page. Each has a different `Target` type: `TextBlock`, `TextBox`,
    and `ComboBox`. However, they won’t be applied to every control of those types
    on the `Page` because we also gave each `Style` an `x:Key`. That means that `Style`
    will only be applied to elements of that type when the `Style` property is explicitly
    set to that named resource. These are referred to as *explicit styles*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you remove `x:Key` from `Style` in `Page.Resources`, that *implicit style*
    will apply to every control of the specified `Target` type on the `Page`, unless
    those controls have another explicit `Style` set. In a large application with
    styles declared at different scopes (`Application`, `Page`, or control), it can
    sometimes be difficult to determine which style has been applied to a control.
    We will see how to do this later in the chapter when discussing Visual Studio’s
    **Live Property Explorer** window. It’s a best practice to have implicit styles
    always inherit from an explicit style. This enables developers to inherit from
    a default style and reduces repeated implicit style attributes across elements.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at a third-party extension that can help find common XAML
    problems through **static** **code analysis**.
  prefs: []
  type: TYPE_NORMAL
- en: Improving your XAML with static code analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a free, open source extension for Visual Studio that, among other things,
    adds support for static code analysis to XAML files. **Rapid XAML Toolkit** ([https://rapidxaml.dev/](https://rapidxaml.dev/))
    provides XAML analyzers and code fixes for common issues and provides support
    for adding your own custom XAML analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Rapid XAML Toolkit for Visual Studio 2022 has not yet
    been released. It is being developed and should be available by the time you read
    this book. The current example illustrates how to use the extension currently
    available for Visual Studio 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install the tool in Visual Studio and see what kind of issues it can
    identify in a WinUI project:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, go to **Extensions** | **Manage Extensions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rapid xaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 11.6 – Installing Rapid XAM\uFEFFL Toolkit](img/B20908_11_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Installing Rapid XAML Toolkit
  prefs: []
  type: TYPE_NORMAL
- en: Click **Download** to queue the extension for installation. When the download
    completes, you can close the **Manage Extensions** window and restart Visual Studio
    to complete the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when you view the **Error List** window in Visual Studio, there are a
    handful of warnings from Rapid XAML’s analyzers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Viewing the new warnings from Rapid XAML Toolkit](img/B20908_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Viewing the new warnings from Rapid XAML Toolkit
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **ItemDetailPage.xaml**, place your cursor over one of the green squiggles
    created by the code analyzer, and click the lightbulb icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – View the quick fix for a code analyzer warning](img/B20908_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – View the quick fix for a code analyzer warning
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can right-click on the XAML and select **Rapid XAML** | **Move
    hard-coded string to resource file.** to fix all warnings of this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a list of other analyzers that are provided by the toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Grid.Row` value without a corresponding `RowDefinition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid.Column` value without a corresponding `ColumnDefinition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid.RowSpan` value without a corresponding `ColumnDefinition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid.ColumnSpan` value without a corresponding `ColumnDefinition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextBox` does not have `InputScope` specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedItem` binding should probably be `TwoWay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RXT200**: The hardcoded string value that should be a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry` does not have a `Keyboard` specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxLength` specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image` lacks accessibility consideration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageButton` lacks accessibility consideration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Checked` and `Unchecked` events for a `CheckBox`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediaPlayerElement` in place of `MediaElement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x:Uid` should begin with an uppercase character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name` should begin with an uppercase character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RXT999**: Unknown error – something went wrong when parsing the XAML document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rapid XAML Toolkit has many other features outside of analyzers and code fixes,
    and new features and analyzers are being added frequently. To see a list of upcoming
    features and fixes being considered, you can view the issues on GitHub: [https://github.com/mrlacey/Rapid-XAML-Toolkit/issues](https://github.com/mrlacey/Rapid-XAML-Toolkit/issues).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Community-driven projects like this are always looking for contributors. It’s
    a great way to get started with the open source community.
  prefs: []
  type: TYPE_NORMAL
- en: Another related topic that can be a common source of developer angst is debugging
    data binding. Let’s see how we can avoid some common pitfalls in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pinpointing data binding failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While debugging data binding problems is not as difficult in WinUI and UWP as
    it is in WPF (if you use `x:Bind`-compiled bindings), there are still some *gotchas*
    to avoid. In this section, we will look at what can go wrong in views and ViewModels
    and how you can diagnose and fix the problems.
  prefs: []
  type: TYPE_NORMAL
- en: Common mistakes in data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use `x:Bind`, the compiler will evaluate whether you’re binding to a
    valid source and can give you the peace of mind of knowing that your views and
    ViewModels are hooked up correctly, but there is still a lot that can go wrong.
    Let’s review a few of the most common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the best binding mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen in previous chapters that the default mode for most controls with
    `x:Bind` is `OneTime`, while the default for `Binding` is `OneWay`. Defaulting
    to `OneTime` helps with performance as many read-only properties are only ever
    set when the view is first created. However, if you forget to change this for
    controls bound to data that changes as the user is interacting with the page,
    you may not immediately realize why the data in the UI isn’t updating.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re binding controls that need data to flow in both directions, remember
    to set `Mode` to `TwoWay`. We used this in the `ComboBox.SelectedItem` property
    to filter the collection by media type.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering PropertyChanged notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By binding to a ViewModel that properly implements `INotifyPropertyChanged`
    for all its public properties, issues related to `PropertyChanged` are not common.
    Using MVVM Toolkit makes it even simpler. Problems can still arise if ViewModel
    code outside of one of these properties updates the property’s value by setting
    the `private` backing variable. This will update the property’s value without
    notifying the view. If you are using MVVM Toolkit, it will call out this issue
    when it generates its code in the hidden partial class. You can avoid this by
    always using the `public` property to update the value. If there is a good reason
    for not updating the property directly, then a `PropertyChanged` event should
    be manually triggered for that property after updating the value. It is a best
    practice to use the `nameof` method in C# to ensure you use a property name that
    exists. Misspelled property names will be caught at compile time and highlighted
    in the editor. You can also use `CallerMemberNameAttribute` in .NET: [https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.callermembernameattribute](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.callermembernameattribute).
    An exception will be raised if your application tries to raise a property change
    notification for a property that does not exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with ObservableCollection<T>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ObservableCollection<T>` serves an important role. Lists in the view will
    stay synchronized with the collections if they are used correctly. There are a
    few practices to avoid when using observable collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Do not replace the entire value of an observable collection. The element on
    the view bound to the property will still be bound to the original collection.
    Any subsequent changes to the collection will not be reflected in the view. While
    you can work around this by triggering a `PropertyChanged` notification, this
    can have performance implications with larger collections. It can also be jarring
    to the user, as most controls will reset the current view to the beginning of
    the list. Set ViewModel properties that use `ObservableCollection<T>` to be read-only
    to avoid accidentally resetting the entire collection. The one exception to this
    is if you know the collection will be completely repopulated. Removing and re-adding
    a large number of items individually in a list can result in a poor user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use LINQ to modify observable collections. LINQ expressions do not operate
    by calling the `Add` and `Remove` methods on the observable collections. They
    do not even return `ObservableCollection<T>`. If you use LINQ and convert the
    results back to `ObservableCollection<T>`, you will be back to replace the entire
    collection, which was just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using LINQ. This will cause the view to stop receiving `CollectionChanged`
    notifications because LINQ does not return an `ObservableCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: for (int i = _entryList.Count - 1; i >= 0; i--)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Entry entry = _entryList[i];
  prefs: []
  type: TYPE_NORMAL
- en: if (!entry.Lastname.StartsWith("J"))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: _entryList.Remove(entry);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <StackPanel DataContext="Test" Background="LightGray">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBox x:Name="Text1"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Text="{Binding Path=SomeText,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mode=TwoWay}"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBox Text="{Binding ElementName=Text1,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Path=Text, Mode=OneWay}"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </StackPanel>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <StackPanel DataContext="Test"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Background="LightGray">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBox x:Name="Text1"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Text="{Binding Path=SomeText,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mode=TwoWay}"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBox Text="{Binding ElementName=Text1,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Path=Text, Mode=OneWay}"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </StackPanel>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
