- en: Chapter 3. Singletons, Statics, GameObjects, and the World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：单例、静态、GameObject和世界
- en: Every level or game world in Unity is represented by a scene, and a scene is
    a collection of game objects situated inside a Cartesian 3D coordinate system
    with *x*, *y* and *z* axes. Units in a scene are measured in Unity units, and
    these correspond (for practical purposes) to meters. In order to script masterfully
    with Unity, it's critical to understand the anatomy of both scenes and objects
    and how interobject communication happens; that is, it's important to know how
    separate and independent objects in a scene can communicate with each other to
    make things happen as you expect. Consequently, this chapter focuses on the native
    Unity methods available to optimally search, reference, and access objects in
    a scene. It also focuses on additional concepts such as statics and singletons
    for the creation of objects that travel between scenes, retaining their data as
    they move. Of course, this chapter will not only consider these methods individually,
    but it'll try to appraise them in practical contexts, with performance and efficiency
    in mind.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，每个级别或游戏世界都由一个场景表示，而场景是由位于笛卡尔3D坐标系中、具有*x*、*y*和*z*轴的游戏对象集合组成的。场景中的单位以Unity单位计量，在实际应用中相当于米。为了能够熟练地使用Unity进行脚本编写，理解场景和对象的解剖结构以及对象间通信的方式至关重要；也就是说，了解场景中独立且分离的对象如何相互通信以实现预期的效果非常重要。因此，本章重点介绍了在场景中优化搜索、引用和访问对象的本地Unity方法。它还关注了诸如静态和单例等额外概念，用于创建在场景间移动并保留其数据的对象。当然，本章不仅会单独考虑这些方法，还会尝试在考虑性能和效率的实用环境中评估它们。
- en: The GameObject
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameObject
- en: 'The `GameObject` is, in many senses, the fundamental unit or entity inside
    a scene. It corresponds most naturally to what we''d call a *thing* in the everyday
    sense. It doesn''t really matter what kind of context-specific behaviors or things
    you''ll actually need inside your own games, because in all cases, you''ll need
    `GameObjects` to implement them. `GameObjects` don''t need to be visible to the
    gamer; they can be, and often are, invisible. Sounds, colliders, and manager classes
    are some examples of invisible `GameObjects`. On the other hand, many `GameObjects`
    will be visible: meshes, animated meshes, sprites, and so on. In all cases, however,
    whether visible or invisible, the `GameObject` is instantiated inside a scene
    as a collection of related components. A **component** is essentially a class
    derived from `MonoBehaviour`, and it can be attached to a `GameObject` in the
    scene to change its behavior. Every `GameObject` has at least one minimal component
    in common, and it''s impossible to remove it, namely, the **Transform** component
    (or the RectTransform for GUI objects). This component keeps track of an object''s
    position, rotation, and scale. For example, if you create a blank, empty game
    object in the scene by going to **GameObject** | **Create Empty** from the application
    menu, as shown in the following screenshot, you would end up with a new game object
    in the scene, featuring only a Transform component. Thus, even a new and empty
    `GameObject` is not, strictly speaking, empty, but it''s as empty as a `GameObject`
    ever gets. The object still needs a Transform component to maintain its physical
    location in a scene.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多意义上，`GameObject`是场景中的基本单元或实体。它最自然地对应于我们日常所说的“事物”。实际上，你需要在游戏中实现的具体的上下文特定行为或事物类型并不重要，因为在所有情况下，你都需要`GameObjects`来实现它们。`GameObjects`不需要对玩家可见；它们可以是，并且通常是不可见的。声音、碰撞体和管理类是一些不可见的`GameObjects`的例子。另一方面，许多`GameObjects`将是可见的：网格、动画网格、精灵等等。然而，在所有情况下，无论是可见的还是不可见的，`GameObject`都是在场景中以相关组件的集合形式实例化的。**组件**本质上是从`MonoBehaviour`派生出的类，并且可以附加到场景中的`GameObject`上以改变其行为。每个`GameObject`至少有一个共同的最小组件，并且无法移除，即**变换**组件（或对于GUI对象而言是RectTransform）。这个组件负责跟踪对象的位置、旋转和缩放。例如，如果你通过从应用程序菜单中选择**GameObject**
    | **Create Empty**来在场景中创建一个空白、空的游戏对象，如图下所示，你将在场景中得到一个新的游戏对象，它只包含一个变换组件。因此，即使是新的空`GameObject`在严格意义上也不是空的，但它几乎是`GameObject`可能达到的最空状态。该对象仍然需要一个变换组件来保持其在场景中的物理位置。
- en: '![The GameObject](img/0655OT_03_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![The GameObject](img/0655OT_03_01.jpg)'
- en: All GameObjects feature a Transform component
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有GameObject都具备变换组件
- en: Of course, a `GameObject` can have many components, and the behavior of an object
    arises from the combination and interaction of its components. You can add more
    premade components to an object using the **Component** menu, and you can add
    your own custom components by dragging-and-dropping your scripts onto an object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个 `GameObject` 可以有多个组件，一个对象的行为是由其组件的组合和交互产生的。你可以使用 **组件** 菜单向对象添加更多预制的组件，也可以通过将你的脚本拖放到对象上来添加自己的自定义组件。
- en: '![The GameObject](img/0655OT_03_02.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![The GameObject](img/0655OT_03_02.jpg)'
- en: Components are attached to GameObjects
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 组件附加到 `GameObject` 上
- en: 'So, `GameObjects` are composed of components. At a higher level, scenes are
    composed of a collection of `GameObjects` inside a single world space. Furthermore,
    objects themselves exist in an important relationship with each other, as defined
    by the scene hierarchy. Objects can be the children of others, who are in turn
    their parents (`transform.parent`). This relationship has important implications
    for how objects move and transform. In short, values for an object''s Transform
    component will cascade downwards and be added to the transform of all its children.
    In this way, a child `GameObject` is always offset and transformed relative to
    its parent; the parent position is the origin of the child position. However,
    if an object has no parent, then it would be transformed away from the world origin
    at (0, 0, 0). The following screenshot shows the **Hierarchy** panel:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`GameObjects` 由组件组成。在更高层次上，场景由单个世界空间内的多个 `GameObjects` 集合组成。此外，对象之间存在着由场景层次结构定义的重要关系。对象可以是其他对象的子对象，而这些对象反过来又是它们的父对象（`transform.parent`）。这种关系对对象的移动和变换有重要影响。简而言之，对象的变换组件的值会向下级联并添加到所有子对象的变换中。通过这种方式，子
    `GameObject` 总是相对于其父对象进行偏移和变换；父对象的位置是子对象位置的起点。然而，如果一个对象没有父对象，那么它就会从世界原点（0, 0,
    0）进行变换。以下截图显示了 **层次结构** 面板：
- en: '![The GameObject](img/0655OT_03_03.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![The GameObject](img/0655OT_03_03.jpg)'
- en: GameObjects exist in a scene hierarchy that determines their transformations
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObjects` 存在于一个场景层次结构中，该结构决定了它们的变换'
- en: Component interactions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件交互
- en: We've seen the anatomy of a `GameObject` as a collection of components and nothing
    more. This raises logistical issues about how components should interact and communicate
    with each other. Each component is effectively implemented as a self-contained
    script file, separate from any other component, yet a component must often interact
    with others. Specifically, you'll often need to access variables and call functions
    on other components on the same `GameObject`, and you might even need to do this
    on every frame. This section explores such intercomponent communication.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `GameObject` 的解剖结构，它是一个组件的集合，没有更多。这引发了一些关于组件如何相互交互和通信的物流问题。每个组件实际上都是一个自包含的脚本文件，与其他组件分开，但组件通常需要与其他组件交互。具体来说，你经常需要访问同一
    `GameObject` 上其他组件的变量并调用函数，甚至可能需要在每一帧都这样做。本节探讨了这种组件间的通信。
- en: One way to call functions on other components is to use `SendMessage` and `BroadcastMessage`,
    as shown in [Chapter 1](ch01.html "Chapter 1. Unity C# Refresher"), *Unity C#
    Refresher*. These functions are type agnostic. Specifically, they're functions
    we might call anywhere in the script to invoke methods by names on *all* other
    components attached to the same object, regardless of their type. These functions
    don't care about the component type at all. This makes both `SendMessage` and
    `BroadcastMessage` convenient to use. However, the problem with them is twofold.
    First, they're an all or nothing affair; we might call a function by name on all
    components or on none at all. We can't pick and choose which component the message
    is dispatched to, because it's always dispatched to them all. Second, both methods
    (`SendMessage` and `BroadcastMessage`) rely internally on reflection, which can
    cause performance issues when used often, such as by calling these functions in
    `Update` events or, even worse, in `OnGUI` events. For these reasons, seek to
    use alternative methods wherever practically possible. Let's consider these in
    the following sections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他组件上调用函数的一种方法是通过使用 `SendMessage` 和 `BroadcastMessage`，如[第 1 章](ch01.html "第
    1 章. Unity C# 快速入门")*Unity C# 快速入门*中所示。这些函数是无类型的。具体来说，它们是我们可能在脚本中的任何地方调用的函数，用于通过名称在
    *所有* 附加到同一对象的组件上调用方法，无论它们的类型如何。这些函数根本不关心组件类型。这使得 `SendMessage` 和 `BroadcastMessage`
    都很方便使用。然而，它们的问题有两个方面。首先，它们是全有或全无的事情；我们可能对所有组件或根本不调用按名称的函数。我们不能挑选和选择消息被发送到的组件，因为它总是发送到所有组件。其次，这两种方法（`SendMessage`
    和 `BroadcastMessage`）在内部依赖于反射，这在使用频繁时可能会引起性能问题，例如在 `Update` 事件中调用这些函数，或者在更糟糕的情况下，在
    `OnGUI` 事件中。因此，在可能的情况下，寻求使用替代方法。让我们在以下章节中考虑这些方法。
- en: GetComponent
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetComponent
- en: 'If you need direct access to a specific and single component on an object and
    you know its data type, try using `GetComponent` as shown in the following code
    sample 3-1\. This function gives you access to the first component of a matching
    type attached to a `GameObject`. Once you get a reference to it, you can access
    the component like any regular object, setting and getting its public variables
    and invoking its methods:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要直接访问对象上的特定单个组件并且你知道其数据类型，尝试使用以下代码示例 3-1 中的 `GetComponent`。这个函数让你可以访问附加到
    `GameObject` 的匹配类型的第一个组件。一旦你获得了它的引用，你就可以像访问任何常规对象一样访问该组件，设置和获取其公共变量，并调用其方法：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are the comments on the code sample 3-1:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 3-1 的注释：
- en: '**Lines 07 and 13**: The variable `ThisTransform` is declared as private. This
    variable is assigned a reference to the Transform component attached to the `GameObject`,
    and it achieves this inside the `Start` event using the `GetComponent` function.
    In the case of accessing the Transform component specifically, we could also have
    used an inherited `transform` property, such as `ThisTransform= transform;`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 07 行和第 13 行**：变量 `ThisTransform` 被声明为私有。这个变量被分配了一个指向附加到 `GameObject` 的
    Transform 组件的引用，并且它是在 `Start` 事件内部使用 `GetComponent` 函数实现的。在特定访问 Transform 组件的情况下，我们也可以使用继承的
    `transform` 属性，例如 `ThisTransform = transform;`。'
- en: '**Line 20**: Here, the `ThisTransform` variable is used directly to set the
    `localPosition` of the `GameObject`. Again, for the Transform component specifically,
    we could also have used `transform.localPosition`. However, this approach internally
    invokes an extra function call, because the member `transform` is a C# property
    and not a standard variable. More on properties can be found in [Chapter 1](ch01.html
    "Chapter 1. Unity C# Refresher"), *Unity C# Refresher*. For this reason, using
    `GetComponent` inside a `Start` or `Awake` event to retrieve a component reference
    to a private class variable is typically one of the most efficient ways to access
    external components, especially if the component must be accessed regularly, such
    as inside an `Update` function.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 20 行**：在这里，`ThisTransform` 变量被直接用来设置 `GameObject` 的 `localPosition`。同样，对于
    Transform 组件来说，我们也可以使用 `transform.localPosition`。然而，这种方法在内部会调用额外的函数调用，因为成员 `transform`
    是一个 C# 属性，而不是一个标准变量。更多关于属性的信息可以在[第 1 章](ch01.html "第 1 章. Unity C# 快速入门")*Unity
    C# 快速入门*中找到。因此，在 `Start` 或 `Awake` 事件中使用 `GetComponent` 来检索私有类变量的组件引用通常是访问外部组件最有效的方法之一，特别是如果组件必须定期访问，例如在
    `Update` 函数中。'
- en: Note
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**localPosition versus position**'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**localPosition 与 position 的区别**'
- en: 'The Transform component exposes two main position members: `position` and `localPosition`.
    Setting either of these will change an object''s position in specific and distinct
    ways. The position member always defines an object''s position in world space
    as a measure from the world origin. Setting this variable in script, therefore,
    might not correspond to the numbers you actually see for the Transform component
    in the Object Inspector when the object is selected. If your object is a child
    of another object that''s not positioned to the world origin, for example, then
    Unity would offset the object''s local position away from its parent, by however
    much is necessary, to position it at the world space location that is specified.
    The `localPosition` member, in contrast, corresponds directly to the `position`
    value shown for the Transform component in the Object Inspector. Specifically,
    it specifies the position of an object as a measured offset away from its parent
    location or else from the world origin if the object has no parent. In the latter
    case, both the `position` and `localPosition` members will be identical.'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Transform 组件公开了两个主要的位置成员：`position` 和 `localPosition`。设置这两个中的任何一个都会以特定和独特的方式改变对象的位置。位置成员始终定义对象在全局空间中的位置，作为从世界原点测量的值。因此，在脚本中设置此变量可能不会对应于当对象被选中时在对象检查器中看到的
    Transform 组件的实际数字。例如，如果您的对象是另一个未定位到世界原点的对象的子对象，那么 Unity 会通过必要的任何方式偏移对象相对于父对象的位置，以便将其定位到指定的全局空间位置。相比之下，`localPosition`
    成员直接对应于在对象检查器中显示的 Transform 组件的 `position` 值。具体来说，它指定了对象的位置，作为从其父位置或（如果对象没有父对象）从世界原点的测量偏移量。在后一种情况下，`position`
    和 `localPosition` 成员将是相同的。
- en: More information on the `GetComponent` function can be found in the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html](http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html).
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于 `GetComponent` 函数的更多信息，可以在 Unity 在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html](http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)。
- en: You can also access the Unity documentation from the MonoDevelop **Help** menu,
    by navigating to **Help** | **Unity API Reference**.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以通过 MonoDevelop 的 **帮助** 菜单访问 Unity 文档，方法是导航到 **帮助** | **Unity API 参考**。
- en: Getting multiple components
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取多个组件
- en: 'Occasionally, you''ll want to retrieve multiple components in a list: sometimes,
    a list of all components and sometimes, a list matching only a specific type.
    You can get this using the `GetComponents` function. See the following code sample
    3-2\. As with the `GetComponent` function, it''s good practice to call `GetComponents`
    during one-off events such as `Start` and `Awake` as opposed to frequent events
    such as `Update`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望在一个列表中检索多个组件：有时是所有组件的列表，有时是仅匹配特定类型的组件的列表。您可以使用 `GetComponents` 函数来实现这一点。请参阅以下代码示例
    3-2。与 `GetComponent` 函数一样，在一次性事件（如 `Start` 和 `Awake`）期间调用 `GetComponents` 是一种良好的实践，而不是在频繁事件（如
    `Update`）期间调用：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More on Components**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于组件的更多内容**'
- en: Unity offers additional variations on the `GetComponent` and `GetComponents`
    functions that facilitate interobject communication and not just communication
    between components in the same object. These functions include `GetComponentsInChildren`
    to retrieve an accumulative list of all components in all children and also `GetComponentsInParent`
    to retrieve all components in an object's parent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了 `GetComponent` 和 `GetComponents` 函数的额外变体，这些变体有助于实现对象间的通信，而不仅仅是同一对象内组件之间的通信。这些函数包括
    `GetComponentsInChildren`，用于检索所有子对象中所有组件的累积列表，以及 `GetComponentsInParent`，用于检索对象父对象中的所有组件。
- en: More information on the `GetComponents` function can be found in the online
    Unity documentation at [http://docs.unity3d.com/ScriptReference/Component.GetComponents.html](http://docs.unity3d.com/ScriptReference/Component.GetComponents.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `GetComponents` 函数的更多信息，可以在 Unity 在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/Component.GetComponents.html](http://docs.unity3d.com/ScriptReference/Component.GetComponents.html)。
- en: Components and messages
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件和消息
- en: 'The `GetComponent` family of functions work well and should meet almost all
    your needs for intercomponent communication. They certainly perform better than
    either `SendMessage` or `BroadcastMessage` when used appropriately. Yet, there
    are situations where it''d be ideal if, given a `GameObject`, you could invoke
    a method with `SendMessage` on *only one* component as opposed to all, without
    having to know anything about the component type in advance. Now, you could achieve
    this behavior to some extent using delegates and interfaces (covered in the next
    chapter). However, here we''ll consider the `SendMessage` approach. One scenario
    where this would be especially useful is for the creation of extendable behaviors.
    For example, perhaps your game has many enemy types and you need to leave open
    the possibility of adding more, all of which could be implemented in different
    ways. Yet, despite their differences, all enemies will need to save their data
    to a persistent file when the game is saved. It''d then be useful for the enemy
    to handle an `OnSave` function, which will be implemented by a specific component.
    This is fine, but you want the `OnSave` function on that component alone to be
    called by the `SendMessage` system. You don''t want the method invoked for other
    components on the object, in case they too handle a function `OnSave` that you
    don''t want called inadvertently. In short, you can achieve this using the `Invoke`
    method. Consider the following code sample 3-3:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComponent` 函数族运行良好，应该能满足您几乎所有的组件间通信需求。当适当使用时，它们的确比 `SendMessage` 或 `BroadcastMessage`
    表现得更好。然而，在某些情况下，如果给定一个 `GameObject`，您能够仅对 `SendMessage` 上的一个组件而不是所有组件调用方法，而不需要事先知道组件类型，这将是非常理想的。现在，您可以通过使用代理和接口（下一章将介绍）在一定程度上实现这种行为。然而，在这里，我们将考虑
    `SendMessage` 方法。一个特别有用的场景是创建可扩展的行为。例如，也许您的游戏有许多敌人类型，您需要保留添加更多类型的可能性，所有这些类型都可以以不同的方式实现。尽管它们不同，但所有敌人都需要在游戏保存时将数据保存到持久文件中。那么，对于敌人来说，处理一个
    `OnSave` 函数将非常有用，该函数将由特定的组件实现。这是可以的，但您希望仅由该组件上的 `SendMessage` 系统调用 `OnSave` 函数。您不希望调用对象上其他组件的方法，以防它们也处理一个您不希望意外调用的
    `OnSave` 函数。简而言之，您可以使用 `Invoke` 方法实现这一点。考虑以下代码示例3-3：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the comments on the code sample 3-3:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例3-3的注释：
- en: '**Line 07**: This class features a public reference variable `Handler`. Using
    this field, you can drag-and-drop any component via the Object Inspector into
    the `Handler` slot. This represents the component to which a message will be dispatched.
    Notice that its class type is `MonoBehaviour` or any class derived from this.
    This means type agnosticism is achieved and we don''t need to know the object
    type in advance.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第07行**: 此类具有一个公共引用变量 `Handler`。使用此字段，您可以通过对象检查器将任何组件拖放到 `Handler` 槽中。这表示将要向其发送消息的组件。请注意，其类类型为
    `MonoBehaviour` 或任何从该类派生的类。这意味着实现了类型无关性，我们不需要事先知道对象类型。'
- en: '**Line 14**: The `Invoke` method of `MonoBehaviour` is called to run any method
    of matching name. The second floating point argument specifies the time in seconds,
    after which the function should be invoked. A time of 0 specifies immediate invoking.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第14行**: 调用 `MonoBehaviour` 的 `Invoke` 方法来运行任何具有匹配名称的方法。第二个浮点数参数指定了在多少秒后调用该函数。0秒表示立即调用。'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `Invoke` function can be found in the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html).
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于 `Invoke` 函数的更多信息可以在Unity在线文档中找到，链接为[http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html)。
- en: GameObjects and the world
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏对象和世界
- en: Another pivotal task in Unity involves searching for objects in the scene from
    script, especially if objects are instantiated at runtime. Tasks such as "get
    me the player object" and "get me all enemies in the scene" are important for
    many operations, from respawning enemies and power-ups to repositioning the player
    and checking collisions between objects. To retrieve references to specific `GameObjects`,
    Unity offers a set of functions associated with the `GameObject` class. These
    functions can be useful but expensive, so be sure to call them during one-off
    events, such as `Start` and `Awake`, wherever possible. Let's explore these further,
    in addition to other techniques and methods to work with found objects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，另一个关键任务是在脚本中搜索场景中的对象，尤其是如果对象在运行时实例化。例如，“获取玩家对象”和“获取场景中所有敌人”等任务对于许多操作都很重要，从复活敌人和增益到重新定位玩家和检查对象之间的碰撞。要检索特定
    `GameObjects` 的引用，Unity 提供了一组与 `GameObject` 类相关的函数。这些函数可能很有用但成本高昂，因此请确保在可能的情况下，在
    `Start` 和 `Awake` 等一次性事件中调用它们。让我们进一步探讨这些内容，以及与其他技术和方法一起使用找到的对象的其他技术。
- en: Finding GameObjects
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找游戏对象
- en: 'Finding an object in the scene can be achieved through either the `GameObject.Find`
    or `GameObject.FindObjectWithTag` function. Of these two, the latter should almost
    always be preferred for performance reasons. However, let''s consider `GameObject.Find`
    first. This function searches the scene for the first occurrence of an object
    with an exactly matching name (case-sensitive) and then returns that object. The
    name that''s searched should match the object name as it appears in the **Hierarchy**
    panel. Unfortunately, the function performs string comparisons to determine the
    match, so it''s a slow and cumbersome option. Besides, it''s only truly effective
    for objects guaranteed to have unique names, and many times, objects won''t have.
    However, that said, `GameObject.Find` is still highly useful when objects are
    appropriately named:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中查找对象可以通过 `GameObject.Find` 或 `GameObject.FindObjectWithTag` 函数实现。在这两个函数中，出于性能考虑，后者几乎总是首选。然而，让我们首先考虑
    `GameObject.Find`。此函数在场景中搜索与名称完全匹配的第一个对象（区分大小写），然后返回该对象。搜索的名称应与 **层次** 面板中显示的对象名称相匹配。不幸的是，该函数执行字符串比较以确定匹配，因此它是一个缓慢且繁琐的选项。此外，它仅对保证具有唯一名称的对象真正有效，而很多时候对象并没有。然而，话虽如此，`GameObject.Find`
    在对象名称适当的情况下仍然非常有用：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**GameObject Finding**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏对象查找**'
- en: If you notice the `GameObject`, you would realize that the `Find` function is
    static. This means that you don't need an instantiation of any specific `GameObject`
    to call the function. You can call it directly from any source file via `GameObject.Find`.
    The concept of static and global scope is considered later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到 `GameObject`，你就会意识到 `Find` 函数是静态的。这意味着你不需要任何特定 `GameObject` 的实例化就可以调用该函数。你可以通过
    `GameObject.Find` 直接从任何源文件中调用它。静态和全局作用域的概念将在本章的后面讨论。
- en: More information on the `GameObject.Find` function can be found in the online
    Unity documentation at [http://docs.unity3d.com/ScriptReference/GameObject.Find.html](http://docs.unity3d.com/ScriptReference/GameObject.Find.html).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `GameObject.Find` 函数的更多信息，可以在 Unity 在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/GameObject.Find.html](http://docs.unity3d.com/ScriptReference/GameObject.Find.html)。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`GameObject.Find` can be a slow function. For this reason, use it only inside
    one-fire events, such as `Awake` and `Start`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject.Find` 可能是一个较慢的函数。因此，仅在一触即发的事件中使用它，例如 `Awake` 和 `Start`。'
- en: 'A more effective search is by tag. Every object in the scene has a tag member
    that is assigned **Untagged** by default. This member is a unique identifier that
    can mark a single object or multiple objects bringing them together into a collection.
    Generally, to search for objects by tag, you''ll first need to explicitly assign
    an object with a tag. You can do this in script, using the `GameObject.tag` public
    member. However, you''ll use the Unity Editor more commonly. You can assign a
    tag to a selected object from the Unity Editor by clicking the **Tag** drop-down
    list in the Object Inspector and picking a tag. In addition, you can create new,
    custom tags by selecting the **Add Tag** option. Common tags include **Player**,
    **Enemy**, **Weapon**, **Bonus**, **Prop**, **Environment**, **Light**, **Sound**,
    and **GameController**, among others. Take a look at the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签进行搜索更有效。场景中的每个对象都有一个默认分配为 **Untagged** 的标签成员。这个成员是一个唯一标识符，可以标记单个对象或多个对象，将它们组合成一个集合。通常，为了通过标签搜索对象，你首先需要显式地给对象分配一个标签。你可以在脚本中使用
    `GameObject.tag` 公共成员来完成此操作。然而，你更常用 Unity 编辑器。你可以在 Unity 编辑器中通过点击对象检查器中的 **Tag**
    下拉列表并选择一个标签来为选定的对象分配一个标签。此外，你可以通过选择 **Add Tag** 选项来创建新的、自定义的标签。常见的标签包括 **Player**、**Enemy**、**Weapon**、**Bonus**、**Prop**、**Environment**、**Light**、**Sound**
    和 **GameController** 等。请查看以下截图：
- en: '![Finding GameObjects](img/0655OT_03_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![寻找 GameObjects](img/0655OT_03_04.jpg)'
- en: Assigning a tag to an object
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为对象分配标签
- en: 'After one or more objects are assigned a tag in the scene, you can effectively
    search for objects by tag in code. The `GameObject.FindGameObjectWithTag` function
    searches the scene for an object with a matching tag and returns the first occurrence.
    The `GameObject.FindObjectsWithTag` returns an array of all occurrences. See the
    following code sample 3-4 for an example. Note that although the `FindGameObjectsWithTag`
    function requires a string argument, Unity internally converts the string into
    a numerical form to increase the speed of tag comparisons:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中为一个或多个对象分配了标签之后，你可以在代码中有效地通过标签搜索对象。`GameObject.FindGameObjectWithTag` 函数在场景中搜索具有匹配标签的对象，并返回第一个匹配的对象。`GameObject.FindObjectsWithTag`
    返回所有匹配的对象数组。请参见以下代码示例 3-4 以获取示例。请注意，尽管 `FindGameObjectsWithTag` 函数需要一个字符串参数，但
    Unity 内部将字符串转换为数值形式，以提高标签比较的速度：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Sometimes, you'd like to assign multiple tags to a single object. Unfortunately,
    Unity doesn't support this behavior yet. However, you can work around the limitation
    by parenting empty game objects to your main object and assigning each of the
    children the tag you need. When searching for objects by tag, though, just remember
    to get a reference to the parent object, which is actually the object you need.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望给单个对象分配多个标签。不幸的是，Unity 目前还不支持这种行为。然而，你可以通过将空游戏对象作为你的主要对象的父对象，并给每个子对象分配所需的标签来绕过这个限制。但是，当通过标签搜索对象时，请记住获取父对象的引用，实际上这个对象才是你需要的那一个。
- en: Comparing objects
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象比较
- en: 'The `GameObject` searching functions are helpful when searching scene-wide
    for specific objects, but there are times when you''ll need to compare two objects
    that you''ve found already. Typically, you''ll want compare the names or tags
    of two objects. You can achieve a tag comparison using the `CompareTag` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在场景中搜索特定对象时，`GameObject` 搜索函数非常有用，但有时你需要比较你已经找到的两个对象。通常，你想要比较两个对象的名称或标签。你可以使用
    `CompareTag` 函数来实现标签比较：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In addition, you''ll sometimes want to compare two objects for equality to
    determine whether they''re the same object and not simply whether they share the
    same tag. This is especially important when coding decision-making behaviors.
    For example, in determining whether an enemy character should fight or flee from
    the player during combat, it''d be helpful to ascertain whether the enemy has
    supporting units nearby to help him. To answer this, you can find all enemies
    in the scene with a tag search, as we saw earlier. However, the results will also
    include the enemy who made the call originally and who is now deciding what to
    do, so we''ll want to exclude him from the results. Code sample 3-4 demonstrates
    how `GetInstanceID` can help us:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你有时可能想要比较两个对象以确定它们是否是同一个对象，而不仅仅是它们是否具有相同的标签。这在编码决策行为时尤为重要。例如，在确定敌人角色在战斗中应该与玩家战斗还是逃跑时，了解敌人附近是否有支援单位帮助他就很有帮助。为了回答这个问题，你可以使用标签搜索找到场景中的所有敌人，正如我们之前看到的。然而，结果也将包括最初发出调用并现在正在决定做什么的敌人，因此我们希望将其排除在结果之外。代码示例3-4演示了`GetInstanceID`如何帮助我们：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Getting the nearest object
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取最近的对象
- en: 'Given an array of `GameObjects`, perhaps returned from a search, how can you
    find the one nearest to you in the scene in terms of linear distance? The following
    code sample 3-5 demonstrates how you can find this object using the `Vector3.Distance`
    function to retrieve the shortest distance (in meters) between any two points
    in the scene:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`GameObjects`数组，可能是从搜索中返回的，你如何找到场景中离你最近的那个对象，从线性距离的角度来看？下面的代码示例3-5演示了如何使用`Vector3.Distance`函数来找到这个对象，该函数可以检索场景中任意两点之间的最短距离（以米为单位）：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finding any object of a specified type
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找指定类型的任何对象
- en: 'Sometimes, you just want a list of all the components of a specified type in
    the scene, regardless of which game objects they''re actually attached to; these
    components include all enemies, all collectible objects, all transform components,
    all colliders, and so on. Achieving this from script is simple but expensive,
    as shown in the following code sample 3-6\. Specifically, by calling the `Object.FindObjectsOfType`
    function, you can retrieve a complete list of all instances of a specified object
    in the scene, unless an object is deactivated. Due to the expense of this method,
    avoid calling it during frame-based events such as `Update`. Use the `Start` and
    `Awake` events, as well as infrequent functions instead:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能只想获取场景中指定类型的所有组件列表，而不考虑它们实际附加到哪个游戏对象上；这些组件包括所有敌人、所有可收集对象、所有变换组件、所有碰撞体等等。从脚本中实现这一点很简单，但成本较高，如下面的代码示例3-6所示。具体来说，通过调用`Object.FindObjectsOfType`函数，你可以检索场景中指定对象的所有实例的完整列表，除非对象被禁用。由于这种方法成本较高，应避免在基于帧的事件，如`Update`期间调用它。使用`Start`和`Awake`事件，以及不频繁调用的函数代替：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Clearing a path between GameObjects
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除GameObject之间的路径
- en: Given any two `GameObjects` in the scene, such as the **Player** and an **Enemy**
    character, it's common to test for a clear path between them, that is, to test
    whether there are any colliders intersecting an imaginary line drawn between the
    two objects. This can be helpful in line-of-sight systems, as we'll see later,
    but also more generally for object culling, to determine AI functionality and
    others.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 给定场景中的任意两个`GameObjects`，例如**玩家**和一个**敌人**角色，通常需要测试它们之间的清晰路径，即测试是否存在任何碰撞体与两个对象之间绘制的想象线相交。这有助于视线系统，正如我们稍后将要看到的，但也可以更普遍地用于对象剔除，以确定AI功能和其他功能。
- en: '![Clearing a path between GameObjects](img/0655OT_03_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![清除GameObject之间的路径](img/0655OT_03_05.jpg)'
- en: Testing for a clear path between two GameObjects using Physics.LineCast
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Physics.LineCast测试两个GameObject之间的清晰路径
- en: 'There are many ways to achieve this behavior. One way is to use the `Physics.LineCast`
    function, as shown in the following code sample 3-7:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种行为有许多方法。一种方法是使用`Physics.LineCast`函数，如下面的代码示例3-7所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the comments on the code sample 3-7:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例3-7的注释：
- en: '**Line 07**: This sample class should be attached to the `Player`; otherwise,
    another source object accepts a public member variable `Enemy` to whom a clear
    path should be tested.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第07行**：此示例类应附加到`Player`；否则，另一个源对象接受一个公共成员变量`Enemy`，该变量应测试是否有清晰路径。'
- en: '**Line 10**: The `LayerMask` variable specifies a bitmask, indicating which
    layers in the scene the collision test applies to. More information on bitmasks
    can be found in the online Unity documentation at [http://docs.unity3d.com/Manual/Layers.html](http://docs.unity3d.com/Manual/Layers.html).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10行**：`LayerMask`变量指定了一个位掩码，表示碰撞测试应用于场景中的哪些层。有关位掩码的更多信息可以在Unity在线文档中找到，链接为[http://docs.unity3d.com/Manual/Layers.html](http://docs.unity3d.com/Manual/Layers.html)。'
- en: '**Line 16**: The `Physics.Linecast` function is used to determine whether a
    clear and nonbroken path exists between two objects in the scene. Note that if
    the two objects themselves have colliders, such as `BoxColliders`, then these
    will be included in the collision detection; they will not be ignored. In other
    words, an object''s own collider can affect the results of any `LineCast` calls.
    For this reason, use the `LayerMask` variable to include or exclude specific layers.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第16行**：`Physics.Linecast`函数用于确定场景中两个对象之间是否存在清晰且不间断的路径。请注意，如果两个对象本身具有碰撞器，例如`BoxColliders`，则这些碰撞器将包含在碰撞检测中；它们不会被忽略。换句话说，一个对象的自身碰撞器可以影响任何`LineCast`调用的结果。因此，使用`LayerMask`变量来包含或排除特定的层。'
- en: Tip
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A `Physics.LineCast` project is included in the book's companion files in the
    `Chapter03/LineCast` folder.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 书籍配套文件中的`Chapter03/LineCast`文件夹包含了一个`Physics.LineCast`项目。
- en: Accessing object hierarchies
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问对象层次结构
- en: 'The **Hierarchy** panel in Unity offers a graphical illustration of the parent-child
    relationship that holds among all `GameObjects` in a scene. This relationship
    is important because child objects are contained by, and inherit, the transformations
    of their parents. However, being able to define and edit the hierarchical relationship
    in the editor is usually not enough. You''ll frequently need to parent one object
    to another in code and also cycle through all children of a specified object to
    process data or invoke functionality on them. Let''s first see how to parent objects.
    The following code sample 3-8 demonstrates how to attach one object X to another
    object Y as its child, through the Transform component:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的**层次结构**面板提供了一个场景中所有`GameObjects`之间父子关系的图形化展示。这种关系很重要，因为子对象包含并继承其父对象的变换。然而，通常在编辑器中定义和编辑层次关系是不够的。你经常需要在代码中将一个对象作为父对象附加到另一个对象上，并遍历指定对象的全部子对象以处理数据或对其调用功能。让我们首先看看如何将对象设置为父对象。以下代码示例3-8展示了如何通过变换组件将一个对象X附加到另一个对象Y作为其子对象：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s see how to cycle through all the child objects attached to a parent.
    Again, this is achieved through the Transform component, as shown in the following
    code sample 3-9:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何遍历附加到父对象的所有子对象。同样，这也是通过变换组件实现的，如下面的代码示例3-9所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The world, time, and updates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界、时间和更新
- en: A Unity scene represents a collection of finite `GameObjects` inside the same
    3D space and that also share the same timeframe. Every game needs to establish
    a unified concept of time to achieve synchronized animation and change, because
    animation means change over time. In Unity, the `Time` class is available for
    reading and understanding time and its passing in script. Working with this class
    is therefore a critical skill for the creation of predictable and consistent motion
    in your games. More on this shortly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Unity场景表示在相同3D空间内的一组有限的`GameObjects`，并且它们也共享相同的时间框架。每个游戏都需要建立一个统一的时间概念，以实现同步的动画和变化，因为动画意味着随时间的变化。在Unity中，`Time`类可用于在脚本中读取和理解时间及其流逝。因此，使用这个类是创建可预测和一致运动的关键技能。关于这一点，我们稍后会详细讨论。
- en: 'Every game has a frame rate, which is defined in **frames per second** (**FPS**).
    This rate is viewable from the **Stats** panel in the **Game** tab. The FPS tells
    you how many times in 1 second Unity is able to loop or iterate through your game
    code to draw a new render from the cameras to the screen. Each iteration is called
    a **frame**. The frame rate varies dramatically over time and across different
    computers. It''s influenced by the power of your computer, other processes that
    might be running, and by how much content it needs to render in the current frame,
    among other factors. This means you can never rely on FPS being consistent over
    time or the same across different computers; there''ll often be a different number
    of FPS. Have a look at the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![The world, time, and updates](img/0655OT_03_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: FPS is important for the creation of time-based behavior and animations
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'To approximate the concept of a frame, Unity offers three class events that
    every `MonoBehaviour` class can implement to perform functionality that must continually
    update or change over time. These events have already been seen, but now, we''ll
    consider them in more depth, specifically `Update`, `FixedUpdate` and `LateUpdate`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`Update`: The `Update` event is called *once* per frame for every active component
    on every active `GameObject` in the scene. If an object is deactivated by the
    `MonoBehaviour.SetActive` method, then `Update` events will not be called for
    that object until it is activated. In short, the `Update` event most accurately
    represents the concept of a frame in Unity, so it''s useful for performing repetitive
    behaviors or functionality that must be updated and monitored over time, such
    as player input events, keyboard presses, and mouse clicks. Note that the order
    in which `Update` events are invoked across all components for each frame is not
    guaranteed; that is, you cannot be sure whether the `Update` function on object
    X will be called before that on object Y during any one frame.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FixedUpdate`: Like `Update`, this event is typically called multiple times
    per frame. However, its calling pattern is regular and normalized, with fixed
    time intervals between each call. The most common use of `FixedUpdate` is to work
    with Unity physics. If you need to update the velocity or properties of a Rigidbody
    component over time, then `FixedUpdate` rather than `Update` would be the place
    to do it.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LateUpdate`: This is called on each frame, like `Update`. However, `LateUpdate`
    is always called after `Update` and `FixedUpdate`. This means that when `LateUpdate`
    is called, you can be sure that `Update` and `FixedUpdate` have already been called
    for every object on the current frame. This makes `LateUpdate` a useful place
    to update camera movement, especially third-person cameras, ensuring that the
    camera always follows objects at their latest positions on the current frame.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The details of `Update`, `FixedUpdate` and `LateUpdate`, in combination with
    the concepts of time and FPS, have significant implications on how you should
    or should not code your games when creating motion over time. Specifically, two
    main guidelines emerge, and these are considered over the next two subsections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update`、`FixedUpdate`和`LateUpdate`的细节，结合时间和FPS的概念，对你在创建运动时应该如何或不应如何编写游戏代码有重大影响。具体来说，出现了两条主要准则，这些准则将在接下来的两个小节中讨论。'
- en: 'Rule #1 – frames are precious'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则#1 – 帧是宝贵的
- en: Frames should occur many times per second; if they don't, your game will look
    laggy and broken. On each frame, an `Update` event is called once for every active
    `MonoBehaviour` in the scene. This means the computational complexity (and performance)
    of your scenes on each frame depends, in large measure, on what you do inside
    `Update` events. More functionality demands more processing time and workload,
    either for the CPU or GPU. For large scenes with many objects and components,
    it would be easy then for things to get out of hand if you don't reduce the workload
    inside `Update` functions by careful code planning. It's important, therefore,
    to think of `Update` events or any regularly called frame-based events as precious.
    In short, you should only put code inside them when you really need to, such as
    to read player input or observe cursor movement. It's helpful to start thinking
    of event-driven programming, as this can help you seriously reduce the workload
    inserted inside `Update` functions. The next chapter considers event-driven programming
    and event systems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 帧应该每秒发生多次；如果不这样，你的游戏看起来会卡顿且不完整。在每一帧，都会为场景中的每个活动`MonoBehaviour`调用一次`Update`事件。这意味着每一帧场景的计算复杂度（和性能）在很大程度上取决于你在`Update`事件内部做了什么。更多的功能需求意味着更多的处理时间和工作量，无论是CPU还是GPU。对于包含许多对象和组件的大场景，如果不通过仔细的代码规划来减少`Update`函数中的工作量，事情很容易失控。因此，将`Update`事件或任何定期调用的基于帧的事件视为宝贵的是非常重要的。简而言之，你应该只在真正需要时在它们内部放置代码，例如读取玩家输入或观察光标移动。将事件驱动编程作为思考起点是有帮助的，因为这可以帮助你严重减少插入到`Update`函数中的工作量。下一章将考虑事件驱动编程和事件系统。
- en: 'Rule #2 – motion must be relative to time'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则#2 – 运动必须相对于时间
- en: 'As you cannot guarantee the frequency of frames (frame rate differs over time
    and across computers), then you need to code motion and change very carefully
    to achieve a consistent experience for the gamer. Consider the simple case of
    moving a cube object in the scene smoothly over time. One way (a bad way) to create
    motion will be as shown in the following code sample 3-10:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你无法保证帧的频率（帧率随时间和计算机而变化），因此你需要非常小心地编码运动和变化，以实现为玩家提供一致的游戏体验。考虑这样一个简单的情况：随着时间的推移，在场景中平滑地移动一个立方体对象。创建运动的一种方法（一种不好的方法）将如下所示，在以下代码示例3-10中：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is effective insofar as it will move the attached object by the variable
    `AmountToMove` on each frame. The problem is that it's frame-rate dependent. Now,
    because frames are inconsistent over time and across computers, each user will
    ultimately receive a different experience; specifically, they'll see the cube
    moving at different speeds. This is bad because we simply cannot predict how the
    game will run for any specific user. To fix this, we need to map motion to time
    as opposed to frames. Frames are variable, but time is constant; one second is
    exactly that. To achieve this, we can use the `deltaTime` variable, which is part
    of the `Time` class. See the following code sample 3-11\. This is an amended version
    of sample 3-10.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在将附加对象通过变量`AmountToMove`在每一帧移动方面是有效的。问题是它是依赖于帧率的。现在，由于帧在时间和计算机之间不一致，每个用户最终都会收到不同的体验；具体来说，他们会看到立方体以不同的速度移动。这是不好的，因为我们根本无法预测游戏对任何特定用户将如何运行。为了解决这个问题，我们需要将运动映射到时间而不是帧上。帧是可变的，但时间是恒定的；一秒就是那样。为了实现这一点，我们可以使用`deltaTime`变量，它是`Time`类的一部分。请参见以下代码示例3-11。这是示例3-10的修改版。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `deltaTime` variable is a floating-point value and always expresses how
    much time, in seconds, has elapsed since the previous `Update` function was called.
    A value of 0.5, for example, means half a second has elapsed since the previous
    frame and so on. This is useful because `deltaTime` can act as a multiplier. By
    multiplying a speed variable by `deltaTime` on each frame, we can know how far
    an object should move because *distance = speed x time*. Thus, `deltaTime` gives
    us frame-rate independence for object motion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`deltaTime`变量是一个浮点值，总是表示自上次调用`Update`函数以来经过的时间（以秒为单位）。例如，值为0.5表示自上次帧以来已经过去了半秒，依此类推。这很有用，因为`deltaTime`可以作为乘数。通过在每一帧将速度变量乘以`deltaTime`，我们可以知道对象应该移动多远，因为*距离
    = 速度 x 时间*。因此，`deltaTime`为我们提供了对象运动的帧率独立性。'
- en: Immortal objects
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不朽的对象
- en: 'By default, Unity regards every object as existing within the self-enclosed
    time and space of a scene. The difference between scenes is like the difference
    between separate universes. Consequently, objects don''t survive outside the scene
    to which they belong; this means that they die whenever the active scene changes.
    This is typically how you want objects to behave, because scenes are usually very
    different and separate from one another. However, even so, there will be objects
    that you don''t want destroyed. There will be objects that you need *carried over*
    between scenes, such as the **Player** character, a high-score system, or a `GameManager`
    class. These are normally high-order objects whose existence shouldn''t be limited
    to specific scenes; they should rather span or arc across multiple scenes. You
    can create object persistence easily using the `DontDestroyOnLoad` function, but
    it has important consequences worth considering. Take a look at the following
    code sample 3-12:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity将每个对象视为存在于场景的自封闭时间和空间中。场景之间的差异就像不同宇宙之间的差异。因此，对象不会在它们所属的场景之外存活；这意味着每当活动场景改变时，它们就会死亡。这通常是您希望对象表现的方式，因为场景通常非常不同且相互独立。然而，即便如此，仍然会有一些您不希望销毁的对象。会有一些您需要在场景之间传递的对象，例如**玩家**角色、高分系统或`GameManager`类。这些通常是高级对象，它们的生存不应局限于特定的场景；它们应该跨越或弧形跨越多个场景。您可以使用`DontDestroyOnLoad`函数轻松创建对象持久性，但它有重要的后果值得考虑。请看以下代码示例3-12：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Object persistence between scenes is important, but *travelling objects* take
    their baggage with them as they move between scenes. This means any and all child
    objects will survive with the persistent object as well as any assets or resources
    it uses, such as meshes, textures, sounds, and others. This is not a problem per
    se, but it is important to be aware of it. For this reason, many persistent objects
    are created light, that is, as empty game objects with no children, featuring
    only the basic component makeup they need to work properly. This ensures that
    only the essential, critical data survives between scene changes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 场景之间的对象持久性很重要，但*移动的对象*在场景之间移动时会带着它们的行李。这意味着任何所有子对象都将与持久对象一起存活，以及它使用的任何资产或资源，例如网格、纹理、声音等。这本身并不是问题，但重要的是要意识到这一点。因此，许多持久对象都是轻量级创建的，也就是说，作为没有子对象的空游戏对象，只包含它们正常工作所需的基本组件组成。这确保了只有必要的关键数据在场景变化之间存活。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Scene Changing**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景切换**'
- en: To change the active scene in Unity, use the `Application.LoadLevel` function.
    There are variations on this, including `LoadLevelAsync`, `LoadLevelAdditive`,
    and `LoadLevelAdditiveAsync`. More information on the level-loading functions
    can be found online at [http://docs.unity3d.com/ScriptReference/Application.html](http://docs.unity3d.com/ScriptReference/Application.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中更改活动场景，请使用`Application.LoadLevel`函数。这个函数有多种变体，包括`LoadLevelAsync`、`LoadLevelAdditive`和`LoadLevelAdditiveAsync`。有关级别加载函数的更多信息，可以在[http://docs.unity3d.com/ScriptReference/Application.html](http://docs.unity3d.com/ScriptReference/Application.html)在线找到。
- en: 'As we saw earlier, the `DontDestroyOnLoad` function is called on an existing
    object in the active scene and prevents that object from being destroyed on future
    scene changes. From this, however, an issue sometimes arises concerning object
    duplication. Specifically, if you later reload or return to the original scene
    in which the persistent object first existed, then a persistent duplicate of the
    object is made, namely, the persistent original that came with you from the previous
    scene and a newer instantiation of the object created for the newly entered instance
    of the scene. This problem is, of course, magnified for each occasion you re-enter
    the scene, as each time a new duplicate will be made. Such duplication is usually
    not what you want. You typically want only one instance of the object to exist
    at any one time: one player, one game manager, or one high-score board. To achieve
    this, you''ll need to create a singleton object, as explained in the next section.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，`DontDestroyOnLoad`函数在活动场景中的现有对象上被调用，防止该对象在未来的场景变化中被销毁。然而，由此有时会出现关于对象复制的問題。具体来说，如果你后来重新加载或返回到持久对象最初存在的原始场景，则会创建该对象的持久副本，即从上一个场景带过来的持久原始对象和为场景的新实例创建的新对象实例。当然，每次重新进入场景都会放大这个问题，因为每次都会创建一个新的副本。这种复制通常不是你想要的。你通常希望在任何时候只有一个对象实例存在：一个玩家、一个游戏管理器或一个高分排行榜。为了实现这一点，你需要创建一个单例对象，正如下一节所解释的。
- en: Understanding singleton objects and statics
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单例对象和静态
- en: Some classes are fundamentally different from others in the way they should
    be instantiated. Most classes define a template for a collection of properties
    and behaviors that might be instantiated many times in a scene as `GameObjects`.
    An enemy class can be used to instantiate many enemy objects, a power-up class
    for many power-up objects, and so on. However, some classes such as `GameManager`,
    `HighScoreManager`, `AudioManager`, or `SaveGameManager` are intended to exist
    as a lone entity, one that consolidates a unified set of behaviors. In short,
    there should only ever be one instance of the class at any one time and never
    more than one. To have more than one instance would either be nonsensical or damage
    the object's authority and usefulness in some way. These kinds of objects are
    known as singletons. Singletons are often persistent objects that survive across
    scenes, though they need not be. The only essential ingredient in a singleton
    (which makes it what it is) is that there cannot be more than one instance of
    the class in memory at any one time. Let's now create a singleton object in the
    context of making a sample `GameManager` class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类在实例化方式上与其他类根本不同。大多数类定义了一个属性和行为集合的模板，这些属性和行为可能在场景中以`GameObjects`的形式实例化多次。敌对类可以用来实例化许多敌对对象，提升类用于许多提升对象，等等。然而，一些类如`GameManager`、`HighScoreManager`、`AudioManager`或`SaveGameManager`旨在作为一个独立实体存在，它整合了一套统一的行为。简而言之，在任何时候，该类只应有一个实例，而不应该有多个实例。拥有多个实例要么没有意义，要么以某种方式损害对象的权威和实用性。这类对象被称为单例。单例通常是跨场景持久存在的对象，尽管它们不必如此。单例（使其成为单例）的唯一必要成分是，在任何时候内存中不能有该类的多个实例。现在，让我们在创建示例`GameManager`类的上下文中创建一个单例对象。
- en: 'Practically, every game has a `GameManager` or `GameController` class; and
    these are almost always singleton objects that persist. The `GameManager` is essentially
    responsible for all high-level functionality in a game. It must determine whether
    a game is paused, whether the win condition has been satisfied, and have a reliable
    way of knowing what''s happening in the game at any one time, among others. Consider
    the sample beginnings of a `GameManager` in the following code sample 3-13:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个游戏都有一个`GameManager`或`GameController`类；并且这些几乎总是持久存在的单例对象。`GameManager`基本上负责游戏中的所有高级功能。它必须确定游戏是否已暂停，是否满足胜利条件，以及有可靠的方式在任何时候了解游戏中的情况，等等。以下是对代码示例3-13中`GameManager`示例的初步了解：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This object will persist across scenes, but how can it (or any class like it)
    become a singleton object? The following code sample 3-14 demonstrates how:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象将在场景之间持续存在，但如何使其（或任何类似类）成为一个单例对象呢？以下代码示例3-14演示了如何实现：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the comments on the code sample 3-14:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例3-14的注释：
- en: '**Lines 10-20**: A private member `instance` is added to the `Manager` class,
    which is declared as `static`. This means the variable is shared across all instances
    of the class if there are multiple instances, as opposed to being a variable whose
    value is specific to each instance. This allows each new instance, when created,
    to determine whether there is any existing instance of the class in memory. This
    variable is made publically accessible too via the `Instance` property, which
    only has a `get` member to make it read-only.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10-20行**：在`Manager`类中添加了一个私有成员`instance`，该成员被声明为`static`。这意味着如果存在多个实例，变量将在所有类的实例之间共享，而不是每个实例都有其特定值的变量。这允许每个新实例在创建时确定内存中是否存在该类的现有实例。这个变量也通过`Instance`属性公开访问，该属性只有一个`get`成员，使其为只读。'
- en: '**Lines 36-43**: Here, in the `Awake` event (called at object creation), the
    instance variable is checked to see whether any valid instance of the class exists
    in the current scene already. If it does, then the current object is deleted,
    because only one instance of this class is allowed and already exists. This means
    the `GameManager` will persist across scene changes, and there will always be
    only one original instance of the object in the scene.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第36-43行**：在这里，在对象创建时调用的`Awake`事件中，检查实例变量以查看当前场景中是否已经存在该类的有效实例。如果存在，则当前对象将被删除，因为只允许一个此类实例存在，并且已经存在。这意味着`GameManager`将跨场景持续存在，场景中始终只有一个原始对象实例。'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Awake versus Start**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Awake与Start的区别**'
- en: 'The `GameManager` class uses the `Awake` function, as opposed to `Start`, in
    code sample 3-12\. The difference between `Start` and `Awake` is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例3-12中，`GameManager`类使用的是`Awake`函数，而不是`Start`。`Start`和`Awake`之间的区别如下：
- en: '`Awake` is always called before `Start`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake`总是在`Start`之前被调用。'
- en: '`Awake` is always called at object creation. `Start` is called on the first
    frame in which the `GameObject` becomes active. If a `GameObject` starts the scene
    deactivated, then `Start` will not be called until the object is activated. For
    objects that are activated by default, `Start` is called at the beginning of the
    scene, after the `Awake` event.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake`总是在对象创建时被调用。`Start`在`GameObject`变为活动状态的第一个帧上被调用。如果一个`GameObject`在场景开始时未激活，则`Start`将不会在对象激活之前被调用。对于默认激活的对象，`Start`在场景开始时被调用，在`Awake`事件之后。'
- en: If you need to cache component references into local variables of a class, such
    as the Transform component in `ThisTransform`, then use the `Awake` event rather
    than `Start`. During the `Start` event, the assumption should be that all local
    references to objects are already valid.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将组件引用缓存到类的局部变量中，例如`ThisTransform`中的Transform组件，那么请使用`Awake`事件而不是`Start`。在`Start`事件期间，应该假设所有对象的局部引用都已经有效。
- en: 'The great benefit of having a global, static `Instance` property for `GameManager`
    is that it becomes instantly and directly accessible to any other script file,
    without the need for any local variables or object references. This means every
    class has instant access to all `GameManager` properties and can call upon high-order
    game functionality. For example, to set the game score variable on the `GameManager`
    from a different class, the following code sample 3-15 can be used:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为`GameManager`拥有一个全局静态的`Instance`属性带来的巨大好处是，它能够立即且直接地被任何其他脚本文件访问，无需任何局部变量或对象引用。这意味着每个类都可以立即访问所有`GameManager`属性，并可以调用高级游戏功能。例如，要从不同的类设置`GameManager`上的游戏分数变量，可以使用以下代码示例3-15：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on singleton objects can be found online at [http://unitypatterns.com/singletons/](http://unitypatterns.com/singletons/).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于单例对象的信息可以在网上找到，链接为[http://unitypatterns.com/singletons/](http://unitypatterns.com/singletons/)。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter considered `GameObjects`, scenes, and components, as well as their
    general usage throughout scenes. These issues might superficially seem simple,
    but understanding their usage and being able to employ them to manage objects
    is a powerful skill that's required in almost all Unity game development projects.
    Specifically, we've seen the `GameObject`, a collection of components that interact
    to produce a unified behavior. The Transform component is especially important.
    We also looked at scenes. A scene is a single time and space inside which `GameObjects`
    exist. Typically, a scene is a self-enclosed entity that prevents any objects
    from existing outside it. Further, every scene works through a concept of time
    that makes change and animation possible. Time can be measured through `deltaTime`,
    which acts like a multiplier and allows us to achieve frame-rate-independent motion.
    Finally, we explored the singleton design pattern, which uses static members to
    define classes that, in practice, can only have one instantiation active in memory
    at any one time. In the next chapter, we'll move on to event-driven programming.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了`GameObject`、场景和组件，以及它们在场景中的通用用法。这些问题表面上可能看起来很简单，但理解它们的用法并能够使用它们来管理对象是一项强大的技能，这在几乎所有的Unity游戏开发项目中都是必需的。具体来说，我们看到了`GameObject`，它是一组相互作用的组件集合，以产生统一的行为。变换组件尤为重要。我们还探讨了场景。场景是在其中`GameObject`存在的单一时间和空间。通常，场景是一个自我封闭的实体，防止任何对象存在于其外部。此外，每个场景都通过一个时间概念来工作，这使得变化和动画成为可能。时间可以通过`deltaTime`来衡量，它像一个乘数，使我们能够实现帧率无关的运动。最后，我们探讨了单例设计模式，它使用静态成员来定义类，在实践中，这些类在任何时候都只能有一个活跃的实例存在于内存中。在下一章中，我们将继续探讨事件驱动编程。
