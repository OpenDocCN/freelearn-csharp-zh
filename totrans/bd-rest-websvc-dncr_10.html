<html><head></head><body>
        

                            
                    <h1 class="header-title">Building a Web Client (Consuming Web Services)</h1>
                
            
            
                
<p>So far in this book, we have created RESTful services so that we can call or consume these services either within or from outside the project. In this chapter, we will discuss some use cases of these services, as well as the techniques and approaches for consuming RESTful web services.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Consuming RESTful web services</li>
<li>Building a REST web client</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Consuming RESTful web services</h1>
                
            
            
                
<p>Until now, we have created RESTful services and discussed server-side code with the help of code examples. We have consumed these services using external third-party tools, such as Postman and Advanced RESTClient. We have also consumed these services using fake objects and during unit testing. While helpful, these examples of consumption have not shown the true strength of RESTful services, as they have either tested their functionality or verified its output.</p>
<p>There may be situations where you will need to consume or use these services within another application similar to a controller, or even your own application itself. These applications can be any of the following:</p>
<ul>
<li>Console based</li>
<li>Web based</li>
<li>Mobile or any other device based</li>
</ul>
<p>Let's take a look at one of the applications we've already discussed: let's say you need some mechanism to implement or consume an external API (in this case, PayPal) while integrating an online payment system. In this case, the external tools we've already covered, such as Postman and Advanced RESTClient can’t help; to meet your needs, you require a REST client.</p>
<p>The following diagram illustrates how services can be consumed using a REST client with the help of an HTTP client. In the following diagram, the REST client is interacting (request, response) with both external and network services that have been developed in ASP.NET Core or are located on either the same or a different server.</p>
<div><img src="img/a80a5a5f-efbd-4d42-a85e-16b910703271.png" style="width:22.17em;height:30.50em;"/></div>
<p><strong>Web</strong>, <strong>Console</strong>, <strong>Mobile</strong>, and so on, are the clients consuming these services with the help of the REST client.</p>
<p>We will now discuss how to build a REST client that we can use to consume other RESTful web services (that is, APIs) in our application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a REST web client</h1>
                
            
            
                
<p>RESTful services may or may not be a part of a web application. A web application may call or consume external APIs or services from the same application. The program that enables the interaction or communication (request, response) between the services and the application consuming those services is called a <strong>client</strong>.</p>
<div><p>A client helps applications to communicate (Request, Response) with APIs.</p>
</div>
<p>In this section, we will create a web client. A web client is an application or program written in ASP.NET Core.</p>
<p>Before we build a test web client, we need to discuss what we have to call.</p>
<p>Continuing our example of the FlixOne BookStore, the following table lists the produces and services that we will call and consume:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>API resource</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET /api/product</kbd></p>
</td>
<td>
<p>Gets a list of products.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET /api/product{id}</kbd></p>
</td>
<td>
<p>Gets a product.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT /api/product{id}</kbd></p>
</td>
<td>
<p>Updates an existing product.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE /api/product{id}</kbd></p>
</td>
<td>
<p>Deletes an existing product.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST /api/product</kbd></p>
</td>
<td>
<p>Adds a new product.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Our FlixOne product service is designed for the following tasks:</p>
<ul>
<li>Adding a new product</li>
<li>Updating an existing product</li>
<li>Deleting an existing product</li>
<li>Retrieving a product</li>
</ul>
<p>We have already ensured Swagger support for our product APIs (please refer to the previous chapters for more information), so let's get going. To start with this project, follow these steps:</p>
<ol>
<li>First, run Visual Studio 2017</li>
<li>Select File | Open</li>
<li>Select the project FlixOne.BookStore.ProductService</li>
<li>Run the project by pressing <em>F5</em> or clicking directly from the menu</li>
<li>Enter the following URL: <kbd>http://localhost:10065/swagger/</kbd></li>
</ol>
<p>You should now see Swagger documentation for your Product APIs, as shown in the following screenshot:</p>
<div><img src="img/4202f70f-415a-491c-affe-7cf9831b0210.png" style="width:36.42em;height:30.25em;"/></div>
<p>Product APIs documentation</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cooking the web client</h1>
                
            
            
                
<p>We have already discussed what APIs need to consume and which resource returns what, so now it's time to cook our web client so we can consume and call our product APIs. To do so, follow these steps:</p>
<ol>
<li>To create an entirely new solution for our new project, go to File | New | Project (or press <em>Ctrl</em> + <em>Shift</em> + <em>N</em>) as shown in the following screenshot.</li>
</ol>
<div><img src="img/7f232c75-ae75-41b4-84b9-5ff7b5735f92.png" style="width:45.92em;height:30.83em;"/></div>
<ol start="2">
<li>From New Project, select ASP.NET Core Web Application.</li>
<li>Name the project <kbd>FlixOne.BookStore.WebClient</kbd> and then click OK as shown in the following screenshot:</li>
</ol>
<div><img src="img/4dd65c06-4f52-43fd-9c75-68a654d22aae.png" style="width:51.67em;height:31.50em;"/></div>
<ol start="4">
<li>From the ASP.NET Core template window, select Web Application and click OK as shown in the following screenshot:</li>
</ol>
<div><img src="img/b8014e2a-003d-4805-8349-e71cb4fc5e87.png" style="width:44.75em;height:29.00em;"/></div>
<ol start="5">
<li>Now run the project Debug | Start Debugging or hit the <em>F5</em> key.</li>
<li>You should now see a default website template.</li>
<li>We will now create a web client using <strong>RestSharp</strong>. We need to add the support of RestSharp to get the facility to make a call over the HTTP protocol for our API resources.</li>
</ol>
<div><p>RestSharp is a lightweight HTTP client library. You can make changes to suit your needs, as it is an open source library. You can find the complete repository at <a href="https://github.com/restsharp/RestSharp">https://github.com/restsharp/RestSharp</a></p>
</div>
<ol start="8">
<li>Add a NuGet package using Open Package Manager (right-click on Solution from Solution Explorer), as shown in the following screenshot:</li>
</ol>
<div><img src="img/c88554eb-4b19-480f-8597-e0b8d2645b0c.png" style="width:37.83em;height:36.67em;"/></div>
<ol start="9">
<li>Search for RestSharp and check the checkbox saying include prerelease, and then click Install as shown in the following screenshot:</li>
</ol>
<div><img src="img/64ac9dd2-1ba4-409d-a422-2104d598a3f1.png"/></div>
<p>Selecting the RestSharp NuGet package</p>
<ol start="10">
<li>The required packages will now be installed, as shown in the following screenshot:</li>
</ol>
<div><img src="img/65a1722d-161f-4ab7-a8d5-0e24d31e113d.png"/></div>
<p>Installing the RestSharp package</p>
<p>Before going forward, let's first make sure that our product APIs are working correctly. Run the product API project, open Swagger, and hit a <kbd>GET /api/product/productlist</kbd> resource as follows:</p>
<div><img src="img/d2bd41c1-e23c-40be-805d-0fefb43d419d.png" style="width:37.17em;height:3.08em;"/></div>
<p>After executing the previous resource, you should see a complete list of products, as shown in the following screenshot:</p>
<div><img src="img/dbc16f11-5f14-4aa5-bbf3-a41d6d6c9cc6.png" style="width:51.08em;height:33.42em;"/></div>
<p>Try all available resources to make sure that your product APIs are working correctly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing code</h1>
                
            
            
                
<p>So far, we have cooked the things required for writing code for our REST web client; in this section, we will be writing actual code:</p>
<ol>
<li>Add a simple code to call or consume your product APIs.</li>
</ol>
<div><p>If you created a new project in the same solution (refer to <em>step 1</em> of the section <em>Cooking the web client</em>), please make sure that the project Product API is running before you start your web client project.</p>
</div>
<ol start="2">
<li>Add a new class (<em>Ctrl</em> + <em>Shift</em> + <em>C</em>) in the <kbd>Client</kbd> folder and name it <kbd>RestSharpWebClient</kbd>.</li>
</ol>
<div><img src="img/2981769f-110c-479f-a737-834a493a847b.png" style="width:20.08em;height:18.50em;"/></div>
<ol start="3">
<li>Now open the <kbd>RestSharpWebClient</kbd> class and add the following code:</li>
</ol>
<pre style="padding-left: 60px">private readonly RestClient _client = new RestClient("http://localhost:10065/api/");</pre>
<p style="padding-left: 60px">The preceding code initializes RestClient of RestSharp and accepts the base URL as a string or a URI.</p>
<div><p>URI stands for Uniform Resource Identifier and is a representation of a string used to identify resources.</p>
</div>
<p>You may come across a scenario where there are multiple environments; in this case, you should store a URI where you point it as per your environment. For example, you can have the URI <kbd>http://devserver:10065/api/</kbd> for your development environment or the URI <kbd>http://testenv:10068/api/</kbd> for your QA environment. You should store these keys in the <kbd>config</kbd> file or somewhere similar so that the values are easily accessible. We recommend using <kbd>new RestClient(somevariableforURI);</kbd>.</p>
<p>In our application, product APIs are running on localhost and the listening port <kbd>10065</kbd>. This may be different in your case.</p>
<p>Let's discuss the following code snippet to call or consume the <kbd>GET /api/product<br/>
/productlist</kbd> resource and populate the complete product list, as follows:</p>
<pre>public List&lt;ProductViewModel&gt; GetProducts()<br/>{<br/>  var request = new RestRequest("product/productlist", Method.GET);<br/>  var response = _client.Execute&lt;List&lt;ProductViewModel&gt;&gt;(request);<br/>  return response.Data ?? new List&lt;ProductViewModel&gt; {new<br/>  ProductViewModel()};<br/>}</pre>
<p>Here, we are making a <kbd>GET</kbd> request using <kbd>RestRequest</kbd>, where we passed a resource and method.</p>
<p>To get a particular product using <kbd>productid</kbd>, enter the following code:</p>
<pre>public ProductViewModel GetProductDetails(string productId)<br/>{<br/>  var request = new RestRequest("product/{productid}", Method.GET);<br/>  request.AddParameter("productid", productId);<br/>  var response = _client.Execute&lt;ProductViewModel&gt;(request);<br/>  return response.Data ?? new ProductViewModel();<br/>}</pre>
<p>In the preceding code block, the <kbd>GetProductDetails</kbd> method does a similar thing to the method <kbd>GetProducts</kbd>. The difference is that it accepts the parameter <kbd>productId</kbd>.</p>
<p>The following is the complete code of our REST client:</p>
<pre>public class RestSharpWebClient<br/>{<br/>  private readonly RestClient _client = new<br/>  RestClient("http://localhost:10065/api/");<br/>  public List&lt;ProductViewModel&gt; GetProducts()<br/>  {<br/>    var request = new RestRequest("product/productlist", <br/>    Method.GET);<br/>    var response = _client.Execute&lt;List&lt;ProductViewModel&gt;&gt;<br/>    (request);<br/>    //To avoid any exception lets return an empty view model<br/>    //On production environment return exact exception or your <br/>    custom code<br/>    return response.Data ?? new List&lt;ProductViewModel&gt; {new<br/>    ProductViewModel()};<br/>  }<br/>  public ProductViewModel GetProductDetails(string productId)<br/>  {<br/>    var request = new RestRequest("product/{productid}", <br/>    Method.GET);<br/>    request.AddParameter("productid", productId);<br/>    var response = _client.Execute&lt;ProductViewModel&gt;(request);<br/>    //To avoid any exception lets return an empty view model<br/>    //On production environment return exact exception or your <br/>    custom code<br/>    return response.Data ?? new ProductViewModel();<br/>  }<br/>  public bool AddProduct(ProductViewModel product)<br/>  {<br/>    var request = new RestRequest("product/addproduct", <br/>    Method.POST);<br/>    request.AddBody(product);<br/>    var response = _client.Execute(request);<br/>    return response.StatusCode == HttpStatusCode.OK;<br/>  }<br/>  public bool UpdateProduct(string id, ProductViewModel product)<br/>  {<br/>    var request = new RestRequest("updateproduct", Method.PUT);<br/>    request.AddQueryParameter("productid", id);<br/>    request.AddBody(product);<br/>    var response = _client.Execute(request);<br/>    return response.StatusCode == HttpStatusCode.NoContent;<br/>  }<br/>  public bool DeleteProduct(string id, ProductViewModel product)<br/>  {<br/>    var request = new RestRequest("deleteproduct", Method.DELETE);<br/>    request.AddQueryParameter("productid", id);<br/>    request.AddBody(product);<br/>    var response = _client.Execute(request);<br/>    return response.StatusCode == HttpStatusCode.NoContent;<br/>  }<br/>}</pre>
<p>With the preceding code snippet, you have now added the functionality that will call and consume your product APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a REST web client</h1>
                
            
            
                
<p>RESTful services may or may not be a part of your web application, but we still need to understand how to implement them.</p>
<p>So, now it's time to do some real work. Add <kbd>ProductController</kbd> to the project, as well as the following action:</p>
<pre>public ActionResult Index()<br/>{<br/>  var webClient = new RestSharpWebClient();<br/>  var products = webClient.GetProducts();<br/>  return View("ProductList", products);<br/>}<br/><br/></pre>
<p>Take a look at the preceding code snippet. We have called the <kbd>GetProducts</kbd> method of <kbd>RestSharpWebClient</kbd> and populated our <kbd>Index.cshtml</kbd> view with a complete list of products.</p>
<p>To add another action method, enter the following complete code of our <kbd>ProductController</kbd>. The following code snippet contains the <kbd>Index</kbd> action method and gives us a list of products:</p>
<pre>public class ProductController : Controller<br/>{<br/>  public ActionResult Index()<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var products = webClient.GetProducts();<br/>    return View("ProductList", products);<br/>  }<br/>  public ActionResult Details(string id)<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var products = webClient.GetProductDetails(id);<br/>    return View(products);<br/>  }</pre>
<p>Let's now look at two <kbd>Create</kbd> action methods: <kbd>HttpGet</kbd> and <kbd>HttpPost</kbd>. The first one provides us with an entry screen for input and the second posts all the data (the input values) using the <kbd>HttpPost</kbd> method. On the server side, you can receive all data in an <kbd>IFormCollection</kbd> parameter, and you can also easily write logic to get all of your values in <kbd>ProductViewModel</kbd>.</p>
<pre>  public IActionResult Create()<br/>  {<br/>    return View();<br/>  }<br/>  [HttpPost]<br/>  [ValidateAntiForgeryToken]<br/>  public IActionResult Create(IFormCollection collection)<br/>  {<br/>    try<br/>    {<br/>      var product = new ProductViewModel<br/>      {<br/>        ProductId = Guid.NewGuid(),<br/>        ProductName = collection["ProductName"],<br/>        ProductDescription = collection["ProductDescription"],<br/>        ProductImage = collection["ProductImage"],<br/>        ProductPrice = Convert.ToDecimal(collection["ProductPrice"]),<br/>        CategoryId = new Guid("77DD5B53-8439-49D5-9CBC-DC5314D6F190"),<br/>        CategoryName = collection["CategoryName"],<br/>        CategoryDescription = collection["CategoryDescription"]<br/>      };<br/>      var webClient = new RestSharpWebClient();<br/>      var producresponse = webClient.AddProduct(product);<br/>      if (producresponse)<br/>      return RedirectToAction(nameof(Index));<br/>      throw new Exception();<br/>    }<br/>    catch<br/>    {<br/>      return View();<br/>    }<br/>  }</pre>
<p>You can also write a <kbd>HttpPost</kbd> method that accepts a parameter of the type <kbd>ProductViewModel</kbd>.</p>
<p class="mce-root">The following code snippet shows us the code for the <kbd>Edit</kbd> action method, which is similar to the <kbd>Create</kbd> action method but except that it updates existing data rather than inserting new data:</p>
<pre><br/>  public ActionResult Edit(string id)<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var product = webClient.GetProductDetails(id);<br/>    return View(product);<br/>  }<br/>  [HttpPost]<br/>  [ValidateAntiForgeryToken]<br/>  public ActionResult Edit(string id, IFormCollection collection)<br/>  {<br/>    try<br/>    {<br/>      var product = new ProductViewModel<br/>      {<br/>        ProductId = new Guid(collection["ProductId"]),<br/>        ProductName = collection["ProductName"],<br/>        ProductDescription = collection["ProductDescription"],<br/>        ProductImage = collection["ProductImage"],<br/>        ProductPrice = Convert.ToDecimal(collection["ProductPrice"]),<br/>        CategoryId = new Guid(collection["CategoryId"]),<br/>        CategoryName = collection["CategoryName"],<br/>        CategoryDescription = collection["CategoryDescription"]<br/>      };<br/>      var webClient = new RestSharpWebClient();<br/>      var producresponse = webClient.UpdateProduct(id, product);<br/>      if (producresponse)<br/>      return RedirectToAction(nameof(Index));<br/>      throw new Exception();<br/>    }<br/>    catch<br/>    {<br/>      return View();<br/>    }<br/>  }</pre>
<p class="mce-root">The <kbd>Delete</kbd> action method is meant to remove a specific record or data from a database or collection. The action method <kbd>Delete</kbd> of <kbd>HttpGet</kbd> fetches a record based on a given ID and displays the data ready for modification. Another <kbd>Delete</kbd> action of <kbd>HttpPost</kbd> sends modified data to the server for further processing. This means the system can delete data and records.</p>
<pre><br/>  public ActionResult Delete(string id)<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var product = webClient.GetProductDetails(id);<br/>    return View(product);<br/>  }<br/>  [HttpPost]<br/>  [ValidateAntiForgeryToken]<br/>  public ActionResult Delete(string id, IFormCollection collection)<br/>  {<br/>    try<br/>    {<br/>      var product = new ProductViewModel<br/>      {<br/>        ProductId = new Guid(collection["ProductId"]),<br/>        ProductName = collection["ProductName"],<br/>        ProductDescription = collection["ProductDescription"],<br/>        ProductImage = collection["ProductImage"],<br/>        ProductPrice = Convert.ToDecimal(collection["ProductPrice"]),<br/>        CategoryId = new Guid(collection["CategoryId"]),<br/>        CategoryName = collection["CategoryName"],<br/>        CategoryDescription = collection["CategoryDescription"]<br/>      };<br/>      var webClient = new RestSharpWebClient();<br/>      var producresponse = webClient.DeleteProduct(id, product);<br/>      if (producresponse)<br/>      return RedirectToAction(nameof(Index));<br/>      throw new Exception();<br/>    }<br/>    catch<br/>    {<br/>      return View();<br/>    }<br/>  }<br/>}</pre>
<p>Now let's open <kbd>_Layout.cshtml</kbd> from the <kbd>Shared</kbd> folder and add the following line to add a link to our newly added <kbd>ProductController</kbd>:</p>
<pre>&lt;li&gt;&lt;<strong>a</strong> <strong>asp-area</strong>="" <strong>asp-controller</strong>="Product" <strong>asp-action</strong>="Index"&gt;Web Client&lt;/<strong>a</strong>&gt;&lt;/li&gt;</pre>
<p>You should see a new menu named Web Client when you run the project, as shown in the following screenshot:</p>
<div><img src="img/0860e52c-5016-46d2-a6df-d0812d31377e.png" style="width:52.33em;height:25.83em;"/></div>
<p>We are now ready to see some results. Click on the Web Client menu, and you will see the following screen:</p>
<div><img src="img/1626a7e2-dcdc-4ad2-983c-4410f4e9784a.png" style="width:53.42em;height:20.83em;"/></div>
<p>From the preceding screen, you can perform other operations, as well as call and consume your product APIs—namely, Create, Edit, and Delete.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The creation of RESTful services is important for any project, but these services are of no use if there is no way of using them. In this chapter, we looked at how to add RestSharp support to our web project and consume our pre-developed product APIs. We also created a web client that could consume web services by rendering output on our web pages using ASP.NET Core.</p>
<p>In the next chapter, we will discuss the hot topic of microservices, the next level of the separation of services. We will discuss how microservices communicate, what their advantages are, and why we require them.</p>


            

            
        
    </body></html>