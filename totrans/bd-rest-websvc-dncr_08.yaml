- en: Securing RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of web applications, where there are numerous request and response
    exchanges over HTTP, security is one of the most important cross-cutting concerns.
    Any unsecured service or web application can face datatampering issues.
  prefs: []
  type: TYPE_NORMAL
- en: '"Whenever data is modified (destroyed, manipulated, or edited) by an unauthorized
    channel, it is generally called data tempering."'
  prefs: []
  type: TYPE_NORMAL
- en: Data can be tampered with when it is in transit or in another place. There might
    be several reasons why data is tampered with—unprotected data is the most common
    reason in the industry. To prevent such issues, you can protect your environment
    and application systems. Generally, a firewall is the best way to protect your
    environment (server). You can protect an application by implementing an authorization
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, data breaches of well-known sites are commonplace these days.
    Taking this into account, information and application security has become critical
    to web applications. For the same reason, secure applications should no longer
    be an afterthought. Security is everyone's responsibility in an organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will mainly be focused on security and the REST and OWASP
    security standards. By the end of this chapter, you will understand the concepts
    of authentication, single sign-on (SSO), token-based authentication, and authentication
    using a proxy server (such as Azure API Management). We will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP standards for web security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing RESTful web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data encryption and storing sensitive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP security standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Open Web Application Security Project** (**OWASP**) is an online community
    that mainly works on web application security problems by creating various studies
    and standards. In this chapter, we will follow the security standards of OWASP
    that were released in 2017 ([https://www.owasp.org/index.php/Top_10-2017_Top_10](https://www.owasp.org/index.php/Top_10-2017_Top_10)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/968d6f59-d1c6-4c36-a56d-25182e578d50.png)'
  prefs: []
  type: TYPE_IMG
- en: Application security risks
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is a pictorial overview of an application's security risks.
    It depicts how an attacker might attack a weaker application. The attacker attacks
    application components by injecting scripts (mostly JavaScript) and impacting
    the system. In this image, you will notice that only an unsecured portion of the
    web application is under attack. A secure system is safe, even after it has been
    attacked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are application security risks as defined by OWASP:'
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broken authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive data exposure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML external entities (XXE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broken access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security misconfiguration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-site scripting (XSS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are high-alarmed security risks that should be handled in every web application.
  prefs: []
  type: TYPE_NORMAL
- en: Securing RESTful web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start with learning about securing RESTful web services, I would
    like to tell you about security in the world of the web. In general, the phrase
    *security* describes the measures that are taken to make sure that everything
    is secure. But what does *everything* include here? Let''s elaborate: security
    is a way or a process that stops unauthenticated and unauthorized access to confidential
    data over web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: The type of confidential data depends upon the nature of the web application—for
    example, if the web application is for medical and clinical services, then the
    confidential information consists of all the patients' data related to their tests,
    medical history, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The first step towards the creation of a security process is to authenticate
    and authorize access to the web application. If the request is not authenticated,
    then it should not be accepted by the system. It should also not be accepted if
    the request is authenticated, but not authorized to access the data of the web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an overview of the authentication process, using
    Auth services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fd52e96-be02-4c61-aeca-ced31340e984.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, you can think about a typical ASP.NET Core API system
    that uses Auth services as a middleware server. There may be several clients or
    consumers who are using these services and can request access to the data. Here,
    Auth services play an important role in authenticating incoming requests from
    clients. If the Auth service identifies the request as authenticated, it generates
    a token and sends it to the API servers for further processing. If the request
    is not an authenticated request, then the Auth service notifies the client of
    the failed authentication. The preceding image is just an overview of a typical
    scenario. An actual scenario could be more complex, with the use of one or more
    middleware backend servers (typical API management servers).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, you will get a better idea of the following two
    important security concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Authentication is nothing but a process where a system
    verifies or identifies the incoming requests by some sort of credentials (generally
    a user ID and password). If the system finds that the provided credentials are
    wrong, then it notifies the user (generally via a message on the GUI screen) and
    terminates the authorization process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Authorization always comes after authentication. It is a
    process that allows the authenticated user who raised the request to access resources
    or data after verifying they have access to the specific resources or data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this, you can conclude that the security of RESTful services is the most
    important feature of the application.
  prefs: []
  type: TYPE_NORMAL
- en: How can you maintain sessions in RESTful web services?
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web services work with the HTTP protocol, which is a stateless protocol
    ([https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol](https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol)),
    and treat every request as a new request. There is no way in which the HTPP protocol
    helps to maintain sessions in RESTful web services. But, we can achieve this programmatically
    with the help of authenticated tokens. This technique is known as token-based
    authorization (we will discuss it in detail in the coming sections). With the
    help of this technique, you can authorize an authenticated user to allow data
    or resources for a predefined period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every request that comes via services or any other mode should be authenticated
    and authorized before the system responds to the user or the client that made
    the call. This process mainly includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality**: The secured system makes sure that any sensitive data
    is not exposed to unauthenticated and unauthorized access requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: The security measures in the system make sure that the system
    is available for users who are genuine, as confirmed through the system''s authentication
    and authorization mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: In a secured system, data tampering is not possible, so the
    data is secure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vulnerable areas of an unsecured web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s web applications, the main vulnerable assets to protect from unauthorized
    access are the resources and data. If a site is unsecured, then the chances of
    vulnerability are high. According to the official website at[ https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/),
    the following areas are the main threats to any unsecured web application.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cross-site scripting attacks—or XSS attacks—typically happen as a result of
    bad input, where an attacker injects client scripts (JavaScript in most cases)
    into the web page. According to the official web page ([https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting](https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Cross-Site Scripting (XSS) is a security vulnerability which enables an attacker
    to place client-side scripts (usually JavaScript) into web pages."'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I am using the example of a web client that consumes web services. You
    will learn more about web clients in [Chapter 10](9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml), *Building
    a Web Client (Consuming Web Services)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a scenario where the Create screen is under
    attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36cad43d-568a-4d96-b78c-540f91b92e34.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is a representation of an unsecure web application.
    Here, the user can inject the script tag, and when the user clicks on Create,
    it is posted back to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the code''s debug mode, where we can see that
    our system is accepting script data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a485f149-a9f6-46d9-ab47-4767482077c4.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows how it was posted to the server and was eventually
    saved in the database or any persistent repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the affected page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2f4336f-308f-4be5-97de-5cb9a92d72ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever anyone accesses a page with affected data, it will show an alert, as
    shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: You can build a system that stops such attacks by applying a few code changes.
    I will cover this in the *Validations* section.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An SQL injection attack is one of the most severe attacks that directly target
    the database. This is first in the list of OWASP application security risks. Attackers
    can steal a system's secured data with the help of SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the process of SQL injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38261ad4-2792-4435-90bd-476e9af7d479.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, you can see a typical SQL injection scenario where
    the attacker has injected an `or` clause to fetch all of the data of a particular
    table. The actual code instruction was to return a single record based on the `EmpId`
    from the employee table. But as it was injected with an extra phrase, it returns
    the complete records of the employee table. This is the biggest problem with an
    unsecured system. Here, the attacker injected a simple clause into the statement.
  prefs: []
  type: TYPE_NORMAL
- en: What is cooking here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you saw an imaginary scenario and went through an
    SQL injection in action. Let’s look at an actual example by creating a RESTful
    product API using ASP.NET Core 2.0\. Before you start building this application,
    bear in mind the following prerequisites for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 update 3 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#7.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Entity Framework Core 2.0.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go through the following steps to create our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select File | New | Project or press *Ctrl* + *Shift* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select ASP.NET Core Web Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the template window, select ASP.NET Core API. Make sure you select .NET
    Core 2.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project, choose the path for the solution, and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Models` folder. In Solution Explore, right-click, select Add New Folder from
    the drop-down menu, and name it `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class under the `Models` folder. Right-click on the `Models` folder
    in Solution Explorer and select Add New Item | Class from the drop-down menu,
    or use *Shift* + *Alt* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that the shortcut keys vary as per your settings for Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name it `Product.cs`, and add the following code to this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Repeat steps 7 and 8, adding `Category.cs` and `ProductViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 6, adding the `Contexts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class under the `Contexts` folder. Right-click on the `Contexts` folder
    in Solution Explorer, select Add New Item, and in the dialog box, select Class,
    or use *Shift* + *Alt* + *C*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `ProductContext.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the `appsettings.json` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on the project in Solution Explorer and select Manage NuGet Package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under NuGet Package Manager screen, search for `Swashbuckle.ASPNETCore` and
    install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Persistence`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `IProductRepository` interface under the `Persistence` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `IProductRepository` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the GitHub repository link at [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core) for
    the complete source code.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `ProductRepository.cs` class under the `Persistence` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `ProductRepository.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Startup.cs` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you are ready to play with the application. Run the application from the
    menu or hit *F5*. In the web browser, add the `/swagger` suffix to the URL in
    the address bar, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f302dc09-ab8e-4e5d-ad35-c2c073964838.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will show the Swagger API documentation, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54ba2a0c-fe5e-482b-853b-fad4f7aab778.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger documentation for the Product APIs
  prefs: []
  type: TYPE_NORMAL
- en: I used Swagger for the documentation and to test API calls. You can use other
    API test clients, such as Advanced Rest Client and PostMan.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our unsecured code, click on the `GET` `/api/product/{productid}` resource and
    pass the product ID, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b575d5b-c23a-4634-8eaf-0c4080a53e49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click Execute. You should see the following expected output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5dc3b253-3137-4adf-91e4-28b1ee7ab72f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to add the `OR` clause and see what happens. Here, I am entering
    the `productid` value as `4D261E4A-A657-4ADD-A0F6-DDE6E1464D55` or `1=1`. Execute
    it and look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acaaa4aa-09b4-45c1-8e0e-b4a20bf55a14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that our application is affected by SQL injection. You are
    seeing all the records from the table. It happened because of the raw SQL query
    (refer to [https://docs.microsoft.com/en-us/ef/core/querying/raw-sql](https://docs.microsoft.com/en-us/ef/core/querying/raw-sql) for
    more information) that we are using. You can find the reason for the earlier results
    after looking closer at the code. The following screenshot will remind you what
    the request URL was:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/793b6f47-ed4b-4448-9a62-4ea52998664a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the injected URL. When our repository''s `GetByProduct(string id)` method executed,
    it created the following raw SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the attacker did the job very smartly and quietly. Our unsecured
    code bled and returned the entirety of the data of the targeted table. I used
    the SQL profiler ([https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler](https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler))
    to trace the queries.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing SQL injection attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is nothing more dangerous than unsecured code. With unsecured code, the
    application is always in danger. Attackers can steal data at any time, forcefully
    manipulating things by tampering with requests.
  prefs: []
  type: TYPE_NORMAL
- en: Saineshwar Bageri has written 10 tips for creating a secure ASP.NET web application.
    You can read them at [https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications](https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can stop an SQL injection attack with the following two techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validations**: We will discuss these later in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using parameters in raw SQL queries**: This is in addition to using a raw
    SQL query directly by concatenating values (refer to our example of unsecured
    code). In this way, you can rewrite the `GetByProduct(string id)` method as the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code still contains a raw SQL query, but it is secure enough
    to handle any injected code. If you try the same parameter value we used earlier,
    then the modified code will not accept it. It will throw an exception, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aec9d30-804a-4095-a26a-f83a942b95cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use string the interpolation syntax with a raw SQL query if your
    EF Core version is 2.0.0 or above. With string interpolation, the code looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public IEnumerable<Product> GetByProduct(string id) => _context.Products`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.FromSql($"SELECT * FROM dbo.Products WHERE id={id}")`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Include(p => p.Category)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.ToList();`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data encryption**: We will discuss this later in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-site request forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CRSF**) can also be shortened to **XSRF**.
    This is a common attack where the attacker infuses an unwanted action while the
    client is interacting (request/response) with the hosted application. Generally,
    attackers use malicious code to influence the interaction.'
  prefs: []
  type: TYPE_NORMAL
- en: Malicious code is scripting code that downloads onto a web browser and executes,
    even without the knowledge of the authenticated user. For details, refer to [https://www.techopedia.com/definition/4013/malicious-active-content](https://www.techopedia.com/definition/4013/malicious-active-content).
  prefs: []
  type: TYPE_NORMAL
- en: Attackers are very smart, and they use different platforms to provide spurious
    links to malicious code. These links are very similar to the domain (website)
    that is under attack. Financial websites are the main targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts an XSRF attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/255cc01d-e689-42fc-a8d3-f7c365e5c71b.png)'
  prefs: []
  type: TYPE_IMG
- en: Attackers could send a link via email, social media, or any other medium. When
    the user clicks on the link, he or she will be in the world of the attacker without
    knowing that it's a spurious site and not their intended site.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the official web page at [https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery](https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery).
  prefs: []
  type: TYPE_NORMAL
- en: CSRF vulnerabilities are fundamentally a problem with the web app, not the end
    user.
  prefs: []
  type: TYPE_NORMAL
- en: To handle this kind of attack, you need to build a system that is secure and
    properly authenticated. I will walk you through the details in the coming section
    focusing on authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, you have learned about the basics of authentication and authorization.
    In this section, you will see these two most important ways of securing an application
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication, token-based authorization, and other authentications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you’re talking about secured web services/web applications, you should
    think about the all the points I mentioned regarding authentication and authorization
    in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’m going to discuss authentication and authorization at the
    implementation stage.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As is evident from the word *basic*, basic authentication involves a mechanism
    where the system asks for simple credentials (username and password) to authenticate
    or validate the user via incoming requests from the client to the web or application
    servers via RESTful web services (in our case, ASP.NET Core web APIs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following diagram, which showcases basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56f71166-ffe5-435d-adff-942f05565884.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is of the basic HTTP authentication that I'm going to
    implement in our code. Here, the request comes from the client to access resources
    that are protected (resources that are kept from public access). The request contains
    a username and password in its header at the service end, and the service checks
    whether it is a validate request or not by validating the username and password
    from its repository, usually a database store. The service returns the data in
    its response to the client if the user is validated; otherwise, it returns invalid
    credentials with HTTP status code 401.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete list of HTTP status codes, along with their definitions,
    at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  prefs: []
  type: TYPE_NORMAL
- en: The security concerns of basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic authentication, as its name suggests, is a very basic authentication
    mechanism, and is not too secure when it comes to stopping attackers. Here, I
    have jotted down the following security vulnerabilities in the authentication
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Credentials**: The required credentials are the most important security concern
    that could lead to security breaches, which could in turn further exploit the
    system''s weak security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request**: Requests can be tampered with, and could lead to a big security
    breach; with basic authentication, every request carries the credentials (username
    and password), which can be tampered with and used to further exploit the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closing the browser session**: There is a concern that should be high priority—there
    is no ability to log out from an application using the basic authentication method,
    unless the user closes the browser to destroy the browser session themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can look at the official web page at [https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication](https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: '"Basic authentication is also vulnerable to CSRF attacks. After the user enters
    credentials, the browser automatically sends them on subsequent requests to the
    same domain, for the duration of the session."'
  prefs: []
  type: TYPE_NORMAL
- en: There might be more security concerns that make the basic authentication mechanism
    the weakest with respect to web application security.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication leads to various security concerns. I am not going to showcase
    these using code examples of basic authentication, but if you still want to test
    the basic authentication mechanism, then I suggest that you extract the code from
    the forked GitHub repository at [https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic](https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic).
  prefs: []
  type: TYPE_NORMAL
- en: Token-based authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I explained authorization in the earlier sections of this chapter, where you
    saw that authorization is the next step after authentication to access restricted
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following diagram, which depicts token-based authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da675a0-34dc-4b93-a420-7ec91e588173.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows a token-based authentication. If the request is
    verified (depending upon the identification of the credentials), then the client
    sends a request with the credentials and the returned token. The client then stores
    this token. It then sends these tokens with the headers in every request until
    the token is valid. If it is authorized to access the secure resource, the server
    verifies the request check and responds with the data. In some cases, the client
    may request a new token or call a refresh token if the existing token expires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an `AuthRequet` model, as shown in our API project created in the
    previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `GenerateTokenController.cs` controller in the `Controller` folder.
    Here is our `GetToken` POST resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the `[AllowAnonymous]`attribute in the preceding code? You will
    see it in later sections. In the preceding code, I simply validate the credentials,
    and if the credentials are valid, the `TokenUtility `middleware generates the
    token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `TokenUtility` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is self-explanatory: it generates the token. In this code,
    I put `JwtKey` as a constant (for demonstration purposes only).'
  prefs: []
  type: TYPE_NORMAL
- en: In production, `JwtKey` should be kept in the environment variable (for security
    reasons) and can be easily accessible, as in, for example, `string jwtKey = Environment.GetEnvironmentVariable("JwtKey");`.
  prefs: []
  type: TYPE_NORMAL
- en: I am not going to discuss the repository model and other such approaches as
    these are self-explanatory. You can extract the entire source code from the GitHub
    repository at [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core).
  prefs: []
  type: TYPE_NORMAL
- en: To enable token-based authentication, you need to make a few changes in the
    `startup.cs` file by inserting `Add app.UseAuthentication();` in the `Configure`
    method before `app.UseMvc();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ConfigureService` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project. Let''s do a simple test using the Swagger documentation,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bc17fec-d7e0-4571-8c5f-c54336168189.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will give the token upon a valid request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c572606c-1b51-4994-9717-94586ec3144d.png)'
  prefs: []
  type: TYPE_IMG
- en: We will make a complex authorization process to access resources depending on
    the roles and access levels of the users in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Other authentication methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from basic and token-based authentications, you can also go with other
    available authentication mechanisms (we will not discuss these in detail, as they
    are beyond the scope of this book). IdentityServer4 is one of the most famous
    authentication servers and enables authentication as a service, single sign-in/sign-out,
    and many more options (refer to [https://identityserver4.readthedocs.io/en/release/](https://identityserver4.readthedocs.io/en/release/) for
    more information).
  prefs: []
  type: TYPE_NORMAL
- en: Securing services using annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core provides various ways to make secure application annotations (data
    annotations). This option is one of the ways in which we can secure our models
    for a web application. Data annotations provide a way to validate the inputs at
    the client end or the server end.
  prefs: []
  type: TYPE_NORMAL
- en: Validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is self-explanatory from the name *validations* that they are nothing but
    validators of user/client inputs. The user input can be validated at the client
    end or at the API end (server side). In RESTful services, you can validate the
    input using model validations with the help of data annotations.
  prefs: []
  type: TYPE_NORMAL
- en: If the model is validated, this does not guarantee that data that comes with
    the request is safe.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will rewrite our model used in the code example of the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the modified `ProductViewModel` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to include the `System.ComponentModel.DataAnnotations` namespace
    while using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, I used a very simple annotation, the `required` attribute.
    This makes sure that our model has the required properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our `Post` resource to add a new product item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Compile the application and run it to test the impact of the data annotation
    on our model. This time, you can try this using PostMan ([https://getpostman.com/](https://getpostman.com/))
    to test the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `addproduct POST` resource; the `/api/product/addproduct` API is
    used to save the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/082343cc-d355-40bb-bb86-3629f41e0058.png)'
  prefs: []
  type: TYPE_IMG
- en: POST request using Swagger
  prefs: []
  type: TYPE_NORMAL
- en: The preceding input is valid; you have supplied all the required values. Let’s
    remove `Price` and `ProductName`. You will see that there is no change while you
    execute the request, even without supplying the required values. Here, the validation
    failed. The reason why these data annotations did not affect the process is that
    you did not direct the system to validate the input. To validate the input, you
    should tell the system explicitly what you want to validate, for example, the
    model state. We will fix this with the help of filters in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Securing context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of the `filter` attribute, you can implement security at the context
    level. In this section, we will rewrite our model and API resources to implement
    filters/attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we used the `Required` attribute with our `Product`
    model, and this did not work for us. In this section, we will fix the problem
    with the help of filters (for more information on filters, go to [https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets add a custom filter that validates the input, detecting whether any of
    the required fields are missing. If they are, it will just throw an exception.
    You need to modify the previous code, changing the `Product` model to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Simply add `ErrorMessage` in the required `ProductName `field; the rest of the
    properties of the model remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new `Filters `folder in the project from Solution Explorer. To do
    this, go through the steps we followed in the previous section on *SQL injections *and
    add a new class in this folder named `ValidateInputAttribute.cs` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply this filter as an attribute to the `Post` resource to add the product.
    Our code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and enter the new product values without the product name,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf7edee1-eb93-4c37-a418-d3be5841ce85.png)'
  prefs: []
  type: TYPE_IMG
- en: Process the request and look at the response from the server, shown in the preceding
    screenshot. The request will not be processed, and a response will come from the
    server notifying you of a bad request with the relevant error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Bad Request response (HttpStatus Code 400):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2562185d-2e4d-4ffd-ba0e-c17d820d147d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make any filter available anywhere, you should add the following code in
    the `startup.cs` configure method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's come back to our token-based authorization method. In the previous
    application, you saw how we can build an API to validate the credentials. Now,
    let's make a policy to restrict a resource. A detailed explanation of this topic
    is beyond the scope of this book; I suggest that you refer to the official documentation
    at [https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies).
  prefs: []
  type: TYPE_NORMAL
- en: Data encryption and storing sensitive data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data security is always a big concern in any application, and it is a high priority
    while writing or designing applications. You can use any hashing algorithm to
    protect the data by encryption and decryption, but it would lead to a performance
    hit. ASP.NET Core provides a way to protect data with the help of the ASP.NET
    DataProtection ([https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/))
    NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: A complete explanation of this topic is beyond the scope of this book. You can
    refer to [https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/](https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/)
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While you work with APIs, you have to store sensitive data: the API key, secret
    key, username, password, and so on. The following are a few recommendations for
    you to take into consideration while you’re working with this data in the ASP.NET
    Core application:'
  prefs: []
  type: TYPE_NORMAL
- en: You should separate the configuration files from code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should avoid storing this data in plain text files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a separate class file where you can store these data values in the
    form of constants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should store confidential data in environment variables. For more information,
    refer to [http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/](http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use a secret manager to store your confidential data ([https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive data varies from application to application and requirement to requirement.
    For more details, you can refer to [https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core](https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed data security, following the OWASP security
    standard, and looking at JWT authentication. We also discussed custom filters
    and input validations using a code example. Data protection is always a high priority
    for any web application. We discussed data protection methods when storing sensitive
    data in an ASP.NET Core application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the performance of web services by looking
    at the scale-in, scale-out methodology and the implementation of a few caching
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
