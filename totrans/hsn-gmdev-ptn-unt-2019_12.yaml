- en: Command
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: I have to admit that the Command pattern might be hard to understand at first.
    I know that it took me time to master it. Even if its name indicates its core
    purpose, its actual application is not apparent at first. But once you start playing
    around with it and comprehend its intricacies, it can become a sturdy pattern
    to apply when designing specific types of systems, such as user interfaces. Its
    primary purpose is to offer a way to encapsulate data that is needed to execute
    an operation or trigger an event at a particular moment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，命令模式可能一开始很难理解。我知道我花了很长时间才掌握它。即使它的名字表明了其核心目的，其实际应用一开始并不明显。但一旦你开始尝试并理解其复杂性，它就可以成为设计特定类型系统（如用户界面）时应用的一个坚固的模式。它的主要目的是提供一个封装所需数据的方法，以便在特定时刻执行操作或触发事件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basic principles behind the Command pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式背后的基本原理
- en: Implementing a Universal Controller that we can control multiple devices with
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个我们可以用其控制多个设备的通用控制器
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following chapter is hands on, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是实践性的，因此你需要对Unity和C#有基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concept:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: Constructors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: If you are unfamiliar with this concept, please review it before moving forward.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个概念不熟悉，请在继续之前先复习一下。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际运行情况：
- en: '[http://bit.ly/2Our6OF](http://bit.ly/2Our6OF)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Our6OF](http://bit.ly/2Our6OF)'
- en: The basics of the Command pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式的概述
- en: The Command pattern is a solution that makes it possible to centralize the process
    of invoking specific commands on objects. A real-world correlation I keep in mind
    when thinking about the Command pattern is a *Universal Controller*. Back in the
    day, before the internet and smartphones, most living rooms had multiple devices,
    each with a specific functionality. You had a stereo to play music, a TV to watch
    shows, a VHS to play tapes, and so on, but each system had a particular remote
    control associated with it, so this often caused confusion because of the variety
    of controllers you needed to manage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是一种解决方案，它使得在对象上集中调用特定命令的过程成为可能。在思考命令模式时，我常常会联想到一个*通用控制器*。在互联网和智能手机出现之前，大多数客厅里都有多个设备，每个设备都有其特定的功能。你有一个音响来播放音乐，一个电视来观看节目，一个VHS来播放磁带，等等，但每个系统都有一个特定的遥控器与之相关联，因此由于需要管理多种控制器，这常常会导致混乱。
- en: Due to this, the programmable *Universal Controller* was invented, which resolved
    this issue and allowed you to control multiple devices from a single remote. This
    approach worked because a *Universal Controller* had a standard set of buttons
    that you could associate with commands and devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，发明了可编程的*通用控制器*，它解决了这个问题，并允许你从单个遥控器控制多个设备。这种方法之所以有效，是因为*通用控制器*有一组标准的按钮，你可以将其与命令和设备相关联。
- en: In a way, the Command pattern is very similar to the concept of a *Universal
    Controller* because it permits you to link and invoke specific commands on objects
    that can handle requests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，命令模式与*通用控制器*的概念非常相似，因为它允许你将特定的命令与可以处理请求的对象链接和调用。
- en: 'Let''s review the following diagram, which is of a typical implementation of
    the Command pattern:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾以下图示，这是命令模式典型实现的示例：
- en: '![](img/8cad29e3-cc4d-44ca-a948-c53825d38454.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cad29e3-cc4d-44ca-a948-c53825d38454.png)'
- en: 'Trying to learn about the Command pattern by looking at a diagram is not the
    right approach, but it does help us isolate the fundamental classes that are participating
    in this pattern:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看图表来学习命令模式并不是正确的方法，但它确实帮助我们隔离了参与此模式的根本类：
- en: An `Invoker` is an object that knows how to execute a command and can also do
    the bookkeeping of executed commands.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Invoker`是一个知道如何执行命令并且可以记录已执行命令的对象。
- en: The `Receiver` is a type of object that can receive commands and execute them.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Receiver`是一种可以接收命令并执行它们的对象类型。'
- en: The `CommandBase` is usually an interface or abstract class for concrete command
    classes. It's the primary layer of abstraction of this pattern.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommandBase`通常是具体命令类的接口或抽象类。它是这种模式的主要抽象层。'
- en: These core classes encapsulate all the information that's needed to execute
    a command at a specific moment. This will be made more evident when we implement
    our use case.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心类封装了在特定时刻执行命令所需的所有信息。这将在我们实现用例时变得更加明显。
- en: Benefits and drawbacks
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: Similar to patterns such as the Strategy and State, the main reason that programmers
    seem to avoid using the Command pattern is because of its *wordiness*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与策略和状态等模式类似，程序员似乎避免使用命令模式的主要原因是其*冗长性*。
- en: 'These are the main benefits of the Command pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是命令模式的主要优点：
- en: '**Sequencing and timing**: The Command pattern gives you the flexibility of
    executing commands in a sequence or within a specific time frame'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序和时间**: 命令模式为你提供了在特定顺序或时间范围内执行命令的灵活性'
- en: '**Undo/Redo**: The Command pattern is often used to implement bookkeeping features
    that permit to rollback commands in specific orders'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤销/重做**: 命令模式通常用于实现簿记功能，允许以特定顺序回滚命令'
- en: '**Extensibility**: A typical advantage of Behavioral patterns is that they
    give you the ability to add behaviors with minimal changes having to be made to
    the main classes'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**: 行为模式的一个典型优点是它们给你提供了添加行为的能力，而无需对主要类进行大量更改'
- en: 'These are the drawbacks of the Command pattern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是命令模式的缺点：
- en: '**Verbosity**: A common disadvantage of this type of pattern is that it makes
    your code very verbose and adds a lot more classes to your code base'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗长性**: 这种模式的一个常见缺点是它会使你的代码非常冗长，并且向你的代码库中添加更多类'
- en: Use case example
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: As a use case, we will actually implement a Universal Controller that will permit
    us to control multiple devices, including a TV and radio. The main reason we are
    going to use the Universal Controller concept as an example is because it's going
    to be easier for us to learn the intricacies of the Command pattern, which we
    will do by implementing a system that is directly related to managing the invocation
    of commands on specific objects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用例，我们将实际实现一个通用控制器，它将允许我们控制多个设备，包括电视和收音机。我们将使用通用控制器概念作为示例的主要原因是因为这将更容易让我们学习命令模式的复杂性，我们将通过实现一个直接与在特定对象上管理命令调用相关的系统来完成这一点。
- en: Code example
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Implementing the Command pattern with a specific use case is the best way to
    master it. The example we are going to write is a perfect fit for the Command
    pattern because it''s all about sending commands to specific receivers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过特定的用例实现命令模式是掌握它的最佳方式。我们将编写的示例非常适合命令模式，因为它全部关于向特定接收器发送命令：
- en: 'For our first class, we will need to declare the `RemoteControlDevice` type
    in the form of an abstract class:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的第一个类，我们需要以抽象类的形式声明`RemoteControlDevice`类型：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next up is the `Command` class, which is our core type for this pattern:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`Command`类，这是我们这种模式的核心类型：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, its primary responsibility is to assign a `Receiver` object and
    `Execute()` a command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，它的主要职责是分配一个`Receiver`对象并执行`Execute()`命令。
- en: 'Now, let''s implement concrete Command classes, each with their unique responsibility.
    First off, let''s implement `TurnOnCommand`, which is used to turn on our devices
    (receivers):'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现具体的命令类，每个类都有其独特的职责。首先，让我们实现`TurnOnCommand`，它用于打开我们的设备（接收器）：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next up is our `TurnOffCommand`, which will, of course, turn off our devices
    (receivers):'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`TurnOffCommand`，它当然会关闭我们的设备（接收器）：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There''s also our `KillSwitchCommand`, which is unique:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有我们的`KillSwitchCommand`，它是独特的：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, `KillSwitchCommand` doesn't merely call the `Execute()` function
    on a `Receiver` object, but goes through a list of devices and calls the `TurnOff()`
    function on each of them. This means that we are batching the execution of a specific
    command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`KillSwitchCommand`不仅仅是在`Receiver`对象上调用`Execute()`函数，而是遍历一系列设备并在每个设备上调用`TurnOff()`函数。这意味着我们正在批量执行特定命令。
- en: 'Now we need to implement our devices that receive the orders to execute specific
    commands. Our first receiver is `Television`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实现接收特定命令以执行特定命令的设备。我们的第一个接收器是`Television`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our next receiver is `Radio`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下一个接收器是`Radio`：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, both receivers have implemented the `TurnOn()` and `TurnOff()`
    functions. They are thus encapsulating the details of their unique behaviors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两个接收者都实现了`TurnOn()`和`TurnOff()`函数。因此，它们封装了各自独特行为的细节。
- en: 'Furthermore, let''s implement a vital player of the `Command pattern`, `Invoker`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，让我们实现命令模式（`Command pattern`）的一个关键角色——`Invoker`：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example of `Invoker` is straightforward but can easily be extended to bookkeep
    the commands that are executed through it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Invoker`的例子很简单，但可以很容易地扩展以记录通过它执行的命令。
- en: 'Finally, we have our `Client` class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有我们的`Client`类：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will notice that there''s a specific sequence of calls to be made when
    invoking a command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在调用命令时有一个特定的调用顺序：
- en: Initialize a new Command
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的命令
- en: Pass it to `Invoker`
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其传递给`Invoker`
- en: '`Invoker` executes the specified Command'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoker`执行指定的命令'
- en: With this approach, we are maintaining a consistent channel of communication
    between those that invoke commands and those that receive them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们维护了调用命令和接收命令之间的一个一致通信渠道。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the Command pattern, a unique pattern that tends
    to confuse a lot of programmers at first because its core usefulness is not always
    apparent. But once you apply it correctly, it does offer a lot of extensibility
    when implementing systems that are dependent on executing commands in specific
    orders on multiple components.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了命令模式（Command pattern），这是一个独特的模式，一开始往往会让很多程序员感到困惑，因为它的核心用途并不总是显而易见。但一旦正确应用，它确实在实现依赖于在多个组件上按特定顺序执行命令的系统时提供了很多可扩展性。
- en: Next up is the Observer pattern, a pattern that's more easily understandable
    than Command and is the core of C#'s event system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是观察者模式（Observer pattern），这个模式比命令模式（Command）更容易理解，并且是C#事件系统的核心。
- en: Practice exercise
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习题
- en: The Command pattern is often used to implement the classic undo/redo functionality
    that you find in most text editors. In our code example, we implemented the groundwork
    to support this feature. So, as a practice exercise, I recommend that you integrate
    your own undo/redo feature. You can find cues on the best approach to this in
    the `Invoker` and `KillSwitchCommand` classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式通常用于实现大多数文本编辑器中常见的经典撤销/重做功能。在我们的代码示例中，我们实现了支持此功能的基础。因此，作为一个练习题，我建议你集成自己的撤销/重做功能。你可以在`Invoker`和`KillSwitchCommand`类中找到关于实现此功能的最佳方法的线索。
- en: Further reading
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Applying UML and Patterns,* by Craig Larman: [http://www.craiglarman.com](http://www.craiglarman.com)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《应用UML和模式》，作者：Craig Larman*：[http://www.craiglarman.com](http://www.craiglarman.com)'
