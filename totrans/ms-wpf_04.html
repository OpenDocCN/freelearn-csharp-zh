<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Becoming Proficient with Data Binding</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">In this chapter, we'll investigate the data binding syntax that is used to connect our data sources to our UI controls. We'll examine how to declare Dependency Properties, along with all of the various options that we have when doing that. We'll find out about the scope of declared bindings and unravel the finer details of data templates.</p>
<p>It is the data binding in WPF that enables it to work so well with the MVVM pattern. It provides the connection for two-way communication between the View and the View Models components. Yet this abstraction can often lead to confusion and make tracking down problems more difficult than when using traditional methods of UI to business logic communication.</p>
<p>As data binding is such an important part of the MVVM pattern, we'll cover this topic thoroughly, from the basics to advanced concepts, and we'll ensure that we are able to fulfill any binding requirements that we may receive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data binding basics</h1>
                </header>
            
            <article>
                
<p>In WPF, we use the <kbd>Binding</kbd> class to create our bindings. In general, it is fair to say that every binding will contain four constituent parts. <span><span>Let's take a look at them now:</span></span></p>
<ul>
<li>The first<span> is the binding source; typically, this will be one of our View Models. </span></li>
<li><span>The second is the path to the property from the source object that we would like to data bind to.</span></li>
<li><span>The third is the binding target; this will typically be a UI control.</span></li>
<li><span>The fourth is the path to the property of the binding target that we want to data bind to.</span></li>
</ul>
<p><span>If one of our bindings does not work, it is most likely that one of these four things has not been set correctly. </span>It is important to stress that the target property will typically be from a UI control, because there is a data binding rule that states that the binding target must be a Dependency Property. The properties of most UI controls are Dependency Properties, and so, this rule simply enforces that data normally travels in the direction from our View Model data sources to the binding target UI controls.</p>
<p>We'll examine the direction of data bound data traversal later in the chapter, but let's first focus on the syntax that is used to specify the value of the <kbd>Binding.Path</kbd> property.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding path syntax</h1>
                </header>
            
            <article>
                
<p>Bindings can be declared either in longhand, defining an actual <kbd>Binding</kbd> element in the XAML, or in shorthand, using the markup language that is translated to a <kbd>Binding</kbd> element for us by the XAML. We'll primarily focus on the shorthand notation, as that is what we will predominantly use throughout the book.</p>
<p>The <kbd>Binding.Path</kbd> property is of type <kbd>PropertyPath</kbd>. This type supports a unique syntax that can be expressed in XAML using a XAML markup extension. While it can be confusing at times, there are specific rules that we can learn to make it easier. Let's investigate.</p>
<p>To start with, let's understand that the binding path is relative to the binding source and that the binding source is typically set by the <kbd>DataContext</kbd> property, or by the path itself. In order to bind to the whole binding source, we can specify our binding like this:</p>
<pre>{Binding Path=.} </pre>
<p>It can also be specified like this:</p>
<pre>{Binding .} </pre>
<p>Most simply, we can specify our binding like this:</p>
<pre>{Binding} </pre>
<p>Note that explicitly declaring the <kbd>Path</kbd> property name in this syntax is optional when the path value is declared first. The three preceding examples are all equal. We will omit the <kbd>Path</kbd> property declaration in the bindings in this book for brevity. Let's now see the remaining property path syntax mini-language.</p>
<p>To data bind to most property paths, we use the same notation as we use in code. For example, when binding directly to the property of a data bound object, we just use the property name:</p>
<pre>{Binding PropertyName} </pre>
<p>To data bind to the property of an object that is directly referenced by a property of our binding source, we again use the same syntax that we do in code. This is known as <strong>indirect property targeting</strong>:</p>
<pre>{Binding PropertyName.AnotherPropertyName} </pre>
<p>Similarly, when data binding to an item in a collection, or a property of a collection item, we use the indexing notation from code. For example, this is how we access a property from the first item in our data bound binding source:</p>
<pre>{Binding [0].PropertyName} </pre>
<p>Of course, if we want to access the second item, we use a key of <kbd>1</kbd> and use a key value of <kbd>2</kbd> if we want the third item and so on. Likewise, to indirectly target a property of a collection item, where the collection is a property of our binding source, we use the following syntax:</p>
<pre>{Binding CollectionPropertyName[0].PropertyName} </pre>
<p>As you can see, we are freely able to combine these various syntactical options to generate more complex binding paths. Multi-dimensional collections are also accessed in the same way as we refer to them in code:</p>
<pre>{Binding CollectionPropertyName[0, 0].PropertyName} 
{Binding CollectionPropertyName[0, 0, 0].PropertyName} 
... </pre>
<p>While discussing data binding to collections, note that there is a special forward slash (<kbd>/</kbd>) syntax that we can use to access the selected item at any time:</p>
<pre>{Binding CollectionPropertyName/PropertyName} </pre>
<p>This particular example would bind to the <kbd>PropertyName</kbd> property of the current item of the collection specified by the <kbd>CollectionPropertyName</kbd> property. Let's take a quick look at a more practical example:</p>
<pre>&lt;StackPanel&gt; 
  &lt;ListBox ItemsSource="{Binding Users}" 
    IsSynchronizedWithCurrentItem="True" /&gt; 
  &lt;TextBlock Text="Selected User's Name:" /&gt; 
  &lt;TextBlock Text="{Binding Users/Name}" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>In this basic example using our <kbd>UsersViewModel</kbd>, we data bind the <kbd>Users</kbd> collection to a listbox. Underneath, we output the value of the <kbd>Name</kbd> property from the currently selected item. Note the setting of the <kbd>IsSynchronizedWithCurrentItem</kbd> property, as without it, this forward slash binding would not work correctly.</p>
<p>Try removing the <kbd>IsSynchronizedWithCurrentItem</kbd> property from the example and running the application again and you will see that the current user's name will be output initially, but not updated after changes to the selected item.</p>
<p>Setting this property to <kbd>True</kbd> will ensure that the <kbd>ItemCollection.CurrentItem</kbd> property from the <kbd>ListBox.Items</kbd> collection is updated each time the selection changes. Note that we could also achieve this same output using the <kbd>ListBox.SelectedItem</kbd> property instead of this forward slash notation:</p>
<pre>&lt;StackPanel&gt; 
  &lt;ListBox Name="ListBox" ItemsSource="{Binding Users}"  
    IsSynchronizedWithCurrentItem="True" /&gt; 
  &lt;TextBlock Text="Selected User's Name:" /&gt; 
  &lt;TextBlock Text="{Binding SelectedItem.Name, ElementName=ListBox}" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>The <kbd>IsSynchronizedWithCurrentItem</kbd> property is now not needed to update the selected user's name in the <kbd>TextBlock</kbd>, because the <kbd>SelectedItem</kbd> property will take care of that. However, setting it to <kbd>True</kbd> in this case will ensure that the first item in the <kbd>ListBox</kbd> is selected and that the <kbd>TextBlock</kbd> will initially output the name of that item's user. Let's continue looking at the forward slash notation.</p>
<p>If you are trying to data bind to a property of an item in a collection, where the collection is itself an item of a parent collection, we can use the forward slash notation multiple times in a single binding path:</p>
<pre>{Binding CollectionPropertyName/InnerCollectionPropertyName/PropertyName} </pre>
<p>To clarify, this path would bind to the <kbd>PropertyName</kbd> property of the selected item of the collection specified by the <kbd>InnerCollectionPropertyName</kbd> property, which itself is the selected item of the collection specified by the <kbd>CollectionPropertyName</kbd> property.</p>
<p>Let's move on from collections now, to Attached Properties. In order to data bind to an Attached Property, we need to use a slightly different syntax from that used in code; we need to enclose the property name in parenthesis, along with the class name:</p>
<pre>{Binding (ClassName.PropertyName)} </pre>
<p>Note that when the Attached Property is a custom-declared property, we must include the XAML namespace prefix inside the parenthesis with its separating colon:</p>
<pre>{Binding (XmlNamespacePrefix:ClassName.PropertyName)} </pre>
<p>Typically, when binding to Attached Properties, we also need to specify the binding target as well as the target property. The binding target will generally either be the object that the binding is set on, or another UI element, so we tend to see the <kbd>RelativeSource</kbd> or <kbd>ElementName</kbd> properties being used in these situations:</p>
<pre>{Binding Path=(Attached:TextBoxProperties.Label), 
  RelativeSource={RelativeSource AncestorType={x:Type TextBox}}}</pre>
<p>We'll see an extended version of this example later in the book, but in short, it binds to the <kbd>TextBoxProperties.Label</kbd> Attached Property of the parent control of type <kbd>TextBox</kbd>. It is called from within a <kbd>ControlTemplate</kbd> and so, the parent textbox is the templated parent of the control that is being data bound.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Escaping invalid characters</h1>
                </header>
            
            <article>
                
<p>When using the <kbd>PropertyPath</kbd> syntax mini-language, there may be the odd occasion when we need to escape certain characters that are used in the syntax. In general, the backslash (<kbd>\</kbd>) is used as the escape character and the only characters that we need to escape are as follows.</p>
<p>The most common character that we may need to escape in our bind paths is the closing curly bracket (<kbd>}</kbd>), which signals the end of a markup section. Also, if you need to use an actual backslash in your binding path, then you must escape it by preceding it with another backslash.</p>
<p>The only two other characters that we need to escape are the equals sign (<kbd>=</kbd>) and the comma character (<kbd>,</kbd>), which are both used to define binding paths. All other characters that we are likely to use in a binding path are deemed<span> to be</span> valid.</p>
<p>Note that there is a special character to use if we need to escape a character when inside an indexer binding expression. In these cases, instead of using the backslash character, we need to use the caret character (<kbd>^</kbd>) as the escape character.</p>
<p>Also note that when explicitly declaring bindings in XAML, we need to escape the ampersand (<kbd>&amp;</kbd>) and the greater than sign (<kbd>&gt;</kbd>) by replacing them with their XML Entity forms. If you need to use these characters, then replace the ampersand with <kbd>&amp;amp;</kbd> and replace the greater than sign with <kbd>&amp;gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the Binding class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Binding</kbd> class has more properties than we have space to discuss here, but we'll cover the most important ones in detail shortly, and briefly look at other notable properties momentarily. The <kbd>Binding</kbd> class is the top-level class in each binding, but internally it uses a lower-level class that maintains the connection between the binding source and binding target.</p>
<p>The <kbd>BindingExpression</kbd> class is that underlying object. When using MVVM, developers do not typically access this inner class, as we tend to keep our functionality in our View Models. However, if we are writing custom controls, then it can be useful to be aware of it.</p>
<p>It can be used to programmatically update the associated binding source in certain circumstances and we'll find out about that later in the chapter. For now, let's focus on what the <kbd>Binding</kbd> class can do for us.</p>
<p>In .NET 4.5, a great new property was added to the <kbd>Binding</kbd> class. The <kbd>Delay</kbd> property enables us to specify an amount of time in milliseconds with which to delay the update of the binding source after a change has been made to the binding target property value.</p>
<p>This is really useful if we are performing some heavy computational validation or other processing dependent upon the user's input in a <kbd>TextBox</kbd> element for example. To clarify this functionality further, this delay is actually restarted each time the data bound property value changes, or each key press in our example. It is typically used to update the binding source in chunks, each time the user pauses, or completes typing, somewhat like buffering:</p>
<pre>&lt;TextBox Text="{Binding Description, 
  UpdateSourceTrigger=PropertyChanged, Delay=400}" /&gt; </pre>
<p>The <kbd>FallbackValue</kbd> property is another useful property when it comes to performance. In order to return a value from each binding, the WPF Framework does up to four things. The first is to simply validate the target property type with the data bound value. If successful, it will then try to resolve the binding path.</p>
<p>Most of the time, this will work, but if not, it will then attempt to find a converter to return the value. If it can't find one, or the located converter returns the <kbd>DependencyProperty.UnsetValue</kbd> value, <span>it will then look to see if the</span> <kbd>FallbackValue</kbd> <span>property has a value to provide it with. If there is no fallback value, then a lookup is required to find the default value of the target Dependency Property.</span></p>
<p>By setting the <kbd>FallbackValue</kbd> property, we can do two things to improve performance, albeit in a slight way. The first is that, it will stop the WPF Framework from performing the lookup of the default value of the target Dependency Property. The second is that it will prevent trace statements from being fed to the <span class="packt_screen">Output</span> window in Visual Studio and to any other trace outputs that have been setup.</p>
<p>The <kbd>TargetNullValue</kbd> property is similar to the <kbd>FallbackValue</kbd> property in that it enables us to provide some output when there is no data bound value from the binding source. The difference is that the <kbd>FallbackValue</kbd> property value is output when a data bound value cannot be resolved, while the <kbd>TargetNullValue</kbd> property value is used when the successfully resolved data bound value is <kbd>null</kbd>.</p>
<p>We can use this functionality to display a more humanized value than <kbd>null</kbd>, or even to provide a default message in our textbox controls for example. To do this, we could set our data bound <kbd>string</kbd> properties to <kbd>null</kbd> and set a suitable value to the <kbd>TargetNullValue</kbd> property:</p>
<pre>&lt;TextBox Text="{Binding Name, TargetNullValue='Please enter your name'}" /&gt;</pre>
<p>Of course, this message will actually appear in the <kbd>TextBox</kbd> control, so it's not an ideal way of providing this functionality. We'll see a better example of this later in the book, but now, let's continue our exploration of the <kbd>Binding</kbd> class.</p>
<p>If we have any properties in our View Model that access their data asynchronously, or if they are calculated by a heavy computational process, then we need to set the <kbd>IsAsync</kbd> method to <kbd>True</kbd> on the binding:</p>
<pre>&lt;Image Source="{Binding InternetSource, IsAsync=True, 
  FallbackValue='pack://application:,,,/CompanyName.ApplicationName;
  component/Images/Default.png'}" /&gt; </pre>
<p>This stops the UI from being blocked while waiting for the data bound property to be calculated, or otherwise resolved. Until the binding source is resolved, the fallback value is used, if set, or the default value will be used otherwise. In this example, we are providing a default image to be displayed until the actual image is downloaded from the internet and the binding source is resolved.</p>
<p>Another useful property of the <kbd>Binding</kbd> class is the <kbd>StringFormat</kbd> property. As the name hints, this uses the <kbd>string.Format</kbd> method internally to format our data bound text output. There are, however, a few caveats to using this functionality. The first is that we can only use a single format item, that is represented by the single data bound value in a normal binding. We'll find out how to use multiple values later in the chapter.</p>
<p>Secondly, we need to declare our format carefully, as curly brackets are used by the markup extensions and we cannot use the double quote characters (<kbd>"</kbd>), as the binding is already declared within double quotes. One solution is to use single quotes to surround our format string:</p>
<pre>&lt;TextBlock Text="{Binding Price, StringFormat='{0:C2}'}" /&gt; </pre>
<p>Another option is to escape the format by preceding it with a pair of curly brackets:</p>
<pre>&lt;TextBlock Text="{Binding Price, StringFormat={}{0:C2}}" /&gt; </pre>
<p>Most of the useful binding properties have now been discussed here, but it should be noted that there are a number of properties in the <kbd>Binding</kbd> class that are not typically used when building a WPF application with MVVM. This is because they involve event handlers and we do not normally implement event handlers when using MVVM.</p>
<p>For example, the three <kbd>NotifyOnSourceUpdated</kbd>, <kbd>NotifyOnTargetUpdated</kbd> and <kbd>NotifyOnValidationError</kbd> properties relate to the raising of the <kbd>Binding.SourceUpdated</kbd>, <kbd>Binding.TargetUpdated</kbd> and <kbd>Validation.Error</kbd> Attached Events.</p>
<p>Likewise, the three <kbd>ValidatesOnDataErrors</kbd>, <kbd>ValidatesOnExceptions</kbd>, <kbd>ValidatesOnNotifyDataErrors</kbd> and <kbd>ValidationRules</kbd> properties all relate to the use of the <kbd>ValidationRule</kbd> class. This is a very UI-related way of validating, but this puts our business logic right into our Views component.</p>
<p>When using MVVM, we want to avoid this blending of components. We therefore tend to work with data elements rather than UI elements, and so we perform these kind of duties in our Data Model and/or View Model classes instead. We'll see this in <a href="549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Implementing Responsive Data Validation</em>, later in the book, but now let's take a deeper look at the most important properties of the <kbd>Binding</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Directing data bound traffic</h1>
                </header>
            
            <article>
                
<p>The direction of data traversal in each binding is specified by the <kbd>Binding.Mode</kbd> property. There are four distinct directional instances declared in the <kbd>BindingMode</kbd> enumeration, plus an additional value. Let's first take a look at the directional values and what they represent.</p>
<p>The first and most common value reflects the most common situation, where data flows from the binding source, say, one of our View Models, to the binding target, represented by a UI control. This binding mode is called <strong>One-Way</strong> and is specified by the <kbd>OneWay</kbd> enumeration instance. This mode is used primarily for display only, or read-only purposes, and situations where the data bound values cannot be altered in the UI.</p>
<p>The next most common direction of travel is represented by the <kbd>TwoWay</kbd> enumeration instance and signifies that data is free to travel both from our View Models to the UI controls and also in the opposite direction. This is the most commonly used mode when data binding to form controls, when we want the users' changes to be reflected in our View Models.</p>
<p>The third directional enumeration instance is the <kbd>OneWayToSource</kbd> instance and is the opposite to the <kbd>OneWay</kbd> instance. That is, it specifies that data can only travel from the binding target, represented by a UI control, to the binding source, for example, one of our View Models. This mode is also useful for capturing user inputted date, when we don't need to alter the data bound values.</p>
<p>The final directional instance is similar to the <kbd>OneWay</kbd> instance, except that it only works once and is represented by the <kbd>OneTime</kbd> instance. While this mode will indeed only work one time, upon instantiation of its containing control, it will actually also update its value each time the <kbd>DataContext</kbd> property of the relevant binding is set. However, its purpose is that it provides better performance than the <kbd>OneWay</kbd> member and is only suitable for binding to non-changing data, so if the data will be updated, this is not the correct directional instance to use.</p>
<p>The final instance is named <kbd>Default</kbd> and as the name hints, is the default value of the <kbd>Binding.Mode</kbd> enumeration. It directs the binding to use the binding mode that was declared from the specified target property. When each Dependency Property is declared, we can specify whether a One or <strong>Two<span class="MsoCommentReference">-W</span>ay</strong> binding mode should be used by default. If this is not specifically declared, then the property will be assigned a One-Way mode. We'll see this explained in more detail later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding to different sources</h1>
                </header>
            
            <article>
                
<p>We generally set the binding source using the <kbd>FrameworkElement.DataContext</kbd> property. All UI controls extend the <kbd>FrameworkElement</kbd> class, so we can set our binding sources on any of them. This must be set for a binding to work, although it can be specified in the <kbd>Path</kbd> property, or inherited from ancestor controls, so it does not have to be explicitly set. Take a look at this simple example, which assumes that a suitable binding source has been correctly set on the parent control:</p>
<pre>&lt;StackPanel&gt; 
  &lt;TextBlock DataContext="{Binding User}" Text="{Binding Name}" /&gt; 
  &lt;TextBlock DataContext="{Binding User}" Text="{Binding Age}" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>Here, we set the binding source of the first <kbd>TextBlock</kbd> to a <kbd>User</kbd> object and the path to the <kbd>Name</kbd> property from that source. The second is set likewise, but with the binding source path pointing to the <kbd>Age</kbd> property instead. Note that we have set the <kbd>DataContext</kbd> property to a <kbd>User</kbd> object on each <kbd>TextBox</kbd> control individually.</p>
<p>While this is perfectly valid XAML, you can imagine how tiresome it would be to do this on every control that we want to data bind to in a large form. As such, we tend to take advantage of the fact that the <kbd>DataContext</kbd> property can inherit its value from any of its ancestor controls. In this way, we can simplify this code by setting the <kbd>DataContext</kbd> on the parent control instead:</p>
<pre>&lt;StackPanel DataContext="{Binding User}"&gt; 
  &lt;TextBlock Text="{Binding Name}" /&gt; 
  &lt;TextBlock Text="{Binding Age}" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>In fact, when developing each <kbd>Window</kbd> or <kbd>UserControl</kbd>, it is customary to set the <kbd>DataContext</kbd> on these top-level controls, so that every contained control will have access to the same binding source. This is why we create a View Model for each <kbd>Window</kbd> or <kbd>UserControl</kbd> and specify that each View Model is responsible for providing all of the data and functionality that its related View requires.</p>
<p>There are a few alternative ways of specifying a binding source, other than setting the <kbd>DataContext</kbd> property. One way is to use the <kbd>Source</kbd> property of the binding and this enables us to explicitly override the binding source that is inherited from the parent <kbd>DataContext</kbd>, if one was set. Using the <kbd>Source</kbd> property, we are also able to data bind to resources, as we saw in our View Model Locator example, or static values, as shown in the following snippet:</p>
<pre>&lt;TextBlock Text="{Binding Source={x:Static System:DateTime.Today}, 
  Mode=OneTime, StringFormat='{}© {0:yyyy} CompanyName'}" /&gt; </pre>
<p>Another way involves the use of the <kbd>RelativeSource</kbd> property of the binding. Using this incredibly useful property of type <kbd>RelativeSource</kbd>, we can specify that we want to use the target control, or a parent of that control as the binding source.</p>
<p>It also enables us to override the binding source from the <kbd>DataContext</kbd> and is often essential when trying to data bind to View Model properties from <kbd>DataTemplate</kbd> elements. Let's adjust the earlier <kbd>DataTemplate</kbd> for our <kbd>User</kbd> Data Model to output a property from its normal <kbd>DataContext</kbd> that is set by the <kbd>DataTemplate</kbd>, and one from the View Model that is set as the <kbd>DataContext</kbd> of the parent control, using the <kbd>AncestorType</kbd> property of the <kbd>RelativeSource</kbd> class:</p>
<pre>&lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
  &lt;StackPanel&gt; 
    &lt;TextBlock Text="{Binding Name}" /&gt; 
    &lt;TextBlock Text="{Binding DataContext.UserCount,   
      RelativeSource={RelativeSource Mode=FindAncestor, 
      AncestorType={x:Type Views:UserView}}}" /&gt; 
  &lt;/StackPanel&gt; 
&lt;/DataTemplate&gt; </pre>
<p>Note that setting the <kbd>Mode</kbd> property, that specifies the relative position of the binding source compared to the binding target, is optional here. Using the <kbd>AncestorType</kbd> property implicitly sets the <kbd>Mode</kbd> property to the <kbd>FindAncestor</kbd> instance, so we can declare the same binding without it, like this:</p>
<pre>&lt;TextBlock Text="{Binding DataContext.UserCount,  
  RelativeSource={RelativeSource 
  AncestorType={x:Type Views:UserView}}}" /&gt; </pre>
<p>The <kbd>Mode</kbd> property is of the <kbd>RelativeSourceMode</kbd> enumeration type, which has four members. We've already seen an example of one instance, the <kbd>FindAncestor</kbd> member, although this can be extended using the related <kbd>RelativeSource.AncestorLevel</kbd> property, which specifies which level of ancestor in which to look for the binding source. This property is only really useful if a control has multiple ancestors of the same type, as in this following simplified example:</p>
<pre>&lt;StackPanel Tag="Outer"&gt; 
  ... 
  &lt;StackPanel Orientation="Horizontal" Tag="Inner"&gt; 
    &lt;TextBlock Text="{Binding Tag, RelativeSource={RelativeSource 
      Mode=FindAncestor, AncestorType={x:Type StackPanel}, 
      AncestorLevel=2}}" /&gt; 
    ... 
  &lt;/StackPanel&gt; 
&lt;/StackPanel&gt; </pre>
<p>The <kbd>TextBox</kbd> in this example will output the word <kbd>"Outer"</kbd> at runtime because we have declared that the binding source should be the second ancestor of type <kbd>StackPanel</kbd>. If the <kbd>AncestorLevel</kbd> property had been set to one or omitted from the binding, then the <kbd>TextBox</kbd> would output the word <kbd>"Inner"</kbd> at runtime.</p>
<p>The next <kbd>RelativeSourceMode</kbd> enumeration instance is <kbd>Self</kbd>, which specifies that the binding source is the same object as the binding target. Note that when using the <kbd>RelativeSource</kbd><kbd>.Self</kbd> property, the <kbd>Mode</kbd> property is implicitly set to the <kbd>Self</kbd> instance. We could use this property to data bind one property of a UI control to another, as in this following example, which sets the control's width value to its <kbd>Height</kbd> property to ensure that it remains a square regardless of the width:</p>
<pre>&lt;Rectangle Height="{Binding ActualWidth, 
  RelativeSource={RelativeSource Self}}" Fill="Red" /&gt; </pre>
<p>The <kbd>RelativeSource.TemplatedParent</kbd> property is only used to access the properties of controls from inside a <kbd>ControlTemplate</kbd>. The templated parent refers to the object that has the <kbd>ControlTemplate</kbd> applied to it. When using the <kbd>TemplatedParent</kbd> property, the <kbd>Mode</kbd> property is implicitly set to the <kbd>TemplatedParent</kbd> instance of the <kbd>RelativeSourceMode</kbd> enumeration. Let's see an example:</p>
<pre>&lt;ControlTemplate x:Key="ProgressBar" TargetType="{x:Type ProgressBar}"&gt; 
  ... 
  &lt;TextBlock Text="{Binding Value, 
    RelativeSource={RelativeSource TemplatedParent}}" /&gt; 
  ... 
&lt;/ControlTemplate&gt; </pre>
<p>In this example, the templated parent is the instance of the <kbd>ProgressBar</kbd> that will have this template applied to it and so, using the <kbd>TemplatedParent</kbd> property, we are able to access the various properties of the <kbd>ProgressBar</kbd> class from within the <kbd>ControlTemplate</kbd>. Furthermore, any binding source that is data bound to the <kbd>Value</kbd> property of the templated parent will also be data bound to the <kbd>Text</kbd> property of this internal <kbd>TextBox</kbd> element.</p>
<p>Moving on to the final <kbd>RelativeSource</kbd> property, <kbd>PreviousData</kbd> is only really useful when defining a <kbd>DataTemplate</kbd> for items in a collection. It is used to set the previous item in the collection as the binding source. While not often used, there can be situations where we need to compare values between neighboring items in a collection and we'll see a full example of this later in this chapter.</p>
<p>Although a far simpler option, the <kbd>ElementName</kbd> property of the <kbd>Binding</kbd> class also enables us to override the binding source set by the <kbd>DataContext</kbd>. It is used to data bind the property of one UI control to either the property of another control, or another property on the same control. The only requirement to use this property is that we need to name the element that we want to data bind to in our current control. Let's see an example:</p>
<pre>&lt;StackPanel Orientation="Horizontal" Margin="20"&gt; 
  &lt;CheckBox Name="Checkbox" Content="Service" Margin="0,0,10,0" /&gt; 
  &lt;TextBox Text="{Binding Service}" 
    Visibility="{Binding IsChecked, ElementName=Checkbox, 
    Converter={StaticResource BoolToVisibilityConverter}}" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>In this example, we have a <kbd>CheckBox</kbd> element and a <kbd>TextBlock</kbd> <span>element.</span> The <kbd>Visibility</kbd> property of the <kbd>TextBlock</kbd> <span>element </span>is data bound to the <kbd>IsChecked</kbd> property of the <kbd>CheckBox</kbd> <span>element </span>and we make use of the <kbd>BoolToVisibilityConverter</kbd> class that we saw earlier to convert the <kbd>bool</kbd> value to a <kbd>Visibility</kbd> instance. Therefore, when the user checks the <kbd>CheckBox</kbd><span> element</span>, the <kbd>TextBlock</kbd><span> </span><span>element</span> will become visible.</p>
<p>The <kbd>ElementName</kbd> property can also be used as a shortcut to access the parent control's <kbd>DataContext</kbd>. If we name our View <kbd>This</kbd> for example, then we can use the <kbd>ElementName</kbd> property from within a data template to data bind to a property from the parent View Model:</p>
<pre>&lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
  &lt;StackPanel&gt; 
    &lt;TextBlock Text="{Binding Name}" /&gt; 
    &lt;TextBlock Text="{Binding DataContext.UserCount, ElementName=This}" /&gt; 
  &lt;/StackPanel&gt; 
&lt;/DataTemplate&gt; </pre>
<p>When specifying these alternative binding sources, it is important to know that we can only use one of these three different methods at once. If we were to set more than one of the binding <kbd>Source</kbd>, <kbd>RelativeSource</kbd>, or <kbd>ElementName</kbd> properties, then an exception would be thrown from the binding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding with priority</h1>
                </header>
            
            <article>
                
<p>On the odd occasion, we may need to specify a number of source binding paths and want to map them to a single binding target property. One way that we can do this is to use the <kbd>MultiBinding</kbd> class and we'll see an example of this in the last section of this chapter. However, there is an alternative class that we can use that provides us with some additional functionality.</p>
<p>The <kbd>PriorityBinding</kbd> class enables us to specify multiple bindings and gives each a priority, with the bindings that are declared first having the highest priority. The special functionality of this class is that it will display the value from the first binding that returns a valid value and if that is not the binding with the highest priority, it will then update the display with the value from the highest priority binding when it is successfully resolved.</p>
<p>To clarify further, this enables us to specify a binding to a normal property that will resolve immediately, while the actual value that we want to data bind to is being downloaded, calculated, or otherwise being resolved over time. This enables us to supply a default image source while the actual required image is being downloaded, or to output a message until a calculated value is ready for display. Let's look at a simple XAML example:</p>
<pre>&lt;TextBlock&gt; 
  &lt;TextBlock.Text&gt; 
    &lt;PriorityBinding&gt; 
      &lt;Binding Path="SlowString" IsAsync="True" /&gt; 
      &lt;Binding Path="FastString" Mode="OneWay" /&gt; 
    &lt;/PriorityBinding&gt; 
  &lt;/TextBlock.Text&gt; 
&lt;/TextBlock&gt; </pre>
<p>In the preceding example, we set the <kbd>PriorityBinding</kbd> on the <kbd>TextBlock.Text</kbd> property and inside, specify two bindings. The first has the higher priority and has the actual property value that we want to display. Note that we set the <kbd>IsAsync</kbd> property to <kbd>True</kbd>, to specify that this binding will take some time to resolve and that it should not block the UI thread.</p>
<p>The second binding is data bound to a normal property using a One-Way binding that simply outputs a message:</p>
<pre>public string FastString 
{ 
  get { return "The value is being calculated..."; } 
} </pre>
<p>By using the <kbd>PriorityBinding</kbd> element, this message will be output instantly and then updated with the actual value from the <kbd>SlowString</kbd> property when it is ready. Let's now move on and investigate one further type of <kbd>Binding</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding from within control templates</h1>
                </header>
            
            <article>
                
<p>A <kbd>TemplateBinding</kbd> is a particular type of binding that is used within <kbd>ControlTemplate</kbd> elements in order to data bind to the properties of the type that is being templated. It is very similar to the <kbd>RelativeSource.TemplatedParent</kbd> property that we discussed earlier:</p>
<pre>&lt;ControlTemplate x:Key="ProgressBar" TargetType="{x:Type ProgressBar}"&gt; 
  ... 
  &lt;TextBlock Text="{TemplateBinding Value}" /&gt; 
  ... 
&lt;/ControlTemplate&gt; </pre>
<p>In this example from earlier that we have edited slightly, we see that declaring a <kbd>TemplateBinding</kbd> is far more straightforward and less verbose than performing the same binding using the <kbd>RelativeSource.TemplatedParent</kbd> property. Let's remind ourselves what that looked like:</p>
<pre>&lt;TextBlock Text="{Binding Value, 
  RelativeSource={RelativeSource TemplatedParent}}" /&gt; </pre>
<p>If possible, it is generally preferable to use a <kbd>TemplateBinding</kbd> instead of the <kbd>RelativeSource.TemplatedParent</kbd> property and although they perform the same connection in the binding, there are a few differences between them. For example, a <kbd>TemplateBinding</kbd> is evaluated at compile time, which enables faster instantiation of control templates, whereas a <span><kbd>TemplatedParent</kbd> binding </span>is not evaluated until runtime.</p>
<p>Furthermore, it is a simpler form of binding and is missing a number of the <kbd>Binding</kbd> class properties, such as <kbd>StringFormat</kbd> and <kbd>Delay</kbd>. In addition, it places the extra constraints on the user, that it is permanently set to have a binding mode of <kbd>OneWay</kbd> and both binding target <em>and</em> binding source must be Dependency Properties. It was designed to be used in a single place with a single purpose and in that situation, it does its job well and more efficiently than its counterpart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding source changes</h1>
                </header>
            
            <article>
                
<p>At times, we may need to make changes to our binding sources and have those changes propagate to the binding target controls. We may want to set default values on a new form, clear old form values, or even set form labels from our View Models. In order to do this, our View Models <em>must</em> implement the <kbd>INotifyPropertyChanged</kbd> interface and this is why we build this implementation into our base View Model class.</p>
<p>When we data bind a binding source to a control in the UI, an event handler is attached to the <kbd>PropertyChanged</kbd> event of the source object. When a notification of a change to the property that is specified by the binding source property path is received, the control is updated with the new value.</p>
<p>It should be noted that the <kbd>PropertyChanged</kbd> event of the binding source will be <kbd>null</kbd> if no handler has specifically been attached and none of its properties have been data bound to UI controls. It is for this reason that we must always check for <kbd>null</kbd>, before raising this event.</p>
<p>All of the binding modes work in the direction of binding source to binding target, except for the <kbd>OneWayToSource</kbd> instance. However, only this and the <kbd>TwoWay</kbd> instance of the <kbd>Binding.Mode</kbd> enumeration propagate changes in the direction of the binding target to the binding source.</p>
<p>When the binding is working in either of these modes, it attaches a handler to the target control to listen for changes to the target property. When it receives notification of a change to the target property, its behavior is determined by the value of the binding's <kbd>UpdateSourceTrigger</kbd> property.</p>
<p>This property is of the enumeration type <kbd>UpdateSourceTrigger</kbd>, which has four members. The most common is the <kbd>PropertyChanged</kbd> instance and this specifies that the source property should be updated as soon as the target property has changed. This is the default value for most controls.</p>
<p>The <kbd>LostFocus</kbd> member is the next most common value and this specifies that the binding should update the binding source when the user moves focus from the data bound control. This option can be useful when we want to trigger validation once the user has completed entry in each textbox, rather than as they type.</p>
<p>The <kbd>Explicit</kbd> instance will not update the binding source without explicit instruction to do so. As we need to programmatically call the <kbd>UpdateSource</kbd> method of the internal <kbd>BindingExpression</kbd> object in order to propagate the changes to the binding source, this option is not generally used in our normal Views.</p>
<p>Instead, if used at all, we would find it in our <kbd>CustomControl</kbd> classes. Note that calling the <kbd>UpdateSource</kbd> method will do nothing if the binding mode is not set to one of the <kbd>OneWayToSource</kbd> or <kbd>TwoWay</kbd> instances.</p>
<p>If we had an instance of a textbox and we wanted to explicitly update the binding source that was data bound to its <kbd>Text</kbd> property, we can access the lower-level <kbd>BindingExpression</kbd> object from the <kbd>BindingOperations.GetBindingExpression</kbd> method and call its <kbd>UpdateSource</kbd> method:</p>
<pre>BindingExpression bindingExpression = 
  BindingOperations.GetBindingExpression(textBox, TextBox.TextProperty); 
bindingExpression.UpdateSource(); </pre>
<p>Alternatively, if our binding target control class extends the <kbd>FrameworkElement</kbd> class and most do, then we can simply call the <kbd>GetBindingExpression</kbd> method on it directly and pass in the Dependency Property key that we want to update the binding from:</p>
<pre>textBox.GetBindingExpression(TextBox.TextProperty); </pre>
<p>The last member of the <kbd>UpdateSourceTrigger</kbd> enumeration is the <kbd>Default</kbd> instance. This is similar to the <kbd>Default</kbd> instance of the <kbd>Binding.Mode</kbd> enumeration in that it uses the value specified by each target Dependency Property and is the default value of the <kbd>UpdateSourceTrigger</kbd> property. Again, we'll find out how to set the metadata for Dependency Properties later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting data bound values</h1>
                </header>
            
            <article>
                
<p>There are many times when developing a WPF application, when we need to convert a data bound property value to a different type. For example, we might want to control the visibility of some UI elements with a <kbd>bool</kbd> property in our View Model, so that we can avoid having the UI-related <kbd>Visibility</kbd> enumeration instance in it.</p>
<p>We might want to convert different enumeration members to different <kbd>Brush</kbd> objects, or collections to <kbd>string</kbd> representations of the contained collection items. We've already seen a number of examples of the <kbd>IValueConverter</kbd> interface, but let's now take a bit more of a thorough look:</p>
<pre>public interface IValueConverter 
{ 
  object Convert(object value, Type targetType, object parameter,  
    CultureInfo culture); 
  object ConvertBack(object value, Type targetType, object parameter,  
    CultureInfo culture); 
} </pre>
<p>As we've already seen, the <kbd>value</kbd> input parameter of type <kbd>object</kbd> is the data bound value of the binding. The <kbd>object</kbd> return type relates to the converted value that we want to return. The <kbd>targetType</kbd> input parameter specifies the type of the binding target property and is typically used to validate the input value to ensure that the converter is being used with the expected type of data.</p>
<p>The <kbd>parameter</kbd> input parameter is optionally used to pass an additional value through to the converter. If used, its value can be set using the <kbd>Binding.ConverterParameter</kbd> property. Finally, the <kbd>culture</kbd> input parameter provides us with a <kbd>CultureInfo</kbd> object to correctly format textual output, when working in a culturally-sensitive application. We'll return to this in a moment, but let's first look at an example of a converter that uses the <kbd>parameter</kbd> input parameter:</p>
<pre>using System; 
using System.Globalization; 
using System.Windows; 
using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  [ValueConversion(typeof(Enum), typeof(bool))] 
  public class EnumToBoolConverter : IValueConverter 
  { 
    public bool IsInverted { get; set; } 
 
    public object Convert(object value, Type targetType, object parameter,
      CultureInfo culture) 
    { 
      if (value == null || parameter == null || (value.GetType() !=
        typeof(Enum) &amp;&amp; value.GetType().BaseType != typeof(Enum)))  
        return DependencyProperty.UnsetValue; 
      string enumValue = value.ToString(); 
      string targetValue = parameter.ToString(); 
      bool boolValue = enumValue.Equals(targetValue,  
        StringComparison.InvariantCultureIgnoreCase); 
      return IsInverted ? !boolValue : boolValue; 
    } 
 
    public object ConvertBack(object value, Type targetType, 
      object parameter, CultureInfo culture)
    { 
      if (value == null || parameter == null) 
        return DependencyProperty.UnsetValue; 
      bool boolValue = (bool)value; 
      string targetValue = parameter.ToString(); 
      if ((boolValue &amp;&amp; !IsInverted) || (!boolValue &amp;&amp; IsInverted))  
        return Enum.Parse(targetType, targetValue); 
      return DependencyProperty.UnsetValue; 
    } 
  } 
} </pre>
<p>The idea of this converter is that we can data bind an enumeration property to a <kbd>RadioButton</kbd> or <kbd>CheckBox</kbd> control that specifies the name of a particular member. If the value of the data bound property matches the specified member, then the converter will return true and check the control. For all other enumeration members, the control will be unchecked. We could then specify a different member in each of a group of <kbd>RadioButton</kbd> controls, so that each member could be set.</p>
<p>In the class, we start by specifying the data types that are involved in the implementation of the converter in the <kbd>ValueConversion</kbd> attribute. Next, we see the <kbd>IsInverted</kbd> property that we saw in the <kbd>BaseVisibilityConverter</kbd> class that enables us to invert the output of the converter.</p>
<p>In the <kbd>Convert</kbd> method, we first check the validity of our <kbd>value</kbd> and <kbd>parameter</kbd> input parameters, and return the <kbd>DependencyProperty.UnsetValue</kbd> value if either are invalid. For valid values, we convert both parameters to their <kbd>string</kbd> representations. We then create a <kbd>bool</kbd> value by comparing the two <kbd>string</kbd> values. Once we have our <kbd>bool</kbd> value, we use it in conjunction with the <kbd>IsInverted</kbd> property to return the output value.</p>
<p>As with our other enumeration converter example, the <kbd>ConvertBack</kbd> method implementation is a little different again, as we are unable to return the correct enumeration instance for a false value; it could be any value except the value specified by the <kbd>parameter</kbd> input parameter.</p>
<p>As such, we are only able to return the specified enumeration instance if the data bound value is true and the <kbd>IsInverted</kbd> property is false, or if it is false and the <kbd>IsInverted</kbd> property is true. For all other input values, we simply return the <kbd>DependencyProperty.UnsetValue</kbd> property, which is preferred by the property system rather than the <kbd>null</kbd> value.</p>
<p>Let's see an example of this in use, with the <kbd>BitRate</kbd> enumeration that we saw in the previous chapter. Let's first look at the simple View Model:</p>
<pre>using System.Collections.ObjectModel; 
using CompanyName.ApplicationName.DataModels.Enums;  
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.ViewModels 
{ 
  public class BitRateViewModel : BaseViewModel 
  { 
    private ObservableCollection&lt;BitRate&gt; bitRates = 
      new ObservableCollection&lt;BitRate&gt;();
    private BitRate bitRate = BitRate.Sixteen; 
 
    public BitRateViewModel() 
    { 
      bitRates.FillWithMembers(); 
    } 
 
    public ObservableCollection&lt;BitRate&gt; BitRates 
    { 
      get { return bitRates; } 
      set { if (bitRates != value) { bitRates = value; 
        NotifyPropertyChanged(); } } 
    } 
 
    public BitRate BitRate 
    { 
      get { return bitRate; } 
      set { if (bitRate != value) { bitRate = value;  
        NotifyPropertyChanged(); } } 
    } 
  } 
}</pre>
<p>This class just contains a collection of type <kbd>BitRate</kbd>, which will hold all possible members and a selection property of type <kbd>BitRate</kbd>, which we will data bind to the various <kbd>RadioButton</kbd> elements using our new converter.</p>
<p>Note the use of the <kbd>FillWithMembers</kbd> Extension Method in the constructor. Let's see that <span>first:</span></p>
<pre>public static void FillWithMembers&lt;T&gt;(this ICollection&lt;T&gt; collection) 
{ 
  if (typeof(T).BaseType != typeof(Enum)) 
    throw new ArgumentException("The FillWithMembers&lt;T&gt; method can only be
    called with an enum as the generic type.");
  collection.Clear(); 
  foreach (string name in Enum.GetNames(typeof(T)))  
    collection.Add((T)Enum.Parse(typeof(T), name)); 
} </pre>
<p>In the <kbd>FillWithMembers</kbd> Extension Method, we first check that the collection that the method is called on is of an enumeration type and throw an <kbd>ArgumentException</kbd> if it's not. We then clear the collection, in case it has any pre-existing items in it. Finally, we iterate through the result of the <kbd>Enum.GetNames</kbd> method, parsing each <kbd>string</kbd> name to the relevant enumeration member and casting it to the correct type, before adding it to the collection.</p>
<p>Let's now see the XAML for the View:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.BitRateView"
   
   
  xmlns:Converters="clr-namespace:CompanyName.ApplicationName.Converters; 
    assembly=CompanyName.ApplicationName.Converters"&gt; 
  &lt;UserControl.Resources&gt; 
    &lt;Converters:EnumToBoolConverter x:Key="EnumToBoolConverter" /&gt; 
  &lt;/UserControl.Resources&gt; 
  &lt;GroupBox Header="Audio Quality" HorizontalAlignment="Left" 
    VerticalAlignment="Top" Padding="5"&gt; 
    &lt;StackPanel&gt; 
      &lt;RadioButton Content="16 bits" IsChecked="{Binding BitRate,  
        Converter={StaticResource EnumToBoolConverter},  
        ConverterParameter=Sixteen}" VerticalContentAlignment="Center" /&gt; 
      &lt;RadioButton Content="24 bits" IsChecked="{Binding BitRate,  
        Converter={StaticResource EnumToBoolConverter}, ConverterParameter=
        TwentyFour}" VerticalContentAlignment="Center" /&gt; 
      &lt;RadioButton Content="32 bits" IsChecked="{Binding BitRate,  
        Converter={StaticResource EnumToBoolConverter},  
        ConverterParameter=ThirtyTwo}" VerticalContentAlignment="Center" /&gt; 
    &lt;/StackPanel&gt; 
  &lt;/GroupBox&gt; 
&lt;/UserControl&gt; </pre>
<p>In this View, we set up the <kbd>Converters</kbd> XAML namespace prefix and then declare an instance of the <kbd>EnumToBoolConverter</kbd> class in the <kbd>Resources</kbd> section. We then declare a <kbd>StackPanel</kbd> containing three <kbd>RadioButton</kbd> elements inside a <kbd>GroupBox</kbd>. Each <kbd>RadioButton</kbd> element is data bound to the same <kbd>BitRate</kbd> property from our View Model, using the converter from the resources.</p>
<p>Each button specifies a different enumeration member in its binding's <kbd>ConverterParameter</kbd> property and this is passed through to the converter in the <kbd>parameter</kbd> input parameter. If a <kbd>RadioButton</kbd> is checked, its true value is passed to the converter and converted to the value specified by its <kbd>ConverterParameter</kbd> value and the <kbd>BitRate</kbd> property is updated with that value. The output of this code looks like the following figure:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1995 image-border" src="assets/c1662d27-2e6f-465f-8a7a-c4f855859850.png" style="width:12.33em;height:11.00em;"/></div>
<p>Note that if we had a large number of enumeration members, or the members were changed regularly, declaring each one manually in the UI like this example might not be such a good idea. In these cases, we could generate the same UI with less work, utilizing a <kbd>DataTemplate</kbd> object. We'll see an example of this later in this chapter, but for now, let's return to the input parameters of our converter.</p>
<p>The final input parameter in the <kbd>Convert</kbd> and <kbd>ConvertBack</kbd> methods is the <kbd>culture</kbd> parameter of type <kbd>CultureInfo</kbd>. In non-international applications, we can simply ignore this parameter, however if globalization plays a part in your application, then using this parameter is essential.</p>
<p>It enables us to correctly format any textual output that we may have in our converter using the <kbd>object.ToString</kbd> method and keep it in line with the rest of the text in the application. We can also use it in the various <kbd>Convert</kbd> class methods to ensure that numerals are also correctly output in the right format. Globalization is beyond the scope of this book and so we'll move on now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding multiple sources to a single target property</h1>
                </header>
            
            <article>
                
<p>In WPF, there is another, more common way to data bind to multiple binding sources at once and to perform some sort of conversion from the various values to a single output value. In order to achieve this, we need to use a <kbd>MultiBinding</kbd> object in conjunction with a class that implements the <kbd>IMultiValueConverter</kbd> interface.</p>
<p>The <kbd>MultiBinding</kbd> class enables us to declare multiple binding sources and a single binding target. If the <kbd>Mode</kbd> or <kbd>UpdateSourceTrigger</kbd> properties of the <kbd>MultiBinding</kbd> class are set, then their values are inherited by the contained <kbd>binding</kbd> elements, unless they have different values set explicitly.</p>
<p>The values from the multiple binding sources can be combined in one of two ways; their <kbd>string</kbd> representations can be output using the <kbd>StringFormat</kbd> property, or we can use a class that implements the <kbd>IMultiValueConverter</kbd> interface to generate the output value. This interface is very similar to the <kbd>IValueConverter</kbd> interface, but works with multiple data bound values instead.</p>
<p>When implementing the <kbd>IMultiValueConverter</kbd> interface, we do not set the <kbd>ValueConversion</kbd> attribute that we are accustomed to setting in the <kbd>IValueConverter</kbd> implementations that we have created.</p>
<p>In the <kbd>Convert</kbd> method that we need to implement, the <kbd>value</kbd> input parameter of type <kbd>object</kbd> from the <kbd>IValueConverter</kbd> interface is replaced by an <kbd>object</kbd> array named <kbd>values</kbd>, which contains our input values.</p>
<p>In the <kbd>ConvertBack</kbd> method, we have an array of type <kbd>Type</kbd> for the types of the binding targets and one of type <kbd>object</kbd> for the return types. Apart from these slight differences, these two interfaces are the same. Let's look at an example to help clarify the situation.</p>
<p>Imagine a scenario where a healthcare application needs to display a patient's weight measurements over time. It would be helpful if we could output an indicator of whether each consecutive measurement was higher or lower than the previous one, to highlight any unhealthy trends.</p>
<p> </p>
<p>This can be implemented using the <kbd>RelativeSource.PreviousData</kbd> property mentioned earlier, a <kbd>MultiBinding</kbd> object and an <kbd>IMultiValueConverter</kbd> class. Let's first take a look at how we implement the <kbd>IMultiValueConverter</kbd> interface:</p>
<pre>using System; <br/>using System.Globalization; <br/>using System.Windows; <br/>using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  public class HigherLowerConverter : IMultiValueConverter 
  { 
    public object Convert(object[] values, Type targetType, 
      object parameter, CultureInfo culture) 
    { <br/>      if (values == null || values.Length != 2 || <br/>        !(values[0] is int currentValue) || <br/>        !(values[1] is int previousValue)) <br/>        return DependencyProperty.UnsetValue;
      return currentValue &gt; previousValue ? "-&gt;" : "&lt;-";
    } 
 
    public object[] ConvertBack(object value, Type[] targetTypes, 
      object parameter, CultureInfo culture) 
    { 
      return new object[2] { DependencyProperty.UnsetValue,  
        DependencyProperty.UnsetValue }; 
    } 
  } 
} </pre>
<p>We start our implementation with the customary validation of the input values. In this specific converter, we are expecting two values of type <kbd>int</kbd>, and so we use C# 6.0 Pattern Matching to verify that before continuing. If valid, we compare our two pre-cast values, returning the appropriate <kbd>string</kbd>-based direction arrow, dependent on the result of the comparison.</p>
<p>As the <kbd>ConvertBack</kbd> method is not required for our example, we simply return an <kbd>object</kbd> array that contains two <kbd>DependencyProperty.UnsetValue</kbd> values. Let's take a quick look at our View Model next:</p>
<pre>using System.Collections.Generic; 
 
namespace CompanyName.ApplicationName.ViewModels 
{ 
  public class WeightMeasurementsViewModel : BaseViewModel 
  { 
    private List&lt;int&gt; weights = 
      new List&lt;int&gt;() { 90, 89, 92, 91, 94, 95, 98, 99, 101 }; 
 
    public List&lt;int&gt; Weights 
    { 
      get { return weights; } 
      set { weights = value; NotifyPropertyChanged(); } 
    } 
  } 
} </pre>
<p>Here, we have a very simple View Model, with just one field and property pair. We've just hardcoded a few test values to demonstrate with. Let's now take a look at our View:</p>
<pre>&lt;UserControl 
  x:Class="CompanyName.ApplicationName.Views.WeightMeasurementsView" 
   
  
  xmlns:Converters="clr-namespace:CompanyName.ApplicationName.Converters; 
    assembly=CompanyName.ApplicationName.Converters" 
  &gt; 
  &lt;UserControl.Resources&gt; 
    &lt;Converters:HigherLowerConverter x:Key="HigherLowerConverter" /&gt; 
  &lt;/UserControl.Resources&gt; 
  &lt;Border BorderBrush="Black" BorderThickness="1" CornerRadius="5" 
    HorizontalAlignment="Left" VerticalAlignment="Top"&gt; 
    &lt;ItemsControl ItemsSource="{Binding Weights}" Margin="20,20,0,20"&gt; 
      &lt;ItemsControl.ItemsPanel&gt; 
        &lt;ItemsPanelTemplate&gt; 
          &lt;StackPanel Orientation="Horizontal" /&gt; 
        &lt;/ItemsPanelTemplate&gt; 
      &lt;/ItemsControl.ItemsPanel&gt; 
      &lt;ItemsControl.ItemTemplate&gt; 
        &lt;DataTemplate DataType="{x:Type System:Int32}"&gt; 
          &lt;StackPanel Margin="0,0,20,0"&gt; 
            &lt;TextBlock Text="{Binding}" /&gt; 
            &lt;TextBlock HorizontalAlignment="Center"&gt; 
              &lt;TextBlock.Text&gt; 
                &lt;MultiBinding 
                  Converter="{StaticResource HigherLowerConverter}"&gt; 
                  &lt;Binding /&gt; 
                  &lt;Binding 
                    RelativeSource="{RelativeSource PreviousData}" /&gt; 
                &lt;/MultiBinding&gt; 
              &lt;/TextBlock.Text&gt; 
            &lt;/TextBlock&gt; 
          &lt;/StackPanel&gt; 
        &lt;/DataTemplate&gt; 
      &lt;/ItemsControl.ItemTemplate&gt; 
    &lt;/ItemsControl&gt; 
  &lt;/Border&gt; 
&lt;/UserControl&gt; </pre>
<p>After the <kbd>Converters</kbd> XAML namespace prefix and the declared <kbd>HigherLowerConverter</kbd> element in the <kbd>Resources</kbd> section, we have a bordered <kbd>ItemsControl</kbd> that is data bound to the <kbd>Weights</kbd> property of the View Model that is set as the <kbd>DataContext</kbd> of this View. Next, we see a horizontal <kbd>StackPanel</kbd> element being used as the <kbd>ItemsPanelTemplate</kbd> in the <kbd>ItemsControl.ItemsPanel</kbd> property. This simply makes the collection control display items horizontally instead of vertically.</p>
<p>Note that in the following <kbd>DataTemplate</kbd> object, we need to specify the data type and so need to import the <kbd>System</kbd> namespace from the <kbd>mscorlib</kbd> assembly to reference the <kbd>Int32</kbd> type. The binding to the <kbd>Text</kbd> property in the first <kbd>TextBlock</kbd> specifies that it is binding to the whole data source object, which is simply an integer in this case.</p>
<p>The binding to the <kbd>Text</kbd> property in the second <kbd>TextBlock</kbd> is where we are using our <kbd>MultiBinding</kbd> and <kbd>IMultiValueConverter</kbd> elements. We set our <kbd>HigherLowerConverter</kbd> class to the <kbd>Converter</kbd> property of the <kbd>MultiBinding</kbd> object and inside this, we specify two <kbd>Binding</kbd> objects. The first is again binding to the integer value and the second uses the <kbd>RelativeSource.PreviousData</kbd> property to data bind to the previous integer value. Let's now see the output of this example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1996 image-border" src="assets/09b903b2-9263-430e-ad92-7534edfe58ff.png" style="width:32.17em;height:11.17em;"/></div>
<p>Each value after the first have an arrow displayed underneath, that specifies whether it is higher or lower than the previous value. While the visual output of this example could be improved, it does still highlight the worrying trend of the weight measurements continually increasing towards the end of the sample data. This useful technique can be used in any situation when we need to compare current data values with previous values, such as when displaying share prices, or stock levels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency Properties</h1>
                </header>
            
            <article>
                
<p>We've already seen some examples of Dependency Properties in previous chapters, but now let's take a more thorough look. We have a large number of options that we can use when declaring these properties, with some more commonly used than others. Let's investigate the standard declaration first, by defining an <kbd>Hours</kbd> property of type <kbd>int</kbd> in a class named <kbd>DurationPicker</kbd>:</p>
<pre>public static readonly DependencyProperty HoursProperty =
  DependencyProperty.Register(nameof(Hours), typeof(int), 
  typeof(DurationPicker)); 
 
public int Hours 
{  
  get { return (int)GetValue(HoursProperty); } 
  set { SetValue(HoursProperty, value); }  
} </pre>
<p>As with all Dependency Properties, we start by declaring the property as static and <kbd>readonly</kbd> because, we only want a single, immutable instance of it. This also enables us to access it without an instance of our class.</p>
<p>Unlike normal CLR properties, we do not store the values of our Dependency Properties in private fields that back the properties. Instead, default values are stored directly within the metadata of each <kbd>DependencyProperty</kbd> object and altered values are stored in a separate array in the <kbd>DependencyObject</kbd><span> instance that the Dependency Property value was set on.</span></p>
<p><span>Let's clarify this a little further and remember that all of the built-in controls extend the <kbd>DependencyObject</kbd> class. This means that the altered values of the <kbd>TextProperty</kbd> Dependency Property for example, which was declared in the <kbd>TextBox</kbd> class, are stored in the actual <kbd>TextBox</kbd> instance that the property value was changed on.</span><span> </span><span>This is the main reason why  bindings can only be set on a Dependency Property of a</span><span> </span><span>Dependency Object</span><span>.</span></p>
<p><span>An array of values exists in each <kbd>DependencyObject</kbd> instance and contains the values of all of its declared Dependency Properties that have been explicitly set on it. This is a very important point. This means that by default, with no changed values, the array is empty and therefore, the memory footprint is very small.</span></p>
<p><span>This is converse to a CLR class, where each property has a memory footprint, whether it is set or not. The result of this arrangement is that it saves a huge amount of memory, because only Dependency Property values that have been explicitly set will be stored in the array of values, while default values are read directly from the Dependency Property objects instead.</span></p>
<p>The fact that this array of changed values exists in the <kbd>DependencyObject</kbd><span> class </span>explains why we need to call its <kbd>GetValue</kbd> and <kbd>SetValue</kbd> methods to <span>access and set the values of our Dependency Properties. </span><span>O</span>ur <kbd>HoursProperty</kbd> here is merely the identifier, <span>known as the </span><strong>Dependency Property Identifier</strong>, whose <kbd>GlobalIndex</kbd> property value is used to access the relevant value from that array.</p>
<p>Note that the values in this array are of type <kbd>object</kbd>, so that it can work with any object type. This explains why we need to cast the return value of the <kbd>GetValue</kbd> method from <span><kbd>object</kbd> </span>to the appropriate type in the getter of our CLR wrapper property. Let's now examine what happens internally when we declare a Dependency Property.</p>
<p><span>In the </span><kbd>DependencyProperty</kbd><span> class, there is a private static </span><kbd>Hashtable</kbd><span> named </span><kbd>PropertyFromName</kbd><span>, which holds references to every registered Dependency Property in the application and is shared among all instances of the class. </span>To declare each property and create our key to the <kbd><span>Hashtable</span></kbd>, we use the <kbd>Register</kbd> method of the <kbd>DependencyProperty</kbd> class.</p>
<p class="mce-root"><span>This method has a number of overloads, but all of them require the following information; the name and type of the property and the type of the declaring class, or</span> <em>owner type</em> <span>as Microsoft prefer to call it. Let's look into this process in a bit more depth.</span></p>
<p>When we register a Dependency Property using one of the <kbd>Register</kbd> methods, the provided metadata is first validated and replaced with default values, if required. Then a private <kbd>RegisterCommon</kbd> method is called and inside it, a class named <kbd>FromNameKey</kbd> is used to generate the unique key from the name and owner type of the Dependency Property to create. It does this by creating a unique hash code, by combining the results from calling the <kbd>object.GetHashCode</kbd> method on both the name and owner type passed to it.</p>
<p>After the <kbd>FromNameKey</kbd> object has been created, the <kbd>PropertyFromName</kbd> collection is checked for this key and an <kbd>ArgumentException</kbd> is thrown if one already exists within it. If it is unique, then the default metadata and default value are validated and set from input parameters, or automatically generated if missing.</p>
<p>After this step, the actual <kbd>DependencyProperty</kbd> instance is created using the <kbd>new</kbd> keyword and a private constructor. This internal instance is then added to the <kbd>PropertyFromName</kbd> <kbd>Hashtable</kbd>, using the <kbd>FromNameKey</kbd> object as the unique key, and then returned to the caller of the <kbd>Register</kbd> method, to be stored locally in the public static <kbd>readonly</kbd> Dependency Property Identifier.</p>
<p><span>Note that the overloaded</span> <kbd>Register</kbd><span> method</span><span>s both have an additional input parameter of type</span> <kbd>PropertyMetadata</kbd><span> and we'll investigate this in the next section. For now, let's focus on the last overload, which also enables us to attach a</span> <kbd>ValidateValueCallback</kbd> <span>handler to our property.</span></p>
<p>As the name suggests, this is solely used for validation purposes and we cannot alter the data bound value in this method. Instead, we are simply required to return <kbd>true</kbd> or <kbd>false</kbd> to specify the validity of the current value. Let's see how we can attach this handler to our property and what its method signature is:</p>
<pre>public static readonly DependencyProperty HoursProperty =
  DependencyProperty.Register(nameof(Hours), typeof(int), 
  typeof(DurationPicker), new PropertyMetadata(12), ValidateHours));
 
private static bool ValidateHours(object value) 
{ 
  int intValue = (int)value; 
  return intValue &gt; 0 &amp;&amp; intValue &lt; 25; 
} </pre>
<p>Note that the <kbd>ValidateValueCallback</kbd> delegate does not provide us with any reference to our class and so, we cannot access its other properties from this static context. In order to compare the current value with other property values, or to ensure that certain conditions are met, we can use another overload of the <kbd>PropertyMetadata</kbd> input parameter of the <kbd>DependencyProperty.Register</kbd> method and we'll see this shortly. But let's now return to focus on the <kbd>PropertyMetadata</kbd> input parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting metadata</h1>
                </header>
            
            <article>
                
<p>Using the overloads of the <kbd>PropertyMetadata</kbd> constructor, we can optionally set a default value for the property and attach handlers to be called when the value changes, or when it is being re-evaluated. Let's update our example to attach a <kbd>PropertyChangedCallback</kbd> handler now:</p>
<pre>public static readonly DependencyProperty HoursProperty = 
  DependencyProperty.Register(nameof(Hours), typeof(int), 
  typeof(DurationPicker), new PropertyMetadata(OnHoursChanged)); 
 
private static void OnHoursChanged(DependencyObject dependencyObject,  
  DependencyPropertyChangedEventArgs e)  
{ 
  // This is the signature of PropertyChangedCallback handlers 
} </pre>
<p>Note that our <kbd>PropertyChangedCallback</kbd> handler must also be declared as static in order to be used from the static context of the declared <kbd>DependencyProperty</kbd> as shown in the preceding code. However, we may have a situation where we need to call an instance method rather than a static method and in these cases, we can declare an anonymous method that calls our instance method like this:</p>
<pre>public static readonly DependencyProperty HoursProperty = 
  DependencyProperty.Register(nameof(Hours), 
  typeof(int), typeof(DurationPicker), 
  new PropertyMetadata((d, e) =&gt; ((DurationPicker)d).OnHoursChanged(d,e)));   
 
private void OnHoursChanged(DependencyObject dependencyObject,  
  DependencyPropertyChangedEventArgs e)  
{ 
  // This is the signature of non-static PropertyChangedCallback handlers 
} </pre>
<p>Anonymous methods comprised of Lambda expressions can appear confusing, so let's first extract the relevant code:</p>
<pre>(d, e) =&gt; ((DurationPicker)d).OnHoursChanged(d, e)) </pre>
<p>This could be re-written to make the example somewhat clearer:</p>
<pre>(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e)
  =&gt; 
  ((DurationPicker)dependencyObject).OnHoursChanged(dependencyObject, e)) </pre>
<p>Now we can clearly see the input parameters of the <kbd>PropertyChangedCallback</kbd> handler, followed by the anonymous method body. Inside this method, we simply cast the <kbd>dependencyObject</kbd> input parameter to the type of the declaring class and then call the non-static method from the cast instance of the class, passing the input parameters through, if required.</p>
<p>As we saw in the <a href="b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Debugging WPF Applications</em>, the CLR properties that provide convenient access to our Dependency Properties will not be called by the WPF Framework when their values change. Using this <kbd>PropertyChangedCallback</kbd> handler is how we are able to perform actions upon value changes, or to debug the changing values.</p>
<p>The last overload of the <kbd>PropertyMetadata</kbd> constructor additionally enables us to set a <kbd>CoerceValueCallback</kbd> handler, which provides the platform for us to ensure that our values remain within valid ranges. Unlike the <kbd>PropertyChangedCallback</kbd> delegate, it requires us to return the output value of the property, so this enables us to alter the value before returning it. Here is a simple example that shows how we can adjust our property values:</p>
<pre>public static readonly DependencyProperty HoursProperty = 
  DependencyProperty.Register(nameof(Hours), 
  typeof(int), typeof(DurationPicker), 
  new PropertyMetadata(0, OnHoursChanged, CoerceHoursValue));
                                                            
... 
   
private static object CoerceHoursValue(DependencyObject dependencyObject,  
  object value) 
{ 
  // Access the instance of our class from the dependencyObject parameter   
  DurationPicker durationPicker = (DurationPicker)dependencyObject; 
  int minimumValue = 1, maximumValue = durationPicker.MaximumValue; 
  int actualValue = (int)value; 
  return Math.Min(maximumValue, Math.Max(minimumValue, actualValue)); 
} </pre>
<p>In this simple example, we first cast the <kbd>dependencyObject</kbd> input parameter, so that we can access its <kbd>MaximumValue</kbd> property. Let's assume that our <kbd>DurationPicker</kbd> control can work with either twelve or twenty-four hour time formats and so we need to determine the current upper hour limit. We can therefore constrain our <kbd>Hours</kbd> property value to be between one and this upper limit.</p>
<p>When using the <kbd>CoerceValueCallback</kbd> handler, there is a special case that enables us to effectively cancel a change in value. If your code detects what your requirements specify to be a wholly invalid value, then you can simply return the <kbd>DependencyProperty.UnsetValue</kbd> value from the handler.</p>
<p>This value signals to the property system that it should discard the current change and return the previous value instead. You could even use this technique to selectively block changes to a property until a certain condition is met elsewhere in the class, for example.</p>
<p>That sums up the useful but fairly limited options that we have with our <kbd>PropertyMetadata</kbd> object, although it should be noted that there are a number of classes that derive from this class that we can use in its place and each have their own benefits. The <kbd>UIPropertyMetadata</kbd> class directly extends the <kbd>PropertyMetadata</kbd> class and adds the ability to disable all animations of the property value via its <kbd>IsAnimationProhibited</kbd> property.</p>
<p>Additionally, the <kbd>FrameworkPropertyMetadata</kbd> class further extends the <kbd>UIPropertyMetadata</kbd> class and provides us with the ability to set property inheritance, the default <kbd>Binding.Mode</kbd> and <kbd>Binding.UpdateSourceTrigger</kbd> values of the property, and a variety of <kbd>FrameworkPropertyMetadataOptions</kbd> flags that affect layout.</p>
<p>Let's take a look at some of the <kbd>FrameworkPropertyMetadataOptions</kbd> members. If we think that most users will want to use Two-Way data binding with our property, then we can declare it with the <kbd>BindsTwoWayByDefault</kbd> instance. This has the effect of switching the <kbd>Binding.Mode</kbd> from the default <kbd>OneWay</kbd> member to the <kbd>TwoWay</kbd> member on all bindings to our property:</p>
<pre>public static readonly DependencyProperty HoursProperty = 
  DependencyProperty.Register(nameof(Hours), typeof(int), 
  typeof(DurationPicker), new FrameworkPropertyMetadata(0, 
  FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, OnHoursChanged,  
  CoerceHoursValue)); </pre>
<p>Another commonly used flag is the <kbd>Inherits</kbd> instance, which specifies that the property value can be inherited by child elements. Think of the <kbd>FontSize</kbd> or <kbd>Foreground</kbd> properties that can be set on a <kbd>Window</kbd> and inherited by each control inside it.</p>
<p>Note that if we want to create a Dependency Property using this <kbd>Inherits</kbd> member, then we should declare it as an Attached Property, as property value inheritance works better with Attached Properties. We will find out more about this soon, in a subsequent section, but now let's continue. Next is the <kbd>SubPropertiesDoNotAffectRender</kbd> member, which can be used to streamline performance, and we'll find out more about this particular instance in <a href="8fc90c0b-ca68-49ef-a77f-75173ca49f31.xhtml"><span class="ChapterrefPACKT">Chapter 12</span></a>, <em>Deploying Your Masterpiece Application</em>.</p>
<p>The last commonly used options are the <kbd>AffectsArrange</kbd>, <kbd>AffectsMeasure</kbd>, <kbd>AffectsParentArrange</kbd> and <kbd>AffectsParentMeasure</kbd> members. These are typically used with Dependency Properties that have been declared in custom panels, or other UI controls, where the property value affects the look of the control and changes to it need to cause a visual update.</p>
<p>It should also be noted that this <kbd>FrameworkPropertyMetadataOptions</kbd> enumeration is declared with the <kbd>FlagsAttribute</kbd> attribute, which signifies that we can also allocate a bitwise combination of its instance values, and therefore set multiple options for each of our Dependency Properties:</p>
<pre>public static readonly DependencyProperty HoursProperty = 
  DependencyProperty.Register(nameof(Hours), typeof(int), 
  typeof(DurationPicker), new FrameworkPropertyMetadata(0, 
  FrameworkPropertyMetadataOptions.BindsTwoWayByDefault | 
  FrameworkPropertyMetadataOptions.AffectsMeasure, OnHoursChanged, 
  CoerceHoursValue));</pre>
<p>In order to set the default value for the <kbd>Binding.UpdateSourceTrigger</kbd> property, we need to use the most heavily populated constructor, passing all six input parameters:</p>
<pre>public static readonly DependencyProperty HoursProperty = 
  DependencyProperty.Register(nameof(Hours), typeof(int), 
  typeof(DurationPicker), new FrameworkPropertyMetadata(0, 
  FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, OnHoursChanged, 
  CoerceHoursValue, false, UpdateSourceTrigger.PropertyChanged)); </pre>
<p>Note that i<span>t is perfectly fine to pass <kbd>null</kbd> values for the callback handlers, if we don't need to use them. </span>The <kbd>false</kbd> after the <kbd>CoerceValueCallback</kbd><span> handler</span> value sets the <kbd>IsAnimationProhibited</kbd> property of the <kbd>UIPropertyMetadata</kbd> class. The <kbd>UpdateSourceTrigger</kbd> value set here will be used on all bindings to this property that have not explicitly set the <kbd>UpdateSourceTrigger</kbd> property on the binding, or have set the <kbd>UpdateSourceTrigger.Default</kbd> member to the binding property.</p>
<p>Now that we have fully investigated the various options that we have when we declare Dependency Properties using the <kbd>Register</kbd> method of the <kbd>DependencyProperty</kbd> class, let's take a look at the another registration method from this class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring read-only Dependency Properties</h1>
                </header>
            
            <article>
                
<p>Typically, read-only Dependency Properties are most commonly found in custom controls in situations where we need to data bind to a value, but do not want it to be publicly accessible. It might be a property that holds some relation to an on screen visual, a mid calculation point, or previous value, but generally, we don't want the users of our framework to be able to data bind to it.</p>
<p>Let's imagine a scenario where we want to create a button that will enable us to set a tooltip message to display when the control is disabled, in addition to the normal tooltip message. In this case, we could declare one Dependency Property to hold the disabled tooltip message and another to store the value of the original tooltip when displaying the disabled tooltip. This original tooltip property is a perfect candidate to be a read-only Dependency Property. Let's see what this property looks like:</p>
<pre>private static readonly DependencyPropertyKey originalToolTipPropertyKey =
  DependencyProperty.RegisterReadOnly("OriginalToolTip", typeof(string),  
  typeof(TooltipTextBox), new PropertyMetadata()); 
 
public static readonly DependencyProperty OriginalToolTipProperty =  
  originalToolTipPropertyKey.DependencyProperty; 
 
public static string GetOriginalToolTip(DependencyObject dependencyObject) 
{ 
  return (string)dependencyObject.GetValue(OriginalToolTipProperty); 
} </pre>
<p>As you can see, we use a different syntax to declare read-only Dependency Properties. Instead of returning the <kbd>DependencyProperty</kbd> identifier that is returned from the <kbd>Register</kbd> method, the <kbd>RegisterReadOnly</kbd> method returns a <kbd>DependencyPropertyKey</kbd> object.</p>
<p>This object is typically declared with a <kbd>private</kbd> access modifier, to stop it from being externally used with the <kbd>DependencyObject.SetValue</kbd> method. However, this method can be used within the class that registered the read-only property to set its value.</p>
<p>The <kbd>DependencyProperty</kbd> property of the <kbd>DependencyPropertyKey</kbd> object is used to return the actual <kbd>DependencyProperty</kbd> identifier that is used to access the property value from the dictionary that we discussed earlier.</p>
<p>The input parameters of the <kbd>RegisterReadOnly</kbd> methods offer the same options as those of the standard <kbd>Register</kbd> method, although there is one less overload. Unlike the <kbd>Register</kbd> method, when calling the <kbd>RegisterReadOnly</kbd> methods, we always need to provide the <kbd>PropertyMetadata</kbd> object, although we can pass a <kbd>null</kbd> value if we do not need what it provides.</p>
<p>One very important point to note is that when data binding to a read-only Dependency Property, we <em>must</em> set the binding <kbd>Mode</kbd> property to the <kbd>OneWay</kbd> enumeration member. Failure to do so will result in an error at runtime. We've now covered the creation of normal Dependency Properties in some detail, so let's move on to take a look at a different kind Dependency Property.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering Attached Properties</h1>
                </header>
            
            <article>
                
<p>The <kbd>DependencyProperty</kbd> class enables us to register one further, special type of Dependency Property. These properties are like the Extension Methods of XAML, as they enable us to extend existing classes with our own functionality. They are of course, Attached Properties.</p>
<p>We've already seen some examples of them earlier in this book and we'll see further examples later, but in this chapter, we'll cover their registration. We can declare Attached Properties in exactly the same ways that we can create Dependency Properties and have all of the same various options of setting metadata and attaching handlers.</p>
<p>There are several overloads of the <kbd>RegisterAttached</kbd> and <kbd>RegisterAttachedReadOnly</kbd> methods that mirror the <kbd>Register</kbd> and <kbd>RegisterReadOnly</kbd> methods in input parameters and functionality. However, instead of declaring a CLR wrapper for our Attached Properties, we are required to declare a pair of getter and setter methods to access and set their values. Let's see another example from the <kbd>TextBoxProperties</kbd> class:</p>
<pre>public static DependencyProperty IsFocusedProperty = 
  DependencyProperty.RegisterAttached("IsFocused", 
  typeof(bool), typeof(TextBoxProperties),
  new PropertyMetadata(false, OnIsFocusedChanged)); 
 
public static bool GetIsFocused(DependencyObject dependencyObject) 
{ 
  return (bool)dependencyObject.GetValue(IsFocusedProperty); 
} 
 
public static void SetIsFocused(DependencyObject dependencyObject,  
  bool value) 
{ 
  dependencyObject.SetValue(IsFocusedProperty, value); 
} 
 
public static void OnIsFocusedChanged(DependencyObject dependencyObject,  
  DependencyPropertyChangedEventArgs e) 
{ 
  TextBox textBox = dependencyObject as TextBox; 
  if ((bool)e.NewValue &amp;&amp; !(bool)e.OldValue &amp;&amp; !textBox.IsFocused)  
    textBox.Focus(); 
} </pre>
<p>Here, we have the declaration of a <kbd>bool</kbd> Attached Property named <kbd>IsFocused</kbd> with a <kbd>PropertyMetadata</kbd> element that specifies a default value and a <kbd>PropertyChangedCallback</kbd> handler. Like the CLR property wrappers for Dependency Properties, these getter and setter methods will not be called by the WPF Framework. They are typically declared both public and static.</p>
<p>However, there is one situation where we do not need to declare these methods as public. If we want to create a Dependency Property whose value can be inherited by its children, then we should declare it using the <kbd>RegisterAttached</kbd> method, even if we don't require an Attached Property. In this situation, we are not required to publicly expose our property getter and setter.</p>
<p>Although we can specify the <kbd>FrameworkPropertyMetadataOptions.Inherits</kbd> metadata option upon the declaration of Dependency Properties and their value inheritance might work in some situations, it is not guaranteed in other situations. As Attached Properties are global properties in the property system, we can be assured that their property value inheritance will work in all situations.</p>
<p>Returning to our example, our <kbd>PropertyChangedCallback</kbd> handler is a simple affair. It casts the <kbd>dependencyObject</kbd> property to the type of control that the property is attached to, in this case, a <kbd>TextBox</kbd>. It then verifies that the data bound <kbd>bool</kbd> value has been set from <kbd>false</kbd> to <kbd>true</kbd> and that the control is not already focused. If these conditions are verified, the control is then focused.</p>
<p>This Attached Property can be data bound to a <kbd>bool</kbd> property in a View Model like this:</p>
<pre> 
... 
&lt;TextBox Attached:TextBoxProperties.IsFocused="{Binding IsFocused}" 
  Text="{Binding User.Name}" /&gt; </pre>
<p>The attached <kbd>TextBox</kbd> control can then be focused from the View Model at any time using this following method:</p>
<pre>private void Focus() 
{ 
  IsFocused = false; 
  IsFocused = true; 
} </pre>
<p>Note that we need to ensure that the variable is <kbd>false</kbd> before setting it to <kbd>true</kbd>, as it is the actual changing of the value that will trigger the control to become focused. Now that we know how to declare our own custom Dependency Properties, let's turn our attention to the rules that govern the way they are set.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prioritizing value setting sources</h1>
                </header>
            
            <article>
                
<p>As we have already seen, there are a number of ways of setting the values of Dependency Properties; we can set them directly in code, locally in XAML, or through the use of our <kbd>CoerceValueCallback</kbd> handlers for example. However, there are many more ways that they can be set. For example, they can also be set in styles, animations, or through property inheritance to name but a few.</p>
<p>When we data bind our View Model properties to Dependency Properties and find that the displayed value is not what we are expecting, one reason for this can be because another method of setting the property has a higher precedence and so, overrides our expected value. This is because all the methods of setting the values of Dependency Properties are ordered in terms of importance in a list called the Dependency Property Setting Precedence List. Let's take a look at that now:</p>
<ol>
<li>Property system coercion</li>
<li>Animated properties</li>
<li>Local value</li>
<li>Template properties</li>
<li>Implicit style (only applies to the <kbd>Style</kbd> property)</li>
<li>Style triggers</li>
<li>Template triggers</li>
<li>Style setters</li>
<li>Default (theme) style</li>
<li>Inheritance</li>
<li>Default value from Dependency Property metadata</li>
</ol>
<p>Last on the list, with the lowest precedence at position eleven, are the default values that are specified in the Dependency Property declarations. Next up the list are changes caused by property inheritance. Remember that this can be defined in our Dependency Properties using the <kbd>Inherits</kbd> instance of the <kbd>FrameworkPropertyMetadataOptions</kbd> enumeration in the <kbd>FrameworkPropertyMetadata</kbd> input parameter of the <kbd>DependencyProperty.Register</kbd> method. Let's see an example of this to highlight this order of precedence:</p>
<pre>&lt;StackPanel TextElement.FontSize="20"&gt; 
  &lt;TextBlock Text="Black Text" /&gt; 
  &lt;StackPanel Orientation="Horizontal" TextElement.Foreground="Red"&gt; 
    &lt;TextBlock Text="Red Text" /&gt; 
  &lt;/StackPanel&gt; 
&lt;/StackPanel&gt; </pre>
<p>In this first example, the <kbd>TextBlock</kbd> control in the outer <kbd>StackPanel</kbd> has its <kbd>Foreground</kbd> color set to black by the default value that was set in the data bound <kbd>Text</kbd> property. However, the <kbd>TextBlock</kbd> control inside the inner <kbd>StackPanel</kbd> has its default <kbd>Foreground</kbd> property value overridden by the <kbd>TextElement.Foreground</kbd> Attached Property value that is set on its parent control. It inherits the value of this property from the <kbd>StackPanel</kbd> and this demonstrates that properties set through property inheritance have a higher precedence than properties set with default values.</p>
<p>However, default property values that are set in theme styles follow on the precedence list, with the next lowest priority, and override property values set through inheritance. As it is quite difficult to come up with a short XAML example for this, we'll skip over this item and move onto the next. At number eight on the list, we have property values that have been set by style setters. Let's adjust our earlier example to demonstrate this:</p>
<pre>&lt;StackPanel TextElement.FontSize="20"&gt; 
  &lt;TextBlock Text="Black Text" /&gt; 
  &lt;StackPanel Orientation="Horizontal" TextElement.Foreground="Red"&gt; 
    &lt;TextBlock Text="Red Text" Margin="0,0,10,0" /&gt; 
    &lt;TextBlock Text="Green Text"&gt; 
      &lt;TextBlock.Style&gt; 
        &lt;Style TargetType="{x:Type TextBlock}"&gt; 
          &lt;Setter Property="Foreground" Value="Green" /&gt; 
        &lt;/Style&gt; 
      &lt;/TextBlock.Style&gt; 
    &lt;/TextBlock&gt; 
  &lt;/StackPanel&gt; 
&lt;/StackPanel&gt; </pre>
<p>In this example, the <kbd>TextBlock</kbd> control in the outer <kbd>StackPanel</kbd> still has its <kbd>Foreground</kbd> color set to black by the default value of the data bound <kbd>Text</kbd> property. The top <kbd>TextBlock</kbd> control inside the inner <kbd>StackPanel</kbd> still has its default <kbd>Foreground</kbd> property value overridden by the <kbd>TextElement.Foreground</kbd> value from its parent control. However, now we can also see that values that are set in a <kbd>Style</kbd> will override inherited property values. This is the output of this code snippet:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1997 image-border" src="assets/cfd1682a-3687-49e2-90ba-7fcc62032f68.png" style="width:19.75em;height:8.42em;"/></div>
<p>Next, at number seven on the precedence list, we have template triggers, which override property values that are set with style setters and all other previously mentioned methods of setting values. Note that this specifically deals with triggers that are declared within templates, such as the <kbd>ControlTemplate</kbd>, and does not relate to triggers that are declared within any <kbd>Style.Triggers</kbd> collections. Let's look at an example:</p>
<pre>&lt;Button Content="Blue Text" FontSize="20"&gt; 
  &lt;Button.Style&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
      &lt;Setter Property="Foreground" Value="Green" /&gt; 
      &lt;Setter Property="Control.Template"&gt; 
        &lt;Setter.Value&gt; 
          &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
            &lt;ContentPresenter /&gt; 
            &lt;ControlTemplate.Triggers&gt;                   
              &lt;Trigger Property="IsEnabled" Value="True"&gt; 
                &lt;Setter Property="Foreground" Value="Blue" /&gt; 
              &lt;/Trigger&gt; 
            &lt;/ControlTemplate.Triggers&gt; 
          &lt;/ControlTemplate&gt; 
        &lt;/Setter.Value&gt; 
      &lt;/Setter&gt; 
    &lt;/Style&gt; 
  &lt;/Button.Style&gt; 
&lt;/Button&gt; </pre>
<p>In this example, we have declared a button and overridden its <kbd>ControlTemplate</kbd>, defining a new, minimal markup for it. In the style, we have set the <kbd>Foreground</kbd> property value to green in a setter. However, in our <kbd>ControlTemplate</kbd>, we have a <kbd>Trigger</kbd> that will override this value and set it to blue when its condition is met. Note that if we changed the trigger condition to <kbd>false</kbd> or removed the whole trigger, the button text would then become green, as set by the style.</p>
<p>Next up the list at position six are triggers that are declared within <kbd>Style.Triggers</kbd> collections. One important point to note here is that this only relates to styles that are either declared inline locally, in the current control's <kbd>Resources</kbd> section, or in the application resources file and not to default styles, which have a lower precedence value. We can extend our previous example by adding a new trigger into the <kbd>Style.Triggers</kbd> collection to highlight this new priority:</p>
<pre>&lt;Button Content="Orange Text" FontSize="20"&gt; 
  &lt;Button.Style&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
      &lt;Setter Property="Foreground" Value="Green" /&gt; 
      &lt;Setter Property="Control.Template"&gt; 
        &lt;Setter.Value&gt; 
          &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
            &lt;ContentPresenter /&gt; 
            &lt;ControlTemplate.Triggers&gt; 
              &lt;Trigger Property="IsEnabled" Value="True"&gt; 
                &lt;Setter Property="Foreground" Value="Blue" /&gt; 
              &lt;/Trigger&gt; 
            &lt;/ControlTemplate.Triggers&gt; 
          &lt;/ControlTemplate&gt; 
        &lt;/Setter.Value&gt; 
      &lt;/Setter&gt; 
      &lt;Style.Triggers&gt; 
        &lt;Trigger Property="IsEnabled" Value="True"&gt; 
          &lt;Setter Property="Foreground" Value="Orange" /&gt; 
        &lt;/Trigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/Button.Style&gt; 
&lt;/Button&gt; </pre>
<p>When running this example, our text is now orange. The <kbd>Foreground</kbd> property value that is set by the trigger in the <kbd>Triggers</kbd> collection of the style has overridden the value set by the template trigger, which itself has overridden the value set by the style setter. Let's move on.</p>
<p>At number five on the list, we have implicit styles. Note that <span>this</span> special level of precedence only applies to the <kbd>Style</kbd> property and no others. A style can be implicitly set to all members of a type by specifying the target type and being declared without an <kbd>x:Key</kbd> directive set. Here is an example:</p>
<pre>&lt;Style TargetType="{x:Type Button}"&gt; 
  &lt;Setter Property="Foreground" Value="Green" /&gt; 
&lt;/Style&gt; </pre>
<p>The relevant style must either be declared in the current XAML page, or the <kbd>Application.Resources</kbd> section of the <kbd>App.xaml</kbd> file. Styles from themes are not included here, as they have a lower <span>value </span><span>precedence</span><span>. Note that this special position in the list was only added in .NET 4 and is omitted from the .NET 3 documentation on the</span> <a href="http://docs.microsoft.com">docs.microsoft.com</a> <span>website.</span></p>
<p>Next up the list at position four are properties that are set within either a <kbd>ControlTemplate</kbd> or a <kbd>DataTemplate</kbd>. If we set a property directly on any element within a template, that value will override all values set by methods with lower precedence. For example, if we directly set the <kbd>Foreground</kbd> property on the <kbd>ContentPresenter</kbd> from our previous example, then its value will override all other settings in that example and the button text will be red:</p>
<pre>&lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
  &lt;ContentPresenter TextElement.Foreground="Red" /&gt; 
  &lt;ControlTemplate.Triggers&gt; 
    &lt;Trigger Property="IsEnabled" Value="True"&gt; 
      &lt;Setter Property="Foreground" Value="Blue" /&gt; 
    &lt;/Trigger&gt; 
  &lt;/ControlTemplate.Triggers&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>At position three on the list, we have locally set values. To demonstrate this, we could just set the <kbd>Foreground</kbd> property on the actual button from the last full example, but instead let's highlight an extremely common mistake that a lot of developers make. Imagine a situation where we want to output a value predominantly in one color, but in another color under certain circumstances. Some developers might try something like this:</p>
<pre>&lt;TextBlock Text="{Binding Account.Amount, StringFormat={}{0:C}}"  
  Foreground="Green"&gt; 
  &lt;TextBlock.Style&gt; 
    &lt;Style TargetType="{x:Type TextBlock}"&gt; 
      &lt;Style.Triggers&gt; 
        &lt;DataTrigger Binding="{Binding Account.IsOverdrawn}" Value="True"&gt; 
          &lt;Setter Property="Foreground" Value="Red" /&gt; 
        &lt;/DataTrigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/TextBlock.Style&gt; 
&lt;/TextBlock&gt; </pre>
<p>Upon running this example, some might expect this to work and be stumped when it doesn't. The reason why this doesn't work is because local property settings have a higher value setting precedence than properties set by style triggers. The solution to correcting this mistake is to use our new found knowledge of this value setting precedence list and move the local property setting to a style setter, which has a lower precedence than the trigger:</p>
<pre>&lt;TextBlock Text="{Binding Account.Amount, StringFormat={}{0:C}}"&gt; 
  &lt;TextBlock.Style&gt; 
    &lt;Style TargetType="{x:Type TextBlock}"&gt; 
      &lt;Setter Property="Foreground" Value="Green" /&gt; 
      &lt;Style.Triggers&gt; 
        &lt;DataTrigger Binding="{Binding Account.IsOverdrawn}" Value="True"&gt; 
          &lt;Setter Property="Foreground" Value="Red" /&gt; 
        &lt;/DataTrigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/TextBlock.Style&gt; 
&lt;/TextBlock&gt; </pre>
<p>Now, the <kbd>TextBlock.Foreground</kbd> property will be set to green from the style setter and overridden by the trigger when the condition is true, as expected. Let's continue up the list to position two. In the penultimate position, we have property values that are set by animations. A very simple example can demonstrate this nicely for us:</p>
<pre>&lt;Rectangle Width="300" Height="300" Fill="Orange"&gt; 
  &lt;Rectangle.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard Storyboard.TargetProperty="Width"&gt; 
          &lt;DoubleAnimation Duration="0:0:1" To="50" AutoReverse="True"
            RepeatBehavior="Forever" /&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/Rectangle.Triggers&gt; 
&lt;/Rectangle&gt; </pre>
<p>In this example, the animation overrides the locally set value of the <kbd>Width</kbd> property and the rectangle grows and shrinks as planned. If we think logically about this, then it is clear that the animation system had to feature at a very high position on the property setting precedence list. Otherwise, if it was much lower down the list, we wouldn't be able to animate anything.</p>
<p>However, properties that are set by animations are at number two of the list, which means that there is one place that a property can be set that will override even values set by animations. At number one on the list of Dependency Property Setting Precedence, with the absolutely highest priority setting, is the property coercion system that we discussed in the <em>Dependency Properties</em> section.</p>
<p>This could only really happen if we built a custom control that animated a custom Dependency Property that had particular requirements placed upon it, such as specifying that it should have a certain maximum or minimum value. In this case, we could enforce these rules in a <kbd>CoerceValueCallback</kbd> handler that is attached to the Dependency Property.</p>
<p>If we had these requirements that were enforced by the property coercion system, yet wanted to animate them in the UI, it again makes perfect sense that we would want our coerced values to override the values set by the animation. In this way, we could rest assured that our coerced property values will remain within the bounds that we set for them at all times.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data templates</h1>
                </header>
            
            <article>
                
<p>We've already seen a number of simple examples of the <kbd>DataTemplate</kbd>, but they are such an important part of WPF that we're going to have a much more thorough look at them now. In short, we use a <kbd>DataTemplate</kbd> to define how we want particular data objects to be rendered in the UI<em>.</em></p>
<p>If we were to data bind a particular type of object to a UI control without providing a <kbd>DataTemplate</kbd> for it, the WPF Framework would not know how to display it. Let's highlight this with an example:</p>
<pre>&lt;ItemsControl ItemsSource="{Binding Users}" /&gt; </pre>
<p><span>In these cases, the best job that <span>the WPF Framework </span>can do is to display a <kbd>string</kbd> representation of each object. </span>It achieves this by calling the <kbd>object.ToString</kbd> method on the data object and setting that value to the <kbd>Text</kbd> property of a <kbd>TextBlock</kbd>, which it uses to display the object. If this method has not been overridden in the object's class, this will result in the name of the type of the object being displayed in its place:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1998 image-border" src="assets/57fd0723-8636-47a6-81ee-773a778a5d4b.png" style="width:31.25em;height:9.25em;"/></div>
<p>Knowing that the WPF Framework will call the <kbd>ToString</kbd> method on our data objects before displaying them enables us to take a shortcut, or a simple alternative to defining a <kbd>DataTemplate</kbd>, if we only need a textual output in the UI. Therefore, it is always a good idea for us to override the <kbd>object.ToString</kbd> method to output some meaningful display:</p>
<pre>public override string ToString() 
{ 
  return Name; 
} </pre>
<p>This will result in the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1999 image-border" src="assets/459b78b3-b320-44cd-88c1-39d554163a39.png" style="width:13.00em;height:9.00em;"/></div>
<p>Note that Visual Studio IntelliSense also calls the <kbd>ToString</kbd> method on our data objects before displaying them, so the benefit of providing a custom implementation for it is doubled. As such, we often add an abstract method into our base class to ensure that all derived classes will implement this method:</p>
<pre>namespace CompanyName.ApplicationName.DataModels 
{ 
  public abstract class BaseDataModel : INotifyPropertyChanged 
  { 
    ... 
 
    public abstract override string ToString(); 
  } 
}</pre>
<p>Returning to the topic of data templates now, let's first take a look at a better example for our <kbd>User</kbd> objects and then investigate where we can declare our data templates:</p>
<pre>&lt;DataTemplate x:Key="UserTemplate" DataType="{x:Type DataModels:User}"&gt; 
  &lt;Border BorderBrush="Black" BorderThickness="1" CornerRadius="5"  
    Padding="5" Margin="0,0,0,5"&gt; 
    &lt;StackPanel Orientation="Horizontal"&gt; 
      &lt;TextBlock Text="{Binding Name}" Margin="0,0,3,0" /&gt; 
      &lt;TextBlock Text="{Binding Age, StringFormat={}({0})}" /&gt; 
    &lt;/StackPanel&gt; 
  &lt;/Border&gt; 
&lt;/DataTemplate&gt; </pre>
<p>In this example, we simply output the user's name in one <kbd>TextBlock</kbd> and their age in another. Note the use of the <kbd>StringFormat</kbd> property to surround the age in brackets in the output. Let's now see how this <kbd>DataTemplate</kbd> renders our <kbd>User</kbd> objects:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2000 image-border" src="assets/e2d76956-d8f4-4a09-969e-ebab45a86e9f.png" style="width:20.08em;height:13.00em;"/></div>
<p>Primarily, we can declare our data templates in one of four main places. The first is in line with the control that the related data object or objects will be displayed in. We have two main options for this too, depending on the number of data objects that we have to display.</p>
<p>If we have a single object to display, we can <span>utilize</span> the <kbd>ContentControl</kbd> element to display it and the <kbd>ContentControl.ContentTemplate</kbd> property to define the <kbd>DataTemplate</kbd> element that it should use to render the data object:</p>
<pre>&lt;ContentControl Content="{Binding Users[0]}"&gt; 
  &lt;ContentControl.ContentTemplate&gt; 
    &lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
      ... 
    &lt;/DataTemplate&gt; 
  &lt;/ContentControl.ContentTemplate&gt; 
&lt;/ContentControl&gt;</pre>
<p>Similarly, in a collection control, or <kbd>ItemsControl</kbd>, such as the <kbd>ListBox</kbd> control, we can declare our <kbd>DataTemplate</kbd> directly in the <kbd>ItemTemplate</kbd> property:</p>
<pre>&lt;ListBox ItemsSource="{Binding Users}"&gt; 
  &lt;ListBox.ItemTemplate&gt; 
    &lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
      ... 
    &lt;/DataTemplate&gt; 
  &lt;/ListBox.ItemTemplate&gt; 
&lt;/ListBox&gt; </pre>
<p>The next place that we can declare our data templates is in the <kbd>Resources</kbd> section of the control that will display the data object or objects. Here is our <kbd>ContentControl</kbd> now:</p>
<pre>&lt;ContentControl Content="{Binding Users[0]}" 
  ContentTemplate="{StaticResource UserTemplate}"&gt; 
  &lt;ContentControl.Resources&gt; 
    &lt;DataTemplate x:Key="UserTemplate" DataType="{x:Type DataModels:User}"&gt;
      ... 
    &lt;/DataTemplate&gt; 
  &lt;/ContentControl.Resources&gt; 
&lt;/ContentControl&gt; </pre>
<p>We can also declare our data templates in the <kbd>Resources</kbd> section of the <kbd>Window</kbd> or <kbd>UserControl</kbd> that contains the control that displays the data objects. If we have multiple data objects, then we can set our data template like this:</p>
<pre>&lt;UserControl.Resources&gt; 
  &lt;DataTemplate x:Key="UserTemplate" DataType="{x:Type DataModels:User}"&gt;
    ... 
  &lt;/DataTemplate&gt; 
&lt;/UserControl.Resources&gt; 
&lt;ListBox ItemsSource="{Binding Users}" 
  ItemTemplate="{StaticResource UserTemplate}" /&gt; </pre>
<p>The last place that we can define our data templates is in the <kbd>Application.Resources</kbd> section of the <kbd>App.xaml</kbd> file. When the WPF framework searches for a data template for particular data type, it first searches the local <kbd>Resources</kbd> section of the control that is applying the template.</p>
<p>If it finds no match for the type, it then searches the <kbd>Resources</kbd> collection of the parent control and then the parent of that control and so on. If it still does not find a data template with a matching type, then it will search through the <kbd>Application.Resources</kbd> section of the <kbd>App.xaml</kbd> page.</p>
<p>We can use this order of lookup to our advantage. We often declare our default data templates in the <kbd>Application.Resources</kbd> section of the <kbd>App.xaml</kbd> page, as these resources are available application wide. If we need to override our default data templates, to display a particular output in a particular View, we can declare a new data template with the same <kbd>x:Key</kbd> directive locally in the View's <kbd>Resources</kbd> section.</p>
<p>As the local <kbd>Resources</kbd> section is searched before the application resources, it will use the locally declared data template instead of the default one. Another way of overriding our default templates is to declare them without setting their <kbd>x:Key</kbd> directives:</p>
<pre>&lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
  ... 
&lt;/DataTemplate&gt; </pre>
<p>Resources that are declared in this way are implicitly applied to all data objects of the appropriate type that do not have a data template explicitly applied. Therefore, in order to override these default data templates, we can simply declare a new data template and explicitly set it to the relative template property using its <kbd>x:Key</kbd> directive. Let's now look at one further way of specifying a data template.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking complete control</h1>
                </header>
            
            <article>
                
<p>At times, we might want to display different objects of the same type in different ways, depending on the values of their properties. For example, with a collection of objects that represent vehicles, you might want to have different displays for different types of vehicle, as trucks have different specifications to motor boats. The <kbd>DataTemplateSelector</kbd> class enables us to do just that.</p>
<p>When extending the <kbd>DataTemplateSelector</kbd> class, we can override its single <kbd>SelectTemplate</kbd> method. In this method, we are provided with both the data object and the data bound object and can select different data templates to return, dependent on the data object's property values.</p>
<p>Let's see a very simple example, where we return one of two data templates based on the <kbd>User</kbd>'s age. We'll first need to declare another <kbd>DataTemplate</kbd> for our <kbd>User</kbd> type:</p>
<pre>&lt;DataTemplate x:Key="InverseUserTemplate" 
  DataType="{x:Type DataModels:User}"&gt; 
  &lt;Border BorderBrush="White" BorderThickness="1" Background="Black"     
    TextElement.Foreground="White" CornerRadius="5" Padding="8,3,5,5"
    Margin="0,0,0,5"&gt; 
    &lt;StackPanel Orientation="Horizontal"&gt; 
      &lt;TextBlock Text="{Binding Name}" Margin="0,0,3,0" /&gt; 
      &lt;TextBlock Text="{Binding Age, StringFormat={}({0})}" /&gt; 
    &lt;/StackPanel&gt; 
  &lt;/Border&gt; 
&lt;/DataTemplate&gt; </pre>
<p>In this template, we have simply inverted the colors of the background and foreground from those in the first template. Let's now see our <kbd>DataTemplateSelector</kbd> class that will reference both this and the other <kbd>DataTemplate</kbd> element:</p>
<pre>using System.Windows; 
using System.Windows.Controls; 
using CompanyName.ApplicationName.DataModels; 
 
namespace CompanyName.ApplicationName.Views.DataTemplateSelectors 
{ 
  public class UserAgeDataTemplateSelector : DataTemplateSelector 
  { 
    public override DataTemplate SelectTemplate(object item,  
      DependencyObject container) 
    { 
      FrameworkElement element = container as FrameworkElement; 
      if (element != null &amp;&amp; item != null &amp;&amp; item is User user) 
      { 
        if (user.Age &lt; 35) return 
          (DataTemplate)element.FindResource("InverseUserTemplate"); 
        else return (DataTemplate)element.FindResource("UserTemplate"); 
      } 
      return null; 
    } 
  } 
} </pre>
<p>In this example, we first defensively cast the <kbd>container</kbd> input parameter to an object of type <kbd>FrameworkElement</kbd>, using the <kbd>as</kbd> keyword. We then perform the standard <kbd>null</kbd> checks for this new object and the other input parameter and use the <kbd>is</kbd> keyword to pattern match the correct type and automatically cast the <kbd>item</kbd> parameter to a <kbd>User</kbd> object, if it's of the right type. If it is, then we call the <kbd>FindResource</kbd> method on our <kbd><span>FrameworkElement</span></kbd> object, to return the appropriate data template, dependent upon the value of the <kbd>Age</kbd> property. Otherwise, we return <kbd>null</kbd>.</p>
<p>The <kbd>FrameworkElement.FindResource</kbd> method first searches the calling object for the data template and then its parent element, and so on, up the logical tree. If it doesn't find it in any parent element in the application window, it then looks through the <kbd>App.xaml</kbd> file. If it still does not find it there, it then searches in the themes and system resources.</p>
<p>The <kbd>container</kbd> input parameter is used to access the <kbd>FindResource</kbd> method. Note that it will typically be of type <kbd>ContentPresenter</kbd> if we're using a normal collection control, so we could have cast it to that type in order to access the data templates.</p>
<p>However, the default container could be overridden to use one of the parent classes that the <kbd>ContentPresenter</kbd> class is derived from. Therefore, to avoid the possibility of exceptions, it is safer to cast it to the <kbd>FrameworkElement</kbd> class that actually declares the <kbd>FindResource</kbd> method.</p>
<p>Let's see how we can use this class now. First, we need to add the XAML namespace prefix for our <kbd>DataTemplateSelectors</kbd> namespace:</p>
<pre>xmlns:DataTemplateSelectors=
  "clr-namespace:CompanyName.ApplicationName.Views.DataTemplateSelectors"</pre>
<p>Then we need to add an instance of our <kbd>UserAgeDataTemplateSelector</kbd> class to a <kbd>Resources</kbd> section:</p>
<pre>&lt;DataTemplateSelectors:UserAgeDataTemplateSelector 
  x:Key="UserAgeDataTemplateSelector" /&gt;</pre>
<p>Finally, we set our resource selector to the <kbd>ItemTemplateSelector</kbd> property:</p>
<pre>&lt;ItemsControl ItemsSource="{Binding Users}" Padding="10"  
  ItemTemplateSelector="{StaticResource UserAgeDataTemplateSelector}" /&gt;</pre>
<p>When running the application now, we'll see this new output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2001 image-border" src="assets/3c08a911-2fd2-477b-b651-e246c3c4ca71.png" style="width:20.08em;height:12.83em;"/></div>
<p>Note that <kbd>DataTemplateSelector</kbd> classes are typically used with very different templates, such as those that make up the different editing or viewing modes of a custom control. Slight differences like those in our simple example can be far easier achieved using style triggers and we'll find out more about triggers and styles in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying hierarchical data</h1>
                </header>
            
            <article>
                
<p>There is one class in the .NET Framework that extends the <kbd>DataTemplate</kbd> class in order to support UI controls that extend the <kbd>HeaderedItemsControl</kbd> class. As it sounds, the <kbd>HeaderedItemsControl</kbd> class represents a particular kind of <kbd>ItemsControl</kbd> element that has a header. Examples include the <kbd>MenuItem</kbd>, <kbd>TreeViewItem</kbd>, and <kbd>ToolBar</kbd> classes.</p>
<p>The <kbd>HierarchicalDataTemplate</kbd> class was created to display hierarchical Data Models. To clarify a little further, a hierarchical data Model is a data Model that contains a collection property with items of the same type as the parent object. Think of the folder view in the Windows Explorer window; each folder can contain further folders.</p>
<p>The main difference between the <kbd>HierarchicalDataTemplate</kbd> and the <kbd>DataTemplate</kbd> class is that the <kbd>HierarchicalDataTemplate</kbd> class has an <kbd>ItemsSource</kbd> property that we can use to bind the children of each item to.</p>
<p>In addition to the <kbd>ItemsSource</kbd> property, there are a number of other item-related properties, such as the <kbd>ItemContainerStyle</kbd>, <kbd>ItemStringFormat</kbd> and <kbd>ItemTemplate</kbd> properties. We'll find out more about what these other properties do in the next chapter, but for now, let's look at an example.</p>
<p>There are plenty of <kbd>HierarchicalDataTemplate</kbd> examples that demonstrate the use of <kbd>TreeViewItem</kbd> elements to be found online, so for this example, we'll see how we <span>can</span> build an application menu using data binding. First, we'll need a View Model to data bind to each <kbd>MenuItem</kbd> control. Let's take a look at our <kbd>MenuItemViewModel</kbd> class:</p>
<pre>using System.Collections.ObjectModel; 
using System.Windows.Input; 
 
namespace CompanyName.ApplicationName.ViewModels 
{ 
  public class MenuItemViewModel : BaseViewModel 
  { 
    private string header = string.Empty; 
    private ICommand command = null; 
    private ObservableCollection&lt;MenuItemViewModel&gt; menuItems = 
      new ObservableCollection&lt;MenuItemViewModel&gt;(); 
 
    public string Header 
    { 
      get { return header; } 
      set { if (header != value) { header = value; 
        NotifyPropertyChanged(); } } 
    } 
 
    public ICommand Command 
    { 
      get { return command; } 
      set { if (command != value) { command = value;
        NotifyPropertyChanged(); } } 
    } 
 
    public ObservableCollection&lt;MenuItemViewModel&gt; MenuItems 
    { 
      get { return menuItems; } 
      set { if (menuItems != value) { menuItems = value;
        NotifyPropertyChanged(); } } 
    } 
  } 
} </pre>
<p>In this simplified example, our View Model only declares three properties to data bind to the <kbd>MenuItem</kbd> control's properties. In a real application, we would typically add further properties, so that we could define the icon, or maybe the style of each menu item as well. However, continuing the example with our View Model, let's look at the class that would declare these View Models.</p>
<p>If an application has a menu control, it would typically reside in the <kbd>MainWindow.xaml</kbd> file. Therefore, the data bound <kbd>MenuItemViewModel</kbd> elements would be declared in the View Model that is data bound to the data context of that View. Let's look at the required properties:</p>
<pre>private ObservableCollection&lt;MenuItemViewModel&gt; menuItems = 
  new ObservableCollection&lt;MenuItemViewModel&gt;();
 
public ObservableCollection&lt;MenuItemViewModel&gt; MenuItems 
{ 
  get { return menuItems; } 
  set { if (menuItems != value) { menuItems = value;
    NotifyPropertyChanged(); } } 
} </pre>
<p>An alternative to programmatically declaring the various menu item View Models would be to define the items in an XML file, read it in and generate the items from that at runtime. However, for the purpose of this simple example, let's just hard code some values to use, omitting the commands for brevity:</p>
<pre>MenuItems.Add(new MenuItemViewModel() { Header = "Users", 
  MenuItems = new ObservableCollection&lt;MenuItemViewModel&gt;() { 
  new MenuItemViewModel() { Header = "Details", 
  MenuItems = new ObservableCollection&lt;MenuItemViewModel&gt;() { 
  new MenuItemViewModel() { Header = "Banking" }, 
  new MenuItemViewModel() { Header = "Personal" } } }, 
  new MenuItemViewModel() { Header = "Security" } } }); 
MenuItems.Add(new MenuItemViewModel() { Header = "Administration" }); 
MenuItems.Add(new MenuItemViewModel() { Header = "View" }); 
MenuItems.Add(new MenuItemViewModel() { Header = "Help", 
  MenuItems = new ObservableCollection&lt;MenuItemViewModel&gt;() { 
  new MenuItemViewModel() { Header = "About" } } }); </pre>
<p>While this code is somewhat difficult to read, it is far more compact than declaring each child item separately and then building up the hierarchy afterwards. The end result is the same, so let's now see what the required XAML looks like:</p>
<pre>&lt;Menu ItemsSource="{Binding MenuItems}" FontSize="14" Background="White"&gt; 
  &lt;Menu.ItemContainerStyle&gt; 
    &lt;Style TargetType="{x:Type MenuItem}"&gt; 
      &lt;Setter Property="Command" Value="{Binding Command}" /&gt; 
    &lt;/Style&gt; 
  &lt;/Menu.ItemContainerStyle&gt; 
  &lt;Menu.ItemTemplate&gt; 
    &lt;HierarchicalDataTemplate 
      DataType="{x:Type ViewModels:MenuItemViewModel}" 
      ItemsSource="{Binding MenuItems}"&gt; 
      &lt;TextBlock Text="{Binding Header}" /&gt; 
    &lt;/HierarchicalDataTemplate&gt; 
  &lt;/Menu.ItemTemplate&gt; 
&lt;/Menu&gt; </pre>
<p>Here, we declare a <kbd>Menu</kbd> control and data bind our <kbd>MenuItems</kbd> collection to its <kbd>ItemsSource</kbd> property. The <kbd>ItemContainerStyle</kbd> enables us to define the style of the UI container that surrounds each of our data items. In this case, that control is a <kbd>MenuItem</kbd> control.</p>
<p>All we need to do in this style is to bind the <kbd>Command</kbd> property of our View Model to the <kbd>Command</kbd> property of the menu item. If we had declared any other properties in our View Model to map to the <kbd>MenuItem</kbd> class properties, then this style would be the place to data bind them.</p>
<p>As discussed earlier, the <kbd>ItemTemplate</kbd> property enables us to provide a data template, or in this case, our <kbd>HierarchicalDataTemplate</kbd> element, that will define how each item will be rendered. In the template declaration, we state the type of our data items and specify the collection property that contains the child items.</p>
<p>Inside the template, we simply output the value of the <kbd>Header</kbd> property in a <kbd>TextBlock</kbd> element. This will represent the name of each menu item. Let's see what this will all look like when the application is running now:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2002 image-border" src="assets/77f1568d-4b49-4677-a0a9-3d6d3491e813.png" style="width:28.83em;height:16.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data binding to enumeration collections</h1>
                </header>
            
            <article>
                
<p>We've already seen a number of examples of data binding to enumeration instances. We've seen converters that we can use to convert our enumeration values and Extension Methods that we can use to extract additional information from each member. Earlier in this chapter, we even saw a full but basic example using our <kbd>BitRate</kbd> enumeration. Now, with our new found knowledge, let's see how we can improve that earlier example.</p>
<p>As noted, in the previous example, we manually declared a <kbd>RadioButton</kbd> control for each of our enumerations. While that is fine for our three member enumeration, it wouldn't make so much sense to use this method if we had a large number of members. Instead, let's think about how we could use a <kbd>DataTemplate</kbd> to declare how each member should be rendered. Let's remind ourselves how we declared each <kbd>RadioButton</kbd> in the previous example:</p>
<pre>&lt;RadioButton Content="16 bits" IsChecked="{Binding BitRate, 
  Converter={StaticResource EnumToBoolConverter}, 
  ConverterParameter=Sixteen}" VerticalContentAlignment="Center" /&gt;</pre>
<p>The first thing that we notice is the hardcoded <kbd>Content</kbd> value. Obviously, we can't do this in a <kbd>DataTemplate</kbd>, otherwise every member would be given the same label. This is a perfect place for us to use the <kbd>EnumToDescriptionStringConverter</kbd> converter that we created earlier, so let's update that now:</p>
<pre>&lt;UserControl.Resources&gt; 
  ... 
  &lt;Converters:EnumToDescriptionStringConverter 
    x:Key="EnumToDescriptionStringConverter" /&gt; 
  ... 
&lt;/UserControl.Resources&gt; 
... 
&lt;RadioButton Content="{Binding ., 
  Converter={StaticResource EnumToDescriptionStringConverter}}" 
  IsChecked="{Binding BitRate, 
  Converter={StaticResource EnumToBoolConverter}, 
  ConverterParameter=Sixteen}" VerticalContentAlignment="Center" /&gt; </pre>
<p>Next, we see that we have also hardcoded the <kbd>Sixteen</kbd> enumeration member to the <kbd>ConverterParameter</kbd> property, so we'll need to change that in our data template too. Our first attempt might be to simply data bind the whole data context from the data template, which in our case, is one of the enumeration instances:</p>
<pre>&lt;RadioButton Content="{Binding ., 
  Converter={StaticResource EnumToDescriptionStringConverter}}" 
  IsChecked="{Binding BitRate, 
  Converter={StaticResource EnumToBoolConverter}, 
  ConverterParameter={Binding}}" VerticalContentAlignment="Center" /&gt;</pre>
<p>However, if we do this and run the application, we will receive the following exception:</p>
<pre><strong>A 'Binding' cannot be set on the 'ConverterParameter' property of type 'Binding'. A 'Binding' can only be set on a DependencyProperty of a DependencyObject.</strong></pre>
<p>Unfortunately, we cannot data bind to the <kbd>ConverterParameter</kbd> property, as it was not declared as a Dependency Property. As we cannot data bind to this property from within our data template and no longer use the <kbd>EnumToBoolConverter</kbd> class to specify the selected enumeration instance, this will complicate our example somewhat.</p>
<p>One trick that we can use is to utilize the <kbd>SelectedItem</kbd> property of the <kbd>ListBoxItem</kbd> class to hold the value of our selected enumeration member instead. We can achieve this by data binding this property to the <kbd>IsChecked</kbd> property of each <kbd>RadioButton</kbd> using a <kbd>RelativeSource.FindAncestor</kbd> binding in our <kbd>DataTemplate</kbd>:</p>
<pre>&lt;RadioButton Content="{Binding ., 
  Converter={StaticResource EnumToDescriptionStringConverter}}" 
  IsChecked="{Binding IsSelected, 
  RelativeSource={RelativeSource AncestorType={x:Type ListBoxItem}},  
  FallbackValue=False}" VerticalContentAlignment="Center" /&gt; </pre>
<p>Note that each data item in a collection control will be implicitly wrapped in a UI container element. In our case, we'll use a <kbd>ListBox</kbd> control and so our enumeration instances will be wrapped <span>in </span><kbd>ListBoxItem</kbd><span> elements</span>, but if we had chosen a <kbd>ComboBox</kbd> for example, then our items' containers would be <kbd>ComboBoxItem</kbd> elements. We'll find out more about this in the next chapter, but for now, let's continue looking at this example.</p>
<p>So, now we have data bound the <kbd>Content</kbd> property of the <kbd>RadioButton</kbd> to the description of each member from the <kbd>DescriptionAttribute</kbd> attribute declared in the enumeration and the <kbd>IsChecked</kbd> property to the <kbd>IsSelected</kbd> property of the <kbd>ListBoxItem</kbd> element. However, we have lost the connection to our selected enumeration property from the View Model.</p>
<p>In order to restore this connection, we can data bind the <kbd>BitRate</kbd> property to the <kbd>SelectedItem</kbd> property of the <kbd>ListBox</kbd> control. The WPF Framework implicitly connects this property with the <kbd>IsSelected</kbd> property of each <kbd>ListBoxItem</kbd> element and so our connection between the <kbd>BitRate</kbd> property and the <kbd>IsChecked</kbd> property of each button is now restored. Let's see the updated XAML:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.BitRateView"<br/>   <br/>   <br/>  xmlns:Converters="clr-namespace:CompanyName.ApplicationName.Converters; 
    assembly=CompanyName.ApplicationName.Converters" 
  &gt; 
  &lt;UserControl.Resources&gt; 
    &lt;Converters:EnumToBoolConverter x:Key="EnumToBoolConverter" /&gt; 
  &lt;/UserControl.Resources&gt; 
  &lt;GroupBox Header="Audio Quality" FontSize="14" Margin="20"  
    HorizontalAlignment="Left" VerticalAlignment="Top" Padding="5"&gt;
    &lt;ListBox ItemsSource="{Binding BitRates}" 
      SelectedItem="{Binding BitRate}"&gt; 
      &lt;ListBox.ItemTemplate&gt; 
        &lt;DataTemplate DataType="{x:Type Enums:BitRate}"&gt; 
          &lt;RadioButton Content="{Binding ., Converter={StaticResource 
            EnumToDescriptionStringConverter}}" 
            IsChecked="{Binding IsSelected, 
            RelativeSource={RelativeSource 
            AncestorType={x:Type ListBoxItem}}, FallbackValue=False}" 
            VerticalContentAlignment="Center" /&gt; 
        &lt;/DataTemplate&gt; 
      &lt;/ListBox.ItemTemplate&gt; 
    &lt;/ListBox&gt; 
  &lt;/GroupBox&gt; 
&lt;/UserControl&gt; </pre>
<p>To update our earlier example, we need to add the new <kbd>Enums</kbd> XAML namespace prefix, so that we can specify our <kbd>BitRate</kbd> enumeration type in the data template. Next, we need to update the content of our <kbd>GroupBox</kbd> element. Now we're using a <kbd>ListBox</kbd> control so that we can take advantage of its item selection capabilities.</p>
<p>We data bind our <kbd>BitRates</kbd> collection to the <kbd>ItemsSource</kbd> property and our selected <kbd>BitRate</kbd> property to the <kbd>SelectedItem</kbd> property of the <kbd>ListBox</kbd>. The one problem with this method is that as we're now using a <kbd>ListBox</kbd> element in our example, we can see it and its contained <kbd>ListBoxItem</kbd> objects. This is not how radio buttons are typically displayed:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2003 image-border" src="assets/880d4dbb-c489-4263-b391-86639919ed7a.png" style="width:12.33em;height:12.33em;"/></div>
<p>It's not a terrible problem and it can be easily fixed by declaring a few styles. We'll return to this example in the following chapter and demonstrate how we can style the <kbd>ListBox</kbd><span> element </span>and its items to completely hide their use from the end users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We've covered a lot of important information in this chapter, from examining the binding path syntax mini-language to exploring a number of different binding scenarios. We've investigated the plethora of options that we're afforded when declaring our own Dependency Properties and looked into the creation of Attached Properties, using some interesting examples. Finally, we examined the finer details of data templating and explored a number of ways of data binding to enumerations.</p>
<p>In the next chapter, we'll have an in-depth look at the various UI elements in the WPF Framework and their most relevant properties. We'll investigate when to customize them and when we need to create our own controls. We'll then explore the various ways of modifying existing controls in WPF and finally, take a detailed look at how to create our own custom controls.</p>


            </article>

            
        </section>
    </body></html>