- en: 13 Understanding the Operation Result Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file71.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explores the **Operation Result** pattern, starting simple and
    progressing to more complex cases. An operation result aims to communicate the
    success or failure of an operation to its caller. It also allows that operation
    to return both a value and one or more messages to the caller.Imagine any system
    where you want to display user-friendly error messages, achieve some small speed
    gain, or even handle failure easily and explicitly. The **Operation Result** design
    pattern can help you achieve these goals. One way to use it is to handle the result
    of a remote operation, such as after querying a remote web service.This pattern
    builds upon foundational object-oriented programming concepts. In this chapter,
    we iterate and design different possibilities incrementally. Of course, you should
    always base your final design on your needs, so learning multiple options will
    help you make the right choices.
  prefs: []
  type: TYPE_NORMAL
- en: The Operation Result pattern is also known as the **Result Object Pattern**.
    I prefer Operation Result because the name specifies that it represents the result
    of an operation, while the Result Object has a broader meaning. Nonetheless, both
    are basically the same.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Operation Result design pattern basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Operation Result design pattern returning a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Operation Result design pattern returning error messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Operation Result design pattern returning messages with severity levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sub-classes and static factory methods for better isolation of successes
    and failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Operation Result pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operation Result design pattern can be very simple to more complex. In this
    section, we explore multiple ways to use this pattern. We start with its simplest
    form and build on that until we can return messages and values and add severity
    levels as the result of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The role of the **Operation Result** pattern is to give an operation (a method)
    the possibility to return a complex result (an object), which allows the consumer
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mandatory] Access the success indicator of the operation (that is, whether
    the operation succeeded or not).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optional] Access the operation result if there is one (the method''s return
    value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optional] Access the cause of the failure if the operation was unsuccessful
    (error messages).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optional] Access other information that documents the operation’s result.
    This could be as simple as a list of messages or as complex as multiple properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can go even further, such as returning the severity of a failure or adding
    any other relevant information for the specific use case. The success indicator
    could be binary (`true` or `false`), or there could be more than two states, such
    as success, partial success, and failure.
  prefs: []
  type: TYPE_NORMAL
- en: Always focus on your needs first, then use your imagination and knowledge to
    find the best solution. Software engineering is not only about applying techniques
    that others tell you to. It’s an art! The difference is that you are crafting
    software instead of painting or woodworking. And that most people won’t see any
    of that art (code) or get it even if they do.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is easy to rely on throwing exceptions when an operation fails. However,
    the Operation Result pattern is an alternative way of communicating success or
    failure between components when you don’t want to use exceptions. One such reason
    could be that the messages are not errors or that treating an erroneous result
    is part of the main flow, not part of a side `catch` flow.A method must return
    an object containing one or more elements presented in the *Goal* section to be
    used effectively. As a rule of thumb, a method returning an operation result should
    not throw exceptions. This way, consumers don’t have to handle anything other
    than the operation result itself.
  prefs: []
  type: TYPE_NORMAL
- en: You can throw exceptions for special cases, but at this point, it is a judgment
    call based on clear specifications or facing a real problem. For example, a critical
    event that happens, like the disk is full, would be a valid use case for an exception
    because it has nothing to do with the main flow, and the code must alert the rest
    of the program about the system failure.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Instead of walking you through all of the possible UML diagrams, let’s jump
    into the code and explore multiple smaller examples after taking a look at the
    basic sequence diagram that describes the simplest form of this pattern, applicable
    to all examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Sequence diagram of the Operation Result design pattern](img/file72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Sequence diagram of the Operation Result design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows that an operation returns a result (an object),
    and then the caller handles that result. The following examples cover what we
    can include in that result object.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Implementing different Operation Result patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, a consumer (REST API) routes the HTTP requests to the correct
    handler. We are visiting each of those handlers one by one to create an incremental
    learning flow from simple to more complex operation results. This project shows
    you many ways to implement the Operation Result pattern to help you understand
    it, make it your own, and implement it as required in your projects.Let’s start
    with the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: The consumer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The consumer of all examples is the `Program.cs` file. The following code from
    `Program.cs` routes the HTTP requests toward a handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we cover each use case one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of the Operation Result pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following diagram represents the simplest form of the Operation Result
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: Class diagram of the Operation Result design pattern](img/file73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Class diagram of the Operation Result design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can translate that class diagram into the following blocks of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code handles the `/simplest-form` HTTP requests. The highlighted
    code consumes the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Executor` class contains the operation to execute represented by the `Operation`
    method. That method returns an instance of the `OperationResult` class. The implementation
    is based on a random number. Sometimes it succeeds, and sometimes it fails. You
    would usually code real application logic in that method instead. Moreover, in
    an actual application, the method should have a proper name representing the operation,
    like `PayRegistrationFees` or `CreateConcert`.The `OperationResult` record class
    represents the result of the operation. In this case, a simple read-only Boolean
    value is stored in the `Succeeded` property.
  prefs: []
  type: TYPE_NORMAL
- en: I chose a record class because there is no reason for the result to change.
    To know more about record classes, have a look at *Appendix A*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this form, the difference between the `Operation` method returning a `bool`
    and an instance of `OperationResult` is small, but it exists nonetheless. By returning
    an `OperationResult` object, you can extend the return value over time, adding
    properties and methods to it, which you cannot do with a `bool` without updating
    all consumers.Next, we add an error message to the result.
  prefs: []
  type: TYPE_NORMAL
- en: A single error message
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we know whether the operation succeeded or not, we want to know what
    went wrong. To do that, we add an `ErrorMessage` property to the `OperationResult`
    record class.With that in place, we no longer need to set whether the operation
    succeeded or not; we can compute that using the `ErrorMessage` property instead.
    The logic behind this improvement goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When there is no error message, the operation succeeded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there is an error message, the operation failed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `OperationResult` record class implementing this logic looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Succeeded` property checks for an error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ErrorMessage` property contains an error message settable when instantiating
    the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The executor of that operation looks similar but uses the new constructor,
    setting an error message instead of directly setting the success indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The consuming code does the same as in the previous sample but writes the error
    message in the response output instead of a generic failure string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When looking at this example, we can begin to comprehend the Operation Result
    pattern’s usefulness. It furthers us from the simple success indicator that looked
    like an overcomplicated Boolean.Next, we add the possibility of setting a value
    when the operation succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a return value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have a reason for failure, we may want the operation to return
    a value. To achieve this, let’s build over the previous example and add a `Value`
    property to the `OperationResult` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By adding a second `init`-only property, we can set the `Value` property when
    the operation succeeds and fails.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world scenario, that `Value` property could be `null` in the case
    of an error, hence the nullable `int` property.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The operation is also very similar, but we are setting the `Value` property
    as well as using the object initializer in both cases (highlighted lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, the consumer can use the `Value` property. In our case,
    the program displays it when the operation succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code displays the `ErrorMessage` property when the operation fails
    or uses the `Value` property when it succeeds. With this, the power of the Operation
    Result pattern continues to emerge.But we are not done yet, so let’s jump into
    the next evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple error messages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we are at the point where we can transfer a `Value` and an `ErrorMessage`
    to the operation consumers; what about transferring multiple errors, such as validation
    errors? To achieve this, we can convert our `ErrorMessage` property from a `string`
    to an `IEnumerable<string>` or another type of collection that fits your needs
    better. Here I chose the `IReadOnlyCollection<string>` interface and the `ImmutableList<string>`
    class so we know that external actors can’t mutate the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the new pieces in the preceding code before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: The errors are now stored in `ImmutableList<string>` object and returned as
    an `IReadOnlyCollection<string>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Succeeded` property accounts for a collection instead of a single message
    and follows the same logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HasErrors` method improves readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default constructor represents the successful state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor that takes error messages as parameters represents a failed
    state and populates the `Errors` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the operation result is updated, the operation itself can stay the
    same. The consumer stays almost the same as well (see the highlight in the code
    below), but we need to tell ASP.NET how to serialize the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We must specify the method returns an object (the highlighted code) so ASP.NET
    understands that the return value of our delegate can be anything. Without this,
    the return type could not be inferred, and the code would not compile. That makes
    sense since the function is returning a `string` in one path and an `IReadOnlyCollection<string>`
    in another.During the executing, ASP.NET serializes the `IReadOnlyCollection<string>
    Errors` property to JSON before outputting it to the client to help visualize
    the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a `plain/text` string when the operation succeeds and an `application/json`
    array when it fails is not a good practice. I suggest avoiding this in real applications.
    Either return JSON or plain text. Do not mix content types in a single endpoint
    unless necessary per specifications. Mixing content types only creates avoidable
    complexity and confusion. Moreover, it is way easier for the consumers of the
    API to always expect the same content type.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When designing system contracts, consistency and uniformity are usually better
    than incoherency, ambiguity, and variance.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Our Operation Result pattern implementation is getting better and better but
    still lacks a few features. One of those features is the possibility to propagate
    messages that are not errors, such as information messages and warnings, which
    we implement next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding message severity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that our operation result structure is materializing, let’s update our
    last iteration to support message severity.First, we need a severity indicator.
    An `enum` is a good candidate for this kind of work, but it could also be something
    else. In our case, we leverage an `enum` that we name `OperationResultSeverity`.Then
    we need a message class to encapsulate both the message and the severity level;
    let’s name that class `OperationResultMessage`. The new code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have a simple data structure to replace our `string` messages.To
    ensure the enum gets serialized as string and make the output easier to read and
    consume, we must register the following converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to update the `OperationResult` class to use that new `OperationResultMessage`
    class instead. We then need to ensure that the operation result indicates a success
    only when there is no `OperationResultSeverity.Error`, allowing it to transmit
    the `OperationResultSeverity.Information` and `OperationResultSeverity.Warnings`
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines represent the updated logic that sets the success state
    of the operation. The operation is successful only when no error exists in the
    `Messages` list. The `FindErrors` method returns messages with an `Error` severity,
    while the `HasErrors` method bases its decision on that method’s output.
  prefs: []
  type: TYPE_NORMAL
- en: The `HasErrors` method logic can be anything. In this case, this works.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With that in place, the `Executor` class is also revamped. Let’s have a look
    at those changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we removed the tertiary operator. The `Operation` method
    also uses all severity levels.
  prefs: []
  type: TYPE_NORMAL
- en: You should always aim to write code that is easy to read. It is OK to use language
    features, but nesting statements over statements on a single line has limits and
    can quickly become a mess.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In that last code block, both successes and failures return two messages:'
  prefs: []
  type: TYPE_NORMAL
- en: When the operation succeeds, the method returns an information and a warning
    message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the operation fails, the method returns an information and an error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the consumer standpoint, we have a placeholder if-else block and return
    the operation result directly. Of course, we could handle this differently in
    a real application that needs to know about those messages, but in this case,
    all we want to see are those results, so this does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is still as easy to use, but now with more flexibility added
    to it. We can do something with the different types of messages, such as displaying
    them to the user, retrying the operation, and more.For now, when running the application
    and calling this endpoint, successful calls return a JSON string that looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Failures return a JSON string that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Another idea to improve this design would be adding a `Status` property that
    returns a complex success result based on each message’s severity level. To do
    that, we could create another `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then we could access that value through a new property named `Status`, on the
    `OperationResult` class. With this, a consumer could handle partial success without
    digging into the messages. I will leave you to play with this one on your own;
    for example, the `Status` property could replace the `Succeeded` property, or
    the `Succeeded` property could leverage the `Status` property similarly to what
    we did with the errors. The most important part is to define what would be a success,
    a partial success, and a failure. Think of a database transaction, for example;
    one failure could lead to the rollback of the transaction, while in another case,
    one failure could be acceptable.Now that we’ve expanded our simple example into
    this, what happens if we want the `Value` to be optional? To do that, we could
    create multiple operation result classes holding more or less information (properties);
    let’s try that next.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-classes and factories
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this iteration, we keep all the properties but instantiate the `OperationResult`
    objects using static factories. Moreover, we hide certain properties in the sub-classes,
    so each result type only contains the data it needs. The `OperationResult` class
    itself only exposes the `Succeeded` property in this scenario.A **static factory
    method** is nothing more than a static method that creates objects. It is handy
    and easy to use but less flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'I cannot stress this enough: be careful when designing something `static`,
    or it could haunt you later; `static` members are not extensible and can make
    their consumers harder to test.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `OperationResultMessage` class and the `OperationResultSeverity` `enum`
    remain unchanged. In the following code block, we do not consider the severity
    when computing the operation’s success or failure state. Instead, we create an
    abstract `OperationResult` class with two sub-classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SuccessfulOperationResult` class represents successful operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FailedOperationResult` class represents failed operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then the next step is to force the use of the specifically designed classes
    by creating two static factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The static `Success` method returns a `SuccessfulOperationResult` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static `Failure` returns a `FailedOperationResult` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This technique moves the responsibility of deciding whether the operation is
    a success from the `OperationResult` class to the `Operation` method that explicitly
    creates the expected result.The following code block shows the new `OperationResult`
    implementation (the static factories are highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After analyzing the code, there are a few closely related particularities:'
  prefs: []
  type: TYPE_NORMAL
- en: The `OperationResult` class has a private constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the `SuccessfulOperationResult` and `FailedOperationResult` classes are
    nested inside the `OperationResult` class, inherit from it, and are `private`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested classes are the only way to inherit from the `OperationResult` class
    because, like other members of the class, nested classes have access to their
    private members, including the constructor. Otherwise, it is impossible to inherit
    from `OperationResult`. Moreover, as private classes, they can only be accessed
    internally from the `OperationResult` class for the same reason and become inaccessible
    from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: Since the beginning of the book, I have repeated **flexibility** many times;
    but you don’t always want flexibility. Even if most of the book is about improving
    flexibility, sometimes you want control over what you expose and what you allow
    consumers to do, whether to protect internal mechanisms (encapsulation) or for
    maintainability reasons.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, allowing consumers to change the internal state of an object can
    lead to unexpected behaviors. Another example would be when managing a library;
    the larger the public API, the more chances of introducing a breaking change.
    Nonetheless, over-hiding elements can be a detrimental experience for the consumers;
    if you need something somewhere, the chances are that someone else will too (eventually).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case, we could have used a protected constructor instead or implemented
    a fancier way of instancing success and failure instances. Nonetheless, I decided
    to use this opportunity to show you how to lock a class in place without the sealed
    modifier, making extending by inheritance from the outside impossible. We could
    have built mechanisms in our classes to allow controlled extensibility (like the
    Template Method pattern), but for this one, let’s keep it locked in tight!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'From here, the only missing pieces are the operation itself and the consumer
    of the operation. Let’s look at the operation first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The two highlighted lines in the preceding code block show the elegance of
    this new improvement. I find this code very easy to read, which was the objective.
    We now have two methods that clearly define our intentions when using them: `Success`
    or `Failure`.The consumer uses the same code that we saw before in other examples,
    so I’ll omit it here. However, the output is different for a successful or a failed
    operation. Here is a successful output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a failed output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As the two preceding JSON outputs show, each object's properties are different.
    The only shared property of the two is the `Succeeded` property. Beware that this
    type of class hierarchy is harder to consume directly since the interface (the
    `OperationResult` class) has a minimal API surface, which is good in theory, and
    each sub-class adds different properties, which are hidden from the consumers.
    For example, it would be hard to use the `Value` property of a successful operation
    directly in the endpoint handler code. Therefore, when hiding properties, as we
    did here, ensure those additional properties are optional. For example, we can
    use this technique when sending the result to another system over HTTP (like this
    project does) or publish the operation result as an event (see *Chapter 19*, *Introduction
    to Microservices Architecture*, where we introduce event-driven architecture).
    Nevertheless, learning to manipulate classes using polymorphism will be helpful
    the day you need it.Next, let’s peek at some advantages and disadvantages of the
    Operation Result pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are a few advantages and disadvantages of the Operation Result design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is more explicit than throwing an `Exception` since the operation result
    type is specified explicitly as the method’s return type. That makes it more evident
    than knowing what type of exceptions the operation and its dependencies can throw.Another
    advantage is the execution speed; returning an object is faster than throwing
    an exception. Not that much faster, but faster nonetheless.Using operation results
    is more flexible than exceptions and gives us design flexibility; for example,
    we can manage different message types like warnings and information.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using operation results is more complex than throwing exceptions because we
    must *manually propagate it up the call stack* (i.e., the result object is returned
    by the callee and handled by the caller). This is especially true if the operation
    result must go up multiple levels, suggesting this pattern may not be the most
    suitable.It is easy to expose members not used by all scenarios, creating a bigger
    API surface than needed, where some parts are used only in some cases. But, between
    this and spending countless hours designing the perfect system, sometimes exposing
    an `int? Value { get; }` property is the best option. Nonetheless, always try
    to reduce that surface to a minimum and use your imagination and design skills
    to overcome those challenges!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we visited multiple forms of the Operation Result pattern,
    from an augmented Boolean to a complex data structure containing messages, values,
    and success indicators. We also explored static factories and private constructors
    to control external access. Furthermore, after all that exploration, let’s conclude
    that there are almost endless possibilities around the Operation Result pattern.
    Each specific use case should dictate how to make it happen. From here, I am confident
    you have enough information about the pattern to explore the many possibilities
    yourself, and I highly encourage you to.The Operation Result pattern is perfect
    for crafting strongly typed return values that self-manage multiple states (error
    and success) or support complex states (like partial success). It is also ideal
    for transporting messages that are not necessarily errors, like information messages.
    Even in its simplest form, we can leverage the Operation Result pattern as a base
    for extensibility since we can add members to the result class over time, which
    would be impossible for a primitive type (or any type we don’t control).
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpResponseMessage` class returned by the methods of the `HttpClient`
    class is an excellent example of a concrete implementation of the Operation Result
    pattern. It contains a single message exposed through the `ReasonPhrase` property.
    It exposes a complex success state through the `StatusCode` property and a simple
    success indicator through its `IsSuccessStatusCode` property. It also contains
    more information about the request and response through other properties.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'At this point, we would usually explore how the **Operation Result** pattern
    can help us follow the SOLID principles. However, it depends too much on the implementation,
    so here are a few key points instead:'
  prefs: []
  type: TYPE_NORMAL
- en: The `OperationResult` class encapsulates the result, extracting that responsibility
    from the other system’s components (SRP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We violated the ISP with the `Value` property in multiple examples. This infringement
    has a minor impact that we fixed as an example of overcoming this challenge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could compare an operation result to a DTO but returned by an operation (method)
    instead of a REST API endpoint. From there, we could add an abstraction or stick
    with returning a concrete class, but sometimes using concrete types makes the
    system easier to understand and maintain. Depending on the implementation, this
    may break different principles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the advantages surpass the minor impacts of those kinds of violations,
    it is acceptable to let them slide. Principles are ideals and are not applicable
    in every scenario—principles are not laws.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most design decisions are trade-offs between two imperfect solutions, so you
    must choose which downsides you prefer to live with to gain the upsides.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This chapter concludes *Section 3:* *Components Patterns* and leads to *Section
    4: Application Patterns*, where we explore higher-level design patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is returning an operation result when doing an asynchronous call, such as an
    HTTP request, a good idea?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the pattern that we implemented using static methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it faster to return an operation result than throw an exception?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what scenario might the Operation Result pattern come in handy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some links to build on what we learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An article on my blog about exceptions (title: *A beginner guide to exceptions*
    | *The basics*): [https://adpg.link/PpEm](https://adpg.link/PpEm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An article on my blog about Operation Result (title*: Operation result* | *Design
    Pattern*): [https://adpg.link/4o2q](https://adpg.link/4o2q)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, asynchronous operations like HTTP are great candidates for the Operation
    Result pattern. For example, in the BCL, the `HttpResponseMessage` instance returned
    by the `Send` method of the `HttpClient` class is an operation result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implemented two **static factory methods**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, returning an object is marginally faster than throwing an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Operation Result pattern comes in handy when we want to return the state
    of the operation along with its return value as part of the main consumption flow.
    It is very suitable to return multiple properties describing the result of the
    process and is extensible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
