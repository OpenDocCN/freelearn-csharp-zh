- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Canvases, Panels, and Basic Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, the majority of this text will focus on
    the Unity UI system, uGUI. Canvases are the core of all UI made with Unity UI.
    Every single uGUI element must be contained within a Canvas for it to render within
    a scene. It works similarly to a canvas on which an artist paints, but instead
    of painting on them, we lay out UI elements on them. So, we’ll start our exploration
    of the various UI elements provided in the uGUI system with Canvases.
  prefs: []
  type: TYPE_NORMAL
- en: Canvases serve the purpose of not only holding all the UI elements within them
    but also determining how the elements will render and how they will scale. It’s
    important to start focusing on setting up a UI that will scale at multiple resolutions
    and aspect ratios early on, as trying to do so later will cause a lot of headaches
    and extra work. Therefore, we will also discuss how to make sure our UI scales
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Canvases and setting their properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UI Panels and setting their properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Rect Tool and the Rect Transform component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly setting anchor and pivot points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and lay out a basic HUD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a background image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a basic pop-up menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2006](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2006)'
  prefs: []
  type: TYPE_NORMAL
- en: UI Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every UI element you create must be a child of a **UI Canvas**. To see a list
    of all UI elements you can create within Unity, select **+** | **UI** from the
    **Hierarchy** window, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: The renderable UI elements within the Unity UI (uGUI) system](img/Figure_06.01_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The renderable UI elements within the Unity UI (uGUI) system'
  prefs: []
  type: TYPE_NORMAL
- en: Every one of the UI items highlighted in the preceding screenshot is a renderable
    UI item and must be contained within a Canvas to render. If you try to add any
    of those UI elements to a scene that does not contain a Canvas, a Canvas will
    automatically be added to the scene, and the item you attempted to create will
    be made a child of the newly added Canvas. To demonstrate this, try adding a new
    **UI Text** element to an empty scene. You can do so by selecting **+** | **UI**
    | **Text**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will cause three new items to appear in the Hierarchy list: `Canvas`,
    `Text`, and `EventSystem`, where the Text is a child of the Canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: The result of adding a UI Text element to the scene](img/Figure_06.02_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The result of adding a UI Text element to the scene'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a Canvas in your scene, any new UI elements you add to the
    scene will automatically be added to this Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you try to take a renderable UI element out of a Canvas, it will not be drawn
    to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an empty Canvas by selecting `EventSystem` GameObject does
    not already exist within the scene, one will automatically be created for you
    (as you saw in the preceding screenshot). We’ll discuss the `EventSystem` GameObject
    further in [*Chapter 8*](B18327_08.xhtml#_idTextAnchor147), but for now, all you
    really need to know is the `EventSystem` allows you to interact with the UI items.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can have more than one Canvas in your scene, each with its own children.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a Canvas, it will appear as a large rectangle within your scene.
    It will be significantly larger than that rectangle representing the camera’s
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: The renderable UI elements within the Unity UI (uGUI) system](img/Figure_06.03_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The renderable UI elements within the Unity UI (uGUI) system'
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas is larger than the Camera because the Canvas component has a scaling
    mode on it. The scaling mode by default equates to one pixel within the UI to
    one Unity unit, so it’s a lot bigger. A nice consequence of this large size is
    that it is really easy to see your UI items as a somewhat separate entity, and
    this keeps it from cluttering up your camera view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every newly created Canvas automatically comes with four components: **Rect
    Transform**, **Canvas**, **Canvas Scaler**, and **Graphic Raycaster**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: The components of a Canvas GameObject](img/Figure_06.04_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The components of a Canvas GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore each of these components.
  prefs: []
  type: TYPE_NORMAL
- en: Rect Transform component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Unity UI GameObject has a **Rect Transform** component as its first component.
    This component is very similar to the **Transform** component on non-UI GameObjects
    in that it allows you to place the object within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll note that when you first place a Canvas in the scene, you can’t adjust
    the values within the **Rect Transform**, and there is a message stating, **“Some
    values driven by Canvas”**, as shown in the preceding screenshot. This message
    means you cannot control the position of the Canvas because the properties selected
    in the **Canvas** component determine them.
  prefs: []
  type: TYPE_NORMAL
- en: When a Canvas component has its **Render Mode** set to **Screen Space-Overlay**
    or **Screen Space-Camera**, the adjustment of the **Rect Transform** component’s
    values is disabled. In these two modes, the values are determined by the resolution
    of the game display because the Canvas fills up the full-screen area. When the
    Canvas’ **Render Mode** is set to **World Space**, you can adjust the values as
    you see fit, as this component will then determine its location within the scene.
    We will discuss how to use the **Rect Transform** Component more thoroughly later
    in this chapter, but for now, let’s review the Canvas component and the various
    render modes more thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Canvas** component allows you to select the Canvas **Render Mode** from
    a dropdown. There are three render modes: **Screen Space-Overlay**, **Screen Space-Camera**,
    and **World Space**. The different render modes determine where in the scene the
    UI elements will be drawn and how the **Rect Transform** component will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: When developing your UI, the first thing you should always do is appropriately
    set your Canvas’ render mode based on your needs. If you have multiple Canvases
    in your scene, they can each have a different render mode. Changing the render
    mode will change the properties available on the Canvas component. Let’s review
    the purpose of each of the render modes and the properties that come with them.
  prefs: []
  type: TYPE_NORMAL
- en: Screen Space-Overlay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Screen Space-Overlay** is the default render mode. If you are asked to think
    of a video game UI, it’s highly likely that you will envision one rendered in
    **Screen Space-Overlay**. This render mode overlays all the UI elements within
    the Canvas in front of everything in the scene as if it is drawn on top of the
    screen. So, UI items like **heads-up-displays** (**HUDs**) and pop-up windows
    that appear on the same plane as the screen will be contained within a **Screen**
    **Space-Overlay Canvas**.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when a Canvas is using the **Screen Space-Overlay** render mode, you
    cannot adjust the **Rect Transform** component of the Canvas. This is because
    the canvas will automatically resize based on the size of the screen (not the
    camera).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Screen Space – Overlay Render Mode properties](img/Figure_06.05_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Screen Space – Overlay Render Mode properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have **Screen Space-Overlay** selected, the following properties become
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixel Perfect**: Selecting this check box will cause the elements rendered
    in the Canvas to line up with pixels. It can make the UI elements appear sharper
    and less blurry. This can cause performance issues, so only use it if absolutely
    necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sort Order**: This option will determine the order in which all the **Screen
    Space-Overlay** Canvases in your scene will render. You can think of it as a stacking
    order. The higher the number, the *closer* the items within the Canvas will appear
    to the person viewing the scene. In other words, higher sort order numbered canvases
    will appear *on top* of lower sort order numbered canvases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target Display**: If you are creating a PC, Mac, Linux Standalone game, you
    can have different cameras display on up to eight different monitors. You can
    also have different UI for each monitor. This is where you will tell the Canvas
    which of the displays it will render on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional Shader Channels**: Shaders are essentially algorithms that describe
    the color of a GameObject based on light and material. Each Canvas automatically
    includes the following shader channels: Position, Color, and Uv0\. However, this
    property lets you add additional channels. Shaders are a pretty complicated topic,
    so we won’t spend a lot of time discussing them in this text. In **Screen Space-Overlay**
    mode, not all of the channels available in the dropdown menu work, and you’ll
    see a message in the component describing which are not working.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s look at **Screen** **Space Camera**.
  prefs: []
  type: TYPE_NORMAL
- en: Screen Space-Camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Screen Space-Camera** performs similarly to **Screen Space-Overlay**, but
    it renders all UI elements as if they are a specific distance away from the camera.
    As you can see from the following screenshot, if there is no **Render Camera**
    selected, this render mode works exactly like the **Screen Space-Overlay** mode
    (as indicated by the warning message):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Warning message for Screen Space – Camera Render Mode](img/Figure_06.06_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Warning message for Screen Space – Camera Render Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can assign any camera in your scene to the **Render Camera** in the **Screen
    Space-Camera** render mode. This is the camera to which the canvas will draw.
    Once you add a camera to the **Render Camera** slot, the warning message will
    disappear, and new options will be made available to you, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Screen Space – Camera Render Mode properties](img/Figure_06.07_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Screen Space – Camera Render Mode properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have **Screen Space-Camera** selected, the following properties become
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixel Perfect**: This is the same option as with **Screen Space-Overlay**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Render Camera**: As stated earlier, this is the camera to which the canvas
    will draw.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plane Distance**: This property tells the Canvas how far away from the camera
    it should display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting Layer**: This property allows you to choose which **Sprite Sorting
    Layer** to display the Canvas with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order in Layer**: This property determines the order in the **Sprite Sorting
    Layer** (chosen earlier) that the Canvas will display. This order works similar
    to the way **Sort Order** works, with higher numbers appearing on top of lower
    numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional Shader Channels**: This property works as it does in **Screen
    Space-Overlay**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rendering mode is helpful if you want a Canvas to render from a different
    perspective than that of your main camera. It is also helpful for creating a static
    background that will consistently scale with the camera in a 2D game. Since you
    can use **Sprite Sorting Layer** with this rendering mode, you can make sure the
    Canvas containing the background always renders behind all other objects in the
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when a Canvas is using the **Screen Space-Camera** render mode, you
    cannot adjust the **Rect Transform** component of the Canvas. This is because
    the canvas will automatically resize based on the size of the camera (not the
    screen).
  prefs: []
  type: TYPE_NORMAL
- en: World Space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last rendering mode is **World Space**. This mode allows you to render UI
    elements as if they are physically positioned within the world.
  prefs: []
  type: TYPE_NORMAL
- en: In **Screen Space-Overlay** and **Screen Space-Camera**, you cannot adjust the
    properties of the **Rect Transform** component. The positions of UI elements within
    Canvases with those two rendering modes do not translate to world space coordinates
    and are instead relative to the screen and camera. However, when a Canvas is in
    **World Space** render mode, the values of the **Rect Transform** can be adjusted
    because the coordinates of the UI elements are based on actual positions within
    the scene. These Canvases do not have to face a specified camera as the other
    two Canvas types do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Render Mode – World Space properties](img/Figure_06.08_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Render Mode – World Space properties'
  prefs: []
  type: TYPE_NORMAL
- en: This mode requests an **Event Camera**, rather than a **Rendering Camera** as
    **Screen Space-Camera** mode requested. An **Event Camera** is different than
    a **Rendering Camera**. Since this Canvas is in the **World Space**, it will be
    rendered with the **Main Camera**, just as all the other objects that exist within
    the scene. The **Event Camera** is the camera that will receive events from the
    EventSystem. So, if items on this Canvas require interactions, you have to include
    an **Event Camera**. If the player won’t be interacting with the items on the
    Canvas, you can leave this blank.
  prefs: []
  type: TYPE_NORMAL
- en: The reason you need to specify an **Event Camera** is ray casting. When the
    user clicks on or touches the screen, a ray (one-directional line) is cast infinitely
    forward from the point of click (or touch) into the scene. The direction it points
    is determined by the direction the camera is facing. Most of the time, you will
    set this as your **Main Camera** because that is the direction in which the player
    will expect the events to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have **World Space** selected, the following properties become available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Camera**: As stated earlier, the camera assigned to this slot determines
    which camera will receive the events of the Canvas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting Layer**: This property is the same as in **Screen Space-Camera**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order in Layer**: This property is the same as in **Screen Space-Camera**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional Shader Channels**: This property works as it does in **Screen
    Space-Overlay**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let us look at the **Canvas** **Scalar** component.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas Scalar component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Canvas Scalar** component determines how the items within the canvas will
    scale. It also determines the pixel density of the items within the UI Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18327_01.xhtml#_idTextAnchor014), we discussed how to build
    your game at a single resolution or a single aspect ratio. However, most of the
    time, you will not have the luxury of choosing the resolution or aspect ratio
    of your game. You’ll note that I only mentioned specifying the aspect ratio and
    resolution for the PC, Mac, and Linux Standalone builds and the WebGL builds.
    When you build to something that will play on a handheld screen or a TV screen,
    you cannot guarantee how big that screen will be.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that you cannot guarantee the resolution or aspect ratio of
    your game, the need for your UI to adjust to various resolutions and scaling is
    very important; that’s why this **Canvas Scalar** component exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Canvas Scalar** component has four **UI** **Scale Modes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant** **Pixel Size**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale With** **Screen Size**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant** **Physical Size**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**World**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three **UI Scale Modes** are available when the Canvas **Render Mode**
    is set to **Screen Space-Overlay** or **Screen Space-Camera**. The fourth **UI
    Scale Mode** is automatically assigned when the Canvas **Render Mode** is set
    to **World Space** (it cannot be changed when set).
  prefs: []
  type: TYPE_NORMAL
- en: Constant Pixel Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Canvas has the **UI Scale Mode** set to **Constant Pixel Size**, every
    item in the UI will maintain its original pixel size regardless of the size of
    the screen. You’ll note that this is the default setting, so by default UI does
    not scale; you must turn the setting on for it to scale by altering screen resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Constant Pixel Size UI Scale Mode properties](img/Figure_06.09_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Constant Pixel Size UI Scale Mode properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you change the **UI Scale Mode** to **Constant Pixel Size**, you will
    see the following properties appear within the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2`, everything within the UI will then double in size. If you set this number
    to `0.5`, all items will have their size halved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`100`, that means two objects that are one game unit apart from each other
    will be 100 pixels apart. Put another way, if two objects are at the same *y-*coordinate,
    but one object has an *x-*coordinate of `1`, and the other has an *x-*coordinate
    of `2`, they are exactly 100 pixels apart. This property works the same way in
    all other modes, so I will not discuss it in the next sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale With Screen Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have the **Canvas Scalar** component set to **Scale with Screen Size**,
    UI elements on the Canvas will scale based on a **Reference Resolution**. If the
    screen is larger or smaller than the **Reference Resolution** value, the items
    on the Canvas will then scale up or down accordingly. In [*Chapter 1*](B18327_01.xhtml#_idTextAnchor014),
    I told you that you should decide on a default resolution that represents the
    ideal resolution of your UI design. This default resolution will be the **Reference
    Resolution**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Scale With Screen Size UI Scale Mode properties](img/Figure_06.10_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Scale With Screen Size UI Scale Mode properties'
  prefs: []
  type: TYPE_NORMAL
- en: If the aspect ratio of your screen matches the **Reference Resolution** value,
    then things will scale up and down without any problems. If it does not match,
    then you need to use the **Canvas Scalar** component to define how items will
    scale if the aspect ratio changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by using the **Screen Match Mode** settings. In the following
    list are the three different **Screen Match Modes** that determine how the Canvas
    will scale if the game’s aspect ratio does not match the **Reference Resolution**
    aspect ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Match Width Or Height**: This will scale the UI with respect to the reference
    height or the reference width. It can also scale based on a combination of both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expand**: If the screen is smaller than the **Reference Resolution**, the
    canvas will be expanded to match that of the **Reference Resolution**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shrink**: If the screen gets larger than the **Reference Resolution**, the
    canvas will be reduced to match that of the **Reference Resolution**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `0` (`1` (**Height**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Scale With Screen Size UI Scale Mode properties](img/Figure_06.11_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Scale With Screen Size UI Scale Mode properties'
  prefs: []
  type: TYPE_NORMAL
- en: When the value of `0`, the **Canvas Scaler** will force the Canvas to always
    have the same width specified by the **Reference Resolution**. This will maintain
    the relative scales and positions of objects along the width of the Canvas. So,
    objects will not get further away from or closer to each other in the horizontal
    direction. However, it will completely ignore the height. So, objects can get
    further from or closer to each other in the vertical direction.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `1` will accomplish the same thing but will maintain the positions
    and scales of the objects along the height, not the width.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `0.5` will compare the game’s width and height to that of **Reference
    Resolution**, and it will try to maintain the distances between objects in both
    the horizontal and vertical directions.
  prefs: []
  type: TYPE_NORMAL
- en: The `0` and `1`. If the number is closer to `1`, scaling will favor the height,
    and if it is closer to `0`, it will favor the width.
  prefs: []
  type: TYPE_NORMAL
- en: None of these `1`). If you want the relative horizontal positions to be maintained,
    use `0`). It really just depends on which spacing you care the most about.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend using the following settings based on the orientation of your game:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Orientation** | **Match Value** |'
  prefs: []
  type: TYPE_TB
- en: '| **Portrait** | `0` (Width) |'
  prefs: []
  type: TYPE_TB
- en: '| **Landscape** | `1` (Height) |'
  prefs: []
  type: TYPE_TB
- en: '| **Varies** | `0.5` (Width and Height) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Orientation and Match Value'
  prefs: []
  type: TYPE_NORMAL
- en: I chose these settings based on whichever of the two numbers on the **Reference
    Resolution** is the smallest. In **Portrait** mode, the width will be the smallest,
    so I find it important to maintain the relative position of the items in the width.
    This is a personal preference and just a recommendation, and it will not necessarily
    make sense for all games. However, I have found it to be a good rule of thumb
    for most games.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to avoid making games that will vary between portrait and landscape
    mode unless you have minimal UI or are very comfortable with creating scalable
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Constant Physical Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Canvas has the **UI Scale Mode** set to **Constant Physical Size**, every
    item in the UI will maintain its original physical size, regardless of the size
    of the screen. Physical size references the size that will appear to the user
    if they were to take out a ruler and measure it on their screen. Much like **Constant
    Pixel Size**, items on Canvases with this **UI Scale Mode** setting will not scale.
  prefs: []
  type: TYPE_NORMAL
- en: If you had a UI item that you wanted to always be a specific width and height,
    you’d put it on a Canvas that has this **UI Scale Mode**. For example, if you
    wanted a button to always be 2 inches wide and 1 inch tall, you’d use this mode.
    This is particularly helpful in mobile games, allowing you to make sure buttons
    are sized large enough for human fingers based on the recommendations we discussed
    in [*Chapter 4*](B18327_04.xhtml#_idTextAnchor054).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Scale with Constant Physical Size UI Scale Mode properties](img/Figure_06.12_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Scale with Constant Physical Size UI Scale Mode properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you change the **UI Scale Mode** to **Constant Physical Size**, you will
    see the following properties appear within the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical** **Unit**: The unit of measure. You can select from **Centimeters**,
    **Millimeters**, **Inches**, **Points**, and **Picas**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fallback Screen DPI**: If the DPI is unknown, this is the assumed DPI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default Sprite DPI**: The DPI of all sprites with Pixels Per Unit that are
    equal to the **Reference Pixels Per** **Unit** value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: World
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**World** is the only **UI Scale Mode** available for Canvases set to **World
    Space**. You’ll see from the following screenshot that the mode cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: Scale with World UI Scale Mode properties](img/Figure_06.13_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Scale with World UI Scale Mode properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you change the **UI Scale Mode** to **World**, you will see the following
    property appear within the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Pixels Per Unit**: This is the Pixels Per Unit setting for all dynamic
    UI items (such as text).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphic Raycaster component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Graphic Raycaster** component allows you to check to see whether objects
    on the Canvas have been hit by a user input using the Event System. As discussed
    when looking at the **World Space** Canvas **Render Mode**, when a user touches
    the screen, a ray is cast forward from the point on the screen at which the player
    touches. The **Graphic Raycaster** checks these rays and sees if they hit something
    on the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: The Graphic Raycaster component](img/Figure_06.14_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: The Graphic Raycaster component'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can adjust the following properties on the **Graphic** **Raycaster** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore Reversed Graphics**: If a UI element is facing away from the player,
    having this selected will stop the hit from registering. If it is not selected,
    hits will register on back-facing UI objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocking Objects**: This setting specifies which types of items in front
    of it will block it from being hit. So, if you select **Two D**, any **Two D**
    object in front of the items on this Canvas will stop the items from being interacted
    with. However, 3D objects will not stop the interaction. The possible options
    are shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.15: Graphics Raycaster Blocking Objects options](img/Figure_06.15_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Graphics Raycaster Blocking Objects options'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocking Mask:** Selecting items on this property works similarly to the
    **Blocking Objects** property. This allows you to select items based on their
    Rendering Layer, so you can get a little more specific. The possible options are
    shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.16: Graphics Raycaster Blocking Mask options](img/Figure_06.16_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Graphics Raycaster Blocking Mask options'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss Raycasting and the Event System more thoroughly in [*Chapter
    8*](B18327_08.xhtml#_idTextAnchor147).
  prefs: []
  type: TYPE_NORMAL
- en: Canvas Renderer component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Canvas Renderer** component is not on a Canvas GameObject but on all renderable
    UI objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: The Canvas Renderer component](img/Figure_06.17_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: The Canvas Renderer component'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a UI element to render, it must have a **Canvas Renderer** component on
    it. All the renderable UI elements that you create via the **+** | **UI** menu
    will automatically have this component attached to them. If you try to remove
    this component, you will see a warning similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18: Warning message when you try to remove a Canvas Renderer component](img/Figure_06.18_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: Warning message when you try to remove a Canvas Renderer component'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, I tried to remove the Canvas Renderer component
    from a Text UI object. As you can see, it will not let me remove the Canvas Renderer
    component because the Text component relies on it. If I return and remove the
    Text component, I would then be able to remove the Canvas Renderer component.
  prefs: []
  type: TYPE_NORMAL
- en: The only property on the **Canvas Renderer** component is the **Cull Transparent
    Mesh** toggle. “To cull” means to not draw. So, this property states that the
    renderer will not draw any geometry that has its vertex color alpha at or close
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: UI Panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main function of **UI Panels** is to hold other UI elements. You can create
    a Panel by selecting **+** | **UI** | **Panel**. It’s important to note that there
    is no Panel component. Panels are really just GameObjects that have **Rect Transform**,
    **Canvas Renderer**, and **Image** components. So, really, a UI Panel is just
    a UI Image with a few properties predefined for it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: The components on a Panel GameObject](img/Figure_06.19_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: The components on a Panel GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Panels start with the **Background** Image (which is just a grey
    rounded rectangle) as the **Source Image** with medium opacity. You can replace
    the **Source Image** with another Image or remove the image entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Panels are very useful when you are trying to ensure that items scale and are
    appropriately positioned relative to each other. Items that are contained within
    the same Panel will scale relative to the Panel and maintain their relative position
    to each other in the process.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the **Image** component more thoroughly soon, but now that we
    are looking at an object that will allow us to edit its **Rect Transform** component,
    let›s explore that component.
  prefs: []
  type: TYPE_NORMAL
- en: Rect Transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each UI element has a **Rect Transform** component. The **Rect Transform** component
    works very similarly to the **Transform** component and is used to determine the
    position of the object on which it is attached.
  prefs: []
  type: TYPE_NORMAL
- en: Rect Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any of the Transform tools can be used to manipulate UI objects. However, the
    Rect Tool allows you to scale, move, and rotate any object by manipulating the
    rectangle that encompasses it. While this tool can be used with 3D objects, it
    is most useful for 2D and UI objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20: The Rect Tool](img/Figure_06.20_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: The Rect Tool'
  prefs: []
  type: TYPE_NORMAL
- en: To move an object with the Rect Tool, select the object and then click and drag
    inside the rectangle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To resize an object, hover over the edge or corner of an object. When the cursor
    changes to arrows, click and drag to resize the object. You can scale uniformly
    by holding down the *shift* button while dragging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To rotate, hover at the corner of the objects--slightly outside of the rectangle
    until the cursor displays a rotating circle at its corner. You can then rotate
    by clicking and dragging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using the Rect Tool, it is important that you have the correct positioning
    modes selected. You can select **Center** or **Pivot** and **Global** or **Local**.
    The modes will toggle by clicking on the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21: The various positioning modes](img/Figure_06.21_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: The various positioning modes'
  prefs: []
  type: TYPE_NORMAL
- en: When in **Center** mode, the object will move based on its center point and
    rotate around its center point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in **Pivot** mode, the object will rotate around its pivot point rather
    than its center point. You can also alter the position of the pivot point in this
    mode by hovering over the pivot point and clicking and dragging to move.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in **Global** mode, the Rect Transform’s bounding box will be a non-rotated
    box that encompasses the entire object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in **Local** mode, the Rect Transform’s bounding box will be a rotated
    box that snuggly fits the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following illustration shows the bounding boxes of the Rect Transform for
    a Panel in **Global** and **Local** modes. The empty blue circle represents the
    object’s pivot point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22: Global mode vs. Local mode](img/Figure_06.22_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: Global mode vs. Local mode'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the **Rect** **Transform** component.
  prefs: []
  type: TYPE_NORMAL
- en: Rect Transform component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated earlier, UI elements do not have the standard **Transform** component;
    they have the **Rect Transform** component. If you compare it to a standard **Transform**
    component, you will see that it has quite a few more properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23: Transform vs. Rect Transform](img/Figure_06.23_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.23: Transform vs. Rect Transform'
  prefs: []
  type: TYPE_NORMAL
- en: You can use it to change the position, rotation, and scale, just as you can
    with `1`.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the labels for the position and dimensional values
    are different in the preceding illustration than they are in the one provided
    in the *UI Panel Properties* section. This is because the labels that represent
    the position and dimension change depending on the Anchor Preset chosen. We’ll
    discuss how to use these Anchor Presets momentarily, but let’s look at some different
    examples of labels the position and dimensional values can hold.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24: Variation in Rect Transform properties](img/Figure_06.24_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: Variation in Rect Transform properties'
  prefs: []
  type: TYPE_NORMAL
- en: If the **Rect Transform** has its Anchor Preset set to not include stretch,
    as with the top-left example in the preceding screenshot, the values for position
    are determined by **Pos X**, **Pox Y**, **Pos Z**, and the dimensions are determined
    by **Width** and **Height**.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Rect Transform** has its Anchor Preset set to include stretch, as with
    the other three examples, the positions perpendicular to the stretch and the dimensions
    parallel to the stretch are labeled with **Left**, **Right**, **Top**, and **Bottom**.
    These values represent the offset from the border of the parent’s **Rect Transform**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Anchor** point of an object determines the point from which all the relative
    positions are measured from. The **Pivot** point determines the point from which
    the scaling and rotating modifiers happen. It will rotate around this point and
    scale toward this point. We will look at Anchors and Pivots more thoroughly in
    the Anchors and Pivot section.
  prefs: []
  type: TYPE_NORMAL
- en: Rect Transform edit modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two different edit modes available to you within the **Rect Transform**
    component—Blueprint mode and Raw Edit mode—as represented by the following icons,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25: Rect Transform edit modes](img/Figure_06.25_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.25: Rect Transform edit modes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blueprint mode will ignore any local rotation or scaling applied to it
    and will display the Rect Transform bounding box as a non-rotated, non-scaled
    box. The following screenshot shows the bounding box of a Panel that has been
    rotated and scaled with Blueprint mode turned off and turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26: Blueprint mode on vs. Blueprint mode off](img/Figure_06.26_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.26: Blueprint mode on vs. Blueprint mode off'
  prefs: []
  type: TYPE_NORMAL
- en: The Raw Edit mode will allow you to change the anchor and pivot points of a
    UI object without the object moving or scaling based on the changes you have made.
  prefs: []
  type: TYPE_NORMAL
- en: Anchor and Pivot Points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every UI object has Anchor Handles and a Pivot Point. When used together, they
    will help ensure that your UI is positioned appropriately and scales appropriately
    if the resolution or aspect ratio of your game changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Anchor Handles are represented by four triangles in the form of an X, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: Anchor Handles and Pivot Points](img/Figure_06.27_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.27: Anchor Handles and Pivot Points'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Anchors can be in a group together forming a single Anchor, as shown in
    the preceding diagram, or they can be split into multiple Anchors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28: Splitting Anchor Handles](img/Figure_06.28_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.28: Splitting Anchor Handles'
  prefs: []
  type: TYPE_NORMAL
- en: The Anchors will always form a rectangle. So, the sides will always line up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `0` in an *x* value moves the handles all the way to the left, and a `1`
    moves the handles all the way to the right. You can see from the following screenshots
    how adjusting the *x* value will move the anchor left and right relative to the
    parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29: Adjusting Anchor Min and Max](img/Figure_06.29_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.29: Adjusting Anchor Min and Max'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Rect Transform** has properties for Anchor Presets and **Anchors** **Min**
    and **Max** points. The Anchor represents the point at which the UI element is
    connected to its parent’s Rect Transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30: Accessing the Anchor Presets](img/Figure_06.30_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.30: Accessing the Anchor Presets'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a Canvas has no parent, you’ll see that the Anchor Preset area is empty.
    This is true regardless of the Canvas Render Mode chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31: Lack of Anchor Presets on a Canvas GameObject](img/Figure_06.31_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.31: Lack of Anchor Presets on a Canvas GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the Anchor Presets box will display a list of all the possible
    **Anchor Presets**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 6.32: All available Anchor Presents](img/Figure_06.32_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.32: All available Anchor Presents'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on one of the presets, it will move the anchors to the position
    displayed in the screenshot. You can also adjust the position and pivot point
    using the anchor preset.
  prefs: []
  type: TYPE_NORMAL
- en: The images representing the presets will change if you hold down *Shift* and/or
    *Alt.* Holding *Shift* will show the positions for the pivot point represented
    by blue dots, holding *Alt* will show how the position will change, and holding
    both will show the pivot point and the position change.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33: Setting pivot and position](img/Figure_06.33_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.33: Setting pivot and position'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If using a Mac, since there is no *Alt* key, you will use the *Option* key instead.
    However, the instructions will still say *Alt* in the Editor and this does not
    change for the Mac version. The previous screenshots were taken on a Mac, despite
    it having no *Alt* key.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the **Canvas** **Group** component.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas Group component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add a **Canvas Group** component to any UI object. Attaching it to a
    UI object will let you adjust the specific properties of the object as well as
    all of its children with a single component rather than having to adjust these
    properties for each of the UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: You can add a Canvas Group component to any UI object by selecting **Add Component**
    | **Layout** | **Canvas Group** (you can also just search for Canvas Group) from
    the UI object›s Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.34: The Canvas Group component](img/Figure_06.34_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.34: The Canvas Group component'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can adjust the following properties using a **Canvas** **Group** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` and `1` and represents a percentage of opaqueness; `0` is completely transparent,
    while `1` is completely opaque.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interactable**: This setting determines whether or not the objects within
    the group can accept input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocks Raycasts**: This setting determines if the objects within the group
    will block raycasts from hitting things behind them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ignore Parent Groups**: If this **Canvas Group** component is on a UI element
    that is a child of another UI element with a Canvas Group component, this property
    determines whether this Canvas Group will override the one above it or not. If
    it is selected, it will override the parent’s Canvas Group properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing UI Text and Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s kind of hard to make any UI examples without using text or images. So,
    before we cover examples of layouts, let’s first look at the basic properties
    of the UI Text and UI Image GameObjects. UI Text and UI Images are discussed more
    thoroughly in [*Chapter 11*](B18327_11.xhtml#_idTextAnchor292) and [*Chapter 12*](B18327_12.xhtml#_idTextAnchor328).
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new Text object using **+** | **UI** | **Text**, you will
    see that it has a **Text** Component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.35: The Text component](img/Figure_06.35_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.35: The Text component'
  prefs: []
  type: TYPE_NORMAL
- en: You can change the displayed text by changing the words in the **Text** box.
    In [*Chapter 11*](B18327_11.xhtml#_idTextAnchor292), we’ll take a closer look
    at the individual properties of the **Text** component, but for now, it should
    be fairly obvious what most of the properties do.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new Image object using **+** | **UI** | **Image**, you will
    see that it has an **Image** component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.36: The Image component](img/Figure_06.36_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.36: The Image component'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a Panel is essentially an Image but with a few properties prefilled.
    When you create an Image, however, there are no prefilled properties.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll work with the **Source Image** property in this chapter, which allows
    you to change the displayed sprite. We’ll look at the other properties in [*Chapter
    11*](B18327_11.xhtml#_idTextAnchor292).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s jump into some examples! We’ll be creating a layout for a basic **heads-up-display**
    (**HUD**) and a background image that stretches with the screen and scales at
    multiple resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin building our UI, let’s set up our project and bring in the art
    assets we will need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by setting up our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity Project and name it `Mastering Unity UI Project`. Create
    it in the 2D mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We’re selecting 2D Mode because it will make importing our UI sprites a lot
    easier. When in 2D Mode, all images import as Sprite (2D and UI) images rather
    than Texture images, as they do in 3D Mode. You can change to 3D Mode at any time
    by navigating to **Edit** | **Project Settings** | **Editor** and changing **Mode**
    to **3D**.
  prefs: []
  type: TYPE_NORMAL
- en: Create two new folders within the `Assets` folder named `Scripts` and `Sprites`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new scene and name it `Chapter6.unity`; ensure that you save it in
    the `Scenes` folder. You could also rename `SampleScene.unity` to `Chapter6.unity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll be using art assets that I’ve modified from free art assets found at
    the following sites:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://opengameart.org/content/free-game-gui](https://opengameart.org/content/free-game-gui)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://opengameart.org/content/cat-dog-free-sprites](https://opengameart.org/content/cat-dog-free-sprites)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Chapter2/Sprites` folder of the text’s source files, locate the `catSprites.png`,
    `pinkBackground.png`, and `uiElements.png` images and import them into your project
    by dragging them into the `Sprites` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.37: Importing the sprites](img/Figure_06.37_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.37: Importing the sprites'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to slice the sprite sheets into individual sprites. If you already
    know how to slice sprite sheets, do so now for the `catSprites` image and the
    `uiElements` image and proceed to the *Laying out the Basic HUD* section. If you
    are not familiar with the process, follow these steps, and continue to Step 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `catSprites` image, hold *Ctrl,* and click on the `uiElements` image
    so that both are selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.38: Selecting both sprite sheets](img/Figure_06.38_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.38: Selecting both sprite sheets'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `catSprites` and `uiElements` sprites to be considered sprite sheets.![Figure
    6.39: Converting the sprites to Multiple Sprite Mode](img/Figure_06.39_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.39: Converting the sprites to Multiple Sprite Mode'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the **Inspector** says **2 Texture 2Ds Import Settings** because we
    have selected two images.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now select the `catSprites` image and open the **Sprite Editor** with the button
    in the **Import** **Settings** Panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Sprite Editor** open, select **Slice**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now change the slice properties so that the **Slice Type** is **Automatic**
    and the sprite **Pivot** is applied to the **Bottom**. Once done, hit **Slice**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see the sprite broken into three separate regions. Hit **Apply**
    to save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you click on the arrow on the `catSprites` image in the project folder
    view, you should see the individual images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.40: The split sprite sheet](img/Figure_06.40_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.40: The split sprite sheet'
  prefs: []
  type: TYPE_NORMAL
- en: Complete Steps 8 through 12 for the `uiElements` image, but set the pivot point
    to the **Center**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our project and sprites set up, we can begin with the UI examples.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out a basic HUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will make a HUD that will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.41: The HUD we will develop](img/Figure_06.41_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.41: The HUD we will develop'
  prefs: []
  type: TYPE_NORMAL
- en: It will be expanded upon in the upcoming chapters, but for now, it’ll have a
    pretty simple layout that will focus on parent–child relationships and anchor/pivot
    point placement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the HUD shown in the preceding image, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Canvas using **+** | **UI** | **Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Canvas `HUD Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is best to set up all of your `1024` x `768`. If you look at the `pinkBackground`
    image (that we’ll apply in the next example), it has a resolution of `2048` x
    `1536`; `1024` x `768` has the same aspect ratio as the background image. So,
    set your **Canvas Scaler** component to the following settings:![Figure 6.42:
    The Canvas Scaler properties](img/Figure_06.42_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.42: The Canvas Scaler properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have set the `1` so that it maintains the ratios in the vertical direction.
    If you remember from the *Scale with Screen Size* section, I find that this works
    best for most games made with a landscape resolution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set your Game view to `1024` x `768` so that you will see everything scaled
    appropriately (refer to the *Changing the Aspect Ratio and Resolution of the Game
    View* section of [*Chapter 1*](B18327_01.xhtml#_idTextAnchor014) for directions
    on adding your own Game view resolution.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.43: 1024 x 768 Game view resolution](img/Figure_06.43_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.43: 1024 x 768 Game view resolution'
  prefs: []
  type: TYPE_NORMAL
- en: Since we only have one Canvas, when we add any new UI elements to our scene,
    they will automatically be made children of our `HUD Canvas`. Create a new Panel
    using `HUD` `Panel`. You will see that it is a child of the `HUD Canvas`. This
    Panel will represent the rectangle that holds all the HUD elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Anchor Presets icon to open the **Anchor Presets**. Select the
    top-left Anchor Preset while holding down *Shift* + *Alt*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.44: Set the Anchor Preset of the HUD Panel](img/Figure_06.44_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.44: Set the Anchor Preset of the HUD Panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the `uiElements` image by selecting the arrow on its right. Locate the
    `uiElements_1` sub-image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.45: Set the Anchor Preset of the HUD Panel](img/Figure_06.45_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.45: Set the Anchor Preset of the HUD Panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag `uiElements_1` to the `HUD Panel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.46: The Image component with uiElements_1 assigned](img/Figure_06.46_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.46: The Image component with uiElements_1 assigned'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the Panel is very faint and stretches across the whole screen. Let’s
    make it easier to see by increasing the opacity. Click on the white rectangle
    in the `Alpha` slider all the way to the right or input the value `255` in the
    alpha value slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.47: Adjusting the alpha value on the color picker to full alpha](img/Figure_06.47_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.47: Adjusting the alpha value on the color picker to full alpha'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the checkbox next to the **Preserve Aspect** setting in the **Image**
    component. This property will make the image always maintain the aspect ratio
    of the original image, even if you set the width and height of the Image to something
    that does not have the same aspect ratio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Panel will now take up only the top portion of the scene:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.48: The Panel after preserving the aspect ratio](img/Figure_06.48_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.48: The Panel after preserving the aspect ratio'
  prefs: []
  type: TYPE_NORMAL
- en: From the `HUD Panel`, you’ll note that the `1024` and `768`, respectively. You
    can also see more easily from the **Scene** view that the Rect Transform expands
    past the viewable region of the sprite. So, the object is much larger than it
    appears to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.49: The Rect Transform exceeding the visible image area](img/Figure_06.49_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.49: The Rect Transform exceeding the visible image area'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s rescale the Rect Transform of the Panel so that it matches the size we
    are looking for and hugs the viewable image better. Change the `300` and the `102`.
    The Rect Transform won’t be a perfectly snug fit in the vertical direction, but
    it will be pretty close.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.50: Rescaling the Rect Transform of the HUD Panel](img/Figure_06.50_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.50: Rescaling the Rect Transform of the HUD Panel'
  prefs: []
  type: TYPE_NORMAL
- en: We now have the main Panel set up. Since all other images will be contained
    within the `HUD Panel`, we want to make them children of the `HUD` `Panel`. That
    way, when the screen rescales, the other images will remain “inside” the `HUD`
    `Panel` and will maintain their size relative to the `HUD` `Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start with the Image that holds the cat character’s head. Right-click
    on the `HUD Panel` and select `HUD Panel`. Rename it `Character Holder`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Place the `uiElement_6` sprite in the **Source Image** slot and select **Preserve
    Aspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since the `Character` `Holder` image is a child of the `HUD` `Panel`, any anchoring
    we set will be relative to the `HUD` `Panel`. Choose the **left-stretch** Anchor
    Preset while holding *Shift* + *Alt*. Additionally, set the position and dimension
    variables as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.51: Rescaling the Rect Transform of the Character Holder](img/Figure_06.51_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.51: Rescaling the Rect Transform of the Character Holder'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the Image for the cat head. We want it to fully fill out the slot
    represented by the `Character Holder` image. So, we will make it a child of the
    `Character` `Holder` image. Right-click on `Character Holder` and select `Character
    Image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add the `catSprites_0` subimage to the **Source Image** of the **Image**
    component and select **Preserve Aspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Anchor Preset** to **stretch-stretch** while holding *Shift* + *Alt*:![Figure
    6.52: Rescaling the Rect Transform of the Character Image](img/Figure_06.52_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.52: Rescaling the Rect Transform of the Character Image'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we ensured that we have the `Character Holder` fit snuggly around the
    holder›s image, it should make the cat›s head fit perfectly within the holder
    image without having to adjust any settings!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.53: The Character Image fitting within the Character Holder](img/Figure_06.53_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.53: The Character Image fitting within the Character Holder'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we are ready to start making the health bar. We will create it similarly
    to the way we made the `Character Holder` and `Character`. Right-click on the
    `HUD Panel` and select `Health Holder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the `uiElement_20` sprite in the **Source Image** slot and select **Preserve
    Aspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Rect Transform** properties as shown in the following image, and
    ensure that you hold *Shift + Alt* when selecting the **Anchor Preset**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.54: The properties of the Health Holder](img/Figure_06.54_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.54: The properties of the Health Holder'
  prefs: []
  type: TYPE_NORMAL
- en: Now, all we have left is the health bar! Just as we made the cat head Image
    a child of the `Character Holder`, we will need to make the health bar’s Image
    a child of `Health Holder`. Right-click on `Health Holder` and select `Health
    Bar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the `uiElement_23` image in the **Source Image** slot. This time, we will
    not be selecting **Preserve Aspect** because we want the image to scale this image
    horizontally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Rect Transform** properties as shown in the following screenshot,
    and ensure that you hold *Shift + Alt* when selecting the **Anchor Presets**:![Figure
    6.55: The properties of Health Holder](img/Figure_06.55_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.55: The properties of Health Holder'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that a little padding was added so that you can see the edges of `Health
    Holder`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before proceeding, it is important that your Rect Transform Positioning mode
    is set to **Pivot**. Otherwise, you will not be able to move the pivot in the
    next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.56: The Rect Transform Positioning mode](img/Figure_06.56_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.56: The Rect Transform Positioning mode'
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost done! Right now, the pivot point of the image is right at the center.
    This means if we try to scale it, it will scale toward the center. However, we
    want it to be able to scale toward the left. So, open the **Anchor Presets**,
    and while holding *Shift* only, select **middle-left**. This will cause only the
    pivot point to move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.57: Moving the pivot point](img/Figure_06.57_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.57: Moving the pivot point'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we adjust the **Scale X** value on the **Rect Transform**, the health
    bar will scale toward the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.58: Adjusting the scale of the health bar](img/Figure_06.58_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.58: Adjusting the scale of the health bar'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for our HUD example! Try changing your Game view’s aspect ratio to
    different settings so that you can see the Panel scale appropriately and see all
    the object-relative positions maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your HUD is doing some wonky stuff when you change the Game’s aspect ratio,
    ensure that your objects have the correct parent–child relationship. Your parent–child
    relationships should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.59: The Hierarchy’s parent–child relationship](img/Figure_06.59_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.59: The Hierarchy’s parent–child relationship'
  prefs: []
  type: TYPE_NORMAL
- en: Also, check to ensure that the anchor and pivot points are set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Placing a 2D game background image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Placing a background image that scales with the screen is not too difficult
    as long as you use the appropriate Canvas properties. We will expand upon our
    HUD example and place a background image in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.60: The result of the background image](img/Figure_06.60_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.60: The result of the background image'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need to ensure that this background image doesn’t just display behind
    other UI elements but also displays behind any game objects we may put in our
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a background image that displays behind all UI elements as well as
    all game elements, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Canvas using **+** | **UI** | **Canvas.** I like to use different
    Canvases to sort my different UI elements, but the need for a new Canvas stems
    from more than personal preference in this case. We need a new Canvas because
    we need a Canvas with a different Render Mode. This Canvas will use the **Screen
    Space-Camera** Render Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Canvas `Background Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `Main Camera` into the **Render** **Camera** slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.61: The Canvas component of the Background Canvas](img/Figure_06.61_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.61: The Canvas component of the Background Canvas'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that this Canvas appears behind all other UI elements and all the
    2D sprites in the game, we will need to use Sorting Layers. In the top-right corner
    of the Unity Editor, you will see a dropdown menu labeled **Layers**. Select it
    and select **Edit Layers**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.62: Editing Layers](img/Figure_06.62_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.62: Editing Layers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand `Background`.![Figure 6.63: Adding the Background Sorting Layer](img/Figure_06.63_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.63: Adding the Background Sorting Layer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sorting layers work so that whichever is on the top of this list will render
    the furthest back in the scene. So, if you wanted to add a foreground layer, you’d
    add it below `Background` layer will be behind any new sprite you create. If you
    do create new layers, ensure that the `Background` layers stay on the top of this
    list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Reselect `Background Canvas` and now change the **Sorting Layer** to **Background**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.64: Setting the Background Sorting Layer](img/Figure_06.64_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.64: Setting the Background Sorting Layer'
  prefs: []
  type: TYPE_NORMAL
- en: Now, all we need to do is add the background image. Right-click on the `Background
    Canvas` and select `Background Image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the `pinkBackground` sprite in the **Source Image** slot. This time, we
    will not be selecting **Preserve Aspect** because we want the image to be able
    to squash and stretch as the game screen resizes and always fills the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Rect Transform** properties as shown and ensure that you hold *Shift*
    + *Alt* when selecting the **Anchor Presets**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.65: The Background Image settings](img/Figure_06.65_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.65: The Background Image settings'
  prefs: []
  type: TYPE_NORMAL
- en: Because the `Background Canvas` is set to **Screen Space – Camera**, you may
    have to change your view so that you can see it. It will be where the Main Camera
    view is.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! Try changing the Game view’s aspect ratio around and resizing the
    screen in **Free Aspect** mode so that you can see the background image always
    filling the screen. Also, try adding some non-UI 2D sprites to the scene and see
    how they render on top of the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that is not ideal about this example is that the background image
    is being allowed to change its aspect ratio. You’ll see that the image looks pretty
    bad at some aspect ratios because of this. This background image will not be a
    good choice for a game that would be released on multiple aspect ratios. I chose
    this image for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You can see how it’s important to pick an image that doesn’t depend so highly
    on aspect ratio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was free!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I highly recommend that if you use this method to create a background image,
    you use one with a pattern that doesn’t so obviously display distortion.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic pop-up menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last example we will cover in this chapter will utilize the **Canvas Group**
    component. We won›t be able to really see this component in action until we start
    programming in [*Chapter 8*](B18327_08.xhtml#_idTextAnchor147), but we can lay
    the groundwork now. We’ll also get a bit more practice with laying out UI with
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.66: The pop-up Panel we will lay out](img/Figure_06.66_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.66: The pop-up Panel we will lay out'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the pop-up menu shown in the preceding image, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Canvas using **+** | **UI** | **Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Popup Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I want to use the same properties for the `HUD Canvas`. Instead of setting up
    all that again, I’ll use a shortcut and copy the `HUD Canvas`. To do so, select
    the three dots (the “kabob” menu) in the right-hand corner of the `HUD Canvas`
    and select **Copy Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select the “kabob” menu in the right-hand corner of the `Popup Canvas` and
    select **Paste** **Component Values**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will add a Panel that will hold all the items, similarly to the way we did
    with the HUD. This will ensure that everything stays together as it should. Right-click
    on `Popup Canvas` and select `Pause Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the `uiElement_32` image in the **Source Image** slot, give it a full
    alpha value, and select **Preserve Aspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Rect Transform** properties as shown in the following screenshot,
    and ensure that you hold *Shift* + *Alt* when selecting the **Anchor Preset**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.67: The properties of Pause Panel](img/Figure_06.67_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.67: The properties of Pause Panel'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s give the Panel a nice banner at the top. Right-click on `Popup Panel`
    and select `Pause Banner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the `uiElement_27` image in the **Source Image** slot and select **Preserve
    Aspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Rect Transform** properties as shown in the following screenshot,
    and ensure that you hold *Shift* + *Alt* when selecting the **Anchor Presets**:![Figure
    6.68: The properties of Pause Banner](img/Figure_06.68_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.68: The properties of Pause Banner'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ll add the text to this banner in a later chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The main point of this example was to demonstrate the use of the `Pause Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Pause Panel`, and then select **Add Component** | **Layout** | **Canvas
    Group** (you can also just search for Canvas Group).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That’s it for now! Change the values of `Pause Panel` `Pause Panel` and the
    `Pause Banner` alpha values change. This is great for pop-up menus you want to
    hide and show without having to program each item individually. Once we spend
    more time with `Pause Panel`, it will have a lot more items on it, and we will
    be happy that we don’t have to program each piece individually.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! This chapter was intense! There was a lot to cover, as this chapter set
    the groundwork that will be used throughout the rest of this book. We discussed
    the concept of a Canvas and how to correctly position it within your scene. Additionally,
    we discussed the basic UI Panel to allow us to explore the concept of positioning
    UI elements within a scene. Correctly setting up Canvases and their scalars is
    an important first step in developing UI.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover how to create different automatic layouts that will
    let us line up our UI in grids.
  prefs: []
  type: TYPE_NORMAL
