- en: Chapter 5. Concurrent Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。并发集合
- en: 'In this chapter, we are going to cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Adding and removing items to `BlockingCollection`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `BlockingCollection` 添加和删除项目
- en: Iterating a `BlockingCollection` with `GetConsumingEnumerable`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GetConsumingEnumerable` 迭代 `BlockingCollection`
- en: Performing LIFO operations with `ConcurrentStack`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentStack` 执行 LIFO 操作
- en: Thread safe data lookups with `ConcurrentDictionary`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentDictionary` 进行线程安全的数据查找
- en: Cancelling an operation in a concurrent collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消并发集合中的操作
- en: Working with multiple producers and consumers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个生产者和消费者一起工作
- en: Creating object pool with `ConcurrentStack`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentStack` 创建对象池
- en: Adding blocking and bounding with `IProducerConsumerCollection`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `IProducerConsumerCollection` 添加阻塞和边界
- en: Using multiple concurrent collections to create a pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个并发集合创建管道
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Although `System.Collections` namespace offers a wide range of collections;
    the only thing which limits our use of them in a multi-threaded or parallel environment
    is that they are not thread safe. A non thread safe collection could lead to race
    conditions, which is a condition that occurs when two or more threads can access
    shared data and try to change it at the same time, producing unexpected errors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `System.Collections` 命名空间提供了广泛的集合；但在多线程或并行环境中使用它们的限制是它们不是线程安全的。非线程安全的集合可能导致竞态条件，这是一种当两个或多个线程可以访问共享数据并尝试同时更改它时发生的情况，从而产生意外的错误。
- en: Concurrent collections in .NET Framework 4.5 allow the developers to create
    type safe as well as thread safe collections. These collection classes form an
    essential part of the parallel programming feature and are available under the
    namespace `System.Collections.Concurrent`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 4.5 中的并发集合允许开发人员创建类型安全和线程安全的集合。这些集合类是并行编程功能的重要组成部分，并在 `System.Collections.Concurrent`
    命名空间下可用。
- en: Adding and removing items to BlockingCollection
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 BlockingCollection 添加和删除项目
- en: '`BlockingCollection<T>` is a thread safe collection class that provides blocking
    and bounding functionality. Bounding means that you can set the maximum capacity
    of a collection, which enables you to control the maximum size of the collection
    in the memory.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>` 是一个线程安全的集合类，它提供了阻塞和边界功能。边界意味着你可以设置集合的最大容量，这使你能够控制集合在内存中的最大大小。'
- en: Multiple threads can add items to a collection concurrently, but if the collection
    reaches capacity, the producing threads will block until items are removed. Multiple
    consumers can remove items from the collection concurrently. If the collection
    becomes empty, consumption will block until more items are produced and added
    to the collection.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程可以同时向集合中添加项目，但如果集合达到容量，生产线程将阻塞，直到项目被移除。多个消费者可以同时从集合中移除项目。如果集合变为空，消费将阻塞，直到有更多项目被生产并添加到集合中。
- en: In this recipe, we will take a look at the basics of adding items to, and removing
    items from `BlockingCollection`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看向 `BlockingCollection` 添加项目和从 `BlockingCollection` 中删除项目的基本方法。
- en: We are going to create a `Console` application that initializes a range of integers
    and creates a parallel task to add the numbers to a blocking collection. Another
    parallel task will be created to remove items from the collection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Console` 应用程序，初始化一系列整数并创建一个并行任务将数字添加到阻塞集合中。另一个并行任务将被创建来从集合中移除项目。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's start Visual Studio and see how to add and remove items with `BlockingCollection`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 Visual Studio，看看如何使用 `BlockingCollection` 添加和删除项目。
- en: Start a new project using the **C# Console Application** project template and
    assign `BlockingCollection` as the **Solution name**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板开始一个新的项目，并将 `BlockingCollection` 作为 **解决方案名称** 指定。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, in the `Main` method of the `Program` class, let's create our range of
    input data and our blocking collection.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `Program` 类的 `Main` 方法中，让我们创建我们的输入数据范围和阻塞集合。
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's create simple producer `Task` which will use a `for` loop to iterate
    through the numbers of our source data and add them to the blocking collection.
    After we are finished with the loop, use the `CompleteAdding` method of `BlockingCollection`
    to indicate we are done producing data.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的生产者 `Task`，它将使用 `for` 循环遍历源数据中的数字并将它们添加到阻塞集合中。在循环完成后，使用 `BlockingCollection`
    的 `CompleteAdding` 方法来指示我们已完成数据的生产。
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, let's create a simple consumer `Task` that uses a `while` loop to take
    items from `BlockingCollection` and write the output to `Console`. Finish up by
    waiting for user input before exiting.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个简单的消费者`Task`，它使用`while`循环从`BlockingCollection`中获取项目并将输出写入`Console`。完成操作后，等待用户输入再退出。
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_01.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你应该会看到以下截图所示的输出：![如何实现…](img/0225OT_05_01.jpg)
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we see how to add items to and remove items from `BlockingCollection`.
    `BlockingCollection` is actually a wrapper for `IProducerConsumer<T>`, and provides
    the blocking and bounding capabilities for thread safe collections. `BlockingCollection`
    takes `IProducerConsumerCollection` in its constructor, or uses `ConcurrentQueue`
    by default.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们看到了如何向`BlockingCollection`中添加项目以及如何从中移除项目。`BlockingCollection`实际上是对`IProducerConsumer<T>`的包装，并为线程安全的集合提供了阻塞和边界能力。`BlockingCollection`在其构造函数中接受`IProducerConsumerCollection`，或默认使用`ConcurrentQueue`。
- en: Adding the source data to the collection was easy enough. We just had to loop
    through the source data and call the `Add` method of `BlockingCollection` to add
    the item. When we are finished adding items to the collection, we call the `CompleteAdding`
    method. After a collection has been marked as complete for adding, no more adding
    will be permitted, and threads removing items from the collection will not wait
    when the collection is empty.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将源数据添加到集合中非常简单。我们只需遍历源数据并调用`BlockingCollection`的`Add`方法来添加项目。当我们完成向集合添加项目后，我们调用`CompleteAdding`方法。一旦集合被标记为添加完成，将不允许再添加更多项目，并且从集合中移除项目的线程在集合为空时不会等待。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Consumer `Task` uses the `IsCompleted` property of `BlockingCollection` to control
    a `while` loop. The `IsCompleted` property, as you would expect, indicates if
    `BlockingCollection` has been marked as complete for adding, and is empty. Inside
    the `while` loop, we just use the `Take` method to take an item from the collection
    and display it on the `Console` application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者`Task`使用`BlockingCollection`的`IsCompleted`属性来控制`while`循环。正如你所期望的，`IsCompleted`属性指示`BlockingCollection`是否被标记为添加完成并且为空。在`while`循环内部，我们只需使用`Take`方法从集合中获取一个项目并在控制台上显示它。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Iterating a BlockingCollection with GetConsumingEnumerable
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GetConsumingEnumerable遍历BlockingCollection
- en: '`BlockingCollection` provides us with an easier alternative for looping through
    a collection, and removing items without setting up a `while` loop, and checking
    the `IsCompleted` property. `BlockingCollection` gives us the ability to do a
    simple `foreach` loop with the `GetConsumingEnumerable` method.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection`为我们提供了一个更简单的替代方案，用于遍历集合，并在不设置`while`循环和检查`IsCompleted`属性的情况下移除项目。`BlockingCollection`通过`GetConsumingEnumerable`方法为我们提供了执行简单`foreach`循环的能力。'
- en: In this recipe, we are going to create a `Console` application that initializes
    a range of source data and spins up a producer task to add the data to the collection.
    The consumer of the collection data will use the `GetConsumingEnumerable` method
    to get `IEnumerable<T>` for items in the collection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个`Console`应用程序，初始化一系列源数据并启动一个生产者任务将数据添加到集合中。集合数据的消费者将使用`GetConsumingEnumerable`方法来获取集合中项目的`IEnumerable<T>`。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's take a look at how to iterate over a `BlockingCollection` with `GetConsumingEnumerable`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`GetConsumingEnumerable`遍历`BlockingCollection`。
- en: Start a new project using the **C# Console Application** project template and
    assign `Enumerate` as the **Solution name**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将`Enumerate`作为**解决方案名称**。
- en: Add the following `using` directives to the top of your `Program` class.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`Program`类的顶部。
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, in the `Main` method of the `Program` class, let's create our range of
    input data and our blocking collection.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Program`类的`Main`方法中，让我们创建我们的输入数据范围和阻塞集合。
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next let's create a simple producer `Task` which will use a `for` loop to iterate
    through the numbers of our source data and add them to the blocking collection.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个简单的生产者`Task`，它将使用`for`循环遍历源数据的数字并将它们添加到阻塞集合中。
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, let's create a consumer `Task` which will iterate through the collection
    with a `foreach` loop by calling the `GetConsumingEnumerable` method of blocking
    collection. Finish up by waiting for user input before exiting.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个消费者`Task`，它将通过调用阻塞集合的`GetConsumingEnumerable`方法使用`foreach`循环遍历集合。完成时，在退出之前等待用户输入。
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_02.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何做…](img/0225OT_05_02.jpg)
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Producer `Task` in this recipe is exactly the same as producer `Task` created
    in the first recipe. The only real change to take note of is that we no longer
    have to set up a `while` loop to take items from the collection, as we did in
    the first recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的生产者`Task`与第一个食谱中创建的生产者`Task`完全相同。唯一真正需要注意的改变是，我们不再需要设置一个`while`循环从集合中获取项目，就像我们在第一个食谱中所做的那样。
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By calling the `GetConsumingEnumerable` method of `BlockingCollection`, we can
    now use much cleaner `foreach` loop syntax.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`BlockingCollection`的`GetConsumingEnumerable`方法，我们现在可以使用更干净的`foreach`循环语法。
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `GetConsumingEnumerable` method takes a snapshot of the current state of
    the underlying collection and returns `IEnumerable<T>` for the collection items.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetConsumingEnumerable`方法会捕捉底层集合的当前状态，并返回集合项目的`IEnumerable<T>`。'
- en: Performing LIFO operations with ConcurrentStack
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ConcurrentStack执行LIFO操作
- en: '`ConcurrentStack` is the thread safe counterpart of `Systems.Collections.Generic.Stack`,
    which is the standard **Last-In-First-Out** (**LIFO**) container in the .NET Framework.
    For algorithms that favor stack usage such as depth-first searches, a thread safe
    stack is a big benefit.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentStack`是`Systems.Collections.Generic.Stack`的线程安全版本，后者是.NET Framework中的标准**后进先出**（**LIFO**）容器。对于倾向于使用堆栈的算法，如深度优先搜索，线程安全的堆栈是一个很大的好处。'
- en: In this recipe we are going to take a look at the basic usage of `ConcurrentStack`.
    Our `Console` application for this recipe will initialize a range of data, which
    a simple producer `Task` will push onto the stack. Consumer `Task` will concurrently
    pop items from the stack and write them to `Console`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将查看`ConcurrentStack`的基本用法。我们的`Console`应用程序将为这个食谱初始化一系列数据，一个简单的生产者`Task`将把这些数据推入堆栈。消费者`Task`将并发地从堆栈中弹出项目并将它们写入`Console`。
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Now, let's take a look at performing LIFO operations with `ConcurrentStack`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`ConcurrentStack`执行LIFO操作。
- en: Start a new project using the **C# Console Application** project template and
    assign `ConcurrentStack` as the **Solution name**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C# Console Application**项目模板创建一个新的项目，并将`ConcurrentStack`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到你的`Program`类顶部：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, in the `Main` method of the `Program` class, let's create our range of
    input data and our blocking collection.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Program`类的`Main`方法中，让我们创建我们的输入数据范围和我们的阻塞集合。
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let's create a simple producer task which will use a `for` loop to iterate
    through the numbers of our source data and pop them onto the stack.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个简单的生产者任务，它将使用一个`for`循环遍历源数据中的数字并将它们弹出堆栈。
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now let's create a consumer `Task` which will use a `while` loop to pop items
    off the stack while the `IsEmpty` property of the stack is false. Finish by waiting
    for user input before exiting.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个消费者`Task`，它将使用一个`while`循环从堆栈中弹出项目，直到堆栈的`IsEmpty`属性为假。完成时，在退出之前等待用户输入。
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_03.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何做…](img/0225OT_05_03.jpg)
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`ConcurrentStack` achieves thread safe access by using the `System.Threading.Interlocked`
    operations. Interlocked operations provide a simple mechanism for synchronizing
    access to variables shared by multiple threads. Interlocked operations are also
    very fast.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentStack`通过使用`System.Threading.Interlocked`操作实现线程安全访问。Interlocked操作提供了一种简单的机制，用于同步多个线程共享的变量的访问。Interlocked操作也非常快速。'
- en: For the most part, `ConcurrentStack` behaves like `System.Collections.Generic.Stack`.
    To push an item onto the stack, you just use the `Push` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`ConcurrentStack`的行为类似于`System.Collections.Generic.Stack`。要向堆栈中推入一个项目，你只需使用`Push`方法。
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, the `Pop` method was removed in favor of `TryPop`. `TryPop` returns
    `true` if an item existed and was popped, otherwise it returns `false`. The `out`
    parameter contains the object removed if the pop was successful, otherwise it
    is indeterminate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了支持`TryPop`，`Pop`方法已被移除。`TryPop`如果存在并弹出项目，则返回`true`，否则返回`false`。如果弹出成功，`out`参数包含被移除的对象，否则是不确定的。
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Thread safe data lookups with ConcurrentDictionary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ConcurrentDictionary`进行线程安全数据查找
- en: '`ConcurrentDictionary` is the thread safe counterpart to the generic `dictionary`
    collection. Both are designed for quick lookups of data based on a key. However,
    `ConcurrentDictionary` allows us to interleave both reads and updates. `ConcurrentDictionary`
    achieves its thread safety with no common lock to improve efficiency. It actually
    uses a series of locks to provide concurrent updates, and has lockless reads.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary`是泛型`dictionary`集合的线程安全版本。两者都旨在基于键快速查找数据。然而，`ConcurrentDictionary`允许我们交错读取和更新。`ConcurrentDictionary`通过没有公共锁来提高效率实现其线程安全性。它实际上使用一系列锁来提供并发更新，并且具有无锁读取。'
- en: In this recipe, we will create `ConcurrentDictionary` and initialize it with
    a small set of key value pairs. Our `dictionary` will be concurrently updated
    by one task and read by another.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建`ConcurrentDictionary`并使用一组小的键值对初始化它。我们的`dictionary`将由一个任务并发更新，并由另一个任务读取。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's take a look at how to use `ConcurrentDictionary` for data lookups.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`ConcurrentDictionary`进行数据查找。
- en: Start a new project using the **C# Console Application** project template and
    assign `ConcurrentDictionary` as the **Solution name**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C# Console Application**项目模板创建一个新的项目，并将`ConcurrentDictionary`分配为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`Program`类的顶部：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, let's create our `ConcurrentDictionary` and initialize it with some data.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的`ConcurrentDictionary`并使用一些数据初始化它。
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now let's create `Task` to update `dictionary` on a separate thread.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`Task`，在单独的线程上更新`dictionary`。
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now let's create another `Task` which will be concurrently reading from `dictionary`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个`Task`，它将并发地从`dictionary`中读取。
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_04.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何操作…](img/0225OT_05_04.jpg)
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`ConcurrentDictionary` behaves like `dictionary` counterpart with slight differences.
    We are updating `dictionary` using the `TryUpdate` method. This method was added
    to provide us with an atomic operation to check if the item exists, and if not,
    add it while still under an atomic lock.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary`的行为类似于`dictionary`的对应版本，但略有不同。我们使用`TryUpdate`方法更新`dictionary`。此方法被添加以提供原子操作来检查项目是否存在，如果不存在，则在原子锁下添加它。'
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are reading `dictionary` directly from the `Key` and `Value` properties of
    each `KeyValuePair` in the collection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接从集合中每个`KeyValuePair`的`Key`和`Value`属性读取`dictionary`。
- en: Cancelling an operation in a concurrent collection
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消并发集合中的操作
- en: When working with `BlockingCollection`, most `Add` and `Take` operations are
    performed in a loop. The `TryAdd` and `TryTake` methods of `BlockingCollection`
    can accept a `CancellationToken` parameter so that we can respond to cancellation
    requests and break out of a loop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`BlockingCollection`一起工作时，大多数`Add`和`Take`操作都是在循环中执行的。`BlockingCollection`的`TryAdd`和`TryTake`方法可以接受一个`CancellationToken`参数，这样我们就可以响应取消请求并退出循环。
- en: In this recipe, we are going to create a `Console` application that has producer
    `Task` and consumer `Task`. The producer will be adding items to `BlockingCollection`
    using `TryAdd`, and the consumer will be removing items using `Try`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个具有生产者`Task`和消费者`Task`的`Console`应用程序。生产者将通过使用`TryAdd`向`BlockingCollection`添加项目，而消费者将使用`Try`移除项目。
- en: After the producer and consumer get started, we will call the `Cancel` method
    on a token source to see how we can use the `TryAdd` and `TryTake` overloads to
    handle cancellation of our operation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产者和消费者开始后，我们将在一个令牌源上调用`Cancel`方法，以查看我们如何使用`TryAdd`和`TryTake`重载来处理操作的取消。
- en: Getting ready…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime `Exception` is thrown, and
    intercepts the `Exception` before it gets to our handler.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要关闭 Visual Studio 2012 的异常助手。异常助手会在抛出运行时 `Exception` 时出现，并在它到达我们的处理器之前拦截
    `Exception`。
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，请转到 **调试** 菜单并选择 **异常**。
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_05_05.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选 **公共语言运行时异常** 旁边的 **用户未处理** 复选框。![准备中…](img/0225OT_05_05.jpg)
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now, let's see how to cancel a concurrent collection operation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何取消并发集合操作。
- en: Start a new project using the **C# Console Application** project template and
    assign `CancelOperation` as the **Solution name**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板启动一个新项目，并将 `CancelOperation` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the `Main` method of the `Program` class, let's create a source range of
    numbers, instantiate our `CancellationTokenSource` and obtain `CancellationToken`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `Main` 方法中，让我们创建一个数字范围，实例化我们的 `CancellationTokenSource` 并获取 `CancellationToken`。
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, just below the previous lines, create a producer `Task` and pass in `CancellationToken`.
    The producer should add items to `BlockingCollection` by calling `TryAdd` inside
    a `try`/`catch` block. The `catch` block should handle `OperationCancelledException`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在上一行下方创建一个生产者 `Task` 并传入 `CancellationToken`。生产者应该通过在 `try`/`catch` 块中调用
    `TryAdd` 来向 `BlockingCollection` 添加项目。`catch` 块应该处理 `OperationCancelledException`。
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now let's create a consumer `Task` and pass in `CancellationToken`. The consumer
    task should take items from `BlockingCollection` by calling `TryTake` inside a
    `try`/`catch` block. The `catch` block should handle `OperationCancelledException`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个消费者 `Task` 并传入 `CancellationToken`。消费者任务应该通过在 `try`/`catch` 块中调用 `TryTake`
    来从 `BlockingCollection` 中获取项目。`catch` 块应该处理 `OperationCancelledException`。
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, let's have the main thread wait for a bit, then call the `Cancel` method
    of `CancellationTokenSource`. Wait for user input before exiting.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让主线程等待一会儿，然后调用 `CancellationTokenSource` 的 `Cancel` 方法。在退出之前等待用户输入。
- en: '[PRE27]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_06.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到以下截图所示的输出：![如何操作…](img/0225OT_05_06.jpg)
- en: How it works…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Responding to cancellations when working with `BlockingCollection` is pretty
    consistent with other classes in the Task Parallel Library.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `BlockingCollection` 处理取消操作时，与其他 Task Parallel Library 中的类非常一致。
- en: In the producer task, we use the overload of `TryAdd` that accepts an out parameter,
    a timeout parameter and `CancellationToken`. We also call `TryAdd` in a `try`/`catch`
    block, so we can respond to `OperationCancelledException`. When the operation
    is cancelled, we call `CompleteAdding` to indicate we will be adding more items
    and execute a `break` statement to break out of the loop.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产者任务中，我们使用接受输出参数、超时参数和 `CancellationToken` 的 `TryAdd` 重载。我们还在 `try`/`catch`
    块中调用 `TryAdd`，以便响应 `OperationCancelledException`。当操作被取消时，我们调用 `CompleteAdding`
    来指示我们将继续添加更多项目，并执行一个 `break` 语句来跳出循环。
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Things are very similar on the consumer side. We pass `CancellationToken` into
    `TryTake` and handle `OperationCancelledException` in our `catch` block. When
    the operation is cancelled, we issue a `break` statement to break out of the loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者端的操作非常相似。我们将 `CancellationToken` 传递给 `TryTake`，并在我们的 `catch` 块中处理 `OperationCancelledException`。当操作被取消时，我们发出一个
    `break` 语句来跳出循环。
- en: Working with multiple producers and consumers
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多个生产者和消费者一起工作
- en: It is possible to use single `BlockingCollection` as a buffer between multiple
    producers and consumers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用单个 `BlockingCollection` 作为多个生产者和消费者之间的缓冲区。
- en: In this recipe, we are going to build a `Console` application that will create
    multiple producer tasks which perform an expensive math operation on a small range
    of numbers. We will also have two consumer tasks that loop through the `BlockingCollection`
    buffer and display the results.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个 `Console` 应用程序，该程序将创建多个执行昂贵数学运算的小范围数字的生产者任务。我们还将有两个消费者任务，它们将循环遍历
    `BlockingCollection` 缓冲区并显示结果。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's take a look at using a single `BlockingCollection` with multiple
    producers and consumers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用单个 `BlockingCollection` 和多个生成器和消费者。
- en: Start a new project using the **C# Console Application** project template and
    assign `MultiptleProducerConsumer` as the **Solution name**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板创建一个新的项目，并将 `Solution name` 设置为 `MultiptleProducerConsumer`。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's start by creating a `static` method on the `Program` class which performs
    our expensive math operation.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `Program` 类上创建一个执行我们昂贵的数学运算的 `static` 方法开始。
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now let's create another `static` method on the `Program` class that the consumers
    will use to display the results to the `Console` application. This method will
    call `GetConsumingEnumerable` on `BlockingCollection` and loop through the collection.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `Program` 类上创建另一个 `static` 方法，消费者将使用此方法将结果显示到 `Console` 应用程序中。此方法将在
    `BlockingCollection` 上调用 `GetConsumingEnumerable` 并遍历集合。
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, in the `Main` method of the `Program` class, let's define our `BlockingCollection`
    buffer and create `List<Task>`, so we can coordinate our multiple tasks, and create
    a couple of simple consumer `tasks` that will use the `DisplayResults` method
    to print out the results.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Program` 类的 `Main` 方法中，让我们定义我们的 `BlockingCollection` 缓冲区并创建 `List<Task>`，以便我们可以协调我们的多个任务，并创建几个简单的消费者
    `tasks`，这些 `tasks` 将使用 `DisplayResults` 方法打印出结果。
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we need to create a `for` loop that loops from one to twenty-five, creating
    producer tasks that use the `CalcSumRoot` method to calculate the result, and
    then add the result to `BlockingCollection` by calling `TryAdd`. The loop must
    also add all of producer `tasks` to the `Task` list.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个从一到二十五的 `for` 循环，创建使用 `CalcSumRoot` 方法计算结果的生成器任务，并将结果通过调用 `TryAdd`
    添加到 `BlockingCollection` 中。循环还必须将所有生成器 `tasks` 添加到 `Task` 列表中。
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, let's create a continuation to run after all producer `tasks` that
    are complete. The continuation simply calls the `CompleteAdding` method of `BlockingCollection`
    to indicate that we are done adding items to the collection. Finish up by waiting
    for user input before exiting.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个在所有生成器 `tasks` 完成后运行的后续操作。后续操作简单地调用 `BlockingCollection` 的 `CompleteAdding`
    方法，以指示我们已完成向集合添加项目。完成操作后，等待用户输入再退出。
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In Visual Studio 2012, press *F5* to run the project. Notice the ordered results
    in the following screenshot:![How to do it…](img/0225OT_05_07.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。注意以下截图中的有序结果：![如何操作…](img/0225OT_05_07.jpg)
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: By default, `BlockingCollection` uses `ConcurrentQueue<T>` as the backing store.
    `ConcurrentQueue` takes care of thread synchronization and `BlockingCollection`
    does a non-busy wait while trying to take an item from the collection. That is,
    if the consumer calls `TryTake` when there are no items in the queue, it does
    a non-busy wait until any items are available.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`BlockingCollection` 使用 `ConcurrentQueue<T>` 作为后端存储。`ConcurrentQueue`
    负责线程同步，而 `BlockingCollection` 在尝试从集合中取出项目时执行非忙碌等待。也就是说，如果消费者在队列中没有项目时调用 `TryTake`，它将进行非忙碌等待，直到有项目可用。
- en: In this recipe, we are spinning up producer `tasks` in a `for` loop. Each producer
    `task` is calling the `CalcSumRoot` method which is a fairly expensive math operation.
    Our consumers are simply displaying the output to the screen. As a result, our
    two consumer `tasks` are probably spending most of their time in a non busy wait
    state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `for` 循环启动生成器 `tasks`。每个生成器 `task` 都调用 `CalcSumRoot` 方法，这是一个相当昂贵的数学运算。我们的消费者只是简单地显示输出到屏幕上。因此，我们的两个消费者
    `tasks` 可能大部分时间都在非忙碌等待状态。
- en: The producers and consumers are pretty simple, but we needed a way to call `CompleteAdding`
    after all producer `tasks` have finished. We handled this by adding all of our
    producer `Task` objects to `List<Task>`, and calling the `ContinueWhenAll` method
    of `Task.Factory`, so our continuation only runs when all of the producers complete.
    The only job of the continuation is to call the `CompleteAdding` method of `BlockingCollection`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器和消费者相当简单，但我们需要一种方法在所有生成器 `tasks` 完成后调用 `CompleteAdding`。我们通过将所有我们的生成器 `Task`
    对象添加到 `List<Task>` 中，并调用 `Task.Factory` 的 `ContinueWhenAll` 方法来处理这个问题，这样我们的后续操作只会在所有生成器完成时运行。后续操作的唯一任务是调用
    `BlockingCollection` 的 `CompleteAdding` 方法。
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating object pool with ConcurrentStack
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConcurrentStack 创建对象池
- en: An object pool is a set of pre-initialized objects that your application can
    use, rather than creating and destroying all of the objects it needs. If the instantiation
    cost of an object type is high, your application might benefit from a pool of
    objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池是一组预初始化的对象，您的应用程序可以使用这些对象，而不是创建和销毁它需要的所有对象。如果对象类型的实例化成本很高，您的应用程序可能从对象池中受益。
- en: In this recipe, we are going to create an object pool based on `ConcurrentStack`.
    `ConcurrentStack` will handle concurrent access issues using fast interlocked
    operations, and will dispense our objects in a LIFO manner. We will also have
    an object pool client which creates three tasks. One creates objects and puts
    them in the pool, the other two tasks request objects from the pool on different
    threads.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将基于 `ConcurrentStack` 创建一个对象池。`ConcurrentStack` 将使用快速互锁操作处理并发访问问题，并以
    LIFO（后进先出）的方式分配我们的对象。我们还将有一个对象池客户端，它创建三个任务。一个创建对象并将它们放入池中，另外两个任务在不同的线程上从池中请求对象。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's see how we can use `ConcurrentStack` to build a pool of pre-initialized
    objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `ConcurrentStack` 来构建一个预初始化对象的池。
- en: Start a new project using the **C# Console Application** project template and
    assign `ObjectPool` as the **Solution name**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板启动一个新的项目，并将 `ObjectPool` 作为 **解决方案名称**。
- en: Let's start by creating our object pool class. Right-click on the `ObjectPool`
    project in the **Solution Explorer** and click on **Add**, then choose **New Item**.
    Select **Visual C# Items**, and **Class.** Enter `ConcurrentObjectPool` as the
    name of the class.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建我们的对象池类。在 **解决方案资源管理器** 中右键单击 `ObjectPool` 项目，然后单击 **添加**，然后选择 **新建项**。选择
    **Visual C# 项**，然后选择 **类**。将类命名为 `ConcurrentObjectPool`。
- en: 'Add the following `using` directives to the top of your `ConcurrentObjectPool`
    class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到您的 `ConcurrentObjectPool` 类的顶部：
- en: '[PRE36]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We want our object pool to work with any type, so add a generic type parameter
    after the class name.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望我们的对象池能够与任何类型一起工作，所以请在类名后添加一个泛型类型参数。
- en: '[PRE37]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our `ObjectPool` class is going to need a couple of private state fields. We
    need a `ConcurrentStack` field which will provide our backing store and a `Func<T>`
    field which will hold an object creation function the pool can use to generate
    objects when the pool is empty. Inside the class declaration, add the following
    fields:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `ObjectPool` 类需要几个私有状态字段。我们需要一个 `ConcurrentStack` 字段，它将提供我们的后端存储，以及一个 `Func<T>`
    字段，它将保存一个对象创建函数，池可以使用该函数在池为空时生成对象。在类声明中添加以下字段：
- en: '[PRE38]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we need a constructor for the `ConcurrentObjectPool` class. The constructor
    should take a `Func<T>` argument for the object generator and should instantiate
    a new `ConcurrentStack` object as the backing store.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个 `ConcurrentObjectPool` 类的构造函数。构造函数应该接受一个 `Func<T>` 参数作为对象生成器，并实例化一个新的
    `ConcurrentStack` 对象作为后端存储。
- en: '[PRE39]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we need a `GetObject` method which will return a new object to the client.
    The `GetObject` method will try to pop an object off the stack. If it can't pop
    one off the stack, it will use `objectInitializer` to instantiate a new object.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个 `GetObject` 方法，该方法将返回一个新的对象给客户端。`GetObject` 方法将尝试从栈中弹出一个对象。如果它不能从栈中弹出一个对象，它将使用
    `objectInitializer` 来实例化一个新的对象。
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The last step for our object pool is a `PutObject` method that takes a generic
    item parameter and pushes it on the stack.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对象池的最后一步是一个 `PutObject` 方法，它接受一个泛型项目参数并将其推入栈中。
- en: '[PRE41]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we need to create the `Console` application that will use the object pool.
    Go back to `Program.cs` and add the following `using` directives at the top of
    the file:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个将使用对象池的 `Console` 应用程序。回到 `Program.cs` 文件，在文件顶部添加以下 `using` 指令：
- en: '[PRE42]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first step is to instantiate our object pool. In the `main` method of the
    program class, create a `ConcurrentObjectPool` object and pass in a function that
    creates a new `StringBuilder` object as the constructor parameter.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是实例化我们的对象池。在程序类的 `main` 方法中，创建一个 `ConcurrentObjectPool` 对象，并将一个创建新的 `StringBuilder`
    对象的函数作为构造函数参数传入。
- en: '[PRE43]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now let's create a task that creates some objects and places them in `pool`
    using the `PutObject` method.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个任务，使用 `PutObject` 方法创建一些对象并将它们放入 `pool` 中。
- en: '[PRE44]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, let's create two continuation tasks that run after the first task is
    completed. Both tasks just request objects from the object `pool` using the `GetObject`
    method.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建两个在第一个任务完成后运行的后续任务。这两个任务只是使用 `GetObject` 方法从对象 `pool` 中请求对象。
- en: '[PRE45]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_08.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到以下截图所示的输出：![如何实现…](img/0225OT_05_08.jpg)
- en: How it works…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are other features we could have added to our object `pool`, such as controlling
    the concurrency level and/or using thread local segments to store our objects,
    but this simple implementation does the job for our purposes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向我们的对象 `pool` 添加其他功能，例如控制并发级别和/或使用线程局部段来存储我们的对象，但这个简单的实现已经完成了我们的目的。
- en: 'The constructor of the object `pool` takes a function argument that it can
    use to generate an object if the pool is empty, and stores the function in a private
    `objectInitializer` field. We are just pooling `StringBuilder` objects in this
    sample, so we passed in the following function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `pool` 的构造函数接受一个函数参数，如果池为空，它可以用来生成一个对象，并将该函数存储在私有的 `objectInitializer` 字段中。在这个示例中，我们只是池化了
    `StringBuilder` 对象，所以我们传递了以下函数：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our `GetObject` method, which the client uses to get objects from `pool`, just
    uses the `TryPop` method of `ConcurrentStack` to return an object. If `TryPop`
    fails to return anything because the stack is empty, we just return the result
    of the `objectInitializer` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `GetObject` 方法，客户端使用它从 `pool` 获取对象，只是使用 `ConcurrentStack` 的 `TryPop` 方法来返回一个对象。如果
    `TryPop` 由于栈为空而无法返回任何内容，我们只需返回 `objectInitializer` 函数的结果。
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `PutObject` method probably doesn't require much explanation. It just uses
    the `Push` method of `ConcurrentStack` to push an object onto the stack.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`PutObject` 方法可能不需要太多解释。它只是使用 `ConcurrentStack` 的 `Push` 方法将对象推送到栈上。'
- en: Given that we chose to use `ConcurrentStack`, our object references are returned
    in a LIFO fashion. We could have chosen another type of backing store if this
    didn't work for us. For example, we could have chosen to use `ConcurrentQueue`
    as a backing store to have items returned in a **First-In-First-Out** (**FIFO**)
    fashion, or we could have used `ConcurrentBag` to provide unordered storage.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们选择了使用 `ConcurrentStack`，我们的对象引用以 LIFO（后进先出）的方式返回。如果我们不希望这样，我们可以选择另一种类型的后端存储。例如，我们可以选择使用
    `ConcurrentQueue` 作为后端存储，以实现 **先进先出**（**FIFO**）的方式返回项目，或者我们可以使用 `ConcurrentBag`
    来提供无序存储。
- en: Adding blocking and bounding with IProducerConsumerCollection
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IProducerConsumerCollection 添加阻塞和边界
- en: By default, `BlockingCollection` uses `ConcurrentQueue` as its backing store.
    However, you can add blocking and bounding functionality to any custom or derived
    collection class by implementing the `IProducerConsumerCollection` interface in
    the class. You can then use an instance of the custom collection class as the
    backing store for `BlockingCollection`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`BlockingCollection` 使用 `ConcurrentQueue` 作为其后端存储。然而，您可以通过在类中实现 `IProducerConsumerCollection`
    接口，将阻塞和边界功能添加到任何自定义或派生集合类中。然后，您可以使用自定义集合类的实例作为 `BlockingCollection` 的后端存储。
- en: In this recipe, we are going to create a custom priority queue and use the custom
    queue as the backing store for `BlockingCollection`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个自定义优先级队列，并使用自定义队列作为 `BlockingCollection` 的后端存储。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Let's examine how we can use `IProducerConsumerColletion` to add blocking and
    bounding functionality to a custom collection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `IProducerConsumerColletion` 将阻塞和边界功能添加到自定义集合中。
- en: Start a new project using the **C# Console Application** project template and
    assign **CustomBlockingBounding** as the **Solution name**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板创建一个新的项目，并将 **Solution name** 设置为 **CustomBlockingBounding**。
- en: First, let's add a `Class` file for our custom queue. Right-click on the **CustomBlockingBounding**
    project and click on **Add Item**, and then click on **Add New Item** and then
    click on **Class**. Name the new class `PriorityQueue.cs`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的自定义队列添加一个 `Class` 文件。右键单击 **CustomBlockingBounding** 项目，然后单击 **Add
    Item**，接着单击 **Add New Item**，然后单击 **Class**。将新类命名为 `PriorityQueue.cs`。
- en: 'Add the following `using` directives to the top of your `PriorityQueue` class:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到您的 `PriorityQueue` 类顶部：
- en: '[PRE48]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Below the `PriorityQueue` class, let's create an enumeration for our queue priority
    levels. We just want to use low, medium, and high as the possible priority levels.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PriorityQueue` 类下方，让我们创建一个枚举来表示我们的队列优先级级别。我们只想使用低、中、高作为可能的优先级级别。
- en: '[PRE49]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our custom collection class will hold `KeyValuePairs` of the queue priority
    level and the data queued. Add priority level and queued data generic type parameters
    to `Class` and declare the `IProducerConsumerCollection` interface.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的定制集合类将包含队列优先级级别和数据队列的 `KeyValuePairs`。将优先级级别和队列数据泛型类型参数添加到 `Class` 中，并声明
    `IProducerConsumerCollection` 接口。
- en: '[PRE50]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next, we need some private fields for the `PriorityQueue` class. We will need
    three `ConcurrentQueue<QueuePriorityLevel, TValue>` fields; one each for the low,
    medium, and high priority queues. We will need an array of `ConcurrentQueue` to
    hold all of the queues and an integer count variable.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为 `PriorityQueue` 类提供一些私有字段。我们需要三个 `ConcurrentQueue<QueuePriorityLevel,
    TValue>` 字段；每个用于低、中、高优先级队列。我们需要一个 `ConcurrentQueue` 数组来存储所有队列和一个整型计数变量。
- en: '[PRE51]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now let's add a default constructor to the `PriorityQueue` class that initializes
    all of our fields.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们向 `PriorityQueue` 类添加一个默认构造函数，该构造函数初始化所有字段。
- en: '[PRE52]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, we need to provide an implementation for several of the `IProducerConsumerCollection`
    interface members. Let's start with the `CopyTo` method. This method makes a copy
    of our collection array to a destination array.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为 `IProducerConsumerCollection` 接口的几个成员提供一个实现。让我们从 `CopyTo` 方法开始。此方法将我们的集合数组复制到目标数组中。
- en: '[PRE53]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we need to provide an implementation for the `ToArray` method which returns
    an array of `KeyValuePairs`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为 `ToArray` 方法提供一个实现，该方法返回一个 `KeyValuePairs` 数组。
- en: '[PRE54]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we are getting to the key `IProducerConsumerCollection` method implementations.
    We need to provide an implementation for the `TryAdd` method which is going to
    determine our private `ConcurrentQueue` collections to add the new item to, and
    then add the item, and use `Interlocked.Increment` to increment the count.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们正在接近关键的 `IProducerConsumerCollection` 方法实现。我们需要为 `TryAdd` 方法提供一个实现，该方法将确定我们的私有
    `ConcurrentQueue` 集合以添加新项目，然后添加项目，并使用 `Interlocked.Increment` 来增加计数。
- en: '[PRE55]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `TryTake` method implementation needs to loop through the backing `ConcurrentQueues`
    in priority order, and try to take the first available item from one of the queues,
    and decrement the count.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TryTake` 方法的实现需要按优先级顺序遍历后端的 `ConcurrentQueues`，并尝试从其中一个队列中取出第一个可用的项目，并减少计数。'
- en: '[PRE56]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Next we need to implement the `GetEnumerator` methods required to implement
    `IEnumerable`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现实现 `IEnumerable` 所需的 `GetEnumerator` 方法。
- en: '[PRE57]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We're almost done with the collection. The last thing we need to do is implement
    a simple getter for the `count` field. There is no need to provide an implementation
    for the other `IProducerConsumerCollection` members.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了集合。最后我们需要实现 `count` 字段的简单获取器。不需要为其他 `IProducerConsumerCollection` 成员提供实现。
- en: '[PRE58]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Ok, let''s move on to our `Console` application which will use the custom `queue`
    class. Open `Program.cs` and add the following `using` directives to the top of
    the class:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们继续到我们的 `Console` 应用程序，该程序将使用定制的 `queue` 类。打开 `Program.cs` 并将以下 `using`
    指令添加到类的顶部：
- en: '[PRE59]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the `Main` method of your `Program` class, start with some local variable
    declarations for a `PriorityQueue` variable, a `BlockingCollection` variable that
    takes the `PriorityQueue` variable as a constructor argument, and a list of tasks
    which will hold references to our producer and consumer `tasks`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `Main` 方法中，从为 `PriorityQueue` 变量、一个以 `PriorityQueue` 变量作为构造函数参数的
    `BlockingCollection` 变量以及将包含我们的生产者和消费者 `tasks` 的任务列表的局部变量声明开始。
- en: '[PRE60]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Our `Console` application has a producer task which will add items to the priority
    queue with a random priority level. The consumer task will remove items from the
    queue in priority order and write the results to `Console`. Let's start with the
    `producer` task.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Console` 应用程序有一个生产者任务，该任务将以随机优先级级别向优先级队列中添加项目。消费者任务将从队列中按优先级顺序移除项目，并将结果写入
    `Console`。让我们从 `producer` 任务开始。
- en: '[PRE61]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Right after the `producer` task, make a call to `Thread.SpinWait` to make the
    main thread wait for a bit before starting the `consumer` task.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `producer` 任务之后，调用 `Thread.SpinWait` 使主线程等待一段时间，然后再启动 `consumer` 任务。
- en: '[PRE62]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now let's add the `consumer` task which will pull items from the queue and display
    the results to the `Console` application.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加 `consumer` 任务，该任务将从队列中提取项目，并将结果显示到 `Console` 应用程序中。
- en: '[PRE63]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finish up by adding the `producer` and `consumer` tasks to the list of `tasks`.
    Wait on both tasks to complete by calling `Task.WaitAll` inside a `try`/`catch`
    block. In the `catch` block, handle any `AggregateException` that may be thrown.
    Lastly, wait for user input before exiting.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`producer`和`consumer`任务添加到`tasks`列表中。在`try`/`catch`块中调用`Task.WaitAll`以等待这两个任务完成。在`catch`块中，处理可能抛出的任何`AggregateException`。最后，在退出之前等待用户输入。
- en: '[PRE64]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_09.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何做…](img/0225OT_05_09.jpg)
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There were a lot of codes in this recipe, but the key points of the implementation
    can be distilled to just a few `IProducerConsumerCollection` interface method
    implementations.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中有很多代码，但实现的关键点可以简化为仅几个`IProducerConsumerCollection`接口方法实现。
- en: '`IProducerConsumerCollection<T>` defines a handful of methods for manipulating
    thread safe collections for producer/consumer usage.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProducerConsumerCollection<T>`定义了一些方法，用于操作线程安全的集合以供生产者/消费者使用。'
- en: To create our custom collection class, we just implemented the `IProducerConsumerCollection`
    interface on our custom `PriorityQueue` class and used some `ConcurrentQueue`
    fields as our backing stores.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的自定义集合类，我们只需在我们的自定义`PriorityQueue`类上实现`IProducerConsumerCollection`接口，并使用一些`ConcurrentQueue`字段作为我们的后端存储。
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The actual implementation of the `IProducerConsumerCollection.TryAdd` method
    is pretty simple. We just determine the queue to place the item in by casting
    our `QueuePriorityLevel` enumeration to an integer, then enqueue the item. We
    then do `Interlocked.Increment` on our count field. `Interlocked.Increment` does
    a thread safe increment of the count field.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProducerConsumerCollection.TryAdd`方法的实际实现相当简单。我们只是通过将我们的`QueuePriorityLevel`枚举强制转换为整数来确定放置项目的队列，然后入队项目。然后我们对计数字段执行`Interlocked.Increment`。`Interlocked.Increment`对计数字段执行线程安全的增量。'
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`TryTake` isn''t much more complex. We just loop through our three private
    backing queues in order of priority and remove the first item we come to. `TryTake`
    returns a bool to indicate of it was successful in taking an item.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryTake`并不复杂。我们只是按照优先级顺序遍历我们的三个私有后端队列，并移除我们遇到的第一个项目。`TryTake`返回一个布尔值，以指示它是否成功取走了一个项目。'
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Using multiple concurrent collections to create a pipeline
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个并发集合创建管道
- en: A pipeline is like an assembly line in a factory. With the pipeline pattern,
    data is processed in a sequential order where the output from the first stage
    becomes the input for the second stage and so on. Pipelines use parallel tasks
    and concurrent queues to process a series of input values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 管道就像工厂中的装配线。使用管道模式，数据按顺序处理，第一个阶段的输出成为第二个阶段的输入，依此类推。管道使用并行任务和并发队列来处理一系列输入值。
- en: In this recipe, we are going to create a simple pipeline that creates a range
    of numbers, doubles the numbers in the range, and then writes the results to `Console`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个简单的管道，该管道创建一个数字范围，将范围内的数字加倍，然后将结果写入`Console`。
- en: How to do it…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Now, let's see how to create a pipeline by using multiple concurrent collections.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何通过使用多个并发集合来创建管道。
- en: Start a new project using the **C# Console Application** project template and
    assign `Pipeline` as the **Solution name**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新项目，并将`Pipeline`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`Program`类的顶部：
- en: '[PRE68]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: First, let's add a `static` method to the `Program` class to create the range.
    This method needs a `BlockingCollection` parameter. It will simply add items to
    `BlockingCollection` in a loop.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向`Program`类添加一个`static`方法来创建范围。此方法需要一个`BlockingCollection`参数。它将简单地通过循环将项目添加到`BlockingCollection`中。
- en: '[PRE69]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, let's create a `static` method to square the range. This method will take
    two `BlockingCollection` parameters and will square each of the items in the source
    collection and place them in the result collection.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个`static`方法来平方范围。此方法将接受两个`BlockingCollection`参数，并将源集合中的每个项目平方，并将它们放置在结果集合中。
- en: '[PRE70]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now let's create a `static` method to display the results. This method will
    take a `BlockingCollection` parameter and will loop through its items and write
    the values to the `Console` application.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`static`方法来显示结果。此方法将接受一个`BlockingCollection`参数，并将遍历其项目，将值写入`Console`应用程序。
- en: '[PRE71]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the `Main` method of the `Program` class, declare the two `BlockingCollection<int>`
    variables. These blocking collections will be the data buffers for the pipeline.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `Main` 方法中，声明两个 `BlockingCollection<int>` 变量。这些阻塞集合将是管道的数据缓冲区。
- en: '[PRE72]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Create and start three tasks to call each of our three methods passing in the
    `BlockingCollection` buffers required for each method.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动三个任务，调用我们的三个方法，并为每个方法传递所需的 `BlockingCollection` 缓冲区。
- en: '[PRE73]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Finally, wait for all three tasks to complete by calling `Task.WaitAll`. Wait
    for user input before exiting.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用 `Task.WaitAll` 等待所有三个任务完成。在退出之前等待用户输入。
- en: '[PRE74]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_10.jpg)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到以下截图所示的输出：![如何操作…](img/0225OT_05_10.jpg)
- en: How it works…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a simple pipeline composed of three stages. Each
    stage reads from and/or writes to a particular buffer. If your machine has more
    available processor cores than there are stages in the pipeline, the stages can
    run in parallel. The concurrent queues used by `BlockingCollection` will buffer
    all shared inputs and outputs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个由三个阶段组成的简单管道。每个阶段都会从特定的缓冲区读取并/或写入数据。如果你的机器有比管道中阶段更多的可用处理器核心，那么这些阶段可以并行运行。`BlockingCollection`使用的并发队列将缓冲所有共享的输入和输出。
- en: Each stage in the pipeline can add items to its output buffer as long as there
    is room. If the buffer is full, the pipeline stage waits for space to become available
    before adding an item. The stages can also wait on inputs from the previous stage.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每个阶段只要输出缓冲区有空间，就可以向其中添加项目。如果缓冲区已满，管道阶段将等待空间可用后再添加项目。阶段也可以等待来自前一阶段的输入。
- en: The stages that produce data use `BlockingCollection.CompleteAdding` to signal
    that they are finished adding data. This tells the consumer that it can end its
    processing loop after all previously added data has been removed or processed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 产生数据的阶段使用 `BlockingCollection.CompleteAdding` 来表示它们已经完成数据的添加。这告诉消费者，在所有之前添加的数据被移除或处理完毕后，它可以结束其处理循环。
