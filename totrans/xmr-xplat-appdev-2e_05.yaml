- en: Chapter 5. XamChat for iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will develop the iOS portion of our cross-platform XamChat
    application. Since we are using the MVVM design pattern, most of the work we will
    be doing will be in the View layer of the application. We will mainly be working
    with native iOS APIs and understanding how we can apply them leverage the shared
    code in our portable class library. Since Xamarin.iOS enables us to call Apple
    APIs directly, our iOS app will be indistinguishable from an application developed
    in Objective-C or Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To begin writing the iOS version of XamChat, create a new **Single View Application**
    under the **iOS** section. Name the project `XamChat.iOS` or some other appropriate
    name of your choice. The project template will automatically create a controller
    with an unfamiliar name; go ahead and delete it. We will create our own controllers
    as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of an iOS application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `UINavigationController`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a login screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segues and `UITableView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a friends list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a list of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of an iOS app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start developing our app, let's review the main settings of the application.
    Apple uses a file named `Info.plist` to store important information about any
    iOS app. These settings are used when an iOS application is installed on a device
    by the Apple App Store. We will begin development on any new iOS application by
    filling out the information in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin Studio provides a neat menu to modify values in the `Info.plist` file,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the basics of an iOS app](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The most important settings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Name**: This is the title below an app''s icon in iOS. Note that
    this is not the same as the official name of your app in the iOS App Store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundle Identifier**: This is your app''s bundle identifier or bundle ID.
    It is a unique name to identify your application. The convention is to use a reverse
    domain naming style beginning with your company name, such as `com.packt.xamchat`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**: This is a version number for your application such as `1.0.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: In this field you can select **iPhone/iPod**, **iPad**, or **Universal**
    (all devices) for your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment Target**: This is the minimum iOS version your application runs
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main Interface**: This is the main storyboard file for your app that declares
    most of the UI of your application. iOS will automatically load this file and
    open the root controller as the initial screen to be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported Device Orientations**: These are the different positions your application
    will be able to rotate to and support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other settings for app icons, splash screens, and so on. You can also
    toggle between the **Advanced** or **Source** tabs to configure additional settings
    that Xamarin does not provide a user-friendly menu for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the following settings for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Name**: `XamChat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundle Identifier**: `com.yourcompanyname.xamchat`; make sure that you name
    future apps beginning with `com.yourcompanyname`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**: This can be any version number you prefer, but it should just
    not be left blank'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: **iPhone/iPod**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment Target**: 7.0 (you can also target 8.0, but we aren''t using any
    iOS 8-specific APIs in this app)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported Device Orientations**: Only select **Portrait**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find some additional settings for Xamarin iOS applications if you right-click
    on your project and select **Options**. It is a good idea to know what is available
    for iOS-specific projects in Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss some of the most important options.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **iOS Build** | **General** tab as shown in the following screenshot:![Understanding
    the basics of an iOS app](img/00034.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have the following options under this tab:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**SDK version**: This is the version of the iOS SDK to compile your application
    with. It is generally best to use **Default**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linker behavior**: Xamarin has implemented a feature called **linking**.
    The linker will strip any code that will never be called within your assemblies.
    This keeps your application small and allows them to ship a stripped-down version
    of the core Mono framework with your app. Except for debug builds, it is best
    to use the **Link SDK assemblies only** option. We will cover linking in the next
    chapter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize PNG files for iOS**: Apple uses a custom PNG format to speed up
    the loading of PNGs within your app. You can turn this off to speed up builds,
    or if you plan on optimizing the images yourself.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable debugging**: Turning this on allows Xamarin to include extra information
    with your app to enable debugging from Xamarin Studio.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional mtouch arguments**: This field is for passing extra command-line
    arguments to the Xamarin compiler for iOS. You can check out the complete list
    of these arguments at [http://iosapi.xamarin.com](http://iosapi.xamarin.com).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigate to **iOS Build** | **Advanced** tab as shown in the following screenshot:![Understanding
    the basics of an iOS app](img/00035.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have the following options under this tab:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Supported architectures**: Here, the options are **ARMv7**, **ARMv7s**, and
    a **FAT** version that includes both. These are instruction sets that different
    iOS device processors support. If you really care about performance, you might
    consider selecting the option to support both; however, this will make your application
    larger.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use LLVM optimizing compiler**: Checking this compiles the code that is smaller
    and runs faster, but it takes longer to compile. **LLVM** stands for **Low Level
    Virtual Machine**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable generic value type sharing**: This is an option specific to Mono that
    draws better performance from C# generics with value types. It has the downside
    of making the application slightly larger, but I would recommend that you leave
    it on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use SGen generational garbage collector**: This uses the new Mono garbage
    collector in your app. I would recommend that you turn this on if you really need
    good performance with the **garbage collector** (**GC**) or are working on an
    app that needs to be responsive in real time, such as a game. It is probably safe
    to turn this on by default now, as the SGen garbage collector is very stable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the reference counting extension (preview)**: This is currently an experimental
    feature, but improves the general memory usage of native objects that are accessible
    from C#. These native object''s reference is managed by the GC instead of a backing
    field on the object when using this setting. Since it is still in preview, you
    should be careful when using this option.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have the following options under **iOS Bundle Signing**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identity**: This is the certificate to identify the app''s creator for deploying
    the application to devices. We''ll cover more on this in later chapters.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provisioning profile**: This is a specific profile that deploys the app to
    a device. This works in tandem with Identity, but also declares the distribution
    method, and the devices that can install the app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom Entitlements**: This file contains additional settings to be applied
    to the provisioning profile, and it contains other specific declarations for the
    app such as iCloud or push notifications. The project template for iOS apps includes
    a default `Entitlements.plist` file for new projects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS Application**: These settings are identical to what you see in the `Info.plist`
    file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this application, you can leave all these options at their defaults. When
    making a real iOS application on your own, you should consider changing many of
    these as per your application's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Using UINavigationController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In iOS applications, the key class that manages navigation between different
    controllers is the `UINavigationController` class. The navigation controller is
    the most basic building block of navigation on iOS, so it is the best choice to
    start with most of the iOS applications. It is a parent controller that contains
    several child controllers in a stack. Users can move forward by putting new controllers
    on top of the stack or using a built-in back button to pop a controller off the
    stack and navigate to the previous screen.
  prefs: []
  type: TYPE_NORMAL
- en: Methods in Navigation Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the methods in Navigation Controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetViewControllers`: This sets an array of child controllers. It has a value
    to optionally animate the transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewControllers`: This is a property to get or set the array of child controllers
    without an option for animations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PushViewController`: This places a new child controller at the top of the
    stack with an option to display an animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopViewControllerAnimated`: This pops off the child controller at the top
    of the stack with an option to animate the transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopToViewController`: This pops to the specified child controller, removing
    all controllers above it. It provides an option to animate the transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopToRootViewController`: This removes all the child controllers except the
    bottom-most controller. It includes an option to display an animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopViewController`: This is a property that returns the child controller that
    is currently on top of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that using the option for animations will cause a crash
    if you try to modify the stack during the animation. To fix this situation, either
    use the `SetViewControllers` method and set the entire list of child controllers,
    or refrain from using the animations during a combination of transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Navigation Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to set up a Navigation Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file to open it in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the controller that was created by the project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Navigation Controller** element from the **Toolbox** pane on the right-hand
    side onto the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that a default **View Controller** element was created as well as a **Navigation
    Controller** element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a **segue** that connects the two controllers. We'll cover this
    concept in more detail later in the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you run the application at this point, you will have a basic iOS app with
    a status bar at the top, a navigation controller that contains a navigation bar
    with a default title, and a child controller that is completely white, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Navigation Controller](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the login screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the first screen of our application will be a login screen, let's begin
    by setting up the appropriate views in the storyboard file. We will implement
    the login screen using Xamarin Studio to write the C# code, and its iOS designer
    to create iOS layouts in our storyboard file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LoginController class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Return to the project in Xamarin Studio and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller and click on the **Properties** pane and select
    the **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `LoginController` into the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the `LoginController` class is generated for you. You can create
    a `Controllers` folder and move the file in it if you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows you what the controller''s settings will look
    like in Xamarin Studio after the changes have been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a LoginController class](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Modifying the controller's layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s modify the layout of the controller by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file a second time to return
    to the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the navigation bar and edit the **Title** field to read `Login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag two text fields onto the controller. Position and size them appropriately
    for the username and password entries. You might also want to remove the default
    text to make the fields blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second field, check the **Secure Text Entry** checkbox. This will set
    the control to hide the characters for the password field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might also want to fill out the **Placeholder** field for `Username` and
    `Password` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a button onto the controller. Set the button's **Title** to `Login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an activity indicator onto the controller. Check the **Animating** and
    **Hidden** checkboxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create an outlet for each of the controls by filling out the **Name**
    field. Name the outlets `username`, `password`, `login`, and `indicator` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file and take a look at `LoginController.designer.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see that Xamarin Studio has generated properties for each of the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the controller''s layout](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and compile the application to make sure that everything is okay. At
    this point, we also need to add a reference to the `XamChat.Core` project created
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Registering and subscribing view models and services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s set up our iOS application to register all of its view models
    and other services that will be used throughout the application. We will use the
    `ServiceContainer` class that we created in [Chapter 4](part0036_split_000.html#page
    "Chapter 4. XamChat – a Cross-platform App"), *XamChat – a Cross-platform App*,
    to set up the dependencies throughout our application. Open `AppDelegate.cs` and
    add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Down the road, we will replace the fake services with the real ones. Now, let''s
    add the login functionality to `LoginController.cs`. First, add `LoginViewModel`
    to a member variable at the top of the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will pull a shared instance of `LoginViewModel` into a local variable in
    the controller. This is the pattern that we will use throughout the book in order
    to pass a shared view model from one class to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, override `ViewDidLoad` to hook up the view model''s functionality with
    the views set up in outlets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll add the code to navigate to a new screen later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s hook up the `IsBusyChanged` event to actually perform an action
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now you might be wondering, why we subscribe to the event in this manner. The
    problem is that the `LoginViewModel` class will last through your application's
    lifetime, while the `LoginController` class will not. If we subscribed to the
    event in `ViewDidLoad`, but didn't unsubscribe later, then our application will
    have a memory leak. We also avoided using a lambda expression for the event since
    it would otherwise be impossible to unsubscribe the event. Note that we don't
    have the same problem with the `TouchUpInside` event on the button, since it will
    live in memory as long as the controller does. This is a common problem with events
    in C#, which is why it is a good idea to use the preceding pattern on iOS.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application now, you should be able to enter a username and password,
    as shown in the following screenshot. When you press **Login**, you should see
    the indicator appear and all the controls disabled. Your application will correctly
    be calling the shared code, and should function correctly when we add a real web
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering and subscribing view models and services](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using segues and UITableView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A segue is a transition from one controller to another. In the same way, a storyboard
    file is a collection of controllers and their views attached together by segues.
    This, in turn, allows you to see the layouts of each controller and the general
    flow of your application at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just a few categories of segue, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: This is used within a navigation controller. It pushes a new controller
    to the top of the navigation controller''s stack. Push uses the standard animation
    technique for navigation controllers and is generally the most commonly used segue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationship**: This is used to set a child controller of another controller.
    For example, the root controller of a navigation controller, container views,
    or split view controllers in an iPad application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modal**: On using this, a controller presented modally will appear on top
    of the parent controller. It will cover the entire screen until dismissed. There
    are several types of different transition animations available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom**: This is a custom segue that includes an option for a custom class,
    which subclasses `UIStoryboardSegue`. This gives you fine-grained control over
    the animation and how the next controller is presented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Segues also use the following pattern while executing:'
  prefs: []
  type: TYPE_NORMAL
- en: The destination controller and its views are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The segue object, a subclass of `UIStoryboardSegue`, is created. This is normally
    only important for custom segues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PrepareForSegue` method is called on the source controller. This is a good
    place to run any custom code before a segue begins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The segue's `Perform` method is called and the transition animation is started.
    This is where the bulk of the code resides for a custom segue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Xamarin.iOS designer, you have the choice of either firing a segue automatically
    from a button or table view row, or just giving the segue an identifier. In the
    second case, you can start the segue yourself by calling the `PerformSegue` method
    on the source controller using its identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s set up a new segue by setting up some aspects of our `MainStoryboard.storyboard`
    file by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Table View Controller** to the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller and navigate to the **Properties** pane and the
    **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `ConversationsController` into the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down under the **View Controller** section and enter **Title** of `Conversations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a segue from `LoginController` to `ConversationsController` by clicking
    while holding *Ctrl* and dragging the blue line from one controller to the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **push** segue from the popup that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the segue by clicking on it and give it an **Identifier** of `OnLogin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your storyboard will look something similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using segues and UITableView](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `LoginController.cs`, and modify the line of code that we marked as `TODO`
    earlier in this chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now if you build and run the application, you will navigate to the new controller
    after a successful log in. The segue will be performed, and you will see the built-in
    animation provided by the navigation controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's set up the table view on the second controller. We are using a powerful
    class on iOS called `UITableView`. It is used in many situations and is very similar
    to the concept of a list view on other platforms. The `UITableView` class is controlled
    by another class called `UITableViewSource`. It has methods that you need to override
    to set up how many rows should exist and how these rows should be displayed on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `UITableViewSource` is a combination of `UITableViewDelegate` and
    `UITableViewDataSource`. I prefer to use `UITableViewSource` for simplicity, since
    many times using both of the other two classes would be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump in and start coding, let''s review the most commonly used methods
    on `UITableViewSource`, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RowsInSection`: This method allows you to define the number of rows in a section.
    All the table views have a number of sections and rows. By default, there is only
    one section; however, it is a requirement to return the number of rows in a section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumberOfSections`: This is the number of sections in the table view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetCell`: This method must return a cell for each row and should be implemented.
    It is up to the developer to set up how a cell should look like; you can also
    implement code to recycle the cells as you scroll. Recycling cells will yield
    better performance while scrolling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TitleForHeader`: This method, if overridden, is the simplest way to return
    a string for the title. Each section in a table view has a standard header view,
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RowSelected`: This method will be called when the user selects a row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are additional methods that you can override, but these will get you by
    in most situations. You can also set up custom headers and footers if you need
    to develop a custom styled table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s open the `ConversationsController.cs` file, and create a nested
    class inside `ConversationsController` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We implemented the two required methods to set up a table view: `RowsInSection`
    and `GetCell`. We returned the number of conversations found on the view model
    and set up our cell for each row. We also used `UITableViewCellAccessory.DisclosureIndicator`
    to add an indicator for the users to know that they can click on the row.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice our implementation of recycling cells. Calling `DequeueReusableCell`
    with a cell identifier will return a `null` cell the first time around. If `null`,
    you should create a new cell using the same cell identifier. Subsequent calls
    to `DequeueReusableCell` will return an existing cell, enabling you to reuse it.
    You can also define the `TableView` cells in the storyboard file, which is useful
    for custom cells. Our cell here is very simple, so it is easier to define it from
    the code. Recycling cells is important on mobile platforms to preserve memory
    and provide the user with a very fluid scrolling table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the `TableView` source on `TableView`. Add some changes
    to our `ConversationsController` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So when the view appears, we will load our list of conversations. Upon completion
    of this task, we'll reload the table view so that it displays our list of conversations.
    If you run the application, you'll see a few conversations appear in the table
    view after logging in, as shown in the following screenshot. Down the road, everything
    will operate in the same manner when we load the conversations from a real web
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using segues and UITableView](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a friends list screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next fairly important screen is that of our friends list. When creating
    a new conversation, the app will load a list of friends to start a conversation
    with. We'll follow a very similar pattern to load our list of conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we''ll create `UIBarButtonItem` that navigates to a new controller
    named `FriendsController` by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Table View Controller** to the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller and click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `FriendsController` in the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **View Controller** section, enter `Friends` in the **Title**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Navigation Item** from the **Toolbox** pane onto the `ConversationsController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Bar Button Item** element and place it in the top-right corner
    of the new navigation bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** pane of the bar button, set its **Identifier** to **Add**.
    This will use the built-in plus button, which is commonly used throughout iOS
    applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a segue from **Bar Button Item** to the `FriendsController` by holding
    *Ctrl* and dragging the blue line from the bar button to the next controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **push** segue from the popup that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your changes to the storyboard should look something similar to what is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a friends list screen](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will see a new `FriendsController` class that Xamarin Studio has generated
    for you. If you compile and run the application, you'll see the new bar button
    item we created. Clicking on it will take you to the new controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement `UITableViewSource` to display our friends list. Start
    with a new nested class inside `FriendsController` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, we implemented table cell recycling and merely set the text
    on the label for each friend. We used `cell.AccessoryView` to indicate to the
    user that each cell is clickable and starts a new conversation. We disabled the
    user interaction on the button just to allow the row to be selected when the user
    clicks on the button. Otherwise, we'd have to implement a click event for the
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to modify `FriendsController` in the same way as we did for
    conversations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will function exactly as the conversations list. The controller will load
    the friends list asynchronously and refresh the table view. If you compile and
    run the application, you''ll be able to navigate to the screen and view the sample
    friend list we created in [Chapter 4](part0036_split_000.html#page "Chapter 4. XamChat
    – a Cross-platform App"), *XamChat – a Cross-platform App*, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a friends list screen](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a list of messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's implement the screen to view a conversation or list of messages. We
    will try to model the screen after the built-in text message application on iOS.
    To do so, we will also cover the basics of how to create custom table view cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll need a new `MessagesController` class to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Table View Controller** to the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller and click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `MessagesController` in the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **View Controller** section, enter `Messages` in the **Title**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a segue from `ConversationsController` to `MessagesController` by holding
    *Ctrl* and dragging the blue line from one controller to the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **push** segue from the popup that appears. Enter the **Identifier**
    `OnConversation` in the **Properties** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create two **Table View Cells** in the table view in `MessagesController`.
    You can reuse the existing one created, by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `MyMessageCell` and `TheirMessageCell` respectively into the **Class**
    field for each cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Identifier** to `MyCell` and `TheirCell` respectively on each cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Xamarin Studio will generate three files: `MessagesController.cs`, `MyMessageCell.cs`,
    and `TheirMessageCell.cs`. You might decide to keep things organized by creating
    a `Views` folder and moving the cells into it. Likewise, you can move the controller
    to a `Controllers` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement a base class for both these cells to inherit from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will override the `Update` method later and take the appropriate action for
    each cell type. We need this class to make things easier while interacting with
    both the types of cells from `UITableViewSource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `MessagesController.cs` and implement `UITableViewSource` inside a
    nested class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We added some logic to check whether a message is from a current user to decide
    on the appropriate table cell identifier. Since we have a base class for both
    cells, we can cast to `BaseMessageCell` and use its `Update` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make the changes to our `MessagesController` file to load our list
    of messages and display them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The only thing new here is where we set the `Title` property to the username
    of the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our custom cells, we will need to make more changes in Xcode by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a new **Label** onto both the custom cells.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use some creativity to style both labels. I chose to make the text in `MyMessageCell`
    blue and `TheirMessageCell` green. I set **Alignment** on the label to the right
    aligned in `TheirMessageCell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Name** of each cell, enter `message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file and return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add the following `Update` method to both `MyMessageCell.cs` and `TheirMessageCell.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is a bit strange to have duplicated the code for each cell, but it is the
    simplest approach to take advantage of the outlets Xamarin Studio generated based
    on the storyboard file. You could also have chosen to use the same class for both
    cells (even with a different layout in Xcode); however, you then lose the ability
    to have different code in each cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application now, you will be able to view the messages list,
    as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a list of messages](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Composing messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final piece of our application, we need to implement some custom functionality
    that Apple doesn't provide with their APIs. We need to add a text field with a
    button that appears to be attached to the bottom of the table view. Most of this
    will require writing code and wiring up a lot of events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by adding some new member variables to our `MessagesController`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will place the text field and bar buttons inside the toolbar, as shown in
    the following code. The `NSObject` fields will be an example of iOS''s event system
    called **notifications**. We''ll see how these are used shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Much of this work involves setting up a basic UI. It is not something we can
    do inside Xcode, because it's a custom UI in this case. We create a text field,
    bar button item, and toolbar from C# and add them to our navigation controller's
    view. This will display the toolbar at the top of the table view, no matter where
    it is scrolled to. Another trick we used was to add a footer view to the table
    view, which is of the same height as the toolbar. This will simplify some animations
    that we'll set up later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will need to modify `ViewWillAppear` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Most of these changes are straightforward, but notice our use of iOS notifications.
    Xamarin has provided a C# friendly way to subscribe to notifications. There is
    a static nested class named `Notifications` inside various `UIKit` classes that
    provide notifications. Otherwise, you would have to use the `NSNotificationCenter`
    class, which is not as easy to use. To unsubscribe from these events, we merely
    need to dispose `NSObject` that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s add an override for `ViewWillDisapper` to clean up these events,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s set up our methods for these events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That is quite a bit of code, but not too difficult. `OnIsBusyChanged` is used
    to disable some of our views while it is loading. `ScrollToEnd` is a quick method
    to scroll the table view to the end. We need this for the sake of usability. Some
    math is required because Apple does not provide a built-in method for this.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `OnKeyboardNotification` has quite a lot going on. We used
    the built-in animation system for iOS to set up an animation when the keyboard
    appears or hides. We use this to move views around for the onscreen keyboard.
    Using the animation system is quite easy; call `UIView.BeginAnimations`, modify
    some views, and then finish up with `UIView.CommitAnimations`. We also used a
    few more values from the keyboard to time our animation identically with the keyboard's
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we need to implement a function to send a new message as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code is also fairly straightforward. After sending the message, we merely
    need to reload the table, hide the keyboard, and then make sure we scroll to the
    bottom to see the new message, as shown in the following screenshot. Using the
    `async` keyword makes this easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing messages](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basic settings that Apple and Xamarin provide
    for developing iOS applications. This includes the `Info.plist` file and project
    options in Xamarin Studio. We covered `UINavigationController`, the basic building
    block for navigation in iOS applications, and implemented a login screen complete
    with username and password fields. Next, we covered iOS segues and the `UITableView`
    class. We implemented the friends list screen using `UITableView`, and the messages
    list screen, also using `UITableView`. Lastly, we added a custom UI functionality;
    a custom toolbar floating at the bottom of the messages list.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will have a partially functional iOS version
    of XamChat. You will have a deeper understanding of the iOS platform and tools,
    and fairly good knowledge to apply to building your own iOS applications. Take
    it upon yourself to implement the remaining screens that we did not cover in the
    chapter. If you get lost, feel free to review the full sample application included
    with this book. In the next chapter, we will develop the Android UI for XamChat
    using the native Android APIs. A lot of our steps will be very similar to what
    we did on iOS, and we will be working mainly with the View layer of the MVVM design
    pattern.
  prefs: []
  type: TYPE_NORMAL
