- en: '*Chapter 16*: Implementing Multi-Tenancy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-tenancy is a common pattern to create **Software as a Service** (**SaaS**)
    solutions, where a single deployment can concurrently serve multiple customers.
    Multi-tenancy is one of the fundamental design principles of ABP Framework, so
    all other framework features are multi-tenancy compatible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with understanding what a multi-tenant system
    is and how ABP provides a multi-tenant solution to us. Then, we will continue
    with the ABP infrastructure to understand, build, and control the multi-tenancy
    in our applications. We will also learn to design specific application features
    and make different tenants use different application features. At the end of this
    chapter, you will understand the basics of multi-tenancy and will be able to build
    multi-tenant applications using ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the main topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multi-tenancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the ABP multi-tenancy infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the feature system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use multi-tenancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the example application from the following GitHub repository:
    [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
    It contains some of the examples given in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multi-tenancy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will understand the SaaS and multi-tenancy concepts, the
    main benefits of creating a SaaS solution, and what ABP provides us as a multi-tenant-aware
    framework. Let's start by understanding what a SaaS system provides.
  prefs: []
  type: TYPE_NORMAL
- en: What is SaaS?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building, deploying, and licensing software solutions with the SaaS model has
    become quite popular. Customers typically purchase a SaaS solution with a subscription
    model and use it online without requiring them to download and install it on their
    own servers, which is called on-premises deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building a SaaS solution has these benefits when hosting:'
  prefs: []
  type: TYPE_NORMAL
- en: You can utilize your resources at the maximum level since customers can share
    servers, databases, and other resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is extremely easy and typically automated to add a new customer (tenant)
    to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to maintain and upgrade the system compared to separate deployment
    for each customer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, using a SaaS solution benefits customers as well. They pay
    less for software and hosting than with an on-premises deployment. They can pay
    based on how much they use it. They also don't need to care about maintenance
    and upgrades as long as they pay the service costs.
  prefs: []
  type: TYPE_NORMAL
- en: While the SaaS solution benefits hosting, creating a SaaS solution comes with
    some development costs and runtime considerations.
  prefs: []
  type: TYPE_NORMAL
- en: SaaS solutions typically share the resources between customers. Some of the
    major shared resources are database, cache, and application servers. Data isolation,
    security, and performance are the main concerns that we should care about when
    sharing resources between customers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to shared resources, application settings, features, and permissions
    should be customized per customer without affecting each other.
  prefs: []
  type: TYPE_NORMAL
- en: As we now understand the benefits and challenges of building SaaS solutions,
    let's talk a bit about multi-tenancy.
  prefs: []
  type: TYPE_NORMAL
- en: What is multi-tenancy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multi-tenancy is an architectural pattern to create SaaS solutions. It defines
    and controls how customers access resources securely and efficiently and how the
    application is customized per customer easily.
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework provides a complete multi-tenancy infrastructure. It defines how
    your application and domain code should be designed, how you access shared resources
    (such as databases and caches), how you customize the application configuration
    per customer, and so on. It not only defines but automates wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two sides of a multi-tenant system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tenant**: A customer that uses the system and pays for it. A customer has
    its own users and data, which are isolated from other tenants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host**: The company that manages the system and the tenants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have separate applications for tenant and host users, or you can build
    a single application that makes some application features available only for tenant
    users or only for host users. The ABP startup solution template uses the second
    approach since it is easier to develop and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses how databases are shared or separated for different
    tenants.
  prefs: []
  type: TYPE_NORMAL
- en: The database architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most fundamental design decisions of a multi-tenant system is how
    to share or separate the databases of different tenants. There are three common
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single database**: All data of all tenants is stored in a single, shared
    database. In this case, you should take care when isolating data of different
    tenants since the database tables are shared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database (or schema) per tenant**: Every tenant has its own dedicated database.
    You should dynamically connect to the database for the tenant of the current user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid**: A mixed approach where some tenants have their own database while
    others are grouped in one or more databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABP supports the hybrid approach at the framework level by allowing every tenant
    to have a separate database connection string. However, the startup template and
    the open source tenant management module come with the single-database model.
    If you want to use the database per tenant or the hybrid approach, you should
    customize the tenant management module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure visualizes the main components of the ABP multi-tenancy
    infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – ABP Framework multi-tenancy in brief'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.1_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – ABP Framework multi-tenancy in brief
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework's goal is to automate the multi-tenancy-related logic as much
    as possible and make your application code multi-tenancy-unaware. ABP resolves
    the current tenant from the HTTP request. It can determine the tenant from the
    domain (or subdomain) name, cookie, HTTP header, and other parameters. Then, it
    uses the current tenant information to automatically select the right connection
    if the tenant has a separate connection string. If the tenant uses a shared database,
    it automatically filters the data so that a tenant doesn't accidentally access
    another tenant's data.
  prefs: []
  type: TYPE_NORMAL
- en: We can now start working with the ABP multi-tenancy infrastructure, as we've
    learned about multi-tenancy and ABP's fundamental multi-tenancy logic overall.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the ABP multi-tenancy infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the basic infrastructure and features of the
    ABP multi-tenancy system. You will learn how ABP understands the current tenant
    and isolates the tenant data, how you can get information about the current tenant,
    and how to switch between tenants. But first, we will start with how you can disable
    multi-tenancy if you don't need it.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and disabling multi-tenancy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ABP startup solution template comes with multi-tenancy enabled by default.
    The startup solution has a single point that you can use to easily enable or disable
    multi-tenancy. Find the `MultiTenancyConsts` class inside the `.Domain.Shared`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set the `IsEnabled` value to `false` to disable multi-tenancy. This
    constant is used in a few places in the solution. It is used to set the `AbpMultiTenancyOptions.IsEnabled`
    option in the `.Domain` project''s module class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: ABP uses `AbpMultiTenancyOptions.IsEnabled` to enable or disable multi-tenancy-related
    features, pages, and components. If you set `MultiTenancyConsts.IsEnabled` to
    `false` and run the application, you won't see the tenant switch box on the login
    form and the tenant management page on the main menu anymore. However, the multi-tenancy-related
    database tables are not removed. The next section explains how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing multi-tenancy tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Disabling multi-tenancy doesn't remove the multi-tenancy-related database tables
    from the database. You can leave this as it is (they will already be empty/not
    used). This way, you can easily enable it for your application later.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t want the multi-tenancy-related tables in your database, find
    the following line in the `DbContext` class in the `.EntityFramework` project
    and remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, remove the implementation of the `ITenantManagementDbContext` interface
    from your `DbContext` class. You need to remove the `Tenants` and `TenantConnectionStrings`
    `DbSet` properties from the class. Finally, remove the `[ReplaceDbContext(typeof(ITenantManagementDbContext))]`
    attribute from the `DbContext` class declaration. These changes remove the tenant
    management module's tables from your database schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a new database migration to remove the tables from the database.
    Run the following command in the root directory of the `.EntityFramework` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command to apply changes to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this way, your database won't include multi-tenancy-related tables. You can
    also remove the `Volo.Abp.TenantManagement.*` NuGet packages from the projects
    in the solution and the code parts using these packages. However, all these are
    optional. I suggest you keep them if you think you may enable multi-tenancy for
    your application later because they have no functionality as long as the `AbpMultiTenancyOptions.IsEnabled`
    option is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen, enabling/disabling multi-tenancy with ABP Framework is just
    a single line of change. If you decide to develop your application as multi-tenancy-enabled,
    you can continue with the next section to understand how ABP determines the current
    tenant from HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the current tenant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at *Figure 16.1* again, you will see that all the requests coming
    from the users are passing through the tenant resolution component before executing
    the application code. This way, the current tenant becomes known inside your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intercepting the incoming requests is done with ABP''s multi-tenancy middleware
    component. All the hosting projects in the startup solution template contain the
    following lines in the `OnApplicationInitialization` method of the ABP module
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This middleware is added after the authentication middleware (because the user's
    authentication ticket is used on tenant resolution) and before the authorization
    middleware (because ABP authorizes users based on their tenants).
  prefs: []
  type: TYPE_NORMAL
- en: The multi-tenancy middleware resolves the current tenant from the HTTP request
    and sets the `ICurrentTenant` properties that are used to obtain the current tenant
    information. The `ICurrentTenant` interface will be explained in the next section,
    but we should first understand how ABP determines the current tenant from the
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current tenant information is obtained from the current HTTP request using
    request parameters in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: If the user (or client) has authenticated, then the current tenant's ID and
    name are extracted from the claims in the authentication ticket (either in the
    cookie or in the header, based on the authentication method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `AbpTenantResolveOptions` is configured, the tenant's name is determined
    from the domain (or subdomain) name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `__tenant` query string parameter is used to get the tenant's name or ID
    if the current HTTP request contains that parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `__tenant` route parameter is used to get the tenant's name or ID if the
    current HTTP request contains that parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `__tenant` HTTP header is used to get the tenant's name or ID if the current
    HTTP request contains that parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `__tenant` cookie's value is used to get the tenant's name or ID if the
    current HTTP request contains that parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If ABP determines the tenant in any of the preceding steps, it doesn't continue
    to other steps as you might expect. If none of the information is found in the
    HTTP request, then it is assumed that the current user is a host user. All the
    options are already preconfigured and working when you create a new solution,
    so you typically do not make many configurations for your solution. You should
    only care about the domain name resolution, which is suggested in the production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to configure the domain name resolver in the
    `ConfigureServices` method of your module class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `AddDomainTenantResolver` method accepts a domain format where the `{0}`
    part matches the tenant name. This means if your tenant's name (the `Name` property
    of the `Tenant` class) is `acme`, then the `acme` users should use the `acme.yourdomain.com`
    URL to enter the application.
  prefs: []
  type: TYPE_NORMAL
- en: Once ABP resolves the tenant, we can work with the current tenant, as explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the current tenant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP determines the tenant before executing our application code, as we''ve
    learned in the previous section. We can get the current tenant''s information
    using the `ICurrentTenant` service. The following example demonstrates how to
    use the `ICurrentTenant` service in an arbitrary class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve injected the `ICurrentTenant` service and accessed the `Id` and `Name`
    properties in the example method. The `Id` and `Name` properties return `null`
    if the current user is a host user (which means that the tenant is not available).
    Some ABP base classes already pre-inject the `ICurrentTenant` service, so you
    can directly use the `CurrentTenant` property, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since the `ApplicationService` base class already has the `CurrentTenant` property
    (of the `ICurrentTenant` type), we can use it directly without manual injection.
  prefs: []
  type: TYPE_NORMAL
- en: '`ICurrentTenant` has no more important properties. If you need to get more
    information/data for the current tenant, you have the tenant''s `Id` property
    to query from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, your application code will work with the current tenant. But
    sometimes, you may need to change the current tenant, as explained in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between tenants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ICurrentTenant` service is also used by ABP Framework to isolate the current
    tenant''s data automatically so that you don''t accidentally access other tenant
    data. However, in some cases, you may need to work with another tenant''s data
    in the same HTTP request and temporarily switch the tenant. The `ICurrentTenant`
    service is not only used to get information about the current tenant but also
    to switch to the desired tenant. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you use the `CurrentTenant.Id` property before the `using` block, you get
    the tenant's ID that was resolved, as explained in the *Determining the current
    tenant* section. The `CurrentTenant.Change` method changes the current tenant
    to a given value, so you get the desired tenant's ID when using the `CurrentTenant.Id`
    property inside the `using` block. For example, if you perform a database query
    from a shared database inside the `using` block, ABP will retrieve the desired
    tenant's data instead of the one resolved by the multi-tenancy middleware. Once
    the `using` block completes, `CurrentTenant.Id` is automatically restored to the
    previous value. You can safely use the `CurrentTenant.Change` method in a nested
    way when you rarely need it. If you want to switch to the host context, you can
    pass a `null` value to the `Change` method. Always use the `Change` method with
    a `using` block, as in this example, to not affect the surrounding context of
    your method.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to switching to the desired tenant, it is also possible to completely
    disable the tenant isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the data isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data isolation is critical in a multi-tenant application. It guarantees to query
    only the current tenant's data. However, in some cases, your application may require
    querying from the entire database, including all tenants' data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We explored the ABP''s data filtering system in the *Using the data filtering
    system* section of [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using
    the Features and Services of ABP*. ABP uses the same data-filtering system to
    filter data of the current tenant. So, we can use the same data-filtering API
    to disable the multi-tenancy filter temporarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are getting the total number of products owned by all the
    tenants in the database. The multi-tenancy data filter is disabled in the `using`
    block, so the repository works with all the records in the database.
  prefs: []
  type: TYPE_NORMAL
- en: While disabling the multi-tenancy filter is pretty easy, there is an important
    limitation – it only works with the single database approach. It cannot query
    a tenant's data if the tenant has a dedicated database. Currently, there is no
    direct way to perform a query on multiple databases and aggregate the query results
    as a single result set.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the technical limitation, there is also a design problem with querying
    all tenants' data. Ideally, multi-tenant software should be designed so that all
    tenants have their on-premises deployment with separate database and application
    servers. We will return to this discussion later in the *When to use multi-tenancy*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned the ways to access and change the current tenant. In the next
    section, we will see how to design our entities to be multi-tenancy-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the domain as multi-tenant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP aims to make your application code multi-tenancy-unaware and automate things
    wherever possible. Designing an entity class as multi-tenant is very simple. Just
    implement the `IMultiTenant` interface for your entity, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Product` aggregate root entity in this example implements the `IMultiTenant`
    interface and defines a `TenantId` property. The tenant identifier type is always
    `Guid` in ABP Framework. The `TenantId` property is nullable, making the `Product`
    entity available both for the tenant and the host side. If the `TenantId` property
    is `null`, that entity belongs to the host side. It also allows us to easily convert
    our application to a single-tenant, on-premises application where the `TenantId`
    property is always `null`.
  prefs: []
  type: TYPE_NORMAL
- en: ABP automatically sets the `TenantId` value using the `ICurrentTenant.Id` property
    when you create a new entity object (a `Product` object for this example). ABP
    is also responsible for saving it to the right database and querying from the
    right database, or filtering the tenant data if you are using a single database.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned the fundamental points of building a multi-tenant solution with
    ABP Framework. The next section introduces the ABP feature system that can be
    used to restrict application functionalities for tenants.
  prefs: []
  type: TYPE_NORMAL
- en: Using the feature system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most SaaS solutions provide different packages to the customers. Every package
    has a different set of application features and is subscribed at a different price.
    ABP provides a feature system used to define such application features, and then
    disable or enable these features for individual tenants. Let's start by defining
    a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is required to define a feature before using it. Create a new class deriving
    from the `FeatureDefinitionProvider` class (typically in the `.Application.Contracts`
    project in the startup solution) and override the `Define` method, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Features are grouped to create more modular systems (where every module defines
    its own group). In this example, I created a feature group for the final application.
    Then, I defined two features under that group. This example defines the two features:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is used to enable or disable the stock management feature for
    tenants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is used to limit the product entity count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature values are actually just strings, such as `false` and `100` in this
    example. However, Boolean values (`true` and `false`) can be used for conditional
    checks by convention.
  prefs: []
  type: TYPE_NORMAL
- en: ABP automatically discovers classes derived from the `FeatureDefinitionProvider`
    class, so you don't need to register it somewhere. After defining a feature, we
    can check its value for the current tenant (we will see how to assign features
    to tenants later, in the *Managing tenant features* section).
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I will show you how to enable, disable, or set the value of a feature for a
    tenant in the *Managing tenant features* section. But first, I want to show you
    how we check a feature's value for a tenant.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to check a feature's value for the current tenant. The
    easiest way is to use the `RequiresFeature` attribute that can be used on methods
    or classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RequiresFeature attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example uses the `RequiresFeature` attribute to restrict a class''s
    usage for the current tenant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `MyApp.StockManagement` feature's value is automatically checked
    in every method call for the `StockAppService` service, and an exception is thrown
    for unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RequiresFeature` attribute can also be used on a method. See the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, only the `GetStockCountAsync` method is restricted, and the other
    methods of `ProductAppService` without the `RequiresFeature` attribute are not
    affected.
  prefs: []
  type: TYPE_NORMAL
- en: The `RequiresFeature` attribute is easy to use but limited to Boolean features
    (with `true` and `false` values). For detailed usage, we should use the `IFeatureChecker`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Using the IFeatureChecker service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `IFeatureChecker` service allows us to get and check the feature values
    programmatically. You can inject it just like any other service. The following
    example checks whether the `MyApp.StockManagement` feature is enabled for the
    current tenant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsEnabled` method returns `true` only if the feature''s value is `true`
    (as `string`). If you have fallback logic (when the tenant doesn''t have that
    feature enabled), then using `IsEnabledAsync` is a good approach. However, if
    you only want to check whether a feature is enabled and should throw an exception
    otherwise, use the `CheckEnabledAsync` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `CheckEnabledAsync` method throws `AbpAuthorizationException` if the given
    feature is not enabled for the current tenant. However, if you need to simply
    check whether a feature is enabled or disabled at the beginning of the method,
    using the `RequiresFeature` attribute would be simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `IFeatureChecker` service is especially useful when you want to get
    the value of non-Boolean features. For example, the `MyApp.MaxProductCount` feature
    introduced in the *Defining the features* section is a numeric feature. We can't
    simply check whether it is enabled or disabled. We need to know its value for
    the current user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example checks the maximum allowed product count for the current
    tenant before creating a new product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `FeatureChecker.GetAsync<T>` method returns the value of the given feature
    by converting to the given generic type argument. Here, `MyApp.MaxProductCount`
    is a numeric feature, so I am converting to `int` and then comparing it with the
    current product count of the current tenant. `IFeatureChecker` also defines the
    `GetOrNullAsync` method that returns the string value of the feature or returns
    `null` if the feature has no value defined for the current tenant.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Feature of Another Tenant
  prefs: []
  type: TYPE_NORMAL
- en: The `IFeatureChecker` service works for the current tenant. If you want to check
    a feature's value for another tenant when you have the other tenant's ID, first
    switch to the target tenant, as explained in the *Switching between tenants* section,
    and then use the `IFeatureChecker` service as normal.
  prefs: []
  type: TYPE_NORMAL
- en: The `RequiresFeature` attribute and the `IFeatureChecker` service are used on
    the server side, but we also need to get and check feature values in our client
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Checking features on the client side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you define a feature, you will need to know its value on the client side.
    For example, if the `MyApp.StockManagement` feature is not enabled for the current
    tenant, you generally want to hide the related UI elements from the application
    pages and disable the client-to-server HTTP API calls for this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP provides multiple UI options, and each one provides a different API to
    check the features on the client side. For example, the ABP MVC/Razor Pages UI
    provides the global `abp.features` JavaScript API to check the features, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Please see the *Checking the tenant features* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, for more details about the `abp.features` JavaScript
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ABP Blazor UI, on the other hand, uses the same `IFeatureChecker` service
    on the client side. For other UI types, please refer to ABP''s documentation:
    [https://docs.abp.io/en/abp/latest/Features](https://docs.abp.io/en/abp/latest/Features).'
  prefs: []
  type: TYPE_NORMAL
- en: You've now learned how to get and check a feature's value for the current tenant.
    The next section explains how you can set the value of a feature for a tenant.
  prefs: []
  type: TYPE_NORMAL
- en: Managing tenant features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At a framework level, ABP doesn't care where the feature values are stored and
    how they are changed. It just defines an interface, `IFeatureStore`, that can
    be implemented to obtain the current value of a feature. However, it would not
    be good to leave its implementation to every developer because, most of the time,
    the implementation will be similar, and we don't want to waste our time re-implementing
    it again and again.
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework provides the `IFeatureStore` interface and provides a UI and API
    to modify the feature values for the tenants. The Feature Management module is
    already installed when you create a new solution using ABP's startup solution
    template. The following sections explain the Feature Management UI modal and the
    API to manage the feature values.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Feature Management UI modal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Feature Management module can automatically create the modal dialog to
    set the feature values. However, we need to define the value type for each feature.
    Return to `MyFeatureDefinitionProvider` and update the feature definitions as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I added `valueType` parameters to the `AddFeature` methods. The first one is
    `ToggleStringValueType`, which indicates that the feature has an on/off style
    (Boolean) value. The second one is `FreeTextStringValueType`, which indicates
    that the feature has a value that should be changed with a textbox. `NumericValueValidator`
    specifies the validation rule for the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined the value types properly, the Feature Management module
    can automatically render the necessary UI to set the feature values. To open the
    Feature Management dialog, log in to the application as an authorized host user,
    navigate to the tenant management page from the main menu, click the **Actions**
    button, and select the **Features** action, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – The Features action on the tenant management page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.2_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.2 – The Features action on the tenant management page
  prefs: []
  type: TYPE_NORMAL
- en: 'This action will open a modal dialog, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – The Feature Management dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.3_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.3 – The Feature Management dialog
  prefs: []
  type: TYPE_NORMAL
- en: We can see the group name on the left side (you can also localize the group's
    display name). When we click the **MyApp** group, we can see the form elements
    to set the values of the features. The UI has been dynamically created by the
    Feature Management module.
  prefs: []
  type: TYPE_NORMAL
- en: The `MyApp.StockManagement` feature becomes a checkbox on the UI, while a numeric
    textbox is shown for the `MyApp.MaxProductCount` feature. This way, you can easily
    set the feature values for any tenant. In addition to the UI, it is also possible
    to programmatically set the feature values using the Feature Management API.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Feature Management API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Feature Management module provides the `IFeatureManager` service to set
    a feature''s value for a tenant programmatically. The following example enables
    the `MyApp.StockManagement` feature for the given tenant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are injecting the `IFeatureManager` service into our class's constructor,
    just like any other service. Then, we use the `SetForTenantAsync` method to set
    the value to `true` for the given tenant.
  prefs: []
  type: TYPE_NORMAL
- en: When to use multi-tenancy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-tenancy is a great pattern to create SaaS solutions, and ABP Framework
    provides a complete infrastructure to create multi-tenant applications. However,
    not all applications should be SaaS, and not all SaaS applications should be multi-tenant.
    ABP's multi-tenancy system has some assumptions, and we've made some design decisions
    while building it. In this section, I want to talk about these assumptions and
    decisions to help you to decide whether ABP's multi-tenancy system fits into your
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP multi-tenant applications should be developed by assuming that each tenant
    will have a separated and isolated production environment. If you make this assumption,
    then you will have some restrictions. Here are a few example restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: You should not perform database queries from multiple tenants at once. If you
    do this, you assume that you will have a shared tenant database because it is
    technically not straightforward to query from multiple databases from different
    (and probably isolated) environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tenant's user cannot log in to the system with another tenant. This means
    you can't assign multiple tenants to a single user since users are completely
    isolated. ABP allows using the same email address or user name in different tenants,
    but they will actually be different users with different passwords and identifiers
    in the database, without any relation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot share roles (and their permissions) between different tenants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are natural restrictions if you assume that two tenants have different
    production environments and can't access each other's environment. ABP assumes
    that the same application can be deployed on-premises for a customer without any
    code change (except the `AbpMultiTenancyOptions.IsEnabled` option).
  prefs: []
  type: TYPE_NORMAL
- en: These assumptions don't mean that the tenants cannot share data at all. If an
    entity doesn't implement the `IMultiTenant` interface, it is naturally shared
    among all tenants and always stored in the central (host) database. In addition,
    you can switch between tenants to temporarily access a tenant's data from another
    tenant user. However, you should think about how this logic will work in an on-premises
    environment, or you can drop the on-premises deployment support from your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the confusion comes from thinking about the multi-tenancy only from
    a technical perspective but not thinking about its purpose of design. For example,
    think of an electronic marketplace where vendors manage and sell their products.
    Individual customers list and search products, add to a cart, and make a payment.
    This application may seem like a multi-tenant system if you assume that the vendors
    have their own products and vendor back-office users manage these products. If
    you use ABP's multi-tenancy system, all the isolation will be automatically done,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: While it has some requirements similar to a multi-tenant system from a technical
    perspective, the marketplace is likely to have parts that are integrated as a
    unified platform. In a multi-tenant system, a customer (tenant) behaves as if
    it owns the entire system. In a marketplace, a vendor is not a tenant. It does
    not use an application in isolation, as in an on-premises system. So, if you start
    with multi-tenancy, you will later have to deal with the problems of data sharing
    and integrations because shared/integrated parts are much more than the isolated
    parts in such a system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've explored the fundamental infrastructure provided by ABP
    Framework. We've learned how ABP determines the current tenant and isolates the
    data between the tenants. We also learned how to switch to another tenant or completely
    disable the data isolation when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Another great ABP feature is the feature system. We've defined features by creating
    a feature provider class and learned different ways of checking the value of a
    feature for the current user.
  prefs: []
  type: TYPE_NORMAL
- en: You are now able to work on a multi-tenant application's development where the
    tenants can have different rights on the application features.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces different levels of automated testing and explains
    how you can create unit and integration tests for your ABP-based solutions.
  prefs: []
  type: TYPE_NORMAL
