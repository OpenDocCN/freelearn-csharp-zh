- en: Implementing a Drone with the Strategy Pattern
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement enemy drones that fly around the
    race track and attack the player by shooting laser beams. They are little annoying
    robotic pests that will test the player's reflexes. Our drones will have a single
    attack that consists of firing a continuous laser beam at a 45-degree angle. To
    create the illusion of autonomous intelligence, the drones can be assigned three
    distinct attack maneuvers at runtime. Each maneuver is a repetitive series of
    predictable movements. Individually, the drone's behavior may look robotic, but
    when they are placed in a formation at specific positions on the race track, it
    could look like they are forming a strategy to outmaneuver the player.
  prefs: []
  type: TYPE_NORMAL
- en: And so, I'm proposing that we use the Strategy pattern to implement the various
    drone behaviors. The main reason for this choice is that this pattern allows us
    to assign specific behavior to an object at runtime. But first, let's break down
    the specifications of the pattern and the design intentions of our enemy drone.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes simplified skeleton code examples for the sake of brevity
    and clarity. If you wish to review a complete implementation of the pattern in
    the context of an actual game project, open the `FPP` folder in the GitHub project.
    You can find the link in the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing enemy drone attack behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is hands-on, so you will need to have a basic understanding of
    Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [https://bit.ly/2TdeoL4](https://bit.ly/2TdeoL4)[.](https://bit.ly/2TdeoL4)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary goal of the Strategy pattern is to defer the decision of which behavior
    to use at runtime. This is made possible because the Strategy pattern lets us
    define a family of behaviors that are encapsulated in individual classes that
    we call strategies. Each strategy is interchangeable and can be assigned to a
    target context object to change its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s visualize the key elements of the pattern with this UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75e1b61e-a602-4cc7-bdf4-166eeb5a4d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – UML diagram of the Strategy pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a breakdown of the key players of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context** is the class that uses the various concrete strategy classes and
    interacts with them through the Strategy interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Strategy** interface is common to all concrete strategy classes. It exposes
    a method that the `Context` class can use to execute a strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete Strategy **classes, also known as **strategies**, are concrete implementations
    of variants of algorithms/behaviors that can be applied to a `Context` object
    at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the moment, these concepts might sound very abstract, but in practice, they
    are quite easy to understand, as we are going to see later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern is a behavioral software design pattern; its closest cousin
    is the State pattern. We can use both to encapsulate a set of behaviors in individual
    classes. You should use the Strategy pattern when you want to select a behavior
    at runtime and apply it to an object. You can also use the State pattern when
    you want an object to change its behavior when its internal state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are some of the benefits of the Strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**: A clear benefit of this pattern is that it enforces variations
    of algorithms to be encapsulated in individual classes. Hence, this helps us avoid
    using long conditional statements while keeping our code structured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: The main benefit of this pattern is that it implements a mechanism
    that permits us to swap algorithms that an object is using at runtime. This approach
    makes our objects more dynamic and open for extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some potential drawbacks of the Strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: The client class must be aware of the individual strategies and
    the variations in the algorithm they implement so as to know which one to select.
    Therefore, the client becomes responsible for making sure that an object is behaving
    as expected during its lifespan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confusion**: Because the Strategy and State patterns are so similar in structure
    but have different intents, confusion could arise when you''re choosing which
    one to use and in what context. In most cases, it''s not an issue, but if you
    are working with a team of programmers, depending on the various levels of knowledge
    of the subject matter, some colleagues might not understand your choice of pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I believe it's essential to have regular open discussions about architecture,
    patterns, and best practices with your colleagues. If you can agree as a team
    on common approaches when using a specific set of design patterns, you will end
    up with a more consistent overall architecture and cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I get tasked with implementing behaviors for an enemy character, the first
    options I consider are the State pattern or a **finite state machine** (**FSM**)
    since most of the time, characters are stateful.
  prefs: []
  type: TYPE_NORMAL
- en: 'But sometimes, I might use the Strategy pattern if the following conditions
    are met:'
  prefs: []
  type: TYPE_NORMAL
- en: I have an entity with several variants of the same behavior, and I want to encapsulate
    them in individual classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I want to assign specific behavior variants to an entity at runtime, without
    the need to take its current internal state into consideration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I need to apply a behavior to an entity so that it can accomplish a specific
    task based on selection criteria that are defined at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third point is probably the main reason I chose to use the Strategy pattern
    over the State pattern to implement the enemy drone presented in this chapter.
    The behavior of the drone is robotic; it has a singular task: attack the player.
    It doesn''t make any alterations to its actions based on internal state changes.
    It only needs to be assigned an attack behavior at runtime to accomplish its task
    of attacking the player, which makes it the right candidate for the Strategy pattern
    in its current design.'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that potential use cases of the Strategy pattern are
    not limited to implementing enemy characters. For example, we could use it to
    encapsulate various encryption algorithms to apply to a saved file, depending
    on the target platform. Or, if we are working on a fantasy game, we could use
    it to encapsulate the individual behaviors of a family of spells that players
    can apply to a target entity. Therefore, the potential use cases for this pattern
    are broad and can be applied to various contexts, ranging from core systems to
    gameplay mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to review the design intentions of our enemy
    drone.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an enemy drone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The enemy drones in our game are not very smart; there is no artificial intelligence
    running behind the scene. These are robots with robotic behaviors, and it's common
    in video games to have enemies with predictable automated behaviors running in
    a loop. For instance, the Goombas in the original Super Mario Bros just walk in
    one direction; they are not aware of the presence of Mario or react to him. They
    are simply running an algorithm to make them wander in a path until they collide
    with an obstacle. Alone, they are not a threat, but if they are put in a formation
    or positioned at a point in the map in which navigation is difficult, they can
    become challenging to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the same approach for our enemy drones. Individually, they
    are easy to defeat because they can't change their behaviors based on the player's
    movements, but in a squad, they can be challenging to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Our drone has three distinct attack maneuvers; each revolves around a specific
    set of movements that are predictable but still challenging to counter when the
    drones are in a squad formation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at each maneuver:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bobbing Maneuver**: In a bobbing maneuver, the drone moves up and down at
    high speed while shooting a laser beam.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weaving Maneuver**: For the weaving maneuver, the drone moves horizontally
    at high speed, while shooting. The weaving maneuver is limited to the distance
    between the two rails of a track.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fallback Maneuver**: For the fallback maneuver, the drone moves backward
    while shooting. The top speed of the drone can match that of the player''s bike,
    but can only move back for a limited amount of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the preceding maneuvers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2c7f88d-444e-47d8-880b-a01102961ed3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Illustration of the drone's attack maneuvers
  prefs: []
  type: TYPE_NORMAL
- en: 'The enemy drone has a single weapon: a front-facing laser beam that''s fired
    at a 45-degree angle toward the ground. The following diagram illustrates the
    laser weapon of the drone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d26c7ff3-661e-4fa1-8faf-a428685bd87e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Illustration of the drone's weapon attack
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the player must avoid the attack by navigating around the drone
    at high speed. If hit by the beam, the bike's front-facing shield will lose a
    certain amount of power. If the shield becomes depleted, the vehicle will explode
    on the next hit, and it will be game over.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to translate this design into code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an enemy drone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write a skeleton implementation of the Strategy pattern
    and the individual attack behaviors of the drone enemy. The code in this section
    may seem oversimplified in certain aspects. Still, the end goal is not to have
    a complete implementation of the enemy drone but to understand the basics of the
    Strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to implementing an enemy drone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the main ingredients of the Strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first element is the Strategy interface; all our concrete strategies will
    use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are passing a parameter of the `Drone` type to the `Maneuver()`
    method. This is an important detail we will review later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is our `Drone` class; it''s going to use our concrete strategies, so
    in the overall structure of the Strategy pattern, we will consider it to be our
    `Context` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the lines of code in this class are for raycasting debugging information;
    we can safely ignore them. However, the following section is essential to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `ApplyStrategy()` method contains the core mechanism of the Strategy pattern.
    If we look closely, we can see that the method in question accepts a concrete
    strategy of the `IManeuverBehaviour` type as a parameter. And this is where things
    get very interesting. A `Drone` object can communicate with the concrete strategies
    it received through the `IManeuverBehaviour` interface. Thus, it only needs to
    call `Maneuver()` to execute a strategy at runtime. Hence, a `Drone` object doesn't
    need to know how a strategy's behavior/algorithm is executed – it just needs to
    be aware of its interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the concrete strategy classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class implements the bopping maneuver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following class implements the weaving maneuver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s implement the fallback maneuver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the code of each class is quite similar, even repetitive
    in certain parts. This accounts for one of the reasons we are using the Strategy
    pattern – we want to encapsulate variations of similar behaviors so that they
    are easier to maintain individually. But also, imagine how messy our `Drone` class
    would be if we tried to implement the bopping, weaving, and fallback behaviors
    in a single class. We would find ourselves in a bloated `Drone` class that's potentially
    filled to the brim with conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: I would not recommend using coroutines to animate non-humanoid entities. Instead,
    I suggest using a Tween engine such as DOTween since you can animate objects with
    less code while getting better results. We are using coroutines in this chapter
    to avoid external dependencies and make our code easy to port. To learn more about
    DOTween, go to [http://dotween.demigiant.com](http://dotween.demigiant.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the enemy drone implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And now for the fun part – testing our implementation. It''s going to be an
    easy one since all we need to do is attach the following client class to an empty
    `GameObject` in a Unity scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In your instance of Unity, if you included all the scripts we wrote in the
    preceding sections in your project, you should see a single button on the screen
    when you start it called Spawn Drone, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75f67a2a-f8c9-4b8b-a0c3-0f07bd89a6b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The code example in action inside Unity
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the scene's primary button, a new cube representing a Drone
    entity should appear at a random position while executing a randomly selected
    attack maneuver.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the enemy drone implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code example, the client class acts like a spawner that randomly
    assigns a strategy to a new drone instance. This could be an interesting approach
    for a real-world use case. But there are many other approaches we could have used
    to choose which strategy to assign to a drone. It could be based on specific rules
    and factors that are only known at runtime. Therefore, it's not limited to randomness
    but can also be deterministic and rule-based.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one glaring issue with the code examples presented in this chapter.
    We encapsulated attack maneuver behaviors into distinct strategy classes, but
    each maneuver is nothing more than a single animation running on a loop. So, in
    an actual game project that's been built by a production team that includes animators,
    I would not have animated the enemy drones in code by using coroutines or even
    a Tween animation engine. Instead, I would ask an animator to author some detailed
    attack maneuver animations in an external authoring tool and then import them
    into Unity as animation clips. I would then have used Unity's native animation
    system and its state machine feature to assign attack maneuver animations to a
    drone dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, I would have gained quality in the animations and the flexibility
    of transitioning smoothly from one attack behavior to another, if I decide that
    the drones can switch attacks when an internal state changes. Therefore, I would
    have moved away from the idea of encapsulating each attack behavior into a strategy
    class and instead defined them as finite states. This switch would not be a dramatic
    change in design as the concepts that drive the FSM, State, and Strategy patterns
    are closely related.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the Strategy pattern's implementation in the example presented in
    this chapter is valid, it's wise to consider what can be achieved natively with
    Unity's animation system first when you're managing an entity's animation set.
    But imagine another use case in which we need to implement variations of a motion
    detection algorithm and assign them to a drone at runtime. In that context, the
    Strategy pattern would be an excellent choice to build that system.
  prefs: []
  type: TYPE_NORMAL
- en: You can read the official documentation on Unity's native animation system at [https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html](https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used the Strategy pattern to implement our game's first
    enemy ingredient, a flying, laser-shooting drone. By using this pattern, we encapsulated
    each variant of the drone's attack maneuvers in individual classes. This approach
    made our code easier to maintain by avoiding having bloated classes filled with
    lengthy conditional statements. Now, we can quickly write new attack maneuver
    variations or adjust existing ones. Hence, we have given ourselves the flexibility
    to be creative and test out new ideas quickly, which is a vital part of game development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start working on a weapon system and explore the
    Decorator pattern.
  prefs: []
  type: TYPE_NORMAL
