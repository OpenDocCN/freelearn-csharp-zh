<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-94">
    <a id="_idTextAnchor094">
    </a>
    
     7
    
   </h1>
   <h1 id="_idParaDest-95">
    <a id="_idTextAnchor095">
    </a>
    
     Azure Durable Functions
    
   </h1>
   <p>
    
     In the previous chapter, we discussed how HTTP APIs in Azure Functions provide an alternative hosting model, as well as solve many traditional problems associated with
    
    
     
      manual hosting.
     
    
   </p>
   <p>
    
     Do you need to massively parallelize hundreds of millions of tasks on an arbitrary number of physical processes or nodes (fan-out) and then wait for them all to complete (fan-in)?
    
    
     Do you then need the app to wait for a human or other process to review and take action to continue the next step?
    
    
     What if that human is unavailable and you need to
    
    <em class="italic">
     
      timeout
     
    </em>
    
     the review process instead?
    
    
     This situation of events is easily expressible in code, and we’ll be tackling a subset of this scenario in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     In this chapter, we will look at
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Expanding on standard APIs to create resilient,
     
     
      
       stateful workflows
      
     
    </li>
    <li>
     
      Differences in debugging these workflows compared to
     
     
      
       previous chapters
      
     
    </li>
    <li>
     
      Interacting and injecting data into live systems using standard
     
     
      
       HTTP APIs
      
     
    </li>
    <li>
     
      Briefly discussing how to set up other common
     
     
      
       usage patterns
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor096">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     Building Azure Durable Functions in Visual Studio has the same requirements as for
    
    <a href="B21998_06.xhtml#_idTextAnchor077">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     .
    
    
     The source code for this chapter is available at
    
    <a href="https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter07">
     
      https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter07
     
    </a>
    
     .
    
   </p>
   <h1 id="_idParaDest-97">
    <a id="_idTextAnchor097">
    </a>
    
     Overview of Durable Functions
    
   </h1>
   <p>
    
     Durable Functions gets its very descriptive name from what it does under the hood: save its state to persistent storage in case of crashes, outages, dependency
    
    <a id="_idIndexMarker180">
    </a>
    <a id="_idIndexMarker181">
    </a>
    
     problems, and so on.
    
    
     Not only does this allow for problems to be recovered from easily but it also allows scalability and coordination among tasks.
    
    
     Durability in an Azure function is provided using a standard storage account by default.
    
    
     Tables, blobs, and queues are all used under
    
    
     
      the hood:
     
    
   </p>
   <ul>
    <li>
     
      Tables are used for managing function execution history, including parameters and
     
     
      
       return values
      
     
    </li>
    <li>
     
      Blob storage is used for the automatic storage of large parameters passed
     
     
      
       to activities
      
     
    </li>
    <li>
     
      Queues are used for triggering activities and
     
     
      
       orchestration instances
      
     
    </li>
   </ul>
   <p>
    
     SQL Server and Netherite are the other two supported durable store options that are not covered in this book but can be used in
    
    
     
      advanced scenarios.
     
    
   </p>
   <p>
    
     While there is never an “easy button” for scaling in a
    
    <a id="_idIndexMarker182">
    </a>
    <a id="_idIndexMarker183">
    </a>
    
     distributed system, the following two specific rules simplify an enormous amount of platform- and dependency-related overhead, allowing you to focus on the logic of the
    
    
     
      code itself:
     
    
   </p>
   <ul>
    <li>
     
      Orchestrator functions must
     
     
      
       be deterministic
      
     
    </li>
    <li>
     
      Activity functions must
     
     
      
       be idempotent
      
     
    </li>
   </ul>
   <p>
    
     Orchestrator functions are exactly what they
    
    <a id="_idIndexMarker184">
    </a>
    <a id="_idIndexMarker185">
    </a>
    
     sound like: they orchestrate, or control the execution order of, activities, which usually contain the bulk of the work or logic of the application.
    
    
     A major restriction that must be followed with orchestrators is that they must be deterministic, which also means that they cannot do any form of I/O directly.
    
    
     All activity, sub-orchestrator, or other awaited calls must be in the same order to return the executing code to its exact state just prior to the next
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     call.
    
    
     Other nondeterministic APIs that you must be aware of fall into categories such as DateTimes, GUIDs, I/O, and other async APIs.
    
    
     In general, if you need data from outside the durable context, use activities to
    
    
     
      retrieve it.
     
    
   </p>
   <p>
    
     Activity functions are always called by orchestrators, and cannot be called directly from anything else.
    
    
     These are where the bulk of the application logic usually happens, and compared to orchestrators, activity functions have one restriction: they must be idempotent.
    
    
     There is no guarantee that an activity instance will run exactly once, so be sure that multiple runs in succession have the
    
    
     
      same result.
     
    
   </p>
   <p>
    
     Adding durable support to your existing function is as easy as adding a NuGet package.
    
    
     All the functions, triggers, and so on can interoperate and coexist in a single project, depending on your
    
    
     
      application requirements.
     
    
   </p>
   <p>
    
     Before Durable Functions, in a manually written situation with only basic OS platform support, you had to manage the state yourself.
    
    
     This included handling crashes, and marking tasks as done, errored, in progress, and so on.
    
    
     Restarts also had to be managed, as did advanced processing such as a parallel fan-out situation.
    
    
     Using Durable Functions simplifies all
    
    
     
      these requirements.
     
    
   </p>
   <p>
    
     Now, let’s look at starting up a durable instance, and how these objects coordinate tasks in a
    
    
     
      stateful system.
     
    
   </p>
   <h2 id="_idParaDest-98">
    <a id="_idTextAnchor098">
    </a>
    
     Orchestrators
    
   </h2>
   <p>
    
     The main “entry point” into the
    
    <a id="_idIndexMarker186">
    </a>
    <a id="_idIndexMarker187">
    </a>
    
     Durable system is through an orchestrator.
    
    
     These are started up inside the running function using
    
    <strong class="source-inline">
     
      DurableTaskClient
     
    </strong>
    
     , or outside of a function process by using the HTTP management APIs discussed later in the
    
    <em class="italic">
     
      Programming and debugging walk-through
     
    </em>
    
     section.
    
    
     I say
    
    <em class="italic">
     
      entry point
     
    </em>
    
     because I find it conceptually easier to think about it in this way.
    
    
     While the OS process itself still uses the classic
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     or void
    
    <strong class="source-inline">
     
      Main(...)
     
    </strong>
    
     , data or message processing in a Durable system usually begins with a method marked with a
    
    <strong class="source-inline">
     
      Function
     
    </strong>
    
     attribute, and
    
    <strong class="source-inline">
     
      DurableTaskClient
     
    </strong>
    
     marked with an
    
    
     <strong class="source-inline">
      
       OrchestrationTrigger
      
     </strong>
    
    
     
      attribute.
     
    
   </p>
   <p>
    
     Serializable data objects, usually in JSON form, can be passed into the orchestrator when an instance is created.
    
    
     These can be things such as larger descriptive objects, SAS tokens to blob storage, binary data that must be deserialized, or all of them combined.
    
    
     While you can work with standard strings or
    
    <strong class="source-inline">
     
      JsonNodes
     
    </strong>
    
     (sometimes you must), my preferred way is to use the generic method overloads and create serialization classes to mirror the structure of the data being passed around in the system.
    
    
     This ensures that it is easy to modify the objects over time, delegating the type-checking to the compiler.
    
    
     This also sidesteps a runtime issue that sometimes occurs during development: missing or mismatched serialization classes, which are not immediately apparent as there would be no standard compilation errors or runtime exceptions.
    
    
     The same will apply
    
    
     
      to activities.
     
    
   </p>
   <p>
    
     Since orchestration instances are durable and their
    
    <a id="_idIndexMarker188">
    </a>
    <a id="_idIndexMarker189">
    </a>
    
     state is written to persistent storage, this means that a running orchestration instance does not need to stay loaded into RAM while it waits for an activity to finish.
    
    
     Taking this a step further, it need not resume running on the same OS process, virtual machine, or physical machine.
    
    
     This can lead to highly performant and efficient allocation of compute and memory resources.
    
    
     In the extreme case, you could have hundreds or thousands of orchestration instances awaiting future completion of tasks, all without using compute or memory, only
    
    
     
      minimal storage.
     
    
   </p>
   <p>
    
     Continuing to take this further, you could have an infinite loop that also does not use any compute or memory while awaiting a task.
    
    
     This concept, called an eternal orchestrator, could respond to outside events, act, and durably wait until the next event.
    
    
     A
    
    <a id="_idIndexMarker190">
    </a>
    <a id="_idIndexMarker191">
    </a>
    
     small caveat though: since orchestration instances save their history to rebuild their state in the future, an eternal orchestrator could have an ever-growing history, which would eventually cause performance problems.
    
    
     A method called
    
    <strong class="source-inline">
     
      ContinueAsNew
     
    </strong>
    
     truncates that history, which prevents it
    
    
     
      from growing.
     
    
   </p>
   <p>
    
     With any API or stateful workflow, you’ll almost certainly need to process something, make network calls, and so on.
    
    
     Since we are unable to do so in orchestrators, this is where activities
    
    
     
      come in.
     
    
   </p>
   <h2 id="_idParaDest-99">
    <a id="_idTextAnchor099">
    </a>
    
     Activities
    
   </h2>
   <p>
    
     The pieces of code that actually
    
    <a id="_idIndexMarker192">
    </a>
    <a id="_idIndexMarker193">
    </a>
    
     contain most of your logic are activities.
    
    
     They have one very specific requirement: they must be idempotent.
    
    
     This means your code must have no side effects if it happens to execute more than once, as there is no guarantee that a specific instance will execute exactly once.
    
    
     Due to various reasons, some out of your control, activities may be terminated in the middle of execution.
    
    
     This must be handled in your activity code so that when the Durable system detects an incomplete instance, starting from the beginning is not
    
    
     
      a problem.
     
    
   </p>
   <p>
    
     Various built-in programming constructs that you would normally not think about, now have a profound potential impact on the rest of the system.
    
    
     For example,
    
    <strong class="source-inline">
     
      Guid.NewGuid()
     
    </strong>
    
     should likely not be used in an activity.
    
    
     Creating files, saving database records, or calling other APIs with this random GUID could now result in an orphaned record if the activity needed to be restarted from the beginning.
    
    
     Instead, you could create the new GUID inside the orchestrator, and pass that into the activity with its object
    
    <a id="_idIndexMarker194">
    </a>
    <a id="_idIndexMarker195">
    </a>
    
     parameter.
    
    
     The
    
    <strong class="source-inline">
     
      TaskOrchestrationContext
     
    </strong>
    
     instance passed into the orchestrator has a specific method called
    
    <strong class="source-inline">
     
      NewGuid
     
    </strong>
    
     to facilitate this
    
    
     
      exact need.
     
    
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor100">
    </a>
    
     Programming and debugging walk-through
    
   </h2>
   <p>
    
     Using the existing
    
    <a href="B21998_06.xhtml#_idTextAnchor077">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     function code, let’s add support for
    
    <a id="_idIndexMarker196">
    </a>
    <a id="_idIndexMarker197">
    </a>
    
     Durable to it.
    
    
     Right-click on the project and select
    
    <strong class="bold">
     
      Add
     
    </strong>
    
     |
    
    <strong class="bold">
     
      New Azure Function
     
    </strong>
    
     just as you did with the first HTTP endpoint.
    
    
     Give it a name, and then select
    
    <strong class="bold">
     
      Durable
     
    </strong>
    
     <strong class="bold">
      
       Functions Orchestration
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 7.1 – Adding a new Durable Functions orchestration" src="img/B21998_07_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.1 – Adding a new Durable Functions orchestration
    
   </p>
   <p>
    
     You can see from the provided template that three static methods were created corresponding to each of the concepts we discussed earlier: a regular function with
    
    <strong class="source-inline">
     
      HttpTrigger
     
    </strong>
    
     , which schedules a new orchestration instance to run, which then calls one or more activities.
    
    
     Visual Studio should have added a reference to
    
    <strong class="source-inline">
     
      Microsoft.Azure.Functions.Worker.Extensions.DurableTask
     
    </strong>
    
     automatically, but add it via NuGet if it
    
    
     
      did not.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Notice that these methods are all static.
    
    
     Though this does work, it leaves a lot to be desired as it prevents impactful concepts discussed in the last chapter such as options, dependency injection, and easier testing.
    
    
     Durable Functions also supports migrating the code to the non-static style in the previous chapter.
    
    
     This exercise is left up to you.
    
    
     We are using the word “the” when referring to the orchestrator and activity we are working on.
    
    
     This may seem out of place since we are referring to single static methods and not necessarily an object or thing you can see visually.
    
    
     The same static method may also be executing in different threads, processes, and virtual machines concurrently with different data.
    
    
     If you do decide to undertake the code migration, the individual files with regular constructors and non-static methods may help you conceptually
    
    
     
      visualize them.
     
    
   </p>
   <p>
    
     We’ll focus on saving some data to a file and waiting for an event that will then update the file again.
    
    
     Let’s begin by deleting the contents of the
    
    <strong class="source-inline">
     
      SayHello
     
    </strong>
    
     method, which contains a string parameter,
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     , with
    
    <strong class="source-inline">
     
      ActivityTrigger
     
    </strong>
    
     on it.
    
    
     This is your one and only
    
    <a id="_idIndexMarker198">
    </a>
    <a id="_idIndexMarker199">
    </a>
    
     parameter that can be passed to your activity from your orchestrator.
    
    
     Though this can be a string, generally, it is some kind of data transfer or
    
    <strong class="bold">
     
      Plain Old C# Class
     
    </strong>
    
     (
    
    <strong class="bold">
     
      POCO
     
    </strong>
    
     ) object that must be JSON serializable.
    
    
     The
    
    <strong class="source-inline">
     
      FunctionContext executionContext
     
    </strong>
    
     parameter can be used to
    
    <a id="_idIndexMarker200">
    </a>
    <a id="_idIndexMarker201">
    </a>
    
     discover information about the running activity, among other things.
    
    
     Change the return type to
    
    <strong class="source-inline">
     
      Task&lt;string&gt;
     
    </strong>
    
     , and add a line that awaits a call to
    
    <strong class="source-inline">
     
      File.WriteAllTextAsync
     
    </strong>
    
     , giving it a filename of your choosing, and then the contents will be the
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     string parameter marked with
    
    <strong class="source-inline">
     
      ActivityTrigger
     
    </strong>
    
     .
    
    
     Rename this parameter and its references to
    
    <strong class="source-inline">
     
      contents
     
    </strong>
    
     by pressing
    
    <em class="italic">
     
      F2
     
    </em>
    
     .
    
    
     This activity is simple and straightforward, which will add extra value to the orchestrator when we use it more
    
    
     
      than once.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      SayHello
     
    </strong>
    
     method should
    
    
     
      resemble this:
     
    
   </p>
   <pre class="source-code">
[Function(nameof(SayHello))]
public static async Task&lt;string&gt; SayHello([ActivityTrigger] string contents, FunctionContext executionContext)
{
    await File.WriteAllTextAsync(“myfile.txt”, contents);
    return default;
}</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      RunOrchestrator
     
    </strong>
    
     method, delete the contents and add an awaited call to
    
    <strong class="source-inline">
     
      context.CallActivityAsync
     
    </strong>
    
     , passing it the name of the activity, which, in our case, is
    
    <strong class="source-inline">
     
      SayHello
     
    </strong>
    
     .
    
    
     Change the return to
    
    <strong class="source-inline">
     
      Task&lt;object&gt;
     
    </strong>
    
     and then
    
    <strong class="source-inline">
     
      return default
     
    </strong>
    
     to make the compiler happy.
    
    
     Add an awaited call to
    
    <strong class="source-inline">
     
      context.WaitForExternalEvent&lt;ExpandoObject&gt;(“MyEvent”)
     
    </strong>
    
     after that, and save that into a
    
    <strong class="source-inline">
     
      dynamic
     
    </strong>
    
     variable.
    
    
     Finally, let’s add another call to our first activity, but this time, pass it the dynamic awaited event’s
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     property that we received from the external
    
    
     
      event call.
     
    
   </p>
   <p class="callout-heading">
    
     Tip
    
   </p>
   <p class="callout">
    
     Though you can use a normal double-quoted string when calling an activity via
    
    <strong class="source-inline">
     
      CallActivityAsync
     
    </strong>
    
     , using the
    
    <strong class="source-inline">
     
      nameof
     
    </strong>
    
     expression is particularly powerful here as it not only evaluates to a string during compile time but also responds to symbol renaming.
    
    
     We’ll use this in the sample.
    
    
     The same idea can be used for
    
    <strong class="source-inline">
     
      WaitForExternalEvent
     
    </strong>
    
     by using the POCO class name,
    
    
     
      for example.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      RunOrchestrator
     
    </strong>
    
     method should
    
    
     
      resemble this:
     
    
   </p>
   <pre class="source-code">
[Function(nameof(MyOrchestrator))]
public static async Task&lt;object&gt; RunOrchestrator(
    [OrchestrationTrigger] TaskOrchestrationContext context)
{
    await context.CallActivityAsync(nameof(SayHello)
);
    dynamic eventValue = await context.
    WaitForExternalEvent&lt;ExpandoObject&gt;(“MyEvent”);
    await context.CallActivityAsync(nameof(SayHello)
    , eventValue.value);
    return default;
}</pre>
   <p class="callout-heading">
    
     Tip
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      Function
     
    </strong>
    
     runtime mandates that we pass JSON data to this endpoint, which would then be automatically deserialized and returned from our awaited
    
    <strong class="source-inline">
     
      WaitForExternalEvent
     
    </strong>
    
     call.
    
    
     This ensures a baseline level of backward compatibility in case things need to change in the future.
    
    
     For our testing purposes, we are using
    
    <strong class="source-inline">
     
      dynamic
     
    </strong>
    
     to reduce the number of boilerplate files that would need to be created during this chapter.
    
   </p>
   <p>
    
     Let’s start debugging in Visual Studio, and
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     /
    
    <em class="italic">
     
      CMD
     
    </em>
    
     click on the
    
    <strong class="source-inline">
     
      MyOrchestrator_HttpStart
     
    </strong>
    
     HTTP trigger to run our orchestrator entrypoint.
    
    
     Navigate to the output folder on the function, likely in
    
    <strong class="source-inline">
     
      bin/debug/net8.0
     
    </strong>
    
     , and
    
    <a id="_idIndexMarker202">
    </a>
    <a id="_idIndexMarker203">
    </a>
    
     notice there’s an empty file.
    
    
     This is the result of the first call to the
    
    <strong class="source-inline">
     
      SayHello
     
    </strong>
    
     activity.
    
    
     What is the function doing now?
    
    
     It is currently awaiting the call to
    
    <strong class="source-inline">
     
      WaitForExternalEvent
     
    </strong>
    
     .
    
    
     Copy or save the URI specified by the
    
    <strong class="source-inline">
     
      sendEventPostUri
     
    </strong>
    
     element, as we’ll need that in a moment.
    
    
     Let’s stop debugging now so that the physical application process terminates.
    
    
     Immediately start debugging again, but do not click on the link again to start a new instance.
    
    
     Our previous instance is still “running” in the Durable Functions sense, only it is not taking up memory, CPU, or any other OS resource, except for
    
    
     
      storage space.
     
    
   </p>
   <p>
    
     Open up your favorite REST client interface such as the new built-in one from Visual Studio, Postman, and so on.
    
    
     You’ll need the URI you copied previously to signal our running orchestration instance event.
    
    
     We’ll be using Visual Studio.
    
    
     Create a new text file by right-clicking on the project, selecting
    
    <strong class="bold">
     
      Add
     
    </strong>
    
     |
    
    <strong class="bold">
     
      New Item...
     
    </strong>
    
     , and then selecting
    
    <strong class="bold">
     
      Text File
     
    </strong>
    
     .
    
    
     The name of this file should end with
    
    <strong class="source-inline">
     
      .http
     
    </strong>
    
     so that Visual Studio recognizes it.
    
    
     Type
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     in all uppercase, and then paste in the URI that you copied earlier.
    
    
     Replace
    
    <strong class="source-inline">
     
      {eventName}
     
    </strong>
    
     with the name that you chose in the code; we used
    
    <strong class="source-inline">
     
      MyEvent
     
    </strong>
    
     .
    
    
     Add a header with the
    
    <strong class="source-inline">
     
      Content-Type: application/json
     
    </strong>
    
     value so that the
    
    <strong class="source-inline">
     
      Function
     
    </strong>
    
     runtime accepts it.
    
    
     Ensure that there is an empty line after
    
    <a id="_idIndexMarker204">
    </a>
    <a id="_idIndexMarker205">
    </a>
    
     the URI, then type some valid JSON with a
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     property and value.
    
    
     To end the body of the request, make sure that there is also an empty
    
    
     
      line afterward.
     
    
   </p>
   <div><div><img alt="Figure 7.2 – REST client setup in Visual Studio" src="img/B21998_07_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.2 – REST client setup in Visual Studio
    
   </p>
   <p>
    
     Switch to the orchestrator file and place a breakpoint on both calls to our activity.
    
    
     Send the
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request using the
    
    <strong class="source-inline">
     
      Send
     
    </strong>
    
     request link in the
    
    <strong class="source-inline">
     
      .http
     
    </strong>
    
     file.
    
    
     The first breakpoint should now hit.
    
    
     But wait, why was the first one hit when we already ran this line and are waiting on the line after that?
    
    
     Hover over the
    
    <strong class="source-inline">
     
      context
     
    </strong>
    
     variable and expand it to look at the read-only
    
    <strong class="source-inline">
     
      IsReplaying
     
    </strong>
    
     property.
    
    
     Notice that it
    
    
     
      is
     
    
    
     <strong class="source-inline">
      
       true
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 7.3 – IsReplaying is true" src="img/B21998_07_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.3 – IsReplaying is true
    
   </p>
   <p>
    
     This is exactly what the property’s name sounds like; it is quite literally rebuilding its internal state line by line.
    
    
     It will do this after every single
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     .
    
    
     This is why orchestrators must be deterministic so that the internal state is always exactly the same no matter how many times it must rerun the same logic over and over.
    
    
     Every single call to these
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     methods is saved in durable storage.
    
    
     At some point in the future, they are queried, deserialized, and returned to the calling orchestrator.
    
    
     Press
    
    <em class="italic">
     
      F10
     
    </em>
    
     to step over the first activity call, and check to see that the
    
    <strong class="source-inline">
     
      IsReplaying
     
    </strong>
    
     property is still
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     .
    
    
     Step again over
    
    <strong class="source-inline">
     
      WaitForExternalEvent
     
    </strong>
    
     , which should return immediately.
    
    
     Now, look at the
    
    <strong class="source-inline">
     
      IsReplaying
     
    </strong>
    
     property again; it should be
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     .
    
    
     This means it is the very first time that this code has been run for this orchestration instance.
    
   </p>
   <div><div><img alt="Figure 7.4 – IsReplaying is false" src="img/B21998_07_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.4 – IsReplaying is false
    
   </p>
   <p>
    
     Press
    
    <em class="italic">
     
      F5
     
    </em>
    
     to continue; it should immediately call the activity.
    
    
     Navigate to the output folder again and open the file.
    
    
     You should see the contents of the value property that you set in the
    
    <strong class="source-inline">
     
      .http
     
    </strong>
    
     file’s
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request.
    
    
     The orchestration instance is now
    
    <a id="_idIndexMarker206">
    </a>
    <a id="_idIndexMarker207">
    </a>
    
     completed.
    
    
     If you query durable storage, you’ll find the complete history of this orchestration instance, including all input and output parameters, errors if there are any, and timestamps.
    
    
     This will allow you to analyze the orchestration instance later if needed or for tracking, logging, and so on.
    
    
     We’ll look at how to view this in a moment.
    
   </p>
   <p>
    
     Waiting on activities, external events, and sub-orchestrators is powerful all on its own.
    
    
     However, we can take it one step further.
    
    
     Using the existing language features such as
    
    <strong class="source-inline">
     
      List&lt;Task&gt;
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Task.WhenAny
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      Task.WhenAll
     
    </strong>
    
     , we can have an arbitrarily long stateful execution system.
    
    
     This can scale, wait for potentially hundreds or thousands of activity instances to run, and then move on to the
    
    
     
      next code.
     
    
   </p>
   <p class="callout-heading">
    
     Tip
    
   </p>
   <p class="callout">
    
     Using
    
    <strong class="source-inline">
     
      Task.WhenAny
     
    </strong>
    
     , we can wait on an external human event or a timeout.
    
    
     This allows us to default to an action if an external event is not received
    
    
     
      in time.
     
    
   </p>
   <p>
    
     To have an easier time debugging, you’re likely to want to be familiar with clearing the durable storage.
    
    
     This allows you to start from a clean state.
    
    
     If you have many outstanding orchestration instances, timers, and so on, it can be difficult when debugging anything in the same project.
    
    
     Using Azure Storage Explorer, navigate to
    
    <strong class="bold">
     
      Emulator &amp; Attached
     
    </strong>
    
     |
    
    <strong class="bold">
     
      (Emulator – Default Ports) (Key)
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Tables
     
    </strong>
    
     , and open two tables that end with
    
    <strong class="source-inline">
     
      History
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Instances
     
    </strong>
    
     .
    
    
     Look around for a bit to see how the data is physically stored if interested.
    
    
     When
    
    <a id="_idIndexMarker208">
    </a>
    <a id="_idIndexMarker209">
    </a>
    
     done, right-click on the
    
    <strong class="source-inline">
     
      History
     
    </strong>
    
     table and select
    
    <strong class="bold">
     
      Delete
     
    </strong>
    
     .
    
    
     Do the same
    
    
     
      for
     
    
    
     <strong class="source-inline">
      
       Instances
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 7.5 – Clearing the local History table" src="img/B21998_07_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.5 – Clearing the local History table
    
   </p>
   <p>
    
     There are additional advanced topics not covered here.
    
    
     Some of them are durable entities, and a counterpart, critical sections (.NET only).
    
    
     These together let you coordinate distributed locks inside
    
    
     
      an orchestrator.
     
    
   </p>
   <h2 id="_idParaDest-101">
    <a id="_idTextAnchor101">
    </a>
    
     Additional options
    
   </h2>
   <p>
    
     Sometimes, you want an orchestrator to continuously wait for an external event without ever exiting.
    
    
     Using a standard
    
    <strong class="source-inline">
     
      for
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      while
     
    </strong>
    
     loop around the
    
    <a id="_idIndexMarker210">
    </a>
    <a id="_idIndexMarker211">
    </a>
    
     call to
    
    <strong class="source-inline">
     
      WaitForExternalEvent
     
    </strong>
    
     is reasonable for a low number of events.
    
    
     But recall how previously I mentioned that every single
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     is some type of network call to the durable storage.
    
    
     Having
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     inside of a loop has the potential to drastically increase the latency for building up the internal state.
    
    
     An alternative way to support this exact scenario is to use eternal orchestrations with a call to
    
    <strong class="source-inline">
     
      ContinueAsNew
     
    </strong>
    
     .
    
    
     Though these are especially suited for the situation described, it’s worth noting that they have some considerations you need to keep in mind.
    
    
     While they do prevent the continuous growth of durable storage for that instance, they do so by truncating the history.
    
    
     This may be acceptable in your situation, but it could also not be.
    
    
     Note that while you have lost the underlying execution history in the durable store, nothing is preventing you from manually logging things that you need or want to keep.
    
    
     You could have a logging activity in place throughout your code to log various important events to, for example, Table storage.
    
    
     There’s also the option of logging to Application Insights.
    
    
     However, Insights is not a permanent log
    
    
     
      storage solution.
     
    
   </p>
   <p>
    
     Sometimes, you want a single instance of a global orchestrator throughout your entire application.
    
    
     These can be useful in background tasks, for example.
    
    
     This is accomplished with what is known as singleton orchestrators.
    
    
     It does not have a
    
    <a id="_idIndexMarker212">
    </a>
    <a id="_idIndexMarker213">
    </a>
    
     specific method call per se, but to enable this functionality, all you need to do is start an orchestration instance normally with a specified instance ID that will
    
    
     
      not change.
     
    
   </p>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor102">
    </a>
    
     Exceptions
    
   </h2>
   <p>
    
     While most programming
    
    <a id="_idIndexMarker214">
    </a>
    <a id="_idIndexMarker215">
    </a>
    
     constructs are available, a bit of special care must be taken when working with exceptions.
    
    
     Using C#, we do have first-class handling of them.
    
    
     However, since this is potentially across a process boundary, a notable incompatibility is when catching derived exception types.
    
    
     You should, in general, catch the normal base exception, and then handle
    
    
     
      it appropriately.
     
    
   </p>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor103">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we discussed how the durable orchestration system comprising activities and orchestrators helps to solve a wide variety of use cases.
    
    
     We then walked through adding Durable Functions to our existing Functions code from the previous chapter.
    
    
     Via debugging, we demonstrated how the orchestrator rebuilds its internal state, and how to get information into a running orchestration instance.
    
    
     We then discussed some helpful tips to clear the local durable store during development and touched on some additional features and pitfalls.
    
   </p>
   <p>
    
     In the next chapter, we‘ll take a look at related concepts including Table storage, Aspire, and some additional advanced
    
    
     
      API topics.
     
    
   </p>
   <h1 id="_idParaDest-104">
    <a id="_idTextAnchor104">
    </a>
    
     You try it
    
   </h1>
   <p>
    
     Create or modify an existing HTTP trigger to start a new Orchestration instance.
    
    
     Have your new Orchestrator await at least two Activities (they can be the same one) so you can debug and step through to watch it rebuild its internal state.
    
    
     The Activity can be something minimal for this, a single API call to anywhere or something else.
    
    
     After it completes, view the Table Storage durable logs in Azure or Azure Storage Explorer.
    
    
     Examine how the logs in the history table line up with your orchestrator.
    
   </p>
  </div>
 </body></html>