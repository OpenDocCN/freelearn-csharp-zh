- en: '*Chapter 11*: DDD – The Application Layer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：DDD – 应用层'
- en: The previous chapter explained the domain-layer building blocks with details.
    The domain layer is used to implement the core, application-independent domain
    logic of the solution. However, we also need some applications to interact with
    that domain logic, such as a web or mobile application. The application layer
    is responsible for implementing the business logic of such applications without
    depending on the **user interface** (**UI**) technology used in the presentation
    layer. We keep the domain layer isolated from the presentation technology by encapsulating
    it with the application services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章详细解释了领域层构建块。领域层用于实现解决方案的核心、与应用程序无关的领域逻辑。然而，我们还需要一些应用程序与该领域逻辑进行交互，例如一个Web或移动应用程序。应用层负责实现这些应用程序的业务逻辑，而不依赖于表示层中使用的**用户界面**（**UI**）技术。我们通过将应用服务封装起来，将领域层与表示技术隔离开来。
- en: In this chapter, we will learn how to design and implement the application services
    and **data transfer objects** (**DTOs**) with ABP Framework. We will also understand
    the differences between domain-layer and application-layer responsibilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用ABP框架设计和实现应用服务和**数据传输对象**（**DTOs**）。我们还将了解领域层和应用层职责之间的区别。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Implementing application services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应用服务
- en: Designing DTOs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计DTOs
- en: Understanding the responsibilities of the layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各层的职责
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can clone or download the source code of the *EventHub* project from GitHub:
    [https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub克隆或下载*EventHub*项目的源代码：[https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub)。
- en: If you want to run the solution in your local development environment, you need
    an **integrated development environment** (**IDE**)/editor (such as Visual Studio)
    to build and run ASP.NET Core solutions. Also, if you want to create ABP solutions,
    you need to have the ABP **command-line interface** (**CLI**) installed, as explained
    in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting Started with
    ABP Framework*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本地开发环境中运行解决方案，您需要一个**集成开发环境**（**IDE**）/编辑器（例如Visual Studio）来构建和运行ASP.NET
    Core解决方案。此外，如果您想创建ABP解决方案，您需要安装ABP **命令行界面**（**CLI**），如[*第2章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)，*开始使用ABP框架*中所述。
- en: Implementing application services
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现应用服务
- en: An application service is a stateless class used by the presentation layer to
    perform use cases of the application. It orchestrates the domain objects to achieve
    the business operation. Application services get and return DTOs instead of entities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务是一个无状态的类，由表示层使用以执行应用程序的用例。它协调领域对象以实现业务操作。应用服务获取和返回DTO而不是实体。
- en: 'An application service method is considered a work unit (meaning all database
    operations—all succeed or all fail as a group, as covered in [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177),
    *Working with the Data Access Infrastructure*), which ABP Framework automatically
    does. A typical flow of an application service method includes the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务方法被视为一个工作单元（意味着所有数据库操作——要么全部成功，要么全部失败作为一个组，如在第[*第6章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)，*与数据访问基础设施一起工作*中所述），ABP框架会自动处理。一个典型应用服务方法的流程包括以下步骤：
- en: Get the necessary aggregates from the repositories using the input parameters
    and the current context.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入参数和当前上下文从仓储获取必要的聚合。
- en: Implement the use case by coordinating the aggregates, domain services, and
    other domain objects, and delegating the work to them.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过协调聚合、领域服务和其他领域对象，并委托工作给它们来实现用例。
- en: Update the changed aggregates in the database using the repositories.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用仓储更新数据库中已更改的聚合。
- en: Optionally, return a resulting DTO to the client (typically, to the presentation
    layer).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，向客户端返回一个结果DTO（通常，返回给表示层）。
- en: About Updating Changed Objects
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于更新更改对象
- en: In fact, *Step 3* is not necessary if you use **Entity Framework Core** (**EF
    Core**), since EF Core has a change-tracking system that can automatically determine
    changed objects and update them in the database at the end of the **unit of work**
    (**UoW**). So, if you have no problem relying on EF Core features, you can skip
    *Step 3*.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，如果你使用 **Entity Framework Core** (**EF Core**)，则 *步骤 3* 是不必要的，因为 EF Core
    有一个更改跟踪系统，可以自动确定更改的对象，并在 **工作单元** (**UoW**) 的末尾将它们更新到数据库中。所以，如果你没有问题依赖 EF Core
    的功能，你可以跳过 *步骤 3*。
- en: 'Let’s see the `AddSessionAsync` application service method in the following
    example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例中的 `AddSessionAsync` 应用服务方法：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method is a simple application service method. It is used to add a new
    session to an event. It first gets the related `Event` aggregate from the database.
    Then, it uses the `AddSession` method of the `Event` class to delegate the actual
    business operation to the domain layer. It finally updates the changed `Event`
    object in the database. We will see the `AddSessionDto` class in the *Designing
    DTOs* section of this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是一个简单的应用服务方法。它用于向事件添加一个新的会话。它首先从数据库中获取相关的 `Event` 聚合。然后，它使用 `Event` 类的 `AddSession`
    方法将实际的业务操作委派给域层。最后，它更新数据库中的更改后的 `Event` 对象。我们将在本章的 *设计 DTOs* 部分看到 `AddSessionDto`
    类。
- en: 'Let’s see a more complex example that creates a new event, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更复杂的例子，如下创建一个新事件：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `CreateAsync` method gets a `CreateEventDto` object from the UI layer that
    carries the new event data and is a good example of creating new entities. Let’s
    investigate how it was implemented.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAsync` 方法从 UI 层获取一个 `CreateEventDto` 对象，该对象携带新事件数据，是创建新实体的一个好例子。让我们调查它是如何实现的。'
- en: It first gets the `organization` object from the database and compares its owner’s
    `AbpAuthorizationException` exception if the user doesn’t meet the condition.
    Authorization is an application-layer responsibility, and the authorization rules
    can be different in different applications. For example, in the admin application,
    an admin user can create events on behalf of any user without checking the organization’s
    ownership.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先从数据库中获取 `organization` 对象，并比较其所有者的 `AbpAuthorizationException` 异常，如果用户不满足条件。授权是应用层的责任，不同的应用中授权规则可能不同。例如，在管理应用中，管理员用户可以代表任何用户创建事件，而不检查组织的所有权。
- en: The `CreateAsync` method then uses the `eventManager` domain service to create
    a new `Event` object with the minimum required properties.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAsync` 方法随后使用 `eventManager` 域服务创建一个新的 `Event` 对象，并带有所需的最小属性。'
- en: We’ve created an `Event` object, but our work hasn’t been completed yet. `CreateEventDto`
    has some optional properties that the user may set. We are again using the `eventManager`
    domain service to set the location of the event. We are then directly setting
    the `Language` property of `Event` because there is no business rule to set it;
    it has a public setter, and the value can even be `null`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 `Event` 对象，但我们的工作还没有完成。`CreateEventDto` 有一些可选属性，用户可能设置。我们再次使用 `eventManager`
    域服务来设置事件的地点。然后，我们直接设置 `Event` 的 `Language` 属性，因为没有业务规则来设置它；它有一个公共设置器，其值甚至可以是 `null`。
- en: The `CreateAsync` method continues using the `eventManager` class to set the
    event capacity by checking the core domain rules. It also saves the event’s cover
    image if it was provided.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAsync` 方法继续使用 `eventManager` 类通过检查核心域规则来设置事件容量。如果提供了事件封面图像，它也会保存该图像。'
- en: Until that point, the `Event` object hasn’t been saved to the database. All
    the operations are performed on an in-memory object. The domain service doesn’t
    save changes to the database since it is the application layer’s responsibility
    to do this. If the domain service methods saved their changes, we would end up
    with one insert and three update operations in the database. With the current
    implementation, the `CreateAsync` method uses the `InsertAsync` method of the
    repository and saves the object at the end of the method with a single database
    operation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，`Event` 对象还没有保存到数据库中。所有操作都是在内存对象上执行的。域服务不会将更改保存到数据库中，因为这是应用层的责任。如果域服务方法保存了它们的更改，我们最终会在数据库中得到一个插入操作和三个更新操作。根据当前实现，`CreateAsync`
    方法使用存储库的 `InsertAsync` 方法，并在方法末尾通过单个数据库操作保存对象。
- en: As you see in the example application service definitions, application service
    methods use DTO classes to get data from the upper layer (typically, the presentation
    layer) and return data to the upper layer. The next section introduces DTO design
    considerations and best practices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在示例应用程序服务定义中看到的，应用程序服务方法使用DTO类从上层（通常是表示层）获取数据，并将数据返回到上层。下一节介绍了DTO设计考虑因素和最佳实践。
- en: Designing DTOs
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计DTO
- en: A DTO is a simple object used to transfer data between the presentation and
    the application layers. Let’s start by seeing the basic principles of designing
    DTO classes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: DTO是一个简单的对象，用于在表示层和应用层之间传输数据。让我们先看看设计DTO类的基本原则。
- en: Designing DTO classes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计DTO类
- en: 'There are some fundamental principles to follow while defining DTO classes,
    as outlined here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义DTO类时，有一些基本的原则需要遵循，如下所述：
- en: DTOs should not contain any business logic; they are just for data transfer.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTOs不应该包含任何业务逻辑；它们只是用于数据传输。
- en: DTO objects should be serializable because most of the time, they are transferred
    over the wire. Typically, they have a parameterless constructor, and all of their
    properties have public getters and setters.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTO对象应该是可序列化的，因为它们大多数时候都是通过网络传输的。通常，它们有一个无参构造函数，并且所有属性都有公共的getter和setter。
- en: DTO classes should not inherit from the entities or use entity types as their
    properties.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTO类不应该从实体继承，也不应该使用实体类型作为它们的属性。
- en: 'The following DTO class is used to store the data while adding a new session
    to an existing track of an event:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下DTO类用于在现有事件的轨迹中添加新会话时存储数据：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `AddSessionDto` class has no method, so it has no business logic. All its
    properties have public getters and setters. The `AddSessionDto` class does not
    define any constructor, so it has an implicit public parameterless constructor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSessionDto`类没有方法，因此没有业务逻辑。它所有的属性都有公共的getter和setter。`AddSessionDto`类没有定义任何构造函数，因此它有一个隐式的公共无参构造函数。'
- en: The `Title` and `Description` properties of the `AddSessionDto` class have validation
    attributes, such as `Required` and `StringLength`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSessionDto`类的`Title`和`Description`属性有验证属性，例如`Required`和`StringLength`。'
- en: The next section discusses validating input DTOs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节讨论了验证输入DTO。
- en: Validating input DTOs
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输入DTO
- en: 'There are a few ways to validate a DTO object when it is used as a parameter
    to an application service method, as outlined here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当DTO对象作为应用程序服务方法参数使用时，有几种方式可以验证DTO对象，如下所述：
- en: We can use data annotation attributes, such as `Required`, `StringLength`, and
    `Range`.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用数据注释属性，例如`Required`、`StringLength`和`Range`。
- en: We can implement an `IValidatableObject` interface for the DTO class and perform
    additional validation logic in the `Validate` method.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为DTO类实现`IValidatableObject`接口，并在`Validate`方法中执行额外的验证逻辑。
- en: We can use third-party libraries to validate a DTO object. For example, ABP
    integrates to the `FluentValidation` library to separate the validation logic
    from the DTO class and perform advanced validation logic.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用第三方库来验证DTO对象。例如，ABP集成了`FluentValidation`库，将验证逻辑从DTO类中分离出来，并执行高级验证逻辑。
- en: Whichever approach you follow (you can use all together for a DTO class), ABP
    automatically checks these validation rules and throws a validation exception
    in case of an invalid value. So, your application service method is always executed
    with a valid DTO object. See the *Validating user inputs* section of [*Chapter
    7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213), *Exploring Cross-Cutting Concerns,*
    for all the details of ABP’s validation infrastructure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您采用哪种方法（您可以为DTO类同时使用所有方法），ABP都会自动检查这些验证规则，并在值无效的情况下抛出验证异常。因此，您的应用程序服务方法始终使用有效的DTO对象执行。有关ABP验证基础设施的所有详细信息，请参阅[*第7章*](B17287_07_Epub_AM.xhtml#_idTextAnchor213)的*验证用户输入*部分，*探索横切关注点*。
- en: The validation logic on the DTO class (or in the `FluentValidation` validator
    class) should only be a formal validation. That means you can check if the given
    input is supplied and well formatted. However, it should not contain a domain
    validation. For example, do not try to check if the given start and end dates
    conflict with another session on the same track. Such validation logic should
    be implemented in the domain layer, typically in the entity or a domain service
    class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DTO 类（或 `FluentValidation` 验证器类中）上的验证逻辑应该是正式验证。这意味着你可以检查给定的输入是否提供并且格式正确。然而，它不应包含领域验证。例如，不要尝试检查给定的开始和结束日期是否与同一轨道上的另一个会话冲突。此类验证逻辑应在领域层实现，通常在实体或领域服务类中。
- en: Another common task with DTOs is mapping them to other objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与 DTO 相关的另一个常见任务是将其映射到其他对象。
- en: Object-to-object mapping
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象到对象映射
- en: We use entities inside the domain and application layers and use DTOs to communicate
    with the upper layers. This approach leads us to create DTO classes similar to
    entity classes and convert entity objects to DTO objects. If the entity class
    has a few properties, then creating a corresponding DTO object can be manually
    done by copying properties one by one. However, entity classes grow over time,
    and writing and maintaining a manual mapping code becomes tedious and error-prone.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在领域和应用层内部使用实体，并使用 DTO 与上层进行通信。这种方法使我们创建与实体类相似的 DTO 类，并将实体对象转换为 DTO 对象。如果实体类只有少量属性，则可以通过逐个复制属性手动创建相应的
    DTO 对象。然而，实体类会随着时间的推移而增长，编写和维护手动映射代码变得繁琐且容易出错。
- en: 'ABP Framework provides an `IObjectMapper` service that is used to convert similar
    objects to each other. See the following application service method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架提供了一个 `IObjectMapper` 服务，用于将相似的对象相互转换。请参阅以下应用程序服务方法：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method simply returns an `EventDto` object by converting it from the `Event`
    object using the `IObjectMapper` service. `EventDto` has a lot of properties,
    and manually creating it would result in a long code block. `IObjectMapper` is
    an abstraction and is implemented using the `AutoMapper` library when you create
    a new ABP solution. If you want to use the preceding code, you should first define
    the `AutoMapper` mapping configuration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地通过使用 `IObjectMapper` 服务将 `Event` 对象转换为 `EventDto` 对象来返回一个 `EventDto` 对象。`EventDto`
    有很多属性，手动创建它会导致代码块变长。`IObjectMapper` 是一个抽象，在创建新的 ABP 解决方案时使用 `AutoMapper` 库实现。如果你想要使用前面的代码，你应该首先定义
    `AutoMapper` 映射配置。
- en: Object-to-Object Mapping Documentation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对象到对象映射文档
- en: 'The topic of object-to-object mapping is not included in this book. However,
    we did use it in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044), *Step-By-Step
    Application Development,* while creating an example application. Please refer
    to ABP’s documentation to fully understand the object-to-object mapping system:
    [https://docs.abp.io/en/abp/latest/Object-To-Object-Mapping](https://docs.abp.io/en/abp/latest/Object-To-Object-Mapping).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对象到对象映射这一主题并未包含在本书中。然而，在创建示例应用程序时，我们确实在 [*第 3 章*](B17287_03_Epub_AM.xhtml#_idTextAnchor044)，*逐步应用开发*
    中使用了它。请参考 ABP 的文档以全面了解对象到对象映射系统：[https://docs.abp.io/en/abp/latest/Object-To-Object-Mapping](https://docs.abp.io/en/abp/latest/Object-To-Object-Mapping)。
- en: While using the object mapper is pretty simple, we should use it carefully.
    Object mapping libraries mostly rely on naming conventions. They automatically
    map same-named properties, while we can configure the mappings manually.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用对象映射器相当简单，但我们仍应谨慎使用。对象映射库主要依赖于命名约定。它们会自动映射同名属性，而我们可以手动配置映射。
- en: 'One possible problem may occur when you refactor entities but do not update
    the corresponding DTOs or the mapping code. The `AutoMapper` library has a concept
    named configuration validation. It validates the mapping configuration on the
    application startup and throws an exception if it detects a mapping configuration
    problem. I suggest enabling it for your application. See the `AutoMapper` documentation
    to learn about configuration validation: [https://docs.automapper.org/en/stable/Configuration-validation.html](https://docs.automapper.org/en/stable/Configuration-validation.html).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重构实体但未更新相应的 DTO 或映射代码时，可能会出现一个问题。`AutoMapper` 库有一个名为配置验证的概念。它在应用程序启动时验证映射配置，并在检测到映射配置问题时抛出异常。我建议为你的应用程序启用它。有关配置验证的更多信息，请参阅
    `AutoMapper` 文档：[https://docs.automapper.org/en/stable/Configuration-validation.html](https://docs.automapper.org/en/stable/Configuration-validation.html)。
- en: 'Object-to-object mapping is really useful when you map your entities to DTOs.
    However, do not map input DTOs to entities. There are some technical and design
    reasons behind this suggestion, as outlined here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将实体映射到 DTO 时，对象到对象的映射非常有用。然而，不要将输入 DTO 映射到实体。这个建议背后有一些技术和设计原因，如下所述：
- en: Do you remember the *Implementing entity constructors* section of the previous
    chapter? Entity classes typically have primary constructors to get the required
    properties and create a valid entity. Auto-mapping operations generally need an
    empty constructor on the target class, so the mapping fails.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还记得上一章的 *实现实体构造函数* 部分吗？实体类通常具有主构造函数来获取所需的属性并创建一个有效的实体。自动映射操作通常需要在目标类上有一个空构造函数，因此映射会失败。
- en: Some properties on the entities are designed with private setters. You should
    use entity methods to change these property values to apply some business rules.
    Directly copying their values from a DTO object may violate the business rules.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体上的一些属性设计为具有私有设置器。你应该使用实体方法来更改这些属性值以应用一些业务规则。直接从 DTO 对象复制它们的值可能会违反业务规则。
- en: You should carefully validate and process the user input instead of blindly
    mapping to the entities.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该仔细验证和处理用户输入，而不是盲目地将它们映射到实体上。
- en: The `CreateAsync` method explained in the *Implementing application services*
    section was a good example of creating an entity using an input DTO. It doesn’t
    map the DTO to the entity but uses a domain service to create a valid entity and
    set optional properties.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *实现应用程序服务* 节中解释的 `CreateAsync` 方法是使用输入 DTO 创建实体的一个好例子。它不将 DTO 映射到实体，而是使用领域服务创建一个有效的实体并设置可选属性。
- en: In the next section, we will discuss some design practices for DTOs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些 DTO 的设计实践。
- en: DTO design best practices
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DTO 设计最佳实践
- en: Creating DTOs seems simple at first—they are simple, indeed. However, once the
    application grows, you will have many DTO classes, and it becomes important to
    understand how to organize these classes. In the next sections, I will provide
    a few suggestions about DTOs to make your code base more maintainable and bug-free.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 DTO 在一开始看起来很简单——它们确实是简单的。然而，一旦应用程序增长，你将有许多 DTO 类，了解如何组织这些类变得很重要。在接下来的几节中，我将提供一些关于
    DTO 的建议，以使你的代码库更易于维护和更少出错。
- en: Do not define unused properties in input DTOs
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在输入 DTO 中定义未使用的属性
- en: No one defines an unused property in an input DTO, right? Unfortunately, this
    isn’t true. I have seen a lot of code bases with this problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 谁会在输入 DTO 中定义一个未使用的属性，对吧？不幸的是，事实并非如此。我见过很多代码库存在这个问题。
- en: A property in a DTO class that is not used in the application service method
    is a perfect way to confuse the developers using that application service method
    and lead to building a buggy code base.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序服务方法中未使用的 DTO 类属性是混淆使用该应用程序服务方法的开发者的完美方式，并可能导致构建有缺陷的代码库。
- en: A probable reason for an unused property in a DTO class is that it was used
    before, but the application service method was changed and the developer has forgotten
    to remove it. We should care about that and always remove unused properties. If
    you care about backward compatibility because you are not the one building the
    client application, then declare an `[Obsolete]` attribute on that property, document
    the breaking change, and try to preserve the old behavior if the value is provided.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DTO 类中未使用的属性的一个可能原因是，它曾经被使用过，但应用程序服务方法已更改，开发者忘记将其删除。我们应该关注这一点，并始终删除未使用的属性。如果你关心向后兼容性，因为你不是构建客户端应用程序的人，那么请在该属性上声明
    `[过时]` 属性，记录破坏性更改，并在提供值的情况下尝试保留旧行为。
- en: Having unused properties can be unavoidable if you violate the rule in the next
    section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你违反了下一节中的规则，未使用的属性可能是不可避免的。
- en: Do not reuse input DTOs
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要重用输入 DTO
- en: When you have too many application service methods, you may think that using
    some DTOs for multiple application service methods is a good idea to reduce the
    number of DTOs. However, if you do that, some properties will be used in some
    methods but not used in others.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有太多的应用程序服务方法时，你可能会认为使用一些 DTO 为多个应用程序服务方法服务是一个好主意，以减少 DTO 的数量。然而，如果你这样做，一些属性将在某些方法中使用，但在其他方法中则不会使用。
- en: It is a good practice to define a specialized input DTO for each application
    service method. Sometimes, it seems practical to reuse the same DTO class for
    two methods since they are almost the same. However, the application service methods
    will change over time, and the requirements will be different. Inheriting a DTO
    from another DTO is another way of reusing DTOs, but the problem is the same.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个应用服务方法定义一个专门的输入DTO是一个好的实践。有时，由于两个方法几乎相同，似乎重用相同的DTO类是实用的。然而，应用服务方法会随着时间的推移而变化，需求也会不同。从另一个DTO继承DTO是重用DTO的另一种方式，但问题仍然是相同的。
- en: 'Code duplication is a better practice than coupling use cases in many scenarios.
    See the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，代码重复比耦合用例是一个更好的实践。请看以下示例：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the `GetAsync` method returns an `EventDto` object that stores
    almost all of the event properties. The `CreateAsync` method reuses the same `EventDto`
    class. In general, reusing an output DTO as an input DTO is not good since some
    `EventDto` properties (such as `Id`, `UrlCode`, `RegisteredUserCount`, and `CreationTime`)
    are not expected to be sent by the client application on event creation but calculated
    on the server side. Finally, reusing the same `EventDto` class in the `UpdateEventTimeAsync`
    method is much worse since this method only uses the `Id`, `StartTime`, and `EndTime`
    properties.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`GetAsync`方法返回一个存储几乎所有事件属性的`EventDto`对象。`CreateAsync`方法重用了相同的`EventDto`类。一般来说，将输出DTO作为输入DTO重用并不好，因为一些`EventDto`属性（如`Id`、`UrlCode`、`RegisteredUserCount`和`CreationTime`）在事件创建时不应由客户端应用程序发送，而是在服务器端计算。最后，在`UpdateEventTimeAsync`方法中重用相同的`EventDto`类更糟糕，因为此方法仅使用`Id`、`StartTime`和`EndTime`属性。
- en: 'A true DTO design is shown in the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的DTO设计在以下示例中展示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve defined a separate DTO class for the `CreateAsync` and `UpdateEventTimeAsync`
    methods. In this way, any change in one DTO won’t affect the other methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`CreateAsync`和`UpdateEventTimeAsync`方法定义了单独的DTO类。这样，一个DTO的任何变化都不会影响其他方法。
- en: The design suggestions in the last two sections were for input DTOs. The next
    section explains the case for output DTOs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中的设计建议是针对输入DTO的。下一部分将解释输出DTO的情况。
- en: About output DTOs
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于输出DTO
- en: In practice, output DTOs are different than input DTOs. The *unused property*
    problem (of input DTOs) does not exist for output DTOs. Let’s try to understand
    why an unused property is a problem for an input DTO. Imagine that we are calling
    a method and setting a property on the input DTO. We expect that it is being processed
    by the method and change the behavior. We get confused if the method doesn’t use
    the property, and we don’t see any behavior difference, whatever we set for that
    property. If a method parameter (or property of the parameter) is there, it should
    work just as expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，输出DTO与输入DTO不同。输入DTO的*未使用属性*问题在输出DTO中不存在。让我们尝试理解为什么未使用的属性对输入DTO是一个问题。想象一下，我们正在调用一个方法并在输入DTO上设置一个属性。我们期望它正在被方法处理并改变行为。如果方法没有使用该属性，并且我们没有看到任何行为上的差异，无论我们为该属性设置了什么，我们都会感到困惑。如果一个方法参数（或参数的属性）存在，它应该像预期的那样工作。
- en: However, for output DTOs, that’s not the case. An application service may return
    more properties than the client currently needs. Thus, I mean that the application
    service method fills all the properties of an output DTO; if a property does exist
    in the DTO, it should always be filled regardless of whether it is being used
    by the client or not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于输出DTO，情况并非如此。一个应用服务可能返回比客户端当前需要的更多属性。因此，我的意思是应用服务方法填充了输出DTO的所有属性；如果DTO中存在某个属性，它应该始终被填充，无论客户端是否使用它。
- en: This approach has an advantage—when the client later needs those properties,
    we don’t need to change the service class, making it easier to extend the UI.
    This is especially useful if the client is not your application or you want to
    open your **application programming interface** (**API**) to third-party clients
    whose needs can be different.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个优点——当客户端稍后需要那些属性时，我们不需要更改服务类，这使得扩展UI更容易。如果客户端不是你的应用程序或者你希望将你的**应用程序编程接口**（**API**）向第三方客户端开放，他们的需求可能不同，这尤其有用。
- en: Since an output DTO may contain some properties that are not used by the client
    yet, we can reduce the number of output DTOs and reuse some DTO classes in multiple
    cases.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出DTO可能包含一些客户端尚未使用的属性，我们可以减少输出DTO的数量，并在多个情况下重用一些DTO类。
- en: 'See the following example application service definition:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例应用程序服务定义：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the methods on this example use the same output DTO class to represent an
    event, `EventDto`, while they get different input DTO objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，所有方法都使用相同的输出 DTO 类 `EventDto` 来表示事件，而它们获取不同的输入 DTO 对象。
- en: Performance Considerations
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Returning fine-tuned and minimal-output DTO objects can be needed for performance
    requirements, especially when returning large result sets. In such cases, you
    can define different DTO classes with the properties only needed for the related
    use cases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回经过微调和最小输出的 DTO 对象可能因性能要求而需要，尤其是在返回大量结果集时。在这种情况下，你可以定义不同的 DTO 类，只包含相关用例所需的属性。
- en: We’ve covered the fundamental building blocks for implementing DDD with ABP
    Framework. The next section demonstrates some examples to understand the roles
    and responsibilities of the layers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了使用 ABP 框架实现 DDD 的基本构建块。下一节将演示一些示例，以了解各层的角色和职责。
- en: Understanding the responsibilities of the layers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解各层的职责
- en: Separating your business logic into application and domain layers allows you
    to create multiple applications on the same domain, as explained in the *Dealing
    with multiple applications* section of [*Chapter 9*](B17287_09_Epub_AM.xhtml#_idTextAnchor300),
    *Understanding Domain-Driven Design*. Large systems typically have multiple applications
    and isolating the core domain from application-specific logic is a key principle
    to not mix the logic of different applications. Creating a separate application
    layer for each application makes it possible to design our application service
    methods best suited to different application requirements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的业务逻辑分离到应用层和领域层，允许你在同一领域上创建多个应用程序，如在第 9 章的 *处理多个应用程序* 部分中解释的，*理解领域驱动设计*。大型系统通常有多个应用程序，将核心领域与应用特定逻辑隔离是避免不同应用程序逻辑混合的关键原则。为每个应用程序创建一个单独的应用层，使我们能够设计最适合不同应用程序要求的应用服务方法。
- en: To successfully separate the application and domain layers, we should have a
    good understanding of each layer’s responsibilities. In the last three chapters,
    I have already mentioned these responsibilities while explaining the DDD building
    blocks. In the next sections, I will summarize these responsibilities to understand
    them better.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功地将应用层和领域层分离，我们应该对每一层的职责有良好的理解。在最后三章中，我已经在解释 DDD 构建块时提到了这些职责。在下一节中，我将总结这些职责，以便更好地理解它们。
- en: Authorizing users
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权用户
- en: Authorization is used to allow or prevent using a certain application functionality
    by a user (on a UI) or a client application (on a machine-to-machine communication).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 授权用于允许或阻止用户（在 UI 上）或客户端应用程序（在机器到机器通信中）使用某些应用程序功能。
- en: ABP provides a declarative way of checking user permissions with the `[Authorize]`
    attribute and an imperative way with the `IAuthorizationService` service. You
    can use these features to restrict access to desired functionalities in your application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 提供了使用 `[Authorize]` 属性进行声明性检查用户权限和通过 `IAuthorizationService` 服务进行命令性检查的方式。你可以使用这些功能来限制对应用程序中所需功能的访问。
- en: Authorization is the responsibility of the application layer and the upper layers
    (such as the presentation layer) because it highly depends on the clients and
    the users of the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是应用层和上层（如表示层）的责任，因为它高度依赖于客户端和应用程序的用户。
- en: For example, in the *EventHub* project, a user in the public web application
    can edit only their own events. However, an admin user in the admin application
    can edit any event without the ownership checking if they have the required permission.
    On the other hand, a background service may change an event’s state without any
    authorization rule. These applications use the same domain layer, hence the same
    domain rules, but implement different authorization rules. So, it is good not
    to include the authorization logic in the domain layer to make it reusable in
    different cases.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 *EventHub* 项目中，公共网络应用中的用户只能编辑自己的事件。然而，在管理应用中的管理员用户，如果他们拥有所需的权限，可以编辑任何事件而无需检查所有权。另一方面，后台服务可能在没有任何授权规则的情况下更改事件的状态。这些应用程序使用相同的领域层，因此相同的领域规则，但实现了不同的授权规则。因此，最好不要在领域层中包含授权逻辑，以便在不同情况下可重用。
- en: Controlling the transaction
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制事务
- en: The UoW system’s responsibility is to create a transaction scope for a use case
    (typically, a web request) and ensure that all the changes done in that use case
    are committed together. The UoW system was covered in the *Understanding the UoW
    system* section of [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working
    with the Data Access Infrastructure*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: UoW系统的责任是为用例（通常是Web请求）创建事务范围，并确保在该用例中进行的所有更改都一起提交。UoW系统在[*第6章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)中*与数据访问基础设施一起工作*的*理解UoW系统*部分中进行了介绍。
- en: The scope of a use case is an application service method. An application service
    method may work with multiple domain services and aggregates and may make changes
    on the aggregates. The only way to ensure that all changes are committed together
    is to control the UoW system at the application service level, in the application
    layer. So, a UoW is an application-layer concept.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 用例的范围是应用程序服务方法。应用程序服务方法可能与多个领域服务和聚合一起工作，并可能在聚合上做出更改。确保所有更改一起提交的唯一方法是控制应用程序层中的应用程序服务级别的UoW系统。因此，UoW是一个应用层概念。
- en: Validating the user input
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: 'As stated in the *Validating user inputs* section of [*Chapter 7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213),
    *Exploring Cross-Cutting Concerns*, a typical application has three levels of
    validation, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第7章*](B17287_07_Epub_AM.xhtml#_idTextAnchor213)中*探索横切关注点*部分的*验证用户输入*所述，一个典型应用程序有三个验证级别，如下所示：
- en: '*Client-side validation* is used to pre-validate the user input before sending
    data to the server. This type of validation is the responsibility of the presentation
    layer.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端验证*用于在将数据发送到服务器之前预先验证用户输入。此类验证是表示层的责任。'
- en: '*Server-side validation* is performed by the server to prevent incomplete,
    badly formatted, or malicious requests. We generally use data annotation attributes
    and other functionalities to validate DTO objects. Such validation is the responsibility
    of the application layer.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器端验证*由服务器执行，以防止不完整、格式错误或恶意请求。我们通常使用数据注释属性和其他功能来验证DTO对象。此类验证是应用层的责任。'
- en: '*Business validation* is also performed in the server, implements your business
    rules, and keeps your business data consistent. Business validation is mostly
    done in the domain layer to force the same business rules in every application.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*业务验证*也在服务器上执行，实现您的业务规则，并保持业务数据的一致性。业务验证通常在领域层执行，以确保每个应用程序中都有相同的业务规则。'
- en: ABP provides good infrastructure and gracefully integrates to ASP.NET Core services
    to easily perform formal validation logic. You can implement business validation
    rules and constraints in the aggregate constructors, methods, and domain services,
    as explained in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316), *DDD
    – The Domain Layer*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ABP提供了良好的基础设施，并优雅地集成到ASP.NET Core服务中，以便轻松执行正式验证逻辑。您可以在聚合构造函数、方法和领域服务中实现业务验证规则和约束，如[*第10章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)中所述，*领域驱动设计
    – 领域层*。
- en: Working with the current user
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与当前用户一起工作
- en: ABP’s `ICurrentUser` service is used to get information about the current user.
    The current user logic requires a stateful session system that stores user information
    and makes it available in every web request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ABP的`ICurrentUser`服务用于获取当前用户的信息。当前用户逻辑需要一个有状态的会话系统，该系统存储用户信息并在每个Web请求中使其可用。
- en: For ASP.NET Core applications, ABP uses the current principle that is based
    on the authentication ticket. An authentication ticket is created when the user
    logs in to the application. It is saved in a cookie to read in subsequent requests.
    It can be stored in local storage for a **single-page application** (**SPA**)
    and sent to the server in the **HyperText Transfer Protocol** (**HTTP**) header
    for every request.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ASP.NET Core应用程序，ABP使用基于身份验证票据的当前原则。当用户登录应用程序时创建身份验证票据。它保存在cookie中，以便在后续请求中读取。对于**单页应用程序**（**SPA**），它可以存储在本地存储中，并在每个请求的**超文本传输协议**（**HTTP**）头中发送到服务器。
- en: The session/current user is a concept that is typically implemented in the presentation
    layer. It is usable in the application layer since the application layer is designed
    to be used by the presentation layer, so it can assume that there is a *current
    user* in the current context. However, the domain layer should be designed as
    independent from any application, so it should not work with the current user.
    In some applications, such as a background service or an integration application,
    there may not be a user at all.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 会话/当前用户是一个通常在表示层中实现的概念。它可以在应用层中使用，因为应用层是为了被表示层使用而设计的，所以它可以假设在当前上下文中存在一个 *当前用户*。然而，领域层应该设计为独立于任何应用，因此它不应该与当前用户一起工作。在某些应用程序中，例如后台服务或集成应用程序，可能根本不存在用户。
- en: 'The following application service method, from the *EventHub* project, is used
    to join a given organization by the current user:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下来自 *EventHub* 项目的应用程序服务方法，用于当前用户加入指定的组织：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First of all, this method is authorized. So, it is guaranteed that the method
    is called by a user that has already logged in to the application and `CurrentUser.GetId()`
    returns a valid user ID.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种方法是经过授权的。因此，可以保证该方法是由已经登录到应用程序的用户调用的，并且 `CurrentUser.GetId()` 返回一个有效的用户
    ID。
- en: We are not accepting the user’s ID as a method parameter; otherwise, any authenticated
    user could make any user a member of any organization. But we want every user
    to be able to join the organization themselves.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不接受用户的 ID 作为方法参数；否则，任何经过身份验证的用户都可以使任何用户成为任何组织的成员。但我们希望每个用户都能自己加入组织。
- en: 'We get the organization and user aggregates from the repositories and delegate
    the work to the domain service (`organizationMembershipManager`). The domain service,
    in this way, is independent of the current user concept and also more reusable:
    it can work with any user, not only with the current one.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从存储库中获取组织和用户聚合，并将工作委托给领域服务（`organizationMembershipManager`）。这样，领域服务就独立于当前用户概念，并且更具可重用性：它可以与任何用户一起工作，而不仅仅是当前用户。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve learned how to properly implement the application services
    and design the DTOs. I’ve covered DTO design in detail, such as validating input
    DTOs and mapping entities to DTOs, and provided suggestions based on best practices
    and my experience.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何正确实现应用程序服务和设计 DTO。我详细介绍了 DTO 设计，例如验证输入 DTO 和将实体映射到 DTO，并基于最佳实践和我的经验提供了建议。
- en: We’ve learned that mixing the responsibilities of the layers makes layering
    meaningless. We’ve investigated some fundamental responsibilities to understand
    at which layer we should implement these responsibilities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，混合层的责任会使分层变得没有意义。我们已经调查了一些基本责任，以了解我们应该在哪个层实现这些责任。
- en: As we’re at the end of this chapter, we’ve completed the third part of the book.
    The purpose of this part was to demonstrate how you can implement **domain-driven
    design** (**DDD**) building blocks with ABP Framework. I’ve provided rules, best
    practices, and suggestions to make your code base more maintainable when you follow
    them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们已经完成了本书的第三部分。这一部分的目的在于展示如何使用 ABP 框架实现 **领域驱动设计**（**DDD**）的构建块。我提供了规则、最佳实践和建议，以便你在遵循它们时可以使代码库更易于维护。
- en: The next part of the book will explore the UI and API development with ABP Framework.
    In the next chapter, we will learn the architectural structure and the fundamental
    features of the ABP Framework MVC/Razor Pages UI.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本书下一部分将探讨使用 ABP 框架进行 UI 和 API 开发。在下一章中，我们将学习 ABP 框架 MVC/Razor Pages UI 的架构结构和基本功能。
