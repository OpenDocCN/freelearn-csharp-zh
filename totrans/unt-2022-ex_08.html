<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor096" class="pcalibre1 pcalibre calibre6"/>5</h1>
<h1 id="_idParaDest-95" class="calibre5"><a id="_idTextAnchor097" class="pcalibre1 pcalibre calibre6"/>Continuing the Adventure Game</h1>
<p class="calibre3">In <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, we covered the larger scope of the adventure game by extending the <strong class="bold">Game Design Document</strong> (<strong class="bold">GDD</strong>) for <a id="_idIndexMarker515" class="pcalibre1 pcalibre calibre6"/>the game and explored the level and environment design while also considering new principles to guide the player. We also imported and prepped artwork for use with additional 2D tooling that will bring the game to life.</p>
<p class="calibre3">We also challenged the player by exploring and adding moving platforms and interactive elements in the level design, immersing the player with a parallax effect on a layered background, and optimizing the sprite draw calls to keep things performant.</p>
<p class="calibre3">With the game level and environment established, we can now move on to creating our player character using the 2D Animation package.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre17">
<li class="calibre15">Setting up the player character with PSD Importer</li>
<li class="calibre15">Using an Input Action Map</li>
<li class="calibre15">Moving the player with a player controller script</li>
<li class="calibre15">Animating the character with Mecanim</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to set up a 2D sprite-based character rigged for animation and driven by player input. You’ll also be able to assign and transition between different animations required for the player’s current state.</p>
<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor098" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter and use the same artwork that was created for the project in this book, download the adventure game 2D art assets from the following GitHub link: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets</a>.</p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop or use a graphics program that can export layered PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).</p>
<p class="calibre3">You can download the complete project from GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor099" class="pcalibre1 pcalibre calibre6"/>Setting up the player character with PSD Importer</h1>
<p class="calibre3">Creating our player<a id="_idIndexMarker516" class="pcalibre1 pcalibre calibre6"/> character for the 2D adventure game will be a multi-step process. In this section, we’ll cover all the steps required to make an animated 2D character controlled by the player.</p>
<p class="calibre3">We’ll start with the import settings for the artwork and setting up the character bones that will allow us to animate. You’ll repeat these actions many times throughout a project while importing artwork and assets. <strong class="bold">PSD Importer</strong> is an<a id="_idIndexMarker517" class="pcalibre1 pcalibre calibre6"/> asset importer that can work with multilayered PSB/PSD files to create a Prefab of sprites based on the source layers.</p>
<p class="calibre3">The import options allow Unity to generate both a sprite sheet and a character rig that arranges the sprites according to their original position and layer order, significantly simplifying the creation of a sprite-based animated character.</p>
<p class="calibre3">Let’s go ahead and import the artwork for the player character. Here, we will set up the source file so that it uses PSD Importer to create the actor (the Prefab created based on the multilayered Photoshop file is<a id="_idIndexMarker518" class="pcalibre1 pcalibre calibre6"/> called an <strong class="bold">actor</strong>):</p>
<ol class="calibre14">
<li class="calibre15">Create a new folder in the <code>Assets/Sprites/Character</code> directory.</li>
<li class="calibre15">Import <code>PlayerCharacter1.psd</code> into the newly created folder.</li>
<li class="calibre15">Select the imported file and, in the <strong class="bold">Inspector</strong> window, change <strong class="bold">Importer</strong> to <strong class="bold">UnityEditor.U2D.PSD.PSDImporter</strong> in the dropdown list.</li>
</ol>
<p class="calibre3"><strong class="bold">PSD Importer</strong> provides two new options that appear as tabs once it’s selected as the importer:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Settings</strong>: This is where you will set the properties for how the file will be imported. The fields under <strong class="bold">Settings</strong> are similar to the default texture importer, with the addition of the <strong class="bold">Layer Import</strong> (when <strong class="bold">Texture Type</strong> is set to <strong class="bold">Multiple</strong>) and <strong class="bold">Character </strong><strong class="bold">Rig</strong> sections</li>
<li class="calibre15"><strong class="bold">Layer Management</strong>: This is where you can customize which layers from the Photoshop file are imported</li>
</ul>
<p class="calibre3">With the default import settings, we are already in good shape to continue with the player character setup since we’ll be using all the layers. The importer will keep the layer positions and sorting order from Photoshop so that our character sprites are arranged correctly for our actor.</p>
<p class="calibre3">We won’t have to recreate the player character in Unity from the individual sprites that make up the character – arms, torso, legs, head, and so on. So, we are ready for the next step – rigging the<a id="_idIndexMarker519" class="pcalibre1 pcalibre calibre6"/> character by adding bones.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Preparing and importing artwork: <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml</a>.</p>
<p class="callout">PSD Importer Inspector properties: <a href="https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml</a>.</p>
<h2 id="_idParaDest-98" class="calibre8"><a id="_idTextAnchor100" class="pcalibre1 pcalibre calibre6"/>Rigging the actor</h2>
<p class="calibre3">With the actor (the player <a id="_idIndexMarker520" class="pcalibre1 pcalibre calibre6"/>character PSD file) still <a id="_idIndexMarker521" class="pcalibre1 pcalibre calibre6"/>selected in the <strong class="bold">Project</strong> window, click the <strong class="bold">Open Sprite Editor</strong> button in the <strong class="bold">Inspector</strong> window. The default view is the sliced sprite shape representing our Photoshop layers.</p>
<p class="calibre3">Don’t worry – as I said, we won’t have to work with our character in a dismembered way, as shown in <em class="italic">Figure 5</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 5.1 – Actor sprite sheet" src="img/B18347_05_1.jpg" class="calibre65"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Actor sprite sheet</p>
<p class="calibre3">If the artwork is shown with the individual sprites representing the Photoshop layers, then we need to switch to <strong class="bold">Sprite Skinning Editor</strong> (part of the 2D Animation package), where we’ll continue setting up the animation rig for the actor.</p>
<p class="calibre3">From the <strong class="bold">Sprite Editor</strong> dropdown, select <strong class="bold">Skinning Editor</strong> – the sprites should now represent the character, as seen in the original Photoshop source file. Sweet!</p>
<p class="calibre3">The entire workflow of <a id="_idIndexMarker522" class="pcalibre1 pcalibre calibre6"/>setting up the actor for <a id="_idIndexMarker523" class="pcalibre1 pcalibre calibre6"/>animations looks like this:</p>
<ol class="calibre14">
<li class="calibre15"><strong class="bold">Create a rig</strong>: A skeleton<a id="_idIndexMarker524" class="pcalibre1 pcalibre calibre6"/> made up of individual bones.</li>
<li class="calibre15"><strong class="bold">Generate mesh geometry</strong>: This will influence the sprite’s position, rotation, and, optionally, deformation.</li>
<li class="calibre15"><strong class="bold">Adjust bone influence</strong>: Change the attributes of a sprite to specify which bone or bones affect it.</li>
<li class="calibre15"><strong class="bold">Adjust weights</strong>: How much a bone, or bones, influence a given sprite (the entire sprite, or just part(s) of it).</li>
<li class="calibre15"><strong class="bold">Preview pose</strong>: Test, test, and test again regarding the rig and sprite bone, geometry, and weight assignments until everything is looking and working correctly when bones are moved or rotated; this is a cyclical process.</li>
<li class="calibre15"><strong class="bold">Inverse kinematics</strong> (<strong class="bold">IK</strong>): You can apply IK to a chain of bones to automatically calculate positions<a id="_idIndexMarker525" class="pcalibre1 pcalibre calibre6"/> and rotations that make it much easier to animate the actor’s limbs.</li>
</ol>
<p class="callout-heading">Additional reading | Inverse kinematics (IK)</p>
<p class="callout">IK is a technique that’s used in computer animation and robotics to control the position and orientation of limbs. It calculates the joint angles required to place the end effector in a given position and orientation – endpoints such as hands and feet. It’s useful for creating natural and realistic human motion, especially for complex poses.</p>
<p class="callout">You can read more at <a href="https://docs.unity3d.com/Manual/InverseKinematics.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/InverseKinematics.xhtml</a>.</p>
<ol class="calibre14">
<li value="7" class="calibre15"><strong class="bold">Animate</strong>: Create animations<a id="_idIndexMarker526" class="pcalibre1 pcalibre calibre6"/> for the actor’s different gameplay states, such as idle, walking, jumping, and attacking.</li>
</ol>
<p class="calibre3">Game development is <a id="_idIndexMarker527" class="pcalibre1 pcalibre calibre6"/>a multidisciplinary <a id="_idIndexMarker528" class="pcalibre1 pcalibre calibre6"/>craft that combines both technical and artistic skills. Creating a character rig with individual bones to affect individual sprites combines both skill sets. Thankfully, the rigging process is non-destructive, so we’ll be able to go back and make changes at any time to adjust and fix anything that doesn’t seem to be working well or look correct.</p>
<p class="calibre3">The general creation process we’ll follow when creating the rig is to start with the pelvic bone – this bone will represent the <em class="italic">true center</em> of the character. Moving or rotating this bone will affect all child bones in the rig, moving the entire actor.</p>
<p class="calibre3">This first bone we’ll create can be seen in <em class="italic">Figure 5</em><em class="italic">.2</em> as the small red bone pointing upwards in the pelvic area of the character. In the bone hierarchy (as shown in the <code>bone_1</code>, is the root bone.</p>
<p class="calibre3">Let’s create our bones! Perform the following steps to develop the whole character rig:</p>
<ol class="calibre14">
<li class="calibre15">We should already be in <strong class="bold">Skinning Editor</strong>; if not, select it from the <strong class="bold">Sprite </strong><strong class="bold">Editor</strong> dropdown.</li>
<li class="calibre15">To view the hierarchy of the bones being created (or to manage the visibility of the sprites you’re working with), toggle on the <strong class="bold">Visibility</strong> panel (the top right of the window next to <strong class="bold">Revert</strong> and <strong class="bold">Apply</strong>).</li>
<li class="calibre15">Now, under the <strong class="bold">Bones</strong> section (the left-hand side of the window), select the <strong class="bold">Create Bone</strong> button – your cursor should now have a red dot at the tip.</li>
<li class="calibre15">Start at the character’s pelvis and click to start creating the root bone. Click again slightly above the first click point to make the small red root bone – refer to <em class="italic">Figure 5</em><em class="italic">.2</em> for the general size and orientation.</li>
<li class="calibre15">Continue by clicking again to create a bone that will represent the lower portion of the torso (yellow bone) and again to make a bone for the upper part of the torso (green bone); this will allow us to bend the character’s torso (for example, arching forward or backward).</li>
<li class="calibre15">Moving up the spine, create two additional bones – a small bone for the neck and another for the head (refer to <em class="italic">Figure 5</em><em class="italic">.2</em>).</li>
<li class="calibre15">Right-click or press the <em class="italic">Esc</em> key to stop creating bones.</li>
</ol>
<p class="calibre3">Our actor now has a<a id="_idIndexMarker529" class="pcalibre1 pcalibre calibre6"/> spine (if you’ll forgive the pun). Creating<a id="_idIndexMarker530" class="pcalibre1 pcalibre calibre6"/> the limbs will follow a similar process, but the critical difference in creating bones for limbs is to first select the bone that will parent the limb bones. Follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">With <strong class="bold">Create Bone</strong> still selected, click on the upper torso bone (green). You should now see a semi-transparent bone coming from the bone that was just clicked (this indicates parenting; you can also see this in the <strong class="bold">Visibility</strong> window’s <strong class="bold">Bone </strong><strong class="bold">Hierarchy</strong> view).</li>
<li class="calibre15">We’ll start by creating a limb for the character’s left arm (the arm behind the torso), so click where the left shoulder joint should be to begin making bones.</li>
<li class="calibre15">Note that to make placing bones easier for sprites behind others, you can toggle the visibility off for the sprites in front by using the <strong class="bold">Visibility</strong> panel.</li>
<li class="calibre15">Keep clicking to create bones for the upper arm, lower arm, and hand (refer to <em class="italic">Figure 5</em><em class="italic">.2</em>).</li>
<li class="calibre15">Right-click or press the <em class="italic">Esc</em> key to stop creating bones.</li>
<li class="calibre15">Continue creating the other limb bones for the right arm and both legs by selecting the parent bone again – for the legs, parent to the pelvic bone (the red root bone we started creating the rig from).</li>
</ol>
<p class="calibre3">Your actor’s entire skeleton<a id="_idIndexMarker531" class="pcalibre1 pcalibre calibre6"/> rig should look similar<a id="_idIndexMarker532" class="pcalibre1 pcalibre calibre6"/> to the rig shown in <em class="italic">Figure 5</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 5.2 – The actor rig and Auto Geometry with Weights" src="img/B18347_05_2.jpg" class="calibre66"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The actor rig and Auto Geometry with Weights</p>
<p class="calibre3">If you want to have your bones named more intelligibly – making it easier for you to know which bones you are working with – you can easily rename them while using the <code>bone_14</code> to <code>foot_right</code>).</p>
<p class="calibre3">Creating the rig is just the first step in making a fully animatable character. Let’s take the next step by assigning the sprite’s mesh geometry to the rig’s bones – as you continue to work with the rig, it <a id="_idIndexMarker533" class="pcalibre1 pcalibre calibre6"/>may help to know that<a id="_idIndexMarker534" class="pcalibre1 pcalibre calibre6"/> the sprite mesh geometry a bone influences will be the same color as the bone.</p>
<h2 id="_idParaDest-99" class="calibre8"><a id="_idTextAnchor101" class="pcalibre1 pcalibre calibre6"/>Generating the sprite mesh geometry</h2>
<p class="calibre3">Perform the following<a id="_idIndexMarker535" class="pcalibre1 pcalibre calibre6"/> steps to<a id="_idIndexMarker536" class="pcalibre1 pcalibre calibre6"/> create the sprite mesh geometry and apply default bone weights that will influence the sprites that we’ll start with:</p>
<ol class="calibre14">
<li class="calibre15">First, double-click in the checkered area to unselect all sprites (noting that this action is not apparent).</li>
<li class="calibre15">Select the <strong class="bold">Auto Geometry</strong> button under the <strong class="bold">Geometry</strong> section (the left-hand side of the window).</li>
<li class="calibre15">In the <strong class="bold">Geometry</strong> panel at the window’s bottom-right section, ensure <strong class="bold">Weights</strong> is enabled; this will automatically generate bone weights along with the mesh geometry, saving a step.</li>
<li class="calibre15">Finish up by clicking the <strong class="bold">Generate For All </strong><strong class="bold">Visible</strong> button.</li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">2D Animation | Editor tools and shortcuts: <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml</a>.</p>
<p class="calibre3">After clicking the <strong class="bold">Generate For All Visible</strong> button for the geometry, all your sprites will have taken on coloring from the associated bones. You’ll notice that it does not look like the solid colors seen in <em class="italic">Figure 5</em><em class="italic">.2</em> since the generated weights were distributed across adjacent bones; instead, the coloring will be a gradient of the adjoining bone colors.</p>
<p class="calibre3">This is due to both the overlapping sprites and Unity wanting to blend the sprite deformation across the bones, which is desired in some cases. We’ll be addressing this shortly in the <em class="italic">Editing sprite bone weights</em> section for the torso and neck sprites. For the remainder of the sprites, we only want one bone to influence a sprite (represented by the solid color) for<a id="_idIndexMarker537" class="pcalibre1 pcalibre calibre6"/> this <a id="_idIndexMarker538" class="pcalibre1 pcalibre calibre6"/>particular character.</p>
<p class="calibre3">We’ll fix this by adjusting the bone influence for each sprite.</p>
<h2 id="_idParaDest-100" class="calibre8"><a id="_idTextAnchor102" class="pcalibre1 pcalibre calibre6"/>Adjusting the bone influence</h2>
<p class="calibre3">The process we’re <a id="_idIndexMarker539" class="pcalibre1 pcalibre calibre6"/>going to follow is<a id="_idIndexMarker540" class="pcalibre1 pcalibre calibre6"/> to remove – or set – bones in the <strong class="bold">Bone Influences</strong> property of the sprites. This will ensure that our character’s sprites are not deformed or distorted while positioned or rotated by only assigning a single bone.</p>
<p class="calibre3">For a different style character, we may very well want a single sprite to be deformed by multiple bones (as we will do shortly with the torso and neck), but that is not what we want for the style character we’re building here.</p>
<p class="calibre3">Perform the following steps to assign the correct bone influence for all of the sprites (again, except for the torso and neck):</p>
<ol class="calibre14">
<li class="calibre15">Select the <strong class="bold">Bone Influence</strong> button under the <strong class="bold">Weights</strong> section (the left-hand side of the window).</li>
<li class="calibre15">Double-click on a sprite. For example, in <em class="italic">Figure 5</em><em class="italic">.3</em>, we’ll double-click on the <em class="italic">wing</em> for the right foot.<p class="calibre3">The panel in the bottom right of the window will now show the selected sprite and the bones influencing it.</p></li>
<li class="calibre15">Since we only want one bone to influence the sprite, we’ll select <code>bone_13</code> (the yellow bone) in the list and then click the minus (<strong class="bold">-</strong>) button on the small tab below the list to remove it.<p class="calibre3">The sprite will turn the same color as the remaining assigned bone, which is green in this case, as seen in <em class="italic">Figure 5</em><em class="italic">.3</em>:</p></li>
</ol>
<div><div><img alt="Figure 5.3 – Bone Influence editing" src="img/B18347_05_3.jpg" class="calibre66"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Bone Influence editing</p>
<p class="calibre3">Note that if there is more than one bone to remove, you can select multiple bones by holding the <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> key down while clicking and then clicking the minus (<strong class="bold">-</strong>) button.</p>
<p class="calibre3">This workflow <a id="_idIndexMarker541" class="pcalibre1 pcalibre calibre6"/>was for assigning a single<a id="_idIndexMarker542" class="pcalibre1 pcalibre calibre6"/> bone to a sprite. Next, we’ll learn how to use multiple bones to influence the deformation of a sprite.</p>
<h2 id="_idParaDest-101" class="calibre8"><a id="_idTextAnchor103" class="pcalibre1 pcalibre calibre6"/>Editing sprite bone weights</h2>
<p class="calibre3">We’ll use two<a id="_idIndexMarker543" class="pcalibre1 pcalibre calibre6"/> weight tools<a id="_idIndexMarker544" class="pcalibre1 pcalibre calibre6"/> to assign the bones and adjust the weight influence each bone has over the sprite: <strong class="bold">Weight Slider</strong> and <strong class="bold">Weight Brush</strong>.</p>
<p class="calibre3">We’ll start with <strong class="bold">Weight Slider</strong> to adjust the overall influence of the bones and then perform any fine-tuning with <strong class="bold">Weight Brush</strong>.</p>
<p class="calibre3">The <strong class="bold">Auto Weights</strong> generation may have already performed an excellent job but let’s examine the results and make some adjustments, starting with the neck sprite:</p>
<ol class="calibre14">
<li class="calibre15">Double-click on the neck sprite (note that you can use the mouse scroll wheel to zoom in on a sprite to work with it).</li>
<li class="calibre15"><strong class="bold">Auto Weights</strong> assigned three bones with influence over the neck sprite, so this sprite should have a color gradient representing the color of the three bones: the (green) upper torso, (cyan) neck, and (blue) head bone (see <em class="italic">Figure 5</em><em class="italic">.4</em>).</li>
<li class="calibre15">Select the <strong class="bold">Weight Slider</strong> button under the <strong class="bold">Weights</strong> section (the left-hand side of the window).</li>
<li class="calibre15">In the <strong class="bold">Weight Slider</strong> panel in the window’s lower-right corner, you can now adjust the amount of influence a selected bone has over the sprite; drag the <strong class="bold">Amount</strong> slider <a id="_idIndexMarker545" class="pcalibre1 pcalibre calibre6"/>left or right <a id="_idIndexMarker546" class="pcalibre1 pcalibre calibre6"/>to increase or decrease the influence.</li>
<li class="calibre15">Preview the effect of weight changes to see how the mesh deforms by rotating the bones:<p class="calibre3">You can rotate and move bones by simply clicking and dragging on them (the mouse cursor will show a rotate or move icon, depending on where you are hovering on the bone). Adjust the <strong class="bold">Weight Slider</strong> amount until you get overall pleasing results – this operation is a lot more artistic than technical:</p></li>
</ol>
<div><div><img alt="Figure 5.4 – Editing weights with Weight Brush" src="img/B18347_05_4.jpg" class="calibre67"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Editing weights with Weight Brush</p>
<p class="calibre3">You may find it challenging to get good results using <strong class="bold">Weight Slider</strong> alone. In this case, continue<a id="_idIndexMarker547" class="pcalibre1 pcalibre calibre6"/> to fine-tune<a id="_idIndexMarker548" class="pcalibre1 pcalibre calibre6"/> the bone influence for any problem areas using <strong class="bold">Weight Brush</strong>.</p>
<ol class="calibre14">
<li value="6" class="calibre15">With the sprite still selected, select the <strong class="bold">Weight Brush</strong> button under the <strong class="bold">Weights</strong> section (the left-hand side of the window).</li>
<li class="calibre15">Click on the bone you want to paint weights for.</li>
<li class="calibre15">You can now adjust the <strong class="bold">Weight Brush</strong> properties in the <strong class="bold">Weight Brush</strong> panel in the window’s lower-right corner or start painting weights. The sprite mesh geometry will update in real time as you paint.</li>
<li class="calibre15">Continue to rotate the bones by hovering your mouse over the bone to show the rotate icon. Then, click and drag to rotate the bone to test the weight painting and adjust it until you’ve achieved the desired results.</li>
</ol>
<p class="calibre3">Note that you can undo bone rotations using <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">Z</em>. If you’ve made many bone rotations and aren’t sure how much influence is being applied, then you can use the <strong class="bold">Reset Pose</strong> button under the <strong class="bold">Pose</strong> section (the top-left corner of the window) to start over.</p>
<p class="calibre3">Continue to repeat this process for the actor’s torso. Once you’re finished with the torso, this is probably a great time to think about saving your work. Use the <strong class="bold">Apply</strong> button in the toolbar on the right-hand side.</p>
<p class="calibre3">When you’re relatively satisfied with the bone weights and want to see how things are progressing, you can do some pose tests! Doing some pose tests allows you to test the range of motion and see if the sprites are associated with only the correct bones that influence the sprite weights without undesirable distortion. This provides you with the first indication of how<a id="_idIndexMarker549" class="pcalibre1 pcalibre calibre6"/> the character <a id="_idIndexMarker550" class="pcalibre1 pcalibre calibre6"/>may look when animated.</p>
<p class="calibre3"><em class="italic">Figure 5</em><em class="italic">.5</em> represents an example of a test pose for the actor:</p>
<div><div><img alt="Figure 5.5 – Pose test for the actor" src="img/B18347_05_5.jpg" class="calibre68"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Pose test for the actor</p>
<p class="calibre3">Being able to pose our character is great, but for the limbs, in particular, it can be time-consuming and challenging to get good results by rotating all the bones individually. Thankfully, there <a id="_idIndexMarker551" class="pcalibre1 pcalibre calibre6"/>is a <a id="_idIndexMarker552" class="pcalibre1 pcalibre calibre6"/>better way – using <strong class="bold">IK</strong>.</p>
<h2 id="_idParaDest-102" class="calibre8"><a id="_idTextAnchor104" class="pcalibre1 pcalibre calibre6"/>Setting up inverse kinematics (IK)</h2>
<p class="calibre3">We’ve now <a id="_idIndexMarker553" class="pcalibre1 pcalibre calibre6"/>finished<a id="_idIndexMarker554" class="pcalibre1 pcalibre calibre6"/> working with <strong class="bold">Skinning Editor</strong> and will continue working with the actor in the scene to add IK. So, let’s create a Prefab from the actor for our player character:</p>
<ol class="calibre14">
<li class="calibre15">Drag the <code>PlayerCharacter1</code> asset from the <strong class="bold">Project</strong> window into the <strong class="bold">Hierarchy</strong> window or <strong class="bold">Scene</strong> view (optionally, you can create a new empty scene to work in).</li>
<li class="calibre15">Parent the actor to a new empty GameObject and name it <code>Player</code>.</li>
<li class="calibre15">Then, drag the GameObject into the <code>Assets/Prefabs</code> folder to create the Prefab.</li>
</ol>
<p class="calibre3">Since we’ll be using an IK setup to position our actor for animation, we’ll want to change the actor’s rig to make posing the limbs – in particular, the legs – much better. We could have done this when we first created the actor’s rig, but it’s easier to show the reason for this change while implementing IK, and it shows that we can go back and make changes to the bone structure at any time and make corrections where necessary.</p>
<p class="calibre3">Next, we’ll be adding a new root bone to the rig using the same <strong class="bold">Create Bone</strong> workflow we used to create the actor’s complete skeleton rig:</p>
<ol class="calibre14">
<li class="calibre15">Start a new bone at the feet of the actor and name it <code>root_bone</code>.</li>
<li class="calibre15">Change the color to gray (just as an indication to us that no sprites are being influenced by it).</li>
<li class="calibre15">Now, click and drag the existing rig (<code>bone_1</code>) to parent it to the new root bone, as shown in <em class="italic">Figure 5</em><em class="italic">.6</em>:</li>
</ol>
<div><div><img alt="Figure 5.6 – Adding root_bone for IK and the parent existing rig" src="img/B18347_05_6.jpg" class="calibre69"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Adding root_bone for IK and the parent existing rig</p>
<p class="calibre3">Be patient with me – this<a id="_idIndexMarker555" class="pcalibre1 pcalibre calibre6"/> will all make<a id="_idIndexMarker556" class="pcalibre1 pcalibre calibre6"/> sense in a bit when we add <strong class="bold">IK Limb Solvers</strong> for the legs.</p>
<h3 class="calibre10">Adding IK Solvers</h3>
<p class="calibre3">We will make IK-constrained<a id="_idIndexMarker557" class="pcalibre1 pcalibre calibre6"/> limbs for the arms and legs, starting with the right arm (the arm in front of the actor).</p>
<p class="calibre3">First, let’s add GameObjects that act as our IK Effectors (the transform the IK Solver solves for) and work in tandem with the limb solver’s Target:</p>
<ol class="calibre14">
<li class="calibre15">Select the forearm bone of the arm in front of the character’s torso – <code>bone_7</code> in my case.</li>
<li class="calibre15">Right-click on it in the <strong class="bold">Inspector</strong> window and click <strong class="bold">Create Empty</strong> to add a child GameObject – this will make the new object a sibling of the hand bone.</li>
<li class="calibre15">Rename it <code>IK Effector</code> and then position it at the tip of the forearm bone.</li>
<li class="calibre15">Using the red arrow of the position tool gizmo, drag it down, extending it past the hand just a bit. Positioning the effector outside of the sprites will make them more visible and easier to click on to manipulate (this step is purely personal preference; you may also leave it at the tip of the forearm bone).</li>
<li class="calibre15">Repeat these steps for the other arm (the arm behind the actor) and both legs.</li>
<li class="calibre15">With our effectors in place, add the <code>IK Manager 2D</code> component to the root bone and start adding <strong class="bold">IK Solvers</strong> for the limbs by clicking the plus (<strong class="bold">+</strong>) button in the tab and then selecting <strong class="bold">Limb</strong>.</li>
</ol>
<p class="calibre3">We’re making this selection because it’s meant for posing joints specifically for arms and legs (also known<a id="_idIndexMarker558" class="pcalibre1 pcalibre calibre6"/> as a <strong class="bold">two-bone Solver</strong>).</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">IK Solvers: <a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers</a>.</p>
<p class="calibre3">Adding an <code>LimbSolver2D</code> component<a id="_idIndexMarker559" class="pcalibre1 pcalibre calibre6"/> added.</p>
<p class="calibre3">Perform the following steps to complete the IK limb setup for the front arm:</p>
<ol class="calibre14">
<li class="calibre15">Rename <code>New LimbSovler2D</code> to <code>Front Arm LimbSolver2D</code> and keep it selected so that the <code>LimbSolver2D</code> component is visible in the <strong class="bold">Inspector</strong> window.</li>
<li class="calibre15">Click and drag the <code>IK Effector</code> object for the front forearm to the <code>LimbSolver2D</code> component.</li>
<li class="calibre15">Once this <code>_Target</code> child GameObject for the limb solver that we can now manipulate the position of in the <strong class="bold">Scene</strong> view to pose the limb.</li>
<li class="calibre15">Click and drag the circle icon that has now appeared on the <strong class="bold">Target</strong> transform in the <strong class="bold">Scene</strong> view to test out the IK limb.</li>
<li class="calibre15">Note that the default value for <strong class="bold">Flip</strong> is disabled, which may work just fine for how the target was created, but if the limb is bending backward as you drag the target around, then enable <strong class="bold">Flip</strong> to solve this issue.</li>
</ol>
<p class="calibre3"><em class="italic">Figure 5</em><em class="italic">.7</em> illustrates the results of these steps:</p>
<div><div><img alt="Figure 5.7 – IK Effector and limb solver setup" src="img/B18347_05_7.jpg" class="calibre70"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.7 – IK Effector and limb solver setup</p>
<p class="calibre3">The <code>Front Arm LimbSolver2D_Target</code> object’s transform position is what is keyframed during<a id="_idIndexMarker560" class="pcalibre1 pcalibre calibre6"/> animation.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Once the IK Solvers have been set up, we can no longer scale the player character with the <strong class="bold">Pixels Per Unit</strong> value in the <strong class="bold">PSD Importer</strong> settings – this is due to the IK targets being based on the transform local positions, which won’t update when the sprite’s PPU is scaled. Instead, change the transform scale on the parented <strong class="source-inline1">PlayerCharacter1</strong> object.</p>
<p class="calibre3">You can now follow these steps any time you need to create an IK limb on a skinned actor rig. Go ahead <a id="_idIndexMarker561" class="pcalibre1 pcalibre calibre6"/>and make IK limbs for the back arm and both legs. With that, we’re ready to animate!</p>
<p class="callout-heading">Reminder</p>
<p class="callout">Don’t forget to apply changes to the <strong class="source-inline1">Player</strong> Prefab!</p>
<p class="callout-heading">Additional resources | 2D characters</p>
<p class="callout">Another option for getting a head start on creating your rigged and animated 2D characters is to work with existing example characters from either the Dagon Crashers or Lost Crypt sample projects that Unity provides on the Asset Store:</p>
<p class="callout">Dragon Crashers: <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721</a>.</p>
<p class="callout">Lost Crypt: <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673</a>.</p>
<h2 id="_idParaDest-103" class="calibre8"><a id="_idTextAnchor105" class="pcalibre1 pcalibre calibre6"/>Creating actor animations</h2>
<p class="calibre3"><strong class="bold">Actor animation</strong> is the <a id="_idIndexMarker562" class="pcalibre1 pcalibre calibre6"/>process of<a id="_idIndexMarker563" class="pcalibre1 pcalibre calibre6"/> repositioning or rotating the actor’s bones at different times on the timeline of the <strong class="bold">Animation</strong> window, which is recorded as keyframes that hold the transform data. In <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, we performed a simpler version of this process when we animated the vines.</p>
<p class="calibre3">Let’s start animating the actor:</p>
<ol class="calibre14">
<li class="calibre15">First, we’ll make an idle animation by opening the <strong class="bold">Animation</strong> window by going to <strong class="bold">Window</strong> | <strong class="bold">Animation</strong> | <strong class="bold">Animation</strong>.</li>
<li class="calibre15">Select <code>PlayerCharacter1</code> in the hierarchy (not the root <code>Player</code> object; we want to animate the <em class="italic">graphics</em>, which can be later switched out with a different actor that may not have the same skeletal rig) and click the <strong class="bold">Create</strong> button.</li>
<li class="calibre15">This will create an animation asset file (<code>.anim</code>) that we’ll name <code>Player Idle</code> and save to the <code>Assets/Animation</code> folder.</li>
</ol>
<p class="calibre3">Now, put your animator hat on again, because it’s time to animate!</p>
<p class="calibre3">The first thing to note while animating with IK limbs is why we added the new root bone in the <em class="italic">Setting Up inverse kinematics (IK)</em> section. Select the <code>bone_1</code>, our <em class="italic">original</em> root bone).</p>
<p class="calibre3">You’ll notice that a square outline has appeared at the larger end of the bone (the base) and that hovering the mouse pointer within this square will show a move icon. Hovering over the part of the bone outside of the square will show a rotate icon. Click and hold the left-mouse button within the square and slowly drag it down.</p>
<p class="calibre3">The whole actor will start to move down except for the feet – they will remain firmly grounded in place. This <a id="_idIndexMarker564" class="pcalibre1 pcalibre calibre6"/>would not be <a id="_idIndexMarker565" class="pcalibre1 pcalibre calibre6"/>possible without IK and the new root bone we added. Yay!</p>
<p class="calibre3">One more thing to note with the IK limbs before letting you lose to create your idle animation – you can position the limbs in two ways:</p>
<ul class="calibre17">
<li class="calibre15">By clicking and dragging the IK circular targets in the <strong class="bold">Scene</strong> view</li>
<li class="calibre15">By selecting the <code>… LimbSolver2D_Target</code> objects in the <strong class="bold">Hierarchy</strong> window and using the <strong class="bold">Move</strong> tool in the <strong class="bold">Scene</strong> view (or entering <strong class="bold">Transform</strong> values in the <strong class="bold">Inspector</strong> window)</li>
</ul>
<p class="calibre3">Do not try to keyframe individual bones in the IK chains, the IK Effector objects, or the objects with the <code>LimbSolver2D</code> components! Create your idle animation by following these steps:</p>
<ol class="calibre14">
<li class="calibre15">Click the red record button (the <strong class="bold">Animation</strong> window; <strong class="bold">Keyframe Recording</strong> mode) to start recording keyframes (any time a bone is rotated or repositioned, a key will be created).</li>
<li class="calibre15">Pose your actor into a nice starting position for a simple idling in place.</li>
<li class="calibre15">Scrub the timeline ahead about 1.5 seconds and make a second pose by lowering the torso bending into the knees, bending the arms, and tilting down the head slightly – something like that.</li>
<li class="calibre15">Now, to animate between these two poses, click and drag a rectangle around the starting frame’s keys – press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">C</em> to copy those keys.</li>
<li class="calibre15">Scrub the timeline to 3 seconds and press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">V</em> to paste the keys.</li>
<li class="calibre15">Click the red record button again to stop recording, then use the <strong class="bold">Play</strong> button to check the results.</li>
</ol>
<p class="calibre3">You know the drill – animation<a id="_idIndexMarker566" class="pcalibre1 pcalibre calibre6"/> is more <a id="_idIndexMarker567" class="pcalibre1 pcalibre calibre6"/>art than technical, so fiddle with the poses and timing until you get good results. <em class="italic">Figure 5</em><em class="italic">.8</em> illustrates a completed actor idle animation:</p>
<div><div><img alt="Figure 5.8 – Actor keyframe idle animation" src="img/B18347_05_8.jpg" class="calibre71"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Actor keyframe idle animation</p>
<p class="calibre3">Note that in <em class="italic">Figure 5</em><em class="italic">.8</em>, I’ve changed the color of the IK Solvers (the <code>IKManager2D</code> component on the <code>root_bone</code> object) to give the limb bones their own color – another way to visually organize the different components that make up the actor and make it a bit easier to work with.</p>
<p class="calibre3">With our base idle animation added to the character, let’s look at how to drive animation and<a id="_idIndexMarker568" class="pcalibre1 pcalibre calibre6"/> apply movement to <a id="_idIndexMarker569" class="pcalibre1 pcalibre calibre6"/>our character from player input.</p>
<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor106" class="pcalibre1 pcalibre calibre6"/>Using an Input Action Map</h1>
<p class="calibre3">We’ll continue to use<a id="_idIndexMarker570" class="pcalibre1 pcalibre calibre6"/> the new <code>Input System</code> package installed:</p>
<ol class="calibre14">
<li class="calibre15">Open <strong class="bold">Package Manager</strong> by going to <strong class="bold">Window</strong> | <strong class="bold">Package Manager</strong>.</li>
<li class="calibre15">The default <strong class="bold">Packages</strong> location is <strong class="bold">In Project</strong>, so if you see <strong class="bold">Input System</strong> in the list under the <strong class="bold">Package – Unity</strong> section, then we’re all set!</li>
<li class="calibre15">If you can’t find <strong class="bold">Input System</strong>, then switch the <strong class="bold">Packages</strong> dropdown to <strong class="bold">Unity Registry</strong>, select <strong class="bold">Input System</strong> from the list, and click <strong class="bold">Install</strong> (the bottom-right corner of the window). See <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, section <em class="italic">New Input System</em> for a refresher.</li>
</ol>
<p class="calibre3">For the collection game, we received input directly from <strong class="bold">Input Device</strong>; this time, we will use the <strong class="bold">Input Action</strong> approach. For that, we’re going to need an <strong class="bold">Action </strong><strong class="bold">Map</strong> asset.</p>
<p class="calibre3">Thankfully, creating a default action map for the player character is quite trivial – with most of the device inputs we’ll need for the keyboard and a game controller already made!</p>
<p class="calibre3">Follow these steps to accomplish this:</p>
<ol class="calibre14">
<li class="calibre15">The magic happens via the <code>Player Input</code> component. So, add it to the root object of the <code>Player</code> Prefab by using the <strong class="bold">Add Component</strong> button in the <strong class="bold">Inspector</strong> window.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">You can work with the <strong class="source-inline1">Player</strong> Prefab by adding it to a scene or working on it directly by double-clicking the Prefab in the <strong class="bold">Project</strong> window.</p>
<ol class="calibre14">
<li value="2" class="calibre15">Once the <code>Player Input</code> component has been added, click the <strong class="bold">Create Actions…</strong> button, as shown in <a id="_idIndexMarker572" class="pcalibre1 pcalibre calibre6"/>the<a id="_idIndexMarker573" class="pcalibre1 pcalibre calibre6"/> following screenshot. This will create a default<a id="_idIndexMarker574" class="pcalibre1 pcalibre calibre6"/> set of <strong class="bold">Input Action Maps</strong>, <strong class="bold">Input Actions</strong>, and <strong class="bold">Input Bindings</strong>:</li>
</ol>
<div><div><img alt="Figure 5.9 – Player Input | Create Actions" src="img/B18347_05_9.jpg" class="calibre72"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Player Input | Create Actions</p>
<ol class="calibre14">
<li value="3" class="calibre15">You will be prompted to save the new <code>.inputactions</code> asset. Select the <code>Assets/Settings</code> folder and use <code>Player Input</code> as the name for it. This asset will then be connected to the <code>Player Input</code> component and<a id="_idIndexMarker575" class="pcalibre1 pcalibre calibre6"/> bring up the <strong class="bold">Input </strong><strong class="bold">Actions editor</strong>.</li>
</ol>
<p class="calibre3">Here, we can see all of the actions pre-populated for the player action map, as shown in <em class="italic">Figure 5</em><em class="italic">.10</em> – everything we need plus more!</p>
<div><div><img alt="Figure 5.10 – Player Input Action Maps (Input Actions)" src="img/B18347_05_10.jpg" class="calibre73"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Player Input Action Maps (Input Actions)</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Input System: <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml</a>.</p>
<p class="callout">Editing Input Actions Assets: <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets</a>.</p>
<p class="calibre3">The <code>Player Input</code> component<a id="_idIndexMarker576" class="pcalibre1 pcalibre calibre6"/> also provides everything we need to respond to input from the player. <em class="italic">Figure 5</em><em class="italic">.10</em> sets the <code>SendMessage()</code> on the GameObject to which the <code>Player Input</code> component belongs, calling the name on every component (<code>MonoBehaviour</code>) added to the GameObject. As shown in <em class="italic">Figure 5</em><em class="italic">.10</em>, the relevant method names will be called as listed in the box just below the <strong class="bold">Behavior</strong> field.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Notification behaviors: <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors</a>.</p>
<p class="calibre3">For simplicity’s sake, we’ll stick with the <code>SendMessage()</code>, which is slower due to having to use <strong class="bold">Reflection</strong>.</p>
<p class="callout-heading">Reflection | C#</p>
<p class="callout"><strong class="source-inline1">SendMessage()</strong> heavily relies on <strong class="bold">Reflection</strong> to find the method to call at runtime. <strong class="bold">Reflection</strong> is slow (supposedly 3x slower than calling the method directly) because it requires managed code to read (search) its metadata to find assemblies.</p>
<p class="calibre3">With our input set <a id="_idIndexMarker577" class="pcalibre1 pcalibre calibre6"/>up and we know how to respond to the inputs we’ve defined, we’re ready to write our player controller code!</p>
<h1 id="_idParaDest-105" class="calibre5"><a id="_idTextAnchor107" class="pcalibre1 pcalibre calibre6"/>Moving the player with a player controller script</h1>
<p class="calibre3">We’ll need more<a id="_idIndexMarker578" class="pcalibre1 pcalibre calibre6"/> than just input to move our player <a id="_idIndexMarker579" class="pcalibre1 pcalibre calibre6"/>character around the level. We’ll have to configure the <code>Player</code> object to work with the <strong class="bold">Physics</strong> system so that it interacts with our level’s ground and platforms and interactivity trigger volumes, and then applies the movement force.</p>
<p class="calibre3">Configure the <code>Player</code> Prefab’s root GameObject with the following components while referring to <em class="italic">Figure 5</em><em class="italic">.11</em>:</p>
<ol class="calibre14">
<li class="calibre15">Add a <code>Rigidbody2D</code> component (by pressing the <code>1</code>: We’ll add some drag to the player’s movement to provide additional constraints on the move to help the player feel more grounded and not very floaty.</li><li class="upper-roman"><strong class="bold">Constraints</strong> | <strong class="bold">Freeze Rotation Z</strong> enabled: We want to prevent the player from spinning around and have them always stand vertically (perpendicular to the ground plane).</li></ol></li>
<li class="calibre15">Add <code>CapsuleCollider2D</code> (by pressing the <strong class="bold">Add Component</strong> button). Use the <strong class="bold">Edit bounding volume</strong> button and modify the collider’s shape until it encompasses the actor.<p class="calibre3">This represents <a id="_idIndexMarker580" class="pcalibre1 pcalibre calibre6"/>the<a id="_idIndexMarker581" class="pcalibre1 pcalibre calibre6"/> player’s hitbox, which may need to be adjusted over time as you playtest:</p></li>
</ol>
<div><div><img alt="Figure 5.11 – Player physics setup" src="img/B18347_05_11.jpg" class="calibre74"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Player physics setup</p>
<p class="calibre3">With the required <code>Player Input</code> component<a id="_idIndexMarker582" class="pcalibre1 pcalibre calibre6"/> is <a id="_idIndexMarker583" class="pcalibre1 pcalibre calibre6"/>only responsible for reading the device input and invoking the assigned action.</p>
<h2 id="_idParaDest-106" class="calibre8"><a id="_idTextAnchor108" class="pcalibre1 pcalibre calibre6"/>Processing Player Input</h2>
<p class="calibre3">While we could use the <a id="_idIndexMarker584" class="pcalibre1 pcalibre calibre6"/>device input directly, as we did in the <em class="italic">Player controller script</em> section of <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, it’s essential to understand the value of using <strong class="bold">Input Action Map</strong>. Here are a few examples:</p>
<ul class="calibre17">
<li class="calibre15">Multiple device inputs can be simultaneously configured without the need to change the input handling code</li>
<li class="calibre15">A different action map can be switched to, depending on the current input actions required</li>
<li class="calibre15">Key rebinding can be implemented without changing the input handling code</li>
</ul>
<p class="calibre3">Armed with this knowledge, you can determine the best approach for different use cases (are you prototyping? Are you engineering a flexible solution for a commercial title?).</p>
<p class="calibre3">Previously, we continuously polled the <code>isPressed</code> key state directly on the input device in the <code>Update()</code> loop to control the player movement, like so:</p>
<pre class="source-code">
void Update()
{
    if (keyboard.aKey.isPressed
        || keyboard.leftArrowKey.isPressed)
            _moveHorizontal = -1.0f;
    …
}</pre> <p class="calibre3">Since we’re receiving <a id="_idIndexMarker585" class="pcalibre1 pcalibre calibre6"/>our input handling from <code>SendMessage()</code> now, we’ll need to make some changes.</p>
<p class="calibre3"><code>SendMessage()</code> is called anytime there is input. Input is not continuously polled! It behaves like an event whenever an input action occurs, which means that for the <em class="italic">Move</em> action, <code>OnMove()</code> will be called when a key is pressed and when it’s released.</p>
<p class="calibre3">The <code>SendMessage()</code> method names that were invoked for the defined input actions.</p>
<p class="calibre3"><code>SendMessage()</code> will also pass an <code>InputValue</code> parameter representing the <code>Vector2</code> in the case of <em class="italic">Move</em>, which holds the horizontal and vertical input values.</p>
<p class="calibre3">We’ll use the horizontal (X-axis) value to determine if a <strong class="bold">move left/right</strong> button was pressed or released since we want to move our player while the button is being held down (or while holding a game controller’s stick in a certain direction).</p>
<p class="calibre3">Our <code>move</code> method (<code>OnMove()</code>) will be called with a <code>Vector2</code> X-axis value for a horizontal input of <code>-1</code> and <code>1</code> for left and right, respectively, when a button is pressed, and a value of <code>0</code> when the button is released.</p>
<p class="calibre3">Now that we have all<a id="_idIndexMarker586" class="pcalibre1 pcalibre calibre6"/> this information, we can begin to code our input handler!</p>
<h2 id="_idParaDest-107" class="calibre8"><a id="_idTextAnchor109" class="pcalibre1 pcalibre calibre6"/>Creating the PlayerController script</h2>
<p class="calibre3">Let’s start by <a id="_idIndexMarker587" class="pcalibre1 pcalibre calibre6"/>creating a new C# script named <code>PlayerController</code> in the <code>Assets/Scripts</code> folder.</p>
<p class="calibre3">We can now add our input handler method for the <em class="italic">move</em> action – <code>OnMove()</code> – and assign the <code>InputValue</code> parameter’s <code>Vector2</code> value to a private member variable named <code>_movementInput</code>. We’ll use this later when we calculate the movement to be applied to the player’s <strong class="bold">Rigidbody2D</strong> velocity.</p>
<p class="calibre3">Here’s what our initial code looks like:</p>
<pre class="source-code">
public class PlayerController : MonoBehaviour
{
    private Vector2 _movementInput;
    void OnMove(InputValue value)
    {
        var move = value.Get&lt;Vector2&gt;();
        _movementInput = (move.x != 0f)
            ? new Vector2(move.x, 0f) : Vector2.zero;
    }
}</pre> <p class="calibre3">We read the input values of the input using the <code>Get()</code> method of the <code>value</code> parameter variable. We’re only interested in the horizontal movement here and will set the <code>_movementInput</code> value depending on the input state: pressed or released.</p>
<p class="calibre3">So, if <code>move.x</code> equals <code>0</code>, then the button key was released (think of it as <code>IsPressed == false</code>). Then, using a ternary operator (<code>?:</code>), we’ll assign <code>Vector2.zero</code> to make sure that any/all input is ignored.</p>
<p class="calibre3">When <code>move.x</code> is not equal to zero, we have a button key press input value that represents the direction (<code>-1</code>: <em class="italic">left</em>, <code>1</code>: <em class="italic">right</em>) and assign it to <code>_movementInput</code> with a new <code>Vector2</code> of the direction and no vertical value: <code>new </code><code>Vector2(move.x, 0f)</code>.</p>
<p class="calibre3">With this approach, we can still respond to vertical input later, such as one for a jetpack! Now that we have a direction, we can apply force (in the form of velocity) to move the player character in<a id="_idIndexMarker588" class="pcalibre1 pcalibre calibre6"/> that direction.</p>
<p class="calibre3">Let’s add the following code to handle this:</p>
<pre class="source-code">
private Rigidbody2D _rb;
void Awake() =&gt; _rb = GetComponent&lt;Rigidbody2D&gt;();
void FixedUpdate() =&gt; UpdateVelocity();
private void UpdateVelocity()
{
    var velocity = _rb.velocity;
    velocity += Time.fixedDeltaTime * _movementInput;
    _rb.velocity = velocity;
}</pre> <p class="calibre3">Let’s break this code down item by item:</p>
<ul class="calibre17">
<li class="calibre15">The <code>_rb</code> variable: This private member variable will hold a reference to the <code>Rigidbody2D</code> component that we previously added, and we’ll be setting the velocity here to move the player. We once made this a <code>public</code> field that could be assigned in the <strong class="bold">Inspector</strong> window, but we’ll keep it private this time to encapsulate it.</li>
<li class="calibre15">The <code>Awake()</code> method (expression body): Since our <code>Rigidbody2D</code> variable is private, we’re only using this Unity message event to get the reference to the <code>Rigidbody2D</code> component on this object at runtime using <code>GetComponent()</code>.</li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">GameObject.GetComponent</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml</a>.</p>
<ul class="calibre17">
<li class="calibre15">The <code>FixedUpdate()</code> method (expression body): This Unity message event is called at <a id="_idIndexMarker589" class="pcalibre1 pcalibre calibre6"/>every <code>UpdateVelocity()</code> method.</li>
<li class="calibre15">The <code>UpdateVelocity()</code> method: This method will calculate and apply the velocity vector to the Player’s <code>Rigidbody2D</code> component.<ul class="calibre22"><li class="calibre15"><code>var velocity</code>: This holds the current value of the <code>Rigidbody2D</code> component’s velocity that we’ll modify and assign back.</li><li class="calibre15">The <code>velocity</code> calculation: This adds the movement input vector multiplied by <code>fixedDeltaTime</code> to the velocity variable. Multiplying by <code>fixedDeltaTime</code> ensures frame rate independence.</li><li class="calibre15">The <code>_rb.velocity</code> assignment: Here, we simply assign the calculated velocity back to the <code>Rigidbody2D</code> component, which moves the player. Remember that <code>FixedUpdate</code> should always be used for executing physics-related code, especially for applying force to a <code>Rigidbody</code> component!</li></ul></li>
</ul>
<p class="callout-heading">Author’s note</p>
<p class="callout">I’ve read discussions on whether it’s necessary to apply <strong class="source-inline1">deltaTime</strong> in <strong class="source-inline1">FixedUpdate</strong> because it runs at a consistent framerate. Anyway, I err on the side of knowing that the <strong class="source-inline1">FixedUpdate</strong> interval is always relative to the in-game time. Also, the Unity-provided example code always includes <strong class="source-inline1">deltaTime</strong>, and being consistent in including it will ensure we achieve frame rate independence across all devices.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">Time.fixedDeltaTime</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml</a>.</p>
<p class="callout">Time and Frame Rate Management: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml</a>.</p>
<p class="calibre3">Multiplying by zero always gives zero, so <code>Vector2.zero</code> with <code>_movementInput</code> will assign a velocity value of zero, stopping the player’s movement.</p>
<p class="calibre3">We’ve applied velocity to the player, but don’t get too excited. This will likely have no net effect on <a id="_idIndexMarker591" class="pcalibre1 pcalibre calibre6"/>moving the player because the velocity value is too small! Let’s fix that by applying an acceleration multiplier to the velocity.</p>
<p class="calibre3">Add the following member variables and make the changes that are shown here to the <code>UpdateVelocity()</code> method:</p>
<pre class="source-code">
[Header("Movement")]
[SerializeField] private float _acceleration = 0.0f;
[SerializeField] private float _speedMax = 0.0f;
private void UpdateVelocity()
{
    var velocity = _rb.velocity;
    velocity += _acceleration * Time.fixedDeltaTime
        * _movementInput;
    velocity.x = Mathf.Clamp(velocity.x,
        -_speedMax, _speedMax);
    _rb.velocity = velocity;
}</pre> <p class="calibre3">Let’s break down these changes:</p>
<ul class="calibre17">
<li class="calibre15">We’ve added two new variables, <code>_acceleration</code> and <code>_speedMax</code>, which we’ve set to private but made available to assign in the <code>[SerializeField]</code> attribute to decorate a private accessor field, we’re telling Unity to serialize it and make it available for assignment in the <code>_acceleration</code>: This <a id="_idIndexMarker593" class="pcalibre1 pcalibre calibre6"/>applies our overall velocity amount (force) for how quickly we’ll reach the maximum speed value.</li><li class="calibre15"><code>_speedMax</code>: The maximum speed of the player character’s movement.</li></ul></li>
<li class="calibre15">In the <code>UpdateVelocity()</code> method, we’ve made the following changes:<ul class="calibre22"><li class="calibre15">We’ve modified the line that adds to the velocity vector by multiplying by the <code>_acceleration</code> value.</li><li class="calibre15">We’ve ensured that <code>velocity.x</code> will be clamped to the maximum speed value by using the <code>Mathf.Clamp()</code> method.</li></ul></li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">SerializeField</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml</a>.</p>
<p class="calibre3">You can now add the <code>PlayerController</code> script to the root of the <code>Player</code> Prefab, add your player to a scene with some ground (don’t forget to add a collider), and playtest. You can move the player with the <em class="italic">A</em> and <em class="italic">D</em> keys, left and right arrow keys, or a game controller’s left stick. You can adjust values for acceleration, max speed, and the <strong class="bold">Rigidbody2D</strong> properties for mass and linear drag.</p>
<p class="callout-heading">PlayerController.cs code</p>
<p class="callout">To view the <a id="_idIndexMarker594" class="pcalibre1 pcalibre calibre6"/>completed code for the <strong class="source-inline1">PlayerController</strong> class, visit the following GitHub repository: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts</a>.</p>
<p class="calibre3">Playtesting means tweaking these movement variables repeatedly until the player control <em class="italic">feels right</em> to you. I’ve currently settled on values of <code>30</code> for acceleration and <code>8</code> for max speed. As you <a id="_idIndexMarker595" class="pcalibre1 pcalibre calibre6"/>build out the game, you’ll find yourself going back and tweaking these values many, many more times – game feel is crucial to player satisfaction.</p>
<h2 id="_idParaDest-108" class="calibre8"><a id="_idTextAnchor110" class="pcalibre1 pcalibre calibre6"/>Physics materials</h2>
<p class="calibre3">While<a id="_idIndexMarker596" class="pcalibre1 pcalibre calibre6"/> playtesting, you may notice that the player <a id="_idIndexMarker597" class="pcalibre1 pcalibre calibre6"/>may slide for a bit when you release the key (or controller stick). This can be corrected by freezing the player in place when the key is released, but I believe a better way is to change the properties of the ground the player is currently standing on. By adjusting the friction of the ground, we can provide different types of ground, including ice, where the player would slide when input is released.</p>
<p class="calibre3">We’re going to add a <strong class="bold">physics material</strong> to the ground to provide <em class="italic">higher default friction</em>. That way, we can have areas with less friction later to change up the gameplay, and so on.</p>
<p class="calibre3">Follow these steps to create a new physics material and apply it to the ground objects in your level:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/Settings</code> folder, create a new folder and name it <code>Physics Materials</code>.</li>
<li class="calibre15">Right-click within the new folder, select <code>Default Friction</code>.</li>
<li class="calibre15">Select the newly created physics material and, in the <code>10</code> (this, like all other gameplay variables, is subject to change with playtesting).</li>
<li class="calibre15">Now, assign the physics material to your ground objects by dragging it into the <code>Collider</code> component, as seen in the following figure:</li>
</ol>
<div><div><img alt="Figure 5.12 – Assigning a physics material to the ground collider" src="img/B18347_05_12.jpg" class="calibre75"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Assigning a physics material to the ground collider</p>
<p class="calibre3">Continue to playtest and adjust these values.</p>
<p class="calibre3">We’ll finish <a id="_idIndexMarker598" class="pcalibre1 pcalibre calibre6"/>up<a id="_idIndexMarker599" class="pcalibre1 pcalibre calibre6"/> the initial player controller next by adding a run animation and having the player always face the direction of movement.</p>
<h1 id="_idParaDest-109" class="calibre5"><a id="_idTextAnchor111" class="pcalibre1 pcalibre calibre6"/>Animating the character with Mecanim</h1>
<p class="calibre3">In the <em class="italic">Creating actor animations</em> section, we <a id="_idIndexMarker600" class="pcalibre1 pcalibre calibre6"/>added an <code>PlayerCharacter1</code> object when we created the idle animation for the actor. The <code>Animator</code> component allows us to assign animation to a GameObject in the <strong class="bold">Scene</strong> view – it’s the interface responsible for controlling <a id="_idIndexMarker601" class="pcalibre1 pcalibre calibre6"/>Unity’s <strong class="bold">Mecanim</strong> animation system (on the actor or any other GameObject you’d like to animate).</p>
<p class="calibre3">An <code>Animator</code> component. This controller asset defines what animations to use and when and how to transition and blend them.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Animator: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml</a>.</p>
<p class="calibre3">To continue setup in the <code>Animator</code> component, we’ll need a second animation to transition to when our player character moves or, let’s say, runs.</p>
<p class="calibre3">Follow these steps to create an additional animation for the actor:</p>
<ol class="calibre14">
<li class="calibre15">Open the <code>PlayerCharacter1</code> object in the <strong class="bold">Scene</strong> view.</li>
<li class="calibre15">Now, in the <strong class="bold">Animation</strong> window, click the <strong class="bold">Animation Clips</strong> list dropdown (the top left of the window just under the playback controls), then click <strong class="bold">Create New Clip…</strong>, as seen in the following figure:</li>
</ol>
<div><div><img alt="Figure 5.13 – Create New Clip…" src="img/B18347_05_13.jpg" class="calibre76"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.13 – Create New Clip…</p>
<ol class="calibre14">
<li value="3" class="calibre15">Save the new clip as <code>Player Run</code> in the <code>Assets/Animation</code> folder.</li>
<li class="calibre15">Animate a run cycle. You’ve got this!</li>
</ol>
<p class="calibre3">Seriously though, animation is a skill you’ll need to grow into. While I can create animations, I still need lots of practice in this area to get better at it (I’ll likely employ a skilled character animator for the final actor animations in the finished project files for this book, and<a id="_idIndexMarker602" class="pcalibre1 pcalibre calibre6"/> these will be available for you to use and learn from as well).</p>
<p class="callout-heading">Additional resources | 2D character animation</p>
<p class="callout">Another option<a id="_idIndexMarker603" class="pcalibre1 pcalibre calibre6"/> for getting a head start on character animations is to work with existing example characters from either the Dragon Crashers or Lost Crypt sample projects that Unity provides on the Asset Store.</p>
<p class="callout">Dragon Crashers: <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721</a>.</p>
<p class="callout">Lost Crypt: <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673</a>.</p>
<p class="calibre3">We can now move on to wiring up the transition for the <em class="italic">idle to </em><em class="italic">run</em> animation.</p>
<h2 id="_idParaDest-110" class="calibre8"><a id="_idTextAnchor112" class="pcalibre1 pcalibre calibre6"/>Transitioning animation states</h2>
<p class="calibre3">To open<a id="_idIndexMarker604" class="pcalibre1 pcalibre calibre6"/> the <code>Animator</code> component on the <code>PlayerCharacter1</code> object or double-click on the <code>PlayerCharacter1</code> asset in the <code>Assets/Animation</code> folder in the <strong class="bold">Project</strong> window.</p>
<p class="calibre3">With the <strong class="bold">Animator</strong> window open (you may want to dock it so that you can still see all the Editor windows clearly), you should see the default states (<strong class="bold">Any State</strong>, <strong class="bold">Entry</strong>, <strong class="bold">Exit</strong>) as well as states for the animation clips currently on the actor (<strong class="bold">Player Idle</strong>, <strong class="bold">Player Run</strong>):</p>
<div><div><img alt="Figure 5.14 – Actor animation transition with Mecanim" src="img/B18347_05_14.jpg" class="calibre77"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Actor animation transition with Mecanim</p>
<p class="calibre3">Note that you can navigate the <strong class="bold">Animator</strong> window using the mouse scroll wheel to zoom in/out and use the <em class="italic">Alt</em> + left-mouse button/<em class="italic">Option</em> + left-mouse button shortcut to pan the view. Click and drag on any State Node to reposition it in an orderly fashion.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">The <strong class="bold">Animator</strong> window: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml</a>.</p>
<p class="calibre3">Follow these steps to create a <strong class="bold">Transition</strong> from the <strong class="bold">Player Idle</strong> to <strong class="bold">Player </strong><strong class="bold">Run</strong> states:</p>
<ol class="calibre14">
<li class="calibre15">First, create a Boolean parameter for whether we are running or not by executing the following steps:<ol class="calibre42"><li class="upper-roman">First, select the <code>Running</code> – we want a Boolean parameter to hold the state for if the player is running (<code>true</code>) or not running (<code>false</code>).</li></ol></li>
<li class="calibre15">Right-click on the <strong class="bold">Player Idle</strong> node and select <strong class="bold">Make Transition</strong> from the popup menu.</li>
<li class="calibre15">With the <strong class="bold">Transition</strong> arrow<a id="_idIndexMarker606" class="pcalibre1 pcalibre calibre6"/> attached <a id="_idIndexMarker607" class="pcalibre1 pcalibre calibre6"/>to the mouse pointer, click on the <strong class="bold">Player </strong><strong class="bold">Run</strong> node.</li>
<li class="calibre15">Now, click on the newly created transition line (<em class="italic">B</em> in <em class="italic">Figure 5</em><em class="italic">.14</em>) to view its properties in the <strong class="bold">Inspector</strong> window.</li>
<li class="calibre15">Within the <code>true</code>; meaning, transition to the assigned node when the <code>true</code>.</li>
<li class="calibre15">Go back to <em class="italic">step 2</em> and repeat the instructions to transition back to <code>false</code>.</li>
<li class="calibre15">The last step is to disable <strong class="bold">Has Exit Time</strong> (<em class="italic">D</em> in <em class="italic">Figure 5</em><em class="italic">.14</em>) for both transitions. We want the state to exit (the animation to stop) as soon as the condition is met and not wait for the animation to play completely.</li>
</ol>
<p class="calibre3">Since we haven’t wired up the animation states to the player input yet, you can test manually to make sure the transition is working well by entering <strong class="bold">Play Mode</strong> and, while viewing both the <strong class="bold">Game view</strong> and <strong class="bold">Animator</strong> windows, toggling the <strong class="bold">Running</strong> parameter on/off. The player should change from an <em class="italic">idle</em> to <em class="italic">run</em> animation and back every time<a id="_idIndexMarker608" class="pcalibre1 pcalibre calibre6"/> you toggle the <a id="_idIndexMarker609" class="pcalibre1 pcalibre calibre6"/>parameter. Yay!</p>
<p class="calibre3">Now, let’s make this transition based on the player’s input.</p>
<h2 id="_idParaDest-111" class="calibre8"><a id="_idTextAnchor113" class="pcalibre1 pcalibre calibre6"/>Changing the animation state with code</h2>
<p class="calibre3">The first<a id="_idIndexMarker610" class="pcalibre1 pcalibre calibre6"/> thing we’ll need is a variable<a id="_idIndexMarker611" class="pcalibre1 pcalibre calibre6"/> to hold the reference to the <code>Animator</code> component (assignable in the <code>Running</code> parameter to <code>true</code>, and when the player stops moving the character, we will set the <code>Running</code> parameter to <code>false</code>. We’ll make quick work of this and accomplish it with only one line of code!</p>
<p class="calibre3">Add the following code to the <code>PlayerController</code> script:</p>
<pre class="source-code">
[Header("Actor")]
[SerializeField] private Animator _animator;
private void UpdateVelocity()
{
    …
    // Update animator.
    _animator.SetBool("Running", _movementInput.x != 0f);
}</pre> <p class="calibre3">The <code>_animator</code> variable declaration is our reference to the <code>Animator</code> component in the <code>Player</code> object. We marked it as <code>private</code> so that no other class can modify it but decorated it with the <code>[SerializeField]</code> attribute so that it’s serialized and assignable in the <strong class="bold">Inspector</strong> window.</p>
<p class="calibre3">In the <code>UpdateVelocity()</code> method, we added a call to <code>_animator.SetBool()</code> and passed in the <code>Running</code> string to identify the bool parameter we’d like to set. We’ll pass in the evaluation result of the <code>_movementInput.x != 0f</code> expression for the bool value.</p>
<p class="calibre3">What this means is that if our player is receiving movement input (value is not zero), then we are moving (<code>Running</code> equals <code>true</code>); otherwise, (that is, <code>if _movementInput.x == 0f</code>), we are standing still (<code>Running</code> equals <code>false</code>).</p>
<p class="calibre3">Once you’ve added and saved this code, drag the child <code>PlayerCharacter1</code> object to the <code>PlayerController</code> component’s <strong class="bold">Animator</strong> field using the <strong class="bold">Hierarchy</strong> and <strong class="bold">Inspector</strong> windows in the <strong class="bold">Editor</strong> view.</p>
<p class="calibre3">Enter <strong class="bold">Play Mode</strong> and move the player left and right to test that the animation is transitioning from idle to run and back. You’ll likely notice that even though the animation is <a id="_idIndexMarker612" class="pcalibre1 pcalibre calibre6"/>transitioning, the<a id="_idIndexMarker613" class="pcalibre1 pcalibre calibre6"/> actor is facing the wrong direction while moving to the left!</p>
<p class="calibre3">We’ll address this next to finish up the player movement.</p>
<h2 id="_idParaDest-112" class="calibre8"><a id="_idTextAnchor114" class="pcalibre1 pcalibre calibre6"/>Flipping the player character</h2>
<p class="calibre3">While the <code>PlayerController</code> script to ensure the player is always facing the direction of movement.</p>
<p class="calibre3">Open the <code>PlayerController</code> script and, at the end of the <code>OnMove()</code> method, add a call to a new method named <code>UpdateDirection</code>. Create the <code>UpdateDirection()</code> method with the following code:</p>
<pre class="source-code">
void OnMove(InputValue value)
{
    …
    UpdateDirection();
}
private void UpdateDirection()
{
    if (_movementInput.x != 0f)
    {
        transform.localScale = Vector3.one;
        if (_movementInput.x &lt; 0f)
            transform.localScale = new
                Vector3(-1f, 1f, 1f);
    }
}</pre> <p class="calibre3">The simple trick we’re employing to flip the direction the player character is facing is to set the <code>localScale X</code> value to <code>-1</code> for the player object’s <strong class="bold">Transform</strong> if the movement input value is less than zero (that is, input indicating moving to the left).</p>
<p class="calibre3">The first <code>if</code> statement in <code>UpdateDirection()</code> checks if we have any input for moving the player. Remember, a value of zero means that the player released the direction key (or game controller stick).</p>
<p class="calibre3">If the movement’s input horizontal value is not zero, we first set a default scale for facing right (an <code>X</code> value of <code>1</code>). If it turns out that the movement input is for facing left (an <code>X</code> value of <code>-1</code>), then we set <code>localScale</code> to <code>Vector3</code> with an X-axis value of <code>-</code><code>1</code>. Easy-peasy.</p>
<p class="callout-heading">Bonus activity</p>
<p class="callout">Based on the techniques learned in this chapter for processing player input, moving the player via its <strong class="source-inline1">Rigidbody2D</strong> component and animating the player using the <strong class="bold">Animator</strong> all within the <strong class="source-inline1">PlayerController</strong> script, add the ability for the player character to jump. Might as well jump, go ahead and jump!</p>
<p class="callout">I didn’t necessarily leave you hanging here. If you’re looking for a lifeline to solve this problem, you can view instructions for completing this jumping bonus activity by visiting the following GitHub link: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping</a></p>
<p class="calibre3">In this section, you <a id="_idIndexMarker616" class="pcalibre1 pcalibre calibre6"/>learned how to create animations<a id="_idIndexMarker617" class="pcalibre1 pcalibre calibre6"/> and apply them to the player, as well as how to transition and change the animation state with code, all while using Mecanim. We finished off by learning how to flip the facing direction of the player character.</p>
<h1 id="_idParaDest-113" class="calibre5"><a id="_idTextAnchor115" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter walked us through the complete setup of an animated 2D player character, including importing art and setting up an animatable rig via PSD Importer, setting up IK Solvers, and creating and applying animations to the player using Mecanim.</p>
<p class="calibre3">We continued by adding movement ability from player input by using an Input Action Map asset with the new Input System, coding a simple player controller script, processing input, and changing animations based on the current player action, also using Mecanim.</p>
<p class="calibre3">In the next chapter, we’ll add a weapon for the player so that they can shoot projectiles efficiently.</p>
</div>
</div></body></html>