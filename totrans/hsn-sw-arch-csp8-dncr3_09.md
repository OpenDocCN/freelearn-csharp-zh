# 如何在云中选择您的数据存储

与其他云服务一样，Azure 提供了广泛的存储设备。最简单的方法是在云中定义一组可扩展的虚拟机，我们可以在这些虚拟机上实现我们的自定义解决方案。例如，我们可以在云托管的虚拟机上创建一个 SQL Server 集群，以增加可靠性和计算能力。然而，通常，自定义架构并不是最佳解决方案，也没有充分利用云基础设施提供的机遇。

因此，本章将不会讨论此类自定义架构，而将主要关注云中可用的各种 **存储即服务**（**SaaS**） 提供方案，特别是 Azure。这些方案包括基于普通磁盘空间的可扩展解决方案、关系型数据库、NoSQL 数据库以及如 Redis 这样的内存数据存储。

选择更合适的存储类型不仅基于应用程序的功能需求，还基于性能和扩展需求。实际上，在处理资源时进行扩展会导致性能的线性增长，但扩展存储资源并不一定意味着性能的合理增长。简而言之，无论你复制多少数据存储设备，如果多个请求影响的是同一数据块，它们将始终需要相同的时间来排队访问它！

扩展数据会导致读取操作吞吐量的线性增长，因为每个副本可以服务不同的请求，但这并不意味着写入操作吞吐量会有相同的增长，因为同一数据块的所有副本都必须更新！因此，需要更复杂的技巧来扩展存储设备，并且并非所有存储引擎都能同等程度地扩展。

尤其是在所有场景中，关系型数据库的扩展性都不好。因此，扩展需求和地理分布数据的需求在存储引擎的选择中起着基本作用，以及在 SaaS 提供商的选择中也是如此。

在本章中，我们将涵盖以下主题：

+   理解不同目的的不同存储库

+   在结构化或 NoSQL 存储之间进行选择

+   Azure Cosmos DB - 管理多大陆数据库的机会

+   用例 - 存储数据

让我们开始吧：

# 技术要求

本章要求您具备以下条件：

+   Visual Studio 2017 或 2019 的免费社区版或更高版本，并安装所有数据库工具。

+   一个免费的 Azure 账户。[第 1 章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)中的“*创建 Azure 账户*”小节解释了如何创建一个。

+   为了获得更好的开发体验，我们建议您还安装 Cosmos DB 的本地模拟器，可在[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)找到。

# 理解不同目的的不同存储库

本节描述了最流行的数据存储技术所提供的功能。主要，我们将关注它们能够满足的功能需求。性能和扩展功能将在下一节中分析，该节专门用于比较关系型数据库和NoSQL数据库。在Azure中，可以通过在所有Azure门户页面顶部的搜索栏中输入产品名称来找到各种服务。

以下小节描述了我们可以用于我们的C#项目的各种数据库类型。

# 关系型数据库

通常，云提供多种数据库引擎。Azure提供各种流行的数据库引擎，如SQL Server（Azure SQL Server）、MySQL和Oracle。

关于Oracle数据库引擎，Azure提供可配置的虚拟机，这些虚拟机上安装了各种Oracle版本，您可以通过在Azure门户搜索栏中输入`Oracle`后得到的建议轻松验证。Azure费用不包括Oracle许可证；它们仅提供计算时间，因此您必须将许可证带到Azure。

在Azure上使用MySQL时，您需要为使用私有服务器实例付费。您产生的费用取决于您拥有的核心数量、需要分配多少内存以及备份保留时间。MySQL实例是冗余的，您可以选择本地或地理分布式的冗余：

![图片](img/3a871e4b-5bbe-4c0f-906e-5e2a3377be2d.png)

Azure SQL Server是最灵活的提供方案。在这里，您可以配置每个数据库使用的资源。当您创建数据库时，您可以选择将其放置在现有的服务器实例上或创建一个新的实例。费用基于已预留的数据库内存以及所需的**数据库事务单元**（**DTUs**）。在这里，一个DTU是由参考工作负载确定的I/O操作、CPU使用率和内存使用的线性组合。大致来说，当您增加DTUs时，最大数据库性能的增加是线性的：

![图片](img/04490184-bfc4-4eec-9eee-281af77ed4d3.png)

您还可以通过启用读扩展来配置数据复制。这样，您可以提高读取操作的性能。备份保留时间对于每个服务级别（基本、标准和高级）都是固定的。

如果您选择“是”以回答“是否想使用SQL弹性池？”，则数据库将被添加到弹性池中。添加到同一弹性池的数据库将共享其资源，因此未被数据库使用的资源可以在其他数据库的*使用高峰*期间使用。弹性池可以包含托管在不同服务器实例上的数据库。弹性池是优化资源使用以降低成本的有效方式。

# NoSQL数据库

在NoSQL数据库中，关系表被更通用的集合所取代，这些集合可以包含异构的JSON对象。也就是说，集合没有预定义的结构和没有预定义的字段长度限制（在字符串的情况下），但可以包含任何类型的对象。与每个集合相关联的唯一结构约束是作为主键的属性名称。

更具体地说，每个集合条目可以包含嵌套对象和嵌套在对象属性中的对象集合，即相关实体，在关系数据库中，这些实体包含在不同的表中并通过外部键连接。在NoSQL中，数据库可以嵌套在其父实体中。由于集合条目包含复杂的嵌套对象，而不是像关系数据库那样简单的属性/值对，因此条目不被称为元组或行，而是*文档*。

在同一集合或不同集合中属于同一文档的文档之间不能定义关系和/或外部键约束。如果一个文档在其属性中包含另一个文档的主键，那么它这样做是有风险的。开发者有责任维护并保持这些一致性的引用。

最后，由于NoSQL存储相对便宜，整个二进制文件可以作为文档属性的值以Base64字符串的形式存储。开发者可以定义规则来决定在集合中索引哪些属性。由于文档是嵌套对象，属性实际上是树路径。通常情况下，默认情况下，所有路径都会被索引，但你也可以指定要索引哪些路径集合和子路径。

NoSQL数据库可以通过SQL的子集或基于JSON的语言进行查询，其中查询是JSON对象，其路径表示要查询的属性，其值表示已应用于它们的查询约束。

在关系数据库中，可以通过一对多关系使用嵌套子对象的可能性。然而，在使用关系数据库时，我们被迫重新定义所有相关表的精确结构，而NoSQL集合不对它们包含的对象施加任何预定义的结构。唯一的约束是每个文档必须为主键属性提供一个唯一的值。因此，当我们的对象结构极其多变时，NoSQL数据库是唯一的选择。然而，它们通常被选择用于扩展读/写操作的方式，以及更普遍的，在分布式环境中的性能优势。它们的功能将在下一节中讨论，该节将它们与关系数据库进行比较。

图数据模型是完全无结构文档的极端情况。整个数据库是一个图，查询可以在其中添加、更改和删除图文档。

在这种情况下，我们有两种类型的文档：节点和关系。虽然关系有一个定义良好的结构（通过关系连接的节点的主键，加上关系名称），但节点没有任何结构，因为属性及其值是在节点更新操作中一起添加的。图数据模型是为了表示人们及其操作的对象（媒体、帖子等）的特征以及他们在*社交应用*中的关系而设计的。Gremlin语言是为了查询图数据模型而专门设计的。我们不会在本章中讨论这个问题，但在*进一步阅读*部分有相关参考资料。

在本章剩余的部分，我们将详细分析NoSQL数据库，这些部分专门用于描述Azure Cosmos DB并将其与关系数据库进行比较。

# Redis

Redis是一种基于键值对的分布式并发内存存储，支持分布式队列。它可以作为永久性内存存储，也可以作为数据库数据的Web应用程序缓存。或者，它可以渲染内容变化不大的页面。

Redis还可以用于存储Web应用程序的用户会话数据。实际上，ASP.NET MVC、Pages和WebForms支持会话数据以克服HTTP协议无状态的事实。更具体地说，用户数据在页面变化之间保持不变，并存储在Redis等服务器端存储中，并通过存储在cookie中的会话键进行索引。

与云中的Redis服务器交互通常基于REST接口；也就是说，每个Redis资源通过HTTP GET在URI上访问，命令通过查询字符串传递，而答案以JSON格式返回。然而，所有流行的语言中都有提供易于使用的接口的客户端。.NET和.NET Core的客户端可以通过`StackExchange.Redis` NuGet包获得。`StackExchange.Redis`客户端的基本操作已在[https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics)中记录，而完整文档可以在[https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis)找到。

在Azure上定义Redis服务器的用户界面相当简单：

![图片](img/df820d64-6224-4523-94ef-2c30f6a9e50d.png)

价格层级下拉菜单允许我们选择可用的内存/复制选项之一。一个快速入门指南，解释如何使用Azure Redis凭据和`StackExchange.Redis` .NET Core客户端的URI，可以在[https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart)找到。

# 磁盘内存

所有云都提供可扩展和冗余的通用磁盘内存，您可以用作虚拟机中的虚拟磁盘或作为外部文件存储。Azure *存储帐户* 磁盘空间也可以在表和队列中进行结构化。然而，这两个存储选项仅支持向后兼容，因为Azure NoSQL数据库比表更好，Azure Redis比Azure存储队列更好：

![](img/67b90062-5d45-4cec-8625-9fa827a64189.png)

在本章的剩余部分，我们将重点关注NoSQL数据库以及它们与关系数据库的不同之处。接下来，我们将探讨如何在这两者之间进行选择。

# 在结构化存储或NoSQL存储之间进行选择

在上一节中，我们提到当数据几乎没有任何预定义结构时，应该优先考虑NoSQL数据库。实际上，非结构化数据可以在关系数据库中表示，因为元组`t`的可变属性可以放置在一个包含属性名称、属性值和`t`的外部键的连接表中。然而，问题是性能。事实上，属于单个对象的属性值会散布在可用的内存空间中。在一个小型数据库中，“散布在可用的内存空间中”意味着距离较远但位于同一磁盘上；在一个大型数据库中，这意味着距离较远但位于不同的磁盘单元中；在分布式云环境中，这意味着距离较远，可能位于不同的——甚至地理上分布的——服务器上。

另一方面，NoSQL数据库不仅将可变属性与其所有者保持接近，而且由于它们允许相关对象嵌套在属性和集合中，它们还将一些相关对象保持接近。

因此，我们可以得出结论，当通常一起访问的表可以存储在内存附近时，关系数据库表现良好。另一方面，NoSQL数据库自动确保相关数据保持接近，因为每个条目都将其相关的大部分数据作为嵌套对象包含在内。因此，当NoSQL数据库分布到不同的内存以及不同的地理上分布的服务器上时，它们的表现更好。

不幸的是，扩展存储写操作的唯一方法是将集合条目根据*分片键*的值分散到几个服务器上。例如，我们可以将所有以A开头的用户名记录放在一个服务器上，以B开头的记录放在另一个服务器上，依此类推。这样，不同起始字母的用户名的写操作可以并行执行，确保写吞吐量随着服务器数量的线性增长。

然而，如果一个*分片*集合与几个其他集合相关联，不能保证相关记录会被放置在同一个服务器上。此外，在不使用集合分片的情况下，将不同的集合放在不同的服务器上可以线性地增加写入吞吐量，直到达到每个服务器单个集合的极限，但这并不能解决在检索或更新通常一起处理的数据时被迫在多个服务器上执行多个操作的问题。

如果必须以事务性方式访问相关分布式对象，并且必须确保结构约束（如外部键约束）不被违反，这个问题将对性能造成灾难性的影响。在这种情况下，所有相关对象必须在事务期间被阻塞，防止其他请求在整个耗时的分布式操作期间访问它们。

NoSQL数据库不受此问题的影响，并且通过分片以及随之而来的写入扩展输出表现更好。这是因为它们不会将相关数据分布到不同的存储单元，而是将它们存储为同一数据库条目的嵌套对象。

在NoSQL数据库设计中，我们总是试图将所有可能一起处理的相关对象放入一个单独的条目中。访问频率较低的相关对象被放置在不同的条目中。由于外部键约束不是自动强制执行的，并且NoSQL事务非常灵活，开发者可以在性能和一致性之间选择最佳折衷方案。

值得注意的是，在某些情况下，关系数据库在分片方面表现良好。一个典型的例子是多租户应用程序。在多租户应用程序中，所有条目集合可以被划分为不重叠的集合，称为**租户**。只有属于同一租户的条目可以相互引用，因此如果所有集合都根据它们的对象租户以相同的方式分片，所有相关记录最终都会落在同一个分片上，即同一个服务器上，并且可以有效地进行导航。

在云中，多租户应用程序并不罕见，因为向几个不同用户提供相同服务的所有应用程序通常都作为多租户应用程序实现，其中每个租户对应一个用户订阅。因此，关系数据库被设计在云中工作，例如Azure SQL Server，并且通常为多租户应用程序提供分片选项。通常，分片不是云服务，必须使用数据库引擎命令定义。在这里，我们不会描述如何使用Azure SQL Server定义分片，但*进一步阅读*部分包含了一个指向官方Microsoft文档的链接。

总之，关系数据库提供了独立于实际存储方式的数据的纯粹逻辑视图，并使用声明性语言来查询和更新它们。这简化了开发和系统维护，但在需要写入扩展的分布式环境中可能会引起性能问题。在NoSQL数据库中，您必须手动处理更多关于如何存储数据的细节，以及所有更新和查询操作的一些过程性细节，但这也允许您在需要读取和写入扩展的分布式环境中优化性能。

在下一节中，我们将探讨Azure Cosmos DB，这是Azure的主要NoSQL服务。

# Azure Cosmos DB – 管理跨大陆数据库的机会

Azure Cosmos DB是Azure的主要NoSQL服务。Azure Cosmos DB拥有自己的接口，它是SQL的一个子集，但可以用MongoDB接口进行配置。它也可以配置为图数据模型，可以用Gremlin查询。Cosmos DB允许进行复制以实现容错和读取扩展，副本可以地理分布以优化通信性能。此外，您可以指定所有副本放置在哪个数据中心。用户还可以选择启用所有副本的写入功能，以便在写入的地理区域立即可用。通过分片实现写入扩展，用户可以通过定义哪些属性用作分片键来配置它。

您可以通过在Azure门户搜索栏中键入Cosmos DB并点击添加来定义一个Cosmos DB账户。以下页面将出现：

![图片](img/83d9ca9f-5a23-4509-8a8a-5487e31c2409.png)

您选择的账户名称在资源URI中用作`{账户名称}.documents.azure.com`。API下拉菜单允许您选择您喜欢的接口类型（SQL、MongoDB或Gremlin）。然后，您可以决定主数据库将放置在哪个数据中心，以及您是否希望启用地理分布复制。一旦启用了地理分布复制，您可以选择您想要使用的副本数量以及它们放置的位置。

最后，多区域写入切换功能允许您在地理分布的副本上启用写入。如果您不这样做，所有写入操作都将路由到主数据中心。

1.  **访问资源**：一旦您创建了账户，选择数据探索器以在内部创建数据库和集合：

![图片](img/3893d21f-a74e-491d-9845-4563487b5afb.png)

1.  **创建集合**：由于数据库只有名称而没有配置，您可以直接添加集合，然后选择您希望放置它的数据库：

![图片](img/6e63a071-b4a1-48b4-80b2-db48df1aff90.png)

在这里，您可以决定数据库和集合名称以及用于分片（分区键）的属性。由于NoSQL条目是对象树，属性名称指定为路径。您还可以添加值必须唯一的属性。然而，唯一性ID是在每个分片中检查的，因此此选项仅在特定情况下有用，例如多租户应用程序（其中每个租户都包含在单个分片中）。费用取决于您选择的集合吞吐量。

1.  **将所有资源参数针对您的需求进行定位**：吞吐量以每秒请求单位表示，其中每秒请求单位定义为每秒执行1 KB读取时的吞吐量。因此，如果您检查“配置数据库吞吐量”选项，所选的吞吐量将共享给整个数据库，而不是作为单个集合保留。

1.  **获取连接信息**：通过选择“键”菜单，您将看到连接到您的应用中的Cosmos DB账户所需的所有信息：

![图片](img/2d565e3b-bb79-41aa-aa36-09615968a7c7.png)

1.  **连接信息页面**：在这里，您将找到账户URI和两个连接键，这些键可以互换使用来连接到账户：

![图片](img/503dcd27-b61c-450e-871a-0232bedf3cab.png)

此外，还有一些具有只读权限的键。每个键都可以重新生成，并且每个账户都有两个等效的键，以便此操作可以高效地处理；也就是说，当一个键更改时，另一个键保持不变。因此，现有的应用程序可以在升级到新键之前继续使用另一个键。

1.  **选择默认一致性级别**：通过选择“默认一致性”，您可以选择要应用于所有集合的默认复制一致性：

![图片](img/32f7d541-7f05-4246-962b-6f83293c0d75.png)

此默认值可以在每个集合中覆盖，无论是从数据资源管理器还是通过编程方式。读写操作中的一致性问题是数据复制的结果。更具体地说，如果读取操作在不同的副本上执行，并且这些副本接收到了不同的部分更新，那么各种读取操作的结果可能是不一致的。

以下是可以用的可用一致性级别。这些级别已按从最弱到最强排序：

+   **最终一致性**：经过足够的时间后，如果没有进一步的写操作，所有的读取将收敛并应用所有的写操作。

+   **一致前缀**：所有写操作都在所有副本上以相同的顺序执行。因此，如果有`n`个写操作，每个读取都与应用前`m`个写操作的结果一致，其中`m`小于或等于`n`。

+   **会话一致性**：这与一致性前缀相同，但也保证了每个写入者在其所有后续读取操作中都能看到其自己的写入结果，并且每个读者的后续读取都是一致的（要么是相同的数据库，要么是其更新版本）。

+   **有限不一致性**：这与延迟时间`Delta`或操作次数`N`相关联。每次读取都会看到在时间`Delta`之前（或最后`N`个操作之前）执行的所有写入操作的结果。也就是说，其读取与所有写入的结果收敛，最大时间延迟为`Delta`（或最大操作延迟为`N`）。

+   **强一致性**：这是结合了`Delta = 0`的有限不一致性。在这里，每次读取都反映了所有之前的写入操作的结果。

可以获得最强的一致性，但会损害性能。默认情况下，一致性设置为Session，这是在一致性和性能之间的一种良好折衷。在应用程序中处理较低级别的一致性比较困难，并且通常只有在会话是只读或只写的情况下才可接受。

如果你选择数据探索器中的“缩放和设置”选项，你可以配置要索引哪些路径以及将哪种索引应用于每个路径的每个数据类型。配置由一个JSON对象组成。让我们分析其各种属性：

[PRE0]

如果你将`indexingMode`设置为`none`而不是`consistent`，则不会生成索引，集合可以用作以集合主键为索引的键值字典。当`automatic`设置为`true`时，所有文档属性都会自动索引：

[PRE1]

“包含的路径”中的每个条目指定了一个路径模式，例如`/subpath1/subpath2/?`（设置仅应用于`/subpath1/subpath2/`属性）或`/subpath1/subpath2/*`（设置应用于以`/subpath1/subpath2/`开头的所有路径）。

当设置必须应用于集合属性中包含的子对象时，模式包含`[]`符号；例如，`/subpath1/subpath2/[]/?`，`/subpath1/subpath2/[]/childpath1/?`等等。设置指定要应用于每个数据类型（字符串、数字、地理点等）的索引类型。范围索引用于比较操作，而如果需要进行相等比较，则散列索引更有效。

可以指定精度，即所有索引键中使用的最大字符数或数字数。`-1`表示无限制。对于字符串，`-1`是可以接受的，而对于数字，应使用有限的精度。另一方面，使用有限的精度与字符串可能会导致意外的行为，因为字符串键会被截断。在散列索引中，精度可能从1到8不等，而在范围索引中，精度可能从1到100不等：

[PRE2]

`excludedPaths`中包含的路径根本不会被索引。索引设置也可以通过编程方式指定。

在这里，你有两种连接到 Cosmos DB 的选项：使用你首选编程语言的官方客户端版本，或者使用 Cosmos DB 的 Entity Framework Core 提供器，截至本书编写时，它仍在预览中。在接下来的小节中，我们将探讨这两种选项。然后，我们将通过一个实际示例描述如何使用 Cosmos DB 的 Entity Framework Core 提供器。

# Cosmos DB 客户端

.NET Core 的 Cosmos DB 客户端可以通过 `Microsoft.Azure.DocumentDB.Core` NuGet 包获得。它提供了对所有 Cosmos DB 功能的完全控制，而 Cosmos DB Entity Framework 提供器更容易使用，但隐藏了一些 Cosmos DB 的特性。按照以下步骤通过官方 Cosmos DB .NET Core 客户端与 Cosmos DB 进行交互：

1.  任何操作都需要创建一个客户端对象：

[PRE3]

1.  不要忘记，当不再需要客户端时，必须通过调用其 `Dispose` 方法（或通过将引用它的代码封装在 `using` 语句中）来释放客户端。

1.  然后，你可以使用以下代码获取数据库的引用并创建它（如果它不存在）：

[PRE4]

1.  最后，你可以使用以下代码获取集合的引用或创建它（如果它不存在）：

[PRE5]

1.  在创建集合期间，你可以传递一个 `option` 对象，其中你可以指定一致性级别、如何索引属性以及所有其他集合功能。

1.  然后，你必须定义与你在集合中需要操作的 JSON 文档结构相对应的 .NET 类。你也可以使用 `JsonProperty` 属性将类属性名称映射到 JSON 名称，如果它们不相等的话。

1.  一旦你有了所有必要的类，你可以使用客户端方法来添加、更新和写入集合条目，以及客户端 `CreateDocumentQuery` 方法，它返回一个 `IQueryable` 值，你可以使用 LINQ 来查询。

当你读取文档，进行一些修改，然后尝试上传你修改后的文档版本时，其他人可能已经修改了相同的文档。通常，只有当没有其他人修改了相同的文档时，你才需要执行更新。这可以通过 `_etag` 属性来完成，Cosmos DB 会自动将其附加到每个文档上。此属性值在每次更新后都会改变，因此你需要遵循以下步骤：

1.  将 `_etag` JSON 属性映射到你的 .NET 类的一个属性上，这样在读取文档时你就能得到它的值。

1.  将 `_etag` 属性的原始值作为传递给 `ReplaceDocumentAsync` 客户端方法的 `option` 对象中 `AccessCondition` 属性的值。

1.  如果 `_etag` 发生了变化，则调用 `ReplaceDocumentAsync`，中止操作并返回异常。

此外，还有 `MvcControlsToolkit.Business.DocumentDB` NuGet 包，它简化并自动化了 `Microsoft.Azure.DocumentDB.Core` 库所需的所有操作，并克服了 Cosmos DB SQL 的一些限制。*进一步阅读*部分包含了对 `Microsoft.Azure.DocumentDB.Core` 和 `MvcControlsToolkit.Business.DocumentDB` 的教程的引用。

# Cosmos DB 实体框架核心提供程序

Cosmos DB 实体框架核心提供程序包含在 `Microsoft.EntityFrameworkCore.Cosmos` NuGet 包中。一旦将其添加到项目中，你就可以以与在 [第 6 章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml) 中使用 SQL Server 提供程序时类似的方式进行操作，但在一些方面有所不同。让我们来看看：

1.  由于 Cosmos DB 数据库没有结构需要更新，因此没有迁移。相反，它有一个确保数据库以及所有必要的集合被创建的方法：

[PRE6]

1.  `DbSet<T>` 和 `DBContext` 属性并不一一对应数据库集合，因为集合可以包含具有不同结构的对象，所以几个 `DbSet<T>` 属性可以映射到同一个集合。此外，默认情况下，所有 `DbSet<T>` 属性都映射到唯一的集合，因为这是最经济的选项，但你可以通过以下配置指令显式指定要将某些实体映射到哪个集合来覆盖此默认设置：

[PRE7]

1.  实体类上唯一有用的注解是 `Key` 属性，当主键被称作 `Id` 时，该属性变得强制使用。

1.  主键必须是字符串，并且不能自动递增，以避免在分布式环境中的同步问题。可以通过生成 GUID 并将其转换为字符串来确保主键的唯一性。

1.  当定义实体之间的关系时，你可以指定一个实体或实体集合属于另一个实体，在这种情况下，它将与父实体一起存储。

在下一节中，我们将探讨 Cosmos DB 实体框架提供程序的使用。

# 用例 - 存储数据

现在我们已经学会了如何使用 NoSQL，我们必须决定 NoSQL 数据库是否适合我们的 WWTravelClub 应用程序。我们需要存储以下数据系列：

+   **关于可用目的地和套餐的信息**：对此数据的相关操作主要是读取，因为套餐和目的地不经常改变。然而，它们必须尽可能快地从世界各地访问，以确保用户浏览可用选项时的良好用户体验。因此，一个具有地理分布副本的分布式关系数据库是可能的，但不是必要的，因为套餐可以存储在其目的地内的更便宜的 NoSQL 数据库中。

+   **目的地评论**：在这种情况下，分布式写入操作有不可忽视的影响。此外，大多数写入都是添加，因为评论通常不会被更新。添加操作从分片中获得很大好处，并且不会像更新那样引起一致性问题。因此，此数据的最佳选择是一个 NoSQL 集合。

+   **预留**：在这种情况下，一致性错误是不可接受的，因为它们可能导致超订。读取和写入有相似的影响，但我们需要可靠的交易和良好的一致性检查。幸运的是，数据可以组织在一个多租户数据库中，其中租户是目的地，因为不同目的地的预订信息完全无关。因此，我们可能使用分片 SQL Azure 数据库实例。

总之，对于第一和第二点中的数据，最佳选择是 Cosmos DB，而对于第三点，最佳选择是 Azure SQL Server。实际应用程序可能需要对所有数据操作及其频率进行更详细的分析。在某些情况下，为各种可能的选项实现原型并在所有这些上执行典型工作负载的性能测试是值得的。

在本节的剩余部分，我们将把我们在[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)，“使用C#与数据交互 - Entity Framework Core”中查看的 destinations/packages 数据层迁移到 Cosmos DB。

# 使用 Cosmos DB 实现目的地/包数据库

让我们继续到我们在[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)，“使用C#与数据交互 – Entity Framework Core”中构建的数据库示例，按照以下步骤将其迁移到 Cosmos DB：

1.  首先，我们需要复制 WWTravelClubDB 项目，并将 `WWTravelClubDBCosmo` 设置为新根文件夹。

1.  打开项目并删除迁移文件夹，因为不再需要迁移了。

1.  我们需要替换 SQL Server Entity Framework 提供程序与 Cosmos DB 提供程序。为此，转到管理 NuGet 包并卸载 `Microsoft.EntityFrameworkCore.SqlServer` NuGet 包。然后，安装 `Microsoft.EntityFrameworkCore.Cosmos` NuGet 包。

1.  然后，对 `Destination` 和 `Package` 实体执行以下操作：

    +   删除所有数据注释。

    +   将 `[Key]` 属性添加到它们的 `Id` 属性，因为这对于 Cosmos DB 提供程序是强制性的。

+   +   将 `Package` 和 `Destination` 的 `Id` 属性类型以及 `PackagesListDTO` 类从 `int` 转换为 `string`。我们还需要将 `Package` 中的 `DestinationId` 外部引用和在 `PackagesListDTO` 类中的 `DestinationId` 转换为 `string`。实际上，对于分布式数据库中的键，最佳选择是从 GUID 生成的字符串，因为当表数据分布在多个服务器之间时，很难维护一个身份计数器。

1.  在 `MainDBContext` 文件中，我们需要指定与目的地相关的包必须存储在目的地文档本身中。这可以通过在 `OnModelCreating` 方法中将 Destination-Package 关系配置替换为以下代码来实现：

[PRE8]

1.  在这里，我们必须将 `HasMany` 替换为 `OwnsMany`。没有 `WithOne` 的等效项，因为一旦实体被拥有，它必须只有一个所有者，而 `MyDestination` 属性包含对父实体的指针的事实可以从其类型中看出。Cosmos DB 也允许使用 `HasMany`，但在这种情况下，两个实体并不是嵌套在一另一个中。还有用于在实体内部嵌套单个实体的 `OwnOne` 配置方法。

1.  实际上，`OwnsMany` 和 `OwnsOne` 都适用于关系数据库，但在这个案例中，`HasMany` 和 `HasOne` 之间的区别在于，子实体会自动包含在返回其父实体的所有查询中，无需指定 `Include` LINQ 子句。然而，子实体仍然存储在单独的表中。

1.  `LibraryDesignTimeDbContextFactory` 必须修改为使用 Cosmos DB 连接数据，如下面的代码所示：

[PRE9]

1.  最后，在我们的测试控制台中，我们必须明确使用 GUIDS 创建所有实体主键：

[PRE10]

在这里，我们调用 `context.Database.EnsureCreated()` 而不是应用迁移，因为我们只需要创建数据库。一旦数据库和集合被创建，我们就可以从 Azure Portal 调整它们的设置。希望未来版本的 Cosmos DB Entity Framework Core 提供程序将允许我们指定所有集合选项。

1.  最后，以 `context.Packages.Where...` 开头的最终查询必须进行修改，因为查询不能从嵌套在其他文档中的实体开始（在我们的情况下，`Package` 实体）。因此，我们必须从我们的 `DBContext` 中的唯一根 `DbSet<T>` 属性开始我们的查询，即 `Destinations`。我们可以借助 `SelectMany` 方法从列出外部集合切换到列出所有内部集合，该方法执行所有嵌套 `Packages` 集合的逻辑合并。然而，由于 `CosmosDB` SQL 不支持 `SelectMany`，我们必须使用 `AsIenumerable()` 在客户端强制模拟 `SelectMany`，如下面的代码所示：

[PRE11]

1.  查询的其余部分保持不变。如果您现在运行项目，应该看到与 SQL Server 的情况相同的输出（除了主键值之外）。

1.  执行程序后，前往您的 Cosmos DB 账户。您应该看到以下类似的内容：

![图片](img/32c20c41-6c2d-466e-9048-f45ae8d0d406.png)

包已经按照要求嵌套在其目的地内部，Entity Framework Core 创建了一个与 `DBContext` 类同名的唯一集合。

如果您想在不用完所有免费 Azure Portal 信用额度的情况下继续实验 Cosmos DB 开发，您可以安装此链接提供的 Cosmos DB 模拟器：[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)。

# 摘要

在本章中，我们探讨了 Azure 中可用的主要存储选项，并学习了何时使用它们。然后，我们比较了关系型数据库和 NoSQL 数据库。我们指出，关系型数据库提供自动一致性检查和事务隔离，但 NoSQL 数据库更便宜，并提供更好的性能，尤其是在平均负载中分布式写入占很大比例时。

然后，我们介绍了 Azure 的主要 NoSQL 选项 Cosmos DB，并解释了如何配置它以及如何与客户端连接。

最后，我们学习了如何使用 Entity Framework Core 与 Cosmos DB 交互，并查看了一个基于 WWTravelClubDB 用例的实用示例。在这里，我们学习了如何为应用程序中涉及的所有数据家族决定使用关系型数据库还是 NoSQL 数据库。这样，您可以选择确保数据一致性、速度和每个应用程序中数据并行访问之间最佳折衷的数据存储类型。

在下一章中，我们将学习有关 Serverless 和 Azure Functions 的所有内容。

# 问题

1.  Redis 是否是关系型数据库的有效替代品？

1.  NoSQL 数据库是否是关系型数据库的有效替代品？

1.  在关系型数据库中，哪种操作更难进行扩展？

1.  NoSQL 数据库的主要弱点是什么？它们的主要优势是什么？

1.  您能否列出所有 Cosmos DB 的一致性级别？

1.  我们可以使用自增整数键与 Cosmos DB 一起使用吗？

1.  哪种 Entity Framework 配置方法用于在相关父文档中存储实体？

1.  使用 Cosmos DB 是否可以有效地搜索嵌套集合？

# 进一步阅读

+   在本章中，我们没有讨论如何使用 SQL Azure 定义分片。如果您想了解更多信息，请参阅官方文档链接：[https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction)。

+   本章详细介绍了 Cosmos DB，但更详细的信息可以在官方文档中找到：[https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/)。

+   以下是对 Cosmos DB 支持的 Gremlin 语言的参考：[http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps)。

+   以下是对 Cosmos DB 图数据模型的通用描述：[https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction)。

+   如何使用 Cosmos DB 的官方 .NET 客户端的详细信息可以在 [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started) 找到。关于本章中提到的 `MvcControlsToolkit.Business.DocumentDB` NuGet 包的良好介绍是 DNCMagazine 第 34 期中的 *Fast Azure Cosmos DB Development with the DocumentDB Package* 文章。这可以从 [http://www.dotnetcurry.net/s/dnc-mag-34th-single](http://www.dotnetcurry.net/s/dnc-mag-34th-single) 下载。
