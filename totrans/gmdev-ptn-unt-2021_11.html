<html><head></head><body>
        

                            
                    Decoupling Components with the Observer Pattern
                
            
            
                
<p class="mce-root">A common challenge in Unity development is to find elegant ways to decouple components from each other. It's a significant hurdle to overcome when writing code in the engine as it offers us so many ways to reference components through the API and the Inspector directly. But this flexibility can come with a price, and it can make your code fragile since, in some instances, it can take a single missing reference to break your game.</p>
<p class="mce-root">So, in this chapter, we will use the Observer pattern to set up relationships with core components. These relationships will be mapped by assigning objects the role of the Subject or Observer. This approach will not altogether remove coupling between our components but will loosen it up and organize it logically. It will also establish an event handling system with a one-to-many structure, which is precisely what we need to implement in the use case presented in this chapter.</p>
<p>If you are looking for a way to decouple objects from each other with events in a many-to-many relationship, please check out <a href="75ba1c8b-0c32-4001-ae33-d9d79e276408.xhtml">Chapter 6</a>, <em>Managing Game Events with the Event Bus</em>.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding the Observer pattern</li>
<li>Decoupling core components with the Observer pattern</li>
<li>Implementing the Observer pattern </li>
<li>Reviewing alternative solutions</li>
</ul>
<h1 id="uuid-d06da9e3-2ff4-4b64-bc19-ba400ec11c06">Technical requirements</h1>
<p>The code files for this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09</a>.</p>
<p class="mce-root">Check out the following video to see the code in action: <a href="https://bit.ly/3xDlBDa">https://bit.ly/3xDlBDa</a>.</p>
<h1 id="uuid-c9eb3ac4-a42a-4d01-846f-bd5924fd2e7e">Understanding the Observer pattern</h1>
<p>The core purpose of the Observer pattern is to establish a one-to-many relationship between objects in which one acts as the subject while the others take the role of observers. The subject then assumes the responsibility of notifying the observers when something inside itself changes and might concern them.</p>
<p class="mce-root">It's somewhat similar to a publisher and subscriber relationship, in which objects subscribe and listen for specific event notifications. The core difference is that the subject and observers are aware of each other in the Observer pattern, so they are still lightly coupled together.</p>
<p class="mce-root">Let's review a UML diagram of a typical implementation of the Observer pattern to see how this might work when implemented in code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/03b549cd-caed-4ef5-a6f2-951802a723de.png" style="width:27.42em;height:21.50em;"/></p>
<p>Figure 9.1 – UML diagram of the Observer pattern</p>
<p>As you can see, the Subject and the Observer both have respective interfaces that they implement, but the most important one to analyze is <kbd>ISubject</kbd>, which includes the following methods:</p>
<ul>
<li><kbd>AttachObserver()</kbd>: This method allows you to add an observer object to the list of observers to notify.</li>
<li><kbd>DetachObserver()</kbd>: This method removes an observer from the list of observers.</li>
<li><kbd>NotifyObservers()</kbd>: This method notifies all the objects that have been added to the subject's list of observers.</li>
</ul>
<p>An object that takes the role of Observer must implement a public method called <kbd>Notify()</kbd>, which will be used by the subject to notify it when it changes states.</p>
<h2 id="uuid-a821c72d-be80-49b0-835e-d3445d7c2f73">Benefits and drawbacks of the Observer pattern</h2>
<p>These are some of the benefits of the Observer pattern:</p>
<ul>
<li><strong>Dynamism</strong>: The Observer permits the Subject to add as many objects as it necessitates as Observers. But it can also remove them dynamically at runtime. </li>
<li><strong>One-to-Many</strong>: The main benefit of the Observer pattern is that it elegantly solves the problem of implementing an event handling system in which there's a one-to-many relationship between objects.</li>
</ul>
<p>The following are some potential drawbacks of the Observer pattern:</p>
<ul>
<li><strong>Disorder</strong>: The Observer pattern doesn't guarantee the order in which Observers get notified. So, if two or more Observer objects share dependencies and must work together in a specific sequence, the Observer pattern, in its native form, is not designed to handle that type of execution context. </li>
<li><strong>Leaking</strong>:<strong> </strong>The Observer can cause memory leaks as the subject holds strong references to its observers. If it's implemented incorrectly and the Observer objects are not correctly detached and disposed of when they are not needed anymore, it could cause issues with garbage collection, and some resources will not be liberated.</li>
</ul>
<p>To understand the potential memory leaking drawback indicated here, I recommend reading the following Wikipedia article on the subject matter: <a href="https://en.wikipedia.org/wiki/Lapsed_listener_problem">https://en.wikipedia.org/wiki/Lapsed_listener_problem</a>.<br/>
<br/>
But take into account that, like anything related to optimization, it's contextual, so you should profile your code before optimizing for potential performance issues.</p>
<h2 id="uuid-608f35b2-a451-4c0a-a7ce-cd6199cba8fc">When to use the Observer pattern</h2>
<p>The advantage of the Observer pattern is that it solves specific problems related to one-to-many relationships between objects. So, if you have a core component that often changes states and has many dependencies that need to react to those changes, then the Observer pattern permits you to define a relationship between those entities and a mechanism that enables them to be notified.</p>
<p class="mce-root">Therefore, if you are unsure when to use the Observer pattern, you should analyze the relationship between your objects to determine if this pattern is well-suited for the problem you are trying to solve.</p>
<h1 id="uuid-80a369eb-9f06-45fa-8b65-42305073ede9">Decoupling core components with the Observer pattern</h1>
<p class="mce-root">The core ingredient of our game is the racing bike. It's the entity in our scene that changes states and updates its properties the most often as it's under the player's control while traveling around the world and interacting with other entities. It has several dependencies to manage, such as the main camera that follows it and the HUD that displays its current speed.</p>
<p class="mce-root">The racing bike is the main subject of our game, and many systems must observe it so that they can update themselves when it changes states. For instance, every time the bike collides with an obstacle, the HUD must update the current value of the shield's health, and the camera displays a full screen shader that darkens the edges of the screen to showcase the diminishing endurance.</p>
<p class="mce-root">This type of behavior is easy to implement in Unity. We could have <kbd>BikeController</kbd> tell <kbd>HUDController</kbd> and <kbd>CameraController</kbd> what to do when it takes damage. But for this approach to work, <kbd>BikeController</kbd> must be aware of the public methods to call on each controller.</p>
<p class="mce-root">As you can imagine, this doesn't scale well since as the complexity of <kbd>BikeController</kbd> grows, the more calls to its dependencies we will have to manage. But with the Observer pattern, we are going to break this coupling between the controllers. First, we will give each component a role; <kbd>BikeController</kbd> will become a subject and be responsible for managing a list of dependencies and notifying them when necessary.</p>
<p class="mce-root">The HUD and Camera controllers will act as observers of <kbd>BikeController</kbd>. Their core responsibility will be to listen for notifications coming from <kbd>BikeController</kbd> and act accordingly. <kbd>BikeController</kbd> doesn't tell them what to do; it just tells them something has changed and lets them react to it at their discretion.</p>
<p>The following diagram illustrates the concept we just reviewed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/da2d43e3-3686-46c3-aafa-57d46f4aaa09.png" style="width:40.92em;height:22.42em;"/></p>
<p>Figure 9.2 – Illustration of the controllers observing a subject</p>
<p>As we can see, we can have as many controllers observing the bike (subject) as we need. In the next section, we will take these concepts and translate them into code.</p>
<h1 id="uuid-6ab41209-48eb-4e80-bf1f-3640b14869f4">Implementing the Observer pattern</h1>
<p class="mce-root">Now, let's implement the Observer pattern in a simple way that can be reused in various contexts:</p>
<ol>
<li class="mce-root">We are going to start this code example by implementing the two elements of the pattern. Let's begin with the <kbd>Subject</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Observer<br/>{<br/>    public abstract class Subject : MonoBehaviour<br/>    {<br/>        private readonly <br/>            ArrayList _observers = new ArrayList();<br/><br/>        public void Attach(Observer observer)<br/>        {<br/>            _observers.Add(observer);<br/>        }<br/><br/>        public void Detach(Observer observer)<br/>        {<br/>            _observers.Remove(observer);<br/>        }<br/><br/>        public void NotifyObservers()<br/>        {<br/>            foreach (Observer observer in _observers)<br/>            {<br/>                observer.Notify(this);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>Subject</kbd> abstract class has three methods. The first two, <kbd>Attach()</kbd> and <kbd>Detach()</kbd>, are responsible for adding or removing an observer object from a list of observers, respectively. The third method, <kbd>NotifyObservers()</kbd> has the responsibility of looping through the list of observer objects and calling their public method, called <kbd>Notify()</kbd>. This will make sense when we implement concrete observer classes in the upcoming steps.</p>
<ol start="2">
<li>Next up is the <kbd>Observer</kbd> abstract class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Observer<br/>{<br/>    public abstract class Observer : MonoBehaviour<br/>    {<br/>        public abstract void Notify(Subject subject);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Classes that wish to become observers have to inherit this <kbd>Observer</kbd> class and implement the abstract method named <kbd>Notify()</kbd>, which receives the subject as a parameter.</p>
<ol start="3">
<li>Now that we have our core ingredients, let's write a skeleton <kbd>BikeController</kbd> class that will act as our subject. However, because it's so long, we will split it into three segments. The first segment is just initialization code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Observer<br/>{<br/>    public class BikeController : Subject<br/>    {<br/>        public bool IsTurboOn<br/>        {<br/>            get; private set;<br/>        }<br/><br/>        public float CurrentHealth<br/>        {<br/>            get { return health; }<br/>        } <br/><br/>        private bool _isEngineOn;<br/>        private HUDController _hudController;<br/>        private CameraController _cameraController;<br/><br/>        [SerializeField]<br/>        private float health = 100.0f;<br/><br/>        void Awake()<br/>        {<br/>            _hudController = <br/>                gameObject.AddComponent&lt;HUDController&gt;();<br/><br/>            _cameraController = <br/>                (CameraController) <br/>                FindObjectOfType(typeof(CameraController));<br/>        }<br/><br/>        private void Start()<br/>        {<br/>            StartEngine();<br/>        }<br/></pre>
<p style="padding-left: 60px">The following segment is important because we are attaching our observers when <kbd>BikeController</kbd> is enabled but also detaching them when it's disabled; this avoids us having to hold on to references we don't need anymore:</p>
<pre style="padding-left: 120px">void OnEnable()<br/>{<br/>    if (_hudController) <br/>        Attach(_hudController);<br/><br/>    if (_cameraController) <br/>        Attach(_cameraController);<br/>}<br/><br/>void OnDisable()<br/>{<br/>    if (_hudController) <br/>        Detach(_hudController);<br/><br/>    if (_cameraController) <br/>        Detach(_cameraController);<br/>}</pre>
<p style="padding-left: 60px">And for the final part, we have some basic implementations of core behaviors. Note that we only notify the observers when the bike's parameters get updated when it takes damage, or when its turbocharger is activated:</p>
<pre style="padding-left: 60px">        private void StartEngine()<br/>        {<br/>            _isEngineOn = true;<br/>            <br/>            NotifyObservers();<br/>        }<br/><br/>        public void ToggleTurbo()<br/>        {<br/>            if (_isEngineOn) <br/>                IsTurboOn = !IsTurboOn;<br/><br/>            NotifyObservers();<br/>        }<br/><br/>        public void TakeDamage(float amount)<br/>        {<br/>            health -= amount;<br/>            IsTurboOn = false;<br/><br/>            NotifyObservers();<br/><br/>            if (health &lt; 0)<br/>                Destroy(gameObject);<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px"><kbd>BikeController</kbd> never calls <kbd>HUDController</kbd> or <kbd>CameraController</kbd> directly; it only notifies them that something has changed – it never tells them what to do. This is important because the observers can independently choose how to behave when being notified.  Therefore, they have been decoupled from the subject to a certain degree.</p>
<ol start="4">
<li>Now, let's implement some observers and see how they behave when the subject signals them. We'll begin with <kbd>HUDController</kbd>, which has the responsibility of displaying the user interface:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Observer {<br/>    public class HUDController : Observer {<br/><br/>        private bool _isTurboOn;<br/>        private float _currentHealth;<br/>        private BikeController _bikeController;<br/><br/>        void OnGUI() {<br/>            GUILayout.BeginArea (<br/>                new Rect (50,50,100,200));<br/>            GUILayout.BeginHorizontal ("box");<br/>            GUILayout.Label ("Health: " + _currentHealth);<br/>            GUILayout.EndHorizontal ();<br/><br/>            if (_isTurboOn) {<br/>                GUILayout.BeginHorizontal("box");<br/>                GUILayout.Label("Turbo Activated!");<br/>                GUILayout.EndHorizontal();<br/>            }<br/><br/>            if (_currentHealth &lt;= 50.0f) {<br/>                GUILayout.BeginHorizontal("box");<br/>                GUILayout.Label("WARNING: Low Health");<br/>                GUILayout.EndHorizontal();<br/>            }<br/><br/>            GUILayout.EndArea ();<br/>        }<br/><br/>        public override void Notify(Subject subject) {<br/>            if (!_bikeController)<br/>                _bikeController = <br/>                    subject.GetComponent&lt;BikeController&gt;();<br/><br/>            if (_bikeController) {<br/>                _isTurboOn = <br/>                    _bikeController.IsTurboOn;<br/>                <br/>                _currentHealth = <br/>                    _bikeController.CurrentHealth;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">The <kbd>Notify()</kbd> method of <kbd>HUDController</kbd> receives a reference to the subject that notified it. Therefore, it can access its properties and choose which one to display in the interface.</p>
<ol start="5">
<li>Lastly, we are going to implement <kbd>CameraController</kbd>. The expected behavior of the camera is to start shaking when the turbo booster of the bike is activated:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Observer<br/>{<br/>    public class CameraController : Observer<br/>    {<br/>        private bool _isTurboOn;<br/>        private Vector3 _initialPosition;<br/>        private float _shakeMagnitude = 0.1f;<br/>        private BikeController _bikeController;<br/><br/>        void OnEnable()<br/>        {<br/>            _initialPosition = <br/>                gameObject.transform.localPosition;<br/>        }<br/><br/>        void Update()<br/>        {<br/>            if (_isTurboOn)<br/>            {<br/>                gameObject.transform.localPosition =<br/>                    _initialPosition + <br/>                    (Random.insideUnitSphere * _shakeMagnitude);<br/>            }<br/>            else<br/>            {<br/>                gameObject.transform.<br/>                    localPosition = _initialPosition;<br/>            }<br/>        }<br/><br/>        public override void Notify(Subject subject)<br/>        {<br/>            if (!_bikeController)<br/>                _bikeController =<br/>                    subject.GetComponent&lt;BikeController&gt;();<br/><br/>            if (_bikeController)<br/>                _isTurboOn = _bikeController.IsTurboOn;<br/>        }<br/>    }<br/>}<br/></pre>
<p class="mce-root"><kbd>CameraController</kbd> checks the public Boolean property of the subject that just notified it and if it's true, it starts shaking the camera until it gets notified again by <kbd>BikeController</kbd> and confirms that the turbo toggle is off.</p>
<p>The main takeaway of this implementation to keep in mind is that <kbd>BikeController</kbd> (<strong>subject</strong>) is not aware of how the HUD and Camera controller (<strong>observers</strong>) will behave once they are notified. Hence, it's at the discretion of the observers to choose how they will react as the subject alerts them of a change.</p>
<p class="mce-root">This approach decouples these controller components from each other. Therefore, it's way easier to implement and debug them individually.</p>
<h2 id="uuid-61474dd3-6022-4f03-8a7b-b539bf4babc8">Testing the Observer pattern implementation</h2>
<p>To test our implementation, we have to do the following:</p>
<ol>
<li>Open an empty Unity scene but make sure it includes at least one camera and one light.</li>
<li>Add a 3D GameObject, such as a cube, to the scene and make it visible to the camera.</li>
<li>Attach the <kbd>BikeController</kbd> script as a component to the new 3D object.</li>
<li>Attach the <kbd>CameraController</kbd> script to the main scene camera.</li>
<li class="mce-root">Create an empty GameObject, add the following <kbd>ClientObserver</kbd> script to it, and then start the scene:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Observer<br/>{<br/>    public class ClientObserver : MonoBehaviour<br/>    {<br/>        private BikeController _bikeController;<br/><br/>        void Start()<br/>        {<br/>            _bikeController = <br/>                (BikeController) <br/>                FindObjectOfType(typeof(BikeController));<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            if (GUILayout.Button("Damage Bike"))<br/>                if (_bikeController) <br/>                    _bikeController.TakeDamage(15.0f);<br/><br/>            if (GUILayout.Button("Toggle Turbo"))<br/>                if (_bikeController) <br/>                    _bikeController.ToggleTurbo();<br/>        }<br/>    }<br/>}</pre>
<p>We should see GUI buttons and labels on the screen, similar to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/168bc28d-38b6-45bb-b13c-e144af66e6ba.png" style="width:73.83em;height:44.50em;"/></p>
<p>Figure 9.3 – The GUI elements in a running Unity scene </p>
<p>If we press the Toggle Turbo button, we will see the camera shake and the HUD display the status of the turbo booster.  The Damage Bike button will reduce the health of the bike.</p>
<p>There are many different ways you can implement the Observer pattern, each with its intrinsic benefits. I can't cover them all in this chapter. Due to this, I wrote the code example in this chapter for educational purposes in mind. Hence, it's not the most optimized approach but one that's easy to understand.</p>
<h1 id="uuid-f456a824-c8bc-4f31-a706-1c5517b6af48">Reviewing alternative solutions</h1>
<p>An alternative to the Observer pattern is the native C# event system. One of the significant advantages of this event system is that it's more granular than the Observer pattern because objects can listen to specific events that another emits, instead of getting a general notification from a subject.</p>
<p class="mce-root">A native event system should always be considered if you need to have components interact through events, especially if you don't need to establish a specific relationship between them.</p>
<p>Unity has its own native event system; it's very similar to the C# version but with added engine features, such as the ability to wire events and actions through the Inspector. To learn more, go to <a href="https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html">https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html</a>.</p>
<h1 id="uuid-1a4ecf1c-9353-4a21-ae14-2d9fcce56cb2">Summary</h1>
<p>In this chapter, we learned how to use the Observer pattern to decouple <kbd>BikeController</kbd> from its dependencies by assigning them the roles of subject or observer. Our code is now easier to manage and extend as we can easily have <kbd>BikeController</kbd> interact with other controllers with minimal coupling.</p>
<p>In the next chapter, we will explore the Visitor pattern, one of the most challenging patterns to learn. We will use it to build power-ups, a core mechanic and ingredient of our game.</p>


            

            
        
    </body></html>