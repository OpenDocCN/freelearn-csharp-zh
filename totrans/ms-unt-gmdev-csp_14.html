<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-132"><a id="_idTextAnchor139" class="calibre6 pcalibre1 pcalibre"/>9</h1>
<h1 id="_idParaDest-133" class="calibre5"><a id="_idTextAnchor140" class="calibre6 pcalibre1 pcalibre"/>Optimizing the Game Using Unity’s Profiler, Frame Debugger, and Memory Profiler</h1>
<p class="calibre3">Welcome to <a href="B22017_09_split_000.xhtml#_idTextAnchor139" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 9</em></a> of your Unity game development journey, where we will explore optimizing game performance using Unity’s Profiler, Frame Debugger, and Memory Profiler. In this chapter, we will learn how to identify and address performance bottlenecks, optimize rendering, and manage memory efficiently. We’ll cover Unity’s profiling tools, dive into performance optimization techniques such as physics, audio, AI, and scripting optimizations, and delve into memory management and optimization, including Memory Profiler usage and asset importing optimizations. Mastering these skills will ensure smooth gameplay and an immersive player experience.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Introducing Unity profiling tools</li>
<li class="calibre11">Performance optimization techniques</li>
<li class="calibre11">Memory management and optimization</li>
</ul>
<h1 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor141" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You will need to install the following to follow along with me in this chapter:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Primary IDE – Visual Studio 2022</strong>: The tutorials and code samples have been crafted using Visual Studio 2022. Ensure it’s installed so that you can follow along seamlessly. Feel free to explore Rider or other IDEs if you prefer, though the instructions are tailored for Visual Studio.</li>
<li class="calibre11"><strong class="bold">Unity version 2022.3.13</strong>: Download and install Unity, choosing version 2022.3.13 for optimal compatibility with the provided content.</li>
</ul>
<p class="calibre3">The code files of this chapter can be found at: <a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009</a>.</p>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"/>Introducing Unity profiling tools</h1>
<p class="calibre3">Welcome <a id="_idIndexMarker549" class="calibre6 pcalibre1 pcalibre"/>to Unity’s profiling tools! These tools are essential for understanding and improving the performance of our games. They provide valuable insights into how our games are running and help us optimize them for a smoother experience across different devices and platforms.</p>
<p class="calibre3">So, why do we need to utilize profiling tools? Profiling tools are invaluable assets in the quest for optimization, which is the process of fine-tuning our games to run as efficiently as possible. These tools act as our detective companions in the world of game development, helping us investigate and identify areas where our game might be slowing down or using too much memory. By using these tools, we can make targeted improvements to our game’s performance, ensuring that players have a seamless and enjoyable gaming experience.</p>
<p class="calibre3">So, what does optimization mean in game development? Optimization is the process of making our games run as efficiently as possible, involving finding ways to reduce unnecessary computations, minimize memory usage, and improve rendering performance. Just like a well-organized city ensures smooth traffic flow and efficient resource management, optimization ensures that our game’s code and graphics work together harmoniously to deliver a captivating experience to players. This optimization is crucial because it directly impacts the player’s experience. No one wants to play a game that lags, stutters, or crashes unexpectedly. By optimizing our games, we can ensure that they run smoothly on a variety of hardware configurations, providing players with a consistent and enjoyable gaming experience across different platforms.</p>
<h2 id="_idParaDest-136" class="calibre7"><a id="_idTextAnchor143" class="calibre6 pcalibre1 pcalibre"/>Exploring Unity’s profiling tools in depth</h2>
<p class="calibre3">Unity’s profiling tools<a id="_idIndexMarker550" class="calibre6 pcalibre1 pcalibre"/> offer a comprehensive suite of features to help us understand and improve our game’s performance. The Profiler allows us to analyze CPU and GPU usage in real time, giving us valuable insights into where optimizations are needed. The Frame Debugger, on the other hand, helps us visualize how our game’s graphics are rendered.</p>
<p class="calibre3">In the upcoming sections, we’ll take a closer look at each of these profiling tools and learn how to use them effectively to optimize our games. So, let’s get ready to dive into the world of Unity profiling!</p>
<h3 class="calibre9">The Profiler</h3>
<p class="calibre3">The Profiler in<a id="_idIndexMarker551" class="calibre6 pcalibre1 pcalibre"/> Unity is like a helpful detective for your <a id="_idIndexMarker552" class="calibre6 pcalibre1 pcalibre"/>game. It checks how the game is doing – for example, how much the computer is thinking (CPU), how the graphics are doing (GPU), and how much memory is used. It’s like a tool to catch issues and make your game work better.</p>
<p class="calibre3">To open the Profiler, go to <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> | <strong class="bold">Profiler</strong>. A new window will appear, as shown in <em class="italic">Figure 9</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 9.1 – The Profiler" src="img/B22017_09_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The Profiler</p>
<p class="calibre3">Now that we’ve opened the Profiler, let’s dive into how it works.</p>
<h4 class="calibre17">Understanding the functionality of Unity’s Profiler</h4>
<p class="calibre3">The Profiler in <a id="_idIndexMarker553" class="calibre6 pcalibre1 pcalibre"/>Unity works by continuously monitoring different aspects of your game’s performance while it’s running. It collects data on CPU usage, GPU usage, memory allocation, rendering performance, and more, allowing us to gain insights into how our game is utilizing system resources.</p>
<p class="calibre3">When you open the Profiler in Unity, it displays a variety of graphs and charts that visualize this data in real time. These graphs show metrics such as CPU usage over time, memory usage by different components of the game, and the time it takes to render each frame.</p>
<p class="calibre3">The Profiler gathers this data by instrumenting your game code with profiling markers. These markers track the time it takes for specific functions and operations to execute, allowing us to identify performance bottlenecks and areas for optimization.</p>
<p class="calibre3">For example, if the Profiler shows a spike in CPU usage during gameplay, we can use the Profiler’s <strong class="bold">Call Stacks</strong> view to pinpoint which functions are consuming the most CPU time. It can then analyze the code within those functions to identify inefficiencies or areas for optimization.</p>
<p class="calibre3">Similarly, if the Profiler detects excessive memory usage, we can use the memory allocation view to identify where memory is being allocated and deallocated in the code. This can help identify memory leaks or inefficient memory usage patterns that may be impacting performance.</p>
<p class="calibre3">Overall, the Profiler in Unity provides us with valuable insights into our game’s performance, allowing us to identify and address issues that could impact the player experience. By using the Profiler effectively, we can optimize our games to run smoothly and efficiently on a variety of platforms and devices.</p>
<p class="calibre3">In Unity, optimizing the performance of your game is crucial for delivering a smooth and immersive player experience. The Unity Profiler is a powerful tool that offers insights into various aspects of your game’s performance through its diverse modules, each focusing on different areas of analysis.</p>
<p class="calibre3">The main modules of the Unity Profiler are as follows:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">CPU Profiler</strong>: This<a id="_idIndexMarker554" class="calibre6 pcalibre1 pcalibre"/> module monitors the CPU usage of your <a id="_idIndexMarker555" class="calibre6 pcalibre1 pcalibre"/>game during runtime. It helps identify performance bottlenecks related to scripting, physics calculations, rendering, and other CPU-intensive tasks.</li>
<li class="calibre11"><strong class="bold">GPU Profiler</strong>: The<a id="_idIndexMarker556" class="calibre6 pcalibre1 pcalibre"/> GPU Profiler focuses on monitoring<a id="_idIndexMarker557" class="calibre6 pcalibre1 pcalibre"/> the GPU usage of your game. It provides information about rendering performance, including the time spent on drawing calls, shaders, and graphics-related computations.</li>
<li class="calibre11"><strong class="bold">Memory Profiler</strong>: This<a id="_idIndexMarker558" class="calibre6 pcalibre1 pcalibre"/> module tracks memory usage <a id="_idIndexMarker559" class="calibre6 pcalibre1 pcalibre"/>in your game, including allocations, deallocations, and memory leaks. It helps identify areas where memory is being used inefficiently or where resources are not managed properly.</li>
<li class="calibre11"><strong class="bold">Audio Profiler</strong>: The <a id="_idIndexMarker560" class="calibre6 pcalibre1 pcalibre"/>Audio Profiler monitors the performance<a id="_idIndexMarker561" class="calibre6 pcalibre1 pcalibre"/> of audio-related operations in your game, such as playing audio clips, mixing audio channels, and processing audio effects. It helps optimize audio performance and troubleshoot any issues related to audio playback.</li>
<li class="calibre11"><strong class="bold">Physics Profiler</strong>: This <a id="_idIndexMarker562" class="calibre6 pcalibre1 pcalibre"/>module focuses on analyzing<a id="_idIndexMarker563" class="calibre6 pcalibre1 pcalibre"/> the performance of physics calculations in your game. It provides insights into the time spent on physics simulations, collisions, rigid body dynamics, and other physics-related computations.</li>
<li class="calibre11"><strong class="bold">UI Profiler</strong>: The <a id="_idIndexMarker564" class="calibre6 pcalibre1 pcalibre"/>UI Profiler is specifically designed to analyze<a id="_idIndexMarker565" class="calibre6 pcalibre1 pcalibre"/> the performance of <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) elements in your game. It helps identify UI-related bottlenecks, such as layout calculations, rendering overhead, and event handling.</li>
<li class="calibre11"><strong class="bold">Network Profiler</strong>: The<a id="_idIndexMarker566" class="calibre6 pcalibre1 pcalibre"/> Network Profiler monitors <a id="_idIndexMarker567" class="calibre6 pcalibre1 pcalibre"/>network activity in your game, including data transmission, latency, and network-related events. It helps optimize network performance and troubleshoot issues related to multiplayer networking or online gameplay.</li>
<li class="calibre11"><strong class="bold">Rendering Profiler</strong>: This<a id="_idIndexMarker568" class="calibre6 pcalibre1 pcalibre"/> module focuses on analyzing <a id="_idIndexMarker569" class="calibre6 pcalibre1 pcalibre"/>rendering performance in your game. It provides insights into rendering overhead, draw calls, batching, and other graphics-related optimizations.</li>
</ul>
<p class="calibre3">Collectively, these modules provide a comprehensive view of your game’s performance, allowing you to identify and address performance issues effectively. By using the Unity Profiler’s various modules, we can optimize our games for better performance, smoother gameplay, and enhanced player experiences.</p>
<p class="calibre3">In this chapter, we will focus on the CPU Profiler and learn how to use it to identify performance related to the CPU.</p>
<h3 class="calibre9">The CPU Profiler module</h3>
<p class="calibre3">The <a id="_idIndexMarker570" class="calibre6 pcalibre1 pcalibre"/>CPU Profiler module<a id="_idIndexMarker571" class="calibre6 pcalibre1 pcalibre"/> is an essential tool in Unity for analyzing the performance of your game. It provides a detailed breakdown of where your game spends its time during runtime, including areas such as rendering, scripting, and animation. This section delves into various aspects of the CPU Profiler module, covering chart categories, the module details pane, live settings, and more.</p>
<h4 class="calibre17">Chart categories</h4>
<p class="calibre3">The <strong class="bold">CPU Usage</strong> Profiler module’s chart categorizes the time spent on the game’s main thread into nine<a id="_idIndexMarker572" class="calibre6 pcalibre1 pcalibre"/> categories. These categories are <strong class="bold">Rendering</strong>, <strong class="bold">Scripts</strong>, <strong class="bold">Physics</strong>, <strong class="bold">Animation</strong>, <strong class="bold">GarbageCollector</strong>, <strong class="bold">VSync</strong>, <strong class="bold">Global Illumination</strong>, <strong class="bold">UI</strong>, and <strong class="bold">Others</strong>. By understanding the distribution of time across these categories, we can pinpoint areas of improvement and optimize our game’s performance accordingly.</p>
<p class="calibre3">By understanding each part and its role or impact, we can easily pinpoint the problem areas in scripts or animations. This allows us to focus our work on addressing these specific issues. You can refer to <em class="italic">Figure 9</em><em class="italic">.2</em> for the charts and their defined colors:</p>
<div><div><img alt="Figure 9.2 – CPU module" src="img/B22017_09_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2 – CPU module</p>
<p class="calibre3">In the<a id="_idIndexMarker573" class="calibre6 pcalibre1 pcalibre"/> following table, I have listed each category, along with common activities that may occur within it, indicating the time spent or the impact on performance:</p>
<table class="no-table-style" id="table001-4">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Category</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Activities Performed in </strong><strong class="bold">Real Time</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Rendering</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Processing data for the GPU and waiting for GPU operations. It includes tasks such as rendering meshes, handling shaders, managing textures, and other graphics-related computations.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Scripts</p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>MonoBehaviour</code> update methods and coroutine executions. It involves executing script code, handling game logic, and managing interactions between game objects.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Physics</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Executing physics simulations and related processes. including collision detection, rigid body interactions, joint handling, and other physics-related calculations.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Animation</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Animation system processing and performance considerations, including processing keyframes, blend trees, animation state transitions, and other animation-related tasks.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">GarbageCollector</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Garbage collection and memory allocation activities, which include memory allocation, deallocating unused memory, managing object life cycles, and optimizing memory usage.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">VSync</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Waiting for vertical synchronization activities. This includes syncing the frame rate of the game with the refresh rate of the display, ensuring smooth and tear-free rendering.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Global Illumination</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Global illumination includes calculations related to lighting in scenes, such as lightmap baking, real-time GI computations, light probes, and reflection probes.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">UI</p>
</td>
<td class="no-table-style2">
<p class="calibre3">UI activities involve rendering and interactive elements, such as canvases, text elements, buttons, panels, and other UI components.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Others</p>
</td>
<td class="no-table-style2">
<p class="calibre3">These are additional CPU activities that are not part of the other categories. This can include various engine tasks, editor-related activities, audio processing, networking tasks, and other miscellaneous computations that occur during runtime but don’t fit into the defined categories.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3">Understanding <a id="_idIndexMarker574" class="calibre6 pcalibre1 pcalibre"/>the activities within each category allows us to target specific areas based on our optimization requirements for the project.</p>
<h4 class="calibre17">Module details pane</h4>
<p class="calibre3">You<a id="_idIndexMarker575" class="calibre6 pcalibre1 pcalibre"/> have the option to display the selected frame in three different views, allowing you to discern how to switch between them, as shown in <em class="italic">Figure 9</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 9.3 – Views dropdown" src="img/B22017_09_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Views dropdown</p>
<p class="calibre3">Let’s understand how these views work:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Timeline</strong>: This view provides an overview of time distribution across different threads on a single time axis, aiding visualization of parallel execution</li>
<li class="calibre11"><strong class="bold">Hierarchy</strong>: This view groups timing data by internal hierarchical structure, offering detailed insights into function calls and memory allocations</li>
<li class="calibre11"><strong class="bold">Raw Hierarchy</strong>: This is similar to the <strong class="bold">Hierarchy</strong> view but provides additional details about performance warnings and thread groupings</li>
</ul>
<p class="calibre3">Now that we’re aware of the available views in the Profiler, we can switch between them to gain a better understanding of how the frame operates.</p>
<h4 class="calibre17">Using Live settings while profiling</h4>
<p class="calibre3">The “Live” setting in the Unity CPU Profiler provides a dynamic and immediate view of performance metrics as we interact with our game, enabling efficient on-the-fly analysis and optimization.</p>
<p class="calibre3">Let’s enable Live settings<a id="_idIndexMarker576" class="calibre6 pcalibre1 pcalibre"/> and see how it works:</p>
<ul class="calibre10">
<li class="calibre11">Enable the Live setting in the CPU Profiler module before you start recording.</li>
<li class="calibre11">As we interact with our game and trigger different events, the Profiler immediately displays real-time information about the current frame in the details pane.</li>
<li class="calibre11">We can see how each action affects CPU usage, memory allocation, and other performance metrics instantly.</li>
<li class="calibre11">This real-time feedback allows us to identify performance bottlenecks quickly, make adjustments on the fly, and see the impact of optimizations immediately.</li>
</ul>
<p class="calibre3">We can also enable the <strong class="bold">Show Full Scripting Method Names</strong> option to display the full method names. This can be particularly useful when you’re dealing with complex scripts or when you need precise visibility into the functions being executed. You can enable this option through the settings, as shown in <em class="italic">Figure 9</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 9.4 – Show Full Scripting Method Names" src="img/B22017_09_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Show Full Scripting Method Names</p>
<p class="calibre3">Before diving into the practical part, it’s essential to understand common Profiler markers.</p>
<h3 class="calibre9">Common markers</h3>
<p class="calibre3">Unity’s code<a id="_idIndexMarker577" class="calibre6 pcalibre1 pcalibre"/> is instrumented with various Profiler markers, offering insights into performance-critical tasks and areas of optimization. By leveraging these markers, we can identify bottlenecks and streamline performance-critical operations, enhancing the overall efficiency and responsiveness of our games.</p>
<p class="calibre3">Unity’s code is marked with numerous Profiler indicators that offer insights into the performance of your game. These markers are invaluable for identifying bottlenecks and optimizing your code. Let’s delve into the main categories of Profiler markers and their functions:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Main thread </strong><strong class="bold">base markers</strong>:<p class="calibre3">The <a id="_idIndexMarker578" class="calibre6 pcalibre1 pcalibre"/>main thread base markers serve to differentiate between time spent on your game and time devoted to Editor and Profiler tasks. These markers are crucial for understanding the timing of frames on the main thread. Here are some examples:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">PlayerLoop</strong>: Contains samples originating from your game’s main loop. When targeting the Editor while the Player is active, <strong class="source-inline1">PlayerLoop</strong> samples the nest under <strong class="source-inline1">EditorLoop</strong>.</li><li class="calibre11"><strong class="source-inline1">EditorLoop</strong> (Editor-only marker): Contains samples from the Editor’s main loop when profiling a player in the Editor. <strong class="source-inline1">EditorLoop</strong> samples indicate time spent rendering and running the Editor alongside the Player.</li><li class="calibre11"><strong class="source-inline1">Profiler.CollectEditorStats</strong> (Editor-only marker): Includes samples related to collecting statistics for active Profiler modules. These samples provide insight into the overhead that’s incurred by the Player when collecting module statistics.</li></ul></li>
<li class="calibre11"><strong class="bold">Editor-only markers</strong>:<p class="calibre3">Certain <a id="_idIndexMarker579" class="calibre6 pcalibre1 pcalibre"/>markers exclusively appear when profiling in Unity Editor, offering insights into Editor-specific activities such as security checks and Prefab-related tasks. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">GetComponentNullErrorWrapper</strong>: A marker exclusive to the Unity Editor, aiding in identifying null component usage</li></ul></li>
<li class="calibre11"><code>MonoBehaviour</code> update methods and coroutine executions. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">BehaviourUpdate</strong>: Contains all samples of <strong class="source-inline1">MonoBehaviour.Update</strong> methods</li></ul></li>
<li class="calibre11"><strong class="bold">Rendering and </strong><strong class="bold">VSync markers</strong>:<p class="calibre3">These<a id="_idIndexMarker581" class="calibre6 pcalibre1 pcalibre"/> markers reveal CPU activities related to processing data for the GPU and waiting for GPU operations to complete. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">WaitForTargetFPS</strong>: Indicates the time spent waiting for the targeted FPS specified by <strong class="source-inline1">Application.targetFrameRate</strong></li></ul></li>
<li class="calibre11"><strong class="bold">Backend </strong><strong class="bold">scripting markers</strong>:<p class="calibre3">These<a id="_idIndexMarker582" class="calibre6 pcalibre1 pcalibre"/> markers highlight scripting backend activities, aiding in troubleshooting issues related to garbage collection and memory allocation. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">GC.Alloc</strong>: Represents an allocation in the managed heap, subject to automatic garbage collection</li></ul></li>
<li class="calibre11"><strong class="bold">Multithreading markers</strong>:<p class="calibre3">These <a id="_idIndexMarker583" class="calibre6 pcalibre1 pcalibre"/>markers focus on thread synchronization and the Job System, offering information about parallel processing and sync points. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">Idle</strong>: Contains samples indicating the length of time a Worker Thread remains inactive</li></ul></li>
<li class="calibre11"><strong class="bold">Physics markers</strong>:<p class="calibre3">Physics markers <a id="_idIndexMarker584" class="calibre6 pcalibre1 pcalibre"/>provide insights into the execution of physics simulations and related processes such as collision detection and joint handling. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">Physics.FetchResults</strong>: Contains samples that collect the results of the physics simulation from the physics engine</li></ul></li>
<li class="calibre11"><strong class="bold">Animation markers</strong>:<p class="calibre3">These<a id="_idIndexMarker585" class="calibre6 pcalibre1 pcalibre"/> markers pertain to the Animation system, offering details on animation processing stages and performance considerations. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">Director.PrepareFrame</strong>: Schedules and awaits <strong class="source-inline1">Director.PrepareFrameJob</strong> jobs, evaluating the state machines for active Animator components</li></ul></li>
<li class="calibre11"><strong class="bold">Performance warnings</strong>:<p class="calibre3">The CPU Profiler<a id="_idIndexMarker586" class="calibre6 pcalibre1 pcalibre"/> identifies common performance issues and displays warnings to alert developers, helping them optimize their code effectively. Here is an example:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">Animation.DestroyAnimationClip</strong>: Indicates a performance issue with calls related to destroying <strong class="source-inline1">AnimationClips</strong>, triggering resource-intensive operations</li></ul></li>
</ul>
<p class="calibre3">With a thorough understanding of these Profiler markers, we can pinpoint performance bottlenecks and optimize our Unity games for enhanced efficiency and responsiveness.</p>
<p class="calibre3">You can learn more about common markers in the official Unity documentation: <a href="https://docs.unity3d.com/Manual/profiler-markers.html" class="calibre6 pcalibre1 pcalibre">https://docs.unity3d.com/Manual/profiler-markers.html</a>.</p>
<p class="calibre3">By becoming familiar with the common markers, we’ve seen that they prove to be invaluable tools in our optimization journey. They allow us to concentrate on specific areas efficiently, ensuring that our efforts are both effective and precise.</p>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor144" class="calibre6 pcalibre1 pcalibre"/>Understanding the profiling process</h2>
<p class="calibre3">Let’s discuss<a id="_idIndexMarker587" class="calibre6 pcalibre1 pcalibre"/> general tips for the profiling process, including how to identify bottlenecks and gain a better understanding of the entire process.</p>
<p class="calibre3">Profiling is most effective when it’s used at three specific times:</p>
<ul class="calibre10">
<li class="calibre11">Establish a baseline by profiling before implementing major changes</li>
<li class="calibre11">Track changes during development and ensure they do not negatively impact performance or exceed resource budgets</li>
<li class="calibre11">After development, profile again to confirm that the changes that have been made have achieved the desired improvements in performance</li>
</ul>
<p class="calibre3">Avoid profiling until you identify issues in your game. Additionally, refrain from excessive profiling; determine the required frame rate for your game. Each frame should adhere to a time budget aligned with your target <strong class="bold">frames per second</strong> (<strong class="bold">FPS</strong>). For instance, a game aiming for 30 FPS should consume less than 33.33 ms per frame (1,000 ms divided by 30 FPS). Similarly, targeting 60 FPS allows for 16.66 ms per frame.</p>
<p class="callout-heading">Note</p>
<p class="callout">Achieving the most precise profiling outcomes necessitates running and profiling builds directly on the intended target devices.Top of Form</p>
<h3 class="calibre9">Identifying bottlenecks</h3>
<p class="calibre3">You <a id="_idIndexMarker588" class="calibre6 pcalibre1 pcalibre"/>should determine whether your game is CPU- or GPU-bound so that you can focus your optimization efforts correctly. For instance, note that <a id="_idIndexMarker589" class="calibre6 pcalibre1 pcalibre"/>while VSync is optional on all platforms, it’s typically enabled on mobile devices and may contribute to CPU time waiting.</p>
<p class="calibre3"><strong class="bold">VSync</strong>, short for <strong class="bold">Vertical Synchronization</strong>, is a graphics technology that synchronizes<a id="_idIndexMarker590" class="calibre6 pcalibre1 pcalibre"/> the frame rate of a game with the refresh rate of the monitor or display device. This synchronization prevents issues such as screen tearing, where parts of different frames appear on the screen simultaneously, leading to a visually jarring experience. VSync ensures that each frame is displayed in full before the next frame is rendered, creating a smoother and more visually pleasing experience for the player.</p>
<p class="calibre3">The <a id="_idIndexMarker591" class="calibre6 pcalibre1 pcalibre"/>performance<a id="_idIndexMarker592" class="calibre6 pcalibre1 pcalibre"/> of a project is determined by the chip or thread that requires the most time to process. This area is where optimization efforts should be concentrated. For instance, consider a game with a target frame time budget of 16.66 ms with VSync enabled:</p>
<ul class="calibre10">
<li class="calibre11">If the CPU frame time (excluding VSync) is 10 ms and the GPU time is 12 ms, there’s no issue as both are within budget.</li>
<li class="calibre11">If the CPU frame time is 20 ms and the GPU time is 12 ms, the CPU performance needs to be optimized as the GPU won’t benefit from optimization. Consider transferring some CPU tasks to the GPU.</li>
<li class="calibre11">If the CPU frame time is 8 ms and the GPU time is 20 ms, focus on optimizing the GPU workload as it is GPU-bound.</li>
<li class="calibre11">If both the CPU and GPU times are at 20 ms, you’re bound by both and need to optimize them below 16.66 ms to achieve a frame rate of 60 FPS.</li>
</ul>
<p class="calibre3">We’ll learn more about CPU- and GPU-bound issues in the following subsections.</p>
<h4 class="calibre17">CPU-bound issues</h4>
<p class="calibre3">It’s considered<a id="_idIndexMarker593" class="calibre6 pcalibre1 pcalibre"/> a CPU-bound issue when the CPU time exceeds the allocated time budget. Let’s walk through an example to illustrate how to identify and resolve such issues using the Profiler. Utilizing the <strong class="bold">Timeline</strong> and <strong class="bold">Hierarchy</strong> views in the Profiler helps us gain a clearer understanding of the specific issue. Refer to <em class="italic">Figure 9</em><em class="italic">.5</em> for detailed information on a spike frame:</p>
<div><div><img alt="Figure 9.5 – A spike frame" src="img/B22017_09_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.5 – A spike frame</p>
<p class="calibre3">The <code>gfx.waitForCommandsFromMainThread</code> marker indicates a potential bottleneck on the main thread that affects overall performance. This occurs when the render <a id="_idIndexMarker594" class="calibre6 pcalibre1 pcalibre"/>thread waits for commands from the main thread, suggesting that tasks or commands that are being processed on the CPU are taking longer. Consequently, the game experiences a CPU-bound issue, causing delays in rendering. Addressing these bottlenecks and optimizing CPU-bound issues can significantly enhance game performance and responsiveness.</p>
<p class="calibre3">Identify the CPU bottleneck by analyzing which thread is the most active. Profiling helps pinpoint bottlenecks accurately for focused optimization. Guesswork can lead to ineffective optimizations or even worsen performance.</p>
<p class="calibre3">The primary threads for identifying performance issues typically include the following:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">The main thread</strong>: This<a id="_idIndexMarker595" class="calibre6 pcalibre1 pcalibre"/> thread handles game logic and script execution, including tasks related to physics, animation, UI, and rendering. It accounts for a significant portion of the processing time.</li>
<li class="calibre11"><strong class="bold">The render thread</strong>: This<a id="_idIndexMarker596" class="calibre6 pcalibre1 pcalibre"/> thread is responsible for processing scene elements during rendering, such as camera culling, depth sorting, and draw call batching. It converts Unity’s scene representation into specific graphics API calls for GPU rendering.</li>
<li class="calibre11"><strong class="bold">The job worker threads</strong>: These threads utilize the C# Job System to offload specific<a id="_idIndexMarker597" class="calibre6 pcalibre1 pcalibre"/> tasks onto separate Worker Threads, reducing the main thread’s workload. Various Unity systems, such as physics, animation, and rendering, also leverage the Job System for improved performance.</li>
</ul>
<p class="calibre3">You need <a id="_idIndexMarker598" class="calibre6 pcalibre1 pcalibre"/>to identify any loops in your code where spikes occur, determine what is causing the high CPU usage or prolonged processing time, and investigate if it corresponds to a common marker in the Profiler. Understanding the meaning of these markers helps you address the issue effectively. Optimize your code based on your findings, monitor the Profiler again after applying fixes, and continue this iterative process until you achieve your target frame rate.</p>
<h4 class="calibre17">GPU-bound issues</h4>
<p class="calibre3">If your<a id="_idIndexMarker599" class="calibre6 pcalibre1 pcalibre"/> game experiences prolonged activity in Profiler markers such as <code>Gfx WaitForPresentOnGfxThread</code>, indicating idle time for the render thread, and simultaneously shows markers such as <code>Gfx PresentFrame</code> or <code>&lt;GraphicsAPIName&gt; WaitForLastPresent</code>, it suggests a GPU-bound scenario. In this context, GPU-boundness is characterized by heavy GPU utilization and potential delays in frame rendering and presentation.</p>
<p class="calibre3">If your game appears to be heavily using the GPU, you can use the Frame Debugger to quickly examine the batches of draw calls that are sent to the GPU. I’ll discuss this tool in more detail in the next section. However, it’s essential to note that while the Frame Debugger provides insights into scene construction, it doesn’t offer specific GPU timing details. So, you can switch between the Profiler and the Frame Debugger to fix any issues related to GPU.</p>
<p class="calibre3">Let’s explore the factors that can lead to GPU performance issues in our projects. The following are some common issues:</p>
<ul class="calibre10">
<li class="calibre11">Complex particle systems with a high number of particles or intricate behaviors can impact GPU performance</li>
<li class="calibre11">Real-time reflections or refractions, particularly in scenes with many reflective surfaces, can be GPU-intensive</li>
<li class="calibre11">Shader permutations or shader variants for different materials or effects can increase GPU workload, especially if they’re not managed efficiently</li>
<li class="calibre11">Dynamic weather or environmental effects, such as rain, fog, or dynamic skies, can add GPU overhead if they’re not optimized</li>
<li class="calibre11">Dynamic Occlusion culling and visibility calculations can affect GPU performance, especially in scenes with complex geometry or many moving objects</li>
<li class="calibre11">High screen resolutions, especially 4K displays or retina displays on mobile devices, can put a heavy load on the GPU</li>
</ul>
<p class="calibre3">Here are<a id="_idIndexMarker600" class="calibre6 pcalibre1 pcalibre"/> some useful tips while using the Profiler:</p>
<ul class="calibre10">
<li class="calibre11">Turn off the <strong class="bold">VSync</strong> and <strong class="bold">Others</strong> categories in the <strong class="bold">CPU Usage</strong> Profiler module. The <strong class="bold">VSync</strong> marker indicates periods of inactivity in the CPU’s main thread, and hiding these markers can enhance the clarity of your profiling analysis.</li>
<li class="calibre11">Disable <strong class="bold">VSync</strong> in your project build to gain a clear understanding of the interactions between the main thread, render thread, and GPU. Profiling a build with <strong class="bold">VSync</strong> disabled can simplify the interpretation of profiler data.</li>
<li class="calibre11">Be mindful of when to conduct profiling in either Play mode or Editor mode. Utilize Play mode for profiling game performance and Editor mode for monitoring Unity Editor processes. Profiling the Editor can aid in identifying performance bottlenecks and improving productivity.</li>
<li class="calibre11">Opt for profiling in the Editor when you need to quickly iterate on resolving performance issues. After identifying problems, use Play mode profiling to efficiently iterate on changes and validate solutions.</li>
</ul>
<p class="calibre3">Optimizing graphics<a id="_idIndexMarker601" class="calibre6 pcalibre1 pcalibre"/> performance and identifying rendering bottlenecks in Unity becomes streamlined and efficient with the powerful capabilities of the Frame Debugger tool. We’ll dive deeper into this in the next section.</p>
<h3 class="calibre9">The Frame Debugger</h3>
<p class="calibre3">The<a id="_idIndexMarker602" class="calibre6 pcalibre1 pcalibre"/> Frame Debugger is a powerful tool that’s used for analyzing and debugging the rendering <a id="_idIndexMarker603" class="calibre6 pcalibre1 pcalibre"/>process of a frame in your game. It allows you to inspect each step involved in rendering, such as draw calls, batching, textures, and materials. This tool is crucial for optimizing graphics performance and identifying rendering bottlenecks.</p>
<p class="calibre3">You can open the <strong class="bold">Frame Debugger</strong> tool from the <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> | <strong class="bold">Frame </strong><strong class="bold">Debugger</strong> menu:</p>
<div><div><img alt="Figure 9.6 – Frame Debugger" src="img/B22017_09_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Frame Debugger</p>
<p class="calibre3">Now that we’ve learned how to open the Frame Debugger, let’s explore how it works and what it does.</p>
<h4 class="calibre17">Understanding how the Frame Debugger operates</h4>
<p class="calibre3">The <a id="_idIndexMarker604" class="calibre6 pcalibre1 pcalibre"/>Frame Debugger works by intercepting and analyzing the rendering commands that are sent to the graphics API (for example, DirectX or OpenGL). It captures information about each draw call, including the shaders, textures, materials, and meshes involved. This captured data is then presented in a visual interface, allowing developers to inspect and understand the rendering pipeline of a frame.</p>
<p class="calibre3">The Frame Debugger operates in real time, meaning you can pause the game in Play mode, analyze the current frame’s rendering, and make optimizations on the fly.</p>
<h4 class="calibre17">Exploring the key functions of the Frame Debugger</h4>
<p class="calibre3">The <a id="_idIndexMarker605" class="calibre6 pcalibre1 pcalibre"/>primary functions of the Frame Debugger are as follows:</p>
<ul class="calibre10">
<li class="calibre11">Capturing and displaying each draw call that’s made during the rendering process</li>
<li class="calibre11">Showing how objects are batched together for optimized rendering performance</li>
<li class="calibre11">Providing details about the shaders, textures, materials, and meshes that are used in rendering</li>
<li class="calibre11">Identifying render targets and offscreen render textures</li>
</ul>
<p class="calibre3">Let’s explore the Frame Debugger. This is what the <strong class="bold">Frame Debugger</strong> window looks like:</p>
<div><div><img alt="Figure 9.7 – The Frame Debugger window has been enabled" src="img/B22017_09_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.7 – The Frame Debugger window has been enabled</p>
<p class="calibre3">After enabling <a id="_idIndexMarker606" class="calibre6 pcalibre1 pcalibre"/>the Frame Debugger, the game will pause, and you’ll be able to view all graphics-related details for that frame. This includes every draw call from the initial black screen to the current scene. In Unity 2022, which is the version we’re using, the Frame Debugger features an <strong class="bold">Output / Mesh</strong> section with two tabs: one displaying the full output or current state of the graphics/scene, and the other showing the drawn mesh, such as the example of a palm tree in this instance. You can see this mesh in <em class="italic">Figure 9</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 9.8 – Mesh Preview" src="img/B22017_09_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Mesh Preview</p>
<p class="calibre3">The details <a id="_idIndexMarker607" class="calibre6 pcalibre1 pcalibre"/>about each draw call will be presented in a separate section that contains important information such as <strong class="bold">RenderTarget</strong>, <strong class="bold">Vertices</strong>, <strong class="bold">Indices</strong>, and <strong class="bold">Used Shader</strong>:</p>
<div><div><img alt="Figure 9.9 – The Details section" src="img/B22017_09_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The Details section</p>
<p class="calibre3">Additionally, the <a id="_idIndexMarker608" class="calibre6 pcalibre1 pcalibre"/>Frame Debugger includes sections for the used <strong class="bold">Textures</strong>, <strong class="bold">Vectors</strong>, <strong class="bold">Floats</strong>, and other sections, as shown in <em class="italic">Figure 9</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 9.10 – The other sections in the Frame Debugger" src="img/B22017_09_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.10 – The other sections in the Frame Debugger</p>
<p class="calibre3">Once you have identified the contents of the frame, the optimization process depends on employing specific strategies and techniques tailored to the unique aspects of each game. Addressing issues requires thorough research to pinpoint areas for optimization, and this process often involves iterative steps to achieve optimal performance. One of the most important ways to reduce draw calls is to use batching. Let’s take a closer look.</p>
<h4 class="calibre17">Draw call batching</h4>
<p class="calibre3">Draw call batching <a id="_idIndexMarker609" class="calibre6 pcalibre1 pcalibre"/>refers to a technique that’s used for optimizing draw calls by merging meshes, allowing Unity to render them in fewer draw calls. Unity <a id="_idIndexMarker610" class="calibre6 pcalibre1 pcalibre"/>offers two default draw call batching methods:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Static batching</strong>:<p class="calibre3">In this process, Unity combines and renders static GameObjects together.</p><p class="calibre3">Static batching in <a id="_idIndexMarker611" class="calibre6 pcalibre1 pcalibre"/>Unity refers to the process of optimizing draw calls by combining meshes either at build time or during runtime. When using static batching, it’s essential to ensure that certain criteria are met for GameObjects to be eligible for static batching:</p><ul class="calibre16"><li class="calibre11">The GameObject must be active</li><li class="calibre11">It should have a <strong class="bold">Mesh Filter</strong> component that is enabled and references a mesh with a vertex count greater than 0</li><li class="calibre11">The GameObject should also have a <strong class="bold">Mesh Renderer</strong> component that is enabled and uses a material without a shader that disables batching</li><li class="calibre11">Meshes that are to be batched together must share the same vertex attributes</li></ul><p class="calibre3">When utilizing static batching, Unity allows the entire batch of meshes to be transformed collectively, such as moving, rotating, or scaling them as a single entity. However, transformations cannot be applied to individual meshes within the batch.</p><p class="calibre3">It’s worth noting that enabling read/write access for the mesh is necessary to use runtime static batching effectively. Overall, static batching is a useful technique for optimizing draw calls and improving performance in Unity projects.</p></li>
<li class="calibre11"><strong class="bold">Dynamic batching</strong>:<p class="calibre3">Dynamic batching is a <a id="_idIndexMarker612" class="calibre6 pcalibre1 pcalibre"/>process where Unity combines small <a id="_idIndexMarker613" class="calibre6 pcalibre1 pcalibre"/>meshes by transforming their vertices on the CPU and grouping similar vertices, ultimately rendering them in a single draw call.</p><p class="calibre3">To enable dynamic batching for meshes in Unity, follow these steps:</p><ol class="calibre18"><li class="upper-roman">Navigate to <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Player</strong>.</li><li class="upper-roman">In the <strong class="bold">Other Settings</strong> section, activate the <strong class="bold">Dynamic </strong><strong class="bold">Batching</strong> option.</li></ol><p class="calibre3">Unity will automatically group moving meshes into a single draw call if they meet the specified criteria.</p><p class="calibre3">Dynamic batching in Unity doesn’t work on GameObjects with mirrored transformations in their <strong class="bold">Transform</strong> components. For instance, if one GameObject has a scale of 1 and another has a scale of -1, Unity cannot batch them together.Top of Form</p></li>
</ul>
<p class="calibre3">In general, Unity combines draw calls for GameObjects using identical materials, so it’s crucial to maximize batching efficiency by sharing materials among multiple GameObjects. If you have two material assets that are almost identical except for their textures, consider merging the textures into a single, larger texture within the same atlas. This allows you to use a single material asset instead of two. When accessing shared material properties from a C# script, ensure that you use <code>Renderer.sharedMaterial</code> instead of <code>Renderer.material</code>. Using <code>Renderer.material</code> creates a duplicate of the material, preventing Unity from batching draw calls for that renderer.</p>
<p class="calibre3">The following are the additional methods you can utilize to decrease the number of draw call batches:</p>
<ul class="calibre10">
<li class="calibre11">Use Occlusion culling to eliminate objects that are hidden behind foreground elements and minimize overdraw. Keep in mind that this may increase CPU processing, so use the Profiler to evaluate the impact of transferring the workload from GPU to CPU.</li>
<li class="calibre11">Employ GPU instancing to reduce batches, particularly for numerous objects that share the same mesh and material. Limiting the number of models in your scene can enhance performance, and with careful implementation, you can create a complex scene without repetitiveness.</li>
<li class="calibre11">Leverage the SRP Batcher to decrease GPU setup between draw calls by grouping <strong class="bold">Bind</strong> and <strong class="bold">Draw</strong> GPU commands. To maximize SRP batching benefits, utilize multiple Materials but restrict them to a few compatible shader variants, such as the <strong class="bold">Lit</strong> and <strong class="bold">Unlit</strong> shaders in the <strong class="bold">Universal Render Pipeline</strong> (<strong class="bold">URP</strong>) and <strong class="bold">High Definition Render Pipeline</strong> (<strong class="bold">HDRP</strong>), minimizing variations between keyword combinations.</li>
</ul>
<p class="calibre3">Utilizing these<a id="_idIndexMarker614" class="calibre6 pcalibre1 pcalibre"/> techniques can significantly enhance rendering performance and streamline the development process in Unity games.</p>
<p class="calibre3">Now, let’s explore the optimization techniques for various categories in any game to improve performance.</p>
</div>


<div><h1 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor145" class="calibre6 pcalibre1 pcalibre"/>Performance optimization techniques</h1>
<p class="calibre3">In this <a id="_idIndexMarker615" class="calibre6 pcalibre1 pcalibre"/>section, we will delve into the crucial aspects of performance optimization techniques in Unity. Performance optimization plays a pivotal role in ensuring that your game runs smoothly, utilizes system resources efficiently, and delivers a seamless experience to players. By implementing optimization techniques, analyzing performance data, and adopting efficient scripting practices, developers can significantly enhance their game’s performance and overall quality. Let’s explore these skills in detail to understand how they contribute to creating high-performance games in Unity.</p>
<p class="calibre3">The following subsections cover key areas for optimization techniques.</p>
<h2 id="_idParaDest-139" class="calibre7"><a id="_idTextAnchor146" class="calibre6 pcalibre1 pcalibre"/>Physics and collisions</h2>
<p class="calibre3">To <a id="_idIndexMarker616" class="calibre6 pcalibre1 pcalibre"/>boost the performance and efficiency of physics and collisions in Unity, strategic optimization techniques play a crucial role. Here, we’ll explore two such techniques and detail their respective problems, solutions, examples, and outcomes:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Collision </strong><strong class="bold">layer masking</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: There are <a id="_idIndexMarker617" class="calibre6 pcalibre1 pcalibre"/>unnecessary collision checks between objects that don’t interact with each other, leading to wasted computational resources.</li><li class="calibre11"><strong class="bold">Solution</strong>: Use collision layer masking to specify which layers should interact with each other, avoiding unnecessary collision checks.</li><li class="calibre11"><strong class="bold">How it works</strong>: Assign different layers to objects based on their interaction requirements. Configure the physics settings to only enable collisions between specific layers that need to interact.</li><li class="calibre11"><strong class="bold">Example</strong>: Let’s consider a 2D platformer game where the player character interacts with<a id="_idIndexMarker618" class="calibre6 pcalibre1 pcalibre"/> enemies, collectibles, and environmental obstacles. By assigning different layers to these objects (for example, Player, Enemy, Collectible, and Obstacle), you can configure the physics settings to enable collisions only between specific layers. Here’s an example:<ul class="calibre16"><li class="calibre11">The Player layer interacts with the Enemy and Obstacle layers but not with the Collectible layer</li><li class="calibre11">The Enemy layer interacts with the Player and Obstacle layers but not with the Collectible layer</li><li class="calibre11">The Collectible layer does not interact with the Player, Enemy, or Obstacle layers:</li></ul></li></ul></li>
</ul>
<div><div><img alt="Figure 9.11 – Physics settings" src="img/B22017_09_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Physics settings</p>
<p class="calibre3">In your scripts, when performing collision checks using raycasts or collider triggers, you can <a id="_idIndexMarker619" class="calibre6 pcalibre1 pcalibre"/>apply layer masks to filter out unnecessary collisions. For instance, when you’re checking for enemy collisions, you can specify a layer mask that includes only the Enemy layer, ignoring collisions with collectibles or obstacles.</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Result</strong>: A reduced number of collision checks and improved performance by eliminating unnecessary physics calculations.</li>
</ul>
<p class="calibre3">In Unity, optimizing<a id="_idIndexMarker620" class="calibre6 pcalibre1 pcalibre"/> physics and collisions through collision layer masking involves strategically assigning layers, configuring physics settings, and applying layer masks to streamline collision checks and enhance performance.</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Simplified </strong><strong class="bold">collision detection</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: Full <a id="_idIndexMarker621" class="calibre6 pcalibre1 pcalibre"/>physics calculations for collision detection on objects that don’t require realistic physical interactions can be resource-intensive.</li><li class="calibre11"><strong class="bold">Solution</strong>: Use triggers as simplified collision detection for non-essential objects.</li><li class="calibre11"><strong class="bold">How it works</strong>: Triggers in Unity are collider components that detect when another collider enters or exits their volume without physically colliding with them. They are ideal for scenarios where you need to detect interactions without simulating physical forces.</li><li class="calibre11"><strong class="bold">Example</strong>: In a game where collectible coins are scattered around the level, instead of using rigid body-based collisions for the coins, you can attach trigger colliders to them. When the player’s character overlaps with a coin’s trigger collider, you can handle the collection logic without the need for full physics calculations.</li><li class="calibre11"><strong class="bold">Result</strong>: Using triggers reduces the computational overhead associated with physics calculations for objects that only require collision detection without physical responses. This leads to improved performance, especially in scenarios with a large number of non-essential objects.</li></ul><p class="calibre3">This technique is beneficial for optimizing performance in scenarios where objects do not require detailed physics interactions but still need basic collision detection functionality. By using simplified collision detection methods, you can conserve computational resources and improve overall performance in your Unity project.</p></li>
</ul>
<h2 id="_idParaDest-140" class="calibre7"><a id="_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"/>Audio</h2>
<p class="calibre3">Optimizing <a id="_idIndexMarker622" class="calibre6 pcalibre1 pcalibre"/>audio in Unity is crucial for maintaining a smooth and immersive gameplay experience. Let’s explore an advanced technique to <a id="_idIndexMarker623" class="calibre6 pcalibre1 pcalibre"/>reduce memory usage and improve audio performance in your game:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Audio </strong><strong class="bold">compression technique</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: Large audio files can consume significant memory, leading to performance issues.</li><li class="calibre11"><strong class="bold">Solution</strong>: Compress audio files using formats such as Ogg Vorbis or MP3 to reduce memory <a id="_idIndexMarker624" class="calibre6 pcalibre1 pcalibre"/>usage without compromising <a id="_idIndexMarker625" class="calibre6 pcalibre1 pcalibre"/>quality. You can learn more about Unity’s importing settings by referring to the official Unity documentation at https://docs.unity3d.com/Manual/class-AudioClip.html#:~:text=Whenever%20importing%20a%20file%2C%20Unity,to%20the%20original%20as%20possible:</li></ul></li>
</ul>
<div><div><img alt="Figure 9.12 – Imported audio settings" src="img/B22017_09_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Imported audio settings</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Example</strong>: Compressing background music and sound effects in a game.</li>
<li class="calibre11"><strong class="bold">Result</strong>: Reduced memory footprint, faster loading times, and smoother gameplay.</li>
</ul>
<p class="calibre3">By employing<a id="_idIndexMarker626" class="calibre6 pcalibre1 pcalibre"/> advanced audio optimization <a id="_idIndexMarker627" class="calibre6 pcalibre1 pcalibre"/>techniques such as compression and streaming, you can significantly enhance your game’s performance while maintaining high-quality audio output.</p>
<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor148" class="calibre6 pcalibre1 pcalibre"/>UI</h2>
<p class="calibre3">I covered<a id="_idIndexMarker628" class="calibre6 pcalibre1 pcalibre"/> this topic in detail in <a href="B22017_05.xhtml#_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 5</em></a>, <em class="italic">Designing Optimized User Interfaces with C# for Unity Games</em>. You can check it out for more details. Optimizing UI is a crucial part of performance, especially in mobile games, as it directly impacts user experience and device resource utilization.</p>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor149" class="calibre6 pcalibre1 pcalibre"/>Networking and multiplayer</h2>
<p class="calibre3">Optimizing <a id="_idIndexMarker629" class="calibre6 pcalibre1 pcalibre"/>networking and multiplayer functionality in Unity games is crucial for ensuring smooth gameplay experiences across various devices and player interactions. Here, we’ll explore key techniques and strategies for enhancing networking performance <a id="_idIndexMarker630" class="calibre6 pcalibre1 pcalibre"/>and implementing effective multiplayer mechanics in Unity games:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Latency </strong><strong class="bold">compensation techniques</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: Latency can cause delays in multiplayer games, leading to synchronization issues and gameplay inconsistencies.</li><li class="calibre11"><strong class="bold">Solution</strong>: Implement latency compensation techniques to mitigate the effects of network latency on gameplay. This depends on the networking solution you have implemented. You can refer to their documentation for specific networking solutions, such as Photon.</li><li class="calibre11"><strong class="bold">Example</strong>: Use techniques such as client-side prediction, interpolation, and lag compensation to predict and smooth out the movement of networked objects based on input and network data.</li><li class="calibre11"><strong class="bold">Results</strong>: Improved responsiveness and synchronization in multiplayer games, reducing the impact of network latency on player experience and enhancing gameplay smoothness.</li></ul></li>
<li class="calibre11"><strong class="bold">Network </strong><strong class="bold">object pooling</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: Excessive instantiation and destruction of networked objects can lead to network <a id="_idIndexMarker631" class="calibre6 pcalibre1 pcalibre"/>congestion and performance issues.</li><li class="calibre11"><strong class="bold">Solution</strong>: Implement network object pooling to reuse existing networked objects instead of creating and destroying them frequently.</li><li class="calibre11"><strong class="bold">Example</strong>: In <a id="_idIndexMarker632" class="calibre6 pcalibre1 pcalibre"/>a multiplayer game, instead of instantiating and destroying bullets each time they are fired, use an object pool to recycle bullets. When a bullet is no longer needed, it is returned to the pool and can be reused later.</li><li class="calibre11"><strong class="bold">Results</strong>: Reduced network overhead and improved performance due to fewer object instantiations and destructions, leading to smoother gameplay experiences.</li></ul></li>
</ul>
<p class="calibre3">These techniques are instrumental in optimizing networking within Unity games as they effectively minimize network overhead, enhance data transmission efficiency, and contribute to a more satisfying multiplayer experience for players. The effectiveness of these optimizations, however, is contingent upon the specific networking solution that’s implemented within the game.</p>
<h2 id="_idParaDest-143" class="calibre7"><a id="_idTextAnchor150" class="calibre6 pcalibre1 pcalibre"/>AI and pathfinding</h2>
<p class="calibre3">Effective<a id="_idIndexMarker633" class="calibre6 pcalibre1 pcalibre"/> AI and pathfinding techniques are pivotal for creating immersive and engaging gameplay experiences in Unity games. We’ll <a id="_idIndexMarker634" class="calibre6 pcalibre1 pcalibre"/>explore two key solutions: A* (A-star) pathfinding and hierarchical pathfinding, along with behavior trees and state machines, to optimize AI navigation and behaviors:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Using </strong><strong class="bold">behavior trees</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: Inefficient pathfinding algorithms can lead to high computational overhead and slow performance, especially in complex game environments with dynamic obstacles.</li><li class="calibre11"><strong class="bold">Example</strong>: Implementing the A* algorithm in Unity using the NavMesh system.</li><li class="calibre11"><strong class="bold">How it works</strong>: A* is a popular pathfinding algorithm that efficiently finds the shortest path between two points on a graph or grid. In Unity, the NavMesh <a id="_idIndexMarker635" class="calibre6 pcalibre1 pcalibre"/>system utilizes A* for AI navigation, allowing agents to navigate dynamic environments while avoiding obstacles.</li><li class="calibre11"><strong class="bold">Result</strong>: Improved AI navigation performance, reduced computational cost, and smoother movement of AI agents in complex game scenes.</li></ul></li>
<li class="calibre11"><strong class="bold">Using state machines for </strong><strong class="bold">AI behavior</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: AI<a id="_idIndexMarker636" class="calibre6 pcalibre1 pcalibre"/> behaviors lacking realism and diversity can result in predictable and monotonous gameplay experiences.</li><li class="calibre11"><strong class="bold">Example</strong>: Implementing state machines for AI character behaviors.</li><li class="calibre11"><strong class="bold">How it works</strong>: State machines model AI behaviors as a set of states, transitions, and actions. Each state represents a specific behavior or condition, and transitions define how AI agents switch between states based on environmental stimuli or internal variables.</li></ul><p class="calibre3">Here’s a simplified structure of a state machine for AI behavior:</p><p class="calibre3"><strong class="bold">State interface/class</strong>:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">Enter</strong>: The <a id="_idIndexMarker637" class="calibre6 pcalibre1 pcalibre"/>method that’s called when entering the state</li><li class="calibre11"><strong class="source-inline1">Update</strong>: The method that’s called during each update cycle while in the state</li><li class="calibre11"><strong class="source-inline1">Exit</strong>: The method that’s called when exiting the state</li></ul><p class="calibre3"><strong class="bold">Concrete states</strong>:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">Idle State</strong>: This<a id="_idIndexMarker638" class="calibre6 pcalibre1 pcalibre"/> represents the AI being idle, with its own <strong class="source-inline1">Enter</strong>, <strong class="source-inline1">Update</strong>, and <strong class="source-inline1">Exit</strong> methods specific to idle behavior.</li><li class="calibre11"><strong class="source-inline1">Attack State</strong>: Represents the AI attacking, with its own <strong class="source-inline1">Enter</strong>, <strong class="source-inline1">Update</strong>, and <strong class="source-inline1">Exit</strong> methods specific to attack behavior</li><li class="calibre11">Other states as needed, each with their own behavior methods</li></ul><p class="calibre3"><strong class="bold">State </strong><strong class="bold">machine manager</strong>:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">Current State</strong>: Keeps<a id="_idIndexMarker639" class="calibre6 pcalibre1 pcalibre"/> track of the AI’s current state</li><li class="calibre11"><strong class="source-inline1">Change State</strong>: This method transitions the AI from one state to another by updating the <strong class="source-inline1">Current </strong><strong class="source-inline1">State</strong> variable</li><li class="calibre11"><strong class="source-inline1">Update</strong>: The method to be called in each update cycle, which, in turn, calls the <strong class="source-inline1">Update</strong> method of the current state</li></ul><p class="calibre3"><strong class="bold">Usage</strong>:</p><ul class="calibre16"><li class="calibre11">Initialize the AI with an initial state (for example, <strong class="source-inline1">Idle State</strong>)</li><li class="calibre11">During each update cycle, call the <strong class="source-inline1">Update</strong> method of the state machine manager to execute the behavior of the current state</li><li class="calibre11">When conditions change (for example, the AI detects an enemy), use the <strong class="source-inline1">Change State</strong> method to switch to the appropriate state (for example, <strong class="source-inline1">Attack State</strong>)</li></ul><p class="calibre3">This structure outlines the components and their relationships in a state machine for AI behavior. You can implement this structure in any programming language by creating classes/interfaces for states, implementing a manager to handle state transitions, and integrating them into your AI system.</p><ul class="calibre16"><li class="calibre11"><strong class="bold">Result</strong>: Modular and organized AI behavior design, easier debugging and maintenance of AI logic, and improved adaptability to changing game conditions.</li></ul></li>
</ul>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor151" class="calibre6 pcalibre1 pcalibre"/>Build size</h2>
<p class="calibre3">Efficient <a id="_idIndexMarker640" class="calibre6 pcalibre1 pcalibre"/>build size is crucial for delivering optimized and polished Unity games to players. Let’s explore a technique known as build size reduction through asset compression to enhance build efficiency:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Build </strong><strong class="bold">size reduction</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: Large <a id="_idIndexMarker641" class="calibre6 pcalibre1 pcalibre"/>build sizes can lead to longer download times and increased storage requirements for players.</li><li class="calibre11"><strong class="bold">Solution</strong>: Implement asset compression techniques such as texture compression, audio compression, and code stripping to reduce the overall size of the build. For texture compression, it’s recommended to use dimensions that are powers of two, such as 64x64. This approach is beneficial for compression, resulting in reduced memory usage and a smaller final build size.</li><li class="calibre11"><strong class="bold">Example</strong>: Use texture compression formats such as ETC2 for Android builds and ASTC for iOS builds to significantly reduce the size of texture assets without compromising quality. The size of the texture is shown in the following figures:</li></ul></li>
</ul>
<div><div><img alt="Figure 9.13 – Before using the compression format" src="img/B22017_09_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Before using the compression format</p>
<div><div><img alt="Figure 9.14 – After using a compression format" src="img/B22017_09_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.14 – After using a compression format</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Result</strong>: Reduced build size, faster download times, and improved performance on devices with limited storage.</li>
</ul>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor152" class="calibre6 pcalibre1 pcalibre"/>Rendering</h2>
<p class="calibre3">Optimizing <a id="_idIndexMarker642" class="calibre6 pcalibre1 pcalibre"/>rendering is essential for delivering visually stunning games while maintaining optimal performance. Let’s explore two powerful techniques: a <strong class="bold">level of detail</strong> (<strong class="bold">LOD</strong>) system for efficient mesh rendering and Occlusion Culling to minimize unnecessary rendering, resulting in enhanced performance <a id="_idIndexMarker643" class="calibre6 pcalibre1 pcalibre"/>and visual quality:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">LOD system</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: High-poly models and complex scenes can lead to performance issues, especially on lower-end devices.</li><li class="calibre11"><strong class="bold">Solution</strong>: Implement a LOD system where objects have multiple versions with varying levels of detail. The system switches to lower-detail versions as objects move farther from the camera, reducing the rendering workload.</li><li class="calibre11"><strong class="bold">Example</strong>: Use Unity’s <strong class="bold">LOD Group</strong> component to create LOD levels for meshes, ensuring smooth transitions between LOD levels based on camera distance. Ensure that you have the necessary meshes ready by either requesting them from artists, utilizing assets from the asset store, or creating them manually if you possess the skills. It’s important to create low-poly meshes from the original ones to optimize performance:</li></ul></li>
</ul>
<div><div><img alt="Figure 9.15 – The LOD Group component" src="img/B22017_09_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.15 – The LOD Group component</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Result</strong>: Improved performance by reducing the number of polygons that are rendered without compromising visual quality.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Occlusion culling</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Problem</strong>: Rendering <a id="_idIndexMarker644" class="calibre6 pcalibre1 pcalibre"/>off-screen <a id="_idIndexMarker645" class="calibre6 pcalibre1 pcalibre"/>objects consumes resources and affects performance, even though they are not visible to the player.</li><li class="calibre11"><strong class="bold">Solution</strong>: Use Occlusion culling to prevent objects that are occluded by other objects or not within the player’s view frustum from being rendered.</li><li class="calibre11"><strong class="bold">Example</strong>: Configure Occlusion culling volumes in Unity to define areas where Occlusion culling should be applied, optimizing rendering by skipping occluded objects:</li></ul></li>
</ul>
<div><div><img alt="Figure 9.16 – The camera before the starting line" src="img/B22017_09_16.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.16 – The camera before the starting line</p>
<div><div><img alt="Figure 9.17 – The camera after the starting line" src="img/B22017_09_17.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.17 – The camera after the starting line</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Result</strong>: Reduced <a id="_idIndexMarker646" class="calibre6 pcalibre1 pcalibre"/>rendering workload, improved frame rates, and<a id="_idIndexMarker647" class="calibre6 pcalibre1 pcalibre"/> enhanced overall performance, especially in complex scenes.</li>
</ul>
<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor153" class="calibre6 pcalibre1 pcalibre"/>Scripting</h2>
<p class="calibre3">Efficient<a id="_idIndexMarker648" class="calibre6 pcalibre1 pcalibre"/> scripting practices are crucial for optimizing game performance and ensuring smooth gameplay experiences. Let’s explore two powerful techniques: object pooling for efficient object management and coroutine optimization to enhance coroutine performance, resulting in improved overall game performance and responsiveness.</p>
<h3 class="calibre9">Object pooling</h3>
<p class="calibre3">Let’s consider a<a id="_idIndexMarker649" class="calibre6 pcalibre1 pcalibre"/> solution for object pooling:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Problem</strong>: Instantiating and destroying objects frequently during gameplay can lead to performance overhead due to memory allocation and garbage collection.</li>
<li class="calibre11"><strong class="bold">Solution</strong>: Implement object pooling, where a set of pre-allocated objects is reused instead of you having to instantiate and destroy them repeatedly.</li>
<li class="calibre11"><code>ObjectPoolManager</code> and understand<a id="_idIndexMarker652" class="calibre6 pcalibre1 pcalibre"/> its functionality.</p><p class="calibre3">In the following code block, the <code>ObjectPoolManager</code> class is responsible for handling all operations related to the pooled objects. To make it accessible from other scripts, we will implement it as a singleton:</p><pre class="source-code">
 public class ObjectPoolManager : MonoBehaviour
   {
       // Static instance of the ObjectPoolManager
       private static ObjectPoolManager instance;
       // Property to access the ObjectPoolManager instance
       public static ObjectPoolManager Instance
       {
           get
           {
               if (instance == null)
               {
                   instance = FindObjectOfType&lt;ObjectPoolManager&gt;();
                   // If not found, create a new GameObject and add the ObjectPoolManager script to it
                   if (instance == null)
                   {
                       GameObject obj = new GameObject("ObjectPoolManager");
                       instance = obj.AddComponent&lt;ObjectPoolManager&gt;();
                   }
               }
               return instance;
           }
       }
       private void Awake()
       {
           if (instance != null &amp;&amp; instance != this)
           {
               Destroy(gameObject);
           }
           else
           {
               instance = this;
               DontDestroyOnLoad(gameObject);
           }
       }</pre><p class="calibre3">This script uses a static <code>Instance</code> property to implement the singleton pattern for <code>ObjectPoolManager</code>. It also includes an <code>Awake</code> method to ensure that only one instance of <code>ObjectPoolManager</code> exists in the scene and persists between scene changes if needed.</p><p class="calibre3">In the following code block, I will<a id="_idIndexMarker653" class="calibre6 pcalibre1 pcalibre"/> continue implementing the logic related to the object pooling by <code>GetPooledObject</code> and <code>ReturnToPool</code> functions of the objects:</p><pre class="source-code">        // Define a dictionary to store object pools
        private Dictionary&lt;string, Queue&lt;GameObject&gt;&gt; objectPools = new Dictionary&lt;string, Queue&lt;GameObject&gt;&gt;();
        // Create or retrieve an object from the pool based on the name of it
        public GameObject GetPooledObject(string objectName)
        {
            if (objectPools.ContainsKey(objectName))
            {
                if (objectPools[objectName].Count &gt; 0)
                {
                    GameObject obj = objectPools[objectName].Dequeue();
                    obj.SetActive(true);
                    return obj;
                }
            }
            Debug.LogWarning("No available object in the pool with name: " + objectName);
            return null;
        }
        // Return an object to the pool
        public void ReturnToPool(string objectName, GameObject obj)
        {
            obj.SetActive(false);
            objectPools[objectName].Enqueue(obj);
        }</pre><p class="calibre3">Here’s an<a id="_idIndexMarker654" class="calibre6 pcalibre1 pcalibre"/> explanation for each part:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">private Dictionary&lt;string, Queue&lt;GameObject&gt;&gt; objectPools = new Dictionary&lt;string, Queue&lt;GameObject&gt;&gt;();</strong>: This line declares a private dictionary named <strong class="source-inline1">objectPools</strong> that stores object pools based on their names. Each name corresponds to a queue of GameObjects.</li><li class="calibre11"><strong class="source-inline1">public GameObject GetPooledObject(string objectName)</strong>: This method retrieves an object from the object pool based on its name. It checks if an object pool with the given name exists and if there are available objects in the pool. If available, it dequeues an object, activates it, and returns it. If no object is available, it logs a warning and returns null.</li><li class="calibre11"><strong class="source-inline1">public void ReturnToPool(string objectName, GameObject obj)</strong>: This method returns an object to the object pool based on its name. It deactivates the object and enqueues it back into the corresponding object pool queue.</li></ul><p class="calibre3">Lastly, I’ll create a function to instantiate pooled objects from other scripts, as demonstrated<a id="_idIndexMarker655" class="calibre6 pcalibre1 pcalibre"/> in the following code block:</p><pre class="source-code">  // Create an object pool for a specific prefab so I can dynamically add object to the pool in runtime
  public void CreateObjectPool(GameObject prefab, int poolSize, string objectName)
  {
      if (!objectPools.ContainsKey(objectName))
      {
          objectPools[objectName] = new Queue&lt;GameObject&gt;();
          for (int i = 0; i &lt; poolSize; i++)
          {
              GameObject obj = Instantiate(prefab);
              obj.SetActive(false);
              objectPools[objectName].Enqueue(obj);
          }
      }
      else
      {
          Debug.LogWarning("Object pool with name " + objectName + " already exists.");
      }
  }</pre><p class="calibre3">Here’s an explanation of the <code>CreateObjectPool</code> method:</p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1">public void CreateObjectPool(GameObject prefab, int poolSize, string objectName)</strong>: This method creates an object pool for a specific prefab with a given pool size and object name. It checks if an object pool with the same name already exists. If not, it creates a new queue in the dictionary and instantiates objects based on the prefab to populate the pool.</li></ul><p class="calibre3">Here’s an example of <a id="_idIndexMarker656" class="calibre6 pcalibre1 pcalibre"/>how to use this manager:</p><pre class="source-code">public class ExampleUsage : MonoBehaviour
 {
     public GameObject prefabToPool;
     public int poolSize = 10;
     public string objectName = "MyTag";
     void Start()
     {
         // Create an object pool with the specified prefab, pool size, and tag
         ObjectPoolManager.Instance.CreateObjectPool(prefabToPool, poolSize, objectName);
         // Get an object from the pool
         GameObject obj = ObjectPoolManager.Instance.GetPooledObject(objectName);
         if (obj != null)
         {
             // Use the object
             obj.transform.position = Vector3.zero;
         }
         // Return the object to the pool
         ObjectPoolManager.Instance.ReturnToPool(objectName, obj);
     }
 }</pre></li> <li class="calibre11"><strong class="bold">Result</strong>: Reduced<a id="_idIndexMarker657" class="calibre6 pcalibre1 pcalibre"/> memory overhead, improved performance, and smoother gameplay experience, especially in scenarios with frequent object creation and destruction.</li>
</ul>
<h3 class="calibre9">Coroutine optimization</h3>
<p class="calibre3">Now, let’s consider a <a id="_idIndexMarker658" class="calibre6 pcalibre1 pcalibre"/>solution for coroutine optimization:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Problem</strong>: Using coroutines extensively without optimization can lead to performance issues, especially when you’re dealing with long-running or frequent coroutines.</li>
<li class="calibre11"><strong class="bold">Solution</strong>: Optimize coroutines by employing techniques such as using <strong class="source-inline1">WaitForSeconds</strong> instead of <strong class="source-inline1">WaitForSecondsRealtime</strong>, minimizing <strong class="source-inline1">WaitForSeconds</strong> calls, and avoiding nested coroutines where possible. Additionally, consider defining or caching <strong class="source-inline1">WaitForSeconds</strong> instances to avoid creating new instances each time the coroutine is executed, which can improve memory efficiency. The following code block shows an example of how to define <strong class="source-inline1">WaitForSeconds</strong>:<pre class="source-code">
// Define WaitForSeconds as a variable
    private WaitForSeconds waitShort = new WaitForSeconds(2f);</pre></li> <li class="calibre11"><strong class="bold">Example</strong>: Refactor coroutine-heavy scripts to reduce the number of coroutine instances, optimize yield instructions, and use alternatives such as <strong class="source-inline1">InvokeRepeating</strong> for repetitive tasks.</li>
<li class="calibre11"><strong class="bold">Result</strong>: Improved <a id="_idIndexMarker659" class="calibre6 pcalibre1 pcalibre"/>performance by reducing coroutine overhead, smoother gameplay, and better frame rates, especially in complex scenes with many coroutines running simultaneously.</li>
</ul>
<p class="calibre3">We now know about some common issues and their appropriate solutions. In the next section, we’ll move on and learn how to optimize memory.</p>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor154" class="calibre6 pcalibre1 pcalibre"/>Memory management and optimization</h1>
<p class="calibre3">Memory profiling in <a id="_idIndexMarker660" class="calibre6 pcalibre1 pcalibre"/>Unity involves utilizing tools such as the Memory Profiler module and package to analyze and optimize memory usage, allowing us to identify areas for improvement and enhance overall performance. You’ll learn more about the Memory Profiler package in this section.</p>
<p class="calibre3">You can analyze <a id="_idIndexMarker661" class="calibre6 pcalibre1 pcalibre"/>memory usage in your Unity application through two methods. First, the Memory Profiler module provides essential insights into memory usage, highlighting areas where your application consumes memory. Second, by integrating the Memory Profiler package into your project, you gain access to an enhanced <strong class="bold">Memory Profiler</strong> window within Unity Editor. This advanced tool allows for more detailed analysis, including storing and comparing snapshots to identify memory leaks and examining memory layouts to detect fragmentation issues.</p>
<h2 id="_idParaDest-148" class="calibre7"><a id="_idTextAnchor155" class="calibre6 pcalibre1 pcalibre"/>The Memory Profiler</h2>
<p class="calibre3">The <a id="_idIndexMarker662" class="calibre6 pcalibre1 pcalibre"/>Memory Profiler in Unity is a tool that’s used for analyzing and optimizing memory usage in Unity projects. It helps us understand how our game uses memory and identify areas where memory can be optimized.</p>
<p class="calibre3">You need to install this package into your project. Go to the <strong class="bold">Package Manager</strong> window and select <strong class="bold">Memory Profiler</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.18</em>:</p>
<div><div><img alt="Figure 9.18 – Installing the Memory Profiler package" src="img/B22017_09_18.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Installing the Memory Profiler package</p>
<p class="calibre3">Wait for <a id="_idIndexMarker663" class="calibre6 pcalibre1 pcalibre"/>Unity to finish installing the Memory Profiler package, then open it from the <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> | <strong class="bold">Memory Profiler</strong> menu. If this is your first time using it in your project, an empty window will open, as shown in <em class="italic">Figure 9</em><em class="italic">.19</em>:</p>
<div><div><img alt="Figure 9.19 – The Memory Profiler panel" src="img/B22017_09_19.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.19 – The Memory Profiler panel</p>
<p class="calibre3">Now that we’ve<a id="_idIndexMarker664" class="calibre6 pcalibre1 pcalibre"/> learned how to open the Memory Profiler, let’s explore how it works and what it does.</p>
<h4 class="calibre17">Understanding how the Memory Profiler operates</h4>
<p class="calibre3">The <a id="_idIndexMarker665" class="calibre6 pcalibre1 pcalibre"/>Memory Profiler works by monitoring and recording memory allocations and usage in real time while your Unity project is running. It tracks various metrics, such as heap size, memory allocations by type, instance counts, and memory leaks. It provides a detailed breakdown of memory usage, allowing developers to pinpoint areas of high memory consumption and potential memory leaks.</p>
<h4 class="calibre17">Exploring the key functions of the Memory Profiler</h4>
<p class="calibre3">The <a id="_idIndexMarker666" class="calibre6 pcalibre1 pcalibre"/>primary functions of the Memory Profiler are as follows:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Tracks memory allocations</strong>: The Memory Profiler tracks memory allocations made by your game, including heap memory, object instances, and resource usage</li>
<li class="calibre11"><strong class="bold">Identifies memory leaks</strong>: It helps identify memory leaks by highlighting objects that are not properly disposed of or released from memory</li>
<li class="calibre11"><strong class="bold">Analyzes memory usage by type</strong>: You can see a breakdown of memory usage by different types of objects, scripts, textures, and other assets in your project</li>
<li class="calibre11"><strong class="bold">Provides instance counts</strong>: The Memory Profiler shows how many instances of each object type are currently in memory, helping you understand memory consumption patterns</li>
<li class="calibre11"><strong class="bold">Offers insights into resource usage</strong>: It provides insights into how resources such as textures, audio clips, and other assets contribute to memory usage</li>
</ul>
<p class="calibre3">Now, let’s learn how to use the Memory Profiler.</p>
<h3 class="calibre9">Using the Memory Profiler</h3>
<p class="calibre3">Before<a id="_idIndexMarker667" class="calibre6 pcalibre1 pcalibre"/> we dive into the Memory Profiler, it’s crucial to consider and adhere to the memory limitations of your target devices in multiplatform development. Design scenes and levels within the specified memory budget for each device to ensure optimal performance based on hardware capabilities. Setting clear limits and guidelines helps maintain compatibility across platforms.</p>
<p class="calibre3">The Memory Profiler package offers comprehensive memory analysis capabilities. Utilize it to store and compare snapshots for identifying memory leaks and optimizing your application’s memory layout. Unlike the Memory Profiler module, this package extends its functionality to include managed memory analysis, snapshot saving, comparison, and detailed memory <a id="_idIndexMarker668" class="calibre6 pcalibre1 pcalibre"/>content exploration with visual breakdowns:</p>
<div><div><img alt="Figure 9.20 – The Summary tab in the Memory Profiler" src="img/B22017_09_20.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.20 – The Summary tab in the Memory Profiler</p>
<p class="calibre3">The <strong class="bold">Summary</strong> tab provides an overview of the memory status in the chosen snapshot(s).</p>
<p class="calibre3">Once you click on any area of the summary, further details about it will appear in the right-hand panel.</p>
<p class="calibre3">Another tab we<a id="_idIndexMarker669" class="calibre6 pcalibre1 pcalibre"/> should consider is <strong class="bold">Unity Objects</strong>, which showcases Unity objects that are utilizing memory, along with their respective allocations in native and managed memory, and the combined total. You can utilize this data to spot duplicate memory entries or pinpoint objects with significant memory usage. You can also utilize the search bar to filter entries in the table based on your specified text. This can be seen in <em class="italic">Figure 9</em><em class="italic">.21</em>:</p>
<div><div><img alt="Figure 9.21 – The Unity Objects tab in the Memory Profiler" src="img/B22017_09_21.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.21 – The Unity Objects tab in the Memory Profiler</p>
<p class="calibre3">Lastly, The <strong class="bold">All Of Memory</strong> tab is exclusive to <strong class="bold">Single Snapshot</strong> mode, providing a comprehensive <a id="_idIndexMarker670" class="calibre6 pcalibre1 pcalibre"/>breakdown of all tracked memory in the snapshot. It visualizes memory usage, showcasing sizable portions managed either by Unity or the platform. This tab is instrumental in discerning non-Unity-related memory consumption and uncovering potential memory issues not evident in the <strong class="bold">Unity </strong><strong class="bold">Objects</strong> tab:</p>
<div><div><img alt="Figure 9.22 – The All Of Memory tab in the Memory Profiler" src="img/B22017_09_22.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.22 – The All Of Memory tab in the Memory Profiler</p>
<p class="calibre3">You can identify<a id="_idIndexMarker671" class="calibre6 pcalibre1 pcalibre"/> optimization candidates by following these steps:</p>
<ol class="calibre15">
<li class="calibre11">Open a snapshot by referring to the instructions for opening snapshots.</li>
<li class="calibre11">Access the <strong class="bold">Unity </strong><strong class="bold">Objects</strong> tab.</li>
<li class="calibre11">Ensure the table is sorted in descending order, which is the default setting in the <strong class="bold">Memory Profiler</strong> window. If the sort order has been changed, select the <strong class="bold">Total Size</strong> column header to revert to descending order for this process. This arrangement highlights objects with the highest memory usage at the top of the table.</li>
</ol>
<p class="calibre3">You can search through the results in one of two ways:</p>
<ul class="calibre10">
<li class="calibre11">Expand groups to view individual objects within each group</li>
<li class="calibre11">Consider enabling the <strong class="bold">Flatten hierarchy</strong> property to exclusively display individual objects in the table</li>
</ul>
<p class="calibre3">If you’re uncertain <a id="_idIndexMarker672" class="calibre6 pcalibre1 pcalibre"/>about which objects might use excessive memory, leave the <strong class="bold">Flatten hierarchy</strong> property disabled and inspect the groups to identify the largest objects. Enable this property if most assets are understood but there’s a suspicion of a few outliers consuming too much memory.</p>
<p class="calibre3">Additionally, enable the <strong class="bold">Show Potential Duplicates Only</strong> property to identify objects flagged by the Memory Profiler as potential duplicates. Utilize the <strong class="bold">References</strong> component and <strong class="bold">Selection Details</strong> component for detailed insights into these objects. This information helps differentiate expected duplicates, such as multiple instances of a Prefab in a scene, from problematic duplicates, such as unintentionally created objects or instances not disposed of correctly by Unity.</p>
<p class="calibre3">Here are some <a id="_idIndexMarker673" class="calibre6 pcalibre1 pcalibre"/>considerations when it comes to memory profiling:</p>
<ul class="calibre10">
<li class="calibre11">Use different memory usage based on settings such as quality levels, graphics tiers, and AssetBundle variants, especially on more powerful devices.</li>
<li class="calibre11"><strong class="bold">Quality Level</strong> and <strong class="bold">Graphics</strong> settings can impact the size of RenderTextures that are used for shadow maps.</li>
<li class="calibre11">Resolution scaling affects screen buffers, RenderTextures, and post-processing effects.</li>
<li class="calibre11">Texture quality settings influence the size of all textures.</li>
<li class="calibre11">Maximum LOD can impact models and other elements.</li>
<li class="calibre11">AssetBundle variants such as HD and SD versions can result in different asset sizes based on the device’s specifications.</li>
<li class="calibre11">The target device’s screen resolution affects the dimensions of RenderTextures that are utilized for post-processing effects.</li>
<li class="calibre11">The supported Graphics API can affect shader sizes based on API-specific variants.</li>
<li class="calibre11">Content generated dynamically during gameplay, such as procedural levels, can significantly impact memory usage. Monitor the memory footprint of dynamically generated assets to ensure efficient memory management.</li>
<li class="calibre11">Conduct thorough testing on target devices with varying specifications, screen resolutions, and hardware configurations to identify and address memory issues specific to each platform.</li>
</ul>
<p class="calibre3">By considering<a id="_idIndexMarker674" class="calibre6 pcalibre1 pcalibre"/> these aspects and conducting comprehensive memory profiling, you can optimize memory usage across different platforms, ensuring optimal performance and resource utilization in your Unity projects.</p>
<p class="calibre3">One effective method to<a id="_idIndexMarker675" class="calibre6 pcalibre1 pcalibre"/> improve memory optimization in Unity is by optimizing the import settings for assets.</p>
<h4 class="calibre17">Importing models</h4>
<p class="calibre3">Importing models is a<a id="_idIndexMarker676" class="calibre6 pcalibre1 pcalibre"/> critical aspect of 3D game development, and optimizing this process can significantly enhance memory usage and overall performance. In this section, we’ll explore key settings, as shown in <em class="italic">Figure 9</em><em class="italic">.</em><em class="italic">23</em>, that can be adjusted to achieve these optimizations effectively:</p>
<div><div><img alt="Figure 9.23 – The model’s settings" src="img/B22017_09_23.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.23 – The model’s settings</p>
<p class="calibre3"><strong class="bold">Mesh Compression</strong> is a setting that determines the level of compression that’s applied to imported mesh data. It <a id="_idIndexMarker677" class="calibre6 pcalibre1 pcalibre"/>affects the file size of the mesh asset and can impact both memory usage and rendering performance:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Options</strong>: Unity <a id="_idIndexMarker678" class="calibre6 pcalibre1 pcalibre"/>provides three options for <strong class="bold">Mesh Compression</strong>:<ul class="calibre16"><li class="calibre11"><strong class="bold">Off</strong>: No compression is applied, resulting in larger file sizes but potentially better rendering performance.</li><li class="calibre11"><strong class="bold">Low</strong>: Applies a basic compression algorithm to reduce file size while still maintaining visual quality. This is suitable for many cases as it doesn’t have a significant impact on rendering performance.</li><li class="calibre11"><strong class="bold">Medium/High</strong>: Utilizes more advanced compression techniques to further reduce file size. However, higher compression levels may lead to slightly lower rendering performance due to additional decompression overhead.</li></ul></li>
<li class="calibre11"><strong class="bold">Best practices</strong>: Use <strong class="bold">Mesh Compression</strong> judiciously based on the specific requirements of your game. For complex models or those with intricate details, consider using <strong class="bold">Low</strong> compression to balance file size reduction with rendering performance. Test different compression levels to find the optimal balance for your project.</li>
</ul>
<p class="calibre3">The <strong class="bold">Read/Write Enabled</strong> setting<a id="_idIndexMarker679" class="calibre6 pcalibre1 pcalibre"/> determines whether the mesh data can be accessed and modified at runtime. Enabling this setting allows scripts to read and modify mesh properties during gameplay:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Impact on performance and memory</strong>: Enabling Read/Write for a mesh increases memory usage because the mesh data needs to be stored in a format that allows runtime modifications. However, it can also provide flexibility for dynamic mesh operations, such as deformation or procedural mesh generation.</li>
<li class="calibre11"><strong class="bold">Best practices</strong>: Only enable Read/Write for meshes that require runtime modifications. For static meshes that do not change during gameplay, leave this setting disabled to reduce memory overhead.</li>
</ul>
<p class="calibre3">The <strong class="bold">Optimize Mesh</strong> setting<a id="_idIndexMarker680" class="calibre6 pcalibre1 pcalibre"/> determines whether Unity applies additional optimizations to the imported mesh data to improve rendering performance:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Effect on performance and memory</strong>: Enabling <strong class="bold">Optimize Mesh</strong> allows Unity to perform optimizations such as vertex welding, which reduces the number of vertices in the mesh <a id="_idIndexMarker681" class="calibre6 pcalibre1 pcalibre"/>without significantly affecting visual quality. This can lead to improved rendering performance by reducing the workload on the GPU.</li>
<li class="calibre11"><strong class="bold">Best practices</strong>: Enable <strong class="bold">Optimize Mesh</strong> for meshes that can benefit from vertex reduction without compromising visual fidelity. This is particularly useful for models with redundant or overlapping vertices as it can significantly reduce memory usage and enhance rendering performance.</li>
</ul>
<p class="calibre3">Setting the <strong class="bold">Animation Type</strong> option to <strong class="bold">None</strong> for a static game object in the <strong class="bold">Rig</strong> tab can have a positive impact on both performance and memory usage. When you choose <strong class="bold">None</strong>, Unity skips any processing related to animation rigging and does not allocate resources for animation-related calculations during runtime. This can be seen in <em class="italic">Figure 9</em><em class="italic">.24</em>:</p>
<div><div><img alt="Figure 9.24 – The Rig tab in the model settings" src="img/B22017_09_24.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.24 – The Rig tab in the model settings</p>
<p class="calibre3">Let’s look at how setting <strong class="bold">Animation Type</strong> to <strong class="bold">None</strong> can affect performance and memory.</p>
<p class="calibre3"><strong class="bold">Performance impact</strong>:</p>
<ul class="calibre10">
<li class="calibre11">By <a id="_idIndexMarker682" class="calibre6 pcalibre1 pcalibre"/>setting <strong class="bold">Animation Type</strong> to <strong class="bold">None</strong>, Unity avoids processing animation data and calculations for <a id="_idIndexMarker683" class="calibre6 pcalibre1 pcalibre"/>the game object. This reduces the workload on the CPU and GPU, especially during the rendering and animation playback phases.</li>
<li class="calibre11">Since there are no animation updates to perform, Unity can optimize the rendering pipeline by skipping unnecessary computations related to bone transformations, blend shapes, or animation state updates.</li>
<li class="calibre11">This optimization can lead to smoother frame rates and improved overall performance, particularly for static objects that do not require any animation functionality.</li>
</ul>
<p class="calibre3"><strong class="bold">Memory impact</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Setting <strong class="bold">Animation Type</strong> to <strong class="bold">None</strong> also has a memory-saving benefit. Unity does not allocate memory for storing animation clips, rigging data, or animation-related components (for example, Animator or Animation Controller) for game objects with this setting applied.</li>
<li class="calibre11">This reduction in memory usage can be significant, especially for scenes with multiple static objects or large models that do not need animation features.</li>
<li class="calibre11">By minimizing memory allocation for animation-related resources, you free up more memory for other game assets and reduce the overall memory footprint of your Unity project.</li>
</ul>
<p class="calibre3"><strong class="bold">Best practices</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Set <strong class="bold">Animation Type</strong> to <strong class="bold">None</strong> for static game objects or models that do not require animation functionality. This is particularly effective for environment props, static scenery elements, or architectural models.</li>
<li class="calibre11">For dynamic objects that require animation, such as characters or interactive elements, choose the appropriate <strong class="bold">Animation Type</strong> based on their animation requirements (for example, <strong class="bold">Generic</strong>, <strong class="bold">Humanoid</strong>, <strong class="bold">Legacy</strong>, and so on).</li>
<li class="calibre11">Regularly review and optimize animation settings for each game object to ensure efficient use of resources and improved performance.</li>
</ul>
<p class="calibre3">In summary, setting <strong class="bold">Animation Type</strong> to <strong class="bold">None</strong> for static game objects can be a beneficial optimization<a id="_idIndexMarker684" class="calibre6 pcalibre1 pcalibre"/> strategy as it reduces both CPU/GPU workload and memory usage in your Unity project.</p>
<p class="calibre3">Lastly, when <a id="_idIndexMarker685" class="calibre6 pcalibre1 pcalibre"/>considering the <strong class="bold">Anim. Compression</strong> option in the <strong class="bold">Animation</strong> tab of model settings in Unity, choosing between <strong class="bold">Optimal Compression</strong> or <strong class="bold">Keyframe Reduction</strong> can indeed have an impact on both performance and memory usage. This can be seen in <em class="italic">Figure 9</em><em class="italic">.25</em>:</p>
<div><div><img alt="Figure 9.25 – The Animation tab in the model settings" src="img/B22017_09_25.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.25 – The Animation tab in the model settings</p>
<p class="calibre3">Let’s look <a id="_idIndexMarker686" class="calibre6 pcalibre1 pcalibre"/>at how each<a id="_idIndexMarker687" class="calibre6 pcalibre1 pcalibre"/> option affects your project.</p>
<p class="calibre3"><strong class="bold">Optimal Compression</strong>:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Performance impact</strong>: <strong class="bold">Optimal Compression</strong> aims to reduce the size of animation clips while preserving visual quality. This can result in improved performance during runtime, especially for devices with limited processing power or memory bandwidth.</li>
<li class="calibre11"><strong class="bold">Memory impact</strong>: By compressing animation data efficiently, <strong class="bold">Optimal Compression</strong> reduces the memory footprint of animation clips. This can be beneficial for projects with many animations or large animation files, leading to lower memory usage and better resource management.</li>
</ul>
<p class="calibre3"><strong class="bold">Keyframe Reduction</strong>:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Performance impact</strong>: <strong class="bold">Keyframe Reduction</strong> focuses on minimizing the number of keyframes in <a id="_idIndexMarker688" class="calibre6 pcalibre1 pcalibre"/>animation clips while maintaining smooth motion. This can lead to improved performance by reducing the computational overhead of interpolating between keyframes during animation playback.</li>
<li class="calibre11"><strong class="bold">Memory impact</strong>: While <strong class="bold">Keyframe Reduction</strong> can help save memory by reducing <a id="_idIndexMarker689" class="calibre6 pcalibre1 pcalibre"/>the data needed for animation playback, it may not be as efficient in terms of memory optimization as <strong class="bold">Optimal Compression</strong>. However, it can still contribute to lowering the overall memory usage of animation clips.</li>
</ul>
<p class="calibre3"><strong class="bold">Best practices</strong>:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Optimal Compression</strong>: Use <strong class="bold">Optimal Compression</strong> for animations that require a balance between file size reduction and visual quality. It’s suitable for a wide range of animations and can offer significant memory and performance benefits.</li>
<li class="calibre11"><strong class="bold">Keyframe Reduction</strong>: Consider <strong class="bold">Keyframe Reduction</strong> for animations where reducing the number of keyframes won’t significantly impact visual fidelity. This option can be particularly useful for repetitive or simple animations, helping to streamline memory usage and improve playback performance.</li>
</ul>
<p class="calibre3"><strong class="bold">Choosing the </strong><strong class="bold">right option</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Evaluate the animation requirements of your project and choose the compression option that best suits your needs. <strong class="bold">Optimal Compression</strong> is generally recommended for most scenarios due to its balanced approach to reducing file size and memory usage while maintaining visual quality.</li>
<li class="calibre11">Regularly <a id="_idIndexMarker690" class="calibre6 pcalibre1 pcalibre"/>test animations with different compression settings to find the optimal balance between performance, memory usage, and visual fidelity for your specific project requirements.</li>
</ul>
<p class="calibre3">In conclusion, both <strong class="bold">Optimal Compression</strong> and <strong class="bold">Keyframe Reduction</strong> in the <strong class="bold">Anim. Compression</strong> option can impact performance and memory in Unity. Choose the compression setting that aligns with your project’s animation complexity, visual quality standards, and target platform capabilities to achieve the best results.</p>
<p class="calibre3">To automate this process, we can create an asset <code>PostProcessor</code> script, which is an editor script that allows us to set default settings for importing assets. The following is an example code block demonstrating a <code>CustomMeshPostProcessor</code> class that achieves the desired default settings when importing meshes. Simply create this script and place it in the <code>Editor</code> folder of your project. Once implemented, the script will automatically apply these settings when importing new models. Feel free to customize it and add more settings as needed for your game:</p>
<pre class="source-code">
using UnityEditor;
using UnityEngine;
public class CustomMeshPostprocessor : AssetPostprocessor
{
    void OnPreprocessModel()
    {
        ModelImporter importer = assetImporter as ModelImporter;
        importer.isReadable = false; // Set Read/Write option to disabled
        importer.meshCompression = ModelImporterMeshCompression.Medium; // Set Mesh Compression to Medium
    }
}</pre> <p class="calibre3">Overall, optimizing<a id="_idIndexMarker691" class="calibre6 pcalibre1 pcalibre"/> the import settings for models in Unity is crucial for achieving efficient memory usage and overall performance in your game. By carefully configuring these settings and following best practices, you can significantly enhance the user experience while maintaining optimal resource utilization.</p>
<h4 class="calibre17">Importing textures</h4>
<p class="calibre3">The<a id="_idIndexMarker692" class="calibre6 pcalibre1 pcalibre"/> topic of importing textures is highly impactful in optimizing both game and memory performance, with notable effects extending to UI performance as well. The available settings are shown in <em class="italic">Figure 9</em><em class="italic">.26</em>:</p>
<div><div><img alt="Figure 9.26 – Texture settings" src="img/B22017_09_26.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Texture settings</p>
<p class="calibre3">When importing textures into Unity, two key settings that can impact performance and memory <a id="_idIndexMarker693" class="calibre6 pcalibre1 pcalibre"/>usage are <strong class="bold">Read/Write</strong> and <strong class="bold">GenerateMipMaps</strong>. Let’s delve into each setting and understand their effects.</p>
<p class="calibre3"><strong class="bold">Read/Write</strong>:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Performance impact</strong>: Enabling <strong class="bold">Read/Write</strong> allows scripts to access and modify texture data at <a id="_idIndexMarker694" class="calibre6 pcalibre1 pcalibre"/>runtime. While this flexibility can be beneficial for certain features, such as dynamic texture updates or procedural generation, it comes with a performance cost. Each texture marked as <strong class="bold">Read/Write</strong> consumes additional memory and may require more processing power during runtime.</li>
<li class="calibre11"><strong class="bold">Memory impact</strong>: Textures with <strong class="bold">Read/Write</strong> enabled occupy more memory compared to those without this option. This is because Unity allocates space for both the texture data and an additional copy that can be modified at runtime. As a result, enabling <strong class="bold">Read/Write</strong> for multiple textures can lead to increased memory usage, especially on resource-constrained platforms.</li>
</ul>
<p class="calibre3"><strong class="bold">GenerateMipMaps</strong>:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Performance impact</strong>: Generating<a id="_idIndexMarker695" class="calibre6 pcalibre1 pcalibre"/> MipMaps creates a series of pre-calculated texture levels (MipMaps) that improve rendering quality and performance. However, this process requires additional computational resources during texture import or runtime generation, impacting loading times and initial performance.</li>
<li class="calibre11"><strong class="bold">Memory impact</strong>: Including MipMaps increases the memory footprint of textures since each MipMap level adds to the total texture size. While MipMaps enhance rendering performance by providing optimized texture sampling at different distances, they also consume more memory, especially for large textures with numerous MipMap levels.</li>
</ul>
<p class="calibre3"><strong class="bold">Best practices</strong>:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Read/Write</strong>: Only enable <strong class="bold">Read/Write</strong> for textures that require runtime modification or dynamic updates. For static textures used as sprites, backgrounds, or UI elements, disable <strong class="bold">Read/Write</strong> to conserve memory and improve performance.</li>
<li class="calibre11"><strong class="bold">GenerateMipMaps</strong>: Use <strong class="bold">GenerateMipMaps</strong> for textures that will benefit from improved rendering quality and performance, such as textures used for 3D models or distant terrain. Consider the trade-off between enhanced visual fidelity and increased memory usage when deciding whether to include MipMaps.</li>
</ul>
<p class="calibre3"><strong class="bold">Choosing the </strong><strong class="bold">right settings</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Evaluate the specific<a id="_idIndexMarker696" class="calibre6 pcalibre1 pcalibre"/> requirements of each texture in your project. Enable <strong class="bold">Read/Write</strong> and <strong class="bold">GenerateMipMaps</strong> judiciously based on whether the texture needs runtime modification and whether MipMaps are necessary for optimized rendering.</li>
<li class="calibre11">Regularly monitor the memory usage and performance impact of textures with different settings to optimize resource utilization and maintain efficient runtime behavior.</li>
</ul>
<p class="calibre3">In conclusion, managing <strong class="bold">Read/Write</strong> and <strong class="bold">GenerateMipMaps</strong> settings when you’re importing textures into Unity is crucial for balancing performance, memory usage, and visual quality. Selecting the appropriate settings based on the intended usage of each texture helps optimize resource allocation and enhances overall application performance.</p>
<p class="calibre3">Another aspect to<a id="_idIndexMarker697" class="calibre6 pcalibre1 pcalibre"/> consider is compression settings, which vary based on the target platform, each with its unique configurations. While specific platform settings are extensive and platform-dependent, there are some general tips for optimizing compression.</p>
<p class="calibre3"><strong class="bold">Maximum size</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Adjusting <a id="_idIndexMarker698" class="calibre6 pcalibre1 pcalibre"/>the maximum size of textures determines their dimensions upon import. Higher resolutions offer better visual quality but consume more memory. Consider the device’s capabilities and the texture’s intended use to strike a balance between quality and performance.</li>
<li class="calibre11"><strong class="bold">Best practice</strong>: Set the maximum size based on the target platform and the texture’s role in the game. Use lower resolutions for background elements or distant objects to conserve memory.</li>
</ul>
<p class="calibre3"><strong class="bold">Resize algorithm</strong>:</p>
<ul class="calibre10">
<li class="calibre11">The <a id="_idIndexMarker699" class="calibre6 pcalibre1 pcalibre"/>resize algorithm dictates how textures are scaled when their dimensions exceed the maximum size. Different algorithms may impact image quality and memory usage.</li>
<li class="calibre11"><strong class="bold">Best practice</strong>: Choose an algorithm that suits the texture type. Use sharper algorithms for detailed textures and smoother ones for gradients or patterns to preserve quality.</li>
</ul>
<p class="calibre3"><strong class="bold">Format</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Texture format determines how the image data is stored, impacting compression, memory usage, and visual fidelity. Common formats include PNG, JPG, and TGA, each with its compression levels and quality trade-offs.</li>
<li class="calibre11"><strong class="bold">Best practice</strong>: Select a <a id="_idIndexMarker700" class="calibre6 pcalibre1 pcalibre"/>format based on the texture’s content and usage. Use PNG for lossless quality, JPG for photographic textures with compression, and TGA for high-quality images with transparency.</li>
</ul>
<p class="calibre3"><strong class="bold">Compression</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Compression<a id="_idIndexMarker701" class="calibre6 pcalibre1 pcalibre"/> methods reduce texture size and memory footprint. Unity offers options such as <strong class="bold">Normal Quality</strong>, <strong class="bold">High Quality</strong>, and <strong class="bold">Low Quality</strong> for compression, each affecting image quality and memory usage differently.</li>
<li class="calibre11"><strong class="bold">Best practice</strong>: Choose compression settings based on performance requirements and visual standards. Use higher-quality compression for critical textures and lower quality for background or non-critical elements.</li>
</ul>
<p class="calibre3"><strong class="bold">Crunch compression</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Crunch compression is an additional method to further reduce texture file sizes while <a id="_idIndexMarker702" class="calibre6 pcalibre1 pcalibre"/>maintaining acceptable quality. It’s beneficial for optimizing memory usage, especially on resource-constrained platforms.</li>
<li class="calibre11"><strong class="bold">Best practice</strong>: Enable crunch compression for textures where file size reduction is crucial, such as UI elements or frequently used textures. Balance the compression level to preserve visual quality while minimizing memory impact.</li>
</ul>
<p class="calibre3">Remember, these<a id="_idIndexMarker703" class="calibre6 pcalibre1 pcalibre"/> settings may vary in impact based on the platform, so testing and iteration are key. Regularly monitor memory usage and performance metrics to fine-tune texture settings for optimal results on each target platform.</p>
<p class="calibre3">By carefully configuring importing settings, you can reduce memory usage and improve overall performance in your Unity project.</p>
<p class="calibre3">Another crucial technique for memory optimization in Unity is utilizing sprite atlases.</p>
<h3 class="calibre9">Sprite Atlases</h3>
<p class="calibre3">Sprite Atlases in Unity<a id="_idIndexMarker704" class="calibre6 pcalibre1 pcalibre"/> are essential tools for optimizing memory and performance, especially for UI elements. They allow you to combine multiple sprites into a single image, reducing draw calls and texture memory usage. Let’s learn how to use Sprite Atlases effectively while considering their best practices and impact on memory and performance.</p>
<h4 class="calibre17">Creating a Sprite Atlas</h4>
<p class="callout-heading">Note</p>
<p class="callout">Make sure you have the <strong class="bold">2D Sprite</strong> package installed in your project via <strong class="bold">Package Manager</strong>.</p>
<p class="calibre3">In<a id="_idIndexMarker705" class="calibre6 pcalibre1 pcalibre"/> your <strong class="bold">Project</strong> tab, right-click and select <strong class="bold">Create</strong> | <strong class="bold">2D</strong> | <strong class="bold">Sprite Atlas</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.27</em>:</p>
<div><div><img alt="Figure 9.27 – Sprite Atlas" src="img/B22017_09_27.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.27 – Sprite Atlas</p>
<p class="callout-heading">Note</p>
<p class="callout">Make sure you’ve enabled the <strong class="bold">Sprite Packer</strong> option in <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Editor</strong> so that you can start using this package.</p>
<p class="calibre3">Enable <strong class="bold">Sprite Packer</strong>, as<a id="_idIndexMarker706" class="calibre6 pcalibre1 pcalibre"/> shown in <em class="italic">Figure 9</em><em class="italic">.28</em>:</p>
<div><div><img alt="Figure 9.28 – Enabling Sprite Packer in Project Settings" src="img/B22017_09_28.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.28 – Enabling Sprite Packer in Project Settings</p>
<p class="calibre3">After <a id="_idIndexMarker707" class="calibre6 pcalibre1 pcalibre"/>creating the sprite atlas, navigate to it to begin adding textures. Click on the <strong class="bold">+</strong> sign to select individual textures or a folder containing textures. Then, click on <strong class="bold">Pack Preview</strong> to combine them into an atlas file, as shown in <em class="italic">Figure 9</em><em class="italic">.29</em>:</p>
<div><div><img alt="Figure 9.29 – Sprite Atlas settings" src="img/B22017_09_29.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.29 – Sprite Atlas settings</p>
<p class="calibre3">Here are <a id="_idIndexMarker708" class="calibre6 pcalibre1 pcalibre"/>some best practices you should consider:</p>
<ul class="calibre10">
<li class="calibre11">Merge frequently used sprites into a single Sprite Atlas to minimize draw calls and enhance performance</li>
<li class="calibre11">Use the packing options in the <strong class="bold">Sprite Packer</strong> window to optimize how sprites are packed within the atlas, minimizing wasted space</li>
<li class="calibre11">Avoid including excessively large sprites or unnecessary sprites in the atlas to keep the atlas’ size manageable</li>
</ul>
<p class="calibre3">Sprite Atlases have <a id="_idIndexMarker709" class="calibre6 pcalibre1 pcalibre"/>an impact on memory and performance. Let’s take a closer look:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Memory</strong>: Sprite Atlases help conserve memory by reducing the number of individual textures that are loaded into memory. However, be mindful of the total size of the Sprite Atlas as it still occupies memory based on its dimensions and content.</li>
<li class="calibre11"><strong class="bold">Performance</strong>: Sprite Atlases improve performance by reducing the number of draw calls required to render UI elements. This is especially beneficial for complex UIs with numerous sprites.</li>
</ul>
<p class="calibre3">Sprite Atlases primarily affect UI elements in terms of memory and performance. They are designed to optimize the rendering of 2D graphics, so their impact on other aspects of your game, such as 3D models or audio, is minimal. However, for UI-heavy games or applications, properly utilizing Sprite Atlases can significantly enhance performance and memory management.</p>
<h1 id="_idParaDest-149" class="calibre5"><a id="_idTextAnchor156" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we embarked on a journey to optimize our game’s performance using Unity’s powerful profiling tools. Building upon the skills we’ve already acquired, we delved into an introduction to Unity profiling tools, reinforcing our ability to identify performance bottlenecks and apply optimization techniques to significantly enhance our game’s performance. This chapter further deepened our understanding of memory management and optimization, guiding us on how to effectively manage memory usage and optimize memory performance in our game. Through practical exercises and insights, we solidified our mastery of the Profiler, Frame Debugger, and Memory Profiler, ensuring that our game runs smoothly and efficiently.</p>
<p class="calibre3">Looking ahead to <a href="B22017_10.xhtml#_idTextAnchor157" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 10</em></a>, we will discover a treasure trove of tips and tricks to enhance our Unity development skills using C#. The next chapter focuses on productivity-boosting shortcuts, advanced techniques and workflows, and troubleshooting common challenges in Unity development. We will learn how to utilize shortcuts for efficient development, apply advanced techniques to enhance our game development processes, and troubleshoot and find solutions to common challenges we may encounter. This chapter will equip us with valuable insights that we can implement to improve our workflow, overcome challenges, and unlock new possibilities in Unity game development using C#.</p>
</div>
</body></html>