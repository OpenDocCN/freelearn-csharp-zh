<html><head></head><body>
<div id="_idContainer034">
<h1 class="chapter-number" id="_idParaDest-106"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.2.1">Handling Data for Each Microservice with the Database per Service Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we explored the concepts of event sourcing and event stores. </span><span class="koboSpan" id="kobo.3.2">Event sourcing patterns help us to reconcile changes made to our data stores across our microservices. </span><span class="koboSpan" id="kobo.3.3">An operation in one microservice might require that data be sent to other microservices. </span><span class="koboSpan" id="kobo.3.4">For efficiency reasons, we create an event store as an intermediary area to which microservices can subscribe for changes and will be able to get the latest version of the data as needed.</span></p>
<p><span class="koboSpan" id="kobo.4.1">This concept revolves around the assumption that each microservice has its own database. </span><span class="koboSpan" id="kobo.4.2">This is the recommended approach in a microservice architecture, given the fundamental requirement that each microservice needs to be autonomous in its operations and data requirements.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Building on this notion, we will explore best practices and techniques for handling data for each microservice.</span></p>
<p><span class="koboSpan" id="kobo.6.1">After reading this chapter, you will know how to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">How to make use of the Database-per-Service pattern</span></li>
<li><span class="koboSpan" id="kobo.8.1">How to develop a database</span></li>
<li><span class="koboSpan" id="kobo.9.1">How to implement the repository pattern</span></li>
</ul>
<h1 id="_idParaDest-108"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.10.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.11.1">The code references used in this chapter can be found in the project repository, which is hosted on GitHub at </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch07"><span class="koboSpan" id="kobo.12.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch07</span></a><span class="koboSpan" id="kobo.13.1">.</span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.14.1">How to make use of the Database-Per-Service pattern</span></h1>
<p><span class="koboSpan" id="kobo.15.1">A core characteristic of microservices</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.16.1"> architecture is loose coupling between our services. </span><span class="koboSpan" id="kobo.16.2">We need to maintain the independence and individuality of each service and allow them to autonomously interact with the data they need when they need it. </span><span class="koboSpan" id="kobo.16.3">We want to ensure that one service’s manipulation of data does not inhibit another service’s ability to use its own data.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Each microservice will be left to define</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.18.1"> its own data access layers and parameters and, unless deliberately implemented, no two services will have direct access to the same data store. </span><span class="koboSpan" id="kobo.18.2">Data is not persisted across two services and the overall decoupling that comes with this pattern means that one database failure will not inhibit the operation of the other services.</span></p>
<p><span class="koboSpan" id="kobo.19.1">We also need to bear in mind that microservices architecture allows us to select different development technologies that best meet the needs of the service being implemented. </span><span class="koboSpan" id="kobo.19.2">Different technologies tend to work bette</span><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.20.1">r with or support specific databases. </span><span class="koboSpan" id="kobo.20.2">Therefore, this pattern may be more of a requirement than a suggestion given that we will want to use the best database technology to support the needs of a service.</span></p>
<p><span class="koboSpan" id="kobo.21.1">As usual, where there is a pro, there is a con. </span><span class="koboSpan" id="kobo.21.2">We need to consider the costs involved with this kind of heterogenous architecture and how we might need to adapt our knowledge base and team to support several databases and, by extension, various database technologies. </span><span class="koboSpan" id="kobo.21.3">We now have to account for additional maintenance, backup, and tuning operations, which might lead to maintenance overheads.</span></p>
<p><span class="koboSpan" id="kobo.22.1">There are several approaches that can be taken in implementing this pattern and some of the approaches reduce ou</span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.23.1">r infrastructure needs and help us to save costs. </span><span class="koboSpan" id="kobo.23.2">We discuss those options in the next section.</span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.24.1">A single database technology per service</span></h2>
<p><span class="koboSpan" id="kobo.25.1">Ultimately, we need to establish</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.26.1"> clear boundaries between the source of truth for each service. </span><span class="koboSpan" id="kobo.26.2">This doesn’t mean that you absolutely need to have different databases, but you can take advantage of features of relational data stores such as the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Tables-per-service</span></strong><span class="koboSpan" id="kobo.28.1">: We can define tables that are optimized</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.29.1"> for the data to be stored for each service. </span><span class="koboSpan" id="kobo.29.2">We will model these tables in the microservice code and ensure that we only include these tables. </span><span class="koboSpan" id="kobo.29.3">In this model, it is common that some tables are denormalized representations of data that can be found in other tables, as the service they are created for requires the data</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.30.1"> in this format.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Schema-per-service</span></strong><span class="koboSpan" id="kobo.32.1">: Relational databases allow us to specify schema</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.33.1"> values to categorize our tables. </span><span class="koboSpan" id="kobo.33.2">A schema is an organizational unit in a database that helps us to categorize tables. </span><span class="koboSpan" id="kobo.33.3">We can use these to organize tables per service. </span><span class="koboSpan" id="kobo.33.4">Like the </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">tables-per-service</span></strong><span class="koboSpan" id="kobo.35.1"> pattern, the tables in each</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.36.1"> schema are optimized based on the needs of the matching microservice. </span><span class="koboSpan" id="kobo.36.2">We also have a better opportunity to tune access rights and restrictions per schema and reduce the security administration overhead.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Database-per-service</span></strong><span class="koboSpan" id="kobo.38.1">: Each microservice has its own</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.39.1"> database. </span><span class="koboSpan" id="kobo.39.2">This can be taken a step further by placing each database on its own server to reduce the infrastructural dependencies.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.40.1">Figure 7.1</span></em><span class="koboSpan" id="kobo.41.1"> shows multiple services connected to one database.</span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.42.1"><img alt="Figure 7.1 – Multiple services share one database, but schemas are created for each service to preserve segregation and data autonomy" src="image/Figure_7.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.43.1">Figure 7.1 – Multiple services share one database, but schemas are created for each service to preserve segregation and data autonomy</span></p>
<p><span class="koboSpan" id="kobo.44.1">Implementing tables</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.45.1"> and schemas per service has the lowest resource requirements since it would be the same thing as building one application on top of one database. </span><span class="koboSpan" id="kobo.45.2">The downside is that we retain a single point of failure and do not adequately scale the varied service demands.</span></p>
<p><span class="koboSpan" id="kobo.46.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">Database per Service</span></strong><span class="koboSpan" id="kobo.48.1"> approach, we can still use one server but provision each microservice with its own database. </span><span class="koboSpan" id="kobo.48.2">This approach matches the name of the pattern more appropriately, but infrastructurally maintains a common choke point that has all the databases on the same server. </span><span class="koboSpan" id="kobo.48.3">The most appropriate implementation to maintain service autonomy and reduce infrastructural dependencies would be to have each database and its reliant microservice in its own fault domain.</span></p>
<p><span class="koboSpan" id="kobo.49.1">Looking at this issue</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.50.1"> from another dimension, we can see that we have the flexibility to choose the best database technology for each service. </span><span class="koboSpan" id="kobo.50.2">Some services might favor a relational data store, while others might use a document data store more efficie</span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.51.1">ntly. </span><span class="koboSpan" id="kobo.51.2">We will discuss this further in the next section.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.52.1">Using different database technologies per service</span></h2>
<p><span class="koboSpan" id="kobo.53.1">Databases are the foundation</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.54.1"> of any application. </span><span class="koboSpan" id="kobo.54.2">A good or poor database design can determine how efficient your application is, how easily it can be extended, and how efficiently you can write your code.</span></p>
<p><span class="koboSpan" id="kobo.55.1">The use of the database-per-service pattern allows us to choose the best database for the operation that each microservice might complete. </span><span class="koboSpan" id="kobo.55.2">It would be ideal for a more homogenous technology stack that all developers can identify with and easily maintain. </span><span class="koboSpan" id="kobo.55.3">Attempting to remain homogenous, however, has led to shortcuts and extensive integration projects in the past, where the need to use one technology overshadowed the opportunity to use the best technology for the problem being addressed.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.56.1">Figure 7.2</span></em><span class="koboSpan" id="kobo.57.1"> shows multiple services connected to individual databases.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.58.1"><img alt="Figure 7.2 – Multiple services can be built using different technologies alongside the most appropriate development framework technology" src="image/Figure_7.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.59.1">Figure 7.2 – Multiple services can be built using different technologies alongside the most appropriate development framework technology</span></p>
<p><span class="koboSpan" id="kobo.60.1">Microservices</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.61.1"> allow us to have multiple teams that can choose the best technology stack to implement the solution and, by extension, they can use the best type of database technology to complement the technology and the problem. </span><span class="koboSpan" id="kobo.61.2">Some development frameworks tend to work best with certain database technologies, and this makes it easier to select the entire stack that is to be used for a particular microservice.</span></p>
<p><span class="koboSpan" id="kobo.62.1">Now that we have reviewed our database-per-service options, let us review some disadvantages of using this development pattern for our microservices architecture.</span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.63.1">Disadvantages of this pattern</span></h2>
<p><span class="koboSpan" id="kobo.64.1">We could spend all day singing</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.65.1"> the praises of this pattern and pointing out why it is the ideal path to take during the microservices development process. </span><span class="koboSpan" id="kobo.65.2">Despite all these advantages, however, we can point to potential pitfalls that we must overcome or learn to mitigate during runtime:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">Additional costs</span></strong><span class="koboSpan" id="kobo.67.1">: When we talk about having fewer infrastructural dependencies between our services, we talk about introducing more robust networking software and hardware, more servers, and more software licenses for the supporting software. </span><span class="koboSpan" id="kobo.67.2">Using a cloud platform might more easily offset some of the infrastructural and software costs, but even this approach will have a modest price tag.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Heterogenous development stack</span></strong><span class="koboSpan" id="kobo.69.1">: This is an advantage from the perspective of attempting to meet the business needs of the microservice as appropriately as possible. </span><span class="koboSpan" id="kobo.69.2">The bigger picture, however, comes when we need to source talent to maintain certain technologies that might have been used. </span><span class="koboSpan" id="kobo.69.3">Cross-training between teams is recommended but not always effective and a company can risk having a microservice built by past staff members that none of the current ones can maintain.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.70.1">Data synchronization</span></strong><span class="koboSpan" id="kobo.71.1">: We have already discussed the issue of </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Eventual Consistency</span></strong><span class="koboSpan" id="kobo.73.1">, which leads us down the path of implementing</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.74.1"> contingencies to deal with data being out of sync across multiple databases. </span><span class="koboSpan" id="kobo.74.2">This comes with additional code and infrastructure overhead to properly implement it.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.75.1">Transactional handling</span></strong><span class="koboSpan" id="kobo.76.1">: We are unable to ensure ACID transactions across databases, which can lead to inconsistent data between data stores. </span><span class="koboSpan" id="kobo.76.2">This will lead</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.77.1"> us to need another coding pattern called the </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">Saga Pattern</span></strong><span class="koboSpan" id="kobo.79.1">, which we will discuss further in the next chapter.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.80.1">Communication failure</span></strong><span class="koboSpan" id="kobo.81.1">: Because one microservice cannot directly access another’s database, we may need to introduce synchronous microservice communication to complete an operation. </span><span class="koboSpan" id="kobo.81.2">This introduces more potential failure points in the operation</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.82.1"> at hand. </span><span class="koboSpan" id="kobo.82.2">These can be mitigated using the </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">Circuit Breaker Pattern</span></strong><span class="koboSpan" id="kobo.84.1">, which will be discussed in subsequent chapters.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.85.1">It is always important</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.86.1"> to remember that with every pattern, we have pros and cons. </span><span class="koboSpan" id="kobo.86.2">We should never do an implementation solely because it is the </span><em class="italic"><span class="koboSpan" id="kobo.87.1">recommended way to go</span></em><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">We should always properly assess the problems that need to be addressed and choose the most appropriate solutions and patterns to ensure full coverage and at the best price.</span></p>
<p><span class="koboSpan" id="kobo.89.1">Now that we have discussed the dos and don’ts for our Database-per-Service pattern, let us move on to discuss best practices when designing a database.</span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.90.1">Developing a database</span></h1>
<p><span class="koboSpan" id="kobo.91.1">The ability to develop</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.92.1"> a capable database is paramount to a developer’s career. </span><span class="koboSpan" id="kobo.92.2">This role was once given to the database developer in a team, whose sole purpose was to do all things database. </span><span class="koboSpan" id="kobo.92.3">The application developer would simply write code to interact with the database based on the application’s needs.</span></p>
<p><span class="koboSpan" id="kobo.93.1">More recently, the role of a typical application developer</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.94.1"> evolved into what is now called a </span><em class="italic"><span class="koboSpan" id="kobo.95.1">full stack developer</span></em><span class="koboSpan" id="kobo.96.1"> role. </span><span class="koboSpan" id="kobo.96.2">This means that the modern developer needs to have as much application development knowledge as they do database development knowledge. </span><span class="koboSpan" id="kobo.96.3">It is now very common to see teams of two to three developers who work on a microservice team, and who can develop and maintain the user interface, application code, and database.</span></p>
<p><span class="koboSpan" id="kobo.97.1">Developing a database transcends one’s comfort level with the technology being used. </span><span class="koboSpan" id="kobo.97.2">In fact, that is the easy part. </span><span class="koboSpan" id="kobo.97.3">Many developers neglect to consult the business and fully understanding the business requirements before they start implementing the technology. </span><span class="koboSpan" id="kobo.97.4">This often leads to poor design and rework, and additional maintenance in the lifetime of the application.</span></p>
<p><span class="koboSpan" id="kobo.98.1">Since we are in the realm of microservices, we have the unique opportunity to build much smaller, target data stores, for tranches of the entire application. </span><span class="koboSpan" id="kobo.98.2">This makes it easier for us to ingest and analyze the storage needs of the service that we are focusing on and reduces the overall complexity of building a large database as a catch-all, thus reducing the margin for error during the design phase. </span><span class="koboSpan" id="kobo.98.3">As discussed previously, we can make better choices about the most appropriate database, which influences the design considerations that we make.</span></p>
<p><span class="koboSpan" id="kobo.99.1">Some services need relational integrity based on the nature of the data they process; others need to produce results fast more than they need to be accurate; some only need a key-value store. </span><span class="koboSpan" id="kobo.99.2">In the next section, we will compare the pros and cons of relational and non-relational data stores and when it is best to use each one.</span></p>
<p><span class="koboSpan" id="kobo.100.1">Databases are an integral part of how well an application performs and it is important to make the correct decision on which technology is used for which microservice. </span><span class="koboSpan" id="kobo.100.2">In the next section, start by assessing the pros and cons of using relational databases.</span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.101.1">Relational databases</span></h2>
<p><span class="koboSpan" id="kobo.102.1">Relational databases</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.103.1"> have been a mainstay</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.104.1"> for years. </span><span class="koboSpan" id="kobo.104.2">They have dominated the database technology landscape for some time and for good reason. </span><span class="koboSpan" id="kobo.104.3">They are built on rigid principles that complement clean and efficient data storage while ensuring a degree of accuracy in what is stored.</span></p>
<p><span class="koboSpan" id="kobo.105.1">Some of the most popular relational database management systems include the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">SQL Server</span></strong><span class="koboSpan" id="kobo.107.1">: This is Microsoft’s flagship relational database</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.108.1"> management</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.109.1"> system, which is widely used by individuals and enterprises alike for application development.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.110.1">MySQL / MariaDB</span></strong><span class="koboSpan" id="kobo.111.1">: MySQL is a traditionally open source</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.112.1"> and free-to-use database</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.113.1"> management system that is mostly used for PHP development. </span><span class="koboSpan" id="kobo.113.2">MariaDB was forked from the original MySQL code base and is maintained by a community of developers to maintain the free-to-use policy.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.114.1">PostgreSQL</span></strong><span class="koboSpan" id="kobo.115.1">: A free and open source database </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.116.1">management system</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.117.1"> that is robust enough to handle a wide range of workloads, from individual projects to data warehouses.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.118.1">Oracle Database</span></strong><span class="koboSpan" id="kobo.119.1">: This is Oracle Corporation’s flagship database</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.120.1"> management system, which</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.121.1"> is designed to handle a wide range of operations, from real-time transaction processing to data warehousing and even mixed workloads.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.122.1">IBM DB2</span></strong><span class="koboSpan" id="kobo.123.1">: Developed by IBM on top of one of the most</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.124.1"> reliable systems for high transaction</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.125.1"> and traffic enterprise settings. </span><span class="koboSpan" id="kobo.125.2">This database supports relational and object-relational structures.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.126.1">SQLite</span></strong><span class="koboSpan" id="kobo.127.1">: A free and lightweight database storage</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.128.1"> option for a quick and easy </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.129.1">database. </span><span class="koboSpan" id="kobo.129.2">Unlike most alternatives that require a server, oftentimes a dedicated machine, SQLite databases can live in the same filesystem as the app it is being integrated into, making it an excellent choice</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.130.1"> for mobile-first</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.131.1"> apps.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.132.1">Through a process called </span><em class="italic"><span class="koboSpan" id="kobo.133.1">normalization</span></em><span class="koboSpan" id="kobo.134.1">, data is efficiently shared across </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.135.1">multiple tables, with references or </span><em class="italic"><span class="koboSpan" id="kobo.136.1">indexes</span></em><span class="koboSpan" id="kobo.137.1"> created between</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.138.1"> each table. </span><span class="koboSpan" id="kobo.138.2">Good design principles</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.139.1"> encourage you to have a </span><em class="italic"><span class="koboSpan" id="kobo.140.1">primary key</span></em><span class="koboSpan" id="kobo.141.1"> column present in each table, which will always have a unique value, to uniquely identify a record. </span><span class="koboSpan" id="kobo.141.2">This unique value is then referenced by other tables in the form of a </span><em class="italic"><span class="koboSpan" id="kobo.142.1">foreign key</span></em><span class="koboSpan" id="kobo.143.1">, which helps to reduce the number</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.144.1"> of times data repeats across tables.</span></p>
<p><span class="koboSpan" id="kobo.145.1">These simple references</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.146.1"> go a long way to ensure that the data is accurate across tables. </span><span class="koboSpan" id="kobo.146.2">Once this association is created between the primary and foreign</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.147.1"> keys, we have created what we call a </span><em class="italic"><span class="koboSpan" id="kobo.148.1">relationship</span></em><span class="koboSpan" id="kobo.149.1">, which introduces a </span><em class="italic"><span class="koboSpan" id="kobo.150.1">constraint</span></em><span class="koboSpan" id="kobo.151.1"> or restriction on what values are possible</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.152.1"> in the foreign</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.153.1"> key column. </span><span class="koboSpan" id="kobo.153.2">This is also referred to as </span><em class="italic"><span class="koboSpan" id="kobo.154.1">referential integrity.</span></em></p>
<p><span class="koboSpan" id="kobo.155.1">Relationships</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.156.1"> can be further defined by their </span><em class="italic"><span class="koboSpan" id="kobo.157.1">cardinality</span></em><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">This refers to the nature by which the primary key values will be referenced in the other table. </span><span class="koboSpan" id="kobo.158.3">The most common cardinalities are as follows:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.159.1">One-to-one</span></strong><span class="koboSpan" id="kobo.160.1">: This means that a primary key value</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.161.1"> is referenced exactly once</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.162.1"> in another table as a foreign key. </span><span class="koboSpan" id="kobo.162.2">For instance, if a customer can only have one address on record. </span><span class="koboSpan" id="kobo.162.3">The table storing the address cannot have multiple records that refer to the same customer.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">One-to-many</span></strong><span class="koboSpan" id="kobo.164.1">: This means that the primary key value</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.165.1"> can be referenced</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.166.1"> multiple times in another table. </span><span class="koboSpan" id="kobo.166.2">For instance, if a customer has made multiple orders, then we have one customer’s ID referenced multiple times in the orders table.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.167.1">Many-to-many</span></strong><span class="koboSpan" id="kobo.168.1">: This means that a primary key</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.169.1"> can be referenced</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.170.1"> multiple times as a foreign key in another table, and that table’s primary key can be referenced multiple times in the original table. </span><span class="koboSpan" id="kobo.170.2">This can get confusing and implementing it as it is described will directly violate the referential integrity that we are fighting hard to maintain. </span><span class="koboSpan" id="kobo.170.3">This is where a </span><em class="italic"><span class="koboSpan" id="kobo.171.1">linker table</span></em><span class="koboSpan" id="kobo.172.1"> is introduced as an intermediary</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.173.1"> to associate the different combinations</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.174.1"> of key values from either table.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.175.1">Using the example of our health care management system, if we revisit how appointments are tracked relative</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.176.1"> to the customer who has made them, we will see that we implemented a reference point between the customer’s ID, their primary key, and the appointment. </span><span class="koboSpan" id="kobo.176.2">This ensures that we do not repeat the customer’s information every time an appointment is booked. </span><span class="koboSpan" id="kobo.176.3">An appointment also cannot be created for a customer who is not already in the system.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.177.1">Figure 7.3</span></em><span class="koboSpan" id="kobo.178.1"> shows a typical relationship.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.179.1"><img alt="Figure 7.3 – An example of a one-to-many relationship where one customer is referenced many times in the appointments table" src="image/Figure_7.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Figure 7.3 – An example of a one-to-many relationship where one customer is referenced many times in the appointments table</span></p>
<p><span class="koboSpan" id="kobo.181.1">Many-to-many relationships </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.182.1">do occur often and it is important to recognize them. </span><span class="koboSpan" id="kobo.182.2">Building on the example of customers and their appointments, we can expand and see that we also have a need to associate a customer with a room for an appointment. </span><span class="koboSpan" id="kobo.182.3">The same room is not always guaranteed, which leads us to realize that many customers will book appointments, and appointments might happen in many rooms. </span><span class="koboSpan" id="kobo.182.4">If we try a direct association, then details of either the customer or the room will need to be repeated to reflect the many possible combinations of customers, rooms, and appointments.</span></p>
<p><span class="koboSpan" id="kobo.183.1">Ideally, we would have a table storing rooms and the associated details, a table storing customers, and an appointments table sitting between the two, which seeks to associate them on the day as needed.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.184.1">Figure 7.4</span></em><span class="koboSpan" id="kobo.185.1"> shows a typical</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.186.1"> many-to-many relationship.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.187.1"><img alt="Figure 7.4 – An example of a many-to-many relationship where we associate many records from two different tables using an intermediary linker table" src="image/Figure_7.4_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">Figure 7.4 – An example of a many-to-many relationship where we associate many records from two different tables using an intermediary linker table</span></p>
<p><span class="koboSpan" id="kobo.189.1">We have already discussed ACID principles and why they are important. </span><span class="koboSpan" id="kobo.189.2">Relational databases are designed to ensure that these principles can be observed as a default mode of operation. </span><span class="koboSpan" id="kobo.189.3">This makes changing the layout and references of tables relatively difficult, especially if the changes involve changing how tables are related to each other.</span></p>
<p><span class="koboSpan" id="kobo.190.1">Another potential drawback of relational database storage comes in terms of performance with large datasets. </span><span class="koboSpan" id="kobo.190.2">Relational databases are typically efficient in data storage, retrieval, and overall speed. </span><span class="koboSpan" id="kobo.190.3">They are built to manage large workloads, so the technology itself is hardly at fault, but our design will either complement speed or inhibit it.</span></p>
<p><span class="koboSpan" id="kobo.191.1">These are trade-offs of proper </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.192.1">relational database design and upholding relational integrity. </span><span class="koboSpan" id="kobo.192.2">Design principles favor normalization, where bits of data are spread across multiple tables, and this is good until we need the data and need to traverse multiple tables with potentially thousands of records to get it. </span><span class="koboSpan" id="kobo.192.3">Considering this deficiency, NoSQL or document storage databases have become more and more popular, as they seek to store</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.193.1"> data in one place, making the retrieval process much faster.</span></p>
<p><span class="koboSpan" id="kobo.194.1">We discuss the use of non-relational databases in the next section.</span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.195.1">Non-relational databases</span></h2>
<p><span class="koboSpan" id="kobo.196.1">Non-relational databases</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.197.1"> took the database world by storm. </span><span class="koboSpan" id="kobo.197.2">That might</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.198.1"> be a naive assessment of the impact that they have had, but the fact remains that they introduced a dimension to data storage that was not very popular or widely used. </span><span class="koboSpan" id="kobo.198.2">They came along and proposed a far more flexible and scalable data storage technique that favored a more agile development style.</span></p>
<p><span class="koboSpan" id="kobo.199.1">Agile development hinges on the ability to morph a project as we go along. </span><span class="koboSpan" id="kobo.199.2">This means that the excess amounts of scoping and planning that would be recommended when using a relational data store would not be necessary upfront. </span><span class="koboSpan" id="kobo.199.3">Instead, we could start with an idea of a system and begin using a non-relational data store to accommodate that tiny part, and as the system evolves, so could the data store, with minimal risk of data loss or attrition.</span></p>
<p><span class="koboSpan" id="kobo.200.1">Non-relational databases</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.201.1"> are also referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">NoSQL databases</span></strong><span class="koboSpan" id="kobo.203.1">, or </span><em class="italic"><span class="koboSpan" id="kobo.204.1">not only SQL</span></em><span class="koboSpan" id="kobo.205.1">, and they favor a non-tabular data storage model. </span><span class="koboSpan" id="kobo.205.2">The most popular NoSQL databases use a document style of storage, where each record is stored in one document, containing all the details needed for that record. </span><span class="koboSpan" id="kobo.205.3">This directly</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.206.1"> violates the principles of </span><em class="italic"><span class="koboSpan" id="kobo.207.1">normalization</span></em><span class="koboSpan" id="kobo.208.1">, which would have us spread the data to</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.209.1"> reduce possible redundancy. </span><span class="koboSpan" id="kobo.209.2">The major advantage of this model, however, is the speed with which we can write and retrieve data since all the details are in one place.</span></p>
<p><span class="koboSpan" id="kobo.210.1">Using the example of our health care appointment management system, if we were to store an appointment in the form of a document, it would look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
{
    "AppointmentId":"5d83d288-6404-4cd5-8526-7af6eabd97b3",
    "Date":"2022-09-01 08:000",
    "Room":{
        "Id":"4fff8260-85ce-45cd-919e-35f0aaf7d51e",
        "Name":"Room 1"
    },
    "Customer": {
        "Id":"4fff8260-85ce-45cd-919e-35f0aaf7d51e",
        "FirstName":"John",
        "LastName":"Higgins"
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.212.1">Unlike with the relational</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.213.1"> model, where these details were split across multiple tables</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.214.1"> and simply referenced, we have the opportunity to include all the details needed to fully assess what an appointment entails.</span></p>
<p><span class="koboSpan" id="kobo.215.1">Types of NoSQL databases include the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.216.1">Document database</span></strong><span class="koboSpan" id="kobo.217.1">: Stores data in the form of </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.219.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.220.1">JSON</span></strong><span class="koboSpan" id="kobo.221.1">) objects. </span><span class="koboSpan" id="kobo.221.2">This JSON document</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.222.1"> outlines fields and values</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.223.1"> and can support</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.224.1"> a hierarchy of JSON objects and collections all in one document. </span><span class="koboSpan" id="kobo.224.2">Popular examples include </span><em class="italic"><span class="koboSpan" id="kobo.225.1">MongoDB</span></em><span class="koboSpan" id="kobo.226.1">, </span><em class="italic"><span class="koboSpan" id="kobo.227.1">CosmosDB</span></em><span class="koboSpan" id="kobo.228.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.229.1">CouchDB</span></em><span class="koboSpan" id="kobo.230.1">.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.231.1">Key-value database</span></strong><span class="koboSpan" id="kobo.232.1">: Stores data in simple key-value pairs. </span><span class="koboSpan" id="kobo.232.2">Values</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.233.1"> are usually stored as string</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.234.1"> values, and they do not natively support storing complex data objects. </span><span class="koboSpan" id="kobo.234.2">They are usually used as quick lookup storage areas, like for application caching. </span><span class="koboSpan" id="kobo.234.3">A popular example of this is </span><em class="italic"><span class="koboSpan" id="kobo.235.1">Redis</span></em><span class="koboSpan" id="kobo.236.1">.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.237.1">Graph database</span></strong><span class="koboSpan" id="kobo.238.1">: Stores data in nodes and edges. </span><span class="koboSpan" id="kobo.238.2">A node stores</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.239.1"> information on the object, such</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.240.1"> as a person or place, and the edges represent relationships between the nodes. </span><span class="koboSpan" id="kobo.240.2">These relationships link how data points relate to each other, as opposed to how records relate to each other. </span><span class="koboSpan" id="kobo.240.3">A popular example of this is </span><em class="italic"><span class="koboSpan" id="kobo.241.1">Neo4j</span></em><span class="koboSpan" id="kobo.242.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.243.1">The clear advantages</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.244.1"> of using NoSQL document databases come from the way that data is stored. </span><span class="koboSpan" id="kobo.244.2">Unlike with the relational model, we do not need to traverse many relationships and tables to get a fully human-readable record of data. </span><span class="koboSpan" id="kobo.244.3">As seen in the preceding example, we can store all the details in one document and simply scale from there. </span><span class="koboSpan" id="kobo.244.4">This comes in handy when we might need to do fast read operations and do not want to compromise system performance with complex queries.</span></p>
<p><span class="koboSpan" id="kobo.245.1">A clear disadvantage, however, comes from how storage</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.246.1"> is handled. </span><span class="koboSpan" id="kobo.246.2">Document databases do very little, if anything at all, to reduce the risk of data redundancy. </span><span class="koboSpan" id="kobo.246.3">We will end up repeating details of what would have been related data, which means that the maintenance of this data, in the long run, could become a problem. </span><span class="koboSpan" id="kobo.246.4">Using our customer records as examples, if we needed to add a new data point for each customer that has booked an appointment, we would need to traverse the appointment records to make one change. </span><span class="koboSpan" id="kobo.246.5">This would be a much easier and more efficient operation using a relational model.</span></p>
<p><span class="koboSpan" id="kobo.247.1">Now that we have discovered some of the advantages and disadvantages of relational and non-relational database stores, let us discuss scenarios where either would be a good choice.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.248.1">Choosing a database technology</span></h2>
<p><span class="koboSpan" id="kobo.249.1">When choosing</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.250.1"> the best technology for anything, we are faced with several factors:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.251.1">Maintainability</span></strong><span class="koboSpan" id="kobo.252.1">: How easy is this technology to maintain? </span><span class="koboSpan" id="kobo.252.2">Does it have excessive infrastructural and software requirements? </span><span class="koboSpan" id="kobo.252.3">How often are updates and security patches produced for the technology? </span><span class="koboSpan" id="kobo.252.4">Ultimately, we want to ensure that we do not regret our selection weeks into starting the project.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.253.1">Extensibility</span></strong><span class="koboSpan" id="kobo.254.1">: To what extent can I use this technology to implement my software? </span><span class="koboSpan" id="kobo.254.2">What happens when the requirements change and the project needs to adapt? </span><span class="koboSpan" id="kobo.254.3">We want to ensure that our technology is not too rigid and can support the dynamics of the business needs.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.255.1">Supporting technologies</span></strong><span class="koboSpan" id="kobo.256.1">: Is the technology stack that I am using the best fit? </span><span class="koboSpan" id="kobo.256.2">We are often forced to take shortcuts and implement methods, sometimes contrary to best practices, to facilitate matching technologies that are not the best fit for each other. </span><span class="koboSpan" id="kobo.256.3">With more libraries being produced to support integrations of heterogenous technology stacks, this is becoming less of an issue, but is still something that we want to take into consideration from day one.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.257.1">Comfort level</span></strong><span class="koboSpan" id="kobo.258.1">: How comfortable are you and the team with the technology? </span><span class="koboSpan" id="kobo.258.2">It is always nice to use new technology and expand your scope and experience, but it is important to recognize your limitations and knowledge gaps. </span><span class="koboSpan" id="kobo.258.3">These can just as easily be addressed with training, but we always want to ensure that we can handle the technology that we choose and are not prone to surprises in the long run.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.259.1">Maturity</span></strong><span class="koboSpan" id="kobo.260.1">: How mature is the technology? </span><span class="koboSpan" id="kobo.260.2">In some development circles, technology lives for months at a time. </span><span class="koboSpan" id="kobo.260.3">We don’t want to embrace new technology the day it is released without doing our due diligence. </span><span class="koboSpan" id="kobo.260.4">Seek to choose more mature technologies that have been tried and proven and have strong enterprise or community support and documentation.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.261.1">Appropriateness</span></strong><span class="koboSpan" id="kobo.262.1">: Lastly, how appropriate is the technology for the application? </span><span class="koboSpan" id="kobo.262.2">We want to ensure that we use the best technology possible to do the job at hand. </span><span class="koboSpan" id="kobo.262.3">This sometimes gets compromised considering the bigger picture, which includes budget constraints, the type of project, team experience, and the business’ risk appetite, but as much as possible, we want to ensure that the technology we choose can adequately address the needs of the project.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.263.1">Now let us narrow </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.264.1">this down to database development. </span><span class="koboSpan" id="kobo.264.2">We have gone through the pros and cons of the different types of database models and the different technology providers for each. </span><span class="koboSpan" id="kobo.264.3">While we are not limited to the options outlined, they serve as guidelines to help us make out assessments from the most unbiased point of view possible.</span></p>
<p><span class="koboSpan" id="kobo.265.1">Within the context of microservices, we want to choose the best database for the service’s needs. </span><span class="koboSpan" id="kobo.265.2">There are no hard and fast rules surrounding which storage mechanism should be used outright, but there are recommendations that can help to guide you during the system design.</span></p>
<p><span class="koboSpan" id="kobo.266.1">You can consider using relational databases</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.267.1"> in the following situations:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.268.1">Working with complex reports and queries</span></strong><span class="koboSpan" id="kobo.269.1">: Relational databases can run efficient queries across large datasets and are a much better storage option for generating reports.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.270.1">Working with a high transaction application</span></strong><span class="koboSpan" id="kobo.271.1">: Relational databases are a good fit for heavy-duty and complex transaction operations. </span><span class="koboSpan" id="kobo.271.2">They do a good job of ensuring data integrity and stability.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.272.1">You require ACID compliance</span></strong><span class="koboSpan" id="kobo.273.1">: Relational databases are based on ACID principles, which can go a long way in protecting your data and ensuring accuracy and completeness.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.274.1">Your service will not evolve rapidly</span></strong><span class="koboSpan" id="kobo.275.1">: If your service doesn’t have changing requirements, then</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.276.1"> a database should be easy to design and maintain in the long run.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.277.1">You can consider</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.278.1"> using a non-relational database</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.279.1"> in the following situations:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.280.1">Your service is constantly evolving, and you need a flexible data store that can adapt to new requirements without too much disruption.</span></li>
<li><span class="koboSpan" id="kobo.281.1">You anticipate that data may not be clean or meet a certain standard all the time. </span><span class="koboSpan" id="kobo.281.2">Given the flexibility that we have with non-relational data stores, we accommodate data of varying levels of accuracy and completeness.</span></li>
<li><span class="koboSpan" id="kobo.282.1">You need to support rapid scaling: This point goes hand in hand with the need to evolve the data store based on the needs of the business, so we can ensure that the database can be changed with minimal code changes and low costs.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.283.1">Now that we have</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.284.1"> explored some of the major considerations regarding choosing a database technology, let us review our options for interacting with a database with code.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.285.1">Choosing an ORM</span></h2>
<p><span class="koboSpan" id="kobo.286.1">Choosing an </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">ORM</span></strong><span class="koboSpan" id="kobo.288.1"> is an important part of the design</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.289.1"> process. </span><span class="koboSpan" id="kobo.289.2">This lays</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.290.1"> a foundation for how our application will communicate with our database. </span><span class="koboSpan" id="kobo.290.2">The abbreviation </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">ORM</span></strong><span class="koboSpan" id="kobo.292.1"> is short for </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">Object Relational Mapping</span></strong><span class="koboSpan" id="kobo.294.1">.</span></p>
<p><span class="koboSpan" id="kobo.295.1">Every language</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.296.1"> has support for some form of ORM. </span><span class="koboSpan" id="kobo.296.2">Sometimes this is built into the language, and sometimes developers and architects alike contract the use of an external package or library to support database-related operations. </span><span class="koboSpan" id="kobo.296.3">In the context of .NET, we have several options, and each has its pros and cons. </span><span class="koboSpan" id="kobo.296.4">The most popular options are as follows:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.297.1">Entity Framework Core</span></strong><span class="koboSpan" id="kobo.298.1">: The most popular and obvious choice</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.299.1"> of .NET developers. </span><span class="koboSpan" id="kobo.299.2">It is a Microsoft-developed and maintained ORM that is packaged with .NET. </span><span class="koboSpan" id="kobo.299.3">It implements a C# query-like syntax called LINQ, which makes it easy to write C# code</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.300.1"> that will execute a query at runtime on the developer’s behalf and has support for most relational and non-relational database technologies.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.301.1">Dapper</span></strong><span class="koboSpan" id="kobo.302.1">: Dapper is considered a </span><em class="italic"><span class="koboSpan" id="kobo.303.1">MicroORM</span></em><span class="koboSpan" id="kobo.304.1"> as it is a fast, lightweight</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.305.1"> ORM for .NET. </span><span class="koboSpan" id="kobo.305.2">It provides a clean and extendable interface for constructing SQL queries and executing them in a secure and efficient manner. </span><span class="koboSpan" id="kobo.305.3">Its performance has always rivaled that of Entity Framework.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.306.1">NHibernate</span></strong><span class="koboSpan" id="kobo.307.1">: NHibernate is an open source</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.308.1"> ORM that has been widely used as an alternative to Entity Framework. </span><span class="koboSpan" id="kobo.308.2">It has wide support for database technologies and offers alternative methods of handling object mapping and query construction that developers have come to prefer.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.309.1">There are other ORMs, but these are arguably the most popular and widely used options.</span></p>
<p><span class="koboSpan" id="kobo.310.1">Entity Framework Core has undergone constant improvement and is currently open source and provides excellent interfaces and abstractions that reduce the need for specific code to be written based on the database being accessed. </span><span class="koboSpan" id="kobo.310.2">This is a significant feature as it allows us to reuse code across different database technologies and helps us to be flexible in terms of the database technology being used. </span><span class="koboSpan" id="kobo.310.3">We can easily change the database technology without affecting the main application and its operations. </span><span class="koboSpan" id="kobo.310.4">Barring the presence of any obvious bias on why we should use Entity Framework in our .NET projects, it does help that we can keep our technology stack homogenous.</span></p>
<p><span class="koboSpan" id="kobo.311.1">To integrate Entity Framework Core, or </span><em class="italic"><span class="koboSpan" id="kobo.312.1">EF Core</span></em><span class="koboSpan" id="kobo.313.1"> for short, into our .NET application, we would need to add the package that is designed for our preferred database technology. </span><span class="koboSpan" id="kobo.313.2">For this example, we can use SQLite</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.314.1"> given its versatility. </span><span class="koboSpan" id="kobo.314.2">The commands to add the packages would look like this:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.315.1">
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
dotnet add package Microsoft.EntityFrameworkCore.Design</span></pre>
<p><span class="koboSpan" id="kobo.316.1">The first command adds all the core and supporting EF Core libraries needed to communicate with a SQLite database and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Microsoft.EntityFrameworkCore.Design</span></strong><span class="koboSpan" id="kobo.318.1"> package adds support for design time logic for migrations and other operations. </span><span class="koboSpan" id="kobo.318.2">We will investigate migrations in the next section.</span></p>
<p><span class="koboSpan" id="kobo.319.1">The next thing we need is a data context class, which serves as a code-level abstraction of the database and the tables therein. </span><span class="koboSpan" id="kobo.319.2">This context file will outline the database objects that we wish to access and refer to them. </span><span class="koboSpan" id="kobo.319.3">So, if our SQLite database should have a table that stores patient information, then we need a class that is modeled from how the patient table should look as well.</span></p>
<p><span class="koboSpan" id="kobo.320.1">Our data context file looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.321.1">
public class ApplicationDatabaseContext : DbContext
  {
    public DbSet&lt;Patient&gt; Patients { get; set; }
    protected override void OnConfiguring
        (DbContextOptionsBuilder optionsBuilder)
    {
      optionsBuilder.UseSqlite("Data Source=patients.db");
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.322.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">ApplicationDatabaseContext</span></strong><span class="koboSpan" id="kobo.324.1"> class inherits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">DbContext</span></strong><span class="koboSpan" id="kobo.326.1">, which is a class provided by EF Core that gives us access to the database operations and functions. </span><span class="koboSpan" id="kobo.326.2">We also have a property of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">DbSet</span></strong><span class="koboSpan" id="kobo.328.1">, which requires a reference type and a name. </span><span class="koboSpan" id="kobo.328.2">The reference type will be the class that models a table, and the name of the property will be the code-level reference point for the table. </span><span class="koboSpan" id="kobo.328.3">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">DbSet</span></strong><span class="koboSpan" id="kobo.330.1"> represents the collection of records in the referenced</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.331.1"> table. </span><span class="koboSpan" id="kobo.331.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">OnConfiguring</span></strong><span class="koboSpan" id="kobo.333.1"> method sets up the connection string to our database. </span><span class="koboSpan" id="kobo.333.2">This connection string will vary based on the type of database we are connecting to.</span></p>
<p><span class="koboSpan" id="kobo.334.1">Now, our patients table will have a few fields and we need a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Patient</span></strong><span class="koboSpan" id="kobo.336.1">, which has C# properties that represent the column names and data types as accurately as possible, relative to how they are presented in the database:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
public class Patient
  {
    // EF Core will add auto increment and Primary Key
        constraints to the Id property automatically
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string TaxId { get; set; }
   // Using ? </span><span class="koboSpan" id="kobo.337.2">beside a data type indicates to the database
        that the field is nullable
    public DateTime? </span><span class="koboSpan" id="kobo.337.3">DateOfBirth { get; set; }
  }</span></pre>
<p><span class="koboSpan" id="kobo.338.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Patient</span></strong><span class="koboSpan" id="kobo.340.1"> class is a typical class. </span><span class="koboSpan" id="kobo.340.2">It simply represents what we want a patient record to look like both in the database and in our application. </span><span class="koboSpan" id="kobo.340.3">This way, we abstract much of the database-specific code and use a standard C# class and standard C# code to interact with our tables and data.</span></p>
<p><span class="koboSpan" id="kobo.341.1">A simple database query to retrieve and print all the records from the patients table would look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
// initialize a connection to the database
  using var context = new ApplicationDatabaseContext();
// Go to the database a retrieve a list of patients
  var patients = await context.Patients.ToListAsync();
// Iterate through the list and print to the screen
  foreach (var patient in patients)
{
  Console.WriteLine($"{patient.FirstName}
     {patient.LastName}");
}</span></pre>
<p><span class="koboSpan" id="kobo.343.1">We can see how cleanly we can use the LINQ syntax in C# and execute a query. </span><span class="koboSpan" id="kobo.343.2">EF Core will attempt to generate the most efficient SQL syntax, carry out the operation, and return the data in the form of objects fashioned by the class that models the table. </span><span class="koboSpan" id="kobo.343.3">We can then interact with the records as standard C# objects.</span></p>
<p><span class="koboSpan" id="kobo.344.1">EF Core gives us a complete way to interact with our database and carry out our operations without needing to break much from our C# syntax. </span><span class="koboSpan" id="kobo.344.2">To go beyond the example shared above, EF Core has full support for dependency injection, which makes connection management and garbage collection almost a non-issue.</span></p>
<p><span class="koboSpan" id="kobo.345.1">A fundamental step</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.346.1"> that was not addressed above comes in the form of database development techniques that govern how we can create our database in our project. </span><span class="koboSpan" id="kobo.346.2">We also have the issue of migrations. </span><span class="koboSpan" id="kobo.346.3">We will discuss those in the next section.</span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.347.1">Choosing a database development technique</span></h2>
<p><span class="koboSpan" id="kobo.348.1">There are best practices</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.349.1"> and general guidelines that govern how databases are designed. </span><span class="koboSpan" id="kobo.349.2">In this section, we are not going to explore or contest those, but we will discuss the possible approaches that exist to materialize a database to support our application.</span></p>
<p><span class="koboSpan" id="kobo.350.1">There are two popular types of development techniques:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.351.1">Schema-first</span></strong><span class="koboSpan" id="kobo.352.1">: Also called </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Database-First</span></strong><span class="koboSpan" id="kobo.354.1">, this technique sees</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.355.1"> us creating the database</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.356.1"> using the usual database management tools. </span><span class="koboSpan" id="kobo.356.2">We then </span><em class="italic"><span class="koboSpan" id="kobo.357.1">scaffold</span></em><span class="koboSpan" id="kobo.358.1"> the database into our application. </span><span class="koboSpan" id="kobo.358.2">Using Entity Framework, we will get a database context class that represents the database and all the objects within, as well as classes per table and view.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.359.1">Code-first</span></strong><span class="koboSpan" id="kobo.360.1">: This technique allows us to model </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.361.1">the database</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.362.1"> more fluently alongside our application code. </span><span class="koboSpan" id="kobo.362.2">We create the data models using standard C# classes (as we saw in the previous section) and manage the changes to the data models and eventual database using </span><em class="italic"><span class="koboSpan" id="kobo.363.1">migrations</span></em><span class="koboSpan" id="kobo.364.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.365.1">Whether we intend to scaffold a database or use the code-first approach, we can use </span><em class="italic"><span class="koboSpan" id="kobo.366.1">dotnet CLI</span></em><span class="koboSpan" id="kobo.367.1"> commands that are made available via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">Microsoft.EntityFrameworkCore.Tools</span></strong><span class="koboSpan" id="kobo.369.1"> package. </span><span class="koboSpan" id="kobo.369.2">You can add this package to your project using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">dotnet add package</span></strong><span class="koboSpan" id="kobo.371.1"> command.</span></p>
<p><span class="koboSpan" id="kobo.372.1">To scaffold a database, the commands look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
dotnet ef dbcontext scaffold "DataSource=PATH_TO_FILE"
  Microsoft.EntityFrameworkCore.Sqlite -o Models</span></pre>
<p><span class="koboSpan" id="kobo.374.1">This command</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.375.1"> simply states that we wish to generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">dbcontext</span></strong><span class="koboSpan" id="kobo.377.1"> based on the database that is located at the connection string that is provided. </span><span class="koboSpan" id="kobo.377.2">Based on the technology of the target database (SQL Server, Oracle, and so on), this connection string will be different, but in this example, we’re looking at scaffolding an SQLite database in our application. </span><span class="koboSpan" id="kobo.377.3">We then specify the database provider package that is most appropriate for the target database and output the generated files</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.378.1"> to a directory in our project called </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Models</span></strong><span class="koboSpan" id="kobo.380.1">. </span><span class="koboSpan" id="kobo.380.2">This command is also agnostic to the IDE being used.</span></p>
<p><span class="koboSpan" id="kobo.381.1">This command can also look like this, and this format is more popularly used when working in Visual Studio:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
Scaffold-DbContext "DataSource=PATH_TO_FILE"
  Microsoft.EntityFrameworkCore.Sqlite --output-dir Models</span></pre>
<p><span class="koboSpan" id="kobo.383.1">Either command needs to be executed within the directory of the project being worked on. </span><span class="koboSpan" id="kobo.383.2">Each time a change is made to the database, we need to rerun this command to ensure that the code reflects the latest version of the database. </span><span class="koboSpan" id="kobo.383.3">It will overwrite the existing files accordingly.</span></p>
<p><span class="koboSpan" id="kobo.384.1">One limitation here is that we are not always able to track all the changes that are happening in the database and adequately track what changes each time we run this command. </span><span class="koboSpan" id="kobo.384.2">Therefore, code-first is a very popular option for database development and its use of migrations helps us to solve this problem.</span></p>
<p><span class="koboSpan" id="kobo.385.1">The concept of migrations is not unique to EF Core, but it is present in several other frameworks in other languages as well. </span><span class="koboSpan" id="kobo.385.2">It is a simple process that tracks all the changes being made to a data model as we write our applications and the tables and objects evolve. </span><span class="koboSpan" id="kobo.385.3">A migration will evaluate the changes being applied to the database and generate commands (which eventually become SQL scripts) to effect those changes against the database.</span></p>
<p><span class="koboSpan" id="kobo.386.1">Unlike with the database-first model, where</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.387.1"> we need to use source control with a dedicated database project, migrations are natively available in our code base and tell the story of every adjustment that is made to the database along the way.</span></p>
<p><span class="koboSpan" id="kobo.388.1">Following the example of using EF Core to add a database to our application, we already created the database context class as well as a patient class. </span><span class="koboSpan" id="kobo.388.2">So, a direct translation of the code would be that our database context is the database, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">Patient.cs</span></strong><span class="koboSpan" id="kobo.390.1"> is our table. </span><span class="koboSpan" id="kobo.390.2">To materialize the database with the table, we need to create a migration that will generate the assets as outlined. </span><span class="koboSpan" id="kobo.390.3">We need the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Microsoft.EntityFrameworkCore.Tools</span></strong><span class="koboSpan" id="kobo.392.1"> package to run our command-line commands and the command to create our first migration will look like this:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.393.1">
dotnet ef migrations add InitialCreate</span></pre>
<p><span class="koboSpan" id="kobo.394.1">Or, it will look like this:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.395.1">
Add-Migration InitialCreate</span></pre>
<p><span class="koboSpan" id="kobo.396.1">Here, we simply generate a migration</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.397.1"> file and give it the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">InitialCreate</span></strong><span class="koboSpan" id="kobo.399.1">. </span><span class="koboSpan" id="kobo.399.2">Naming our migrations helps us to visibly track what might have changed in that operation and helps our team as well. </span><span class="koboSpan" id="kobo.399.3">Each time we make a change to a data model and/or the database context class, we need to create a new migration, which will produce commands that outline the best possible interpretations of what has changed since the last known version of the database.</span></p>
<p><span class="koboSpan" id="kobo.400.1">This command will generate a class with </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Up</span></strong><span class="koboSpan" id="kobo.402.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">Down</span></strong><span class="koboSpan" id="kobo.404.1"> methods that outline what changes are to be applied, and what will be undone if the migration is reversed. </span><span class="koboSpan" id="kobo.404.2">This makes it convenient for us to make sure that the changes we intended are what will be carried out and we can remove a migration and make corrections before these changes are applied. </span><span class="koboSpan" id="kobo.404.3">Migrations can only be removed before they are applied to the database and the command for that looks like this:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.405.1">
dotnet ef migrations remove</span></pre>
<p><span class="koboSpan" id="kobo.406.1">Or, it looks like this:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.407.1">
Remove-Migration</span></pre>
<p><span class="koboSpan" id="kobo.408.1">When we are satisfied that a migration correctly outlines the changes that we intend to make, we can apply it using the simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">database update</span></strong><span class="koboSpan" id="kobo.410.1"> command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.411.1">
dotnet ef database update</span></pre>
<p><span class="koboSpan" id="kobo.412.1">Or, we can use the following:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.413.1">
Update-Database</span></pre>
<p><span class="koboSpan" id="kobo.414.1">If source control is being used with your project, then migrations will always be included in the code base for other team members to see and evaluate if necessary. </span><span class="koboSpan" id="kobo.414.2">It is important to collaborate with team members when making these adjustments as well. </span><span class="koboSpan" id="kobo.414.3">It is possible to have migration collisions if changes are not coordinated and this can lead to mismatched database versions if a central database is being used. </span><span class="koboSpan" id="kobo.414.4">Ultimately, if we need a fresh copy of the database as of the latest migrations, we can simply change our connection string to target a server and an intended database name, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Update-Database</span></strong><span class="koboSpan" id="kobo.416.1"> command, and have EF Core generate a database that reflects the most recent version of our database.</span></p>
<p><span class="koboSpan" id="kobo.417.1">Now that we understand</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.418.1"> how to use EF Core to either reverse engineer a database into our application or create a new database using migrations, let us investigate writing extensible database querying code on top of the interfaces provided by EF Core.</span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.419.1">Implementing the repository pattern</span></h1>
<p><span class="koboSpan" id="kobo.420.1">By definition, a repository</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.421.1"> is a central storage area for data or items. </span><span class="koboSpan" id="kobo.421.2">In the context of database development, we use the word repository to label a widely used and convenient development pattern. </span><span class="koboSpan" id="kobo.421.3">This pattern helps us to extend the default interfaces and code given to us by our ORM, making it reusable and even more specific for certain operations.</span></p>
<p><span class="koboSpan" id="kobo.422.1">One side effect of this pattern is that we end up with more code and files, but the general benefit is that we can centralize our core operations. </span><span class="koboSpan" id="kobo.422.2">As a result, we abstract our business logic and database operations away from our controllers and eliminate repeating database access logic throughout our application. </span><span class="koboSpan" id="kobo.422.3">It helps us to maintain the </span><em class="italic"><span class="koboSpan" id="kobo.423.1">single responsibility principle</span></em><span class="koboSpan" id="kobo.424.1"> in our code base as we seek to author clean code.</span></p>
<p><span class="koboSpan" id="kobo.425.1">In any application, we need to carry out four main operations against any database table. </span><span class="koboSpan" id="kobo.425.2">We need to create, read, update, and delete data. </span><span class="koboSpan" id="kobo.425.3">In the context of an API, we need a controller per database table, and we would have our </span><em class="italic"><span class="koboSpan" id="kobo.426.1">CRUD</span></em><span class="koboSpan" id="kobo.427.1"> code repeating in every controller, which is good for getting started, but becomes dangerous as our application code base grows. </span><span class="koboSpan" id="kobo.427.2">This means that if something changes in the way that we retrieve records from every table, we have that many places that we need to change code in.</span></p>
<p><span class="koboSpan" id="kobo.428.1">An API controller with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">GET</span></strong><span class="koboSpan" id="kobo.430.1"> operation for our patients table would look like this without using the repository pattern:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
    [Route("api/[controller]")]
    [ApiController]
    public class PatientsController : ControllerBase
    {
        private readonly ApplicationDatabaseContext
            _context;
        public PatientsController
            (ApplicationDatabaseContext context)
        {
            _context = context;
        }
        // GET: api/Patients
        [HttpGet]
        public async Task&lt;ActionResult&lt;Ienumerable
            &lt;Patient&gt;&gt;&gt; GetPatients()
        {
          if (_context.Patients == null)
          {
              return NotFound();
          }
            return await _context.Patients.ToListAsync();
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.432.1">We simply inject the database</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.433.1"> context into the controller and use this instance to carry out our queries. </span><span class="koboSpan" id="kobo.433.2">This is simple and efficient as the query logic is not very complicated. </span><span class="koboSpan" id="kobo.433.3">Now imagine that you have several controllers with similar </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">GET</span></strong><span class="koboSpan" id="kobo.435.1"> operations. </span><span class="koboSpan" id="kobo.435.2">All is well until we get feedback that we need to add paging to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">GET</span></strong><span class="koboSpan" id="kobo.437.1"> operations for all endpoints. </span><span class="koboSpan" id="kobo.437.2">Now, we have that many places that need to be refactored with a far more complex query, which may also change again in the future.</span></p>
<p><span class="koboSpan" id="kobo.438.1">For scenarios like this, we need to centralize the code as much as possible and reduce the rework that becomes necessary across the application. </span><span class="koboSpan" id="kobo.438.2">This is where the repository pattern can come to our rescue. </span><span class="koboSpan" id="kobo.438.3">We typically have two files that contain generic templating code, then, we derive more specific repositories for each table where we can add custom operations as needed.</span></p>
<p><span class="koboSpan" id="kobo.439.1">Our generic repository includes an interface and a derived class. </span><span class="koboSpan" id="kobo.439.2">They look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
    public interface IGenericRepository&lt;T&gt; where T : class
    {
        Task&lt;T&gt; GetAsync(int? </span><span class="koboSpan" id="kobo.440.2">id);
        Task&lt;List&lt;T&gt;&gt; GetAllAsync();
        Task&lt;PagedResult&lt;T&gt;&gt; GetAllAsync&lt;T&gt;(QueryParameters
            queryParameters);
    }</span></pre>
<p><span class="koboSpan" id="kobo.441.1">Here, we only outline methods for read operations, but this interface can just as easily be extended to support all CRUD operations. </span><span class="koboSpan" id="kobo.441.2">We use generics as we are prepared to accept any type of class that represents a data model. </span><span class="koboSpan" id="kobo.441.3">We also outline a method for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">GET</span></strong><span class="koboSpan" id="kobo.443.1"> operation that returns paged results in keeping with the recent requirement. </span><span class="koboSpan" id="kobo.443.2">Our derived class</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.444.1"> looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
public class GenericRepository&lt;T&gt; : IGenericRepository&lt;T&gt;
    where T : class
    {
        protected readonly ApplicationDatabaseContext
            _context;
        public GenericRepository(ApplicationDatabaseContext
           context)
        {
            this._context = context;
       }
        public async Task&lt;List&lt;T&gt;&gt; GetAllAsync()
        {
            return await _context.Set&lt;T&gt;().ToListAsync();
        }
        public async Task&lt;PagedResult&lt;T&gt;&gt; GetAllAsync&lt;T&gt;
            (QueryParameters queryParameters)
        {
            var totalSize = await _context.Set&lt;T&gt;()
                .CountAsync();
            var items = await _context.Set&lt;T&gt;()
                .Skip(queryParameters.StartIndex)
                .Take(queryParameters.PageSize)
                .ToListAsync();
            return new PagedResult&lt;T&gt;
            {
                Items = items,
                PageNumber = queryParameters.PageNumber,
                RecordNumber = queryParameters.PageSize,
                TotalCount = totalSize
            };
        }
        public async Task&lt;T&gt; GetAsync(int? </span><span class="koboSpan" id="kobo.445.2">id)
        {
            if (id is null)
            {
                return null;
            }
            return await _context.Set&lt;T&gt;().FindAsync(id);
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.446.1">We see here that we are injecting</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.447.1"> the database context into the repository and then we can write our preset queries in one place. </span><span class="koboSpan" id="kobo.447.2">This generic repository can now be injected into the controllers that need to implement these operations:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
    [Route("api/[controller]")]
    [ApiController]
    public class PatientsController : ControllerBase
    {
        private readonly IGenericRepository&lt;Patient&gt;
            _repository;
        public PatientsController(IGenericRepository&lt;Patient&gt; 
          repository)
        {
            _repository = repository;
        }
        // GET: api/Patients
        [HttpGet]
        public async Task&lt;ActionResult&lt;Ienumerable
            &lt;Patient&gt;&gt;&gt; GetPatients()
        {
            return await _repository.GetAllAsync();
        }
         // GET: api/Patients/?StartIndex=0&amp;pagesize=25
             &amp;PageNumber=1
        [HttpGet()]
        public async Task&lt;ActionResult&lt; PagedResult
            &lt;Patient&gt;&gt;&gt; GetPatients([FromQuery]
                QueryParameters queryParameters)
        {
            return await _repository.GetAllAsync
                (queryParameters);
        }</span></pre>
<p><span class="koboSpan" id="kobo.449.1">Now we can simply call the appropriate method</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.450.1"> from the repository. </span><span class="koboSpan" id="kobo.450.2">The repository gets instantiated in our controller relative to the class that is used in its injection and the resulting query will be applied against the related table. </span><span class="koboSpan" id="kobo.450.3">This makes it much easier to standardize our queries across multiple tables and controllers. </span><span class="koboSpan" id="kobo.450.4">We need to ensure that we register our </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">GenericRepository</span></strong><span class="koboSpan" id="kobo.452.1"> service in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Program.cs</span></strong><span class="koboSpan" id="kobo.454.1"> file like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.455.1">
builder.Services.AddScoped(typeof(IGenericRepository&lt;&gt;),
    typeof(GenericRepository&lt;&gt;));</span></pre>
<p><span class="koboSpan" id="kobo.456.1">Now we may need to implement</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.457.1"> operations that are specific to our patient table and are not needed for other tables. </span><span class="koboSpan" id="kobo.457.2">This means that the generic approach will not be best moving forward, as we would end up cluttering it with custom logic for our tables. </span><span class="koboSpan" id="kobo.457.3">We can now extend it and create a specific interface for our table and write our custom logic:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
public interface IPatientsRepository : IGenericRepository
    &lt;Patient&gt;
{
    Task&lt;Patient&gt; GetByTaxIdAsync(string id);
}
public class PatientsRepository : GenericRepository
    &lt;Patient&gt;, IPatientsRepository
{
    public PatientsRepository(ApplicationDatabaseContext
        context) : base(context)
    {}
    public async Task&lt;Patient&gt; GetByTaxIdAsync(string id)
    {
        return await _context.Patients.FirstOrDefaultAsync
            (q =&gt; q.TaxId == id);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.459.1">Now we can register</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.460.1"> this new service in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Program.cs</span></strong><span class="koboSpan" id="kobo.462.1"> file like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
builder.Services.AddScoped&lt;IPatientsRepository,
    PatientsRepository&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.464.1">And then we can inject it into our controller instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">GenericRepository</span></strong><span class="koboSpan" id="kobo.466.1"> and use it like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
public class PatientsController : ControllerBase
{
    private readonly IPatientsRepository _repository;
    public PatientsController(IPatientsRepository
        repository)
    {
        _repository = repository;
    }
    // GET: api/Patients
    [HttpGet]
    public async Task&lt;ActionResult&lt;IEnumerable&lt;Patient&gt;&gt;&gt;
        GetPatients()
    {
        return await _repository.GetAllAsync();
    }
    // GET: api/Patients/taxid/1234
    [HttpGet("taxid/{id}")]
    public async Task&lt;ActionResult&lt;Patient&gt;&gt;
        GetPatients(string id)
    {
        var patient = await _repository.GetByTaxIdAsync
            (id);
        if (patient is null) return NotFound();
        return patient;
    }
    // GET: api/Hotels/?StartIndex=0&amp;pagesize=25
        &amp;PageNumber=1
    [HttpGet()]
    public async Task&lt;ActionResult&lt;PagedResult&lt;Patient&gt;&gt;&gt;
        GetPatients([FromQuery] QueryParameters
            queryParameters)
    {
        return await _repository.GetAllAsync
            (queryParameters);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.468.1">Here, we can cleanly call the custom code while maintaining access to the base functions that we implemented in the generic repository.</span></p>
<p><span class="koboSpan" id="kobo.469.1">There are debates</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.470.1"> as to whether this pattern saves us time and effort or just makes our code base more complicated. </span><span class="koboSpan" id="kobo.470.2">There are pros and cons to this pattern but ensure that you do a fair assessment of the benefits and pitfalls before you choose to include it in your project.</span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.471.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.472.1">Databases are a critical part of application development, and we need to ensure that we make the right decisions as early as possible. </span><span class="koboSpan" id="kobo.472.2">The technology, type of storage mechanism, and supporting application logic all play a large role in making our application as effective as possible in implementing business requirements. </span><span class="koboSpan" id="kobo.472.3">In this chapter, we explored the different considerations involved when developing supporting databases for microservices, the best type of database to use and when, and choosing a pattern of development that helps us to reduce redundant code.</span></p>
<p><span class="koboSpan" id="kobo.473.1">In the next chapter, we will investigate implementing transactions across multiple services and databases using the </span><em class="italic"><span class="koboSpan" id="kobo.474.1">saga pattern</span></em><span class="koboSpan" id="kobo.475.1">, since this is a big issue when we choose the database-per-service approach to microservice architecture.</span></p>
</div>
</body></html>