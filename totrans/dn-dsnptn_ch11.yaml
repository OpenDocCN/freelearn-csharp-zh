- en: Chapter 11. What is Reactive Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now we have seen how parallel and functional programming constructs in the
    .NET world help one naturally compose algorithms/business logic and model programs/data
    flows. These paradigms help realize a software system that has close correlation
    with the real world in which they exist. We have seen relevance of data structures
    and their role in program composition. We also saw the benefits (in terms of concurrency
    and parallelism) of keeping the data structures (modeled in an object-oriented
    way) different from the algorithms (modelled as pure function compositions) that
    consume them. To take this one knot further, in order to keep up with growing
    system complexity, there's a growing software revolution called **reactive programming**,
    which defines how to model applications from a behavior stand-point. In this chapter,
    we will try to unravel the concept through some examples, and understand how this
    programming paradigm becomes a natural succession, but more importantly, a unifying
    model for creating responsive systems. We will look at the various reactive programming
    constructs (including key data structures, interfaces, and operators) available
    in .NET **Reactive Extensions** (**Rx**). By the end of the chapter, you will
    understand how natural it is to model responsiveness, which becomes quite relevant
    in this new world of multicore, cloud, mobile, and web-scale systems.
  prefs: []
  type: TYPE_NORMAL
- en: Being reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, let's look at the classic definition of reactive programming,
    and try to understand the concept brought forth by this model. This is important
    to undo any misconceptions that govern one's mind on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *In computing, reactive programming is a programming paradigm that maintains
    a continuous interaction with their environment, but at a speed which is determined
    by the environment, not the program itself.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Gèrard Berry* |'
  prefs: []
  type: TYPE_TB
- en: This implies that this programming model helps, or rather, has an inherent capability
    to propagate changes without the programmer having to explicitly wire any such
    logic (the conventional way, which was error prone and rendered programs inconsistent;
    a nightmare that still haunts some of us). This would mean that the programming
    model would be declarative and provide the needed constructs (including data structures
    and interfaces) to capture the relationship between attributes in order to ensure
    seamless propagation or synchronization of changes through data flows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The design pattern that really powers this model is observer, where the relationships
    between subscribers and publishers are declaratively modeled.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand this further via this example. In typical assignment
    statements (in the imperative world), relations are implicitly declared (say *c²
    = a² + b²* , the Pythagorean equation that symbolizes the Pythagorean theorem),
    or functions (in the functional programming world) are defined explicitly, say
    *c = Compute Hypotenuse(a, b)*. On the other hand, in the reactive world, computation
    (value of *c*) is automatically done with new values of the sides (*a* and *b*).
    The computation is automatically triggered every time the value changes for *a*
    and *b* in the relation *c² = a² + b²*. This behavior is termed as **reactive**.
    You could say that this is similar to event-driven programming, but there is a
    very distinct difference here that you need to understand.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is extremely important to model concurrent real-world systems
    including real-time analytics, control systems with feedback loops, electronic
    circuits and **printed circuit board** (**PCB**) design, rule engine, state machines,
    simulators, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic spread sheets - A quintessential example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Electronic spreadsheets such as Excel software help one to input values in
    Cells, in a program-specific manner (for example-*A7* , *B6*, and so on). They
    also allow you to embed computation as a value of a cell (such as *=$A7*$B6* )
    using formulas. Whenever a value is changed in *A7* or *B6*, the resulting formula
    will be recomputed. Actually, the change is propagated to cells where there is
    reference to the cell which changed. This can be called a type of reactive computation.
    Let''s see our Pythagorean triple generation in action on Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic spread sheets - A quintessential example](img/B05691_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding table, you can see that column **F** indicates (achieved with
    conditional formatting using icon sets) whether **a**, **b,** and **c** are Pythagorean
    triples or not.
  prefs: []
  type: TYPE_NORMAL
- en: The hidden columns **D** and **F** compute the values of (**a² + b²**) and **c²**
    independently, and column F just checks for an equality in order to display a
    potential match. All these are done, of course, using formulas, and the changes
    across cells are propagated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic spread sheets - A quintessential example](img/B05691_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example should give you an idea of how reactive programming works, and
    more interestingly, we will use this trivial example to illustrate a deep consequence
    beyond reactive programming. This spreadsheet program elegantly models the **Model-View-ViewModel**
    (**MVVM**) pattern, an architectural pattern heavily employed in WPF, Silverlight,
    and now, most of the prevalent HTML UI frameworks (JS-based). The Model in this
    case would be columns **A** and **B** (consider each row as entities and the columns
    as entity attributes). The View Model would be columns **D** and **E** (derived
    attributes from the model attributes). And column **F** would be the View which
    is bound to the View Model (and any change in View Model would be synchronized
    with the View; as a matter of fact, any changes in the Model would be propagated
    to the View Model and further down to the View).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, reactive programming is nothing but programming with asynchronous
    data streams. By applying various operations on stream, we can achieve different
    computational goals. The primary task in a reactive program is to convert the
    data into streams, regardless of what the source of the data is. While writing
    modern graphical user interface applications, we process mouse move-and-click
    events. Currently, most systems get a callback, and process these events as and
    when they happen. Most of the time, the handler does a series of filtering operations
    before it invokes the action methods associated with the event calls.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular context, reactive programming helps us in aggregating the
    mouse move-and-click events into a collection, and sets filters on them before
    notifying the handler logic. In this way, the application/handler logic does not
    get executed unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Stream-processing model is well known, and it is very easy to encode by application
    developers. Pretty much anything can be converted into a stream. Such candidates
    include messages, logs, properties, twitter feeds, blog posts, RSS feeds, and
    so on. Functional programming techniques are really good at processing streams.
    A language like C#, with its inherent support for functional programming idioms,
    becomes a natural choice for writing reactive programs.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind reactive programming is that there are certain datatypes
    that represent a value over time. These datatypes (or rather data sequences) are
    represented as observable sequences in this programming paradigm. Computations
    that involve these changing (time dependent) values will, in turn, themselves
    have values that change over time, and would need to asynchronously receive notifications
    (as and when the dependent data changes). Remember the spreadsheet application
    discussed earlier?
  prefs: []
  type: TYPE_NORMAL
- en: Functional reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern programming languages support functional programming constructs.
    Functional programming constructs such as Map/Reduce, Filter, Fold, and so on
    are good for processing streams. Programming asynchronous data streams using functional
    programming constructs is called functional reactive programming. This is gaining
    more traction among the developers these days.
  prefs: []
  type: TYPE_NORMAL
- en: The FRP programs can be classified as **push-based** and **pull-based**. The
    pull-based system waits for a demand to push the data streams to the requestor
    (or subscriber in our case). This is the classic case where the data source is
    actively polled for more information. This employs the iterator pattern, and `IEnumerable
    <T>`/`IEnumerator <T>` interfaces are specifically designed for such scenarios
    that are synchronous in nature (application can block while pulling data). On
    the other hand, a push-based system aggregates the events and pushes through a
    signal network to achieve the computation. In this case, unlike the pull-based
    system, data and related updates are handed to the subscriber from the source
    (observable sequences in this case). This asynchronous nature is achieved by not
    blocking the subscriber, but rather making it react to the changes. The observer
    pattern is put to extensive use here using the `IObservable <T>` and `IObserver<T>`
    interfaces (which have been introduced as part of .NET framework 4.0). As you
    can see, employing this push pattern is more beneficial in rich UI environments
    where you wouldn't want to block the main UI thread while waiting for some events.
    This becomes ideal, thus making reactive programs responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reactive systems are composed of small subsystems, which have got reactive properties
    at the subsystems level. This is possible, because reactive applications apply
    sound design principles to maintain the responsiveness of their constituents.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the reactive manifesto, the following are the four principles
    of reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsiveness**: A reactive system is supposed to respond to events in a
    time-bound manner. This helps in usability and utilizability of the systems. Responsive
    systems help us to detect anomalies very early, and can maintain good **Quality
    of Service** (**QoS**). This is very important for systems that have **service
    level agreement** (**SLA**) and **operations level agreement** (**OLA**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: Reactive systems should stay responsive even in the case of
    a system failure. Failures are contained in each component by careful isolation
    of subsystems, and making sure that failure does not get propagated to other parts.
    By good modularization, we can recover from failure by replacing components that
    fail without affecting the other modules of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elasticity**: Reactive systems should stay responsive under varying levels
    of stress due to the workloads. By effective throttling of event streams and dynamic
    resource management, we can write systems that can handle varying workloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message driven**: Reactive systems rely on asynchronous messaging-based programming
    models to establish strict boundaries between components by maintaining loose
    coupling and location transparency (in the case of distributed systems). Employing
    explicit message-passing helps to manage load better, and to provide elasticity
    and explicit flow control through throttling. Non-blocking communication between
    components makes sure that resource management is done diligently. Moreover, system
    failures can be propagated as messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Reactive programming principles](img/B05691_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rx from Microsoft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft brought out **software development kit** (**SDK**) for reactive programming,
    which it monikers as .NET Rx. According to them, Rx extensions is a unified library
    for composing asynchronous and event-based programs using observable sequences
    and LINQ style query operations. The key aspects of their descriptions are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous event streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable sequences (streams)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ style queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequences can be contents of a file, network socket, web service response,
    input streams, and so on. Microsoft gives a symbolic formula for Rx, that is,
    *Rx = Observables + LINQ + Schedulers*.
  prefs: []
  type: TYPE_NORMAL
- en: Key data structures of Rx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Microsoft Rx SDK specifies some key data types, which a programmer can
    leverage to implement reactive programs. Some of the key types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IObservable<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IObserver<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subject<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signature of `IObserver` and `IObservable` is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: IEnumberable/IObservable duality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The .NET framework has built-in support for the Iterator pattern (through `IEnumerable<T>`)
    and observer pattern (through `IObservable<T>`). If you take a closer look, there
    is only a subtle difference between these two patterns. `IEnumerable<T>` can be
    considered the pull-based equivalent of the push-based `IObservable<T>`. In fact,
    they are duals. When two entities exchange information, one entity''s action of
    pull corresponds to other entity pushing the information. This duality is illustrated
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IEnumberable/IObservable duality](img/B05691_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand this duality by looking at this sample code, an even number
    sequence generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write a number sequence generator to demonstrate how these data types
    work together in converting a pull-based program to an Rx push program. First
    we will write a toy implementation of `IDisposable` to be used later: The robustness
    aspect is given low priority to keep the listing terse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet invokes the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From this preceding example, you see how one can naturally subscribe for even
    numbers from an observable sequence of natural numbers. The system will automatically
    push (publish) the values to the observer (subscriber) when an even number is
    detected. The code gives explicit implementations for the key interfaces so that
    one can understand or speculate what really happens under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example would be Pythagorean triple generation from observable sequences
    of base, altitude, and hypotenuse. We have already seen the **functional** code
    for achieving this, and now, let''s see the **reactive** equivalent (or should
    we say, a better one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Converting entities to streams (IObservable<T>)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following constructs can be converted to a sequence source. `IObservable<T>`
    can be generated from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IEnumerable<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting events into stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now understood how one can convert an `IEnumerable<T>`-based pull program
    to an `IObservable<T>`/`IObserver<T>`-based push program. In real life, the event
    source is not as simple as we found in the number stream example given previously.
    Let us see how we can convert a `MouseMove` event into a stream with a small WinForms
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Please see the following form, which displays the mouse positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting events into stream](img/B05691_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reduction of streams (sequences)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The whole idea of converting data to streams is to apply functional programming
    operators such as Reduce, Aggregate, Fold, and so on. This is quite relevant in
    terms of choosing the needed data (and also in an efficient way) from an enormous
    pile that is ever growing with respect to time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter and partition operators**: These operations help to reduce the source
    sequence into a sequence of elements that we are interested in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation operators**: Reduce the source sequence to a sequence with a
    single element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fold operators**: Reduce the source sequence to a single element as a scalar
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the common sequence/stream operators supported by Rx/LINQ are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Where`: As the name implies, and for those familiar with this operator from
    LINQ days, it does the very purpose of filtering of sequences. If we were to rewrite
    our earlier example-that of extracting/filtering even numbers-it would declaratively
    be as simple as this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, the input is 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, and
    the output will be 2, 4, 6, and 8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Skip`: This helps in skipping *n* items in a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Take`: This helps in taking *n* items (skipping the rest) in a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipWhile`: This helps in skipping items (while a certain condition is satisfied)
    in a sequence. Please note that the element would be skipped until the predicate
    evaluates to `true`. Beyond this, all items would be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeWhile`: This is the converse of `SkipWhile`, and helps in taking items
    (while a certain condition is satisfied) in a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipUntil`: This requires two observable sequences, and continues to skip
    all the values in the first sequence until any value is produced by the second
    sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeUntil`: Again, this requires two observable sequences, and forces the
    first sequence to completion when the second sequence starts producing any value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipLast`: Intelligently queues elements, skips the last *n* elements, and
    returns the rest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeLast`: Returns the last *n* elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zip`: Merges two observable sequences into one observable sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspection of streams (sequences)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rx provides a set of operators, which can help us to inspect the contents of
    a stream. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Any`: This returns an observable sequence (result), which returns one value
    (`True` or `False`) and completes. `True` indicates that the source sequence produced
    a value that caused the result sequence to produce `True`. On the other hand,
    the result sequence returns `False` if the source sequence completes without any
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`All`: This works similar to `Any` except that the results sequence returns
    `True` if the predicate is evaluated to `True` and `False` vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contains`: This shows the same behavior as `All` except that it helps seek
    a specific value instead of a value that fits the predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ElementAt`: This returns an observable sequence (result), which returns the
    value in the source sequence (specified by the index) and completes. It uses a
    0-based index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation of streams (sequences)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rx provides a series of operators, which help us to aggregate the content of
    a stream. Some of the most important ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min`, `Max`, `Average`, `Sum` (descriptive statistics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinBy`, `MaxBy`, `GroupBy` (partitioning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom aggregators and scans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation of streams (sequences)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The values produced by our event source are not in the formats that we might
    want, and we are required to make the transformation on each element in the sequence.
    The most important functional transformation is bind, where we apply a function
    (morphism) on each element of the sequence to produce a new sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In functional programming parlance, the transformations available are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anamorphism, which transforms `T` to `IObservable<T>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unfold`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Generate`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Catamorphism, which transforms an `IObservable<T>` to `T`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fold`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reduce`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Accumulate`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bind, which transforms an `IObservable<T>` to `IObservable<T>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectMany`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Projection`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Transform`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining streams (sequences)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We get data from different data sources, and it is necessary to combine streams
    to do processing. Rx provides a series of operators, which can be grouped into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequential concatenation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Concat`: As the name indicates, the resulting sequence concatenates multiple
    input sequences without interleaving them'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repeat`: Creates a sequence that emits a particular item multiple times'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartWith`: Emits a specified sequence of items before beginning to emit the
    items from the source sequence'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concurrent sequences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Amb`: This returns one of the sequences (from two or more source sequences),
    which first starts emitting an item or notification'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Merge`: As the name indicates, this operator combines multiple sequences into
    one'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Switch`: This returns a sequence (from two or more source sequences) that
    emits the items emitted by the most recently emitted one of those input/source
    sequences'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pairing sequences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CombineLatest`: Combines the most recently emitted items from each of the
    participating input sequences using a function that is provided, and emits the
    return value of that function'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zip`: The behavior is similar to that of `CombineLatest` except that the function
    is applied in a strict sequence (in terms of combining items from the participating
    input sequences)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`And`/`Then`/`When`: The behavior is very similar to `Zip`, but certain intermediary
    data structures (namely pattern and plan objects) are used as part of combining
    the input sequences before emitting the resulting sequence'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A philosophy for reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with a lot of verbose description about the reactive
    programming model. Then, we showed how one can convert an `IEnumerable<T>`-based
    sequence generator to an `IObservable<T>`/`IObserver<T>-`based push program. We
    also demonstrated how one can convert mouse-event data to a stream, using a toy
    program. The rest of the chapter was about the tools available for manipulating
    streams or sequences. You learned about the different genres of stream processing
    operators. One needs to consult the Microsoft documentation on Rx to understand
    the specifics of stream processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic philosophy here can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate data into asynchronous or synchronous streams from the event source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply preprocessing methods using various operators available at the data source
    itself (outside the stream consumer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the resulting stream pushed from the data source at the data sink level
    by applying functional transformation techniques. We can compose stream operations
    to produce compound operations. By doing this, the whole program becomes a linear
    chain of functions applied on a stream. If the data stream is not mutated, there
    is no need for a compensating transaction logic as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Schematically, the preceding code snippets can be interpreted as that we can
    apply a series of functions on a stream to produce output stream. Since the input
    stream is immutable when we process at the data sink level, there is no need for
    a compensating transaction in the catch handler. The whole processing can be easily
    debugged as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the conceptual underpinnings of (functional) reactive
    programming, and how Microsoft Rx helps you to write reactive programs using a
    scheduler, observable interface, and LINQ. We have avoided API documentation in
    this book (as that is exhaustive and redundant considering the nature of this
    book). We urge you to refer to the ReactiveX website ([http://reactivex.io/documentation/operators](http://reactivex.io/documentation/operators)),
    MSDN, interactive Rx illustrations website ([http://rxmarbles.com](http://rxmarbles.com)),
    and the online book *Introduction to Rx* by Lee Campbell ([http://www.introtorx.com](http://www.introtorx.com))
    for specifics and usage examples on the various operators that we have discussed.
    In the following chapters, we will see detailed examples in C# and JavaScript-based
    functional reactive programs.
  prefs: []
  type: TYPE_NORMAL
