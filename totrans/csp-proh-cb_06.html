<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Making Apps Responsive with Asynchronous Programming</h1></div></div></div><p>This chapter will introduce you to asynchronous programming. This chapter will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Return types of asynchronous functions</li><li class="listitem" style="list-style-type: disc">Handling tasks in asynchronous programming</li><li class="listitem" style="list-style-type: disc">Exception handling in asynchronous programming</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Introduction</h1></div></div></div><p>Asynchronous programming is<a class="indexterm" id="id384"/> an exciting feature in C#. It allows you to continue program execution on the main thread while a long-running task runs in its own thread separately from the main thread. When this long-running task is complete, it will let the main thread know that it has completed (or failed). The benefit of asynchronous programming is that it improves the responsiveness of your application. The best way to learn and understand asynchronous programming is to experience it. The following recipes will illustrate some of the basics to you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Return types of asynchronous functions</h1></div></div></div><p>In asynchronous <a class="indexterm" id="id385"/>programming, the <code class="literal">async</code> methods can have<a class="indexterm" id="id386"/> three possible return types. These <a class="indexterm" id="id387"/>are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">void</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Task</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Task&lt;TResult&gt;</code></li></ul></div><p>We will have a look at each return type<a class="indexterm" id="id388"/> in the following recipe.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec96"/>Getting ready</h2></div></div></div><p>What could be the use of a <code class="literal">void</code> return type in asynchronous methods? Generally, <code class="literal">void</code> is used with event handlers. Just bear in mind that <code class="literal">void</code> returns nothing, so you can't wait for it. Therefore, if you call a <code class="literal">void</code> return type asynchronous method, your calling code should be able to continue executing code without having to wait for the asynchronous method to complete.</p><p>With asynchronous<a class="indexterm" id="id389"/> methods that have a return type of <code class="literal">Task</code>, you can utilize the <code class="literal">await</code> operator to pause the execution of the current thread until the called<a class="indexterm" id="id390"/> asynchronous method has completed. Keep in mind that an asynchronous method that returns a type of <code class="literal">Task</code> basically does not return an operand. Therefore, if it was written as a synchronous method, it would be a <code class="literal">void</code> return type method. This statement might be confusing, but it will become clear in the following recipes.</p><p>Finally, asynchronous methods that have a <code class="literal">return</code> statement have a return type of <code class="literal">TResult</code>. In other words, if the asynchronous method returns a Boolean, you would create an asynchronous method with a return type of <code class="literal">Task&lt;bool&gt;</code>.</p><p>Let's start with the <code class="literal">void</code> return<a class="indexterm" id="id391"/> type asynchronous method.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec97"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new class library by right-clicking on your solution and selecting <strong>Add</strong> and then <strong>New Project</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_06_01.jpg"/></div></li><li class="listitem">From the <strong>Add New Project</strong> dialog <a class="indexterm" id="id392"/>screen, select<a class="indexterm" id="id393"/> <strong>Class Library</strong> from the installed templates and call your class <code class="literal">Chapter6</code>:<div><img alt="How to do it…" src="img/B05391_06_02.jpg"/></div></li><li class="listitem">Your new class<a class="indexterm" id="id394"/> library will be added to your solution with a default name of <code class="literal">Class1.cs</code>, which we renamed to <code class="literal">Recipes.cs</code> in order to distinguish the code properly. You can, however, rename your <a class="indexterm" id="id395"/>class to whatever you like, if it makes more sense to you.</li><li class="listitem">To rename your class, simply click on the class name in <strong>Solution Explorer</strong> and select <strong>Rename</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_06_03.jpg"/></div></li><li class="listitem">Visual Studio <a class="indexterm" id="id396"/>will ask you to confirm the new <a class="indexterm" id="id397"/>names of all references to the code element <strong>Class1</strong> in the project. Just click on <strong>Yes</strong>:<div><img alt="How to do it…" src="img/B05391_06_04.jpg"/></div></li><li class="listitem">The next step is<a class="indexterm" id="id398"/> to add another new project. Right-click<a class="indexterm" id="id399"/> on the solution and select <strong>Add</strong> and then <strong>New Project</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_06_05.jpg"/></div></li><li class="listitem">This time, you <a class="indexterm" id="id400"/>will be creating a new Windows Forms<a class="indexterm" id="id401"/> application for your solution. We need to do this so that we can create a button click event. We called our project <code class="literal">winformAsync</code>:<div><img alt="How to do it…" src="img/B05391_06_06.jpg"/></div></li><li class="listitem">Your<a class="indexterm" id="id402"/> <strong>Solution Explorer</strong> will now look similar to the<a class="indexterm" id="id403"/> following screenshot, with the Winforms application added:<div><img alt="How to do it…" src="img/B05391_06_07.jpg"/></div></li><li class="listitem">After you have<a class="indexterm" id="id404"/> added your Winforms application, add <a class="indexterm" id="id405"/>a reference to the <code class="literal">Chapter6</code> class you created earlier. To do this, right-click on <strong>References</strong> under the <strong>winformAsync</strong> project and click on the <strong>Add Reference</strong> menu item from the context menu:<div><img alt="How to do it…" src="img/B05391_06_10.jpg"/></div></li><li class="listitem">From the <a class="indexterm" id="id406"/><strong>Reference Manager</strong> screen, select the <a class="indexterm" id="id407"/><code class="literal">Chapter6</code> class, which is found under the <strong>Projects</strong> | <strong>Solution</strong> node in the tree view to the left. Then, click on the <strong>OK</strong> button:<div><img alt="How to do it…" src="img/B05391_06_11.jpg"/></div></li><li class="listitem">Another important <a class="indexterm" id="id408"/>step is to set the <strong>winformAsync</strong> project<a class="indexterm" id="id409"/> as the startup project in the solution. To do this, right-click the <strong>winformAsync</strong> project and select the <strong>Set as StartUp Project</strong> menu item from the context menu:<div><img alt="How to do it…" src="img/B05391_06_12.jpg"/></div></li><li class="listitem">On the <strong>winformAsync</strong><a class="indexterm" id="id410"/> form designer, open <strong>Toolbox</strong> and<a class="indexterm" id="id411"/> select the <strong>Button</strong> control, which is found under the <strong>All Windows Forms</strong> node:<div><img alt="How to do it…" src="img/B05391_06_08.jpg"/></div></li><li class="listitem">Drag the button control onto the <strong>Form1</strong> designer:<div><img alt="How to do it…" src="img/B05391_06_09.jpg"/></div></li><li class="listitem">With the button control<a class="indexterm" id="id412"/> selected, double-click on the control to create the click event in the code behind. Visual Studio<a class="indexterm" id="id413"/> will insert the event code for you:<div><pre class="programlisting">namespace winformAsync
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void button1_Click(object sender, EventArgs e)
        {

        }
    }
}</pre></div></li><li class="listitem">Change the <code class="literal">button1_Click</code> event and add the <code class="literal">async</code> keyword to the click event. This is an<a class="indexterm" id="id414"/> example of a <code class="literal">void</code> returning an asynchronous method:<div><pre class="programlisting">private async void button1_Click(object sender, EventArgs e)
{

}</pre></div></li><li class="listitem">In the <code class="literal">Chapter6</code> class library, add a new class called <code class="literal">AsyncDemo</code>:<div><pre class="programlisting">public class AsyncDemo
{
}</pre></div></li><li class="listitem">The next method to add to<a class="indexterm" id="id415"/> the <code class="literal">AsyncDemo</code> class is the asynchronous method that returns <code class="literal">TResult</code> (in this case, a Boolean). This method simply checks whether the current year is a leap year. It then returns a Boolean to the calling code:<div><pre class="programlisting">async Task&lt;bool&gt; TaskOfTResultReturning_AsyncMethod()
{
    return await Task.FromResult&lt;bool&gt; (DateTime.IsLeapYear(DateTime.Now.Year));
}</pre></div></li><li class="listitem">The next method to add is the <code class="literal">void</code> returning method that returns a <code class="literal">Task</code> type so that it allows you to await the method. The method itself does not return any result, making it a <code class="literal">void</code> returning method. However, in order to use the <code class="literal">await</code> keyword, you return the <code class="literal">Task</code> type from this asynchronous method:<div><pre class="programlisting">async Task TaskReturning_AsyncMethod()
{
    await Task.Delay(5000);
    Console.WriteLine("5 second delay");
}</pre></div></li><li class="listitem">Finally, add a method that will call the previous asynchronous methods and display the result of the leap year check. You will notice that we are using the <code class="literal">await</code> keyword with both method calls:<div><pre class="programlisting">public async Task LongTask()
{
    bool isLeapYear = await TaskOfTResultReturning_AsyncMethod();
    Console.WriteLine($"{DateTime.Now.Year} {(isLeapYear ? " is " : "  is not  ")} a leap year");
    await TaskReturning_AsyncMethod();
}</pre></div></li><li class="listitem">In the button click, add the<a class="indexterm" id="id416"/> following code that<a class="indexterm" id="id417"/> calls the long-running task asynchronously:<div><pre class="programlisting">private async void button1_Click(object sender, EventArgs e)
{
    Console.WriteLine("Button Clicked");
    Chapter6.AsyncDemo oAsync = new Chapter6.AsyncDemo();
    await oAsync.LongTask();
    Console.WriteLine("Button Click Ended");
}</pre></div></li><li class="listitem">Running your application will display the Windows Forms application:<div><img alt="How to do it…" src="img/B05391_06_13.jpg"/></div></li><li class="listitem">Before clicking on the <strong>button1</strong> button, ensure that the <strong>Output</strong> window is visible:<div><img alt="How to do it…" src="img/B05391_06_14.jpg"/></div></li><li class="listitem">From the<a class="indexterm" id="id418"/> <strong>View</strong> menu, click on the <strong>Output</strong> menu item<a class="indexterm" id="id419"/> or type <em>Ctrl</em> + <em>Alt</em> + <em>O</em> to display the <strong>Output</strong> window. This will allow us to see the <code class="literal">Console.Writeline()</code> outputs as we have added them to the code in the <code class="literal">Chapter6</code> class and in the Windows application.</li><li class="listitem">Clicking on the <strong>button1</strong> button will display the outputs to our <strong>Output</strong> window. Throughout this<a class="indexterm" id="id420"/> code execution, the form remains responsive:<div><img alt="How to do it…" src="img/B05391_06_15.jpg"/></div></li><li class="listitem">Finally, you can also<a class="indexterm" id="id421"/> use the <code class="literal">await</code> operator in separate calls. Modify the code in the <code class="literal">LongTask()</code> method as follows:<div><pre class="programlisting">public async Task LongTask()
{
    Task&lt;bool&gt; blnIsLeapYear = TaskOfTResultReturning_AsyncMethod();

    for (int i = 0; i &lt;= 10000; i++)
    {
        // Do other work that does not rely on blnIsLeapYear before awaiting
    }

    bool isLeapYear = await TaskOfTResultReturning_AsyncMethod();

    Console.WriteLine($"{DateTime.Now.Year} {(isLeapYear ? " is " : "  is not  ")} a leap year");

    Task taskReturnMethhod = TaskReturning_AsyncMethod();

    for (int i = 0; i &lt;= 10000; i++)
    {
        // Do other work that does not rely on taskReturnMethhod before awaiting
    }

    await taskReturnMethhod;
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec98"/>How it works…</h2></div></div></div><p>In the preceding code, we<a class="indexterm" id="id422"/> have seen the <code class="literal">void</code> returning type asynchronous method that was used in the <code class="literal">button1_Click</code> event. We also created a <code class="literal">Task</code> returning <a class="indexterm" id="id423"/>method that returns nothing (that would be a <code class="literal">void</code> if used in synchronous programming), but returning <code class="literal">Task</code> type allows us to await the method. Finally, we created a <code class="literal">Task&lt;TResult&gt;</code> returning method that performs some task and returns the result to the calling code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Handling tasks in asynchronous programming</h1></div></div></div><p>
<strong>Task-Based Asynchronous Pattern</strong> (<strong>TAP</strong>) is now the recommended method to create asynchronous code. It executes<a class="indexterm" id="id424"/> asynchronously on a<a class="indexterm" id="id425"/> thread from the thread pool and does not <a class="indexterm" id="id426"/>execute synchronously on the main thread of your application. It allows us to check the task's state by calling the <code class="literal">Status</code> property.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec99"/>Getting ready</h2></div></div></div><p>We will create a task to read a very large text file. This will be accomplished using an asynchronous <code class="literal">Task</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec100"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a large text file (we called ours <code class="literal">taskFile.txt</code>) and place it in your <code class="literal">C:\temp</code> folder:<div><img alt="How to do it…" src="img/B05391_06_16.jpg"/></div></li><li class="listitem">In the <code class="literal">AsyncDemo</code> class, create<a class="indexterm" id="id427"/> a method called <code class="literal">ReadBigFile()</code> that returns a <code class="literal">Task&lt;TResult&gt;</code> type, which will be<a class="indexterm" id="id428"/> used to return an integer of bytes read from our big text file:<div><pre class="programlisting">public Task&lt;int&gt; ReadBigFile()
{    

}</pre></div></li><li class="listitem">Add the following code to open and read the file bytes. You will see that we are using the <code class="literal">ReadAsync()</code> method that asynchronously reads a sequence of bytes from the stream and advances the position in that stream by the number of bytes read from that stream. You will also notice that we are using a buffer to read those bytes:<div><pre class="programlisting">public Task&lt;int&gt; ReadBigFile()
{
    var bigFile = File.OpenRead(@"C:\temp\taskFile.txt");
    var bigFileBuffer = new byte[bigFile.Length];
    var readBytes = bigFile.ReadAsync(bigFileBuffer, 0, (int)bigFile.Length);
    
    return readBytes;
}</pre></div><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Exceptions you can expect to handle from the <code class="literal">ReadAsync()</code> method are <code class="literal">ArgumentNullException</code>, <code class="literal">ArgumentOutOfRangeException</code>, <code class="literal">ArgumentException</code>, <code class="literal">NotSupportedException</code>, <code class="literal">ObjectDisposedException</code> and <code class="literal">InvalidOperatorException</code>.</p></div></div></li><li class="listitem">Finally, add the final section of code just after the <code class="literal">var readBytes = bigFile.ReadAsync(bigFileBuffer, 0, (int)bigFile.Length);</code> line that uses a lambda expression to specify the work that the task needs to perform. In this case, it is to<a class="indexterm" id="id429"/> read the bytes in the file:<div><pre class="programlisting">public Task&lt;int&gt; ReadBigFile()
{
    var bigFile = File.OpenRead(@"C:\temp\taskFile.txt");
    var bigFileBuffer = new byte[bigFile.Length];
    var readBytes = bigFile.ReadAsync(bigFileBuffer, 0, (int)bigFile.Length);
    readBytes.ContinueWith(task =&gt;
    {
        if (task.Status == TaskStatus.Running)
            Console.WriteLine("Running");
        else if (task.Status == TaskStatus.RanToCompletion)
            Console.WriteLine("RanToCompletion");
        else if (task.Status == TaskStatus.Faulted)
            Console.WriteLine("Faulted");

        bigFile.Dispose();
    });
    return readBytes;
}</pre></div></li><li class="listitem">If not done so<a class="indexterm" id="id430"/> in the previous recipe, add a button to your Windows Forms application's Forms Designer. On the <strong>winformAsync</strong> form designer, open <strong>Toolbox</strong> and select the <strong>Button</strong> control, which is found under the <strong>All Windows Forms</strong> node:<div><img alt="How to do it…" src="img/B05391_06_08.jpg"/></div></li><li class="listitem">Drag the button<a class="indexterm" id="id431"/> control onto the <strong>Form1</strong> <a class="indexterm" id="id432"/>designer:<div><img alt="How to do it…" src="img/B05391_06_09.jpg"/></div></li><li class="listitem">With the button<a class="indexterm" id="id433"/> control selected, double-click the control to create the click event in the code behind. Visual Studio will insert the <a class="indexterm" id="id434"/>event code for you:<div><pre class="programlisting">namespace winformAsync
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void button1_Click(object sender, EventArgs e)
        {

        }
    }
}</pre></div></li><li class="listitem">Change the <code class="literal">button1_Click</code> event and add the <code class="literal">async</code> keyword to the click event. This is an example<a class="indexterm" id="id435"/> of a <code class="literal">void</code> returning an asynchronous method:<div><pre class="programlisting">private async void button1_Click(object sender, EventArgs e)
{

}</pre></div></li><li class="listitem">Now, make sure that you add code to call the <code class="literal">AsyncDemo</code> class's <code class="literal">ReadBigFile()</code> method asynchronously. Remember to read the result from the method (which are the bytes read) into an integer variable:<div><pre class="programlisting">private async void button1_Click(object sender, EventArgs e)
{
    Console.WriteLine("Start file read");
    Chapter6.AsyncDemo oAsync = new Chapter6.AsyncDemo();
    int readResult = await oAsync.ReadBigFile();
    Console.WriteLine("Bytes read = " + readResult);
}</pre></div></li><li class="listitem">Running your<a class="indexterm" id="id436"/> application will display the Windows Forms application:<div><img alt="How to do it…" src="img/B05391_06_13.jpg"/></div></li><li class="listitem">Before clicking <a class="indexterm" id="id437"/>on the <strong>button1</strong> button, ensure<a class="indexterm" id="id438"/> that the <strong>Output</strong> window is visible:<div><img alt="How to do it…" src="img/B05391_06_14.jpg"/></div></li><li class="listitem">From the <strong>View</strong> menu, click on the <strong>Output</strong> menu item or type <em>Ctrl</em> + <em>Alt</em> + <em>O</em> to display the <strong>Output</strong> window. This will allow us to see the <code class="literal">Console.Writeline()</code> outputs as we have added them to the code in the <code class="literal">Chapter6</code> class and in the Windows application.</li><li class="listitem">Clicking on the <a class="indexterm" id="id439"/><strong>button1</strong> button will display the <a class="indexterm" id="id440"/>outputs in our <strong>Output</strong> window. Throughout this code execution, the form remains responsive:<div><img alt="How to do it…" src="img/B05391_06_17.jpg"/></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Take note though that the information displayed in your <strong>Output</strong> window will differ from the screenshot. This is because the file you used is different from mine.</p></div></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec101"/>How it works…</h2></div></div></div><p>The task is executed on a separate thread from the thread pool. This allows the application to remain responsive while the large file is being processed. Tasks can be used in multiple ways to improve your code. This recipe is but one example.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Exception handling in asynchronous programming</h1></div></div></div><p>Exception handling in<a class="indexterm" id="id441"/> asynchronous programming has always been a challenge. This was especially true in the catch blocks. As of C# 6, you are <a class="indexterm" id="id442"/>now allowed to write asynchronous code inside the <code class="literal">catch</code> and <code class="literal">finally</code> block of your exception handlers.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec102"/>Getting ready</h2></div></div></div><p>The application will simulate the action of reading a logfile. Assume that a third-party system always makes a backup of the logfile before processing it in another application. While this processing is happening, the logfile is deleted and recreated. Our application, however, needs to read this logfile on a periodic basis. We, therefore, need to be prepared for the case where the file does not exist in the location we expect it in. Therefore, we will purposely omit the main logfile, so that we can force an error.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec103"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a text file and two folders to contain the logfiles. We will, however, only create a single logfile in the <code class="literal">BackupLog</code> folder. The <code class="literal">MainLog</code> folder will remain empty:<div><img alt="How to do it…" src="img/B05391_06_18.jpg"/></div></li><li class="listitem">In our <code class="literal">AsyncDemo</code> class, write a method to read the main logfile in the <code class="literal">MainLog</code> folder:<div><pre class="programlisting">private async Task&lt;int&gt; ReadMainLog()
{
    var bigFile = File.OpenRead(@"C:\temp\Log\MainLog\taskFile.txt");
    var bigFileBuffer = new byte[bigFile.Length];
    var readBytes = bigFile.ReadAsync(bigFileBuffer, 0, (int)bigFile.Length);
    await readBytes.ContinueWith(task =&gt;
    {
        if (task.Status == TaskStatus.RanToCompletion)
            Console.WriteLine("Main Log RanToCompletion");
        else if (task.Status == TaskStatus.Faulted)
            Console.WriteLine("Main Log Faulted");

        bigFile.Dispose();
    });
    return await readBytes;
}</pre></div></li><li class="listitem">Create a second <a class="indexterm" id="id443"/>method to read the<a class="indexterm" id="id444"/> backup file in the <code class="literal">BackupLog</code> folder:<div><pre class="programlisting">private async Task&lt;int&gt; ReadBackupLog()
{
    var bigFile = File.OpenRead(@"C:\temp\Log\BackupLog\taskFile.txt");
    var bigFileBuffer = new byte[bigFile.Length];
    var readBytes = bigFile.ReadAsync(bigFileBuffer, 0, (int)bigFile.Length);
    await readBytes.ContinueWith(task =&gt;
    {
        if (task.Status == TaskStatus.RanToCompletion)
            Console.WriteLine("Backup Log RanToCompletion");
        else if (task.Status == TaskStatus.Faulted)
            Console.WriteLine("Backup Log Faulted");

        bigFile.Dispose();
    });
    return await readBytes;
}</pre></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>In actual fact, we would probably only create a single method to read the logfiles, passing only the path as a parameter. In a production application, creating a class and overriding a method to read the different logfile locations would be a better approach. For the purposes of this recipe, however, we specifically wanted to create two separate methods so that the different calls to the asynchronous methods are clearly visible in the code.</p></div></div></li><li class="listitem">We will then create a main <code class="literal">ReadLogFile()</code> method that tries to read the main logfile. As we have not created the logfile in the <code class="literal">MainLog</code> folder, the code will throw a <code class="literal">FileNotFoundException</code>. It will then run the asynchronous <a class="indexterm" id="id445"/>method and await that in the <code class="literal">catch</code> block of the <code class="literal">ReadLogFile()</code> method (something that was<a class="indexterm" id="id446"/> impossible in the previous versions of C#), returning the bytes read to the calling code:<div><pre class="programlisting">public async Task&lt;int&gt; ReadLogFile()
{
    int returnBytes = -1;
    try
    {
        Task&lt;int&gt; intBytesRead = ReadMainLog();
        returnBytes = await ReadMainLog();
    }
    catch (Exception ex)
    {
        try
        {
            returnBytes = await ReadBackupLog();
        }
        catch (Exception)
        {
            throw;
        }
    }
    return returnBytes;
}</pre></div></li><li class="listitem">If not done so in the previous recipe, add a button to your Windows Forms application's Forms Designer. On the <strong>winformAsync</strong> Forms Designer, open <strong>Toolbox</strong> and select the <strong>Button</strong> control, which is found under the <strong>All Windows Forms</strong> node:<div><img alt="How to do it…" src="img/B05391_06_08.jpg"/></div></li><li class="listitem">Drag the button<a class="indexterm" id="id447"/> control onto<a class="indexterm" id="id448"/> the <strong>Form1</strong> designer:<div><img alt="How to do it…" src="img/B05391_06_09.jpg"/></div></li><li class="listitem">With the button <a class="indexterm" id="id449"/>control selected, double-click<a class="indexterm" id="id450"/> on the control to create the click event in the code behind. Visual Studio will insert the event code for you:<div><pre class="programlisting">namespace winformAsync
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void button1_Click(object sender, EventArgs e)
        {

        }
    }
}</pre></div></li><li class="listitem">Change the <code class="literal">button1_Click</code> event and add the <code class="literal">async</code> keyword to the click event. This is an example of a <code class="literal">void</code> returning an asynchronous method:<div><pre class="programlisting">private async void button1_Click(object sender, EventArgs e)
{

}</pre></div></li><li class="listitem">Next, we will write the code to create a new instance of the <code class="literal">AsyncDemo</code> class and attempt to<a class="indexterm" id="id451"/> read the main logfile. In a real-world example, it is at this point that the code does not know that the main<a class="indexterm" id="id452"/> logfile does not exist:<div><pre class="programlisting">private async void button1_Click(object sender, EventArgs e)
{
    Console.WriteLine("Read backup file");
    Chapter6.AsyncDemo oAsync = new Chapter6.AsyncDemo();
    int readResult = await oAsync.ReadLogFile();
    Console.WriteLine("Bytes read = " + readResult);
}</pre></div></li><li class="listitem">Running your application will display the Windows Forms application:<div><img alt="How to do it…" src="img/B05391_06_13.jpg"/></div></li><li class="listitem">Before clicking on<a class="indexterm" id="id453"/> the <strong>button1</strong> button, ensure<a class="indexterm" id="id454"/> that the <strong>Output</strong> window is visible:<div><img alt="How to do it…" src="img/B05391_06_14.jpg"/></div></li><li class="listitem">From the <strong>View</strong> menu, click on the <strong>Output</strong> menu item or type <em>Ctrl</em> + <em>Alt</em> + <em>O</em> to display the <strong>Output</strong> window. This will allow us to see the <code class="literal">Console.Writeline()</code> outputs as we have added them to the code in the <code class="literal">Chapter6</code> class and in the Windows application.</li><li class="listitem">To simulate a file <a class="indexterm" id="id455"/>not found exception, we <a class="indexterm" id="id456"/>deleted the file from the <code class="literal">MainLog</code> folder. You will see that the exception is thrown, and the <code class="literal">catch</code> block runs the code to read the backup logfile instead:<div><img alt="How to do it…" src="img/B05391_06_19.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec104"/>How it works…</h2></div></div></div><p>The fact that we can await in <code class="literal">catch</code> and <code class="literal">finally</code> blocks allows developers much more flexibility, because asynchronous results can consistently be awaited throughout the application. As you can see from the code we wrote, as soon as the exception was thrown, we asynchronously read the file read method for the backup file.</p></div></div></body></html>