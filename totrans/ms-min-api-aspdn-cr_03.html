<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer033">
<h1 class="chapter-number" id="_idParaDest-39"><a id="_idTextAnchor038"/>3</h1>
<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Working with Minimal APIs</h1>
<p>In this chapter, we will try to apply some advanced development techniques available in earlier versions of .NET. We will touch on four common topics that are disjointed from each other.</p>
<p><a id="_idTextAnchor040"/><a id="_idTextAnchor041"/>We’ll cover productivity topics and best practices for frontend interfacing and configuration management.</p>
<p>Every developer, sooner or later, will encounter the issues that we describe in this chapter. A programmer will have to write documentation for APIs, will have to make the API talk to a JavaScript frontend, will have to handle errors and try to fix them, and will have to configure the application according to parameters.</p>
<p>The themes we will touch on in this chapter are as follows:</p>
<ul>
<li>Exploring Swagger</li>
<li>Supporting CORS</li>
<li>Working with global API settings</li>
<li>Error handling</li>
</ul>
<h1 id="_idParaDest-41"><a id="_idTextAnchor042"/>Technical requirements</h1>
<p>As reported in the previous chapters, it will be necessary to have the .NET 6 development framework available; you will also need to use .NET tools to run an in-memory web server.</p>
<p>To validate the functionality of <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>), we should exploit a frontend application residing on a different HTTP address from the one where we will host the API. </p>
<p>To test the CORS example that we will propose within the chapter, we will take advantage of a web server in memory, which will allow us to host a simple static HTML page.</p>
<p>To host the web page (HTML and JavaScript), we will therefore use <strong class="bold">LiveReloadServer</strong>, which you can install as a .NET tool with the following command:</p>
<p class="source-code">dotnet tool install -g LiveReloadServer</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03</a>.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor043"/>Exploring Swagger</h1>
<p>Swagger has <a id="_idIndexMarker061"/>entered the life of .NET developers in a big way; it’s been present on the project shelves for several versions of Visual Studio.</p>
<p>Swagger is a tool based on the OpenAPI specification and allows you to document APIs with a web <a id="_idIndexMarker062"/>application. According to the official documentation available at <a href="https://oai.github.io/Documentation/introduction.xhtml">https://oai.github.io/Documentation/introduction.xhtml</a>:</p>
<p class="author-quote">“The OpenAPI Specification allows the description of a remote API accessible through HTTP or HTTP-like protocols.</p>
<p class="author-quote">An <em class="italic">API</em><em class="italic"> </em>defines the allowed interactions between two pieces of software, just like a user interface defines the ways in which a user can interact with a program.</p>
<p class="author-quote">An API is composed of the list of possible methods to call (requests to make), their parameters, return values and any data format they require (among other things). This is equivalent to how a user’s interactions with a mobile phone app are limited to the buttons, sliders and text boxes in the app’s user interface.”</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Swagger in the Visual Studio scaffold</h2>
<p>We <a id="_idIndexMarker063"/>understand<a id="_idIndexMarker064"/> then that <strong class="bold">Swagger</strong>, as we know it in the .NET world, is nothing but a set of specifications defined for all applications that expose web-based APIs:</p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="Figure 3.1 – Visual Studio scaffold" height="644" src="image/Figure_3.1_B17902.jpg" width="848"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Visual Studio scaffold</p>
<p>By selecting <strong class="bold">Enable OpenAPI support</strong>, Visual <a id="_idIndexMarker065"/>Studio goes<a id="_idIndexMarker066"/> to<a id="_idIndexMarker067"/> add a <strong class="bold">NuGet</strong> package called <strong class="source-inline">Swashbuckle.AspNetCore</strong> and automatically configures it in the <strong class="source-inline">Program.cs</strong> file.</p>
<p>We show the few lines that are added with a new project. With these few pieces of information, a web application is enabled only for the development environment, which allows the developer to test the API without generating a client or using tools external to the application:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.Services.AddEndpointsApiExplorer();</strong>
<strong class="bold">builder.Services.AddSwaggerGen();</strong>
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
<strong class="bold">    app.UseSwagger();</strong>
<strong class="bold">    app.UseSwaggerUI();</strong>
}</pre>
<p>The graphical part generated by Swagger greatly increases productivity and allows the developer to share information with those who will interface with the application, be it a frontend application or a machine application.</p>
<p class="callout-heading">Note</p>
<p class="callout">We remind you that enabling Swagger in a production environment is <em class="italic">strongly discouraged</em> because sensitive information could be publicly exposed on the web or on the network where the application resides.</p>
<p>We have seen how to introduce Swagger into our API applications; this functionality allows us to <a id="_idIndexMarker068"/>document<a id="_idIndexMarker069"/> our API, as well as allow users to generate a client to call our application. Let’s see the options we have to quickly interface an application with APIs described with OpenAPI.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>OpenAPI Generator</h2>
<p>With <a id="_idIndexMarker070"/>Swagger, <a id="_idIndexMarker071"/>and especially with the OpenAPI standard, you can automatically generate clients to connect to the web application. Clients can be generated for many languages but also for development tools. We know how tedious and repetitive it is to write clients to access the Web API. <strong class="bold">Open API Generator</strong> helps us automate code generation, inspect the API documentation made by Swagger and OpenAPI, and automatically generate code to interface with the API. Simple, easy, and above all, fast.</p>
<p>The <strong class="source-inline">@openapitools/openapi-generator-cli</strong> npm package is a very well-known package wrapper for OpenAPI Generator, which you can find at <a href="https://openapi-generator.tech/">https://openapi-generator.tech/</a>.</p>
<p>With this tool, you can generate clients for programming languages as well as load testing tools<a id="_idIndexMarker072"/> such<a id="_idIndexMarker073"/> as <strong class="bold">JMeter</strong> and <strong class="bold">K6</strong>.</p>
<p>It is not necessary to install the tool on your machine, but if the URL of the application is accessible from the machine, you can use a Docker image, as described by the following command:</p>
<p class="source-code">docker run --rm \</p>
<p class="source-code">    -v ${PWD}:/local openapitools/openapi-generator-cli generate \</p>
<p class="source-code">    -i /local/petstore.yaml \</p>
<p class="source-code">    -g go \</p>
<p class="source-code">    -o /local/out/go</p>
<p>The command allows you to <a id="_idIndexMarker074"/>generate a <strong class="bold">Go</strong> client using the OpenAPI definition found in the <strong class="source-inline">petstore.yaml</strong> file that is mounted on the Docker volume.</p>
<p>Now, let’s go <a id="_idIndexMarker075"/>into <a id="_idIndexMarker076"/>detail to understand how you can leverage Swagger in .NET 6 projects and with minimal APIs.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Swagger in minimal APIs</h2>
<p>In ASP.NET <a id="_idIndexMarker077"/>Web API, as <a id="_idIndexMarker078"/>in the following code excerpt, we see a method documented with C# language annotations with the triple slash (<strong class="source-inline">///</strong>).</p>
<p>The documentation section is leveraged to add more information to the API description. In addition, the <strong class="source-inline">ProducesResponseType</strong> annotations help Swagger identify the possible codes that the client must handle as a result of the method call:</p>
<pre class="source-code">
/// &lt;summary&gt;
/// Creates a Contact.
/// &lt;/summary&gt;
/// &lt;param name="contact"&gt;&lt;/param&gt;
/// &lt;returns&gt;A newly created Contact&lt;/returns&gt;
/// &lt;response code="201"&gt;Returns the newly created contact&lt;/response&gt;
/// &lt;response code="400"&gt;If the contact is null&lt;/response&gt;
[HttpPost]
[ProducesResponseType(StatusCodes.Status201Created)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public async Task&lt;IActionResult&gt; Create(Contact contactItem)
{
     _context.Contacts.Add(contactItem);
     await _context.SaveChangesAsync();
     return CreatedAtAction(nameof(Get), new { id = 
     contactItem.Id }, contactItem);
}</pre>
<p>Swagger, in<a id="_idIndexMarker079"/> addition to<a id="_idIndexMarker080"/> the annotations on single methods, is also instructed by the documentation of the language to give further information to those who will then have to use the API application. A description of the methods of the parameters is always welcome by those who will have to interface; unfortunately, it is not possible to exploit this functionality in the minimal API.</p>
<p>Let’s go in order and see how to start using Swagger on a single method:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =&gt;
{
    c.SwaggerDoc("v1", new() 
    { 
        Title = builder.Environment.ApplicationName,
        Version = "v1", Contact = new() 
        { Name = "PacktAuthor", Email = "authors@packtpub.com",
          Url = new Uri("https://www.packtpub.com/") },
          Description = "PacktPub Minimal API - Swagger",
          License = new Microsoft.OpenApi.Models.
            OpenApiLicense(),
          TermsOfService = new("https://www.packtpub.com/")
});
});
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}</pre>
<p>With this <a id="_idIndexMarker081"/>first <a id="_idIndexMarker082"/>example, we have configured Swagger and general Swagger information. We have included additional information that enriches Swagger’s UI. The only mandatory information is the title, while the version, contact, description, license, and terms of service are optional.</p>
<p>The <strong class="source-inline">UseSwaggerUI()</strong> method automatically configures where to put the UI and the JSON file describing the API with the OpenAPI format.</p>
<p>Here is the result at the graphical level:</p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<img alt="Figure 3.2 – The Swagger UI" height="338" src="image/Figure_3.2_B17902.jpg" width="971"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The Swagger UI</p>
<p>We can immediately see that the OpenAPI contract information has been placed in the <strong class="source-inline">/swagger/v1/swagger.json</strong> path.</p>
<p>The contact information is populated, but no operations are reported as we haven’t entered any yet. Should the API have versioning? In the top-right section, we can select the available operations for each version.</p>
<p>We can customize the Swagger URL and insert the documentation on a new path; the important thing is to redefine <strong class="source-inline">SwaggerEndpoint</strong>, as follows:</p>
<pre class="source-code">
app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint("/swagger/v1/swagger.json", $"{builder.Environment.ApplicationName} v1"));</pre>
<p>Let’s now go on to add the endpoints that describe the business logic.</p>
<p>It is very important to define <strong class="source-inline">RouteHandlerBuilder</strong> because it allows us to describe all the properties of the endpoint that we have written in code.</p>
<p>The UI of<a id="_idIndexMarker083"/> Swagger<a id="_idIndexMarker084"/> must be enriched as much as possible; we must describe at best what the minimal APIs allow us to specify. Unfortunately, not all the functionalities are available, as in ASP.NET Web API.</p>
<h3>Versioning in minimal APIs</h3>
<p><strong class="bold">Versioning</strong> in <a id="_idIndexMarker085"/>minimal <a id="_idIndexMarker086"/>APIs is not handled in the framework functionality; as a result, even Swagger cannot handle UI-side API versioning. So, we observe that when we go to the <strong class="bold">Select a definition</strong> section shown in <em class="italic">Figure 3.2</em>, only one entry for the current version of the API is visible.</p>
<h3>Swagger features</h3>
<p>We just realized that <a id="_idIndexMarker087"/>not all features are available in Swagger; let’s now explore what is available instead. To describe the possible output values of an endpoint, we can call functions that can be called after the handler, such as the <strong class="source-inline">Produces</strong> or <strong class="source-inline">WithTags</strong> functions, which we are now going to explore.</p>
<p>The <strong class="source-inline">Produces</strong> function decorates the endpoint with all the possible responses that the client should be able to manage. We can add the name of the operation ID; this information will not appear in the Swagger screen, but it will be the name with which the client will create the method to call the endpoint. <strong class="source-inline">OperationId</strong> is the unique name of the operation made available by the handler.</p>
<p>To exclude an endpoint from the API description, you need to call <strong class="source-inline">ExcludeFromDescription()</strong>. This function is rarely used, but it is very useful in cases where you don’t want to expose endpoints to programmers who are developing the frontend because that particular endpoint is used by a machine application.</p>
<p>Finally, we can add and tag the various endpoints and segment them for better client management:</p>
<pre class="source-code">
app.MapGet("/sampleresponse", () =&gt;
    {
        return Results.Ok(new ResponseData("My Response"));
    })
    .Produces&lt;ResponseData&gt;(StatusCodes.Status200OK)
    .WithTags("Sample")
    .WithName("SampleResponseOperation"); // operation ids to 
                                             Open API
app.MapGet("/sampleresponseskipped", () =&gt;
{
    return Results.Ok(new ResponseData("My Response Skipped"));
})
    .ExcludeFromDescription();
app.MapGet("/{id}", (int id) =&gt; Results.Ok(id));
app.MapPost("/", (ResponseData data) =&gt; Results.Ok(data))
   .Accepts&lt;ResponseData&gt;(MediaTypeNames.Application.Json);</pre>
<p>This is the graphical<a id="_idIndexMarker088"/> result of Swagger; as I anticipated earlier, the tags and operation IDs are not shown by the web client:</p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<img alt="Figure 3.3 – Swagger UI methods  " height="961" src="image/Figure_3.3_B17902.jpg" width="769"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Swagger UI methods </p>
<p>The endpoint<a id="_idIndexMarker089"/> description, on the other hand, is very useful to include. It’s very easy to implement: just insert C# comments in the method (just insert three slashes, <strong class="source-inline">///</strong>, in the method). Minimal APIs don’t have methods like we are used to in web-based controllers, so they are not natively supported.</p>
<p>Swagger isn’t just the GUI we’re used to seeing. Above all, Swagger is the JSON file that supports the OpenAPI specification, of which the latest version is 3.1.0.</p>
<p>In the following snippet, we show the section containing the description of the first endpoint that we inserted in the API. We can infer both the tag and the operation ID; this information will<a id="_idIndexMarker090"/> be used by those who will interface with the API:</p>
<pre class="source-code">
"paths": {
         "/sampleresponse": {
              "get": {
                   "tags": [
                        "Sample"
                   ],
                   "operationId": "SampleResponseOperation",
                   "responses": {
                        "200": {
                             "description": "Success",
                             "content": {
                                  "application/json": {
                                       "schema": {
                                            "$ref": "#/components/schemas/ResponseData"
                                       }
                                  }
                             }
                        }
                   }
              }
         },</pre>
<p>In this section, we have seen how to configure Swagger and what is currently not yet supported.</p>
<p>In the following chapters, we will also see how to configure OpenAPI, both for the OpenID Connect standard and authentication via the API key.</p>
<p>In the preceding code snippet of the Swagger UI, Swagger makes the schematics of the objects involved <a id="_idIndexMarker091"/>available, both inbound to the various endpoints and outbound from them.</p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<img alt="Figure 3.4 – Input and output data schema " height="362" src="image/Figure_3.4_B17902.jpg" width="518"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Input and output data schema</p>
<p>We will learn how to deal with these objects and how to validate and define them in <a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em>.</p>
<h3>Swagger OperationFilter</h3>
<p>The operation <a id="_idIndexMarker092"/>filter<a id="_idIndexMarker093"/> allows you to add behavior to all operations shown by Swagger. In the following example, we’ll show you how to add an HTTP header to a particular call, filtering it by <strong class="source-inline">OperationId</strong>.</p>
<p>When you go to define an operation filter, you can also set filters based on routes, tags, and operation IDs:</p>
<pre class="source-code">
public class CorrelationIdOperationFilter : IOperationFilter
{
    private readonly IWebHostEnvironment environment;
    public CorrelationIdOperationFilter(IWebHostEnvironment 
    environment)
    {
        this.environment = environment;
    }
    /// &lt;summary&gt;
    /// Apply header in parameter Swagger.
    /// We add default value in parameter for developer 
        environment
    /// &lt;/summary&gt;
    /// &lt;param name="operation"&gt;&lt;/param&gt;
    /// &lt;param name="context"&gt;&lt;/param&gt;
    public void Apply(OpenApiOperation operation, 
    OperationFilterContext context)
    {
        if (operation.Parameters == null)
        {
            operation.Parameters = new 
            List&lt;OpenApiParameter&gt;();
        }
        if (operation.OperationId == 
            "SampleResponseOperation")
        {
             operation.Parameters.Add(new OpenApiParameter
             {
                 Name = "x-correlation-id",
                 In = ParameterLocation.Header,
                 Required = false,
                 Schema = new OpenApiSchema { Type = 
                 "String", Default = new OpenApiString("42") }
             });
        }
         }
}</pre>
<p>To define an <a id="_idIndexMarker094"/>operation<a id="_idIndexMarker095"/> filter, the <strong class="source-inline">IOperationFilter</strong> interface <a id="_idIndexMarker096"/>must be implemented.</p>
<p>In the constructor, you can define all interfaces or objects that have been previously registered in the dependency inject engine.</p>
<p>The filter then consists of a single <a id="_idIndexMarker097"/>method, called <strong class="source-inline">Apply</strong>, which provides two objects:</p>
<ul>
<li><strong class="source-inline">OpenApiOperation</strong>: An operation where we can add parameters or check the operation ID of the current call</li>
<li><strong class="source-inline">OperationFilterContext</strong>: The filter context that allows you to read <strong class="source-inline">ApiDescription</strong>, where you can find the URL of the current endpoint</li>
</ul>
<p>Finally, to enable the operation filter in Swagger, we will need to register it inside the <strong class="source-inline">SwaggerGen</strong> method.</p>
<p>In this method, we should then add the filter, as follows:</p>
<pre class="source-code">
builder.Services.AddSwaggerGen(c =&gt;
{
         <strong class="bold">… removed for brevity</strong>
         c.OperationFilter&lt;CorrelationIdOperationFilter&gt;();
});</pre>
<p>Here is the result at the UI level; in the endpoint and only for a particular operation ID, we would have a<a id="_idIndexMarker098"/> new mandatory<a id="_idIndexMarker099"/> header with a default parameter that, in development, will not have to be inserted:</p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<img alt="Figure 3.5 – API key section " height="376" src="image/Figure_3.5_B17902.jpg" width="824"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – API key section</p>
<p>This case study helps us a lot when we have an API key that we need to set up and we don’t want to insert it on every single call.</p>
<p class="callout-heading">Operation filter in production</p>
<p class="callout">Since Swagger should not be enabled in the production environment, the filter and its default value will not create application security problems.</p>
<p class="callout">We recommend that you disable Swagger in the production environment.</p>
<p>In this section, we<a id="_idIndexMarker100"/> figured out how to enable a UI tool that describes the API and<a id="_idIndexMarker101"/> allows us to test it. In the next section, we will see how to enable the <a id="_idIndexMarker102"/>call between <strong class="bold">single-page applications</strong> (<strong class="bold">SPAs</strong>) and the backend via CORS.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor047"/>Enabling CORS</h1>
<p>CORS is a security<a id="_idIndexMarker103"/> mechanism whereby an HTTP/S request is blocked if it arrives from a different domain than the one where the application is hosted. More information can be found in the Microsoft documentation or on the Mozilla site for developers.</p>
<p>A browser prevents a web page from making requests to a domain other than the domain that serves that web page. A web page, SPA, or server-side web page can make HTTP requests to several backend APIs that are hosted in different origins.</p>
<p>This restriction is<a id="_idIndexMarker104"/> called the <strong class="bold">same-origin policy</strong>. The same-origin policy prevents a malicious site from reading data from another site. Browsers don’t block HTTP requests but do block response data.</p>
<p>We, therefore, understand that the CORS qualification, as it relates to safety, must be evaluated with caution.</p>
<p>The most common scenario is that of SPAs that are released on web servers with different web addresses than the web server hosting the minimal API:</p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<img alt="Figure 3.6 – SPA and minimal API " height="249" src="image/Figure_3.6_B17902.jpg" width="678"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – SPA and minimal API</p>
<p>A similar scenario is that of microservices, which need to talk to each other. Each microservice will reside at a particular web address that will be different from the others.</p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<img alt="Figure 3.7 – Microservices and minimal APIs " height="487" src="image/Figure_3.7_B17902.jpg" width="682"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Microservices and minimal APIs</p>
<p>In all these cases, therefore, a CORS problem is encountered.</p>
<p>We now<a id="_idIndexMarker105"/> understand the cases in which a CORS request can occur. Now let’s see what the correct HTTP request flow is and how the browser handles the request.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>CORS flow from an HTTP request</h2>
<p>What happens<a id="_idIndexMarker106"/> when a call <a id="_idIndexMarker107"/>leaves the browser for a different address other than the one where the frontend is hosted?</p>
<p>The HTTP call is executed and it goes all the way to the backend code, which executes correctly.</p>
<p>The response, with the correct data inside, is blocked by the browser. That’s why when we execute a call with<a id="_idIndexMarker108"/> Postman, Fiddler, or <a id="_idIndexMarker109"/>any HTTP client, the response reaches us correctly.</p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 3.8 – CORS flow " height="633" src="image/Figure_3.8_B17902.jpg" width="722"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – CORS flow</p>
<p>In the following figure, we can see that the browser makes the first call with the <strong class="source-inline">OPTIONS</strong> method, to <a id="_idIndexMarker110"/>which the <a id="_idIndexMarker111"/>backend responds correctly with a <strong class="source-inline">204</strong> status code:</p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 3.9 – First request for the CORS call (204 No Content result) " height="623" src="image/Figure_3.9_B17902.jpg" width="702"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – First request for the CORS call (204 No Content result)</p>
<p>In the second call that the browser makes, an error occurs; the <strong class="source-inline">strict-origin-when-cross-origin</strong> value is shown in <strong class="bold">Referrer Policy</strong>, which indicates the refusal by the browser to accept data from the backend:</p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 3.10 – Second request for the CORS call (blocked by the browser) " height="358" src="image/Figure_3.10_B17902.jpg" width="938"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Second request for the CORS call (blocked by the browser)</p>
<p>When CORS is <a id="_idIndexMarker112"/>enabled, in the <a id="_idIndexMarker113"/>response to the <strong class="source-inline">OPTIONS</strong> method call, three headers are inserted with the characteristics that the backend is willing to respect:</p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="Figure 3.11 – Request for CORS call (with CORS enabled) " height="438" src="image/Figure_3.11_B17902.jpg" width="875"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Request for CORS call (with CORS enabled)</p>
<p>In this case, we can see that three headers are added that define <strong class="source-inline">Access-Control-Allow-Headers</strong>, <strong class="source-inline">Access-Control-Allow-Methods</strong>, and <strong class="source-inline">Access-Control-Allow-Origin</strong>.</p>
<p>The browser <a id="_idIndexMarker114"/>with this information <a id="_idIndexMarker115"/>can accept or block the response to this API.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>Setting CORS with a policy</h2>
<p>Many <a id="_idIndexMarker116"/>configurations are possible within a .NET 6 application for activating CORS. We can define authorization policies in which the four available settings can be configured. CORS can also be activated by adding extension methods or annotations. </p>
<p>But let us proceed in order.</p>
<p>The <strong class="source-inline">CorsPolicyBuilder</strong> class allows us to define what is allowed or not allowed within the CORS acceptance policy.</p>
<p>We have, therefore, the possibility to set different methods, for example: </p>
<ul>
<li><strong class="source-inline">AllowAnyHeader</strong></li>
<li><strong class="source-inline">AllowAnyMethod</strong></li>
<li><strong class="source-inline">AllowAnyOrigin</strong></li>
<li><strong class="source-inline">AllowCredentials</strong></li>
</ul>
<p>While the first three methods are descriptive and allow us to enable any settings relating to the header, method, and origin of the HTTP call, respectively, <strong class="source-inline">AllowCredentials</strong> allows us to include the cookie with the authentication credentials.</p>
<p class="callout-heading">CORS policy recommendations</p>
<p class="callout">We recommend that you don’t use the <strong class="source-inline">AllowAny</strong> methods but instead filter out the necessary information to allow for greater security. As a best practice, when enabling CORS, we recommend the use of these methods:</p>
<ul>
<li><strong class="source-inline">WithExposedHeaders</strong></li>
<li><strong class="source-inline">WithHeaders</strong></li>
<li><strong class="source-inline">WithOrigins</strong></li>
</ul>
<p>To simulate a scenario for CORS, we created a simple frontend application with three different buttons. Each button allows you to test one of the possible configurations of CORS within the minimal API. We will explain these configurations in a few lines.</p>
<p>To enable the CORS scenario, we have created a single-page application that can be launched on a web server in memory. We have used <strong class="source-inline">LiveReloadServer</strong>, a tool that can be installed with the .NET CLI. We talked about it at the start of the chapter and now it’s time to use it.</p>
<p>After installing it, you need to launch the SPA with the following command:</p>
<p class="source-code">livereloadserver "{BasePath}\Chapter03\2-CorsSample\Frontend"</p>
<p>Here, <strong class="source-inline">BasePath</strong> is the folder where you are going to download the examples available on GitHub.</p>
<p>Then you must start the application backend, either through Visual Studio or Visual Studio Code or through the .NET CLI with the following command:</p>
<p class="source-code">dotnet run .\Backend\CorsSample.csproj</p>
<p>We’ve figured out how to start an example that highlights the CORS problem; now we need to configure the server to accept the request and inform the browser that it is aware that the<a id="_idIndexMarker117"/> request is coming from a different source.</p>
<p>Next, we will talk about policy configuration. We will understand the characteristics of the default policy as well as how to create a custom one.</p>
<h3>Configuring a default policy</h3>
<p>To configure a <a id="_idIndexMarker118"/>single CORS enabling policy, you need to define the behavior in the <strong class="source-inline">Program.cs</strong> file and add the desired configurations. Let’s implement a policy and define it as <strong class="source-inline">Default</strong>.</p>
<p>Then, to enable the policy for the whole application, simply add <strong class="source-inline">app.UseCors();</strong> before defining the <a id="_idIndexMarker119"/>handlers:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var corsPolicy = new CorsPolicyBuilder("http://localhost:5200")
    .AllowAnyHeader()
    .AllowAnyMethod()
    .Build();
builder.Services.AddCors(c =&gt; c.AddDefaultPolicy(corsPolicy));
var app = builder.Build();
app.UseCors();
app.MapGet("/api/cors", () =&gt;
{
         return Results.Ok(new { CorsResultJson = true });
});
app.Run();</pre>
<h3>Configuring custom policies</h3>
<p>We can create <a id="_idIndexMarker120"/>several policies within an application; each policy may have its own configuration and each policy may be associated with one or more endpoints.</p>
<p>In the case of microservices, having several policies helps to precisely segment access from a different source.</p>
<p>In order to configure a new policy, it is necessary to add it and give it a name; this name will give access to the policy and allow it to be associated with the endpoint. </p>
<p>The customized policy, as in the previous example, is assigned to the entire application:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var corsPolicy = new CorsPolicyBuilder("http://localhost:5200")
    .AllowAnyHeader()
    .AllowAnyMethod()
    .Build();
builder.Services.AddCors(options =&gt; options.AddPolicy("MyCustomPolicy", corsPolicy));
var app = builder.Build();
app.UseCors("MyCustomPolicy");
app.MapGet("/api/cors", () =&gt;
{
    return Results.Ok(new { CorsResultJson = true });
});
app.Run();</pre>
<p>We next look at how to apply a single policy to a specific endpoint; to this end, two methods are <a id="_idIndexMarker121"/>available. The first is via an extension method to the <strong class="source-inline">IEndpointConventionBuilder</strong> interface. The second method is to add the <strong class="source-inline">EnableCors</strong> annotation followed by the name of the policy to be enabled for that method.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor050"/>Setting CORS with extensions</h2>
<p>It is <a id="_idIndexMarker122"/>necessary to use the <strong class="source-inline">RequireCors</strong> method followed by the name of the policy.</p>
<p>With this method, it is then possible to enable one or more policies for an endpoint:</p>
<pre class="source-code">
app.MapGet("/api/cors/extension", () =&gt;
{
    return Results.Ok(new { CorsResultJson = true });
})
.RequireCors("MyCustomPolicy");</pre>
<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/>Setting CORS with an annotation</h2>
<p>The second <a id="_idIndexMarker123"/>method is to add the <strong class="source-inline">EnableCors</strong> annotation followed by the name of the policy to be enabled for that method:</p>
<pre class="source-code">
app.MapGet("/api/cors/annotation", [EnableCors("MyCustomPolicy")] () =&gt;
{
   return Results.Ok(new { CorsResultJson = true });
});</pre>
<p>Regarding controller programming, it soon becomes apparent that it is not possible to apply a policy to all methods of a particular controller. It is also not possible to group controllers and enable the policy. It is therefore necessary to apply the individual policy to the method or the entire application.</p>
<p>In this section, we found out how to configure browser protection for applications hosted on different domains.</p>
<p>In the next section, we will start configuring our applications.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor052"/>Working with global API settings</h1>
<p>We have just<a id="_idIndexMarker124"/> defined how you can load data with the <strong class="source-inline">options</strong> pattern within an ASP.NET application. In this section, we want to describe how you can configure an application and take advantage of everything we saw in the previous section.</p>
<p>With the<a id="_idIndexMarker125"/> birth of <strong class="bold">.NET Core</strong>, the standard has moved from the <strong class="source-inline">Web.config</strong> file to the <strong class="source-inline">appsettings.json</strong> file. The configurations can also be read from other sources, such as other file formats like the old <strong class="source-inline">.ini</strong> file or a positional file. </p>
<p>In minimal APIs, the <strong class="source-inline">options</strong> pattern feature remains unchanged, but in the next few paragraphs, we <a id="_idIndexMarker126"/>will see how to reuse the interfaces or the <strong class="source-inline">appsettings.json</strong> file structure.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Configuration in .NET 6</h2>
<p>The object <a id="_idIndexMarker127"/>provided from .NET is <strong class="source-inline">IConfiguration</strong>, which<a id="_idIndexMarker128"/> allows us to read some specific configurations inside the <strong class="source-inline">appsettings</strong> file. </p>
<p>But, as described earlier, this interface does much more than just access a file for reading. </p>
<p>The following extract from the official documentation helps us understand how the interface is the generic access point that allows us to access the data inserted in various services:</p>
<p class="author-quote">Configuration in ASP.NET Core is performed using one or more configuration providers. Configuration providers read configuration data from key-value pairs using a variety of configuration sources.</p>
<p>The following is a list of configuration sources:</p>
<ul>
<li>Settings files, such as <strong class="source-inline">appsettings.json</strong></li>
<li>Environment variables</li>
<li>Azure Key Vault</li>
<li>Azure App Configuration</li>
<li>Command-line arguments</li>
<li>Custom providers, installed or created</li>
<li>Directory files</li>
<li>In-memory .NET objects</li>
</ul>
<p>(<a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/">https://docs.microsoft.com/aspnet/core/fundamentals/configuration/</a>)</p>
<p>The <strong class="source-inline">IConfiguration</strong> and <strong class="source-inline">IOptions</strong> interfaces, which we will see in the next chapter, are designed to read data from the various providers. These interfaces are not suitable for reading and editing the configuration file while the program is running.</p>
<p>The <strong class="source-inline">IConfiguration</strong> interface is available through the <strong class="source-inline">builder</strong> object, <strong class="source-inline">builder.Configuration</strong>, which provides all the methods needed to read a value, an object, or a connection string.</p>
<p>After looking at one of the most important interfaces that we will use to configure the application, we want to define good development practices and use a fundamental building block for any developer: namely, classes. Copying the configuration into a class will allow us to better enjoy the content anywhere in the code.</p>
<p>We define classes <a id="_idIndexMarker129"/>containing a property and classes <a id="_idIndexMarker130"/>corresponding <strong class="source-inline">appsettings</strong> file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Configuration classes</p>
<pre class="source-code">
public class MyCustomObject
{
    public string? CustomProperty { get; init; }
}
public class MyCustomStartupObject
{
    public string? CustomProperty { get; init; }
}</pre>
<p>And here, we bring back the corresponding JSON of the C# class that we just saw:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">appsettings.json definition</p>
<pre class="source-code">
{
    "MyCustomObject": {
         "CustomProperty": "PropertyValue"
    },
    "MyCustomStartupObject": {
         "CustomProperty": "PropertyValue"
    },
    "ConnectionStrings": {
         "Default": "MyConnectionstringValueInAppsettings"
    }
}</pre>
<p>Next, we will be performing several operations.</p>
<p>The first operation we perform creates an instance of the <strong class="source-inline">startupConfig</strong> object that will be of the <strong class="source-inline">MyCustomStartupObject</strong> type. To populate the instance of this object, through <strong class="source-inline">IConfiguration</strong>, we are going to read the data from the section called <strong class="source-inline">MyCustomStartupObject</strong>:</p>
<pre class="source-code">
var startupConfig = builder.Configuration.GetSection(nameof(MyCustomStartupObject)).Get&lt;MyCustomStartupObject&gt;();</pre>
<p>The newly<a id="_idIndexMarker131"/> created <a id="_idIndexMarker132"/>object can then be used in the various handlers of the minimal APIs.</p>
<p>Instead, in this second operation, we use the dependency injection engine to request the instance of the <strong class="source-inline">IConfiguration</strong> object:</p>
<pre class="source-code">
app.MapGet("/read/configurations", (<strong class="bold">IConfiguration configuration</strong>) =&gt;
{
    var customObject = <strong class="bold">configuration</strong>.
    GetSection(nameof(MyCustomObject)).Get&lt;MyCustomObject&gt;();</pre>
<p>With the <strong class="source-inline">IConfiguration</strong> object, we will retrieve the data similarly to the operation just described. We select the <strong class="source-inline">GetSection(nameof(MyCustomObject))</strong> section and type the object with the <strong class="source-inline">Get&lt;T&gt;()</strong> method.</p>
<p>Finally, in these last two examples, we read a single key, present at the root level of the <strong class="source-inline">appsettings</strong> file: </p>
<pre class="source-code">
MyCustomValue = configuration.GetValue&lt;string&gt;("MyCustomValue"),
ConnectionString = configuration.GetConnectionString("Default"),</pre>
<p>The <strong class="source-inline">configuration.GetValue&lt;T&gt;(“JsonRootKey”)</strong> method extracts the value of a key and converts it into an object; this method is used to read strings or numbers from a root-level property.</p>
<p>In the next line, we can see how you can leverage an <strong class="source-inline">IConfiguration</strong> method to read <strong class="source-inline">ConnectionString</strong>.</p>
<p>In the <strong class="source-inline">appsettings</strong> file, <em class="italic">connection strings</em> are placed in a specific section, <strong class="source-inline">ConnectionStrings</strong>, that allows you to name the string and read it. Multiple connection strings can be placed in this section to exploit it in different objects. </p>
<p>In the configuration provider for Azure App Service, connection strings should be entered with a prefix that also indicates the SQL provider you are trying to use, as described <a id="_idIndexMarker133"/>in the<a id="_idIndexMarker134"/> following link: <a href="https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings">https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings</a>.</p>
<p>At runtime, connection strings are available as environment variables, prefixed with the following connection types:</p>
<ul>
<li>SQLServer: <strong class="source-inline">SQLCONNSTR_</strong></li>
<li>MySQL: <strong class="source-inline">MYSQLCONNSTR_</strong></li>
<li>SQLAzure: <strong class="source-inline">SQLAZURECONNSTR_</strong></li>
<li>Custom: <strong class="source-inline">CUSTOMCONNSTR_</strong></li>
<li>PostgreSQL: <strong class="source-inline">POSTGRESQLCONNSTR_</strong></li>
</ul>
<p>For completeness, we will bring back the entire code just described in order to have a better general picture of how to exploit the <strong class="source-inline">IConfiguration</strong> object inside the code:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var startupConfig = builder.Configuration.GetSection(nameof(MyCustomStartupObject)).Get&lt;MyCustomStartupObject&gt;();
app.MapGet("/read/configurations", (IConfiguration configuration) =&gt;
{
    var customObject = configuration.GetSection
    (nameof(MyCustomObject)).Get&lt;MyCustomObject&gt;();
    return Results.Ok(new
    {
        MyCustomValue = configuration.GetValue
        &lt;string&gt;("MyCustomValue"),
         ConnectionString = configuration.
         GetConnectionString("Default"),
         CustomObject = customObject,
         StartupObject = startupConfig
    });
})
.WithName("ReadConfigurations");</pre>
<p>We’ve seen how<a id="_idIndexMarker135"/> to take advantage of the <strong class="source-inline">appsettings</strong> file <a id="_idIndexMarker136"/>with connection strings, but very often, we have many different files for each environment. Let’s see how to take advantage of one file for each environment.</p>
<h3>Priority in appsettings files</h3>
<p>The <strong class="source-inline">appsettings</strong> file <a id="_idIndexMarker137"/>can be managed according to<a id="_idIndexMarker138"/> the environments in which the application is located. In this case, the practice is to place key information for that environment in the <strong class="source-inline">appsettings.{ENVIRONMENT}.json</strong> file. </p>
<p>The root file (that is, <strong class="source-inline">appsettings.json</strong>) should be used for the production environment only.</p>
<p>For example, if we created these examples in the two files for the <strong class="source-inline">“Priority”</strong> key, what would we get?</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">appsettings.json</p>
<pre class="source-code">
"Priority": "Root"</pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">appsettings.Development.json </p>
<pre class="source-code">
"Priority":    "Dev"</pre>
<p>If it is a <em class="italic">Development</em> environment, the value of the key would result in <strong class="source-inline">Dev</strong>, while in a <em class="italic">Production</em> environment, the value would result in <strong class="source-inline">Root</strong>.</p>
<p>What would happen if the environment was anything other than <em class="italic">Production</em> or <em class="italic">Development</em>? For example, if it were called <em class="italic">Stage</em>? In this case, having not specified any <strong class="source-inline">appsettings.Stage.json</strong> file, the read value would be that of one of the <strong class="source-inline">appsettings.json</strong> files and therefore, <strong class="source-inline">Root</strong>.</p>
<p>However, if we specified the <strong class="source-inline">appsettings.Stage.json</strong> file, the value would be read from the that file.</p>
<p>Next, let’s visit the <strong class="source-inline">Options</strong> pattern. There are objects that the framework provides to load <a id="_idIndexMarker139"/>configuration<a id="_idIndexMarker140"/> information upon startup or when changes are made by the systems department. Let’s go over how.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/>Options pattern</h2>
<p>The <strong class="source-inline">options</strong> pattern<a id="_idIndexMarker141"/> uses <a id="_idIndexMarker142"/>classes to provide strongly typed access to groups of related settings, that is, when configuration settings are isolated by scenario into separate classes.</p>
<p>The <strong class="source-inline">options</strong> pattern will be implemented with different interfaces and different functionalities. Each interface (see the following subsection) has its own features that help us achieve certain goals.</p>
<p>But let’s start in order. We define an object for each type of interface (we will do it to better represent the examples), but the same class can be used to register more options inside the configuration file. It is important to keep the structure of the file identical:</p>
<pre class="source-code">
public class OptionBasic
{
    public string? Value { get; init; }
}
    public class OptionSnapshot
    {
        public string? Value { get; init; }
    }
    public class OptionMonitor
    {
        public string? Value { get; init; }
    }
    public class OptionCustomName
    {
        public string? Value { get; init; }
    }</pre>
<p>Each option is registered in the dependency injection engine via the <strong class="source-inline">Configure</strong> method, which<a id="_idIndexMarker143"/> also<a id="_idIndexMarker144"/> requires the registration of the <strong class="source-inline">T</strong> type present in the method signature. As you can see, in the registration phase, we declared the types and the section of the file where to retrieve the information, and nothing more:</p>
<pre class="source-code">
builder.Services.Configure&lt;OptionBasic&gt;(builder.Configuration.GetSection("OptionBasic"));
builder.Services.Configure&lt;OptionMonitor&gt;(builder.Configuration.GetSection("OptionMonitor"));
builder.Services.Configure&lt;OptionSnapshot&gt;(builder.Configuration.GetSection("OptionSnapshot"));
builder.Services.Configure&lt;OptionCustomName&gt;("CustomName1", builder.Configuration.GetSection("CustomName1"));
builder.Services.Configure&lt;OptionCustomName&gt;("CustomName2", builder.Configuration.GetSection("CustomName2"));</pre>
<p>We have not yet defined how the object should be read, how often, and with what type of interface.</p>
<p>The only thing that changes is the parameter, as seen in the last two examples of the preceding code snippet. This parameter allows you to add a name to the option type. The name is<a id="_idIndexMarker145"/> required to <a id="_idIndexMarker146"/>match the type used in the method signature. This feature<a id="_idIndexMarker147"/> is called <strong class="bold">named options</strong>.</p>
<h3>Different option interfaces</h3>
<p>Different interfaces <a id="_idIndexMarker148"/>can take advantage of the recordings you just defined. Some support named options and some do not:</p>
<ul>
<li><strong class="source-inline">IOptions&lt;TOptions&gt;</strong>:<ul><li>Does not support the following:<ul><li>Reading of configuration data after the app has started</li><li>Named options</li></ul></li><li>Is registered as a singleton and can be injected into any service lifetime</li></ul></li>
<li><strong class="source-inline">IOptionsSnapshot&lt;TOptions&gt;</strong>:<ul><li>Is useful in scenarios where options should be recomputed on every request</li><li>Is registered as <strong class="bold">scoped</strong> and therefore cannot be injected into a singleton service</li><li>Supports named options</li></ul></li>
<li><strong class="source-inline">IOptionsMonitor&lt;TOptions&gt;</strong>:<ul><li>Is used to retrieve options and manage options notifications for <strong class="source-inline">TOptions</strong> instances</li><li>Is registered as a singleton and can be injected into any service lifetime</li><li>Supports the following:<ul><li>Change notifications</li><li>Named options</li><li>Reloadable configuration</li><li>Selective options invalidation (<strong class="source-inline">IOptionsMonitorCache&lt;TOptions&gt;</strong>)</li></ul></li></ul></li>
</ul>
<p>We want to point you to the use of <strong class="source-inline">IOptionsFactory&lt;TOptions&gt;</strong>, which is responsible for creating new instances of options. It has a single <strong class="source-inline">Create</strong> method. The default implementation takes all registered <strong class="source-inline">IConfigureOptions&lt;TOptions&gt;</strong> and <strong class="source-inline">IPostConfigureOptions&lt;TOptions&gt;</strong> and performs all configurations first, followed by post-configuration (<a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces">https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces</a>).</p>
<p>The <strong class="source-inline">Configure</strong> method can also be followed by another method in the configuration pipeline. This<a id="_idIndexMarker149"/> method is called <strong class="source-inline">PostConfigure</strong> and is intended to modify the configuration each time it is configured or reread. Here is an example of how to record this behavior:</p>
<pre class="source-code">
builder.Services.<strong class="bold">PostConfigure</strong>&lt;MyConfigOptions&gt;(myOptions =&gt;
{
   myOptions.Key1 = "my_new_value_post_configuration";
});</pre>
<h3>Putting it all together</h3>
<p>Having defined<a id="_idIndexMarker150"/> the <a id="_idIndexMarker151"/>theory of these numerous interfaces, it remains for us to see <strong class="source-inline">IOptions</strong> at work with a concrete example.</p>
<p>Let’s see the use of the three interfaces just described and the use of <strong class="source-inline">IOptionsFactory</strong>, which, along with the <strong class="source-inline">Create</strong> method and with the named options function, retrieves the correct instance of the object:</p>
<pre class="source-code">
app.MapGet("/read/options", (IOptions&lt;OptionBasic&gt; optionsBasic,
         IOptionsMonitor&lt;OptionMonitor&gt; optionsMonitor,
         IOptionsSnapshot&lt;OptionSnapshot&gt; optionsSnapshot,
         IOptionsFactory&lt;OptionCustomName&gt; optionsFactory) =&gt;
{
         return Results.Ok(new
         {
             Basic = optionsBasic.Value,
             Monitor = optionsMonitor.CurrentValue,
             Snapshot = optionsSnapshot.Value,
             Custom1 = optionsFactory.Create("CustomName1"),
             Custom2 = optionsFactory.Create("CustomName2")
         });
})
.WithName("ReadOptions");</pre>
<p>In the previous code snippet, we want to bring attention to the use of the different interfaces available.</p>
<p>Each individual<a id="_idIndexMarker152"/> interface used in the previous snippet has a particular life cycle that characterizes its behavior. Finally, each interface has slight differences in the methods, as we have already described in the previous paragraphs.</p>
<h3>IOptions and validation</h3>
<p>Last but not<a id="_idIndexMarker153"/> least<a id="_idIndexMarker154"/> is the validation<a id="_idIndexMarker155"/> functionality of the data present in the configuration. This is very useful when the team that has to release the application still performs manual or delicate operations that need to be at least verified by the code.</p>
<p>Before the advent of .NET Core, very often, the application would not start because of an incorrect configuration. Now, with this feature, we can validate the data in the configuration <a id="_idIndexMarker156"/>and<a id="_idIndexMarker157"/> throw errors.</p>
<p>Here is an example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Register option with validation</p>
<pre class="source-code">
builder.Services.AddOptions&lt;ConfigWithValidation&gt;().Bind(builder.Configuration.GetSection(nameof(ConfigWithValidation)))
.<strong class="bold">ValidateDataAnnotations</strong>();
app.MapGet("/read/options", (IOptions&lt;ConfigWithValidation&gt; optionsValidation) =&gt;
{
    return Results.Ok(new
    {
        Validation = optionsValidation.Value
    });
})
.WithName("ReadOptions");</pre>
<p>This is the configuration file where an error is explicitly reported:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Appsettings section for configuration validation</p>
<pre class="source-code">
"ConfigWithValidation": {
         "Email": "andrea.tosato@hotmail.it",
         "NumericRange": 1001
    }</pre>
<p>And here is the class containing the validation logic:</p>
<pre class="source-code">
public class ConfigWithValidation
{
    [RegularExpression(@"^([\w\.\-]+)@([\w\-]+)((\.(\w)
                      {2,})+)$")]
    public string? Email { get; set; }
    [Range(0, 1000, ErrorMessage = "Value for {0} must be 
                                    between {1} and {2}.")]
    public int NumericRange { get; set; }
}</pre>
<p>The application then encounters errors while using the particular configuration and not at startup. This <a id="_idIndexMarker158"/>is <a id="_idIndexMarker159"/>also because, as we have<a id="_idIndexMarker160"/> seen before, <strong class="source-inline">IOptions</strong> could reload information following a change in <strong class="source-inline">appsettings</strong>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Error validate option</p>
<p class="source-code">Microsoft.Extensions.Options.OptionsValidationException: DataAnnotation validation failed for 'ConfigWithValidation' members: 'NumericRange' with the error: 'Value for NumericRange must be between 0 and 1000.'.</p>
<p class="callout-heading">Best practice for using validation in IOptions </p>
<p class="callout">This setting is <a id="_idIndexMarker161"/>not suitable for all application scenarios. Only some options can have formal validations; if we think of a connection string, it is not necessarily formally incorrect, but the connection may not be working.</p>
<p class="callout">Be cautious about applying this feature, especially since it reports errors at runtime and not during startup and gives an Internal Server Error, which is not a best practice in scenarios that should be handled.</p>
<p>Everything we’ve seen up to this point is about configuring the <strong class="source-inline">appsettings.json</strong> file, but what <a id="_idIndexMarker162"/>if <a id="_idIndexMarker163"/>we wanted to use other sources for configuration management? We’ll look at that in the next section.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Configuration sources</h2>
<p>As we <a id="_idIndexMarker164"/>mentioned at the beginning of the section, the <strong class="source-inline">IConfiguration</strong> interface and all variants of <strong class="source-inline">IOptions</strong> work not only with the <strong class="source-inline">appsettings</strong> file but also on different sources.</p>
<p>Each source has its own characteristics, and the syntax for accessing objects is very similar between providers. The main problem is when we must define a complex object or an array of objects; in this case, we will see how to behave and be able to replicate the dynamic structure of a JSON file.</p>
<p>Let’s look at two very common use cases.</p>
<h3>Configuring an application in Azure App Service </h3>
<p>Let’s start<a id="_idIndexMarker165"/> with <a id="_idIndexMarker166"/>Azure, and in particular, the Azure Web Apps service. </p>
<p>On the <strong class="bold">Configuration</strong> page, there are two sections: <strong class="bold">Application settings</strong> and <strong class="bold">Connection strings</strong>. </p>
<p>In the first section, we need to insert the keys and values or JSON objects that we saw in the previous examples.</p>
<p>In the <strong class="bold">Connection strings</strong> section, you can insert the connection strings that are usually inserted in the <strong class="source-inline">appsettings.json</strong> file. In this section, in addition to the textual string, it is necessary to set the connection type, as we saw in the <em class="italic">Configuration in .NET 6</em> section.</p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<img alt="Figure 3.12 – Azure App Service Application settings " height="624" src="image/Figure_3.12_B17902.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Azure App Service Application settings</p>
<h3>Inserting an object</h3>
<p>To insert <a id="_idIndexMarker167"/>an object, we must specify the parent for each key.</p>
<p>The format is as follows:</p>
<p><strong class="source-inline">parent__key</strong></p>
<p>Note that there are <em class="italic">two</em> underscores.</p>
<p>The object in the JSON file would be defined as follows:</p>
<pre class="source-code">
"MyCustomObject": {
         "CustomProperty": "PropertyValue"
    }</pre>
<p>So, we should write <strong class="source-inline">MyCustomObject__CustomProperty</strong>.</p>
<h3>Inserting an array</h3>
<p>Inserting<a id="_idIndexMarker168"/> an array is much more verbose.</p>
<p>The format is as follows:</p>
<p><strong class="source-inline">parent__child__ArrayIndexNumber_key</strong></p>
<p>The array in the JSON file would be defined as follows:</p>
<pre class="source-code">
{
    "MyCustomArray": {
       "CustomPropertyArray": [
         { "CustomKey": "ValueOne" },
         { "CustomKey ": "ValueTwo" }
     ]
    }
}</pre>
<p>So, to <a id="_idIndexMarker169"/>access the <strong class="source-inline">ValueOne</strong> value, we should write the following: <strong class="source-inline">MyCustomArray__CustomPropertyArray__0__CustomKey</strong>.</p>
<h3>Configuring an application in Docker </h3>
<p>If we are<a id="_idIndexMarker170"/> developing for containers and therefore for <a id="_idIndexMarker171"/>Docker, <strong class="source-inline">appsettings</strong> files are usually replaced in the <strong class="source-inline">docker-compose</strong> file, and very often in the <strong class="source-inline">override</strong> file, because it behaves analogously to the settings files divided by the environment.</p>
<p>We want to provide a brief overview of the features that are usually leveraged to configure an application hosted in Docker. Let’s see in detail how to define root keys and objects, and how to set the connection string. Here is an example:</p>
<pre class="source-code">
app.MapGet("/env-test", (IConfiguration configuration) =&gt;
{
    var rootProperty = configuration.
    GetValue&lt;string&gt;("RootProperty");
    var sampleVariable = configuration.
    GetValue&lt;string&gt;("RootSettings:SampleVariable");
    var connectionString = configuration.
    GetConnectionString("SqlConnection");
    return Results.Ok(new
    {
        RootProperty = rootProperty,
        SampleVariable = sampleVariable,
        Connection String = connectionString
    });
})
.WithName("EnvironmentTest");</pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Minimal APIs that use configuration</p>
<p>The <strong class="source-inline">docker-compose.override.yaml</strong> file<a id="_idIndexMarker172"/> is as <a id="_idIndexMarker173"/>follows:</p>
<pre class="source-code">
services:
    dockerenvironment:
         environment:
              - ASPNETCORE_ENVIRONMENT=Development
              - ASPNETCORE_URLS=https://+:443;http://+:80
              - RootProperty=minimalapi-root-value
              - RootSettings__SampleVariable=minimalapi-variable-value
              - ConnectionStrings__SqlConnection=Server=minimal.db;Database=minimal_db;User Id=sa;Password=Taggia42!</pre>
<p>There is only one application container for this example, and the service that instantiates it is called <strong class="source-inline">dockerenvironment</strong>.</p>
<p>In the configuration section, we can see three particularities that we are going to analyze line by line.</p>
<p>The snippet we want to show you has several very interesting components: a property in the configuration root, an object composed of a single property, and a connection string to a database.</p>
<p>In this first configuration, you are going to set a property that is the root of the configurations. In this case, it is a simple string:</p>
<pre class="source-code">
# First configuration
- RootProperty=minimalapi-root-value</pre>
<p>In this second configuration, we are going to set up an object:</p>
<pre class="source-code">
# Second configuration
- RootSettings__SampleVariable=minimalapi-variable-value</pre>
<p>The object is called <strong class="source-inline">RootSettings</strong>, while the only property it contains is called <strong class="source-inline">SampleVariable</strong>. This object can be read in different ways. We recommend using the <strong class="source-inline">Ioptions</strong> object that we have seen extensively before. In the preceding example, we show how <a id="_idIndexMarker174"/>to<a id="_idIndexMarker175"/> access a single property present in an object via code.</p>
<p>In this case, via code, you need to use the following notation to access the value: <strong class="source-inline">RootSettings:SampleVariable</strong>. This approach is useful if you need to read a single property, but we recommend using the <strong class="source-inline">Ioptions</strong> interfaces to access the object.</p>
<p>In this last example, we show you how to set the connection string called <strong class="source-inline">SqlConnection</strong>. This way, it will be easy to retrieve the information from the base methods available on <strong class="source-inline">Iconfiguration</strong>:</p>
<pre class="source-code">
# Third configuration
- ConnectionStrings__SqlConnection=Server=minimal.db;Database=minimal_db;User Id=sa;Password=Taggia42!</pre>
<p>To read the information, it is necessary to exploit this method: <strong class="source-inline">GetConnectionString(“SqlConnection”)</strong>.</p>
<p>There are a lot of scenarios for configuring our applications; in the next section, we will also see how to handle errors.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/>Error handling</h1>
<p>Error handling is <a id="_idIndexMarker176"/>one of the features that every application must provide. The representation of an error allows the client to understand the error and possibly handle the request accordingly. Very often, we have our own customized methods of handling errors.</p>
<p>Since what we’re describing is a key functionality of the application, we think it’s fair to see what the framework provides and what is more correct to use.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Traditional approach</h2>
<p>.NET provides <a id="_idIndexMarker177"/>the same tool for minimal APIs that we can implement in traditional<a id="_idIndexMarker178"/> development: a <strong class="bold">Developer Exception Page</strong>. This is nothing but middleware that reports the error in plain text format. This middleware can’t be removed from the ASP.NET pipeline and works exclusively in the development environment (<a href="https://docs.microsoft.com/aspnet/core/fundamentals/error-handling">https://docs.microsoft.com/aspnet/core/fundamentals/error-handling</a>).</p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 3.13 – Minimal APIs pipeline, ExceptionHandler " height="741" src="image/Figure_3.13_B17902.jpg" width="1280"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Minimal APIs pipeline, ExceptionHandler</p>
<p>If exceptions are raised within our code, the only way to catch them in the application layer is through middleware that is activated before sending the response to the client. </p>
<p>Error handling<a id="_idIndexMarker179"/> middleware is standard and can be implemented as follows:</p>
<pre class="source-code">
app.UseExceptionHandler(exceptionHandlerApp =&gt;
{
    exceptionHandlerApp.Run(async context =&gt;
    {
        context.Response.StatusCode = StatusCodes.
        Status500InternalServerError;
        context.Response.ContentType = Application.Json;
        var exceptionHandlerPathFeature = context.Features.
          Get&lt;IExceptionHandlerPathFeature&gt;()!;
        var errorMessage = new
        {
            Message = exceptionHandlerPathFeature.Error.Message
        };
        await context.Response.WriteAsync
        (JsonSerializer.Serialize(errorMessage));
         if (exceptionHandlerPathFeature?.
             Error is FileNotFoundException)
         {
             await context.Response.
             WriteAsync(" The file was not found.");
         }
         if (exceptionHandlerPathFeature?.Path == "/")
         {
             await context.Response.WriteAsync("Page: Home.");
         }
    });
});</pre>
<p>We have shown here a possible implementation of the middleware. In order to be implemented, the <strong class="source-inline">UseExceptionHandler</strong> method must be exploited, allowing the writing of management code for the whole application. </p>
<p>Through the <strong class="source-inline">var</strong> functionality called <strong class="source-inline">exceptionHandlerPathFeature = context.Features.Get&lt;IExceptionHandlerPathFeature&gt;()!;</strong>, we can access the error stack and return the information of interest for the caller in the output:</p>
<pre class="source-code">
app.MapGet("/ok-result", () =&gt;
{
         throw new ArgumentNullException("taggia-parameter", 
         "Taggia has an error");
})
.WithName("OkResult");</pre>
<p>When an exception occurs in the code, as in the preceding example, the middleware steps in and<a id="_idIndexMarker180"/> handles the return message to the client. </p>
<p>If the exception were to occur in internal application stacks, the middleware would still intervene to provide the client with the correct error and appropriate indication.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Problem Details and the IETF standard</h2>
<p><em class="italic">Problem Details for HTTP APIs</em> is <a id="_idIndexMarker181"/>an<a id="_idIndexMarker182"/> IETF<a id="_idIndexMarker183"/> standard<a id="_idIndexMarker184"/> that was approved in 2016. This standard<a id="_idIndexMarker185"/> allows a set of information to be returned to the caller with standard fields and JSON notations that help identify the error.</p>
<p>HTTP status codes are sometimes not enough to convey enough information about an error to be useful. While the humans behind web browsers can be informed about the nature of the problem with an HTML response body, non-human consumers, such as machine, PC, and server, of so-called <em class="italic">HTTP APIs</em> usually cannot.</p>
<p>This specification defines simple JSON and XML document formats to suit this purpose. They are designed to be reused by HTTP APIs, which can identify distinct <em class="italic">problem types</em> specific to their needs.</p>
<p>Thus, API clients can be informed of both the high-level error class and the finer-grained details of the problem (<a href="https://datatracker.ietf.org/doc/html/rfc7807">https://datatracker.ietf.org/doc/html/rfc7807</a>).</p>
<p>In .NET, there is a package with all the functionality that meets the IETF standard.</p>
<p>The package<a id="_idIndexMarker186"/> is<a id="_idIndexMarker187"/> called <strong class="source-inline">Hellang.Middleware.ProblemDetails</strong>, and you can download <a id="_idIndexMarker188"/>it at <a id="_idIndexMarker189"/>the following address: <a href="https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/">https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/</a>.</p>
<p>Let’s see now how to insert the package into the project and configure it:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.Services.TryAddSingleton&lt;IActionResultExecutor&lt;ObjectResult&gt;, ProblemDetailsResultExecutor&gt;();</strong>
<strong class="bold">builder.Services.AddProblemDetails(options =&gt;</strong>
<strong class="bold">{   options.MapToStatusCode&lt;NotImplementedException&gt;</strong>
<strong class="bold">    (StatusCodes.Status501NotImplemented);</strong>
<strong class="bold">});</strong>
var app = builder.Build();
app.<strong class="bold">UseProblemDetails</strong>();</pre>
<p>As you can see, there are only two instructions to make this package work:</p>
<ul>
<li><strong class="source-inline">builder.Services.AddProblemDetails</strong></li>
<li><strong class="source-inline">app.UseProblemDetails();</strong></li>
</ul>
<p>Since, in the minimal APIs, the <strong class="source-inline">IActionResultExecutor</strong> interface is not present in the ASP.NET pipeline, it is necessary to add a custom class to handle the response in case of an error.</p>
<p>To do this, you need to add a class (the following) and register it in the dependency injection engine: <strong class="source-inline">builder.Services.TryAddSingleton&lt;IActionResultExecutor&lt;ObjectResult&gt;, ProblemDetailsResultExecutor&gt;();</strong>.</p>
<p>Here is the class<a id="_idIndexMarker190"/> to <a id="_idIndexMarker191"/>support the package, also under <a id="_idIndexMarker192"/>minimal <a id="_idIndexMarker193"/>APIs:</p>
<pre class="source-code">
public class ProblemDetailsResultExecutor : IActionResultExecutor&lt;ObjectResult&gt;
{
    public virtual Task ExecuteAsync(ActionContext context, 
    ObjectResult result)
{
        ArgumentNullException.ThrowIfNull(context);
        ArgumentNullException.ThrowIfNull(result);
        var executor = Results.Json(result.Value, null, 
        "application/problem+json", result.StatusCode);
        return executor.ExecuteAsync(context.HttpContext);
    }
}</pre>
<p>As mentioned earlier, the standard for handling error messages has been present in the IETF standard for several years, but for the C# language, it is necessary to add the package just mentioned.</p>
<p>Now, let’s see how this package goes about handling errors on some endpoints that we report here:</p>
<pre class="source-code">
app.MapGet("/internal-server-error", () =&gt;
{
    throw new ArgumentNullException("taggia-parameter", 
    "Taggia has an error");
})
    .Produces&lt;ProblemDetails&gt;(StatusCodes.
     Status500InternalServerError)
         .WithName("internal-server-error");</pre>
<p>We throw an application-level exception with this endpoint. In this case, the <strong class="source-inline">ProblemDetails</strong> middleware goes and returns a JSON error consistent with the error. We then <a id="_idIndexMarker194"/>have<a id="_idIndexMarker195"/> the<a id="_idIndexMarker196"/> handling of an unhandled<a id="_idIndexMarker197"/> exception for free:</p>
<pre class="source-code">
{
    "type": "https://httpstatuses.com/500",
    "title": "Internal Server Error",
    "status": 500,
    "detail": "Taggia has an error (Parameter 'taggia-
     parameter')",
    "exceptionDetails": [
         {
 ------- for brevity
         }
    ],
    "traceId": "00-f6ff69d6f7ba6d2692d87687d5be75c5-
     e734f5f081d7a02a-00"
}</pre>
<p>By inserting additional configurations in the <strong class="source-inline">Program</strong> file, you can map some specific exceptions to HTTP errors. Here is an example:</p>
<pre class="source-code">
builder.Services.AddProblemDetails(options =&gt;
{
    options.MapToStatusCode&lt;NotImplementedException&gt;
      (StatusCodes.Status501NotImplemented);
});</pre>
<p>The code with the <strong class="source-inline">NotImplementedException</strong> exception is mapped to HTTP error code <strong class="source-inline">501</strong>:</p>
<pre class="source-code">
app.MapGet("/not-implemented-exception", () =&gt;
{
    throw new NotImplementedException
      ("This is an exception thrown from a Minimal API.");
})
    .Produces&lt;ProblemDetails&gt;(StatusCodes.
     Status501NotImplemented)
         .WithName("NotImplementedExceptions");</pre>
<p>Finally, it is<a id="_idIndexMarker198"/> possible<a id="_idIndexMarker199"/> to<a id="_idIndexMarker200"/> create<a id="_idIndexMarker201"/> extensions to the <strong class="source-inline">ProblemDetails</strong> class of the framework with additional fields or to call the <strong class="source-inline">base</strong> method by adding custom text.</p>
<p>Here are the last two examples of <strong class="source-inline">MapGet</strong> endpoint handlers:</p>
<pre class="source-code">
app.MapGet("/problems", () =&gt;
{
    return Results.Problem(detail: "This will end up in 
                                    the 'detail' field.");
})
    .Produces&lt;ProblemDetails&gt;(StatusCodes.Status400BadRequest)
    .WithName("Problems");
app.MapGet("/custom-error", () =&gt;
{
    var problem = new OutOfCreditProblemDetails
    {
        Type = "https://example.com/probs/out-of-credit",
        Title = "You do not have enough credit.",
        Detail = "Your current balance is 30, 
        but that costs 50.",
        Instance = "/account/12345/msgs/abc",
        Balance = 30.0m, Accounts = 
        { "/account/12345", "/account/67890" }
    };
    return Results.Problem(problem);
})
    .Produces&lt;OutOfCreditProblemDetails&gt;(StatusCodes.
     Status400BadRequest)
     .WithName("CreditProblems");
app.Run();
public class OutOfCreditProblemDetails : ProblemDetails
{
    public OutOfCreditProblemDetails()
    {
        Accounts = new List&lt;string&gt;();
    }
    public decimal Balance { get; set; }
    public ICollection&lt;string&gt; Accounts { get; }
}</pre>
<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>Summary</h1>
<p>In this chapter, we have seen several advanced aspects regarding the implementation of minimal APIs. We explored Swagger, which is used to document APIs and provide the developer with a convenient, working debugging environment. We saw how CORS handles the issue of applications hosted on different addresses other than the current API. Finally, we saw how to load configuration information and handle unexpected errors in the application.</p>
<p>We explored the nuts and bolts that will allow us to be productive in a short amount of time.</p>
<p>In the next chapter, we will add a fundamental building block for SOLID pattern-oriented programming, namely the dependency injection engine, which will help us to better manage the application code scattered in the various layers.</p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer034">
<h1 id="_idParaDest-59"><a id="_idTextAnchor060"/>Part 2: What’s New in .NET 6?</h1>
<p>In the second part of the book, we want to show you the features of the .NET 6 framework and how they can also be used in minimal APIs.</p>
<p>We will cover the following chapters in this section:</p>
<ul>
<li><a href="B17902_04.xhtml#_idTextAnchor061"><em class="italic">Chapter 4</em></a>, <em class="italic">Dependency Injection in a Minimal API Project</em></li>
<li><a href="B17902_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>, <em class="italic">Using Logging to Identify Errors</em></li>
<li><a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em></li>
<li><a href="B17902_07.xhtml#_idTextAnchor094"><em class="italic">Chapter 7</em></a>, <em class="italic">Integration with the Data Access Layer</em></li>
</ul>
</div>
<div>
<div id="_idContainer035">
</div>
</div>
<div>
<div id="_idContainer036">
</div>
</div>
</div></body></html>