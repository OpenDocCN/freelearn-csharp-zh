<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-121"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-122"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.2.1">Implement Transactions across Microservices Using the Saga Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We have just looked at database development and what we need to consider when building an application developed using a microservices architecture. </span><span class="koboSpan" id="kobo.3.2">We discussed the pros and cons of creating individual databases per microservice. </span><span class="koboSpan" id="kobo.3.3">It does allow each microservice to have more autonomy, allowing us to choose the best technology needed for the service. </span><span class="koboSpan" id="kobo.3.4">While it is preferred and a recommended technique, it does have significant drawbacks when it comes to ensuring data consistency across the data stores.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Typically, we ensure consistency through transactions. </span><span class="koboSpan" id="kobo.4.2">Transactions, as discussed earlier in this book, ensure that all data is committed or none. </span><span class="koboSpan" id="kobo.4.3">That way, we can ensure that an operation will not partially write data and that what we see truly reflects the state of the data being tracked.</span></p>
<p><span class="koboSpan" id="kobo.5.1">It is difficult to enforce transactions across microservices with different databases, but that is when we employ the </span><em class="italic"><span class="koboSpan" id="kobo.6.1">saga pattern</span></em><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">This pattern helps us to orchestrate database operations and ensure that our operations are consistent.</span></p>
<p><span class="koboSpan" id="kobo.8.1">After reading this chapter, we will understand how to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Use the Saga pattern to implement transactions across microservices</span></li>
<li><span class="koboSpan" id="kobo.10.1">Choreograph data operations across microservices</span></li>
<li><span class="koboSpan" id="kobo.11.1">Implement orchestration</span></li>
</ul>
<h1 id="_idParaDest-123"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.12.1">Exploring the Saga pattern</span></h1>
<p><span class="koboSpan" id="kobo.13.1">We </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.14.1">have previously explored the </span><em class="italic"><span class="koboSpan" id="kobo.15.1">database-per-service</span></em><span class="koboSpan" id="kobo.16.1"> pattern, which encourages us to have individual data stores per service. </span><span class="koboSpan" id="kobo.16.2">With this in place, each microservice will handle its own database and transactions internally. </span><span class="koboSpan" id="kobo.16.3">This presents a new challenge where an operation that requires several services to take part and potentially modify their data runs the risk of partial failures and eventually leads to data inconsistency in our application. </span><span class="koboSpan" id="kobo.16.4">This is the major drawback of this pattern choice as we cannot guarantee that our databases will remain in sync at all times.</span></p>
<p><span class="koboSpan" id="kobo.17.1">This is where we employ the saga pattern. </span><span class="koboSpan" id="kobo.17.2">You may think of a saga as a predefined set of steps that outline the order in which the services should be called. </span><span class="koboSpan" id="kobo.17.3">The saga pattern will also have the responsibility of providing oversight across all our services watching and listening, so to speak, for any signs of failure in any service along the way.</span></p>
<p><span class="koboSpan" id="kobo.18.1">If a failure is reported by a service, the saga will also contain a rollback measure for each service. </span><span class="koboSpan" id="kobo.18.2">So, it will proceed, in a specific order, to prompt each service that might have been successful before the failure to undo the change it made. </span><span class="koboSpan" id="kobo.18.3">This comes in handy since our services are decoupled and ideally will not communicate directly with each other.</span></p>
<p><span class="koboSpan" id="kobo.19.1">A saga is a mechanism that spans multiple services and can implement transactions across various data stores. </span><span class="koboSpan" id="kobo.19.2">We have distributed transaction options such as </span><em class="italic"><span class="koboSpan" id="kobo.20.1">two-phase commit</span></em><span class="koboSpan" id="kobo.21.1">, which can require that all data stores commit or rollback. </span><span class="koboSpan" id="kobo.21.2">This would be perfect, except some NoSQL databases and message brokers are not entirely compatible with this model.</span></p>
<p><span class="koboSpan" id="kobo.22.1">Imagine that a new patient registered with our healthcare center. </span><span class="koboSpan" id="kobo.22.2">This process will require that the patient provides their information and some essential documents, and books an initial appointment, which requires payment. </span><span class="koboSpan" id="kobo.22.3">These actions require four different microservices to get involved and thus, four different data stores will be affected.</span></p>
<p><span class="koboSpan" id="kobo.23.1">We can refer to an operation that spans multiple services as a </span><em class="italic"><span class="koboSpan" id="kobo.24.1">saga</span></em><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">Once again, a saga is a sequence of local transactions. </span><span class="koboSpan" id="kobo.25.3">Each transaction updates the data target database and produces a message or event that triggers the next transaction operation of the saga. </span><span class="koboSpan" id="kobo.25.4">If one of the local transactions fails along the chain, the saga will execute rollbacks across the databases that were affected by the preceding transactions.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Three types of transactions are generally implemented by a saga:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Compensable</span></strong><span class="koboSpan" id="kobo.28.1">: These </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.29.1">are transactions that can be reversed by another transaction with the opposite effect.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.30.1">Retryable</span></strong><span class="koboSpan" id="kobo.31.1">: These</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.32.1"> transactions are guaranteed to succeed and are implemented after pivot transactions.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.33.1">Pivot</span></strong><span class="koboSpan" id="kobo.34.1">: As the</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.35.1"> name suggests, the success or failure of these transactions is pivotal to the continuation of the saga. </span><span class="koboSpan" id="kobo.35.2">If the transaction commits, then the saga runs until it is completed. </span><span class="koboSpan" id="kobo.35.3">These transactions can be placed as a final compensable transaction or the first retryable transaction of the saga. </span><span class="koboSpan" id="kobo.35.4">They may also be implemented as neither.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.36.1">Figure 8.1</span></em><span class="koboSpan" id="kobo.37.1"> shows the saga pattern:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.38.1"><img alt="Figure 8.1 – Each local transaction sends a message to the next service in the saga until the saga is completed" src="image/Figure_8.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.39.1">Figure 8.1 – Each local transaction sends a message to the next service in the saga until the saga is completed</span></p>
<p><span class="koboSpan" id="kobo.40.1">As we know with every pattern, we have advantages and disadvantages, and it is important to consider all angles so that we can adequately plan an approach. </span><span class="koboSpan" id="kobo.40.2">Let us review some known issues and considerations that need to be taken when implementing this pattern.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.41.1">Issues and considerations</span></h2>
<p><span class="koboSpan" id="kobo.42.1">Given the fact that, up until this chapter, we would have written off the possibility of implementing ACID transactions across our data stores in a microservices architecture, we can imagine that this</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.43.1"> pattern is not easy to implement. </span><span class="koboSpan" id="kobo.43.2">It requires absolute </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.44.1">coordination and a good understanding of all the moving parts of our application.</span></p>
<p><span class="koboSpan" id="kobo.45.1">This pattern is also difficult to debug. </span><span class="koboSpan" id="kobo.45.2">Given that we are implementing a singular function across autonomous services, we have now introduced a new touch point and potential point of failure for which special effort must be made to track and trace where the failure may have been. </span><span class="koboSpan" id="kobo.45.3">This complexity increases with each added step to the participating services of the saga.</span></p>
<p><span class="koboSpan" id="kobo.46.1">We need to make sure that our saga can handle transient failures in the architecture. </span><span class="koboSpan" id="kobo.46.2">These are errors that happen during an operation that might not be permanent. </span><span class="koboSpan" id="kobo.46.3">Thus, it is prudent of us to include retry logic to ensure that a single failure in an attempt does not end the saga prematurely. </span><span class="koboSpan" id="kobo.46.4">In doing so, we also need to ensure that our data is consistent with each retry.</span></p>
<p><span class="koboSpan" id="kobo.47.1">This pattern is certainly not without its challenges, and it will increase the complexity of our application code significantly. </span><span class="koboSpan" id="kobo.47.2">It is not foolproof as it will have its fallacies, but it will certainly assist us in ensuring that our data is more consistent across our loosely coupled services, by either rolling back or compensating for operational failures.</span></p>
<p><span class="koboSpan" id="kobo.48.1">Sagas are usually coordinated using either </span><em class="italic"><span class="koboSpan" id="kobo.49.1">orchestration</span></em><span class="koboSpan" id="kobo.50.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.51.1">choreography</span></em><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">Both methods have their pros and cons. </span><span class="koboSpan" id="kobo.52.3">Let us begin with exploring choreography.</span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.53.1">Understanding and implementing choreography</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.54.1">Choreography</span></strong><span class="koboSpan" id="kobo.55.1"> is a </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.56.1">method of coordinating sagas where participating services used messages or events to notify each other of completion or failure. </span><span class="koboSpan" id="kobo.56.2">In this model, the event broker sits in between the services but does not control the flow of messages or the flow of the saga. </span><span class="koboSpan" id="kobo.56.3">This means that there is no central point of reference or control, and each service is simply watching for a message that acts as a confirmation trigger for it to start its operation.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.57.1">Figure 8.2</span></em><span class="koboSpan" id="kobo.58.1"> shows the choreography flow:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.59.1"><img alt="Figure 8.2 – An application request sends a message to the queue to inform the first service in the saga to begin, and messages flow between all participating services" src="image/Figure_8.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.60.1">Figure 8.2 – An application request sends a message to the queue to inform the first service in the saga to begin, and messages flow between all participating services</span></p>
<p><span class="koboSpan" id="kobo.61.1">The main takeaway from the </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.62.1">choreography model is that there is no central point of control. </span><span class="koboSpan" id="kobo.62.2">Each service will listen to events and decide whether it is time to take an action. </span><span class="koboSpan" id="kobo.62.3">The contents of the message will inform the service it should act and if it acts, it will reply with a message stating the success or failure of its action. </span><span class="koboSpan" id="kobo.62.4">If the last service of the saga is successful, then no message is produced, and the saga will end.</span></p>
<p><span class="koboSpan" id="kobo.63.1">If we were to visualize this process using our user registration and appointment booking example mentioned earlier in this chapter, we would have a flow looking like this:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.64.1">The user submits a registration and appointment booking request (client request).</span></li>
<li><span class="koboSpan" id="kobo.65.1">The </span><em class="italic"><span class="koboSpan" id="kobo.66.1">registration service</span></em><span class="koboSpan" id="kobo.67.1"> stores the new user’s data and then publishes an event with relevant appointment and payment details. </span><span class="koboSpan" id="kobo.67.2">This event could be called, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">USER_CREATED</span></strong><span class="koboSpan" id="kobo.69.1">.</span></li>
<li><span class="koboSpan" id="kobo.70.1">The </span><em class="italic"><span class="koboSpan" id="kobo.71.1">payment service</span></em><span class="koboSpan" id="kobo.72.1"> listens for </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">USER_CREATED</span></strong><span class="koboSpan" id="kobo.74.1"> events and will attempt to process a payment as necessary. </span><span class="koboSpan" id="kobo.74.2">When successful, it will produce a </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">PAYMENT_SUCCESS</span></strong><span class="koboSpan" id="kobo.76.1"> event.</span></li>
<li><span class="koboSpan" id="kobo.77.1">The </span><em class="italic"><span class="koboSpan" id="kobo.78.1">appointment booking</span></em><span class="koboSpan" id="kobo.79.1"> service processes </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">PAYMENT_SUCCESS</span></strong><span class="koboSpan" id="kobo.81.1"> events and proceeds to add the appointment information as expected. </span><span class="koboSpan" id="kobo.81.2">This service makes the booking arrangements and produces a </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">BOOKING_SUCCESS</span></strong><span class="koboSpan" id="kobo.83.1"> event for the next service.</span></li>
<li><span class="koboSpan" id="kobo.84.1">The </span><em class="italic"><span class="koboSpan" id="kobo.85.1">document upload service</span></em><span class="koboSpan" id="kobo.86.1"> receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">BOOKING_SUCCESS</span></strong><span class="koboSpan" id="kobo.88.1"> event and proceeds to upload the documents and add a record to the document service data store.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.89.1">This example shows that we can </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.90.1">track the processes along the chain. </span><span class="koboSpan" id="kobo.90.2">If we wanted to know each leg and the outcome, we can have the registration service listen to all events and make state updates or logs of the progress along the saga. </span><span class="koboSpan" id="kobo.90.3">It will also be able to communicate the success or failure of the saga back to the client.</span></p>
<p><span class="koboSpan" id="kobo.91.1">What happens though when a service fails? </span><span class="koboSpan" id="kobo.91.2">How do we mitigate or reap the benefit of the the saga pattern's ability to reverse changes that have already gone? </span><span class="koboSpan" id="kobo.91.3">Let’s review that next.</span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.92.1">Rolling back on failure</span></h2>
<p><span class="koboSpan" id="kobo.93.1">Sagas are </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.94.1">necessary because they allow us to roll back the changes that have already happened when something fails. </span><span class="koboSpan" id="kobo.94.2">If a local transaction fails, the service will publish an event stating that it was unsuccessful. </span><span class="koboSpan" id="kobo.94.3">We then need additional code in the preceding service that will react with the rollback procedures accordingly. </span><span class="koboSpan" id="kobo.94.4">For example, if our payment service operation failed, then the flow would look something like this:</span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.95.1">The appointment booking service failed to confirm the appointment booking and publishes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">BOOKING_FAILED</span></strong><span class="koboSpan" id="kobo.97.1"> event.</span></li>
<li><span class="koboSpan" id="kobo.98.1">The payment service receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">BOOKING_FAILED</span></strong><span class="koboSpan" id="kobo.100.1"> event and proceeds to issue a refund to the client. </span><span class="koboSpan" id="kobo.100.2">This would be a remediation step.</span></li>
<li><span class="koboSpan" id="kobo.101.1">The preceding registration service will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">BOOKING_FAILED</span></strong><span class="koboSpan" id="kobo.103.1"> event and notify the client that the booking was not successful.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.104.1">In this situation, we are not completely reversing every step since we retain the user’s registration information for future reference. </span><span class="koboSpan" id="kobo.104.2">What is important, though, is that the next service in the saga, which uploads the documents, is not configured to listen for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">BOOKING_FAILED</span></strong><span class="koboSpan" id="kobo.106.1"> event. </span><span class="koboSpan" id="kobo.106.2">So, it will have nothing to do unless it sees a </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">BOOKING_SUCCESS</span></strong><span class="koboSpan" id="kobo.108.1"> event.</span></p>
<p><span class="koboSpan" id="kobo.109.1">We can also take note of the fact that our remediation steps are relative to the actual operation being carried out. </span><span class="koboSpan" id="kobo.109.2">Our </span><em class="italic"><span class="koboSpan" id="kobo.110.1">payment service</span></em><span class="koboSpan" id="kobo.111.1"> is likely a wrapper around a third-party payment engine that will also write a local database record of the payment operation. </span><span class="koboSpan" id="kobo.111.2">In its remediation steps, it will not remove the payment record, but simply mark it as a refunded payment or cancel the payment, given the lack of completion of the saga.</span></p>
<p><span class="koboSpan" id="kobo.112.1">While this is not </span><em class="italic"><span class="koboSpan" id="kobo.113.1">ACID</span></em><span class="koboSpan" id="kobo.114.1"> in the true sense of what a local database would do, and undo a database the effects of a write operation, a rollback might look different for each service, based on the business rules or nature of the operation. </span><span class="koboSpan" id="kobo.114.2">We also see that our rollback did not span every single service, since our business rules suggest that we keep the user registration information for future reference.</span></p>
<p><span class="koboSpan" id="kobo.115.1">Another thing </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.116.1">that we need to consider is whether there is a necessity in our rollback operations. </span><span class="koboSpan" id="kobo.116.2">Given the event-based nature of our services, if we want to implement an order, then we will need more event types that services will listen for specifically.</span></p>
<p><span class="koboSpan" id="kobo.117.1">Let us review the pros and cons of this choreography implementation.</span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.118.1">Pros and cons</span></h2>
<p><span class="koboSpan" id="kobo.119.1">In the choreography model, we </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.120.1">have a simple approach to implementing a saga. </span><span class="koboSpan" id="kobo.120.2">This method makes use of some of the previous patterns that we have discussed in </span><em class="italic"><span class="koboSpan" id="kobo.121.1">event sourcing</span></em><span class="koboSpan" id="kobo.122.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.123.1">asynchronous service communication</span></em><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">Each service retains its autonomy, and a rollback operation might look different per service. </span><span class="koboSpan" id="kobo.124.3">It is a clean way to implement a saga for a smaller operation with fewer participants and fewer potential outcomes based on success or failure.</span></p>
<p><span class="koboSpan" id="kobo.125.1">We can also take the asynchronous approach to the saga as some form of advantage, as we can trigger multiple simultaneous operations stemming from each service’s success. </span><span class="koboSpan" id="kobo.125.2">This is good for getting operations done quickly while the client is waiting on the outcome.</span></p>
<p><span class="koboSpan" id="kobo.126.1">We also see that we need</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.127.1"> to always be expanding our code base to facilitate the varying operations and their outcomes, especially if we intend to implement an order for the rollback operations. </span><span class="koboSpan" id="kobo.127.2">Given the asynchronous model that is used to implement this type of saga, it might be dangerous to use one event type to trigger operations simultaneously.</span></p>
<p><span class="koboSpan" id="kobo.128.1">As the number of </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.129.1">participants grows, we run the risk of implementing a complex web of participants, events, and remediations. </span><span class="koboSpan" id="kobo.129.2">It grows increasingly difficult to properly monitor all the services and adequately trace the points of failure. </span><span class="koboSpan" id="kobo.129.3">If an operation is to be tested, all services must be running to properly troubleshoot our operations. </span><span class="koboSpan" id="kobo.129.4">The bigger the saga gets, the more difficult it is to monitor.</span></p>
<p><span class="koboSpan" id="kobo.130.1">For this reason, we look to another saga pattern in the form of orchestration, which implements a central point of control. </span><span class="koboSpan" id="kobo.130.2">We will review it next.</span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.131.1">Understanding and implementing orchestration</span></h1>
<p><span class="koboSpan" id="kobo.132.1">When we think of the word </span><em class="italic"><span class="koboSpan" id="kobo.133.1">orchestration</span></em><span class="koboSpan" id="kobo.134.1">, we think of coordination. </span><span class="koboSpan" id="kobo.134.2">An orchestra</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.135.1"> is a coordinated combination of</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.136.1"> musicians all working towards producing the same kind of music. </span><span class="koboSpan" id="kobo.136.2">Each musician plays their part, but they are led by a conductor who guides each of them along the same path.</span></p>
<p><span class="koboSpan" id="kobo.137.1">The orchestration method of implementing a saga is not very different in terms of how we need a central point of control (like a conductor), and all the services are monitored by the central point of control to ensure that they play their part well, or report failure accordingly. </span><span class="koboSpan" id="kobo.137.2">The central control is referred to as</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.138.1"> an </span><em class="italic"><span class="koboSpan" id="kobo.139.1">orchestrator</span></em><span class="koboSpan" id="kobo.140.1"> and it is a microservice that sits between the client and all other microservices. </span><span class="koboSpan" id="kobo.140.2">It handles all the transactions, telling participating services when to complete an operation based on feedback it receives during the saga. </span><span class="koboSpan" id="kobo.140.3">The orchestrator executes the request, tracks and interprets the request’s state after each task, and handles the remediating operations, as necessary.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.141.1">Figure 8.3</span></em><span class="koboSpan" id="kobo.142.1"> shows the orchestrator flow:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.143.1"><img alt="Figure 8.3 – An application request sends a message to the orchestrator, which begins to coordinate and monitor the subsequent calls to the participating services" src="image/Figure_8.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.144.1">Figure 8.3 – An application request sends a message to the orchestrator, which begins to coordinate and monitor the subsequent calls to the participating services</span></p>
<p><span class="koboSpan" id="kobo.145.1">Let us revisit our appointment </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.146.1">booking operation from the perspective of the orchestration saga implementation:</span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.147.1">The user submits a registration and appointment booking request (client request).</span></li>
<li><span class="koboSpan" id="kobo.148.1">The client request is passed to the </span><em class="italic"><span class="koboSpan" id="kobo.149.1">orchestrator</span></em><span class="koboSpan" id="kobo.150.1"> service.</span></li>
<li><span class="koboSpan" id="kobo.151.1">The </span><em class="italic"><span class="koboSpan" id="kobo.152.1">orchestrator</span></em><span class="koboSpan" id="kobo.153.1"> service centrally stores the data from the client request. </span><span class="koboSpan" id="kobo.153.2">This data will be used during the </span><em class="italic"><span class="koboSpan" id="kobo.154.1">User Registration</span></em><span class="koboSpan" id="kobo.155.1"> saga.</span></li>
<li><span class="koboSpan" id="kobo.156.1">The </span><em class="italic"><span class="koboSpan" id="kobo.157.1">orchestrator</span></em><span class="koboSpan" id="kobo.158.1"> service begins the saga by passing the user’s information to the </span><em class="italic"><span class="koboSpan" id="kobo.159.1">registration</span></em><span class="koboSpan" id="kobo.160.1"> service, which will add a new record to its database and respond with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">201Created</span></strong><span class="koboSpan" id="kobo.162.1"> HTTP response. </span><span class="koboSpan" id="kobo.162.2">The </span><em class="italic"><span class="koboSpan" id="kobo.163.1">orchestrator</span></em><span class="koboSpan" id="kobo.164.1"> will store the user’s ID, as it will be needed during the saga.</span></li>
<li><span class="koboSpan" id="kobo.165.1">The </span><em class="italic"><span class="koboSpan" id="kobo.166.1">orchestrator</span></em><span class="koboSpan" id="kobo.167.1"> then sends the user’s payment information to the </span><em class="italic"><span class="koboSpan" id="kobo.168.1">payment</span></em><span class="koboSpan" id="kobo.169.1"> service, which will respond with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">200OK</span></strong><span class="koboSpan" id="kobo.171.1"> HTTP response. </span><span class="koboSpan" id="kobo.171.2">The </span><em class="italic"><span class="koboSpan" id="kobo.172.1">orchestrator</span></em><span class="koboSpan" id="kobo.173.1"> will store the payment response details, in the event that a rollback is needed and the payment should be canceled.</span></li>
<li><span class="koboSpan" id="kobo.174.1">The </span><em class="italic"><span class="koboSpan" id="kobo.175.1">orchestrator</span></em><span class="koboSpan" id="kobo.176.1"> then sends a request to the </span><em class="italic"><span class="koboSpan" id="kobo.177.1">appointment booking</span></em><span class="koboSpan" id="kobo.178.1"> service, which processes the appointment booking accordingly and responds with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">201Created</span></strong><span class="koboSpan" id="kobo.180.1"> HTTP response.</span></li>
<li><span class="koboSpan" id="kobo.181.1">The </span><em class="italic"><span class="koboSpan" id="kobo.182.1">orchestrator</span></em><span class="koboSpan" id="kobo.183.1"> will finally trigger the </span><em class="italic"><span class="koboSpan" id="kobo.184.1">document upload</span></em><span class="koboSpan" id="kobo.185.1"> service, which uploads</span><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.186.1"> the documents and adds records to the document service database.</span></li>
<li><span class="koboSpan" id="kobo.187.1">The </span><em class="italic"><span class="koboSpan" id="kobo.188.1">orchestrator</span></em><span class="koboSpan" id="kobo.189.1"> then confirms that the saga has ended and will update the state of the operation. </span><span class="koboSpan" id="kobo.189.2">It</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.190.1"> will then respond to the client with the overall result.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.191.1">We can see that the orchestrator is at the helm of every step of the operation and remains informed of each service’s outcome. </span><span class="koboSpan" id="kobo.191.2">It acts as the main authority on whether we should move to the next step or not. </span><span class="koboSpan" id="kobo.191.3">We can also see that a more </span><em class="italic"><span class="koboSpan" id="kobo.192.1">synchronous service communication</span></em><span class="koboSpan" id="kobo.193.1"> model is implemented in this saga pattern.</span></p>
<p><span class="koboSpan" id="kobo.194.1">Let us review what a rollback operation might look like.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.195.1">Rolling back on failure</span></h2>
<p><span class="koboSpan" id="kobo.196.1">Rolling back is the most important</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.197.1"> part of implementing a saga, and like the choreography pattern, we are governed by the business rules of the operation and induvial service operations. </span><span class="koboSpan" id="kobo.197.2">The main takeaway here is that the services will respond with failure to a central point, which will then coordinate the rollback operations across the various services. </span><span class="koboSpan" id="kobo.197.3">Reusing the failure scenario previously discussed, our orchestration would look something like this:</span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.198.1">The </span><em class="italic"><span class="koboSpan" id="kobo.199.1">appointment booking</span></em><span class="koboSpan" id="kobo.200.1"> service sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">400BadRequest</span></strong><span class="koboSpan" id="kobo.202.1"> HTTP response to the </span><em class="italic"><span class="koboSpan" id="kobo.203.1">orchestrator</span></em><span class="koboSpan" id="kobo.204.1">.</span></li>
<li><span class="koboSpan" id="kobo.205.1">The </span><em class="italic"><span class="koboSpan" id="kobo.206.1">orchestrator</span></em><span class="koboSpan" id="kobo.207.1"> proceeds to call the </span><em class="italic"><span class="koboSpan" id="kobo.208.1">payment</span></em><span class="koboSpan" id="kobo.209.1"> service to cancel the payment. </span><span class="koboSpan" id="kobo.209.2">It already stored the relevant information about the payment during the saga.</span></li>
<li><span class="koboSpan" id="kobo.210.1">The </span><em class="italic"><span class="koboSpan" id="kobo.211.1">orchestrator</span></em><span class="koboSpan" id="kobo.212.1"> will trigger additional clean-up operations such as flagging the user’s registration record as incomplete, as well as purging any additional data that may have been stored at the beginning of the operation.</span></li>
<li><span class="koboSpan" id="kobo.213.1">The </span><em class="italic"><span class="koboSpan" id="kobo.214.1">orchestrator</span></em><span class="koboSpan" id="kobo.215.1"> will </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.216.1">notify the client of the operation’s failure.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.217.1">A rollback here is arguably easier to implement – not because we are changing how and what the services do, but because we can be sure of the order in which the remediations will happen in case the order is important, and we can accomplish that without introducing too much more complexity to the flow.</span></p>
<p><span class="koboSpan" id="kobo.218.1">Let us discuss the benefits of using this pattern in more detail.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.219.1">Pros and cons</span></h2>
<p><span class="koboSpan" id="kobo.220.1">One obvious</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.221.1"> advantage to using this implementation of the saga pattern is the level of control that we can be sure to implement. </span><span class="koboSpan" id="kobo.221.2">We can orchestrate our service calls and receive real-time feedback, which can be used to decide and have a set path along the saga that we can track and monitor. </span><span class="koboSpan" id="kobo.221.3">This makes it easier to implement complex workflows and extend the number of participants over time.</span></p>
<p><span class="koboSpan" id="kobo.222.1">This implementation is excellent for us if we need to control the exact flow of saga activities and be sure that we do not have services being triggered simultaneously and from information that they may think is relevant. </span><span class="koboSpan" id="kobo.222.2">Services only act when called upon, and misconfigurations are less likely. </span><span class="koboSpan" id="kobo.222.3">Services do not need to directly depend on each other for communication and are more autonomous, leading to simpler business logic. </span><span class="koboSpan" id="kobo.222.4">Troubleshooting also becomes easier since we can track what the singular code base is doing and more easily identify the point of failure.</span></p>
<p><span class="koboSpan" id="kobo.223.1">Despite all these</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.224.1"> proposed benefits of orchestration, we need to remember that we are simply creating a central point of synchronous service calls. </span><span class="koboSpan" id="kobo.224.2">This can become a choke point along the saga if one of the services runs more slowly than desired. </span><span class="koboSpan" id="kobo.224.3">This can be managed, of course, through properly implemented </span><em class="italic"><span class="koboSpan" id="kobo.225.1">retry</span></em><span class="koboSpan" id="kobo.226.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.227.1">circuit breaker</span></em><span class="koboSpan" id="kobo.228.1"> logic, but it remains a risk worthy of consideration.</span></p>
<p><span class="koboSpan" id="kobo.229.1">We also run into a situation where we end up with yet another microservice to develop and maintain. </span><span class="koboSpan" id="kobo.229.2">We will introduce a new and more central point of failure since no other microservice gets called into action if the orchestrator is out of operation.</span></p>
<p><span class="koboSpan" id="kobo.230.1">Let us review what we have learned in this chapter.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.231.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.232.1">Until now, we have seen several patterns surrounding microservices architecture and development. </span><span class="koboSpan" id="kobo.232.2">Each pattern’s purpose is to reduce the attrition that comes with this kind of architecture.</span></p>
<p><span class="koboSpan" id="kobo.233.1">We saw a potential pain point and point of concern with our </span><em class="italic"><span class="koboSpan" id="kobo.234.1">database-per-service</span></em><span class="koboSpan" id="kobo.235.1"> pattern implementation and the difficulty that comes from having disparate data stores. </span><span class="koboSpan" id="kobo.235.2">We cannot always guarantee that all services will be successful in an operation and as such, we cannot guarantee that the data stores will reflect the same thing.</span></p>
<p><span class="koboSpan" id="kobo.236.1">To address this, we look to the saga pattern, which can either be leveraged through an event-based </span><em class="italic"><span class="koboSpan" id="kobo.237.1">choreography</span></em><span class="koboSpan" id="kobo.238.1"> implementation or a more centralized </span><em class="italic"><span class="koboSpan" id="kobo.239.1">orchestration</span></em><span class="koboSpan" id="kobo.240.1"> method. </span><span class="koboSpan" id="kobo.240.2">We have reviewed the pros, cons, and considerations surrounding either implementation and how they help us to more effectively help microservices maintain data consistency.</span></p>
<p><span class="koboSpan" id="kobo.241.1">In the next chapter, we will review the potential flaws involved in communication between microservices, and review how we can implement more fault-tolerant communication between services using the </span><em class="italic"><span class="koboSpan" id="kobo.242.1">circuit breaker pattern</span></em><span class="koboSpan" id="kobo.243.1">.</span></p>
</div>


<div class="Content" id="_idContainer039">
<h1 id="_idParaDest-132"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.1.1">Part 3: Resiliency, Security, and Infrastructure Patterns</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Reliability is one of the most critical aspects of API design. </span><span class="koboSpan" id="kobo.2.2">This part discusses the technique surrounding robust API design, security, and hosting. </span><span class="koboSpan" id="kobo.2.3">By the end of this part, you should be able to design advanced and secure APIs that can communicate with a lower failure rate and be hosted efficiently. </span></p>
<p><span class="koboSpan" id="kobo.3.1">This part has the following chapters:</span></p>
<ul>
<li><a href="B19100_09.xhtml#_idTextAnchor140"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Building Resilient Microservices</span></em></li>
<li><a href="B19100_10.xhtml#_idTextAnchor156"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Performing Health Checks on Your Services</span></em></li>
<li><a href="B19100_11.xhtml#_idTextAnchor168"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Implementing the API and BFF Gateway Patterns</span></em></li>
<li><a href="B19100_12.xhtml#_idTextAnchor184"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.14.1">, </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Securing Microservices with Bearer Tokens</span></em></li>
<li><a href="B19100_13.xhtml#_idTextAnchor202"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.17.1">, </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Microservice Container Hosting </span></em></li>
<li><a href="B19100_14.xhtml#_idTextAnchor219"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Implementing Centralized Logging for Microservices</span></em></li>
<li><a href="B19100_15.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.22.1">Chapter 15</span></em></a><span class="koboSpan" id="kobo.23.1">, </span><em class="italic"><span class="koboSpan" id="kobo.24.1">Wrapping It All Up</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer040">
</div>
</div>
</body></html>