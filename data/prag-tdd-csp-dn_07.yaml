- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: A Pragmatic View of Domain-Driven Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种对领域驱动设计的实用观点
- en: '**Domain-driven design** (**DDD**) is a set of software design principles that
    are widely used in modern enterprise applications. They were bundled and made
    popular in 2003 by Eric Evans in his book *Domain-Driven Design*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）是一组在现代企业应用程序中广泛使用的软件设计原则。它们在 2003 年由 Eric Evans 在其著作 *领域驱动设计*
    中捆绑并推广。'
- en: You might be wondering how this is related to **test-driven development** (**TDD**).
    Is it because it is a similar-sounding acronym? The reality is that TDD and DDD
    work together where TDD covers the design from the client’s perspective and the
    quality, while DDD complements the rest of the design. You will hear the two terms
    used together in a conversation and in job specifications, and the reason for
    this will be clear by the end of *Part 2*, *Building an Application with TDD*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道这与**测试驱动开发**（**TDD**）有什么关系。是因为它们有相似的缩写吗？现实是 TDD 和 DDD 在一起工作，其中 TDD 从客户端的角度覆盖设计和质量，而
    DDD 补充了其余的设计。您将在对话和职位说明中听到这两个术语一起使用，到 *第二部分*，*使用 TDD 构建应用* 的结束时，原因将变得清晰。
- en: This chapter is meant to be a primer on DDD, so you will have the foundation
    required to build a complete application using a combination of TDD and DDD.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在作为 DDD 的入门指南，因此您将获得构建一个完整应用所需的基础，该应用结合了 TDD 和 DDD。
- en: DDD is a technical and a philosophical topic. Given the pragmatism of this book
    and the length of this chapter, our focus will be limited to the pragmatic aspect
    of DDD related to the application we are implementing in the following chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 是一个技术和哲学话题。鉴于本书的实用主义和本章的长度，我们的重点将限于与我们在以下章节中实施的应用相关的 DDD 的实用方面。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with a sample application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例应用进行工作
- en: Exploring domains
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索领域
- en: Exploring services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索服务
- en: Exploring repositories
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索存储库
- en: Putting everything together
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合一切
- en: By the end of the chapter, you will understand the basic DDD terminology and
    be able to explain it to a colleague.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解基本的 DDD 术语，并能够向同事解释它。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07)'
- en: Working with a sample application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例应用进行工作
- en: 'We need a sample application to demonstrate DDD concepts. The word *application*
    can have various meanings in your project. It can be one of the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个示例应用来展示 DDD 概念。在您的项目中，“应用”这个词可能有多种含义。它可以是以下之一：
- en: A **single microservice** that is part of a larger application
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**单一微服务**，它是更大应用的一部分
- en: A **monolith application** that is a standalone application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**单体应用**，它是一个独立的应用
- en: This chapter will use a monolith application, as it is easier to explain the
    concept and the context will be clearer. So, we’ll focus on the specifics of DDD
    rather than diverging into a more complex architecture.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用单体应用，因为它更容易解释概念，并且上下文将更清晰。因此，我们将专注于 DDD 的具体细节，而不是深入更复杂的架构。
- en: 'Let’s take a blog application as an example. A DDD-style blog application might
    look like this in Microsoft **Visual Studio** (**VS**):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个博客应用为例。一个 DDD 风格的博客应用在 Microsoft **Visual Studio**（**VS**）中可能看起来像这样：
- en: '![Figure 7.1 – A blog application in VS ](img/Figure_7.1_B18370.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – VS 中的博客应用](img/Figure_7.1_B18370.jpg)'
- en: Figure 7.1 – A blog application in VS
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – VS 中的博客应用
- en: '**UQS** is our fictitious company’s initials, standing for **Unicorn Quality
    Solutions**. These projects have the following dependencies on each other:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**UQS** 是我们虚构公司的缩写，代表 **Unicorn Quality Solutions**。这些项目之间有以下依赖关系：'
- en: '![Figure 7.2 – Project dependencies ](img/Figure_7.2_B18370.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 项目依赖关系](img/Figure_7.2_B18370.jpg)'
- en: Figure 7.2 – Project dependencies
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 项目依赖关系
- en: 'Nothing special here: this is a set of regular project dependencies. Let’s
    dig into each project role.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的：这是一组常规的项目依赖关系。让我们深入了解每个项目角色。
- en: The application project
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用项目
- en: Our solution communicates with the outside world, the clients, and the `Uqs.Blog.WebApi`
    project. This solution is using a RESTful Web API to communicate with the UI layer.
    This should make it easy for a browser-based UI layer, such as **React**, **Angular**,
    **Vue**, or **Blazor**, to exchange the data (in the form of contracts).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目与外界、客户端以及`Uqs.Blog.WebApi`项目进行通信。这个解决方案正在使用RESTful Web API与UI层通信。这应该使得基于浏览器的UI层，如**React**、**Angular**、**Vue**或**Blazor**，交换数据（以合同的形式）变得容易。
- en: Also, it can act as a standalone API project that can be referred to as a *headless*
    blog, which is a fancy term to say that this is only a backend platform without
    a UI. Multiple UIs can interact with it, so it is not coupled to one UI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还可以作为一个独立的API项目，可以被称为*无头*博客，这是一个术语，意思是这只是一个没有UI的后端平台。多个UI可以与之交互，因此它不耦合于一个UI。
- en: This could be a standard ASP.NET Core Web API, similar to what we’ve used in
    the previous chapters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个标准的ASP.NET Core Web API，类似于我们在前面的章节中使用过的。
- en: In [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding Dependency
    Injection by Example*, and [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066), *Getting
    Started with Unit Testing*, you’ve seen examples of `WeatherForecastingController`.
    In DDD terms, the controller was acting as an **application service**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18370_02.xhtml#_idTextAnchor037) *通过示例理解依赖注入* 和 [*第3章*](B18370_03.xhtml#_idTextAnchor066)
    *开始单元测试* 中，你已经看到了`WeatherForecastingController`的示例。在DDD术语中，控制器充当了**应用服务**的角色。
- en: The contract objects project
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合同对象项目
- en: To communicate with the outside world, your data should have a defined structure.
    This defined structure comprises classes, and it is in the `Uqs.Blog.Contract`
    project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要与外界通信，您的数据应该有一个定义的结构。这个定义的结构包括类，它位于`Uqs.Blog.Contract`项目中。
- en: If this is a UI project, these contracts might be called **view models**, as
    they are models that are *bound* to the UI (the view) directly. Also, they might
    be called **data transportation objects** (**DTOs**) as they transport the data
    from the server to the clients. In API projects, they are usually referred to
    as **contracts**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个UI项目，这些合同可能被称为**视图模型**，因为它们是直接绑定到UI（视图）的模型。它们也可能被称为**数据传输对象**（**DTOs**），因为它们将数据从服务器传输到客户端。在API项目中，它们通常被称为**合同**。
- en: 'Put simply, if the RESTful APIs have an API that requests the full information
    of a post, with the following URL:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果RESTful API有一个请求帖子完整信息的API，其URL如下：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then the contract might look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，合同可能看起来像这样：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is usually transferred in JSON. This is an example of the preceding C#
    contract being serialized as JSON:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常以JSON的形式传输。这是前面C#合同序列化为JSON的示例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Contracts are not part of the DDD philosophy, but they are needed here to have
    a complete application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 合同不属于DDD哲学的一部分，但在这里需要它们来构建一个完整的应用程序。
- en: The domain layer project
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域层项目
- en: The components of this layer are in `Uqs.Blog.Domain`. This is where all the
    types related to the domain design live.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层的组件位于`Uqs.Blog.Domain`中。这是所有与领域设计相关的类型所在的地方。
- en: Important Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Dividing layers, naming projects, and arranging them based on layers is a highly
    opinionated process. There is no widespread industry standard of the best approach.
    So, consider my approach here as *an example* rather than *the way* to do it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 分层、命名项目和根据层来安排它们是一个高度主观的过程。没有广泛认可的行业标准来定义最佳方法。因此，请将我这里的方法视为*一个例子*，而不是*做事的方式*。
- en: 'This layer contains the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层包含以下内容：
- en: Business logic
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业逻辑
- en: Database persistence
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库持久化
- en: 'Our project resembles a similar design to this one:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目与这个类似的设计：
- en: '![Figure 7.3 – A design diagram for the application ](img/Figure_7.3_B18370.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 应用程序的设计图](img/Figure_7.3_B18370.jpg)'
- en: Figure 7.3 – A design diagram for the application
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 应用程序的设计图
- en: This diagram represents our application; however, it’s worth noting that DDD
    is concerned with the backend, not the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表示我们的应用程序；然而，值得注意的是，DDD关注的是后端，而不是客户端。
- en: Next, we will go through the constituents of DDD and we will start with the
    domain.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨DDD的组成部分，并从领域开始。
- en: Exploring domains
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索领域
- en: DDD is a collection of software design philosophies and best practices. There
    are a handful of books dedicated to DDD, and most of them are above 500 pages.
    So, we can talk a lot about DDD, but this book isn’t about DDD, so we will be
    brief.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是一系列软件开发哲学和最佳实践。有几本书是专门关于DDD的，而且大多数都超过500页。因此，我们可以大谈DDD，但本书不是关于DDD的，所以我们将简要介绍。
- en: DDD focuses on business logic and the interaction with the DB and the outside
    world and employs a set of practices for a robust software design. The word *domain*
    in DDD refers to a *business domain*, which can be car insurance, accounting,
    billing, banking, e-commerce, and others. DDD emphasizes the business domain,
    as per the term *domain-driven*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: DDD专注于业务逻辑以及与数据库和外部世界的交互，并采用一系列实践来确保软件设计的健壮性。DDD中的*领域*一词指的是*业务领域*，可以是汽车保险、会计、账单、银行、电子商务等。DDD强调业务领域，正如术语*领域驱动*所表示的。
- en: Next, we will explore the architectural components that make the practical aspect
    of DDD.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨构成DDD实际方面的架构组件。
- en: Domain objects
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域对象
- en: 'A **domain object** is a representation of a real-life business entity. Exploring
    our blog project, the domain objects can be like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域对象**是现实生活商业实体的表示。在探索我们的博客项目时，领域对象可能如下所示：'
- en: '![Figure 7.4 – The classes and structs contributing to a blog domain ](img/Figure_7.4_B18370.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 贡献于博客领域的类和结构](img/Figure_7.4_B18370.jpg)'
- en: Figure 7.4 – The classes and structs contributing to a blog domain
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 贡献于博客领域的类和结构
- en: You can see how the names of these types and the properties reflect the blog
    business. These entities generally map directly to relational database tables,
    so you have database tables for posts, authors, tags, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些类型和属性的名称如何反映博客业务。这些实体通常直接映射到关系数据库表，因此你有帖子、作者、标签等数据库表。
- en: In a document database, the domain objects may or may not be the ones persisted
    directly into your collection.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档数据库中，领域对象可能直接持久化到您的集合中，也可能不是。
- en: Important Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: DDD doesn’t state that domain objects should be mapped to a relational DB table,
    but in practice, this is what happens as it is more practical to do it in this
    way, especially with the use of **object-relational mappers** (**ORMs**) such
    as **Hibernate** (**Java**) and **Entity Framework** (**.NET**).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: DDD没有规定领域对象应该映射到关系数据库表，但在实践中，这是实际的做法，尤其是在使用**对象关系映射器**（**ORMs**）如**Hibernate**（**Java**）和**Entity
    Framework**（**.NET**）的情况下。
- en: You will often find words such as *models*, *business objects*, and *domain
    objects* used interchangeably to mean the same thing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现诸如*模型*、*业务对象*和*领域对象*等词语被互换使用，意思相同。
- en: 'Not all domain objects are created equal. DDD differentiates between two types
    of domain objects: entities and value objects.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有领域对象都是平等的。DDD区分两种类型的领域对象：实体和值对象。
- en: Entities and value objects
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体和值对象
- en: DDD distinguishes between objects that have their own identity, which are called
    `Id` property, but it stands for the plain English meaning of *identity*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: DDD区分具有自身身份的对象，这些对象被称为`Id`属性，但它代表的是*身份*的普通英语含义。
- en: Value objects
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值对象
- en: '**Value objects** represent typed values that have no conceptual identity.
    The most commonly used example of a value object is money. A £5 note (bill) doesn’t
    have an identity and if it is replaced by another £5 note, then nothing has changed.
    In other words, if two persons swapped £5 notes, then they have the same value,
    and we don’t have to worry about or track the notes.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**值对象**代表没有概念身份的已类型化值。最常见的值对象例子是货币。£5纸币（钞票）没有身份，如果它被另一张£5纸币所替换，那么什么都没有改变。换句话说，如果两个人交换了£5纸币，那么他们具有相同的值，我们不必担心或追踪这些纸币。'
- en: Important Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A £5 note is a value object unless the serial number of the note is important.
    This might be the case if this is part of a money-issuing project for the Bank
    of England. But in most cases, this is a value object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: £5纸币是一个值对象，除非纸币的序列号很重要。这可能是在英格兰银行发行货币项目的一部分。但在大多数情况下，这是一个值对象。
- en: 'There are plenty of examples of what can be a value object. Here are a few:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多例子可以说明什么是值对象。以下是一些例子：
- en: Dates
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: First names, as the first name on its own doesn’t make an identity
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字，因为单独的名字本身并不构成身份
- en: Addresses
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: Value objects are modeled in `Tag` struct.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象在`Tag`结构体中建模。
- en: Blog tags such as .NET, DDD, and TDD don’t require an ID. But for database storage,
    having an identifier might be more practical as it allows better management of
    tags.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 博客标签，如 .NET、DDD 和 TDD，不需要 ID。但为了数据库存储，有一个标识符可能更实用，因为它允许更好地管理标签。
- en: Important Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: From a pure DDD approach, a tag should be a property in `Post`, not a standalone
    business object. However, what if there is a misspelling, and you wanted to fix
    it? What if you wanted to show the user a list of existing tags for autocomplete?
    Having it as an independent domain object and storing it in a standalone table
    or a container might lead to better performance and management.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯 DDD 方法来看，一个标签应该是 `Post` 中的一个属性，而不是一个独立的企业对象。然而，如果出现拼写错误，你想修正它怎么办？如果你想向用户显示一个现有标签列表以实现自动完成，将其作为一个独立的领域对象并存储在单独的表或容器中可能会带来更好的性能和管理。
- en: In practice, .NET developers rarely use structures unless they are building
    something low-level, such as performance optimization, and interacting with unmanaged
    resources. Usually, value objects are modeled with classes, which is not very
    DDD-compliant.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，.NET 开发者很少使用结构体，除非他们正在构建一些底层的东西，例如性能优化，以及与未管理资源交互。通常，值对象是用类建模的，这并不非常符合
    DDD。
- en: Entities
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体
- en: An object primarily defined by its identity is called an **entity**. It is a
    type of domain model that needs to be tracked over time and whose attributes are
    likely to change over time. A perfect example of this would be a person entity,
    which has a changeable email and home address but a fixed identity, which is the
    person herself/himself.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 主要由其身份定义的对象称为 **实体**。它是一种需要随时间跟踪的领域模型，其属性可能随时间而变化。一个完美的例子就是人员实体，它有一个可变的电子邮件和家庭地址，但有一个固定的身份，即本人。
- en: In our preceding blog example, `Post`, `Author`, `Comment`, and `Commenter`
    are entities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的博客示例中，`Post`、`Author`、`Comment` 和 `Commenter` 都是实体。
- en: '`Comment` is peculiar as some can argue that it is a value type! But what if
    it is editable? Then, its identity becomes important.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comment` 是一个特殊的情况，因为有人可能会认为它是一个值类型！但如果它是可编辑的，那么它的身份就变得很重要。'
- en: Entities are represented as classes and records, and they definitely have an
    **identifier** (**ID**).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实体以类和记录的形式表示，并且它们肯定有一个 **标识符**（**ID**）。
- en: Entity versus value objects
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体与值对象
- en: 'When designing your domain, it is important to understand the differences so
    that you pick the right design. Here are the major distinguishing aspects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计你的领域时，理解这些差异非常重要，这样你才能选择正确的设计。以下是主要的区分方面：
- en: '**Lifespan**: Entities live in a continuum while value objects are created
    and destroyed with ease.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期**：实体存在于连续体中，而值对象可以轻松创建和销毁。'
- en: '**Immutability**: An object is said to be immutable if its value cannot change
    after creation. Entities are mutable while value objects are immutable.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：如果一个对象在创建后其值不能改变，则称该对象为不可变。实体是可变的，而值对象是不可变的。'
- en: '**Identifier**: Entity objects require an identifier while value objects don’t.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**：实体对象需要一个标识符，而值对象不需要。'
- en: '**Classes or structs**: Entities use classes and adhere to the .NET reference
    type principles (stored in heap, passed by reference, and so on) while value types
    are structs (at least as DDD recommends), which adhere to the .NET value type
    principles (stored in stack, passed by value, and so on).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类或结构体**：实体使用类并遵循 .NET 引用类型原则（存储在堆中，通过引用传递等），而值类型是结构体（至少 DDD 推荐如此），它们遵循 .NET
    值类型原则（存储在栈中，通过值传递等）。'
- en: To summarize, when we design our domain objects, they can be done as entities
    or value objects depending on whether they represent an identity.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当我们设计我们的领域对象时，它们可以是实体或值对象，这取决于它们是否代表一个身份。
- en: Aggregates
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: '**Aggregates** are a group of classes that form one business aim. The previous
    blog classes set a distinguished business objective, which is managing a blog
    post. These classes form an aggregate.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合**是一组形成单一业务目标的类。之前的博客类设置了一个显著的业务目标，即管理博客文章。这些类形成一个聚合。'
- en: Important Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The *aggregation* term that is used in **object-oriented programming** (**OOP**)
    and the **Unified Modeling Language** (**UML**) is not the same concept as the
    DDD aggregate.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **面向对象编程**（**OOP**）和 **统一建模语言**（**UML**）中使用的 *聚合* 术语与 DDD 聚合的概念并不相同。
- en: An `Post` domain object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Post` 领域对象。
- en: Anemic models
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贫血模型
- en: 'When we studied OOP, we learned that an object handles its own data and its
    behavior. So, if we have a class called `Person`, there might be a read-only property
    called `Email` in that class. Also, to set the email address, you will have a
    method that might be creatively called `void ChangeEmail(string email)`, which
    does some business logic and validations before setting the email. Our class,
    according to DDD, would look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习面向对象编程时，我们了解到对象处理自己的数据和自己的行为。因此，如果我们有一个名为`Person`的类，那么在这个类中可能有一个只读属性`Email`。此外，要设置电子邮件地址，你可能会有一个可能被称为`void
    ChangeEmail(string email)`的方法，该方法在设置电子邮件之前执行一些业务逻辑和验证。根据DDD，我们的类将看起来像这样：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class stores its own data. For example, the `Email` property is storing
    the email value and there is a behavior, which is represented by the `ChangeEmail`
    method, which is changing the stored `Email`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类存储了自己的数据。例如，`Email`属性存储电子邮件值，并且有一个行为，由`ChangeEmail`方法表示，该方法是更改存储的`Email`。
- en: 'An `Person` class earlier to an anemic version:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的一个`Person`类到贫血版本的例子：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now the email has a setter, but how are validation and other business logic
    implemented if it is not within the class itself? The answer is that another class
    would be responsible, such as the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在电子邮件有了设置器，但如果它不在类内部，如何实现验证和其他业务逻辑？答案是，另一个类将负责，如下所示：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this scenario, another class, `PersonService`, handles the behavior of the
    `Person` class, and the more the behavior of `Person` is outsourced to other classes,
    the more the `Person` class is anemic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，另一个类`PersonService`处理`Person`类的行为，`Person`类的行为越外包给其他类，`Person`类就越贫血。
- en: In an anemic model, the client interprets the purpose and use of the domain
    object, and the business logic ends up being implemented in other classes, similar
    to the preceding example. An anemic model is considered an *anti-pattern*, as
    it opposes the theories of OOP.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在贫血模型中，客户端解释领域对象的目的和使用，而业务逻辑最终在其他类中实现，类似于前面的例子。贫血模型被认为是一种**反模式**，因为它与面向对象编程的理论相悖。
- en: However, the *anti-pattern* of using anemic models in domain objects is very
    common between developers, as the practice of setting ORMs such as **Entity Framework**
    (**EF**) and other practicalities does clash with DDD best practices.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在领域对象中使用贫血模型的**反模式**在开发者之间非常普遍，因为设置ORM（如**Entity Framework**（EF））和其他实际操作与DDD最佳实践相冲突。
- en: The rest of the book is taking the anemic model approach, as it is the dominant
    one in the market. It is more pragmatic and works well with ORMs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余部分采用贫血模型方法，因为它在市场上占主导地位。它更实用，并且与ORM（对象关系映射）配合良好。
- en: Ubiquitous language
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普遍语言
- en: The word *ubiquitous*, pronounced as *yu-bikwitus*, means, according to the
    Cambridge Dictionary, *seeming to be everywhere*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 词语**普遍存在**（ubiquitous），发音为**yu-bikwitus**，根据剑桥词典的定义，意味着**无处不在**。
- en: 'From a DDD perspective, it means using well-known terminology in naming your
    domain objects similar to what the business people are using. In other words,
    do not invent your own terminology and follow the existing language: the business
    language.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从DDD的角度来看，这意味着在命名领域对象时使用众所周知的术语，类似于业务人员所使用的术语。换句话说，不要发明自己的术语，而是遵循现有的语言：业务语言。
- en: 'This approach has a couple of clear advantages:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个明显的优点：
- en: Smoother conversation between the business stakeholders and the developers
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务利益相关者和开发者之间的对话更加流畅
- en: New developers get on with the business logic and the code rapidly
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的开发者可以快速处理业务逻辑和代码。
- en: I did use this in the blog example, where I used the terminology that is used
    in blogging. The same concept applies to projects of a larger size.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我在博客示例中确实使用了这种方法，其中我使用了博客中使用的术语。同样的概念也适用于更大规模的项目。
- en: By now, you have a general idea about domain objects and aggregates in DDD.
    In the next section, we will dig into a major DDD topic, which we will use extensively
    in *Part 2*, *Building an Application with TDD*, of this book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你对DDD中的领域对象和聚合体已经有了大致的了解。在下一节中，我们将深入探讨一个主要的DDD主题，我们将在本书的**第2部分**，即**使用TDD构建应用程序**中广泛使用这个主题。
- en: Exploring services
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索服务
- en: '**Services** in DDD are divided into three types, but we will focus on the
    **domain services** for now, and then we will discuss the other two later: **infrastructure
    services** and **application services**.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**在领域驱动设计（DDD）中分为三种类型，但我们将目前专注于**领域服务**，稍后我们将讨论其他两种：**基础设施服务**和**应用服务**。'
- en: 'A domain service is the unit within the DDD ecosystem where the business logic
    lives. A domain service has the following responsibilities:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 域服务是 DDD 生态系统中包含业务逻辑的单元。域服务有以下职责：
- en: Loading domain objects through the help of repositories
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仓库的帮助加载域对象
- en: Applying business logic
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用业务逻辑
- en: Persisting the domain objects with the help of repositories
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仓库的帮助下持久化域对象
- en: It is important to understand that the domain services are unaware of how the
    data is loaded from the storage medium and how it is stored. They only know how
    to request a data-loading or persistence operation through the help of data repositories.
    Repositories will be covered later in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 理解域服务不知道数据是如何从存储介质加载的以及如何存储的非常重要。它们只知道如何通过数据仓库请求数据加载或持久化操作。仓库将在本章后面介绍。
- en: Let’s add some services for our blog project to help us with publishing posts,
    and retrieving and updating them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的博客项目添加一些服务，以帮助我们发布帖子、检索和更新它们。
- en: Post management
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帖子管理
- en: If you have ever published a blog post or an online article, you will be familiar
    with this process. If you open a text editor to write a blog post, you will have
    to fill in the title, the content, and other fields, but you can also save without
    completing everything. It is okay to save without filling the required fields
    as you are still editing, but when you want to publish, everything should be completed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经发布过博客文章或在线文章，你将熟悉这个过程。如果你打开文本编辑器来撰写博客文章，你必须填写标题、内容和其他字段，但你也可以在不完成所有内容的情况下保存。在编辑时，不填写必填字段是可以的，但当你想要发布时，一切都应该完成。
- en: Let’s start implementing the domain services required to manage a post.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现管理帖子所需的域服务。
- en: Adding post service
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加帖子服务
- en: 'Adding a new post will require the author’s ID but no other field. The code
    for this service can look as such:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新帖子将需要作者的 ID 但不需要其他字段。此服务的代码可以看起来像这样：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, you’ll notice that I have dedicated a whole class, `AddPostService`,
    with a single method, `AddPost`. Some designs create a single service class such
    as `PostService` and add multiple business logic methods inside it. I opted for
    the single public method in a single class approach to respect the single-responsibility
    principle of **SOLID**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到我专门创建了一个包含单个方法 `AddPost` 的类 `AddPostService`。一些设计创建了一个单一的 `PostService`
    服务类，并在其中添加了多个业务逻辑方法。我选择了在单个类中只有一个公共方法的方法，以尊重 **SOLID** 的单一职责原则。
- en: 'I have injected into the class two repositories that are needed for the business
    logic: the `author` and `post` repositories. For a reminder of DI, have a look
    at [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding Dependency
    Injection by Example*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将两个仓库注入到类中，这些仓库对于业务逻辑是必需的：`author` 和 `post` 仓库。关于依赖注入的提醒，请参阅 [*第 2 章*](B18370_02.xhtml#_idTextAnchor037)，*通过示例理解依赖注入*。
- en: I implemented a business logic that checks whether a non-existent author is
    passed to the method. Also, if the author is locked from publishing, then I created
    a post and got back the created ID. I could have used `Guid` but the UI would
    want an integer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我实现了一个业务逻辑，用于检查是否将不存在的作者传递给方法。如果作者被锁定以发布，则创建一个帖子并返回创建的 ID。我本可以使用 `Guid`，但 UI
    会想要一个整数。
- en: The notable thing here is that the service did not know how `Author` was loaded.
    It might have been loaded from a relational DB, a document DB, an in-memory DB,
    or even a text file! The service delegated this knowledge to the repository.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是，服务并不知道如何加载 `Author`。它可能来自关系型数据库、文档数据库、内存数据库，甚至是一个文本文件！服务将这种知识委托给了仓库。
- en: The service here focused on a single responsibility, which is the business logic
    for adding a new post. This is an example of the separation of concerns.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的服务专注于单一职责，即添加新帖子的业务逻辑。这是一个关注点分离的例子。
- en: Updating title service
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新标题服务
- en: 'The title of the blog can be up to 90 characters and can be updated at any
    time. This is sample code to achieve this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 博客的标题可以长达 90 个字符，并且可以随时更新。以下是一个实现此功能的示例代码：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding logic is straightforward. What is new here is the way the service
    loaded the entity, then modified one of its properties, and then asked the repository
    to manage the update operation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述逻辑很简单。这里的新颖之处在于服务加载实体、修改其属性之一，然后请求仓库管理更新操作的方式。
- en: In both services, the business logic involved no knowledge of the data platform.
    This can be SQL Server, Cosmos DB, MongoDB, and so on. DDD refers to the libraries
    for these tools as *infrastructure*, so the services have no knowledge of the
    infrastructure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个服务中，涉及的业务逻辑对数据平台没有任何了解。这可能包括 SQL Server、Cosmos DB、MongoDB 等等。DDD 将这些工具的库称为
    *基础设施*，因此服务对基础设施没有任何了解。
- en: Application services
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序服务
- en: Earlier, we were describing the domain services. Application services provide
    the interaction with the outside world or the glue that allows a client to request
    something from your system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们描述了领域服务。应用程序服务提供与外部世界的交互或粘合剂，允许客户端从你的系统中请求某些内容。
- en: A perfect example of an application service is an **ASP.NET** controller, where
    a controller can use domain services to provide a response to a **RESTful** request.
    Application services will typically use both domain services and repositories
    to deal with external requests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务的完美例子是一个 **ASP.NET** 控制器，其中控制器可以使用领域服务来响应 **RESTful** 请求。应用程序服务通常使用领域服务和仓库来处理外部请求。
- en: Infrastructure services
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施服务
- en: These are used to abstract technical concerns (cloud storage, service bus, email
    provider, and so on).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于抽象技术问题（云存储、服务总线、电子邮件提供者等等）。
- en: We will be using services extensively in *Part 2*, *Building an Application
    with TDD*, of this book. So, I hope you got an idea of what they are. Later on,
    we will have an end-to-end project that will involve multiple services.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的 *第2部分*，*使用TDD构建应用程序* 中广泛使用服务。所以我希望你对它们有了概念。稍后，我们将有一个涉及多个服务的端到端项目。
- en: Service characteristics
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务特征
- en: There are guidelines on how to build a service in DDD. We will go through a
    few of them here. However, I recommend going through the *Further reading* section
    at the end of this chapter if you would like to know more.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何在 DDD 中构建服务有一些指导原则。我们在这里将讨论其中的一些。然而，如果你想了解更多，我建议阅读本章末尾的 *进一步阅读* 部分。
- en: We will discuss stateless services, ubiquitous language, and using domain objects
    instead of services.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论无状态服务、通用语言以及使用领域对象而不是服务。
- en: Stateless
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无状态
- en: A service should not hold a state. Holding a state is akin to remembering data,
    which means, in plain English, persisting some business data in the fields or
    properties of a service class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 服务不应该持有状态。持有状态类似于记住数据，也就是说，用简单的话说，在服务类的字段或属性中持久化一些业务数据。
- en: Avoid maintaining a state in your service as it will complicate your architecture,
    and if you think that you need a state, then this is what repositories are for.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在服务中维护状态，因为这会复杂化你的架构，如果你认为你需要状态，那么这就是仓库的作用所在。
- en: Use ubiquitous language
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通用语言
- en: As always, use ubiquitous language. In the previous examples, we named the services
    and the methods following the business operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，使用通用语言。在之前的例子中，我们按照业务操作命名服务和方法。
- en: Use domain objects where relevant
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在相关的地方使用领域对象
- en: DDD is against anemic models, so it encourages the user to check whether a domain
    model can do the operation rather than having this done in a service.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 反对贫血模型，因此它鼓励用户检查领域模型是否可以执行操作，而不是在服务中执行此操作。
- en: 'In our example, DDD would have encouraged us to have behavior (public methods)
    in `Post`. If we were to follow the DDD advice, our `Post` class would have looked
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，DDD 会鼓励我们在 `Post` 中有行为（公共方法）。如果我们遵循 DDD 的建议，我们的 `Post` 类将看起来像这样：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the setters for the properties are now private as only the methods
    within the class can set the properties. The second note is that the `UpdateTitle`
    method doesn’t need to get `Id` as a parameter as it has access to `Id` from within
    the class. It only requires the new title.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性的设置器现在是私有的，因为只有类内的方法可以设置属性。第二个要注意的是，`UpdateTitle` 方法不需要获取 `Id` 作为参数，因为它可以从类内部访问
    `Id`。它只需要新的标题。
- en: The advantage of this is that your class is not anemic and follows OOP principles.
    Obviously, we have not followed the DDD recommendation in our implementation and
    wrote the `UpdateTitle` method in the service class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的好处是，你的类不是贫血的，并且遵循 OOP 原则。显然，我们没有遵循 DDD 的建议，在服务类中编写了 `UpdateTitle` 方法。
- en: 'I did not do this to upset DDD practitioners, but for practical purposes! Let
    me list the potential problems that you may encounter in this approach while using
    EF, the main .NET ORM:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做不是为了惹恼 DDD 实践者，而是出于实用目的！让我列出在使用 EF（主要的 .NET ORM）时，采用这种方法可能遇到的一些潜在问题。
- en: '`Post` class at runtime. This is not a common practice, and I am not even sure
    whether this is possible with non-hacky code.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，`Post` 类。这不是一个常见的做法，我甚至不确定这是否可能通过非黑客代码实现。
- en: '`Post` from the database, it will be unable to set the properties, which renders
    EF useless.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中获取 `Post`，它将无法设置属性，这使得 EF 无用。
- en: '**Distribution of business logic**: If the domain classes contain business
    logic, sometimes your business logic will be in services and sometimes it will
    be in domain objects rather than one or the other. In other words, it will be
    distributed in multiple classes.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑的分布**：如果领域类包含业务逻辑，有时你的业务逻辑会在服务中，有时会在领域对象中，而不是在两者之一中。换句话说，它将在多个类中分布。'
- en: There are ways to make this work, but they aren’t worth the effort. Here, practicality
    doesn't meet the DDD theory, and this is why I opted to have anemic domain objects.
    The takeaway is that you know what DDD is advocating and the reason for that and
    you know why we are shifting from this practice.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以使这行得通，但它们不值得付出努力。在这里，实用性不符合 DDD 理论，这就是我选择使用贫血领域对象的原因。得到的启示是，你知道 DDD 是什么，为什么会有这样的倡导，以及为什么我们要从这种做法转变。
- en: Services do not care how data is loaded and persisted because it is the responsibility
    of the repositories, which naturally leads us to the next topic.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 服务不关心数据是如何加载和持久化的，因为这由仓储负责，这自然引出了下一个话题。
- en: Exploring repositories
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索仓储
- en: '**Repositories** are classes that belong to infrastructure. They understand
    the underlying storage platform and interact with the specifics of the data store
    system.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**仓储**是属于基础设施的类。它们理解底层存储平台并与数据存储系统的具体细节交互。'
- en: They should not contain business logic, and they should only be concerned with
    loading and saving data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不应该包含业务逻辑，而应该只关注加载数据和保存数据。
- en: Repositories are a way of achieving a single responsibility (as in SOLID’s single
    responsibility principle) by having the services and the domains responsible for
    business logic but not responsible for data persistence. DDD gives the data persistence
    responsibility to the repositories.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储是一种通过让服务和领域负责业务逻辑但不负责数据持久性来实现单一责任（如 SOLID 的单一责任原则）的方法。DDD 将数据持久性责任赋予仓储。
- en: An example of a repository
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓储的一个例子
- en: 'You’ve seen this line of code previously in the `UpdateTitleService` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前在 `UpdateTitleService` 类中见过这一行代码：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we will show you a potential implementation of `GetById`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将向你展示 `GetById` 的一个潜在实现。
- en: Using Dapper with SQL Server
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Dapper 与 SQL Server
- en: '**Dapper** is a .NET library categorized under the term *micro-ORM*. It is
    very popular and used in **StackOverflow**.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dapper** 是一个被归类为 *微 ORM* 的 .NET 库。它非常受欢迎，并在 **StackOverflow** 上使用。'
- en: Dapper can be used to access a SQL Server DB, so assuming our blog DB is a SQL
    Server one, we will use Dapper to implement `GetById` of `PostRepository`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper 可以用来访问 SQL Server 数据库，所以假设我们的博客数据库是 SQL Server 类型，我们将使用 Dapper 实现 `PostRepository`
    的 `GetById`。
- en: 'To use `Dapper` in any project, you can install it via `System.Data.SqlClient`
    NuGet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要在任何项目中使用 `Dapper`，您可以通过 `System.Data.SqlClient` NuGet 进行安装：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually, the repository classes have an interface counterpart to allow them
    to be injected into services. Notice that in our previous `PostService`, we have
    injected `IPostRepository`. The code shows how a repository works but it is not
    DI-compliant, however, it will be in the next section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仓储类有一个接口对应物，以便它们可以被注入到服务中。注意，在我们的上一个 `PostService` 中，我们已经注入了 `IPostRepository`。代码展示了仓储的工作方式，但它不符合
    DI 规范，然而，在下一节中将会。
- en: The `SqlConnection` class is an **ADO.NET** class, which allows you to manage
    a connection with a SQL Server DB.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlConnection` 类是一个 **ADO.NET** 类，它允许你管理与 SQL Server 数据库的连接。'
- en: '`Query()` is an extension method provided by Dapper. It allows you to issue
    a regular **T-SQL** query and map the results to an object.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query()` 是 Dapper 提供的一个扩展方法。它允许你发出一个常规的 **T-SQL** 查询并将结果映射到对象。'
- en: Using Dapper with SQL Server and DI
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Dapper 与 SQL Server 和 DI
- en: 'As you’ve noticed, we have not injected `SqlConnection` and we have directly
    instantiated it in the code. Obviously, this is not the best practice! Here is
    an implementation that utilizes injecting the connection object:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们没有注入 `SqlConnection`，而是直接在代码中实例化了它。显然，这不是最佳实践！以下是一个利用注入连接对象的实现：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`SqlConnection` implements `IDbConnection` and we can wire this in the DI section
    in our startup to inject the right object at runtime (*not shown here, as this
    is a fictitious sample*). The DI will take care of instantiating the connection
    object, so we don’t have to do it here.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlConnection` 实现 `IDbConnection`，我们可以在启动时的 DI 部分将其连接起来，以在运行时注入正确的对象（*此处未显示，因为这只是一个虚构的示例*）。DI
    将负责实例化连接对象，所以我们在这里不需要做。'
- en: The `GetById` method uses Dapper’s ADO.NET extension methods to map the query
    results to a C# object. There are cleaner ways to achieve this, but I opted for
    the most readable one for this example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetById` 方法使用 Dapper 的 ADO.NET 扩展方法将查询结果映射到 C# 对象。有更干净的方法可以实现这一点，但在这个例子中，我选择了最易读的一种。'
- en: Using other DBs
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他数据库
- en: In the previous example, we have used a SQL Server DB; however, any other database
    would do. The only implementation that is going to change is within the `PostRepository`
    class. The consumers of `IPostRepository` will not change.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了 SQL Server 数据库；然而，任何其他数据库都可以。唯一会改变的是 `PostRepository` 类内部的实现。`IPostRepository`
    的消费者不会改变。
- en: In the following chapters, we will demonstrate end-to-end implementations that
    use SQL Server (with EF) and Cosmos DB.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将演示使用 SQL Server（与 EF）和 Cosmos DB 的端到端实现。
- en: EF and repositories
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EF 和仓储
- en: '**EF** is .NET’s major ORM. An *ORM* is a term to say it loads your relational
    DB records into objects.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**EF** 是 .NET 的主要 ORM。*ORM* 是一个术语，表示它将关系型数据库记录加载到对象中。'
- en: EF provides a high level of abstraction that embodies multiple DDD patterns,
    most notably the repositories. When using EF, the repository pattern disappears
    in favor of EF and the code design becomes simpler.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: EF 提供了高级抽象，体现了多个 DDD 模式，最显著的是仓储模式。当使用 EF 时，仓储模式消失，取而代之的是 EF，代码设计变得更简单。
- en: In this chapter, it is enough to know this. In [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226),
    *Building an Appointment Booking App with Entity Framework and Relational DB*,
    we will have a complete implementation that includes EF with a fully working source
    code, which will clarify how things are done from end to end.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，了解这一点就足够了。在 [*第 9 章*](B18370_09.xhtml#_idTextAnchor226)，“使用 Entity Framework
    和关系型数据库构建预约应用”，我们将有一个完整的实现，包括 EF 和一个完全工作的源代码，这将阐明从端到端是如何完成的。
- en: Putting everything together
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: This is my favorite part. I have been providing little snippets here and there
    and, hopefully, now you can see the big picture of how everything is linked from
    a DDD point of view. I have included the snippets in the source code directory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我最喜欢的一部分。我一直在这里那里提供一些小片段，希望现在你能看到从 DDD 视角看一切是如何相互关联的。我已经将这些片段包含在源代码目录中。
- en: Solution Explorer view
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案资源管理器视图
- en: 'What we’ve done in this project is a collection of snippets. Let’s have a look
    at them:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们所做的是一系列片段的集合。让我们看看它们：
- en: '![Figure 7.5 – VS solution files from a DDD perspective ](img/Figure_7.5_B18370.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 从 DDD 视角看 VS 解决方案文件](img/Figure_7.5_B18370.jpg)'
- en: Figure 7.5 – VS solution files from a DDD perspective
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 从 DDD 视角看 VS 解决方案文件
- en: 'Let’s have a recap of every item:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下每个项目：
- en: '**Contracts**: This is what the outside world sees. These contracts represent
    the shape of the data that will be exchanged between the backend and the client.
    The client should know the data elements of the contract, so it knows what to
    expect from your headless blog.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**契约**：这是外部世界看到的内容。这些契约代表了将在后端和客户端之间交换的数据的形状。客户端应该知道契约的数据元素，以便知道从你的无头博客中可以期待什么。'
- en: '**Entities**: They are the domain objects with identities.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实体**：它们是有身份的领域对象。'
- en: '**Value Objects**: They are the domain objects that don’t require an identity.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**值对象**：它们是不需要身份的领域对象。'
- en: '**Domain Objects**: This is the group of entities and value objects in your
    system.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**领域对象**：这是系统中实体和值对象的集合。'
- en: '**Repositories**: These are the classes that will save and load your data from
    a data store (relational DB, document DB, file system, blog storage, and so on).'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**仓储**：这些是保存和加载数据到数据存储（关系型数据库、文档数据库、文件系统、博客存储等）的类。'
- en: '**Domain Services**: This is where the business logic will live, and it will
    interact with the repositories for CRUD operations. These services are not exposed
    to the outside world.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**领域服务**：这是业务逻辑将驻留的地方，它将与存储库进行 CRUD 操作的交互。这些服务不会暴露给外界。'
- en: '`REST` request. Application services are exposed to the outside world.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`REST` 请求。应用服务暴露给外界。'
- en: It also happened that we only have a single aggregate, which is all our domain
    objects. A domain might have more than one aggregate. We also have `Post` as our
    aggregate root.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的是，我们只有一个聚合，那就是我们所有的领域对象。一个领域可能包含多个聚合。我们还有 `Post` 作为我们的聚合根。
- en: Architectural view
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构视图
- en: 'We’ve seen a potential project and file structure for our DDD project and now,
    let’s have a look at it from a software design point of view:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们 DDD 项目的潜在项目和文件结构，现在，让我们从软件设计的角度来审视它：
- en: '![Figure 7.6 – A simplified software design view of DDD ](img/Figure_7.6_B18370.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – DDD 的简化软件设计视图](img/Figure_7.6_B18370.jpg)'
- en: Figure 7.6 – A simplified software design view of DDD
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – DDD 的简化软件设计视图
- en: 'Let’s discuss this DDD-style system:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这个 DDD 风格的系统：
- en: '**Application Services**: They interact with the clients and the domain services.
    They deliver the data to a client based on the contract and they deal with domain
    services directly.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**：它们与客户端和领域服务交互。根据合同，它们将数据传递给客户端，并直接处理领域服务。'
- en: '**Domain Services**: They provide services to **Application Services**.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域服务**：它们为 **应用服务** 提供服务。'
- en: '**Infrastructure Services**: They provide services that are not part of the
    domain, such as fetching the ZIP code/postcode city.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施服务**：它们提供不属于领域的服务，例如获取 ZIP 码/邮编城市。'
- en: '**Aggregate**: Each aggregate contains several domain objects and has one aggregate
    root.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：每个聚合包含多个领域对象，并有一个聚合根。'
- en: '**Domain Objects**: They are all the entities and value objects in all aggregates.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域对象**：它们是所有聚合中的所有实体和值对象。'
- en: I hope I was able to show you the foundation of the DDD design from the coding
    and projects structure and from an architectural view as well, although risking
    repeating the concepts twice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我能够从编码和项目结构以及从架构的角度展示 DDD 设计的基础，尽管冒着重复概念两次的风险。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are topics in DDD that I have omitted, as they don’t contribute directly
    to the rest of the book, such as bounded contexts, domain events, units of work,
    and others. I have provided additional resources in the *Further reading* section
    that will help you to explore the concepts further.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DDD 中有一些我没有涉及的主题，因为它们没有直接贡献于本书的其余部分，例如边界上下文、领域事件、工作单元等。我在 *进一步阅读* 部分提供了额外的资源，帮助你进一步探索这些概念。
- en: We have discussed the basics of DDD and I am expecting this chapter to make
    you familiar with this concept, so we can use the terms such as *domain objects*,
    *domain services*, and *repositories* freely in later chapters without you raising
    an eyebrow. We have also seen sample code of the different constituents of DDD.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 DDD 的基础知识，并期待这一章能让你熟悉这个概念，这样我们就可以在后续章节中自由使用诸如 *领域对象*、*领域服务* 和 *存储库*
    等术语，而无需你皱眉。我们还看到了 DDD 不同组成部分的示例代码。
- en: We have also seen where we will shift from DDD guidelines where it is more practical
    to do so and explained why.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了在什么情况下我们可以从 DDD 指南中做出调整，使其更加实用，并解释了原因。
- en: In the next chapter, we will set a foundation for a complete project that will
    utilize all that you’ve learned so far, including DDD.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为利用你迄今为止所学的一切知识（包括 DDD）的完整项目打下基础。
- en: Further reading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following resources:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，你可以参考以下资源：
- en: '*Domain-Driven Design* by Eric Evans, Addison-Wesley (2003)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《领域驱动设计》*，作者：Eric Evans，Addison-Wesley（2003）'
- en: '*Implementing Domain-Driven Design* by Vaughn Vernon, Addison-Wesley (2013)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《实现领域驱动设计》*，作者：Vaughn Vernon，Addison-Wesley（2013）'
- en: '*Hands-On Domain-Driven Design with .NET Core* by Alexey Zimarev, Packt Publishing
    (2019)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《.NET Core 实战领域驱动设计》*，作者：Alexey Zimarev，Packt Publishing（2019）'
- en: '*Design a DDD-oriented microservice*: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计面向 DDD 的微服务*: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice)'
- en: '*Martin Fowler on DDD*: [https://martinfowler.com/bliki/DomainDrivenDesign.xhtml](https://martinfowler.com/bliki/DomainDrivenDesign.xhtml)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*马丁·福勒关于 DDD*: [https://martinfowler.com/bliki/DomainDrivenDesign.xhtml](https://martinfowler.com/bliki/DomainDrivenDesign.xhtml)'
- en: '*Quickstart: Build a console app by using the .NET V4 SDK to manage Azure Cosmos
    DB SQL API account resources*: [https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4](https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速入门：使用 .NET V4 SDK 构建 console 应用程序以管理 Azure Cosmos DB SQL API 资源*: [https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4](https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4)'
- en: '*Dapper on GitHub*: [https://github.com/DapperLib/Dapper](https://github.com/DapperLib/Dapper)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitHub 上的 Dapper*: [https://github.com/DapperLib/Dapper](https://github.com/DapperLib/Dapper)'
