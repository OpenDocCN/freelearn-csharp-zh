- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI/CD for ASP.NET Core Using Azure Pipelines and GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have explored the fundamentals of building, testing,
    and running ASP.NET Core applications. We have also discussed how to access data
    from a database using `dotnet run` command to run our applications locally. Now,
    it is time to take the next step in our ASP.NET Core journey and learn how to
    deploy our applications to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the concept of **continuous integration and
    continuous delivery/deployment** (**CI/CD**). This chapter will focus on two popular
    CI/CD tools and platforms: Azure Pipelines and GitHub Actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerizing ASP.NET Core applications using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI/CD using Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon completion of this chapter, you will have a basic understanding of containerization
    concepts and the ability to build and deploy your ASP.NET Core applications to
    the cloud using either of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers work on code every day – they may create new features, fix bugs,
    or refactor existing code. In a team environment, multiple developers may be working
    on the same code base. A developer may create a new feature, while another developer
    may be fixing a bug. The code base is constantly changing, and it is important
    to ensure that the code changes made by different developers do not conflict with
    each other and do not break any existing functionalities. To avoid such issues,
    developers should integrate their code changes frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when the application is ready to be deployed, it is important
    to consider the different environments it may be deployed to, such as development,
    staging, or production. Different environments may have different configurations,
    and the deployment process may be different for each environment. To ensure that
    the application is deployed correctly and consistently, it is ideal to automate
    the deployment process. This is where CI/CD comes in.
  prefs: []
  type: TYPE_NORMAL
- en: The acronym *CI/CD* can have different interpretations depending on the context.
    **CI**, a development practice that allows developers to integrate code changes
    regularly. **CD** can refer to either **continuous delivery** or **continuous
    deployment**, which are often used interchangeably. It is not worth debating the
    exact definitions of these terms, as in most cases, *CD* means building, testing,
    and deploying the applications to the production environment (and, potentially,
    other environments) frequently and automatically.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD pipelines are key components of **DevOps**, a combination of the words
    **development** and **operations**. DevOps has evolved over the years and is generally
    defined as a set of practices, tools, and processes that enable continuous delivery
    of value to end users. While DevOps is a vast topic, this chapter will focus on
    CI/CD pipelines specifically.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical CI/CD process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – A typical CI/CD process](img/B18971_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – A typical CI/CD process
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in *Figure 14**.1* are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer creates a new feature or fixes a bug in the code base and then
    commits the changes to the shared code repository. If the team is using Git as
    its **version control system** (**VCS**), the developer will create a pull request
    to submit the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pull request will initiates the CI pipeline, which will build the application
    and execute tests. If the build or tests fail, the developer will be notified,
    allowing them to address the issue promptly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the build and tests are successful and the pull request is approved by the
    team, the code changes will be merged into the `main` branch. This ensures that
    the code is up to date and aligns with the team’s standards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The merge will trigger the CI pipeline to build the application and publish
    the artifacts (for example, binaries, configuration files, Docker images, and
    so on) to the artifact repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CD pipeline can be triggered manually or automatically. The CD pipeline
    then deploys the application to the target environment (for example, development,
    staging, or production environment).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI/CD process can be more complex than what is shown in *Figure 14**.1*.
    For example, the CI pipeline may require static code analysis, code test coverage,
    and other quality checks. The CD pipeline may need to apply different configurations
    for different environments or have different deployment strategies, such as blue/green
    deployment or canary deployment. With the increasing complexity of CI/CD pipelines,
    DevOps engineers are in high demand as they possess the skills to implement these
    pipelines using the various tools and platforms available.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into the details of CI/CD, let us first introduce some concepts
    and terminologies that are commonly used in CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD concepts and terminologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is essential to understand key concepts and terminologies commonly used
    in CI/CD. The following are some of the most common terms used in CI/CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipeline**: A pipeline is an automated process used to build, test, and deploy
    applications. They can be triggered manually or automatically and can even be
    set up to be triggered by other pipelines. This helps streamline the development
    process, ensuring that applications are built, tested, and deployed quickly and
    efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: A build is a process that involves compiling the source code and
    creating the necessary binaries or Docker images. This ensures that the code is
    ready for deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: A pipeline may include automated tests, such as unit tests, integration
    tests, performance tests, or **end-to-end** (**E2E**) tests. These tests can be
    incorporated into the pipeline to ensure that the code changes do not break any
    existing functionalities. This helps to ensure that the software remains stable
    and reliable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artifact**: An artifact is a file or collection of files – normally, the
    output of a build process. Examples of artifacts include binary files, a Docker
    image, or a ZIP file containing the binary files. These artifacts can then be
    used as inputs for the deployment process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerization**: Containerization is a method of packaging an application
    and its dependencies into a container image, which can be deployed and run in
    a consistent environment, regardless of the host operating system. One of the
    most popular containerization tools is Docker. Containerization offers numerous
    benefits, such as improved scalability, portability, and resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VCS**: VCSs are an essential tool for software development, allowing developers
    to track and manage changes to source code. Git is one of the most widely used
    VCSs, providing developers with an effective way to manage their code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: Deployment is the process of deploying the application to the
    target environment. It involves configuring the application to meet the requirements
    of the environment, as well as ensuring that it is secure and ready for use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` branch can trigger the CI pipeline to build and publish artifacts. The
    successful CI pipeline can trigger the CD pipeline to deploy the application to
    non-production environments. However, the CD pipeline may need to be triggered
    manually to deploy the application to the production environment as a safety measure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining an understanding of the fundamental concepts and terminologies associated
    with CI/CD is essential for successful implementation. As many different tools
    and platforms can be used to implement CI/CD pipelines, we will discuss the details
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of CI/CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI/CD plays an important role in DevOps. It helps the team respond to changes
    and deliver value to end users frequently, safely, and reliably. As CI/CD pipelines
    are automated, they can streamline the process of delivering software and reduce
    the time and effort needed to deploy applications to the production environment.
    Additionally, CI/CD helps maintain a stable and reliable code base.
  prefs: []
  type: TYPE_NORMAL
- en: In order to successfully implement a CI/CD pipeline, the team must adhere to
    certain practices. Automated tests should be conducted to ensure that code changes
    do not break any existing functionalities. Additionally, a well-defined deployment
    strategy should be established, such as staging the application in a development
    environment before deploying it to the production environment. By following these
    practices, the team can reduce **time to market** (**TTM**) and deliver the application
    to end users faster and more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'CI/CD practices help development teams in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster feedback**: CI/CD pipelines can be triggered automatically when code
    changes are committed to the shared code repository. This provides developers
    with faster feedback on code changes, allowing them to address any issues early
    in the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced manual effort and risk**: CI/CD pipelines automate the deployment
    process, reducing manual effort and risk. This decreases the time and effort needed
    for production deployment, eliminating manual and error-prone processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Automated builds and deployments ensure consistency across
    different environments. This reduces the risk of deployment failures due to configuration
    issues or *it works on my* *machine* problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced quality**: Automated tests can be integrated into CI/CD pipelines,
    which helps to ensure that the code base remains stable and reliable. CI/CD pipelines
    can also run other quality checks, such as static code analysis and code test
    coverage, which leads to higher-quality code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rapid delivery and agility**: CI/CD pipelines enable the team to release
    new features and bug fixes to end users faster and more frequently. This allows
    businesses to respond quickly to customer needs and market changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these benefits in mind, it is clear that CI/CD is a must-have for any development
    team. No one would want to go back to the days of manual builds and deployments
    anymore, as it is time-consuming and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned some concepts of CI/CD and why it is important. In the next
    section, we will discuss how to containerize ASP.NET Core applications using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing ASP.NET Core applications using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many years ago, when we deployed applications to the production environment,
    we needed to ensure that the target environment had the correct version of the
    .NET Framework installed. Developers were struggling with the *it works on my
    machine* problem, as development environments may have had different configurations
    than the production environment, including software versions, operating systems,
    and hardware. This often led to deployment failures due to configuration issues.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of .NET Core, a cross-platform and open-source framework, has
    enabled us to deploy our applications on any platform, including Windows, Linux,
    and macOS. However, for successful deployment, we still need to ensure that the
    target environment has the correct runtime installed. This is where containerization
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: What is containerization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers are lightweight, isolated, and portable environments that contain
    all the necessary dependencies for running an application. Unlike **virtual machines**
    (**VMs**), they do not require a separate guest operating system as they share
    the host operating system kernel. This makes them more lightweight and portable
    than VMs, as they can run on any platform that supports the container runtime.
    Containers also provide isolation, ensuring that applications are not affected
    by changes in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization is a powerful tool that enables us to package our applications
    and their dependencies into a single container image. **Docker** is one of the
    most popular containerization solutions, offering support for Windows, Linux,
    and macOS for development purposes, as well as many variants of Linux, such as
    Ubuntu, Debian, and CentOS, for production environments. Additionally, Docker
    is compatible with cloud platforms, including Azure, **Amazon Web Services** (**AWS**),
    and **Google Cloud Platform** (**GCP**). If we use Docker as the container runtime,
    then the container images are called **Docker images**.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images are a convenient way to package an application and its dependencies.
    They contain all the components necessary to run an application, such as the application
    code (binaries), runtime or SDK, system tools, and configurations. Docker images
    are immutable, meaning they cannot be changed once they are created. To store
    these images, they are placed in a registry, such as Docker Hub, **Azure Container
    Registry** (**ACR**), or AWS **Elastic Container Registry** (**ECR**). Docker
    Hub is a public registry that offers many pre-built images. Alternatively, a private
    registry can be created to store custom Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Once a Docker image has been created, it can be used to create a Docker container.
    A Docker container is an isolated, in-memory instance of a Docker image, with
    its own filesystem, network, and memory. This makes creating a container much
    faster than booting up a VM and also allows for fast destruction and rebuilding
    of a container from the same image. In addition, multiple containers can be created
    from the same image, which is useful for scaling out applications. If any container
    fails, it can be destroyed and rebuilt from the same image in a matter of seconds,
    making containerization a powerful tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files in a Docker image are stackable. *Figure 14**.2* shows an example
    of a container filesystem that contains an ASP.NET Core app and its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Docker container file system](img/B18971_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Docker container file system
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.2* illustrates the layers of a Docker container. On top of the
    kernel layer is the base image layer, which is an empty container image created
    from Ubuntu. On top of the base image layer is the ASP.NET Core runtime layer,
    then the ASP.NET Core app layer. When a container is created, Docker adds a final
    writeable layer on top of the other layers. This writeable layer can be used to
    store temporary files, such as logs. However, as we mentioned earlier, Docker
    images are immutable, so any changes made to the writeable layer will be lost
    when the container is destroyed. This is why we should not store any persistent
    data in a container. Instead, we should store the data in a volume, which is a
    directory on the host machine that is mounted into the container.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simplified explanation of Docker images and containers. Next,
    let us install Docker and create a Docker image for our ASP.NET Core application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can download Docker Desktop from the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac: [https://docs.docker.com/desktop/install/mac-install/](https://docs.docker.com/desktop/install/mac-install/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: [https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please follow the official documentation to install Docker on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: If you use Windows, please use the **Windows Subsystem for Linux 2** (**WSL
    2**) backend instead of Hyper-V. WSL 2 is a compatibility layer that allows Linux
    binary executables to be run natively on Windows. Using WSL 2 as the backend for
    Docker Desktop on Windows provides better performance than the Hyper-V backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install WSL 2 on Windows, please follow the instructions at this link: [https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install).
    By default, WSL 2 uses the Ubuntu distribution. You can also install other Linux
    distributions, such as Debian, CentOS, or Fedora.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing WSL 2, you can check the version of WSL by running the following
    command in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the `VERSION` field shows `2`, that means WSL 2 is installed correctly.
    Then, you can install Docker Desktop and choose WSL 2 as the backend. If you have
    multiple Linux distributions installed, you can choose the default distribution
    to use with Docker Desktop. Go to **Settings** | **Resources** | **WSL integration**,
    and choose the distribution you want to use with Docker Desktop, as shown in *Figure
    14**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Choosing the default Linux distribution to use with Docker
    Desktop](img/B18971_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Choosing the default Linux distribution to use with Docker Desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the example output of the `wsl -l -v` command, which shows two Linux
    distros installed on this machine; the default distro is `Ubuntu-22.04`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Desktop installs two internal Linux distros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-desktop`: This is used to run the Docker engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-desktop-data`: This is used to store containers and images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that Docker may consume a lot of resources on your machine. If you feel
    that Docker slows down your machine or consumes too many resources, you can configure
    the resources allocated to WSL 2 following the instructions in this link: [https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig](https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig).'
  prefs: []
  type: TYPE_NORMAL
- en: After installing Docker Desktop, we can now create a Docker image for our ASP.NET
    Core application. In the next section, we will discuss some commands that are
    commonly used in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Dockerfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how to build and run Docker images, we will need a sample ASP.NET
    Core application. You can create a new ASP.NET Core web API project using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can clone the sample code from the `/samples/chapter14/MyBasicWebApiDemo`
    folder in the book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker images can be built using a Dockerfile, a text file containing a list
    of instructions used to build the image. You can create a Dockerfile in the root
    directory of the ASP.NET Core project manually, or you can use VS 2022 to create
    it for you. To create a Dockerfile using VS 2022, right-click on the project in
    Solution Explorer, then select **Add** | **Docker Support**. You will see the
    following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Adding Docker support to an ASP.NET Core project in VS 2022](img/B18971_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Adding Docker support to an ASP.NET Core project in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options here: **Linux** and **Windows**. It is recommended to
    use Linux for development purposes, as the Linux image is smaller than the Windows
    image. Docker was originally designed for Linux, so it is more mature on Linux
    than on Windows. Many cloud platforms, such as Azure, AWS, and GCP, support Linux
    containers. However, not all Windows servers support Windows containers. Unless
    you have strong reasons to host your application on a Windows server, you should
    choose **Linux** here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have selected the `Dockerfile` without any file extension. This allows
    us to build the Docker image using the `docker build` command without needing
    to specify the Dockerfile name. The default Dockerfile created by VS 2022 will
    resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us go through the Dockerfile line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `FROM` instruction specifies the base image to use. The `FROM` instruction
    must be the first instruction in a Dockerfile. In this case, we are using the
    `mcr.microsoft.com/dotnet/aspnet:8.0` image, which is the ASP.NET Core runtime
    image. This image is provided by Microsoft. `mcr.microsoft.com` is the domain
    name of the `AS base` means we are giving this image a name, which is `base`.
    This name can be used later in the Dockerfile to refer to this image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, the `USER` instruction specifies the username or `app` user is created
    by the base image. This user is not a superuser, so it is more secure than the
    root user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WORKDIR` instruction sets the working directory inside of the container
    for these instructions: `RUN`, `CMD`, `COPY`, `ADD`, `ENTRYPOINT`, and so on.
    This instruction is similar to the `cd` command in the terminal. It supports both
    absolute and relative paths. If the directory does not exist, it will be created.
    In this example, the working directory is set to `/app`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `EXPOSE` instruction exposes the specified port(s) to the container when
    it is running. Note that this instruction does not actually publish the port to
    the host machine. It just means the container will listen on the specified port(s).
    By default, the `EXPOSE` instruction exposes the port(s) on the TCP protocol.
    In this case, the container will listen on ports `8080` and `8081`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines, we are using a different image, which is the `mcr.microsoft.com/dotnet/sdk:8.0`
    image, and naming it `build`. This image contains the .NET SDK, which is used
    to build the application. The `ARG` instruction defines a variable that can be
    used later in the Dockerfile. In this case, we are defining a variable called
    `BUILD_CONFIGURATION` and setting its default value to `Release`. The `WORKDIR`
    instruction sets the working directory to `/src`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `COPY` instruction copies files or directories from the source (on the local
    machine) to the destination (the filesystem of the container). In this case, we
    are copying the `.csproj` file to the current directory. The `RUN` instruction
    executes the specified command on top of the current image and creates a new layer,
    then commits the results. The new layer will be used for the next step in the
    Dockerfile. In this case, we are running the `dotnet restore` command to restore
    the NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines, we are copying all the files from the local machine
    to the current directory in the container. Then, we are setting the working directory
    to `/src`. Finally, we are running the `dotnet build` command to build the application.
    Note that we are using the `BUILD_CONFIGURATION` variable defined earlier in the
    Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `FROM` instruction uses the `build` image we defined earlier and
    names it `publish`. Then, the `RUN` instruction runs the `dotnet publish` command
    to publish the application. The `$BUILD_CONFIGURATION` variable is used again.
    The published application will be placed in the `/``app/publish` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we rename the `base` image as `final` and set the working directory to
    `/app`. To run the application, we only need the runtime, so we do not need the
    SDK image. Then, the `COPY` instruction copies the published application from
    the `app/publish` directory of the `publish` image to the current directory. Finally,
    the `ENTRYPOINT` instruction specifies the command to run when the container starts.
    In this case, we are running the `dotnet BasicWebApiDemo.dll` command to start
    the ASP.NET Core application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about Dockerfile instructions in the official
    documentation provided by Docker: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
    Next, let us move on to building a Docker image.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker provides a set of commands that can be used to build, run, and manage
    Docker images and containers. To build a Docker image, go to the root directory
    of the ASP.NET Core project we created earlier, then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `-t` option is used to tag the image with a name. `.` at the end means the
    current directory. Docker expects to find a file named `Dockerfile` in the current
    directory. If you have renamed the Dockerfile or the Dockerfile is not located
    in the current directory, you can use the `-f` option to specify the Dockerfile
    name, such as `docker build -t basicwebapidemo -f` `MyBasicWebApiDemo/MyDockerfile
    MyBasicWebApiDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that Docker is building the image layer by layer. Each instruction
    in the Dockerfile will create a layer in the image and add more content on top
    of the previous layer. The layers are cached, so if a layer has not changed, it
    will not be rebuilt for the next build. But if a layer has changed (for example,
    if we update the source code), then the layer that copies the source code will
    be rebuilt, and all the layers after that will be affected and need to be rebuilt
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us review the default Dockerfile generated by VS 2022\. Why does it
    copy all the files after running the `dotnet restore` command? It is because if
    we only update the source code but the NuGet packages have not changed, then the
    `dotnet restore` command will not be executed again as the layer is cached. This
    can improve the build performance. However, if we update the NuGet packages, meaning
    the `.csproj` file has changed, then the `dotnet restore` command will be executed
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips for writing Dockerfiles:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the order of layers. Layers that are less likely to change should be
    placed before layers that are more likely to change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep layers small as much as possible. Do not copy unnecessary files. You can
    configure the `.dockerignore` file to exclude files or directories from the build
    context. If you use VS 2022 to create the Dockerfile, it will generate a `.dockerignore`
    file for you. Alternatively, you can manually create a text file named `.dockerignore`
    and then edit it. Here is a sample `.``dockerignore` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For more information about the `.dockerignore` file, please refer to the official
    documentation here: [https://docs.docker.com/engine/reference/builder/#dockerignore-file](https://docs.docker.com/engine/reference/builder/#dockerignore-file).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Keep as few layers as possible. For example, to host an ASP.NET Core application,
    we can reduce the number of layers by using the `mcr.microsoft.com/dotnet/aspnet`
    image. This image contains the ASP.NET Core runtime already, eliminating the need
    to install the SDK in the container. You can also combine commands into a single
    `RUN` instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use multi-stage builds. Multi-stage builds allow us to use multiple `FROM`
    instructions in a Dockerfile. Each `FROM` instruction can be used to create a
    new image. The final image will only contain the layers from the last `FROM` instruction.
    This can reduce the size of the final image. For example, we can use the `mcr.microsoft.com/dotnet/sdk`
    image to build the application and then use the `mcr.microsoft.com/dotnet/aspnet`
    image to run the application. This way, the final image will only contain the
    ASP.NET Core runtime, and it will not contain the SDK, which is not needed for
    running the application. To learn more about multi-stage builds, please refer
    to the official documentation here: [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on optimizing Docker builds, please refer to the official
    documentation here: [https://docs.docker.com/build/cache/](https://docs.docker.com/build/cache/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use the following command to list all Docker images on our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `basicwebapidemo` image is the one we just built. Each image has a `TAG`
    value and an `IMAGE ID` value. The `TAG` value is a human-readable name for the
    image. By default, the tag is `latest`. We can specify a different tag when building
    the image. For example, we can use the following command to build the image with
    the `v1` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, the `-t` option is used to tag the image with a name,
    which is separated from the tag with a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove an image, use the `docker rmi <container name or ID>` command followed
    by the image name or image ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that if the image is used by a container, you will need to stop the container
    first before removing the image.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a Docker image for our ASP.NET Core application. All the necessary
    dependencies are included in the image. Next, let us run the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run a Docker image in the container, we can use the `docker run` command.
    The following command will run the `basicwebapidemo` image we just built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-d` option is used to run the container in detached mode, meaning the container
    will run in the background. You can omit this option and then the container will
    run in the foreground, which means if you exit the terminal, the container will
    stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` option is used to publish a container’s port(s) to the host. In this
    case, we are publishing port 8080 of the container to port 80 of the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--name` option is used to specify a name for the container. The last argument
    is the name of the image to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the `-it` option to run the container in interactive mode.
    This option allows you to run a command in the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we wrote the Dockerfile, we explained that the `EXPOSE` instruction exposes
    ports 8080 and 8081 to the container only. To publish the internal container port
    to the host, we need to use the `-p` option. The first port number is the port
    of the host machine, and the second port number is the internal container port.
    In this example, we are exposing the container port 8080 to the host port 80\.
    This may confuse some people. So, please check the port numbers carefully. Also,
    sometimes the port number of the host machine may be occupied by another process.
    In this case, you will need to use a different port number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should return the container ID, which is a UID for the container,
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker ps` command to list all running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the output, we can see that port 8080 of the container has been mapped to
    port 80 of the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all containers in all states, just add a `-``a` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can check the status of containers. If the container is running, the status
    should be `Up`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following commands to manage containers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To pause a container: `docker pause <container name` `or ID>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To restart a container: `docker restart <container name` `or ID>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To stop a container: `docker stop <container name` `or ID>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To remove a container: `docker rm <container name` `or ID>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the container is running, you can test the endpoint by sending a request
    to this URL: `http://localhost/weatherforecast`. You will see the response from
    the ASP.NET Core application. If you change the port number of the host machine,
    you will need to use the correct port number in the URL. For example, if you use
    `-p 5000:8080`, then you will need to use [http://localhost:5000/weatherforecast](http://localhost:5000/weatherforecast)
    to access the endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `docker logs <container name or ID>` command to show logs from
    a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see logs such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the stats of a container, you can use the `docker stats <container
    name or` `ID>` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the stats of the container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can send a request to the `/weatherforecast` endpoint to get the response
    from the ASP.NET Core application. Note that the container is running in the production
    environment, so the Swagger UI is not available. This is because in the `Program.cs`
    file, we enabled the Swagger UI only in the development environment. To enable
    the Swagger UI, we can stop and delete the current container, then create a new
    one in development environment. Alternatively, you can create a new container
    with a different name. For example, you can stop the container by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then remove the container by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add an environment variable to the `docker run` command to set the environment
    to development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can view the Swagger UI by navigating to the `/swagger` endpoint in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned how to build and run Docker images. Docker has many
    other commands that can be used to manage Docker images and containers. To summarize,
    here are some of the most commonly used Docker commands from Docker official documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker build`: Build a Docker image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker run`: Run a Docker image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker images`: List all images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker ps`: List all running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker ps -a`: List all containers in all states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker logs`: Show logs from a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker stats`: Show stats of a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker pause`: Pause a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker restart`: Restart a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker stop`: Stop a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker rm`: Remove a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker rmi`: Remove an image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker exec`: Run a command in a running container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker inspect`: Display detailed information on one or more containers or
    images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker login`: Log in to a Docker registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker logout`: Log out from a Docker registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker pull`: Pull an image from a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker push`: Push an image to a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker tag`: Create a `TARGET_IMAGE` tag that refers to `SOURCE_IMAGE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume`: Manage volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker network`: Manage networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker system`: Manage Docker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker version`: Show the Docker version information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker info`: Show Docker system-wide information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker port`: List port mappings or a specific mapping for a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more information about Docker commands here: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/).'
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to build a Docker image for our ASP.NET Core application
    and run it in a container. Even though the container is running on our local machine,
    there is not much difference from running it in a production environment. The
    container is isolated from the host machine. The portable nature of containers
    makes it easy to deploy the application to any environment.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use Docker commands to push the image to a registry, such as Docker
    Hub, ACR, and so on. However, manual deployment is error-prone and time-consuming.
    That is why we need a CI/CD pipeline to automate the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how to deploy the containerized application
    to the cloud using Azure DevOps and Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD using Azure DevOps and Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure DevOps is a cloud-based service that provides a set of tools for managing
    the software development process. It includes the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Boards**: A service for managing work items, such as user stories,
    tasks, and bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Repos**: A service for hosting code repositories. It supports Git and
    **Team Foundation Version Control** (**TFVC**). The repositories can be public
    or private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Pipelines**: A service for building, testing, and deploying applications
    with any language, platform, and cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Test Plans**: A service for manual and exploratory testing tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Maven`, `npm`, `NuGet`, and `Python` packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps is free for open-source projects and small teams. We will not cover
    all the features of Azure DevOps in this book. Let us focus on Azure Pipelines.
    In this section, we will discuss how to use Azure Pipelines to build and deploy
    our ASP.NET Core application to Azure App Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need these resources before we can deploy the application to Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure DevOps** **account**: [https://azure.microsoft.com/en-us/products/devops](https://azure.microsoft.com/en-us/products/devops).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure subscription**: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
    You can sign up for a free account here. You will get some free credits to use
    Azure services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub repository**: You need a GitHub repository to host the source code.
    The pipeline will be triggered when code changes are committed to the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub is one of the most popular source control solutions. It is free for public
    repositories. We suppose you already have a GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the example code from [/chapter14/MyBasicWebApiDemo](https://h/chapter14/MyBasicWebApiDemo).
    This is a simple ASP.NET Core web API application with its unit tests and integration
    tests. Create a new repository on GitHub, then push the source code to the repository.
    The directory structure of the repository should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding directory structure, the main ASP.NET Core web API project
    is placed in the `src` folder, and the unit tests and integration tests are placed
    in the `tests` folder. This can better organize the solution structure. But it
    is just a personal preference. You can also place the unit tests and integration
    tests in the same folder as the main project. If you use a different directory
    structure, please update the paths in the pipeline accordingly in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this repository for the pipeline. Next, let us create the required
    Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In today’s technology landscape, cloud computing has become the backbone of
    modern software development. Cloud computing provides many benefits, such as scalability,
    **high availability** (**HA**), and cost efficiency. Among the various cloud providers,
    such as AWS, GCP, and Alibaba Cloud, Microsoft Azure stands out as a robust and
    versatile platform for hosting and orchestrating your applications. Azure provides
    many services for hosting applications, such as Azure App Service, **Azure Kubernetes
    Service** (**AKS**), **Azure Container Instances** (**ACI**), Azure VMs, and Azure
    Functions. In this book, we will use Azure as the cloud platform to host our applications.
    For other cloud platforms, the concepts are similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need the following Azure resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Container Registry**: A private registry for storing Docker images.
    You can create a new Azure container registry in the Azure portal. Please refer
    to the official documentation here: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Web App for Containers**: A service for hosting containerized web applications.
    It provides a quick and easy way to build, deploy, and scale enterprise-grade
    web, mobile, and API apps on any platform. You can create a new Azure Web App
    for Containers instance in the Azure portal. Please refer to the official documentation
    here: [https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&pivots=container-linux-azure-portal](https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&pivots=container-linux-azure-portal).
    Please select **Docker Container** for the **Publish** option, and select **Linux**
    for the **Operating System** option when creating the Web App for Containers instance
    because we are using Linux containers in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that you can also choose Azure App Service to host your application without
    containerization. Azure App Service supports many programming languages and frameworks,
    such as .NET, .NET Core, Java, Node.js, Python, and so on. It also supports containers.
    You can learn more about Azure App Service here: [https://docs.microsoft.com/en-us/azure/app-service/overview](https://docs.microsoft.com/en-us/azure/app-service/overview).
    In this section, we will explore how to deploy applications in containers, so
    we will use Azure Web App for Containers in the following example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better manage these resources, it is recommended to create a resource group
    to group these resources together. You can create a new resource group in the
    Azure portal or create a new resource group when you create a new resource. Here
    is key information on the resources we need to prepare for the pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource group
  prefs: []
  type: TYPE_NORMAL
- en: 'name: `devops-lab`'
  prefs: []
  type: TYPE_NORMAL
- en: Container registry
  prefs: []
  type: TYPE_NORMAL
- en: 'name: `devopscrlab`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web App for Containers instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: `azure-pipeline-demo`'
  prefs: []
  type: TYPE_NORMAL
- en: "You can use either the Azure portal or Azure CLI to create these resources.\
    \ Defining the scripts to create the resources in code is a good practice, which\
    \ is called **infrastructure as code** (**IaC**). However, we will not cover IaC\
    \ here because it is out of the scope of this book. You can learn more about IaC\
    \ here: [https://learn.microsoft.com/en-us/devops/deliver/what-is-infrastructure-as-code](https://learn.microsoft.com/en-us/devops/deliver/what-is\uFEFF\
    -infrastructure-as-code)."
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us create an Azure DevOps project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure DevOps project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the official documentation provides detailed instructions on how to create
    an Azure DevOps project, we will not cover the details here. Please refer to the
    official documentation here: [https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops](https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops).'
  prefs: []
  type: TYPE_NORMAL
- en: You need to follow the official documentation to create an Azure DevOps account.
    You can sign up with a Microsoft account or a GitHub account. Once you create
    an Azure DevOps account, you can create a new organization. An organization is
    a container for projects and teams. You can create multiple organizations with
    one Azure DevOps account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can create a new project in Azure DevOps. Click the **New project**
    button on the home page, then follow the instructions to create a new project
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Creating a new project in Azure DevOps](img/B18971_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Creating a new project in Azure DevOps
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create these pipelines in the project in the next sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pull request build pipeline**: A pipeline for building the application and
    running tests when a pull request is created. This pipeline will be triggered
    when a pull request is created in the GitHub repository. If the build fails or
    the tests fail, the pull request cannot be merged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release pipeline**: A pipeline for deploying the application to Azure Container
    Apps. This pipeline can be triggered when a new image is published to ACR, or
    it can be triggered manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pull request pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create a pull request build pipeline. Follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Azure DevOps portal, click the **Pipelines** tab on the left
    side, and then click the **Create Pipeline** button. You will see a page like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Creating a new pipeline in Azure DevOps](img/B18971_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Creating a new pipeline in Azure DevOps
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure DevOps Pipelines supports various sources, such as Azure Repos, GitHub,
    Bitbucket, and Subversion. We already have a GitHub repository, so we will use
    GitHub as the source. Click the **GitHub** button, then follow the instructions
    to authorize Azure DevOps to access your GitHub account. Once you have authorized
    Azure DevOps to access your GitHub account, you will see a list of repositories
    in your GitHub account. Select the repository we created earlier; you will be
    navigated to GitHub and see a page where you can install Azure Pipelines to the
    repository. Click the **Approve and install** button to install Azure Pipelines
    to the repository. Then, you will be navigated back to Azure DevOps. You will
    see a page like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Configuring the pipeline](img/B18971_14_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Configuring the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure DevOps Pipelines can provide various templates for your project. In this
    case, you can choose the **ASP.NET** template to start with. Azure DevOps Pipelines
    can automatically detect the source code and generate a basic pipeline for you.
    The default pipeline is a YAML file, which may look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default pipeline is targeting Windows. We will run the application in a
    Linux container, so we need to make some changes to the pipeline. Delete the default
    content and we will start from scratch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, rename the pipeline to `pr-build-pipeline`. You can rename the pipeline
    by clicking the `.``yml` filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Renaming the pipeline](img/B18971_14_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Renaming the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to update the trigger to make the pipeline run when a pull request
    is opened or updated for one of the target branches. Use the `pr` keyword to indicate
    that the pipeline will be triggered by a pull request for the `main` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set `pool` to use the `ubuntu-latest` image. The `ubuntu-latest` image
    is a Linux image, which is smaller than a Windows image. Also, the application
    is targeting Linux containers, so it is better to use a Linux image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create some variables for the solution path, build configuration, and
    so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to add some tasks. Add a `steps:` section, then add the following
    tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UseDotNet@2` task is used to install the .NET SDK so that we can use the
    .NET CLI to execute commands. In this case, we are installing the .NET 8.0 SDK.
    The `includePreviewVersions` option is used to include preview versions of the
    .NET SDK. We need to use the preview version because the .NET 8.0 SDK is still
    in preview at the time of writing this book. If you are reading this book after
    the .NET 8.0 SDK is released, you can remove the `includePreviewVersions` option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The online pipeline editor provides IntelliSense for the YAML file like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.9 – IntelliSense for YAML file](img/B18971_14_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – IntelliSense for YAML file
  prefs: []
  type: TYPE_NORMAL
- en: 'You can click the **Settings** link above the task to configure the task in
    a dialog box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Configuring the task in a dialog box](img/B18971_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Configuring the task in a dialog box
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a `DotNetCoreCLI@2` task to build the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DotNetCoreCLI@2` task is used to run dotnet CLI commands. In this case,
    we are running the `dotnet build` command to build the application. The `--configuration`
    option is used to specify the build configuration. The `--runtime` option is used
    to specify the target runtime. In this case, we are targeting the Linux runtime.
    The `projects` option is used to specify the path to the `.csproj` file or solution
    file. In this case, we are using the `$(solution)` variable we defined earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add tasks to run unit tests and integration tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding tasks, we are running the `dotnet test` command to run unit
    tests and integration tests. The `--no-build` option is used to skip building
    the application. The `--no-restore` option is used to skip restoring the NuGet
    packages because we have already restored the packages and built the application
    in the previous tasks. The other options are used to specify the logger and collect
    code coverage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click the **Save and run** button to commit the changes and run the pipeline.
    You will see the pipeline is running. After a while, the pipeline will be completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.11 – The pipeline is successful](img/B18971_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – The pipeline is successful
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Tests** tab and you will then see the test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.12 – The test results](img/B18971_14_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – The test results
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the code coverage as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.13 – The code coverage](img/B18971_14_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.13 – The code coverage
  prefs: []
  type: TYPE_NORMAL
- en: We just manually triggered the first run of the pipeline. Next, let us create
    a pull request and see how the pipeline is triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new branch and make some changes to the source code. For example,
    we can return 6 items instead of 5 items in `WeatherForecastController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, commit the changes and push the changes to the remote repository. You
    will find the pipeline runs for the new branch as well. That is because YAML pipelines
    are enabled by default for all branches. You can disable this feature by using
    the `trigger none` option. Add the following line to the beginning of the YAML
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, this pipeline will not be triggered automatically for new branches but
    will be triggered by pull requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a new pull request in the GitHub repository. You will see the
    pipeline is triggered automatically and then fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.14 – The pipeline is triggered by the pull request but fails](img/B18971_14_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.14 – The pipeline is triggered by the pull request but fails
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we cannot merge the pull request because the build pipeline failed.
    You can check the logs to see what is wrong with the pipeline. In this case, the
    pipeline failed because the unit tests failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.15 – The unit tests failed](img/B18971_14_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.15 – The unit tests failed
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Tests** tab and you will then see the test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.16 – The unit tests results](img/B18971_14_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.16 – The unit tests results
  prefs: []
  type: TYPE_NORMAL
- en: The details of the failed test case can help us to identify the problem. Next,
    you can fix the error and push the changes to the remote repository. Then, the
    pipeline will be triggered again. If the pipeline is successful, you can merge
    the pull request.
  prefs: []
  type: TYPE_NORMAL
- en: The pull request build pipeline is used to ensure that code changes do not break
    the application. It is important to run the tests before merging the pull request.
    Next, let us create a CI build pipeline to build the Docker image and publish
    it to ACR.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the Docker image to ACR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we created a pull request build pipeline to validate
    code changes in pull requests. The pipeline will be triggered when a pull request
    is created or updated. Once the pull request is merged to the `main` branch, we
    can automatically build the Docker image and publish it to ACR. To do that, we
    will create a CI build pipeline following these steps
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new pipeline following the same steps as we did in the previous section.
    In the configure step, we can choose the `pr-build-pipeline.yml` file we created
    in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.17 – Choosing an existing YAML file to start with](img/B18971_14_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.17 – Choosing an existing YAML file to start with
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way is to choose the **Docker - Build and push an image to Azure Container
    Registry** template, which is exactly what we need. You will be prompted to configure
    your Azure subscription, ACR, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.18 – Configuring ACR, Dockerfile, and image name](img/B18971_14_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.18 – Configuring ACR, Dockerfile, and image name
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Pipelines will automatically detect the Dockerfile and generate a pipeline
    for you. The default pipeline may look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Azure Pipelines has recognized the path of the Dockerfile in the preceding pipeline.
    Additionally, several variables must be configured, such as the image name and
    container registry. The `tag` variable is used to tag the image with the build
    ID. Note that we added a `latest` tag to the image. The `latest` tag is used to
    indicate the latest version of the image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Azure Pipelines predefined variables
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Pipelines provides many predefined variables that can be used in a pipeline.
    For example, the `$(Build.SourcesDirectory)` variable is used to obtain the local
    path on the agent where the source code files have been downloaded. You can find
    all the predefined variables here: [https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml](https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference from a pull request build pipeline is that we have **stages**
    and **jobs** in the pipeline. *Figure 14**.19* shows the structure of a pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.19 – The structure of a pipeline](img/B18971_14_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.19 – The structure of a pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The components in *Figure 14**.19* are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A trigger is used to specify when the pipeline should run. It can be a schedule,
    a pull request, a commit to a specific branch, or a manual trigger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pipeline contains one or more stages. A stage is used to organize jobs. In
    the pull request build pipeline, the stage is omitted. You can have multiple stages
    in one pipeline for different purposes. For example, you can have a build stage,
    a test stage, and a deploy stage. The stage can be also used to set boundaries
    for security and approvals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each stage contains one or more jobs. A job is a container of steps. A job can
    run on one agent or without an agent. For example, you can have a job that runs
    on a Windows agent, and another job that runs on a Linux agent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each job contains one or more steps. A step is the smallest building block
    in a pipeline. A step is normally a task or a script. Azure Pipelines provides
    many built-in tasks, such as the `Docker@2` task we are using in this pipeline.
    A built-in task is a predefined packaged script that performs an action. You can
    also write your own custom tasks. A task can be a command-line tool, a script,
    or a compiled program. You can find all built-in tasks here: [https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding pipeline, we have one stage, one job, and one step. The step
    is the `Docker@2` task. The `Docker@2` task is used to build and push a Docker
    image to a container registry. Using this task simplifies the process of building
    and pushing a Docker image so that we do not need to write `docker build` commands
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename this pipeline to `docker-build-pipeline`. Similarly to `pr-build-pipeline`,
    we need to exclude the `docker-build-pipeline` pipeline from running for new branches
    and pull requests. Add the following line to the beginning of the YAML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, when we create a new branch or a new pull request, the `docker-build-pipeline`
    will not be triggered automatically. We will trigger the pipeline manually or
    by merging a pull request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the `docker-build-pipeline` is triggered automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything is fine, you will see the `docker-build-pipeline` pipeline is
    successful and the Docker image is published to ACR:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.20 – The Docker image is published to ACR](img/B18971_14_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.20 – The Docker image is published to ACR
  prefs: []
  type: TYPE_NORMAL
- en: 'A CI pipeline is a good practice to ensure that code changes can be built successfully
    without breaking the application. However, some changes may not need running tests
    or rebuilding the Docker image. For example, if you only change the documentation,
    (for example, the `README` file), you do not need to run the tests or rebuild
    the Docker image. In this case, you have a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can exclude some files from the pipeline. For example, you can exclude
    the `README.md` file from the pipeline. You can use the `paths` option to specify
    paths to include or exclude, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can skip CI pipelines for some commits. Use `[skip ci]` in the commit message
    to skip CI pipelines. For example, you can use `[skip ci] update README` in the
    commit message to skip CI pipelines for this commit. Some variations include `[ci
    skip]`, `[skip azurepipelines]`, `[skip azpipelines]`, `[skip azp]`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may encounter some errors when creating pipelines. Here are some troubleshooting
    tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the logs carefully. The logs can help you to identify the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the variables. Make sure the variables are correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the permissions. Make sure the service connection has the correct permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the YAML syntax. Make sure the YAML file is valid. YAML files use indentation
    to indicate the structure. Make sure the indentation is correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the pipeline structure. Make sure the pipeline structure is correct. For
    example, make sure the `steps` section is under the `jobs` section and the `jobs`
    section is under the `stages` section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the pipeline triggers. Make sure the pipeline is triggered by the correct
    event. You can use `branches`, `paths`, `include`, and `exclude` to specify branches
    and paths to trigger the pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that if you edit the pipeline YAML file in the online editor, you will
    commit the changes to the `main` branch directly. Your local `feature` branch
    will not be updated automatically. When you push a change to your feature branch,
    whether the pipeline should be triggered depends on the settings in the YAML file
    in your feature branch, not the `main` branch. So, make sure your feature branch
    keeps synchronized with the `main` branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use VS to create the Dockerfile, double-check the paths in the Dockerfile.
    Sometimes, VS cannot detect the correct paths if you use a custom solution structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now pushed the Docker image to ACR. Next, let's create a release pipeline
    to deploy the application to Azure Web App for Containers.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application to Azure Web App for Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we created a CI build pipeline to build the Docker
    image and publish it to ACR. In this section, we will create a release pipeline
    to pull the Docker image from ACR and deploy it to Azure Web App for Containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps in the previous section to create a new pipeline. When we
    configure the pipeline, choose the **Starter pipeline** template because we will
    start from scratch. The default starter pipeline has two scripts as examples.
    Delete the scripts, and it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can disable the triggers for the pipeline because we will manually run the
    pipeline when we need to deploy the application. Rename the pipeline as `release-pipeline`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add some variables to the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to configure the username and password to authenticate the pipeline
    to pull the Docker image from ACR. You can find the username and password of your
    ACR instance in the Azure portal. Click the **Access keys** button on the left
    side, and you will then see the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the password is a secret, we cannot use it in the YAML file directly, otherwise
    the password will be exposed in the GitHub repository. Azure Pipelines provides
    a way to store secrets in the pipeline. Click the **Variables** button in the
    top-right corner, then click the **New variable** button to add a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.21 – Adding a new variable to store the password](img/B18971_14_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.21 – Adding a new variable to store the password
  prefs: []
  type: TYPE_NORMAL
- en: Check the `$(acrpassword)` variable to refer to the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a task to set up the Azure App Service settings. Choose the **Azure
    App Service Settings** task from the task assistant. We need to add the credentials
    to authenticate the Azure Web App to pull the Docker image from ACR. Azure Pipelines
    will prompt you to configure the task. Note that the **App settings** field is
    a JSON string. The tasks should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the `appSettings` field, we use the `$(acrpassword)` variable to refer to
    the password we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click the **Show assistant** button in the top-right corner to open the
    assistant. The assistant helps us to use the built-in tasks easily. Choose the
    **Azure Web App for Containers** task that is used to deploy the Docker image
    from ACR to Azure Web App for Containers. Azure Pipelines will prompt you to configure
    the task. Configure the task as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the **Azure App Service Deploy** task from the assistant.
    This task is used to deploy the application to Azure Web App that supports either
    native deployment or container deployment. You need to configure the Azure subscription,
    App Service type, and so on. When you choose the **Web App for Containers (Linux)**
    option for **App Service type**, you will be prompted to configure the ACR name,
    Docker image name, tag, and so on. The task should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also need to specify a `StartupCommand` value. In this case, we
    use `dotnet MyBasicWebApiDemo.dll` to start the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can manually trigger the pipeline to deploy the application. If everything
    is fine, you will see the deployment is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the configuration of the Azure Web App. You will see the **Application
    settings** are updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.22 – The application settings are updated](img/B18971_14_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.22 – The application settings are updated
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Azure portal and check the details of the Azure Web App we created
    earlier. You can find the URL of the Azure Web App, such as `azure-pipeline-demo.azurewebsites.net`.
    Open the URL in the browser and check the controller endpoint, such as `https://azure-pipeline-demo.azurewebsites.net/WeatherForecast`.
    You will see the response from the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have created three pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pull request build pipeline**: This pipeline is to validate the code changes
    in pull requests. It will be triggered when a pull request is created or updated.
    If the build fails or the tests fail, the pull request cannot be merged. This
    pipeline does not produce any artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` branch. This pipeline produces a Docker image as the artifact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release pipeline**: This pipeline is to pull the Docker image from ACR and
    deploy it to Azure Web App for Containers. This pipeline can be triggered manually
    or automatically when a new Docker image is published to ACR. This pipeline does
    not produce any artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring settings and secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we created a release pipeline to deploy the application
    to Azure Web App for Containers. We may also need to deploy the application to
    other environments, such as staging. These different environments may have different
    settings, such as database connection strings, API keys, and so on. So, how can
    we configure the settings for different environments?
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to achieve this. A simple way is to configure variables
    for different environments. You can define variables in each pipeline directly.
    Azure Pipelines also provides a **Library** to manage variables. You can group
    variables into a variable group and then use the variable group in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Storing confidential information securely is essential to any organization.
    To ensure the safety of your secrets, you can use a variety of key vaults, such
    as Azure Key Vault and AWS Secrets Manager. Azure Pipelines offers a Key Vault
    task to fetch secrets from the vault. With the Azure Key Vault task, you can easily
    retrieve secrets from the vault and use them in your pipeline. To learn more about
    the Key Vault task, please visit [https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project](https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not intended to cover all the details of Azure Pipelines, but
    you should now have a basic understanding of Azure Pipelines. Using CI/CD pipelines
    can help you to automate the build, test, and deployment process, which eliminates
    manual work and reduces the risk of human errors. It is more and more important
    to use CI/CD pipelines in modern software development. Every developer should
    learn how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore GitHub Actions, which is another popular
    CI/CD tool.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we explored Azure Pipelines. Next, let us explore GitHub
    Actions. GitHub Actions is a CI/CD tool provided by GitHub. It is quite similar
    to Azure Pipelines. In this section, we will use GitHub Actions to build and test
    the application and push the Docker image to ACR.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how to use GitHub Actions, we will use the same source code
    as we used in the previous section. You can download the source code from the
    GitHub repository here: [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo).
    Create a new GitHub repository and push the source code to the repository. The
    directory structure of the source code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you use a different directory structure, please update the paths in the pipeline
    accordingly in the following sections. We will use this repository to demonstrate
    how to configure GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse the Azure resources we created in the previous section. If you
    have not created the Azure resources, please refer to the *Creating Azure resources*
    section to create the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the GitHub repository page, click the **Actions** tab, and you can see many
    templates for different programming languages and frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.23 – Choosing a template for GitHub Actions](img/B18971_14_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.23 – Choosing a template for GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Continuous integration** section, you can find the **.NET** template.
    Click the **Configure** button to create a new workflow. The workflow is a YAML
    file that defines the CI/CD pipeline. The default workflow may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The syntax of the workflow is quite similar to Azure Pipelines. The workflow
    is triggered when a pull request is created or updated, or when a commit is pushed
    to the `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right side, you can find the **Marketplace** panel. The Marketplace
    is similar to the assistants of Azure DevOps Pipelines and provides many built-in
    actions that you can use in your workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.24 – The Marketplace panel](img/B18971_14_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.24 – The Marketplace panel
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample application uses .NET 8\. So, we need to update `dotnet-version`
    to `8.0.x`. Click the `dotnet.yml` file is committed to the `/.github/workflows`
    directory. Make a change to the source code or create a new branch and push the
    changes to the remote repository. For example, you can change the controller to
    return six items instead of five items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a pull request. You will see the workflow is triggered
    automatically and the test is failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.25 – The workflow is triggered automatically and then fails](img/B18971_14_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.25 – The workflow is triggered automatically and then fails
  prefs: []
  type: TYPE_NORMAL
- en: Click the links in the logs to see details of the code that caused the test
    failure. It is handy to review code changes in the pull request. If everything
    is fine, you can merge the pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify that it works for pull request builds, we can rename this file to
    `pr-build.yml` and update the `on` section to make the workflow run for pull requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Next, let us build a Docker image and push it to ACR.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a Docker image to ACR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new YAML file named `docker-build.yml` in the `.github\workflows`
    folder. Update the content of the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This workflow is triggered when a commit is pushed to the `main` branch or a
    pull request is merged into the `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: To authenticate the action to access ACR, we need to configure the username
    and password of ACR in GitHub secrets. Find the username and password by clicking
    the **Access keys** menu of ACR in the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **Settings** in the GitHub repository and click **Secrets and variables**
    in the **Security** category. Then, click **Actions**, and you will see the secrets
    and variables page. There are two types of secrets: environment secrets and repository
    secrets. You can store the username and password in repository secrets directly.
    To demonstrate how to use environment secrets, we will use environment secrets
    in this example. Click the **Manage environments** button to create a new environment
    named **Production**. Then, click the **Add secret** button to add a username
    and password:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `REGISTRY_USERNAME`. Value: The username of ACR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: `REGISTRY_PASSWORD`. Value: The password of ACR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change the environment secret names, but make sure you use the same
    names in the following workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the environment secrets should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.26 – The Actions secrets and variables page](img/B18971_14_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.26 – The Actions secrets and variables page
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `docker-build.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is similar to the `pr-build.yml` file, but we made some changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We added an `environment` section to specify the environment so that we can
    refer to the environment secrets later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a new `azure/docker-login@v1` step to log in to ACR. In this step,
    we specified the login server, username, and password using the environment secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a new step to build the Docker image and push it to ACR. In this step,
    we used the `github.run_id` variable to tag the image with the run ID. We also
    tagged the image with `latest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions context
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Actions supports many built-in context variables, such as `github.run_id`,
    `github.run_number`, `github.sha`, `github.ref`, and so on. You can find all the
    context variables here: [https://docs.github.com/en/actions/learn-github-actions/contexts](https://docs.github.com/en/actions/learn-github-actions/contexts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Commit the changes and push the changes to the remote repository. Next time
    you merge a pull request, you will see the workflow is triggered automatically
    and the Docker image is pushed to ACR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.27 – The GitHub Actions workflow is triggered automatically](img/B18971_14_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.27 – The GitHub Actions workflow is triggered automatically
  prefs: []
  type: TYPE_NORMAL
- en: 'As there are many similarities between Azure Pipelines and GitHub Actions,
    we will not cover all the details of GitHub Actions. Maybe it is your turn to
    create a GitHub Actions workflow to deploy the Docker image to Azure Web App for
    Containers? You can find more information about GitHub Actions here: [https://docs.github.com/en/actions](https://docs.github.com/en/actions).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the fundamentals of CI/CD. We discussed how to
    use Docker to containerize ASP.NET web API applications, including how to create
    a Dockerfile, build a Docker image, and run a Docker container locally. We then
    looked at Azure DevOps Pipelines, a powerful CI/CD platform from Microsoft, and
    how to create CI/CD pipelines in YAML files. We covered configuring triggers,
    using built-in tasks, and using variables. We created three pipelines for builds,
    Docker image builds, and releases. We also briefly discussed GitHub Actions, another
    popular CI/CD tool, and created a GitHub Actions workflow to build and test the
    application, then build the Docker image and push it to ACR. After reading this
    chapter, you should have a basic understanding of CI/CD and be able to use CI/CD
    pipelines to automate the build, test, and deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine some common practices for building ASP.NET
    web APIs, including caching, `HttpClient` factory, and so on.
  prefs: []
  type: TYPE_NORMAL
