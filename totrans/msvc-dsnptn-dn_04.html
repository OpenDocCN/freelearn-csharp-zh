<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-58"><a id="_idTextAnchor057"/>4</h1>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Asynchronous Communication between Microservices</h1>
<p>We have just reviewed synchronous communication between microservices and the pros and cons of that method. Now, we will take a look at its opposite counterpart, asynchronous communication.</p>
<p>Synchronous communication is needed at times and, based on the operation being carried out, can be unavoidable. It does introduce potentially long wait times as well as potential break points in certain operations. At this point, it is important to properly assess the operation and decide whether immediate feedback from an additional service is required to continue. Asynchronous communication means that we send data to the next service but do not wait for a response. The user will be under the impression that the operation was completed, but the actual work is being done in the background.</p>
<p>From that review, it is obvious that this method of communication cannot always be used but is necessary to implement certain flows and operations efficiently in our application.</p>
<p>After reading this chapter, we will be able to do the following:</p>
<ul>
<li>Understand what asynchronous communication is and when we should use it</li>
<li>Implement Pub-Sub communication</li>
<li>Learn how to configure a message bus (<strong class="bold">RabbitMQ</strong> or <strong class="bold">Azure Service Bus</strong>)</li>
</ul>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Technical requirements</h1>
<p>Code references used in this chapter can be found in the project repository, which is hosted on GitHub at this URL: <a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch04">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch04</a></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Functioning with asynchronous communication</h1>
<p>Let us revisit<a id="_idIndexMarker143"/> some vital definitions and concepts before moving forward.</p>
<p>There are basically two messaging patterns that we will employ between microservices:</p>
<ul>
<li><strong class="bold">Synchronous communication</strong>: We<a id="_idIndexMarker144"/> covered this pattern in the previous chapter, where one service calls another directly and waits for a response</li>
<li><strong class="bold">Asynchronous communication</strong>: In this <a id="_idIndexMarker145"/>pattern, we use messages to communicate without waiting for a response</li>
</ul>
<p>There are times when one microservice needs another to complete an operation, but at the moment, it doesn’t need to know the outcome of the task. Let us think of sending confirmation emails after an appointment has been successfully booked by our health care management system. Imagine the user waiting on the user interface to complete its loading operation and show the confirmation. In between them clicking <strong class="bold">Submit</strong> and seeing the confirmation, the booking service needs to complete the following operations:</p>
<ol>
<li>Create an appointment record</li>
<li>Send an email to the doctor booked for the appointment</li>
<li>Send an email to the patient who booked the appointment</li>
<li>Create a calendar entry for the system</li>
</ol>
<p>Despite our best efforts, the booking service attempting to complete these operations will take some time and might lead to a less than pleasing user experience. We could also argue that the responsibility of sending emails should not be native to the booking service. In the same way, calendar management should stand on its own. So, we could refactor the booking service’s tasks as follows:</p>
<ol>
<li value="1">Create an appointment record</li>
<li>Synchronously call the email service to send an email to the doctor booked for the appointment</li>
<li>Synchronously call the email service to send an email to the patient who booked the appointment</li>
<li>Synchronously call the calendar management service to create a calendar entry for the system</li>
</ol>
<p>Now, we have refactored the booking service to do fewer operations and offload the intricacies of non-appointment booking operations to other services. This is a good refactor, but we have retained and potentially amplified the main flaw in this design. We are still going to wait on the completion of one potentially time-consuming operation before we move on to the next operation, which runs the same risk. At this point, we can consider how important waiting on a response to these actions really is, relative to us entering the booking record in our database, which is the most important operation relative to allowing the user to know the outcome of the booking process.</p>
<p>In this setting, we can make use of an asynchronous communication pattern to ensure that the major operation gets completed and other operations, such as sending an email and entering a calendar entry, can happen eventually, without compromising our user experience.</p>
<p>At a very<a id="_idIndexMarker146"/> basic level, we can still implement asynchronous communication using HTTP patterns. Let us discuss how effective this can be.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>HTTP asynchronous communication</h2>
<p>In seeming <a id="_idIndexMarker147"/>contrast to what we have explored so far, we can actually implement asynchronous communication via HTTP. If we assess how HTTP communication works, we form an assessment of success or failure based on the HTTP response we receive. Synchronously, we would expect the booking service to call the email service and then wait on an HTTP <code>200 OK</code> successful response code before it tries to move to the next command. Synchronously, we would actually try to send the email at the moment, and based on the success or failure of that operation, we would form our response.</p>
<p>Asynchronously, we would let the email service respond with an HTTP <code>202 ACCEPTED</code> response, which indicates that the service has accepted the task and will carry it out eventually. This way, the booking service can continue its operation based on that promise and spend less time on the operation. In the background, the email service will carry out the task when it gets around to it.</p>
<p>While this does alleviate some of the pressure that the booking service carries, there are other patterns, such as the Pub-Sub pattern, that can be implemented to make this process<a id="_idIndexMarker148"/> smoother. Let us review this pattern.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Understanding Pub-Sub communication</h1>
<p>The Pub-Sub <a id="_idIndexMarker149"/>pattern has gained a fair amount of popularity and acclaim and is widely used in distributed systems. <em class="italic">Pub</em> is short for <em class="italic">Publisher</em> and <em class="italic">Sub</em> is short for <em class="italic">Subscriber</em>. Essentially, this pattern revolves around publishing data, contextually called messages, to an intermediary messaging system, which can be described as resilient and reliable, and then having subscribing applications monitor this intermediary system. Once a message is detected, the subscribing application will conduct its processing as necessary.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Understanding message queues</h2>
<p>Before we <a id="_idIndexMarker150"/>explore <a id="_idIndexMarker151"/>the Pub-Sub method, we need to understand the basics of messaging systems and how they work. The first model we will look at is called a <em class="italic">message queue</em>. A message queue is usually implemented as a bridge between two systems, a publisher and a consumer. When a publisher places messages in the queue, a consumer processes the information in the message as soon as it becomes available. Queues <a id="_idIndexMarker152"/>enforce a <strong class="bold">first-in-first-out</strong> (<strong class="bold">FIFO</strong>) delivery method, so the order of processing can always be guaranteed. This is usually implemented in a one-to-one communication scenario, so a specific queue is provisioned for each subscribing application. Payment systems tend to use this pattern heavily, where the actual sequence of submitted payments matters and they need to ensure the resilience of the instructions. If you think about it, payment systems generally have a very low failure rate. Most of the time when we submit a payment request, we can rest assured that it will be completed successfully at some point in the future.</p>
<p><em class="italic">Figure 4.1</em> shows a publisher interacting with several message queues.</p>
<div><div><img alt="Figure 4.1 – Each message queue ensures that each application gets the exact data it needs and nothing more" src="img/Figure_4.1_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Each message queue ensures that each application gets the exact data it needs and nothing more</p>
<p>The unfortunate thing here is that one bad message can spell trouble for the other messages waiting in the queue, and so we have to consider this potential downside. We also have to consider that we have our first chink in the armor. Messages are also discarded after they are read, so special provisions need to be made for messages that were not processed successfully.</p>
<p>While message queues do have their uses and bring a certain level of reliability to our system design, in a distributed system, they can be a bit inefficient and introduce some cons that we <a id="_idIndexMarker153"/>might not be prepared to live with. In that<a id="_idIndexMarker154"/> event, we turn our attention to a more distributed messaging setup such as a message bus. We will discuss this next.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Understanding message bus systems</h2>
<p>A <em class="italic">message bus</em>, <em class="italic">event bus</em>, or <em class="italic">service bus</em> provides<a id="_idIndexMarker155"/> interfaces, where one published message <a id="_idIndexMarker156"/>can be processed by multiple or competing subscribers. This is advantageous in scenarios where we need to publish the same data to multiple applications or services. This way, we do not need to connect to multiple queues to send a message, but we can have one connection, complete one <em class="italic">send</em> action, and not worry about the rest.</p>
<p><em class="italic">Figure 4.2</em> shows a publisher interacting with a message, which has several consumers.</p>
<div><div><img alt="Figure 4.2 – This message bus has several consumers or subscribers listening for messages" src="img/Figure_4.2_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – This message bus has several consumers or subscribers listening for messages</p>
<p>Going back to our scenario where booking an appointment has several operational concerns, we can use a message bus to distribute data to the relevant services and allow them to complete their operations in their own time. Instead of making direct calls to the other APIs, our<a id="_idIndexMarker157"/> appointment booking API will<a id="_idIndexMarker158"/> create a message and place it on the message bus. The email and calendar services are subscribed to the message bus and process the message accordingly.</p>
<p>This pattern has several advantages where decoupling and application scalability are concerned. This aids in making the microservices even more independent from each other and reduces limitations associated with adding more services in the future. It also adds stability to the overall interactions of our services, since the message bus acts as a storage intermediary for the data needed to complete an operation. If a consuming service is unavailable, the message will be retained, and the pending messages will be processed once normalcy is restored. If all services are running and messages are backing up, then we can scale the number of instances of the services to reduce the message backlog more quickly.</p>
<p>There are several types of messages that you may encounter, but we will focus on two for this chapter. They are <strong class="bold">command</strong> and <strong class="bold">event</strong> messages. Command messages essentially <a id="_idIndexMarker159"/>request <a id="_idIndexMarker160"/>some action is performed. So, our message to the calendar services sends an instruction for a calendar entry to be created. Given the nature of these commands, we can take advantage of this asynchronous pattern and have the messages get picked up eventually. That way, even large numbers of messages will be processed.</p>
<p>Event messages simply announce that some action took place. Since these messages are generated after an action, they are worded in the past tense and can be sent to several microservices. In this case, the message to the email service can be seen as an event and our email service will relay that information accordingly. This type of message generally has just enough information to let the consuming services know what action was completed.</p>
<p>Command messages are generally aimed at microservices that need to post or modify data. Until a message is consumed and actioned, the expected data will not be available for some amount<a id="_idIndexMarker161"/> of time. This is one of the key<a id="_idIndexMarker162"/> downsides to the asynchronous messaging model, and it is termed <strong class="bold">eventual consistency</strong>. We need to explore this in more detail and discover the best approaches to take.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Understanding eventual consistency</h2>
<p>One of the biggest<a id="_idIndexMarker163"/> challenges we face in <a id="_idIndexMarker164"/>microservices design is data management and developing a strategy for keeping data in sync, which sometimes means that we need to have multiple copies of the same data in several microservice databases. <strong class="bold">Eventual consistency</strong> is a notion in distributed computing systems that accepts that data will be out of sync for a period of time. This type of constraint is only acceptable in distributed systems and fault-tolerant applications.</p>
<p>It is easy enough to manage one dataset in one database, as is the case with a monolithic application, since data will always be up to date for any other part of the application to be able to access. A single database approach to our application gives us the guarantee of ACID transactions, which we discussed earlier, but we still are met with the challenge of <strong class="bold">concurrency</strong> management. Concurrency refers to the fact that we might have <a id="_idIndexMarker165"/>multiple versions of the same data available at different points. This challenge is easier to manage in a single database application but presents a unique challenge in a distributed system.</p>
<p>It is a reasonable assumption that when data changes in one microservice, data will change in another and lead to some inconsistency between the data stores for a period. The <strong class="bold">CAP theorem</strong> introduces <a id="_idIndexMarker166"/>the notion that we cannot guarantee all three of the main attributes of a distributed system: <strong class="bold">consistency</strong>, <strong class="bold">availability</strong>, and <strong class="bold">partition tolerance</strong>:</p>
<ul>
<li><strong class="bold">Consistency</strong>: This means <a id="_idIndexMarker167"/>that every read operation against a data store will yield the current and most up-to-date version of the data, or an error will be raised if the system cannot guarantee that it is the latest.</li>
<li><strong class="bold">Availability</strong>: This means<a id="_idIndexMarker168"/> that data will always be returned for a read operation, even if this is not the latest guaranteed version.</li>
<li><strong class="bold">Partition tolerance</strong>: This<a id="_idIndexMarker169"/> means that systems will operate even when there might be transient errors that would stop a system under normal circumstances. Imagine we have minor connectivity issues between our services and/or messaging systems. Data updates will be delayed, but this principle will suggest that we need to choose between <strong class="bold">availability</strong> and <strong class="bold">consistency</strong>.</li>
</ul>
<p>Choosing consistency or availability is a very important decision moving forward. Given that microservices <a id="_idIndexMarker170"/>need to be generally always<a id="_idIndexMarker171"/> available, we must be careful with our decision and how strictly we impose our constraints around a system’s consistency policy – eventual or strong.</p>
<p>There are scenarios where strong consistency is not required, since all the work that was performed by an operation is completed or rolled back. These updates are either lost (if rolled back) or will propagate to the other microservices in their own time, without having any detrimental effects on the overall operations of the application. If this model is selected, we can gauge our user experience through sensitization and letting them know that updates are not always immediate across the different screens and modules.</p>
<p>Using the Pub-Sub model is the number one way to implement this kind of event-driven communication between services, where they all communicate via a messaging bus. With the completion of each operation, each microservice will publish an event message to the message bus, and other services will pick this up and process it eventually.</p>
<p>To implement eventual consistency, we usually use event-driven communication using a publish-subscribe model. When data is updated in one microservice, you can publish a message to a central messaging bus, and other microservices that have copies of the data can receive a notification by subscribing to the bus. Because the calls are asynchronous, the individual microservices can continue to serve requests using the copy of the data that they already have, and the system needs to tolerate that while it might not be consistent right away, meaning that the data may not all be in sync immediately, eventually it will be consistent across the microservices. Of course, implementing eventual consistency can be more complex than just firing and forgetting messages to a message bus. Later in this book, we’ll look at ways we can mitigate the risks.</p>
<p>Until now, we have explored the concepts of using event-driven or Pub-Sub patterns to facilitate asynchronous communication. All of these concepts have been based on the idea that we have<a id="_idIndexMarker172"/> a messaging system persisting <a id="_idIndexMarker173"/>and distributing messages between services and operations. Now, we need to explore some of our options in the forms of RabbitMQ and Azure Service Bus.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Configuring a message bus (RabbitMQ or Azure Service Bus)</h1>
<p>After waxing <a id="_idIndexMarker174"/>poetic about messaging buses and queues, we can finally discuss two excellent options <a id="_idIndexMarker175"/>for<a id="_idIndexMarker176"/> facilitating message-based service communication. They are <strong class="bold">RabbitMQ</strong> and <strong class="bold">Azure Service Bus</strong>.</p>
<p>These are by no means the only options, nor are they the best, but they are popular and can get the job done. Alternatives that you may encounter <a id="_idIndexMarker177"/>include <strong class="bold">Apache Kafka</strong>, which <a id="_idIndexMarker178"/>is famed for its high performance and low latency, or <strong class="bold">Redis Cache</strong>, which <a id="_idIndexMarker179"/>can double as a simple key-value caching store but also as a message broker. Ultimately, the tool you use is relative to what you need <a id="_idIndexMarker180"/>and what the tool offers your context.</p>
<p>Let us explore how we can integrate with RabbitMQ in a .NET Core application.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Implementing RabbitMQ in an ASP.NET Core web API</h2>
<p>RabbitMQ <a id="_idIndexMarker181"/>is the most deployed<a id="_idIndexMarker182"/> and used open source message broker, at least at the time of writing. It supports multiple operating systems, has a ready-to-go container image, and is a reliable intermediary messaging system that is supported by several programming languages. It also provides a management UI that allows us to review messages and overall system performance as part of monitoring measures. If you plan to deploy a messaging system on-premises, then RabbitMQ is an excellent option.</p>
<p>RabbitMQ supports sending <a id="_idIndexMarker183"/>messages in two main ways – <strong class="bold">queues</strong> and <strong class="bold">exchanges</strong>. We <a id="_idIndexMarker184"/>already have an appreciation for what queues are, and exchanges support the message bus paradigm.</p>
<p>Let us take a look at what it takes to configure RabbitMQ on a Windows computer and what supporting C# code is needed to publish and consume. Let us start by including the <code>MassTransit.RabbitMQ</code> RabbitMQ package via NuGet. In our <code>Program.cs</code> file, we need to ensure that we configure <code>MassTransit</code> to use RabbitMQ by adding the following lines:</p>
<pre class="source-code">
builder.Services.AddMassTransit(x =&gt;
{
    x.UsingRabbitMq();
});</pre>
<p>This creates an injectable service that can be accessed in any other part of our code. We need to inject <code>IPublishEndpoint</code> into our code, and this will allow us to submit a message <a id="_idIndexMarker185"/>to<a id="_idIndexMarker186"/> the RabbitMQ exchange:</p>
<pre class="source-code">
[ApiController]
[Route("api/[controller]")]
public class AppointmentsController : ControllerBase
{
    private readonly IPublishEndpoint _publishEndpoint;
    private readonly IAppointmentRepository
        _appointmentRepository;
    public AppointmentsController (IAppointmentRepository
        appointmentRepository, IPublishEndpoint
            publishEndpoint)
    {
        _publishEndpoint = publishEndpoint;
        _appointmentRepository = appointmentRepository;
    }
[HttpPost]
public async Task&lt;IActionResult&gt; CreateAppointment
    (AppointmentDto appointment)
{
       var appointment = new Appointment()
       {
         CustomerId = AppointmentDto.CustomerId,
         DoctorId = AppointmentDto.DoctorId,
         Date = AppointmentDto.Date
       });
       await _appointmentRepository.Create(appointment);
      var appointmentMessage = new AppointmentMessage()
       {
        Id = appointment.Id
         CustomerId = appointment.CustomerId,
         DoctorId = appointment.DoctorId,
         Date = appointment.Date
       });
       await _publishEndpoint.Publish(appointmentMessage);
       return Ok();
  }
}</pre>
<p>After creating <a id="_idIndexMarker187"/>an <a id="_idIndexMarker188"/>appointment record, we can share the record’s details on the exchange. The different subscribers will pick up this message and process what they need. Consumers are generally created as windows or background worker services that are always on and running. The following example shows how a consumer’s code might look:</p>
<pre class="source-code">
public class AppointmentCreatedConsumer :
    IConsumer&lt;AppointmentMessage&gt;
{
public async Task Consume(ConsumeContext&lt;Appointment
    Message&gt; context)
{
   // Code to extract the message from the context and
     complete processing – like forming email, etc…
        var jsonMessage =
            JsonConvert.SerializeObject(context.Message);
        Console.WriteLine($"ApoointmentCreated message:
            {jsonMessage}");
      }
}</pre>
<p>Our consumers will be able to receive any message of the <code>AppointmentMessage</code> type and use the information as they need to. Note that the data type for the message exchange is consistent between the producer and the consumer. So, it would be prudent of us to have a <code>CommonModels</code> project that sits in between and serves up these common data types.</p>
<p>If we implement this consumer in a console application, then we need to register a <code>appointment-created-event</code>. To create a console application that will listen until we terminate the instance, we need code that looks like this:</p>
<pre class="source-code">
var busControl = Bus.Factory.CreateUsingRabbitMq(cfg =&gt;
{
    cfg.ReceiveEndpoint("appointment-created-event", e =&gt;
    {
        e.Consumer&lt;AppointmentCreatedConsumer&gt;();
    });
});
await busControl.StartAsync(new CancellationToken());
try
{
    Console.WriteLine("Press enter to exit");
    await Task.Run(() =&gt; Console.ReadLine());
}
finally
{
    await busControl.StopAsync();
}</pre>
<p>Now that we<a id="_idIndexMarker190"/> have <a id="_idIndexMarker191"/>seen in a nutshell what it takes to communicate with a RabbitMQ exchange, let us review what is needed to communicate with the cloud-based Azure Service Bus.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Implementing Azure Service Bus in an ASP.NET Core API</h2>
<p>Azure Service <a id="_idIndexMarker192"/>Bus is an excellent <a id="_idIndexMarker193"/>choice for cloud-based microservices. It is a fully managed enterprise message broker that supports queues as well as Pub-Sub topics. Given Microsoft Azure’s robust availability guarantees, this service supports load balancing, and we can be assured of secure and coordinated message transfers if we choose this option. Similar to RabbitMQ, Azure Service Bus has support for <strong class="bold">queues</strong> and <strong class="bold">topics</strong>. Topics are the direct equivalent of <strong class="bold">exchanges</strong>, where we can have multiple services subscribed and waiting on new messages. Let us reuse the concept we just explored with RabbitMQ and review the code needed to publish a message on a topic and see what consumers would look like. We are going to focus on the code in this section and assume that you have already created the following:</p>
<ul>
<li>An Azure Service Bus resource</li>
<li>An Azure Service Bus topic</li>
<li>An Azure Service Bus subscription to the topic</li>
</ul>
<p>These elements all need to exist, and we will retrieve a connection string to Azure Service Bus through the Azure portal. To get started with the code, add the <code>Azure.Messaging.ServiceBus</code> NuGet package to the producer and consumer projects.</p>
<p>In our publisher, we can create a service wrapper that can be injected into parts of the code that will publish messages. We will have something like this:</p>
<pre class="source-code">
public interface IMessagePublisher {
    Task PublisherAsync&lt;T&gt; (T data);
}
public class MessagePublisher: IMessagePublisher {
    public async Task PublishMessage&lt;T&gt; (T data, string
       topicName) {
         await using var client = new ServiceBusClient
             (configuration["AzureServiceBusConnection"]);
        ServiceBusSender sender = client.CreateSender
            (topicName);
        var jsonMessage =
            JsonConvert.SerializeObject(data);
        ServiceBusMessage finalMessage = new
            ServiceBusMessage(Encoding.UTF8.GetBytes
                (jsonMessage))
        {
            CorrelationId = Guid.NewGuid().ToString()
        };
        await sender.SendMessageAsync(finalMessage);
        await client.DisposeAsync();
}</pre>
<p>In this <a id="_idIndexMarker194"/>code, we <a id="_idIndexMarker195"/>declare an interface, <code>IMessagePublisher.cs</code>, and implement it through <code>MessagePublisher.cs</code>. When a message comes in, we create <code>ServiceBusMessage</code> and submit it to the specified topic.</p>
<p>We need to ensure that we register this service so that it can be injected into other parts of our code:</p>
<pre class="source-code">
services.AddScoped&lt;IMessagePublisher, MessagePublisher&gt;();</pre>
<p>Now, let us look at the same controller and how it would publish a message to Azure Service Bus <a id="_idIndexMarker196"/>instead <a id="_idIndexMarker197"/>of RabbitMQ:</p>
<pre class="source-code">
[ApiController]
[Route("api/[controller]")]
public class AppointmentsController : ControllerBase
{
    private readonly IMessageBus _messageBus;
    private readonly IAppointmentRepository
        _appointmentRepository;
    public AppointmentsController (IAppointmentRepository
        appointmentRepository, IMessageBus messageBus)
    {
      _appointmentRepository = appointmentRepository;
      _messageBus = messageBus;
    }
[HttpPost]
public async Task&lt;IActionResult&gt; CreateAppointment
    (AppointmentDto appointment)
{
       var appointment = new Appointment()
       {
         CustomerId = AppointmentDto.CustomerId,
         DoctorId = AppointmentDto.DoctorId,
         Date = AppointmentDto.Date
       });
       await _appointmentRepository.Create(appointment);
      var appointmentMessage = new AppointmentMessage()
       {
        Id = appointment.Id
         CustomerId = appointment.CustomerId,
         DoctorId = appointment.DoctorId,
         Date = appointment.Date
       });
       await _messageBus.PublishMessage(appointmentMessage,
           "appointments");
       return Ok();
  }
}</pre>
<p>Now that we <a id="_idIndexMarker198"/>know <a id="_idIndexMarker199"/>how we can set up the publisher code, let us review what we need for a consumer. This code could be used by a background worker or Windows service to continuously monitor for new messages:</p>
<pre class="source-code">
public interface IAzureServiceBusConsumer
    {
        Task Start();
        Task Stop();
    }</pre>
<p>We start with defining an interface that outlines <code>Start</code> and <code>Stop</code> methods. This interface will be implemented by a consumer service class, which will connect to Azure Service Bus<a id="_idIndexMarker200"/> and<a id="_idIndexMarker201"/> begin executing code that listens to Service Bus for new messages and consumes them accordingly:</p>
<pre class="source-code">
    public class AzureServiceBusConsumer :
        IAzureServiceBusConsumer
    {
        private readonly ServiceBusProcessor
            appointmentProcessor;
        private readonly string appointmentSubscription;
        private readonly IConfiguration _configuration;
        public AzureServiceBusConsumer(IConfiguration
            configuration)
        {
           _configuration = configuration;
            string appointmentSubscription =
              _configuration.GetValue&lt;string&gt;
                ("AppointmentProcessSubscription")
            var client = new ServiceBusClient
                (serviceBusConnectionString);
            appointmentProcessor = client.CreateProcessor
                ("appointments", appointmentSubscription);
        }
        public async Task Start()
        {
            appointmentProcessor.ProcessMessageAsync +=
                ProcessAppointment;
            appointmentProcessor.ProcessErrorAsync +=
                ErrorHandler;
            await appointmentProcessor
                .StartProcessingAsync();
        }
        public async Task Stop()
        {
            await appointmentProcessor
                .StopProcessingAsync();
            await appointmentProcessor.DisposeAsync();
        }
        Task ErrorHandler(ProcessErrorEventArgs args)
        {
            Console.WriteLine(args.Exception.ToString());
            return Task.CompletedTask;
        }
        private async Task ProcessAppointment
            (ProcessMessageEventArgs args)
        {
            // Code to extract the message from the args,
            parse to a concrete type, and complete 
            processing – like
forming email, etc…
           await args.CompleteMessageAsync(args.Message);
        }
    }</pre>
<p>From these two examples of how we interact with message bus systems, we can see that they are conceptually very similar. Similar considerations and techniques would be employed for any of the other message bus systems supported by .NET Core libraries.</p>
<p>Surely, there are trade-offs when we implement this type of message-based communication. We now have an additional system and potential point of failure, so we must consider <a id="_idIndexMarker202"/>the<a id="_idIndexMarker203"/> additional infrastructural requirements. We also see that the code required adds more complexity to our code base. Let us dive into some of the disadvantages of this approach.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Disadvantages of asynchronous communication between microservices</h1>
<p>As with any <a id="_idIndexMarker204"/>system or programming method, there are always advantages and disadvantages that come with the territory. We have already explored why having an asynchronous messaging pattern is a good idea for operations that might be long-running. We need to ensure that the end user doesn’t spend too much time waiting on an entire operation to be completed. Messaging systems are an excellent way to shorten the perceived time it takes to complete an operation and allows services to operate as efficiently as possible on their own. They also aid in decoupling systems, allowing for greater scalability and introducing a certain level of stability to a system where data transfer and processing are concerned.</p>
<p>Now, disadvantages creep in when we analyze the real level of complexity that this pattern can introduce. Far more coordination needs to be considered when designing how our services interact with others, what data they need to share, and what events need to be posted when operations are completed. In the synchronous model, we will be more sure of tasks getting completed down the line, since we cannot move forward without a favorable response from the next service along the chain. In the asynchronous model using queues and buses, we have to rely on the consuming service(s) posting an event regarding the state of completion. We also have to ensure that there are no repeated calls and, in some cases, need to make a concerted effort to ensure that messages are processed in a specific order.</p>
<p>This brings us to another disadvantage in the form of data consistency. Remember that the initial response from the message bus suggests that the operation is successful, but this just means that data was successfully submitted to the bus. After this, our consuming services still need to follow through and complete their operations. If one or more of these services fails to process and potentially submits the data to a data store, then we'll end up with inconsistency in our data. This is something to be mindful of, as it can lead to<a id="_idIndexMarker205"/> detrimental side effects and user attrition.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Summary</h1>
<p>In this chapter, we explored a few things. We did a blow-by-blow comparison of how a process would be handled through synchronous API communication versus asynchronous communication. We then expanded our general knowledge of how messaging systems can be leveraged to support an asynchronous communication model for our services. In all of this, we discussed challenges that we can face with data consistency between operations and how we can gauge acceptable metrics for this unavoidable factor. In the latter parts, we reviewed two popular messaging systems and then discussed some of the outright disadvantages that we have to contend with in this paradigm.</p>
<p>In our next chapter, we will explore the <strong class="bold">Command-Query Responsibility Segregation</strong> (<strong class="bold">CQRS</strong>) pattern and how it helps us to write cleaner code in our services.</p>
</div>
</body></html>