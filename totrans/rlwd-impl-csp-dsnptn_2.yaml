- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Prepping for Practical Real-World Applications of Patterns in C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为C#中模式的实际现实世界应用做准备
- en: Becoming a prepper
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为预备者
- en: 'You may think that because I was born in Oklahoma and live in Texas, I could
    be one of those crazy people who runs around in the woods preparing for the imminent
    end of the world. Hey, let’s try to keep my personal life out of this! However,
    when I tell you that I want you to become a prepper, it has nothing to do with
    a conspiracy theory or end-of-times rhetoric. Instead, it has to do with a fundamental
    transformation that is likely to be happening in your professional life. Unlike
    the radical political transformations that concern most real-world preppers, ours
    are hopefully fully beneficial, with the aim to make us better at our craft. This
    chapter is geared toward preparing you to use patterns. Relying on patterns to
    improve your code doesn’t make sense if the code you’re working with doesn’t conform
    to the following conditions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，因为我出生在俄克拉荷马州，住在德克萨斯州，我可能是那些在树林里四处奔跑，为即将到来的世界末日做准备的那些疯狂的人之一。嘿，让我们尽量把我的个人生活排除在外！然而，当我告诉你我想让你成为一个预备者时，这和阴谋论或末日言论无关。相反，这与你职业生活中可能发生的根本性转变有关。与大多数现实世界预备者所关心的激进政治转变不同，我们希望的是完全有益的转变，目的是让我们在技艺上更加出色。本章旨在为你准备使用模式。如果你正在处理的代码不符合以下条件，那么依赖模式来改进你的代码是没有意义的：
- en: Sports a high level of organization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有高度的组织性
- en: Structured for modification with minimal risk
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以最小风险进行结构化修改
- en: Testable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Measurable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可衡量性
- en: So, you need to prepare. Think of it as though you were sanding down rough spots
    on a piece of wood before painting it. The patterns are the paint; if you apply
    the paint before sanding, all the rough spots are going to stand out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要做好准备。想象一下，你正在打磨一块木头上的粗糙部分，然后再上漆。模式就是油漆；如果你在上漆之前打磨，所有的粗糙部分都会突出出来。
- en: Consider this chapter an explanation of why the code at your company is the
    way it is. If you work at Microsoft, Google, Apple, Meta, Twitter, or Amazon,
    your code is likely in good shape. You need to understand that a high-quality
    code base doesn’t happen by accident, nor is it immune to the same chaotic forces
    that plague the physical universe. Entropy isn’t limited to the concerns of thermodynamics
    in some distant stellar nebulae. It’s happening all the time in your code and
    you must learn to recognize it and work diligently to fix it or fend it off.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章视为解释你公司代码现状的原因。如果你在微软、谷歌、苹果、Meta、推特或亚马逊工作，你的代码可能状况良好。你需要明白，高质量的代码库不是偶然出现的，它也并非对困扰物理宇宙的相同混乱力量免疫。熵并不仅限于遥远星云中热力学的关注。它一直在你的代码中发生，你必须学会识别它，并勤奋地修复或抵御它。
- en: 'If you work at one of the other 99.99% of the companies in the world that creates
    software as a normal part of doing business, there might be some unrecognized
    opportunities for improvement. Let’s look at what we’re covering in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在世界其他99.99%的公司中工作，这些公司通常将软件开发作为业务的一部分，可能存在一些未被认识到的改进机会。让我们看看本章我们将涵盖的内容：
- en: Spaghetti < lasagna < ravioli – software evolution explained with pasta
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意大利面比千层面更比意大利肉丸——用意大利面解释软件演变
- en: The foundational principle – writing clean code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本原则——编写干净的代码
- en: Creating maintainable systems using SOLID principles
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SOLID原则创建可维护的系统
- en: Measuring quality
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 衡量质量
- en: 'When you reach the end of the chapter, you’ll be able to do the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读到本章的结尾时，你将能够做到以下几件事情：
- en: Identify some common metaphors for poorly constructed code, as well as exemplary
    code.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别一些拙劣构建的代码的常见隐喻，以及典范代码。
- en: Articulate the importance of good basic coding habits as the key to the success
    of your project and applying code. Patterns make your code better, but only if
    it’s clean code.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阐述良好的基本编码习惯作为你项目成功和代码应用的关键。模式可以使你的代码变得更好，但前提是它是干净的代码。
- en: Apply SOLID principles to your code and your design process.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SOLID原则应用于你的代码和设计过程。
- en: Identify the most common software metrics so we can understand when our code
    is more likely good than bad.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别最常见的软件度量标准，以便我们了解何时我们的代码更有可能是好的而不是坏的。
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter presents some code samples. They are geared toward demonstrating
    some of the concepts we’re going to be covering. I’m not sure they are exciting
    enough to make you want to recreate the projects yourself, but you are welcome
    to do so. Should you decide to try any of this out, you’ll need the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示一些代码示例。它们旨在展示我们将要讨论的一些概念。我不确定它们是否足够吸引人，让你想要自己重新创建项目，但欢迎你这样做。如果你决定尝试任何这些内容，你需要以下这些：
- en: A computer running the Windows operating system. I’m using Windows 10.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Windows 操作系统的计算机。我正在使用 Windows 10。
- en: A supported IDE such as Visual Studio 2022, JetBrains Rider, or Visual Studio
    Code with C# extensions.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的 IDE，例如带有 C# 扩展的 Visual Studio 2022、JetBrains Rider 或 Visual Studio Code。
- en: .NET Core 6 SDK.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 6 SDK.
- en: Spaghetti < lasagna < ravioli – software evolution explained with pasta
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意大利面 < 千层面 < 饺子 – 用意大利面解释软件演化
- en: The first part of any prepping journey involves securing your food supply. Real-world
    preppers love pasta because it’s portable and keeps without refrigeration. So,
    let’s start with pasta.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 任何准备之旅的第一部分涉及确保你的食物供应。现实世界的准备者喜欢意大利面，因为它便于携带且无需冷藏。所以，让我们从意大利面开始。
- en: The title of [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016) was *Why Is There
    a Big Ball of Mud on Your Plate of Spaghetti?* I never mentioned spaghetti. I
    didn’t need to. It’s such an obvious descriptive metaphor for a chaotic mess that
    it likely needs little further discussion. Spaghetti code is actually mentioned
    in the original publication of the *Big Ball of Mud* antipattern. What a lot of
    developers don’t see is that spaghetti code is a symptom. It isn’t the disease
    itself. The real diseases are the antipatterns. It is possible to have multiple
    infections ransacking your body at the same time. It is equally as possible for
    your code to be similarly and simultaneously inflicted with multiple antipatterns.
    You can gauge your code’s health by deciding where your code lies on the pasta
    spectrum..
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第一章*](B18605_01.xhtml#_idTextAnchor016) 的标题是 *为什么你的意大利面盘上有一个大泥球？* 我从未提到过意大利面。我不需要。它是一个如此明显的描述性隐喻，用来形容混乱的混乱，可能不需要进一步的讨论。实际上，意大利面代码在
    *Big Ball of Mud* 反模式的原版出版物中就有提及。许多开发者没有看到的是，意大利面代码是一个症状，而不是疾病本身。真正的疾病是反模式。你的身体可能同时受到多种感染的侵袭。同样，你的代码也可能同时受到多种反模式的侵害。你可以通过决定你的代码在意大利面谱系中的位置来衡量你代码的健康状况。'
- en: Spaghetti code
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意大利面代码
- en: Spaghetti code is characterized as chaotic, poorly organized, hard to follow,
    and impossible to maintain. The more spaghetti you have, the worse it is. As soon
    as spaghetti appears, it tends to spread rapidly. We’ve also compared code architecture
    to a physical building’s architecture in the previous chapter. There is a well-known
    principle from the field of criminology called *the broken windows theory*. The
    theory postulates that outward signs of crime, anti-social behavior, civil disobedience,
    or visible urban decay encourage further crime, particularly vandalism. A building
    with one broken window will soon have all its windows broken because it’s clear
    that you can get away with throwing rocks with no repercussions. Who doesn’t enjoy
    breaking Windows? Microsoft does it all the time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码被描述为混乱、组织不良、难以跟随和难以维护。意大利面越多，情况越糟糕。一旦出现意大利面代码，它往往会迅速扩散。我们也在上一章中将代码架构与物理建筑的架构进行了比较。犯罪学领域有一个著名的原理，称为*破碎窗户理论*。该理论假设犯罪的外在迹象、反社会行为、公民不服从或明显的城市衰败会鼓励进一步的犯罪，尤其是破坏行为。一栋有一扇破碎窗户的建筑很快就会所有窗户都破碎，因为很明显你可以扔石头而不受任何后果。谁不喜欢打破窗户呢？微软经常这样做。
- en: Your code is the same way. If you allow just one broken window, your code is
    no longer clean. You need to correct the situation immediately or it won’t be
    long before all you have in your code repository is a Big Ball of Mud on your
    plate of spaghetti.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码也是如此。如果你允许一扇破碎的窗户，你的代码就不再干净。你需要立即纠正这种情况，否则不久你的代码库中就只剩下你盘上的大泥球了。
- en: Maybe running fast and loose has paid off so far. Maybe it allowed you to get
    your software to market ahead of any competitors. Maybe your bosses and stakeholders
    are impressed with the velocity and small turnaround time on your initial releases.
    All that feels pretty good. What’s really happening is that you’re being rewarded
    for throwing rocks at your own windows. You’re sacrificing long-term profit for
    short-term gain.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可能到目前为止，快速行动已经得到了回报。可能它让你能够将软件提前推向市场，领先于任何竞争对手。可能你的老板和利益相关者对你的初始发布速度和短周期周转时间印象深刻。所有这些都感觉很好。实际上发生的是，你正在因为砸自己的窗户而得到奖励。你正在牺牲长期利润以换取短期收益。
- en: You need to get out of the spaghetti production business entirely.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要完全退出意大利面生产业务。
- en: Lasagna code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 千层面代码
- en: The logical step up from spaghetti code is lasagna. Most characterizations of
    lasagna code say that it is the object-oriented version of spaghetti. I don’t
    necessarily agree. Lasagna itself consists of many of the same ingredients found
    in spaghetti. It’s still noodles, tomato sauce, spices, and often meat or vegetables.
    The difference is in how it’s organized. Instead of hundreds of intertwined chaotic
    structures of noodles that can only be tamed by twirling them on a spoon, lasagna
    uses big noodles that serve as boundaries between discrete layers. Many of the
    layers are composed of the same stuff as the other layers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从意大利面代码到千层面代码的逻辑步骤。大多数对千层面代码的描述都说它是意大利面的面向对象版本。我并不完全同意。千层面本身由许多与意大利面相同的成分组成。它仍然是面条、番茄酱、香料，通常还有肉类或蔬菜。区别在于它的组织方式。千层面不是通过在勺子上旋转来驯服的数百个相互交织的混乱面条结构，而是使用大面条作为离散层之间的边界。许多层由与其他层相同的东西组成。
- en: 'In software, layered code fixes the spaghetti code into many small classes.
    Using lasagna as a metaphor for software cropped up around 1982, as the industry
    was beginning to move to a new hardware architecture. We were moving away from
    big-iron monolithic mainframes to something called **client-server**. The mainframes
    of the day required a financial commitment similar to that of the GDP of several
    small European countries combined. Client-server systems, on the other hand, were
    affordable for a reasonably well-funded small business. The systems consisted
    of a powerful server, servicing multiple clients, taking the form of less powerful
    computers. Does this sound familiar? It’s the same model used by the internet.
    The difference is that networking technology is now universal, exponentially better,
    faster, and more reliable. Spoiler alert: **cloud computing** is not a new concept.
    It’s just a marketing term for work done on other people’s computers.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件领域，分层代码将意大利面式的代码整理成许多小的类。将千层面作为软件的隐喻出现在1982年左右，当时行业正开始转向新的硬件架构。我们正从大型铁块式的单体主机转向所谓的**客户端-服务器**架构。当时的单体主机需要类似于几个小型欧洲国家GDP总和的财务投入。另一方面，对于资金合理充足的小型企业来说，客户端-服务器系统是负担得起的。这些系统由一个强大的服务器组成，为多个客户端提供服务，其形式是较不强大的计算机。这听起来熟悉吗？这正是互联网所使用的相同模式。不同之处在于，网络技术现在已经普及，指数级地更好、更快、更可靠。剧透一下：**云计算**不是一个新概念。它只是对在他人计算机上完成的工作的一种营销术语。
- en: It’s worth noting that the 1980s also brought us the first forays into object-oriented
    programming. I doubt Java was even a glimmer in James Gosling’s eye then, and
    the inventor of C#, Anders Hejlsberg, was still in college. However, Bjarne Stroustrup
    began working on **C++** in 1979 while working at AT&T Bell Labs. He based C++
    on the C language. C is a strictly procedural language designed to control telecommunications
    switching networks. Stroustrup reimagined this language by bolting on object orientation
    by way of classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，20世纪80年代还带给我们对面向对象编程的首次尝试。我怀疑当时詹姆斯·高斯林甚至还没有想到Java，C#的发明者安德斯·海尔斯伯格当时还在上大学。然而，Bjarne
    Stroustrup在1979年，在AT&T贝尔实验室工作时，开始研究**C++**。C++基于C语言。C是一种严格的过程式语言，旨在控制电信交换网络。Stroustrup通过将面向对象通过类的方式附加到这种语言上，重新构想了这个语言。
- en: C++ was released to the world in 1985 when Stroustrup published a textbook on
    the language. Those of you who were not yet born now understand that the 80s brought
    us more than just hairbands, Madonna wannabes, *The Karate Kid*, and Valley girls.
    It brought a whole new way of thinking about and designing software. It was a
    mere coincidence that we looked fabulous while doing it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C++在1985年由斯特劳斯特普发布了一本关于该语言的书后，向世界发布。那些当时还没有出生的人现在明白，80年代带给我们的不仅仅是发带、麦当娜的模仿者、《功夫小子》和山谷女孩。它带来了一种全新的思考软件和设计软件的方式。我们在做的时候看起来很棒，这仅仅是一个巧合。
- en: The hardware shift toward client-server necessitated a change in software design
    practices, as we considered what pieces should run on servers and which on clients.
    We started seeing something that we call **separation of concerns** today. When
    done well, separation of concerns is a really good idea. When done poorly, it
    creates lasagna.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 向客户端-服务器硬件转移的需要促使软件设计实践发生变化，因为我们考虑哪些部分应该在服务器上运行，哪些应该在客户端运行。我们开始看到我们现在称之为**关注点分离**的东西。当做得好的时候，关注点分离是一个非常不错的想法。当做得不好的时候，它会产生类似千层面的问题。
- en: 'Lasagna doesn’t usually begin as lasagna. A software developer thoughtfully
    lays out a layered architecture that separates components of the overall system
    into layers called *tiers*. Here’s an example of a common four-tier architecture
    design:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 千层面通常不会一开始就是千层面。一位软件开发者深思熟虑地设计了一个分层架构，将整个系统的组件分离成称为**层**的层级。以下是一个常见的四层架构设计示例：
- en: '![Figure 2.1 – A common four-tiered architecture ](img/B18605_Figure_2.1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 常见的四层架构](img/B18605_Figure_2.1.jpg)'
- en: Figure 2.1 – A common four-tiered architecture
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 常见的四层架构
- en: This is exactly the kind of architecture we see in modern mobile applications.
    The presentation layer is the app you downloaded from the app store, which runs
    on your phone, while the remaining tiers run invisibly in the cloud.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在现代移动应用中看到的这种架构。表示层是您从应用商店下载的应用程序，它在您的手机上运行，而其余的层级则在云中无形地运行。
- en: Since the separation exists at the hardware level, it makes sense to think about
    making software in a set of layers that mirrors the systems running the program.
    The presentation layer is the **view**, or the part of the program interacting
    with the users. The business rules layer implements the logic that drives what
    the presentation layer displays. It draws information from the persistence layer,
    which is responsible for storing and retrieving data. Some of this might be stored
    as files, or in memory, but some data will undoubtedly be at the lowest level
    in a database. All communication between the layers should move through each layer
    above it or below it, depending on the direction of flow for the data. As these
    layers become more and more complicated, it is easy for functionality to start
    bleeding out of the intended layer into other layers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分离存在于硬件级别，因此考虑以一组层来构建软件，这些层反映了运行程序的系统，是有意义的。表示层是**视图**，或与用户交互的程序部分。业务规则层实现了驱动表示层显示的逻辑。它从负责存储和检索数据的持久层获取信息。其中一些可能以文件形式存储或在内存中，但无疑一些数据将在数据库的最低级别。层与层之间的所有通信都应该通过它上面的每一层或下面的每一层进行，具体取决于数据流的方向。随着这些层变得越来越复杂，功能开始从预期的层渗出到其他层是很常见的事情。
- en: Imagine you need a quick fix for the way something is displayed in the UI. Maybe
    you want to show something in one way to an administrative user, and another way
    to a regular user. The right way to effect this change might be to alter a rule
    in the business rule layer, but it’s easier and faster to slap something directly
    into the UI. You’ve just broken a window. It’s no big deal; you tell yourself
    you’ll fix it later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要快速修复UI中显示方式的问题。也许你想要以某种方式向管理员用户显示某些内容，而以另一种方式向普通用户显示。实现这种更改的正确方式可能是更改业务规则层中的一个规则，但直接将某些内容直接粘贴到UI中更容易、更快。你刚刚打破了一个窗户。这没什么大不了的；你告诉自己你以后会修复它。
- en: In other scenarios, lasagna can be the result of an overcorrection. Take a programmer
    who writes spaghetti code in a procedural language such as C, then give them an
    object-oriented language such as C++ or C#. Now, add a book on patterns. The natural
    inclination of the programmer will likely be the same as yours the first time
    you realized that you could use different fonts in *PowerPoint*. One font is good;
    therefore,, all 25 on your computer must be better! Naturally, you start creating
    presentations that try to use as many fonts as possible. Patterns are an amazing
    tool. They are meant to guide you toward clean architecture the way fonts, used
    sparingly, should add emphasis, clarity, and aesthetics to a presentation. Patterns
    aren’t meant to be a prison.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，千层面可能是由过度修正造成的。以一个在C这样的过程式语言中编写意大利面代码的程序员为例，然后给他们提供一个面向对象的编程语言，如C++或C#。现在，再加上一本关于模式的书。程序员的自然倾向可能与你第一次意识到可以在*PowerPoint*中使用不同字体时的倾向相同！一个字体很好；因此，你电脑上的所有25个字体都必须更好！自然地，你开始创建尽可能使用尽可能多字体的演示文稿。模式是一个惊人的工具。它们旨在引导你走向干净的架构，就像字体，如果使用得当，应该为演示文稿增添强调、清晰度和美学。模式并不是为了成为监狱。
- en: The lasagna problem isn’t limited to large, multi-service programs. You’ll see
    it in smaller ones too, in the form of layers of inheritance. Inheritance is a
    foundational feature of object-oriented programming. If a language doesn’t support
    inheritance, it’s not in the club, and it can’t call itself object-oriented. Consider
    what the `NginxLogLine` class from the project in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016),
    *There’s a Big Ball of Mud on Your Plate of Spaghetti*, might look like after
    a few iterations of requirements gathering, coding, and releases. The use case
    I’m presenting here is pure fiction and doesn’t actually relate to the release
    history of NGINX’s log structure. I need a believable series of complications
    to help make my example work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拉斯agna问题不仅限于大型、多服务程序。你也会在较小的程序中看到它，以继承层的形式出现。继承是面向对象编程的基础特性。如果一个语言不支持继承，它就不在俱乐部里，而且它不能自称是面向对象的。考虑一下项目在[*第一章*](B18605_01.xhtml#_idTextAnchor016)，“你的意大利面盘上有一个大泥球”，在几次需求收集、编码和发布迭代后可能看起来像什么。我在这里提出的用例是纯粹的虚构，实际上并不与NGINX日志结构的发布历史相关。我需要一个可信的复杂系列来帮助使我的例子有效。
- en: 'Let’s say the code in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016) represents
    the first release. The client was thrilled and started coming up with new requirements,
    as the software was exposed to different business users in the real world. A shortlist
    of new requirements might be the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设[*第一章*](B18605_01.xhtml#_idTextAnchor016)中的代码代表第一次发布。客户非常高兴，并开始提出新的需求，因为软件在现实世界的不同商业用户中得到了应用。以下可能是一些新的需求清单：
- en: It was noted by some of the IT professionals using the program that while it
    works perfectly with the latest version of the web server software, it breaks
    when working with older versions because the log structure has changed several
    times over the last few years. We need to support the last major revision’s log
    format, as well as the most current.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些使用该程序的专业IT人员指出，虽然它与最新的网络服务器软件版本配合得很好，但在与较旧版本一起工作时会出现问题，因为日志结构在过去几年中已经改变了几次。我们需要支持最后主要修订版的日志格式，以及最新的格式。
- en: Users based in Asia noted that the text formatting in their log files is not
    supported because their text files are encoded using double-byte formats. We need
    to support international text formats.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于亚洲的用户指出，他们的日志文件中的文本格式不受支持，因为他们的文本文件使用双字节格式编码。我们需要支持国际文本格式。
- en: Another important IT group can’t even use your software because they don’t use
    NGINX exclusively. They also use Apache and they noted they have the same constraints.
    The log formats have changed over time, so they have several formats to consider,
    and they too need support for single- and double-byte text implementations.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个重要的IT团队甚至不能使用你的软件，因为他们并不完全使用NGINX。他们也使用Apache，并且他们指出他们也有相同的限制。日志格式随着时间的推移而改变，所以他们需要考虑几种格式，并且他们也需要对单字节和双字节文本实现的支持。
- en: Let me reiterate my earlier disclaimer. While I do know my way around a web
    server log, I am by no means a web server log aficionado. As a reminder, this
    is a fictitious cautionary tale. Any resemblance of our requirements to actual
    software requirements is purely coincidental. I further promise under the penalty
    of perjury that no cute and fluffy animals will be harmed in the equally fictitious
    production of said software. My lawyer wants me to add more, but my editor wants
    me to get on with it already and I learned early that my editor is always right.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我重申我之前的免责声明。虽然我对网络服务器日志有所了解，但绝对不是网络服务器日志爱好者。作为提醒，这是一个虚构的警示故事。我们需求的任何与实际软件需求相似之处纯属巧合。我进一步承诺，根据伪证罪的法律责任，不会在同样虚构的生产过程中伤害任何可爱而蓬松的动物。我的律师想让我添加更多内容，但我的编辑想让我继续前进，而且我早就知道我的编辑总是对的。
- en: Next, let’s suppose since there was zero inheritance used in the original code
    that maybe it was because we were new to C# and didn’t fully understand how to
    use inheritance. Now, suppose we bought a book from a publisher other than Packt.
    It was written by a university professor who has never published software in a
    commercial setting. This is common. They’ve never heard a pointy-haired boss who
    wielded godlike power over their livelihood tell them to clean up the prototype
    and ship it next week. At no point have they faced a deadline unrealistically
    dictated by a marketing department. In short, this book would be by an author
    who doesn’t work in the real world of software development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设原始代码中没有使用任何继承，这可能是因为我们刚开始接触C#，并没有完全理解如何使用继承。现在，假设我们从除了Packt以外的出版社买了一本书。这本书是由一位从未在商业环境中发布过软件的大学教授所写。这是很常见的。他们从未听到过一位像神一样拥有对他们生计绝对控制力的秃头老板告诉他们清理原型并在下周发货。他们从未面临过由营销部门不合理规定的截止日期。简而言之，这本书将由一位不从事实际软件开发工作的作者所写。
- en: 'This kind of author may have presented a muddy, overly academic picture of
    C#’s inheritance model, along with the academically perfect way to structure your
    code. They are basing their estimation on the available academic literature reviews,
    also written by university professors who have never actually worked in the field.
    Your young, sharp, supple, but impressionable mind might be persuaded by all the
    author’s academic credentials to make something similar to what follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种作者可能会展示一个关于C#继承模型的模糊、过于学术的画面，以及结构化代码的学术上完美的方式。他们基于可用的学术文献综述进行估计，这些综述也是由从未在实地工作过的大学教授所写。你年轻、敏锐、灵活，但容易受影响，可能会被作者的所有学术资历说服，做出以下类似的东西：
- en: '![Figure 2.2 – The UML equivalent of a dumpster fire next to a train wreck
    (this is an example of too much inheritance) ](img/B18605_Figure_2.2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 垃圾桶火灾旁边火车出轨的UML等效图（这是过度继承的一个例子）](img/B18605_Figure_2.2.jpg)'
- en: Figure 2.2 – The UML equivalent of a dumpster fire next to a train wreck (this
    is an example of too much inheritance)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 垃圾桶火灾旁边火车出轨的UML等效图（这是过度继承的一个例子）
- en: This is a poorly constructed inheritance chain represented using the **Unified
    Modeling Language** (**UML**). If you’ve never seen a UML class diagram before,
    you should jump to [*Appendix 2*](B18605_Appendix_2.xhtml#_idTextAnchor204) at
    the end of the book. It has an overview of how to draw and interpret these diagrams.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条用**统一建模语言**（**UML**）表示的构建不良的继承链。如果你之前从未见过UML类图，你应该跳转到书的末尾的[*附录2*](B18605_Appendix_2.xhtml#_idTextAnchor204)。那里有如何绘制和解释这些图的概述。
- en: The inheritance chain represented in the diagram goes deeper than is necessary,
    The design goal can be accomplished more cleanly by using tools such as interfaces
    and techniques such as composition. You’re also staring at the beginning of class
    proliferation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图中表示的继承链比必要的更深，可以通过使用接口等工具和组合等技术更干净地实现设计目标。你也在目睹类膨胀的开始。
- en: Class proliferation happens when you find yourself needing to add more and more
    classes to support new requirements. This sets us up for a classic stovepipe design.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要添加越来越多的类来支持新的需求时，就会发生类膨胀。这使我们陷入了经典的烟囱式设计。
- en: Too many layers of inheritance, especially when functionality that belongs in
    one class slowly bleeds into other classes over time, will yield lasagna.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 过多的继承层，尤其是当属于一个类的功能随着时间的推移慢慢渗入其他类时，会产生千层面。
- en: If only we had yet another pasta metaphor that is delicious and satisfying,
    but less deleterious to the work-life balance of whoever has to maintain what
    we’ve created thus far…
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还有另一个美味且令人满意的意面隐喻，但对我们所创造的东西的维护者来说不那么有害于工作与生活的平衡，那会怎么样呢……
- en: Ravioli – the ultimate in pasta code
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ravioli – 意面代码的极致
- en: While everybody loves spaghetti and lasagna, you don’t want them showing up
    in your code. Ravioli, on the other hand, is something we aspire toward.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个人都喜欢意大利面和千层面，但你不想它们出现在你的代码中。另一方面，Ravioli 是我们向往的东西。
- en: When we make ravioli, it is again comprised of the same set of ingredients used
    to make spaghetti and lasagna. Again, the difference is in the configuration of
    the materials. The noodles now form a full boundary around the deliciousness inside.
    The meat or cheese within the noodle is fully encapsulated, with the content only
    ever being exposed when it is consumed. There’s probably also a delicious sauce
    on the outside that brings the whole dish together into something that’s not chaotic
    and not unnecessarily dense.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们制作 Ravioli 时，它仍然由制作意大利面和千层面所用的相同成分组成。再次强调，区别在于材料的配置。现在面条形成了一个围绕美味内部的完整边界。面条内的肉或奶酪被完全封装，内容只有在被消费时才会暴露。可能还有美味的酱汁在外面，将整个菜肴融合成一个既不混乱也不过于密集的整体。
- en: 'It is also worth noting that the level of effort needed to shape and stuff
    the noodles is a lot more work than simply boiling a handful of straight noodles.
    Making ravioli, as with good object-oriented code, requires patience and work.
    The idea of ravioli is the epitome of pasta object-oriented design if you remember
    the foundational pillars used to previously describe object-oriented design:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，塑造和填充面条所需的努力远远超过简单地煮一撮直面条。制作 Ravioli，就像编写优秀的面向对象代码一样，需要耐心和努力。如果你还记得之前用来描述面向对象设计的基石，Ravioli
    的理念是意面面向对象设计的典范：
- en: Encapsulation is used to limit access to an object’s state.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装用于限制对对象状态的访问。
- en: Abstraction refers to a class modeling a real-world object with only the level
    of detail needed by the software. If we were to write software that needed a `Person`
    class to model a human being, the `Person` class would be modeled differently
    in a medical records application than it would in a phone book application.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象指的是一个类仅用软件所需的细节级别来模拟现实世界中的对象。如果我们编写需要 `Person` 类来模拟人的软件，`Person` 类在病历应用中的建模方式将与电话簿应用中的建模方式不同。
- en: Inheritance allows common structures between classes to be shared in a parent
    class, negating the need to copy the same code repeatedly between classes.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承允许在父类中共享类之间的公共结构，从而消除了在类之间重复复制相同代码的需要。
- en: Polymorphism allows a class designer to defer implementing abstracted details
    to concrete classes. For example, an abstract `Vehicle` class might have a `Go()`
    method. The `Go()` method would work very differently for concrete classes such
    as a car versus a boat, a skateboard, a submarine, or an airplane. Polymorphism
    allows us to create the appropriate implementation at the concrete level but define
    it at the abstract level.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态允许类设计者将抽象的细节推迟到具体类中实现。例如，一个抽象的 `Vehicle` 类可能有一个 `Go()` 方法。对于具体的类，如汽车、船、滑板、潜艇或飞机，`Go()`
    方法的工作方式会有很大不同。多态允许我们在具体级别创建适当的实现，但在抽象级别定义它。
- en: We need to talk a little more about encapsulation with specific regard to C#.
    In well-designed object-oriented code, objects are encapsulated. This means the
    object’s state is closely guarded. Only the instance should be allowed to alter
    its own internal state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要就封装进行更多讨论，特别是针对 C#。在设计良好的面向对象代码中，对象是封装的。这意味着对象的状态受到严密保护。只有实例应该被允许改变其自身的内部状态。
- en: By contrast, poorly constructed code allows for objects to directly change the
    state of other objects. Auto-implemented properties in C# make this very easy
    by making properties no better than fields. If every property is public, and there
    are no rules, as is the case with auto-implemented properties, any object can
    change the state of any other object. We can compound the problem with a long
    inheritance chain, where every property at every level is public, internal, or
    protected. When this is the case, any object at any level can impose state changes
    up or down the inheritance chain. This makes it difficult to track what is changing
    each object’s state and under what circumstances. State changes bleeding between
    layers is the very definition of lasagna.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，结构不良的代码允许对象直接改变其他对象的状态。在C#中，自动实现的属性使得这一点变得非常容易，因为属性并不比字段更好。如果每个属性都是公共的，并且没有任何规则，就像自动实现的属性那样，任何对象都可以改变任何其他对象的状态。我们可以通过一个长的继承链来加剧这个问题，其中每一层的每个属性都是公共的、内部的或受保护的。在这种情况下，任何层的任何对象都可以在继承链的上下方向施加状态变化。这使得跟踪每个对象状态的变化及其发生的条件变得困难。层与层之间状态变化的泄露正是lasagna的定义。
- en: If your code is similar to ravioli, each instance of each object stands alone
    as a fully encapsulated class with limited inheritance. It is the master of its
    own state, and it meticulously and entirely controls that state. Since these objects
    bear all these hallmarks, you can easily leverage composition to build complex
    objects instead of relying solely on inheritance to define the behavior of an
    object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码类似于ravioli，每个对象的每个实例都是一个完全封装的类，具有有限的继承。它是自己状态的主宰，并且细致入微地完全控制着那个状态。由于这些对象都具有这些特征，你可以轻松利用组合来构建复杂对象，而不是仅仅依赖继承来定义对象的行为。
- en: Composition is a technique focusing on building objects out of other objects.
    Composition works best when we use interfaces to define how these objects fit
    together. An interface defines the structure of an object. Think of it as a mechanical
    socket such as a light socket. You can plug any bulb into that socket, provided
    it fits. What makes it fit is the definition presented by the dimensions of the
    socket. Interfaces in C# can define a set of properties and methods that an object
    is expected to have. Any object that fits the specification can be used just as
    a bulb fitting into a socket would.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种将对象构建成其他对象的技术。当我们使用接口来定义这些对象如何组合在一起时，组合效果最佳。接口定义了对象的结构。把它想象成一个机械插座，比如灯座。只要它适合，你可以把任何灯泡插入那个插座。使其适合的是插座尺寸的定义。C#中的接口可以定义一组属性和方法，对象预期应该具有这些属性和方法。任何符合规格的对象都可以像灯泡插入插座一样被使用。
- en: Imagine a set of classes designed to model an automobile. There are lots of
    different kinds of cars. There are sports cars, family sedans, minivans, and my
    personal favorite, the Jeep. All of these cars are very different. We could try
    to come up with an inheritance chain to tie them all together in a familial hierarchy.
    I suspect though, that if you limited your design to strictly inheritance, you’d
    wind up with hundreds of classes. The resulting code would be a messy, muddy plate
    of pasta.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一组设计用来模拟汽车的类。有很多不同种类的汽车。有跑车、家庭轿车、微型面包车，以及我个人的最爱，吉普车。所有这些汽车都非常不同。我们试图提出一个继承链来将它们全部联系在一起，形成一个家族等级。但我怀疑，如果你将设计限制在严格的继承上，你最终会得到数百个类。结果代码将是一盘混乱、泥泞的意大利面。
- en: A better idea is to use composition. We can keep our abstract car model, but
    instead of making subclasses, we can add interfaces to define the characteristics
    of the car. For example, we can make an interface for each component that defines
    a car. For example, we can make an interface that defines an engine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的想法是使用组合。我们可以保留我们的抽象汽车模型，但不是创建子类，而是可以添加接口来定义汽车的特征。例如，我们可以为每个组件创建一个定义汽车的接口。例如，我们可以创建一个定义发动机的接口。
- en: We can also create an interface that defines the transmission. There is a huge
    difference between the transmission of a family sedan, a high-end sports car,
    and a 4x4 off-road vehicle. However, it is possible to define a common set of
    properties and methods. Any transmission object I can model will slot into my
    car object, provided it follows the required interface.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个定义传输的接口。家庭轿车、高端跑车和4x4越野车的传输之间存在着巨大的差异。然而，我们可以定义一组通用的属性和方法。只要遵循所需的接口，我可以建模的任何传输对象都可以适配到我的汽车对象中。
- en: If I were to sum up the job of an object-oriented developer, and I were only
    allowed one sentence, I would say that our job is to always ensure that no object
    should ever be allowed to fall into an invalid state. I’ll expand on this idea
    in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我必须用一句话总结面向对象开发者的工作，并且只允许我说一句话，我会说我们的工作始终确保没有任何对象应该被允许进入一个无效状态。我将在下一节中扩展这个想法。
- en: The foundational principle – writing clean code
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本原则——编写干净代码
- en: The main point of presenting the topics in this chapter is to set a boundary.
    You can master all the patterns in this book and more, but if your software is
    poorly written, overly clever, haphazardly structured, or hard to maintain, then
    all the patterns in the world can’t help you. Let’s set some boundaries. I’m going
    to suggest some guidelines for creating “clean code.” You are welcome to argue
    the minutiae. It doesn’t bother me one bit if we differ in opinion over tabs versus
    spaces as long as you have a method to your particular flavor of madness. Let’s
    paint some broad strokes that hopefully everyone can agree with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍主题的主要目的是设定一个边界。你可以掌握这本书中的所有模式以及更多，但如果你的软件编写得不好，过于聪明，结构混乱，或者难以维护，那么世界上所有的模式都无法帮助你。让我们设定一些边界。我将提出一些创建“干净代码”的指导方针。你可以就细节进行争论。只要你有自己疯狂风格的方法，我们对于制表符与空格的看法不同，我一点也不介意。让我们画一些大家都可能同意的大致轮廓。
- en: 'Clean code has the following characteristics:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 干净代码具有以下特点：
- en: Easily readable by human beings with limited cognitive load
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对认知负荷有限的人类易于阅读
- en: Consistent in style
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风格一致
- en: Documented with an appropriate level of commentary
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以适当的注释进行文档化
- en: You should write code that is readable by humans
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该编写人类可读的代码
- en: 'I feel as though this isn’t as obvious as it should be. We write code to be
    compiled and executed by machines who don’t care for the expressiveness we use
    when we write our code. Writing code is writing language. Human languages are
    expressive and so are humans. We can take our written languages and create a business
    email indicating stock shortages, a medical report outlining potential patient
    outcomes following a diagnosis of dermatomyositis, a master’s thesis on molecular
    biology, a long-form romance novel, or even a haiku. Your computer languages are
    also expressive with their limited vocabulary. C# has 79 keywords. With those
    79 keywords, you can create everything from a short program to download your email
    to an entire operating system. It’s a powerful and expressive language. As long
    as you use valid syntax, the compiler will be happy. You need to focus your efforts
    on making your code readable to other people. I’ve always believed the golden
    rule applies here: *do unto others as you would have others do unto you.* You
    should treat everyone with the same level of respect you’d like to be treated
    to yourself. You should write code that requires minimal effort by others to scan
    and understand.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这并不像它应该的那样明显。我们编写代码是为了让机器编译和执行，这些机器并不关心我们编写代码时所使用的表达性。编写代码就是编写语言。人类语言是富有表现力的，人类也是。我们可以用我们的书面语言创建一封关于库存短缺的商业电子邮件，一份关于皮肤肌炎诊断后潜在患者结果的医学报告，一篇关于分子生物学的硕士论文，一部长篇浪漫小说，甚至是一首俳句。你的计算机语言也是有限的词汇量中的富有表现力的。C#
    有 79 个关键字。凭借这 79 个关键字，你可以创建从下载电子邮件的简短程序到整个操作系统的任何东西。它是一种强大且富有表现力的语言。只要你的代码对其他人来说是可读的，你就需要集中精力。我一直相信黄金法则在这里适用：*己所不欲，勿施于人.*你应该以你希望别人如何对待你的同样的尊重来对待每个人。你应该编写其他人扫描和理解所需努力最少的代码。
- en: 'This starts with the way you name classes, variables, methods, and the other
    elements used to create your software. If the names represent the intent for how
    those elements are used, you’ve taken a step toward creating code that is more
    readable and more maintainable. Some staples of best practice include the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这从你命名类、变量、方法和用于创建你的软件的其他元素的方式开始。如果这些名称代表了这些元素的使用意图，你就朝着创建更易读和更易于维护的代码迈出了一步。以下是一些最佳实践的基本要素：
- en: Name your elements so that their intended use is intuitive. `this.pn` is not
    intuitive. You can likely think of a dozen things it might be. If we’d used `this.phoneNumber`,
    you wouldn’t have to guess.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的元素命名，使其使用目的直观。`this.pn` 并不直观。你可能能想到它可能代表的一打事物。如果我们使用了 `this.phoneNumber`，你就不需要猜测了。
- en: Create names that are searchable. `MAX_FILES_PER_UPLOAD` defined as a constant
    makes it easy to find in your code, especially if you’re using an IDE that indexes
    your code.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可搜索的名称。将 `MAX_FILES_PER_UPLOAD` 定义为常量，使得在代码中查找它变得容易，尤其是如果你使用的是索引你的代码的 IDE。
- en: Leave outdated encodings to the old-timers. You likely don’t do things like
    this unless you are very (how can we say it nicely?) seasoned. A long time ago,
    in this very galaxy, we learned to create variable names using codes. I don’t
    mean programming code; I mean codes as in Hungarian notation. This was before
    we had type-checking IDEs. It reminds me of Garrison Keeler’s *Lake Wobegon* podcasts
    where he spun tales of a simpler time. We wrote in simple console editors such
    as *vi* and *emacs* and we liked it that way. We might as well have been using
    *Notepad* with our fingers tied together. Back then, we didn’t have *Roslyn* looking
    over our shoulders and pointing out our missteps. We needed a way to tell which
    data type was used in our variables, so we’d call a variable `intAge` or maybe
    `iAge`. As I said, you probably don’t do this anymore unless you were taught this
    way. If you were taught this way, kindly knock it off. Thank you.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将过时的编码留给老一辈的人。除非你非常（我们如何优雅地说这个？）经验丰富，否则你很可能不会做这样的事情。很久以前，在这个星系中，我们学会了使用编码来创建变量名。我说的不是编程代码；我是指匈牙利命名法中的编码。那是在我们还没有类型检查
    IDE 的时候。这让我想起了加里森·凯勒的 *Lake Wobegon* 播客，他在那里讲述了一个更简单时代的传说。我们使用简单的控制台编辑器，如 *vi*
    和 *emacs*，并且我们喜欢这种方式。我们甚至可以像手被绑在一起一样使用 *Notepad*。当时，我们没有 *Roslyn* 在我们身后监督并指出我们的错误。我们需要一种方法来告诉我们变量中使用了哪种数据类型，所以我们可能会将变量命名为
    `intAge` 或 `iAge`。正如我说的，你可能不再这样做，除非你是这样被教导的。如果你是这样被教导的，请停止这样做。谢谢。
- en: Don’t bother with member prefixes or suffixes. It used to be common to prefix
    member variables with `m_`, for example. As with encodings, this kind of thing
    isn’t needed because we have good IDEs, and your classes should be short and discrete
    in function so that prefixes are not needed. Besides, after a while, people tend
    to ignore them as noise while scanning your code and they cease to be significant.
    I’ve seen university professors teach it this way for a long time. I might have
    been one of them. I’m not proud of it, but that was a long time ago and I’ve moved
    on since then. The exception that I still observe is the common custom of naming
    private fields with an initial underscore. I think most people do that so they
    can name the field something obvious that matches the property name where they
    intend to expose the field.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用成员前缀或后缀。过去，通常会在成员变量前加上前缀 `m_`，例如。与编码一样，这类事情并不需要，因为我们有好的集成开发环境（IDE），而且你的类应该短小且功能明确，这样就不需要前缀。此外，过了一段时间后，人们在浏览你的代码时往往会忽略它们，因为它们不再具有意义。我见过大学教授长时间这样教。我可能就是其中之一。我不为此感到自豪，但那已经是很久以前的事情了，自从那时起我就已经有所进步。我仍然观察到的例外是，通常用初始下划线命名私有字段。我认为大多数人这样做是为了让他们能够给字段起一个明显的名字，以匹配他们打算公开的字段名。
- en: Use parts of speech in your code. Your objects are nouns. They represent people,
    places, and things. Name them as such. `Person` makes for a good abstract class
    name, which might be extended in `Student` and `Professor`. Class names that contain
    verbs as part of the name, such as a class named `ParseLogLines`, become confusing
    as class names. Naming the class `LogLineParser` is clearer because it sounds
    like a thing rather than an action. Within classes, the methods are your verbs,
    so name them that way. `ParseLogLines` totally works as a method name. If you
    pay attention to these details, your code will wind up reading as a normal sentence
    would, albeit with odd but understandable punctuation.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中使用词性。你的对象是名词。它们代表人、地点和事物。按照这样的方式命名它们。`Person` 是一个很好的抽象类名称，它可能会在 `Student`
    和 `Professor` 中扩展。包含动词作为名称一部分的类名，例如名为 `ParseLogLines` 的类，作为类名来说会让人困惑。将类命名为 `LogLineParser`
    更清晰，因为它听起来像是一个事物而不是一个动作。在类内部，方法是动词，所以按照这种方式命名它们。`ParseLogLines` 完全可以作为方法名。如果你注意这些细节，你的代码最终会像正常句子一样阅读，尽管带有一些奇怪但可以理解的标点符号。
- en: '**Don’t Repeat Yourself** (**DRY**). By this, I mean don’t write the same code
    twice. Also, don’t duplicate anything, and never repeat something you’ve already
    written. Dang it, sorry about that. I see this most often when people are in a
    hurry. They’ve got some code in another project or another part of their current
    project but it’s not written in a way that is conducive to reuse, so they copy
    and paste it into different programs or different parts of the same program. This
    is a broken window. Soon, your code will not be DRY; it’ll be wetter than an octopus’
    belly button, and that kind of thing will be everywhere.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）。我的意思是不要重复编写相同的代码。也不要重复任何东西，永远不要重复你已经写过的内容。真是抱歉，我经常看到人们在匆忙中这样做。他们可能在另一个项目或当前项目的另一部分中有一些代码，但编写的方式不利于重用，所以他们将其复制粘贴到不同的程序或同一程序的不同部分。这是一个破损的窗户。很快，你的代码将不再遵循DRY原则；它将比章鱼肚脐眼还要湿，而且这种事情会无处不在。'
- en: Get rid of dead code. This is a huge pet peeve for me. Once I was working as
    a Java developer. I know, I was young and I needed the money. I was pretty new
    to the job and we had a database function that wasn’t writing to the database
    as expected. I’d change the method around and run the tests. Same result. Eventually,
    I decided to make a silly, ridiculous big change. Nothing. I was working on a
    method called `WriteInventoryPartToDatabase`. OK, that seems well named. It seemed
    to be an obvious place to look for the problem. After an hour or so, I realized
    the method I was working on was *old code* and that the actual method I needed
    had been moved to another class. The developer who moved the method kept the old
    method in place *just in case* and never cleaned it up later. OK, people. This
    is why revision control systems exist. You can always go back. Don’t be lazy.
    If you delete or remove something, don’t just change it in the calling method.
    Get rid of the dead parts or someone else will potentially spend a lot of time
    on a red herring.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除死代码。这是我的一大烦恼。有一次，我作为一名Java开发者工作。我知道，我那时年轻，需要钱。我对这份工作相当陌生，我们有一个数据库函数没有按预期写入数据库。我修改了方法并运行了测试。结果相同。最终，我决定做一个愚蠢、荒谬的大改动。没有任何变化。我正在处理一个名为`WriteInventoryPartToDatabase`的方法。好吧，这个名字听起来很合适。它似乎是一个寻找问题的明显地方。大约一个小时后，我意识到我正在处理的是*旧代码*，而我真正需要的方法已经被移动到另一个类中。移动方法的开发者保留了旧方法以备不时之需，但后来从未清理过。好吧，人们。这就是版本控制系统存在的原因。你可以随时回退。不要偷懒。如果你删除或移除了某些内容，不要只是更改调用方法中的内容。移除死代码部分，否则其他人可能会在一条死胡同上浪费大量时间。
- en: 'Format your code for human consumption. Something such as this should be an
    anathema to your very being:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化你的代码以便人类阅读。以下这种代码应该让你感到厌恶：
- en: '[PRE0]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our IDEs have gotten pretty good at defaulting to fonts that help us detect
    the differences between zeros and capital Os, and lowercase Ls and 1s. Options
    such as turning on font ligatures help even more. Ligatures are improved fonts
    that show you a more expressive set of characters. For example, look at the way
    `!=` is rendered in *CaskaydiaCove Nerd* Font from [nerfonts.com](http://nerfonts.com).
    It appears as `≠`, which is the way your high school math teacher presented it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的IDE已经非常擅长默认使用帮助我们检测零和O大写字母、小写L和大写1之间差异的字体。开启字体连字符等选项可以提供更多帮助。连字符字体是改进后的字体，可以显示一组更具表现力的字符。例如，看看
    *CaskaydiaCove Nerd* 字体中`!=`的渲染方式来自[nerfonts.com](http://nerfonts.com)。它显示为`≠`，这是你高中数学老师展示的方式：
- en: '![Figure 2.3 – An IDE with font ligatures turned on displaying !=  ](img/B18605_Figure_2.3.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 开启字体连字符的IDE显示!=](img/B18605_Figure_2.3.jpg)'
- en: Figure 2.3 – An IDE with font ligatures turned on displaying !=
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 开启字体连字符的IDE显示!=
- en: 'You can turn these on in your IDE. In Visual Studio, you just set the font
    to one that supports ligatures:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的集成开发环境（IDE）中开启这些功能。在Visual Studio中，你只需将字体设置为支持连字符的字体：
- en: '![Figure 2.4 – In Visual Studio, simply set the font in the Options window
    to one that supports ligatures, such as CaskaydiaCove Nerd Font Mono, which you
    can find free at nerdfonts.com ](img/B18605_Figure_2.4.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 在Visual Studio中，只需在“选项”窗口中将字体设置为支持连字符的字体，例如CaskaydiaCove Nerd Font
    Mono，你可以在nerdfonts.com免费找到它](img/B18605_Figure_2.4.jpg)'
- en: Figure 2.4 – In Visual Studio, simply set the font in the Options window to
    one that supports ligatures, such as CaskaydiaCove Nerd Font Mono, which you can
    find free at nerdfonts.com
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 在Visual Studio中，只需在“选项”窗口中将字体设置为支持连字符的字体，例如CaskaydiaCove Nerd Font Mono，你可以在nerdfonts.com免费找到它
- en: 'In *JetBrains Rider*, you have an actual setting:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *JetBrains Rider* 中，你有一个实际的设置：
- en: '![Figure 2.5 – JetBrains Rider IDE settings for fonts allow you to specifically
    turn ligatures on and off ](img/B18605_Figure_2.5.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – JetBrains Rider IDE 字体设置允许您特别开启和关闭连字符](img/B18605_Figure_2.5.jpg)'
- en: Figure 2.5 – JetBrains Rider IDE settings for fonts allow you to specifically
    turn ligatures on and off
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – JetBrains Rider IDE 字体设置允许您特别开启和关闭连字符
- en: 'If you prefer *Visual Studio Code*, you’ll need to edit your `settings.json`
    file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢 *Visual Studio Code*，你需要编辑你的 `settings.json` 文件：
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The IDE’s normal coloring helps too, except when you’re reading a book printed
    in grayscale 😊.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 的常规配色也有帮助，除非你在阅读以灰度打印的书本 😊。
- en: The previous bullet points are guidelines for writing code for human consumption.
    These tips will help you as we move into the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的要点是编写供人类消费的代码的指南。这些提示将帮助我们在进入下一节时。
- en: Establishing and enforcing style and consistency
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立和执行风格和一致性
- en: You should be using a set of conventions for consistently naming elements of
    your code, as well as applying a consistent coding style. If you do this well,
    you won’t be able to tell where your code ends and someone else’s starts. I’m
    not going to dedicate time to recommending coding conventions, as these are well
    established in the industry. Some such conventions are baked into the IDEs, such
    as curly braces always dropping to a new line, For the rest, you can use an automation
    tool such as JetBrains’ *ReSharper*, *Prettier* for *Visual Studio Code*, or the
    open source project called *StyleCop*. All of these have tools that allow you
    to add style enforcement to the IDE, as well as the ability to run a check when
    you commit your code to a **Continuous Integration** (**CI**) server. Mavericks
    who aren’t using the proper styling will fail their builds, giving everyone else
    on the team the opportunity to help them see the error of their ways.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用一套约定来一致地命名代码元素，以及应用一致的编码风格。如果你做得好，你将无法分辨出你的代码在哪里结束，别人的代码在哪里开始。我不会花时间去推荐编码约定，因为这些在业界已经确立。一些这样的约定已经内置到
    IDE 中，例如花括号总是换行，对于其他部分，你可以使用自动化工具，如 JetBrains 的 *ReSharper*，*Prettier* 用于 *Visual
    Studio Code*，或者开源项目 *StyleCop*。所有这些都有工具允许你在 IDE 中添加风格强制，以及在你将代码提交到 **持续集成** (**CI**)
    服务器时运行检查。那些没有使用适当样式的马大哈会失败构建，给团队中的其他人一个机会帮助他们看到错误。
- en: Limiting cognitive load
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制认知负荷
- en: The problem isn’t that the poorly written code is unintelligible. The problem
    is that it’s unscannable. One thing I’ve noticed over the years is that, regrettably,
    I no longer read entire paragraphs in prose anymore. Granted, it’s rare that I
    read books with zero code in them. Over the years, my brain has adapted to reading
    code, so I scan. If you’ve also been reading code for a while, you probably do
    it too even if you don’t realize it. Remember this and work toward making your
    code scannable. If you can just look at it and think *OK, got it. Next?*, then
    it’s easy to scan and understand. The opposite is having to stare at some code
    for seconds or minutes in order to decode it in your brain. It takes a noticeable
    and uncomfortable amount of time to figure out what it means and what it does.
    Psychologists refer to this as **cognitive load**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于编写糟糕的代码难以理解。问题在于它难以阅读。多年来，我注意到遗憾的是，我不再阅读整段散文了。当然，我很少读完全没有代码的书。多年来，我的大脑已经适应了阅读代码，所以我扫描。如果你也阅读代码有一段时间了，你可能也在这样做，即使你没有意识到。记住这一点，努力使你的代码易于阅读。如果你只需看一眼就能想“好的，明白了。下一个？”，那么它就很容易阅读和理解。相反，你必须盯着一些代码几秒钟或几分钟，才能在你的大脑中解码它。弄清楚它的含义和作用需要明显且不舒服的时间。心理学家将这称为**认知负荷**。
- en: 'Try this instead:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这样做：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s better. No more thinking. Save that for when you really need it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。不再需要思考。保留它，等你真正需要的时候再用。
- en: Terse is worse
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简洁是更糟的
- en: 'Speaking of cognitive load, I know a lot of developers who love terse syntax.
    Let me show you what I mean. I found a perfect example on Stack Overflow at [https://stackoverflow.com/questions/7103979/nested-ternary-operators/7104091#7104091](https://stackoverflow.com/questions/7103979/nested-ternary-operators/7104091#7104091):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 说到认知负荷，我知道很多开发者喜欢简洁的语法。让我给你举个例子。我在 Stack Overflow 上找到了一个完美的例子，在 [https://stackoverflow.com/questions/7103979/nested-ternary-operators/7104091#7104091](https://stackoverflow.com/questions/7103979/nested-ternary-operators/7104091#7104091)：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s so terse that it’s impossible to scan. You’re going to have to hunker down
    for a good few minutes to even figure out what it does. Some developers think
    writing code in this way makes them appear smarter than everyone else. It doesn’t.
    This would be similar to an English writer who is overtly sycophantic and obsequious
    toward their quasi-internalized sesquipedalian. Did you get all that, or did your
    eyes scan back across the sentence a few times? I could have simply said, “*This
    would be the same as an English writer who goes out of their way to give in to
    the obsessive use of long words.*” Good writers can write to be understood by
    a university-educated audience, which is to say, their peers. Great writers can
    write the same content to be understood by a group of talented sixth graders.
    This takes as much concentrated effort as writing tersely, but you can do the
    same thing with your code and everybody charged with maintenance will thank you
    for it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它如此简短，以至于无法扫描。你可能需要坐下来几分钟才能弄清楚它做什么。一些开发者认为以这种方式编写代码使他们看起来比其他人聪明。事实并非如此。这就像一个英语作家过分谄媚和顺从地使用长词。你明白了吗，或者你的眼睛是不是扫了几次这句话？我可以说，“*这就像一个英语作家故意迎合过度使用长词的倾向。*”优秀的作家可以写出让受过大学教育的人群理解的文章，也就是说，他们的同行。伟大的作家可以用同样的内容让一群有才华的六年级学生理解。这需要与简洁写作一样多的集中精力，但你可以用你的代码做到这一点，所有负责维护的人都会为此感谢你。
- en: 'Let’s refactor it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构它：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Bam! Welcome to the least sexy code ever written. If you post it to Reddit,
    the best you can hope for is the occasional *meh* amidst a litany of trollish
    comments, not all of which are limited to your code. That said, now you can scan
    it, and the rules governing setting the default phone number are fairly obvious.
    This is true because while the terse code was bad, we did at least use obvious
    object and property names to indicate proper intent.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 嘭！欢迎来到最不吸引人的代码。如果你把它发到 Reddit 上，你最好的希望是在一长串恶评中偶尔得到一个“嗯”的评论，而这些评论并不局限于你的代码。话虽如此，现在你可以扫描它了，管理设置默认电话号码的规则相当明显。这是因为虽然代码简短是坏事，但我们至少使用了明显的对象和属性名称来表示正确的意图。
- en: Comment but don’t go overboard
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释，但不要过度
- en: Commenting on your code is good. I’ve read academic articles that present solid
    arguments for as much as one-third of your lines of code being devoted to comments.
    The problem with this is the practice is dangerously close to writing documentation,
    and the only thing programmers hate more than writing documentation is directly
    interacting with users. Good news – if you write clean code using the ideas I’ve
    stressed so far, you can get away with fewer comments because your code will already
    be easy to read.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注释你的代码是好的。我读过一些学术论文，它们提出了多达三分之一的代码行用于注释的坚实论据。问题是这种做法危险地接近编写文档，而程序员最讨厌的事情莫过于直接与用户互动。好消息是——如果你使用我之前强调的想法编写干净代码，你可以减少注释，因为你的代码本身已经很容易阅读。
- en: I think a happy medium is represented by a comment containing a brief restatement
    of the requirements. If your requirements are documented in an online system as
    they should be, you could even link to the requirement.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一个合适的平衡点是通过注释简要重申需求来实现的。如果你的需求已经按照应有的方式记录在在线系统中，你甚至可以链接到该需求。
- en: 'I also comment on anything that isn’t obvious, such as my motivations for writing
    something a certain way. This is a useful comment: *I’m doing it this way because
    our suppliers require data to be in this format.* This way, my team doesn’t come
    in behind me, see something they think needs refactoring, but wind up breaking
    code that conforms to customer requirements.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会对任何不明显的东西进行注释，比如我为什么以某种方式编写某段代码的动机。这是一个有用的注释：*我这样做是因为我们的供应商要求数据以这种格式存储。*
    这样，我的团队在我之后进来，看到他们认为需要重构的东西，但最终破坏了符合客户要求的代码。
- en: Comments go bad when there are too many of them. Commenting every line is silly
    unless you’re writing a book, or teaching a class for beginners who are learning
    to read code for the first time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当注释过多时，注释就会变得糟糕。除非你正在写一本书，或者教授初学者阅读代码，否则逐行注释是愚蠢的。
- en: Creating maintainable systems using SOLID principles
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SOLID 原则创建可维护的系统
- en: 'SOLID is a reference to the top five principles of **Object-Oriented Design**
    (**OOD**):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 是指面向对象设计（OOD）的前五个原则：
- en: The Single Responsibility principle
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The Open-Closed principle
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放-封闭原则
- en: The Liskov Substitution principle
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liskov 替换原则
- en: The Interface Segregation principle
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The Dependency Inversion principle
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: Following these principles will allow you to create systems that are robust,
    extensible, and maintainable. Honoring these principles prepares you well for
    working with patterns because many patterns are built on or reference these principles.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些原则将允许你创建健壮、可扩展和可维护的系统。遵守这些原则为你使用模式做好了充分的准备，因为许多模式都是基于或引用这些原则的。
- en: The Single Responsibility principle
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Every method should do one thing. Every class should represent one thing. We
    call this idea the **Single Responsibility Principle** (**SRP**). If you have
    a method inside an object that does many things without invoking outside methods,
    your method is doing too much and runs the risk of becoming an example of the
    antipattern known as *the god function*. These are big, messy piles of inedible
    pasta. Once, I got a desperate text from a colleague. Her program was crashing.
    She couldn’t figure out why. I looked. The entire program was in one file that
    when printed out was over 20 pages long. There were nine functions in the whole
    program. I closed the project, deferring the review for a time when I could sit
    down and go through it in earnest. I highly suspected she was ignoring the SRP.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都应该只做一件事。每个类都应该代表一件事。我们称这个想法为**单一职责原则**（**SRP**）。如果你在对象内部有一个方法做了很多事，而没有调用外部方法，那么你的方法就做得太多了，存在变成被称为*神函数*的反模式例子的风险。这些都是大杂烩，难以消化的意大利面。有一次，我收到一位同事的绝望短信。她的程序崩溃了。她不知道为什么。我检查了一下。整个程序都在一个文件里，打印出来超过20页长。整个程序有九个函数。我关闭了项目，推迟了审查，等到我可以坐下来认真处理的时候再进行。我高度怀疑她忽略了SRP。
- en: 'Let’s look at an example of a method that does too much:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个过度设计的例子：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve started a function that’s clearly going to do too much. We begin by opening
    a text file on our computer’s hard drive and reading in the first line. Next,
    let’s read through each line in the file, and send each line of text to a fictitious
    online service that translates the text into another language.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始了一个明显会做很多事的功能。我们首先在我们的电脑硬盘上打开一个文本文件，并读取第一行。接下来，让我们逐行读取文件中的每一行，并将每一行文本发送到一个虚构的在线服务，该服务将文本翻译成另一种语言。
- en: 'To be valid, the sentence needs the text to be trimmed, all uppercase, and
    there can be no semicolons in there because the service’s author got hacked by
    SQL injection once, and he vowed never again:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效，句子需要文本被修剪，全部大写，并且其中不能有分号，因为服务的作者曾经被SQL注入攻击过一次，他发誓再也不这样做了：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, the text is ready. Let’s transmit it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，文本准备好了。让我们发送它：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ve transmitted the data; let’s parse out the response and print it to the
    console:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经传输了数据；让我们解析响应并将其打印到控制台：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Read the next line, rinse, and repeat until we reach the end of the file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 读取下一行，清洗，重复，直到我们到达文件的末尾：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you open it, you should close it, so let’s clean up after ourselves:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开了它，你应该关闭它，所以让我们清理一下：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Can you see the problem here? We have one method performing many operations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在这里看到问题吗？我们有一个方法执行了多项操作：
- en: We open a file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开一个文件。
- en: We process each line.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理每一行。
- en: We transmit to the service.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将信息传输到服务端。
- en: We process the results.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理结果。
- en: Each of these should be separated into its own method. When you do this, you
    can reuse the methods in other contexts to solve other problems. Reading a file
    is generic. It’s the kind of thing you’d do often. So is sanitizing your input
    string. So is posting to a `RESTful` endpoint. You can’t reuse the `doesTooMuch()`
    method. It’s too specific to a single point of implementation. In [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063),
    *Getting Creative with Creational Patterns*, we’re going to take off the training
    wheels and start learning patterns. Patterns are utterly incompatible with god
    methods of this kind.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都应该被分离到它们自己的方法中。当你这样做时，你可以在其他上下文中重用这些方法来解决其他问题。读取文件是通用的。这是你经常要做的事情。同样，清理你的输入字符串也是。同样，向`RESTful`端点发送也是。你不能重用`doesTooMuch()`方法。它太具体于一个实现点。在[*第3章*](B18605_03.xhtml#_idTextAnchor063)，“用创建型模式发挥创意”中，我们将摘掉训练轮子，开始学习模式。模式与这种类型的神函数完全不相容。
- en: The Open-Closed Principle
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: Classes should be open for extension but closed for modification. This is called
    the **Open-Closed Principle** (**OCP**). This is especially true of software that’s
    already in production. You’ve got a set of well-written, fully tested production
    classes. Messing around with the wiring introduces the risk of breaking something.
    When new code can be written as an extension to what you already have, the risk
    is limited to the extension.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类应该对扩展开放，但对修改封闭。这被称为**开放封闭原则**（**OCP**）。这对于已经投入生产的软件尤其如此。你已经有一组编写良好、完全测试的生产类。乱动连接会引入破坏东西的风险。当新代码可以作为现有代码的扩展来编写时，风险就限制在扩展上了。
- en: 'Let’s look at an example by looking at code that violates the OCP. We’re going
    to make a simple utility designed to add up the areas of a set of geometric shapes.
    For our initial release, we’ll support circles and squares. I’ll represent the
    `Circle` library this way:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看违反OCP的代码示例来分析一下。我们将创建一个简单的实用工具，用于计算一组几何形状的面积总和。对于我们的初始版本，我们将支持圆形和正方形。我将这样表示`Circle`库：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I’ve set this up with an `Area` property that is read-only. There is no reason
    to allow someone to set the property directly. Instead, I use the constructor
    to force you to define the radius of the circle on instantiation. This prevents
    you from setting `Area` to whatever the heck you feel like, which might result
    in the object entering an invalid state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经设置了一个只读的`Area`属性。没有理由允许某人直接设置该属性。相反，我使用构造函数强制你在实例化时定义圆的半径。这防止了你将`Area`设置为任何你想要的东西，这可能会导致对象进入无效状态。
- en: When you instantiate, you pass in the radius, which is all we need to find the
    area of the circle. Good old *π • r²,* or the constant pi times the radius squared.
    The area is set automatically.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化时，你传入半径，这是我们找到圆面积所需的所有信息。古老的*π•r²*，或者常数π乘以半径的平方。面积会自动设置。
- en: 'We can do something similar with a square. We only need to know the length
    of one side:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方法处理正方形。我们只需要知道一边的长度：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As before, we present an `area` property as read-only and use the constructor
    to set the area automatically upon instantiation by multiplying the `lengthOfOneSide`
    argument by itself.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将`area`属性作为只读属性提供，并使用构造函数在实例化时自动设置面积，通过将`lengthOfOneSide`参数自乘来实现。
- en: 'Now, I have two classes to represent my shapes and each has an `area` property
    set automatically on instantiation. All I need is a class to glue them together:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我有两个类来表示我的形状，每个类在实例化时都会自动设置`area`属性。我需要的只是一个将它们粘合在一起的类：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have a class called `AreaCalcuator` with an `area` property. On this
    one, I chose to create a backing variable to make it easy to keep a running total.
    Each time you add either a square or a circle using the twice-overloaded `AddShape`
    method, it takes the area computed on instantiation and adds it to the total.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个名为`AreaCalculator`的类，它有一个`area`属性。在这个例子中，我选择创建一个后端变量，以便更容易地保持运行总账。每次使用两次重载的`AddShape`方法添加正方形或圆形时，它都会将实例化时计算的面积添加到总和中。
- en: 'I can test its function with code as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用以下代码测试其功能：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks pretty good! Ship it already! All is well until our delighted customer
    returns with a request to support more shapes. It’s not hard, is it? Maybe all
    they want is a rectangle. All I need to do is make a `Rectangle` class, then modify
    the `AreaCalculator` class with another constructor.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当不错！现在就发货吧！一切顺利，直到我们高兴的客户回来要求支持更多形状。这难道不难吗？也许他们只是想要一个矩形。我需要做的就是创建一个`Rectangle`类，然后修改`AreaCalculator`类以添加另一个构造函数。
- en: If I do this, I am violating the OCP because I have to change the `AreaCalculator`
    class directly every time we get a new shape requirement. I should design it so
    that you can pass in anything with an `area` property on it, then I would never
    have to alter `AreaCalculator` ever again. Let’s fix it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我这样做，我就违反了OCP，因为每次我们得到新的形状要求时，都必须直接更改`AreaCalculator`类。我应该设计它，以便你可以传递任何具有`area`属性的任何东西，这样我就永远不需要再次更改`AreaCalculator`了。让我们修复它。
- en: 'I’ll make an interface to define my requirement for an `Area` property:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个接口来定义我对`Area`属性的要求：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let’s modify the shape classes to implement the interface. This is easy
    since both already have the `area` property exposed in a way that satisfies the
    requirements of the interface.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改形状类以实现接口。这很简单，因为它们都已经以符合接口要求的方式公开了`area`属性。
- en: 'First, let’s do the circle:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看圆形：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I renamed the class `OCPCircle` so that I wouldn’t get them mixed up. Now,
    let’s do the square:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我将类名重命名为 `OCPCircle`，这样我就不会弄混它们了。现在，让我们来做正方形：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, I’ll modify the `AreaCalculator` class to use the interface as its type
    on the `AddShape` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将修改 `AreaCalculator` 类，使其在 `AddShape` 方法上使用接口作为其类型：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Awesome! Now, we never need to alter this method in this class again. It is
    open for extension and closed for modification. To honor any new requirement for
    any shape, I need only add a new class that implements the `IShapeWithArea` interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们再也不需要修改这个类中的这个方法了。它是可扩展的，但不可修改。为了满足任何新形状的要求，我只需要添加一个新的类来实现 `IShapeWithArea`
    接口。
- en: 'I’ll go ahead and add a rectangle class that implements the same `IShapeWithArea`
    interface:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加一个实现相同 `IShapeWithArea` 接口的矩形类：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It doesn’t matter what the clients ask for next. Adding support for a hexagon,
    rhombus, or dodecagon is a simple matter of Googling the area formula for that
    shape and making a new class that implements our interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何客户接下来会提出什么要求，添加对六边形、菱形或十二边形的支持只是简单地通过谷歌搜索该形状的面积公式，然后创建一个新的类来实现我们的接口。
- en: The Liskov Substitution principle
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利斯科夫替换原则
- en: In 1988, Barbara Liskov delivered a keynote speech at a conference titled *Data
    Abstraction and Hierarchy*, wherein she introduced what came to be called the
    **Liskov Substitution Principle** (**LSP**).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在1988年，芭芭拉·利斯科夫在一场名为 *数据抽象和层次结构* 的会议上发表了主题演讲，其中她介绍了后来被称为 **利斯科夫替换原则**（**LSP**）的概念。
- en: The principle states that any object of a subtype should be a suitable and working
    substitute for its superclass. This really relies on inheritance more than anything
    else. Using the strategy I just showed you, which is to rely more on interfaces
    than inheritance, you’ll not likely run afoul of the LSP. By now, you’ve no doubt
    surmised that I enjoy breaking rules (ask anyone), so let’s break this one.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则指出，任何子类的对象都应该是一个合适的、可以工作的其超类替代品。这实际上更多地依赖于继承。使用我刚刚展示的策略，即更多地依赖接口而不是继承，你不太可能违反LSP。到现在，你无疑已经推测出我喜欢打破规则（问问任何人），所以让我们打破这个规则。
- en: 'The requirements I’m working toward are similar but not identical to the last
    example. Here, I have a requirement to compute the area of rectangles – just rectangles.
    To make this work, pretend that I didn’t show you the best solution already in
    the last example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在努力实现的需求与上一个例子相似，但并不完全相同。在这里，我有一个计算矩形面积的要求——仅仅是矩形。为了使这可行，假设我没有在上一个例子中展示出最佳解决方案：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I was a little less cautious this time. I used normal auto-implemented properties
    for the width and height rather than a constructor. If I’m breaking rules, I may
    as well let my hair down entirely. The `Area` property is suitably encapsulated,
    so you can’t get up to anything too nefarious here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我这次稍微不那么谨慎了。我使用了正常的自动实现属性来设置宽度和高度，而不是构造函数。如果我正在违反规则，我干脆完全放松。`Area` 属性得到了适当的封装，所以你在这里不会做出什么太过分的事情。
- en: 'Now, let’s make a class to handle adding up areas of rectangles in a very similar
    fashion to our last example for the OCP:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个类来处理以与上一个例子中处理 OCP 的方式非常相似的方式来计算矩形的面积：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s pretty straightforward. Not even an hour after you create this, the ubiquitous
    pointy-haired boss tells you about a requirements change. You need to support
    a square too.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。在你创建这个类不到一个小时后，那位无处不在的爱出风头的老板告诉你有需求变更。你需要支持正方形。
- en: 'No problem, you think. A square IS A rectangle. Obviously, we can do this with
    inheritance. Perhaps we don’t need any change at all, but the pointy-haired boss
    must be appeased. I highlighted the IS A term earlier because this phrase characterizes
    inheritance, and it happens to be true. A square IS A rectangle. We make the class.
    Since we’re using inheritance, we need to make a quick change to the `Rectangle`
    class so that it can support inheritance. We’ll make the properties virtual so
    that we can override them in the subclass if we need to:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，没问题。正方形是矩形的一种。显然，我们可以通过继承来实现这一点。也许我们根本不需要做任何改变，但那位爱出风头的老板必须得到安抚。我之前已经强调了“是”这个术语，因为这个短语描述了继承，而且确实如此。正方形是矩形的一种。我们创建了这个类。由于我们正在使用继承，我们需要快速修改一下
    `Rectangle` 类，以便它能够支持继承。我们将属性设置为虚拟的，这样我们就可以在子类中覆盖它们，如果需要的话：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The thing about the square is that it is rectangular, but we only need the
    length of one side to compute the area. The parent class, `Rectangle`, requires
    the length of two sides. Suddenly, things are starting to look a little ugly.
    Let’s think while we type:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于正方形的事情是，它实际上是矩形的，但我们只需要一边的长度来计算面积。父类`Rectangle`需要两边的长度。突然，事情开始看起来有点难看。让我们在打字的同时思考：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I had this great idea! We could fix it so that we have a backing variable. Any
    time you modify the width or height, the `accessor` method simply changes the
    backing variable, which is referenced by the getter on the `Area` property. Since
    both the width and height are set to the same thing, multiplying width times height
    will give us the area of the square. It doesn’t mess up the whole rectangle class
    needing both values. I would now like you to visit YouTube and search for *Guinness
    beer commercial brilliant*. Pick any video with the cartoonish-looking guys. I’ll
    wait. Brilliant! This calls for celebration, perhaps even a libation. Will it
    work? Of course it will. I’ll ship it and feel extra special today, as though
    I got away with something naughty because I was clever. In fact, right now might
    be a good time to go do my taxes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个很棒的想法！我们可以修复它，以便我们有一个后备变量。每次你修改宽度或高度时，`accessor`方法只是简单地改变后备变量，该变量由`Area`属性的getter引用。由于宽度和高度都设置为相同的东西，乘以宽度乘以高度将给出正方形的面积。它不会弄乱整个矩形类需要两个值。现在，我想让你访问YouTube并搜索*Guinness啤酒商业广告精彩*。挑选任何看起来滑稽的视频。我会等着。太棒了！这需要庆祝，也许甚至需要一杯饮料。它会起作用吗？当然会的。我今天会发货，感觉特别特别，就像我因为聪明而逃脱了什么淘气的事情一样。事实上，现在可能是一个去交税的好时机。
- en: Meanwhile, in a totally different department, the newbie developer recently
    hired by the pointy-haired boss wrestles with a similar requirement. Naturally,
    we want to reuse as much as we can. The newbie takes your code but does something
    totally unexpected. The requirements make it necessary to change the numbers for
    the width and height. Never mind why. Do you know what happened to the last newbie
    that questioned the veracity of the pointy-haired boss’ technical direction? They’re
    in a basement cubicle without air conditioning somewhere hot and humid, working
    on ways to speed up bubble sort algorithms using Z80 assembly language on punched
    cards. Their breakroom is devoid of a latte machine. They don’t even get Herman
    Miller chairs. It’s downright barbaric. You don’t want that to be you, right?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在完全不同的部门，最近被尖头老板雇佣的新手开发者正在与一个类似的要求作斗争。自然，我们想要尽可能多地重用代码。新手拿走了你的代码，但做了完全出乎意料的事情。要求必须更改宽度和高度的数字。不管为什么。你知道上一个质疑尖头老板技术方向的真实性的新手发生了什么事吗？他们在某个又热又潮湿的地方的一个地下室隔间里，没有空调，正在尝试使用Z80汇编语言在穿孔卡片上加快冒泡排序算法。他们的休息室里没有咖啡机。他们甚至没有赫曼·米勒椅子。这简直是野蛮。你不想成为那样的人，对吧？
- en: 'Here’s the newbie’s code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新手的代码：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Brilliant? Maybe, but probably not. Some requirement is forcing the newbie to
    change the values of width and height independently within the superclass. This
    is not a problem for the `Rectangle` superclass, which is designed for this kind
    of thing. However, this will absolutely break the square implementation when you
    try to substitute the square for the rectangle, despite the obvious IS A relationship
    between a square and a rectangle.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 棒吗？也许吧，但可能不是。某些要求迫使新手在超类中独立更改宽度和高度的值。对于设计用于此类事情的`Rectangle`超类来说，这不是问题。然而，当你尝试用正方形替换矩形时，这绝对会破坏正方形的实现，尽管正方形和矩形之间有明显的“是”关系。
- en: 'If you’re familiar with the Darwin Awards, you’ll know that every winner utters
    the same phrase before embarking upon whatever it is that won them the award.
    In Texas, or pretty much any southern state, it happens as follows: *Hey, y’all?
    Hold my beer and watch this.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉达尔文奖，你就会知道，每个获奖者在开始他们获得奖项的事情之前都会说出同样的话。在德克萨斯州，或者几乎任何南方州，事情是这样的：*嘿，大家？拿着我的啤酒，看着这个*。
- en: I’m going to show you an example of Liskov substitution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给你展示一个Liskov替换的例子。
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So far, so good. Everything works. This next part is where it breaks:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。一切正常工作。接下来的这部分是它开始出错的地方：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we pass a square to `AddShape`, we get an answer that isn’t 200\. It comes
    out as 400, which causes the error to be thrown.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个正方形传递给`AddShape`，我们得到的答案不是200。它变成了400，这导致抛出了错误。
- en: Because our intrepid newbie needed to change the `base` class to modify the
    values independently, we broke the LSP, which says we must be able to substitute
    the subclass, `Square`, for the superclass, `Rectangle`. While our sneaky overrides
    in the `Square` class seem clever, it doesn’t work for every case. You might say
    we’re trying to fit a square peg in a round hole. Then again, you might think
    better of it, ask for that beer back, and stare admiringly at the rugged simplicity
    of the earlier OCP solution with the interface, which is likely the best solution
    to this problem.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们勇敢的新手需要更改`base`类以独立修改值，我们打破了LSP（Liskov替换原则），它指出我们必须能够用子类`Square`替换父类`Rectangle`。虽然我们在`Square`类中的巧妙覆盖看起来很聪明，但这并不适用于所有情况。你可能会说我们试图将方钉塞入圆孔。然后，你可能会重新考虑，要求找回那杯啤酒，并赞赏地凝视着早期OCP（开闭原则）解决方案的简洁性，该解决方案可能是解决这个问题的最佳方案。
- en: You’ve now seen an example of broken Liskov substitution. No doubt you want
    to see it done well. I will be happy to oblige you in later chapters, which are
    chock-full of references to the LSP.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到了一个违反Liskov替换原则的例子。毫无疑问，你想要看到它被正确地实现。我很乐意在后面的章节中满足你的愿望，这些章节充满了对LSP的引用。
- en: The Interface Segregation principle
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: No class should be forced to implement an interface that it doesn’t use, nor
    should it depend on a method it doesn’t use. Don’t you hate it when this happens?
    You’re forced to use something you don’t need or want? This is undoubtedly how
    the newbie who blew it with the Liskov substitution problem felt. However, we’re
    coders, not psychologists, so let’s press on and expand upon the idea of railing
    against being forced to use things we don’t need via the **Interface Segregation
    Principle** (**ISP**).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类应该被迫实现它不使用的接口，也不应该依赖于它不使用的方法。你不讨厌这种情况吗？你被迫使用你不需要或想要的东西？毫无疑问，新手在Liskov替换问题上的失败就是这种感觉。然而，我们是程序员，不是心理学家，所以让我们继续前进，并扩展通过**接口隔离原则**（**ISP**）反对被迫使用我们不需要的东西的想法。
- en: Let’s say we get a new requirement that has us working with two- and three-dimensional
    shapes, where we need the area for two-dimensional shapes and the volume for three-dimensional
    shapes. Naturally, we want to stick with something that works, and the interface
    idea in the section on the OCP seemed to work so well that it proved useful in
    the Liskov scenario too.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们得到了一个新的需求，需要我们处理二维和三维形状，我们需要二维形状的面积和三维形状的体积。自然地，我们希望坚持使用有效的方法，并且OCP（开闭原则）部分中提到的接口想法似乎效果很好，这也证明了它在Liskov场景中的有用性。
- en: This time, the pointy-haired boss doesn’t give us a newbie – he gives us a seasoned
    veteran. Unfortunately, this seasoned veteran has a case of psychogenic blindness
    as a result of the *not invented by me* syndrome. This is to say that when he
    looks at any solution he didn’t invent personally, he instantly assumes said solution
    is flawed, and he expresses his disdain for the solution using colorful language
    commonly heard emanating from maritime professionals. In short, he cusses as though
    he were a sailor when he describes code that he didn’t write, even though the
    person who did write that code is probably a few cubes away. Since awkwardness
    means nothing to this guy, given he’s the smartest guy in the room, he decides
    he doesn’t need anything that we’ve written so far and he strikes out on his own.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，秃头老板没有给我们一个新手，而是给我们一个经验丰富的老兵。不幸的是，这位经验丰富的老兵患有由“不是我自己发明的”综合症引起的心理性失明。也就是说，当他看到任何他个人没有发明的解决方案时，他会立刻认为该解决方案有缺陷，并使用从海事专业人士那里常听到的一些色彩丰富的语言来表达他对该解决方案的蔑视。简而言之，当他描述他未编写的代码时，就像一个水手在诅咒，尽管编写该代码的人可能就在几个隔间之外。鉴于这个人对尴尬一无所知，因为他是最聪明的人，他决定我们之前写的任何东西他都不需要，于是他独自一人开始了自己的行动。
- en: 'He’s in a hurry and this work is beneath him anyway. He wants to get back to
    solving the traveling salesman problem and the n-body problem simultaneously with
    a runtime of O(log n). Your silly project is in the way. He half-heartedly types
    the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 他很匆忙，而且这项工作对他来说太简单了。他想回到同时解决旅行商问题和多体问题，并且运行时间为O(log n)。你的愚蠢项目挡了他的路。他半心半意地输入以下内容：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: OK, he wouldn’t call it `IPollutedShape`. I did that for you. I spent 3 years
    working in technical pre-sales and I learned something that stuck with me. Never
    let the truth or any sense of realism get in the way of a good story.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，他不会称之为`IPollutedShape`。我为你取了这个名字。我在技术预销售领域工作了3年，我学到了一些让我印象深刻的东西。永远不要让真相或任何现实主义阻碍一个好故事。
- en: You can see the problem without the implementation, right? If I made a `cube`
    or `cuboid` class that extends this interface, it’s fine. They’re both three-dimensional
    shapes and we need three dimensions to calculate volume.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不查看实现的情况下看到问题，对吧？如果我创建了一个扩展此接口的`cube`或`cuboid`类，那就没问题。它们都是三维形状，我们需要三个维度来计算体积。
- en: 'However, if we use the same interface with a two-dimensional shape, we’d be
    forced to have a `Depth` property, which has no place in such a class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用与二维形状相同的接口，我们就被迫有一个`Depth`属性，这在这样一个类中是没有位置的：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Yuck! We’ve got this extra property just sitting there doing nothing! It reminds
    me of that time my aunt Linda had spinach in her teeth. Whatever, we saved time
    by only making one interface. Our cocky super-coder can get back to picking up
    Sir Isaac Newton’s slack.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们得到了这个额外的属性，它在那里什么也没做！这让我想起了那次我的阿姨琳达嘴里有菠菜。不管怎样，我们只制作了一个接口就节省了时间。我们的自大的超级程序员可以回去填补艾萨克·牛顿的空白。
- en: We have now violated the ISP by forcing the use of a property or method that
    we don’t need. That other guy isn’t paying attention. Someone asked about how
    it is to be a graduate student at Carnegie Mellon, and there’s nothing he loves
    more than talking about his time in graduate school back when he was dumbing down
    his best work just so that his professors could understand his assignments. This
    is perfect. Let’s fix it while he’s not looking.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在违反了ISP，因为我们强制使用了一个我们不需要的属性或方法。那个家伙没有注意到。有人问卡内基梅隆大学的研究生生活是怎样的，他最喜欢谈论的是他读研究生时的时光，当时他简化了自己的最佳作品，以便教授们能理解他的作业。这太完美了。趁他没注意，让我们来修复它。
- en: 'Obviously, we need two interfaces. Unlike inheritance, where you can only have
    one superclass, you can implement multiple interfaces on one class. With C#, there’s
    an even cleaner way. Let’s make the interface for the two-dimensional shapes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要两个接口。与只能有一个超类的情况不同，你可以在一个类上实现多个接口。在C#中，有一个更干净的方法。让我们为二维形状制作接口：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we do this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们这样做：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That was easy. A three-dimensional shape uses all the same parts as a two-dimensional
    shape but adds depth. Let’s do this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。一个三维形状使用与二维形状相同的部件，但增加了深度。让我们来做这件事：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'C# allows inheritance in interfaces. I used the properties defined in the interface
    for two-dimensional shapes and extended it to require a property representing
    depth. Now, let’s type out the `cube` class for the win:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: C#允许在接口中使用继承。我使用了接口中定义的二维形状的属性，并将其扩展为需要表示深度的属性。现在，让我们输入`cube`类以获胜：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ta-da! We honor the ISP by only enforcing exactly what is needed and no more.
    There’s nothing wrong with stacking multiple interfaces if that’s your thing.
    You can also use inheritance in your interfaces, as I did.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们通过只强制执行所需的内容而没有更多内容来遵守ISP。如果你喜欢，堆叠多个接口没有问题。你还可以在你的接口中使用继承，就像我这样做的一样。
- en: The Dependency Inversion principle
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: When you first learn how to design an inheritance hierarchy, you learn that
    high-level objects establish a base, while low-level objects form dependencies
    on that base. The **Dependency Inversion Principle** (**DIP**) flips this upside
    down and forms the basis of a very important practice called **decoupling**. We
    saw the power of decoupling in the OCP example earlier. We learned how to use
    an interface to prevent a strong coupling between two concrete classes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次学习如何设计继承层次结构时，你会知道高级对象建立基础，而低级对象则在这个基础上形成依赖。**依赖倒置原则**（**DIP**）将这种关系颠倒过来，并形成了一种非常重要的实践——**解耦**的基础。我们在之前的OCP示例中看到了解耦的力量。我们学习了如何使用接口来防止两个具体类之间的强耦合。
- en: 'I am offering a note of caution. Dependency inversion on the surface sounds
    similar to **Dependency Injection** (**DI**). It also sounds similar to **Inversion
    of Control** (**IoC**). These are not identical concepts. Given that we just talked
    about Liskov substitution, you should understand that they are not interchangeable.
    The reasons are subtle but they are there. I don’t want to stray too far off-topic,
    so I’ll leave you a link in the *Further reading* section at the end of this chapter
    where Martin Fowler explains the subtle differences between the three seemingly
    synonymous words. Let’s move our focus back to the DIP. This principle states
    two points:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我要提出一个警告。表面上看，依赖反转听起来与**依赖注入**（**DI**）相似。它也听起来与**控制反转**（**IoC**）相似。这些概念并不相同。鉴于我们刚刚讨论了Liskov替换，你应该明白它们是不可互换的。原因微妙但确实存在。我不想离题太远，所以我在本章末尾的*进一步阅读*部分留给你一个链接，在那里Martin
    Fowler解释了这三个看似同义的词之间的微妙差异。让我们将我们的焦点重新回到DIP上。这个原则指出两点：
- en: '*A. High-level classes or modules should not depend on low-level classes or
    modules and both should depend on abstractions.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*A. 高层类或模块不应该依赖于低层类或模块，两者都应依赖于抽象。*'
- en: '*B. Abstractions should not depend on implementation details but instead details
    should depend upon abstractions.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*B. 抽象不应该依赖于实现细节，而细节应该依赖于抽象。*'
- en: 'To me, this sounds comparable to something a Shaolin monk might say in a kung
    fu movie right before ripping off his shirt and serenely engaging in mortal combat.
    Let’s see whether we can bring it to the street. Consider how you might design
    a lamp using OOP principles. One way might look as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，这听起来就像武侠电影中少林僧人在脱掉上衣，平静地进入生死搏斗之前可能会说的话。让我们看看我们是否能够将其带到现实生活中。考虑一下你可能会如何使用面向对象原则来设计一个灯。一种可能的方式如下：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There’s a lamp. We need a button to turn it on and off:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个灯。我们需要一个按钮来开关它：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This lamp will work. When you trigger the `ToggleLamp` method inside the button,
    the lamp will turn on or off as expected. However, it violates the DIP. The notion
    that a lamp is a high-level object while the button is a low-level object feels
    intuitive. There’s just something wrong with putting a lamp inside of a button.
    You’d think it should be the other way around, just as it is in real life. Your
    gut feeling here results in violating both tenets of the DIP. The high-level object
    is inside the low-level object, and everything is a concrete class with nary an
    abstraction in sight. How do we fix it?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个灯会工作。当你触发按钮内的`ToggleLamp`方法时，灯会按预期打开或关闭。然而，它违反了DIP。灯是一个高级对象，而按钮是一个低级对象的想法感觉直观。但是，将灯放在按钮里似乎有些不对劲。你可能会认为它应该是相反的，就像现实生活中一样。你在这里的直觉导致违反了DIP的两个原则。高层对象在低层对象内部，而且一切都是具体的类，没有抽象的概念。我们该如何解决这个问题呢？
- en: 'We can use composition. Remember that composition entails building, or composing,
    an object out of component objects. This could be something similar to the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用组合。记住，组合意味着从组件对象中构建或组合一个对象。这可能类似于以下内容：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s our button with no lamp in it. Instead, the button should be in the
    lamp. To put it another way, we should compose a lamp using a button:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的按钮，里面没有灯。相反，按钮应该包含在灯中。换句话说，我们应该使用按钮来组合一个灯：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We inverted the dependency. The button is inside the lamp and the low-level
    object directly depends on the high-level object. We’ve satisfied the first tenet
    of the DIP. We still have more work to do before we reach Shaolin-level mastery.
    The button and the lamp are still tightly coupled via concrete object implementations.
    What if we want to use something other than the button to turn the lamp on? Maybe
    a motion detector. Maybe one of those fancy **Internet of Things** (**IoT**) microcontrollers
    that everybody’s talking about. Effectively, this is still a button, but it’s
    much fancier and its object representation would be more complex than our button.
    We need an abstraction for the button that allows us to plug in any object that
    works as a button would. Let’s make an interface that describes what the lamp
    needs:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们反转了依赖关系。按钮在灯内部，低级对象直接依赖于高级对象。我们已经满足了DIP的第一个原则。在我们达到少林级大师之前，我们还有更多的工作要做。按钮和灯仍然通过具体的对象实现紧密耦合。如果我们想用除了按钮以外的其他东西来打开灯呢？也许是一个运动探测器。也许是一些大家都在谈论的**物联网（IoT）**微控制器。实际上，这仍然是一个按钮，但它要复杂得多，其对象表示会比我们的按钮更复杂。我们需要一个关于按钮的抽象，它允许我们插入任何可以作为按钮工作的对象。让我们创建一个描述灯需要的接口：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we make the button extend the interface:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们让按钮扩展接口：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we rewire the lamp:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重新布线灯：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As usual, I changed the names a little bit so that we can keep our examples
    straight. I changed the name of the member variable that formerly held our concrete
    button to something more generic, namely `DipoleSwitch`, which I figured could
    describe just about anything that fulfills a binary on-and-off function.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我稍微改变了一些名称，以便我们可以保持我们的例子一致。我将之前持有我们具体按钮的成员变量改名为更通用的`DipoleSwitch`，我认为它可以描述几乎任何实现二进制开/关功能的任何事物。
- en: We now have a lamp with high-level and low-level objects in the proper orientation.
    We could argue that they’re correct now and that we started with them inverted
    the wrong way. Kind of like in the southern United States when someone offers
    you sweet tea or unsweetened tea. There’s no such thing as unsweetened tea. It
    isn’t as if you put the sweetness in and then took it out. It was unsweetened
    when it was made. The wording is weird, but we say it that way anyway. That’s
    how our lamp started when it was inside the button class. It works, and everybody
    knows what you meant, but it’s still wrong.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个灯，其中包含高级和低级对象，并且它们处于正确的方向。我们可以争论说，它们现在是正确的，而且我们最初是以错误的方式倒置的。有点像在美国南部，当有人给你提供加糖茶或不加糖茶时。根本就没有不加糖的茶。这并不是说你在里面加了糖然后再把它取出来。它在制作时就未加糖。措辞很奇怪，但我们仍然那样说。这就是我们的灯在按钮类内部开始时的样子。它工作得很好，每个人都知道你的意思，但这仍然是错误的。
- en: We also removed the concrete button object and swapped it for an interface.
    We could have used an abstract class to satisfy the second tenet, but I still
    believe we should tend toward interfaces, as they are more flexible.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还移除了具体的按钮对象，并用接口替换了它。我们本可以使用抽象类来满足第二个原则，但我仍然认为我们应该倾向于接口，因为它们更灵活。
- en: We have, in the process of learning about the DIP, learned what it means to
    decouple. Decoupling is a strategy rather than a pattern and it has many uses
    at many different levels of your software projects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习DIP的过程中，我们了解了解耦的含义。解耦是一种策略而不是一种模式，它可以在你的软件项目的许多不同层面上有许多用途。
- en: Measuring quality beyond the development organization
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越开发组织衡量质量
- en: We’ve spent a lot of time in this chapter talking about quality code from the
    perspective of software engineering. Software is never developed in a bubble.
    It is always developed in concert with business professionals working to solve
    business problems. That means a great many people on your project might not be
    developers or engineers. All of our discussions so far have revolved around specific
    engineering practices. However, you need to realize that these views won’t be
    shared by your business-oriented colleagues.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们花了很多时间从软件工程的角度讨论质量代码。软件永远不会在真空中开发。它总是与致力于解决业务问题的商业专业人士一起开发。这意味着你的项目中的许多人可能不是开发者或工程师。到目前为止，我们所有的讨论都是围绕特定的工程实践展开的。然而，你需要意识到，这些观点不会得到你的以业务为导向的同事的认同。
- en: For them, *quality* is often defined as *conformance to requirements*. That
    means quality code is code that meets its requirements. I would argue that this
    is a far too basic definition. The corporate quality movements of the 80s and
    90s, such as the lean manufacturing and zero defects ideals espoused by Deming,
    have been coopted into our field by well-meaning managers. They want to focus
    100 percent on the customer. They have trouble relating to what we do because
    they don’t understand anything about software beyond the superficial layer the
    users see. Your non-engineer colleagues will have trouble talking to you about
    quality because you are speaking different languages.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对他们来说，“质量”通常被定义为“符合要求”。这意味着高质量代码是满足其要求的代码。我认为这是一个过于基本的定义。20世纪80年代和90年代的 corporate
    quality movements，如Deming提倡的精益制造和零缺陷理念，已被有良心的管理者引入我们的领域。他们希望将100%的精力集中在客户身上。他们很难与我们联系，因为他们对软件的了解仅限于用户看到的表面层。你的非工程师同事在谈论质量时会遇到困难，因为你正在使用不同的语言。
- en: 'To get everybody on the same page, let’s consider some questions:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家达成共识，让我们考虑一些问题：
- en: What does the term *quality code* mean to you?
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “高质量代码”这个术语对你来说意味着什么？
- en: What does it mean to your boss?
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的老板来说，它意味着什么？
- en: What does it mean to your boss’s boss?
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的老板的老板来说，它意味着什么？
- en: What does it mean to your end users?
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的最终用户来说，它意味着什么？
- en: What does it mean to your suppliers, that is, the business professionals who
    supply the raw process inputs that drive your work?
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你的供应商来说，这意味着什么，即那些提供驱动你工作的原始过程输入的商业专业人士？
- en: After you’ve done this exercise, you’ve likely explored a wide gamut of perspectives.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个练习后，你很可能已经探索了广泛的视角。
- en: Code reviews
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查
- en: In an age where everything is expected to be available in an instant, it becomes
    increasingly difficult to stress refactoring as a regular exercise. It’s very
    easy to solve a bug report as quickly as possible, do something sloppily, then
    move on to the next bug. Runners have the *runner’s high*, referring to a release
    of endorphins at some point during the run. Personally, I wouldn’t know. I only
    run when chased. I think coders have a similar dependence on the dopamine released
    when we move an issue from *In Progress* to *Done*. Equally, if you have a project
    manager who reports up the chain of command, it’s tempting to always present progress
    in terms of the number of issues worked through, rather than using actual quality
    metrics and tending to the health of your code base.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个期望一切都能立即获得的时代，强调重构作为一种常规练习变得越来越困难。尽快解决一个错误报告很容易，草率地做些事情，然后继续处理下一个错误。跑步者有“跑步者的快感”，指的是在跑步过程中某个时刻内啡肽的释放。我个人不知道。我只在被迫时才跑步。我认为程序员在将问题从“进行中”移至“完成”时对多巴胺的依赖有相似之处。同样，如果你有一个向上级报告的项目经理，总是以处理的问题数量来展示进度，而不是使用实际的质量指标并关注代码库的健康状况，这很诱人。
- en: The best practice is to conduct code reviews.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是进行代码审查。
- en: Code reviews are perhaps the most important practice for maintaining a healthy
    code base, which leads to happy developers. You’ll experience fewer shipped bugs,
    fewer outages, and higher retention rates at a time when organizations are engaged
    in stiff competition to retain their development talent. Code reviews are an easy
    and inexpensive way to invest in your individual contributors. The developers
    under review, often by a senior teammate, will learn better techniques and more
    patterns. The senior developers can help their junior counterparts identify areas
    where they might benefit from training, at the beginning of the course, by assigning
    them a good book on patterns. Hopefully, you presently find yourself in a position
    to recommend one.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查可能是维护健康代码库的最重要实践，这导致开发者快乐。在组织为了在激烈竞争中保留其开发人才而投入大量精力的时候，你将经历更少的已发布错误、更少的停机时间和更高的保留率。代码审查是投资个人贡献者的一种简单且成本效益高的方式。接受审查的开发者，通常由资深团队成员进行，将学会更好的技术和更多模式。资深开发者可以帮助他们的初级同事识别他们可能从培训中受益的领域，在课程开始时，通过分配一本关于模式的优秀书籍。希望你现在能处于推荐一本书籍的位置。
- en: A lot of this book assumes very little about your level of experience in the
    field of software development. Following that principle, you may currently be
    wondering what a code review entails. A bad one is where someone glances at your
    code and after a minute or two says, “*Meh. Looks good to me*.” They sign off
    on it and go back to what they were working on. Code reviews need to be scheduled
    as a meeting. If the code review is an interruption to someone else’s work, it
    will not yield results, and it will not be effective.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本书对你在软件开发领域的经验水平假设非常少。遵循这一原则，你可能现在正在想代码审查是什么。一个糟糕的代码审查是有人匆匆浏览你的代码，一两分钟后说，“*嗯。看起来不错*。”然后他们签字并回到他们之前的工作。代码审查需要像会议一样安排。如果代码审查是打扰了别人的工作，它将不会产生结果，也不会有效。
- en: 'When conducting a code review, there are two key areas to consider: overall
    design and functionality.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行代码审查时，有两个关键领域需要考虑：整体设计和功能。
- en: Overall design
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整体设计
- en: 'This is ultimately a book designed to help you improve your understanding and
    practice of software design. It stands to reason that I’d bring this up in a review.
    Some questions I invariably ask consist of the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书最终是为了帮助你提高你对软件设计的理解和实践。从逻辑上讲，我会在审查中提到这一点。我不可避免地会问以下问题：
- en: How does the new code fit into the overall architecture of the production code?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码如何融入生产代码的整体架构？
- en: Does the code follow SOLID principles, domain-driven design, behavior-driven
    design, or other paradigms followed by the team?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是否遵循SOLID原则、领域驱动设计、行为驱动设计或其他团队遵循的范式？
- en: Are formatting and style conventions being honored? Do the names of things follow
    the guidelines we established earlier? Do they make sense? Are they easy to read?
    Are they self-describing?
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否遵守了格式和风格约定？事物的名称是否遵循我们之前制定的指南？它们是否合理？是否易于阅读？是否具有自描述性？
- en: Is the code readable per the first half of this chapter?
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是否符合本章前半部分的阅读性要求？
- en: What patterns are used and are they appropriate?
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了哪些模式，它们是否合适？
- en: Is the code in the right place? We don’t want lasagna!
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是否在正确的位置？我们不希望有千层面！
- en: Can the new code be reused in other places? This might necessitate moving it.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码是否可以在其他地方重用？这可能需要将其移动。
- en: Could the new code replace something we already have? If your addition has 100
    lines of code that can replace 1,000, that’s a huge win!
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码能否替换我们已有的东西？如果你的添加有100行代码可以替换1000行，那将是一个巨大的胜利！
- en: What can I take out of the current code now that we have this new addition?
    I consider it a big deal when I get to remove code. If only this could apply to
    the US tax code as well!
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有了这个新添加的功能，我能从当前代码中移除什么？当我能够移除代码时，我认为这是一件大事。如果这也能应用到美国税法上就好了！
- en: Is the code too clever? Clever code requires effort through the cognitive load
    required to understand it. Look for opportunities to make your code scannable.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是否过于巧妙？巧妙的代码需要通过理解它所需的认知负荷来付出努力。寻找使你的代码可扫描的机会。
- en: Aside from being readable, is it rife with features that were not asked for
    or specified? Is it loaded with code for use cases that are very unlikely to ever
    be needed? This is called **You Ain’t Gonna Need It** (**YAGNI**).
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了可读性外，它是否充满了未被请求或指定的功能？它是否充满了非常不可能被需要的用例的代码？这被称为**你不会需要它**（**YAGNI**）。
- en: Use of the word “ain’t” will likely anger my editors, my wife, my boss, my pastor,
    and my sixth-grade English teacher, but there it is. Deal with it, y’all. Having
    reviewed the overall design, the review can shift to functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“ ain't”这个词可能会激怒我的编辑、我的妻子、我的老板、我的牧师和我的六年级英语老师，但就是这样。大家处理好，好吧。在审查了整体设计之后，审查可以转向功能。
- en: Functionality
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性
- en: 'The review’s focus should entail making sure the code does what it is supposed
    to do. It should also ask questions about how we know the code is done beyond
    the warm feeling we got when we changed the issue status from *In Progress*:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 审查的重点应该是确保代码做了它应该做的事情。它还应该询问关于我们如何知道代码已经完成的问题，而不仅仅是当我们从*进行中*状态更改问题时所感受到的温暖感觉：
- en: Can someone from another group who doesn’t know the code look at this code and
    understand it?
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自不知道代码的其他组的人能否查看这段代码并理解它？
- en: Are the automated unit and regression tests passing consistently? What? You
    don’t have tests? You need tests!
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动单元和回归测试是否始终通过？什么？你没有测试？你需要测试！
- en: Is there documentation for the new features? How will the end users know how
    to use these new features, or even know that they’re there?
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新功能是否有文档？最终用户将如何知道如何使用这些新功能，或者甚至知道它们的存在？
- en: Are exceptions communicated well enough to give a full account of what went
    wrong to the technical team without blaming or unnecessarily confusing the user?
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常是否得到了充分的沟通，以便向技术团队提供完整的错误报告，而不责怪或无谓地混淆用户？
- en: Does this new code introduce holes in your security?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段新代码是否在你的安全中引入了漏洞？
- en: Does anything violate regulatory constraints for your industry?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的行业是否有任何违反监管约束的情况？
- en: Did you benchmark performance? Can we make anything faster?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否对性能进行了基准测试？我们能加快任何事情吗？
- en: Is there any risk involved with rolling this to production right now?
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在将此推向生产是否涉及任何风险？
- en: What have you not thought of?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有想到什么？
- en: This one’s tough. You can’t do it by yourself. You need code reviews with another
    developer. While this is not an exhaustive checklist, these questions should get
    you moving in the right direction.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这件事很难。你不能自己完成。你需要与其他开发者的代码审查。虽然这不是一个详尽的清单，但这些问题应该能帮助你朝着正确的方向前进。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about preparing you to transform the way that you work
    and the way you that think about creating software. Learning patterns is a big
    deal. They usually encourage big changes to the quality and maintainability of
    your projects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章的全部内容都是关于准备你改变工作方式和思考创建软件的方式。学习模式是一件大事。它们通常鼓励对项目质量和可维护性进行重大改变。
- en: We started with some common metaphors that describe the typical devolution of
    software projects, namely spaghetti code and lasagna code. Spaghetti code is represented
    by a chaotic structure. Lasagna code is represented as a tiered structure with
    a leaky state and functionality between layers. Ravioli code represents the best
    code, as it uses the same ingredients as spaghetti and lasagna, but the contents
    of ravioli are fully encapsulated.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些常见的隐喻开始，描述了软件项目典型的退化，即意大利面代码和千层面代码。意大利面代码代表一种混乱的结构。千层面代码代表一种分层结构，层与层之间存在泄漏的状态和功能。意大利馄饨代码代表最好的代码，因为它使用了意大利面和千层面相同的原料，但意大利馄饨的内容是完全封装的。
- en: We introduced a few topics that usually fill entire books on their own. SOLID
    principles are the guiding star for most serious coding organizations, but I rarely
    see them taught. Beginner- and intermediate-level coders are usually so focused
    on languages and syntax that they don’t develop the muscles needed to plan and
    execute an architecture.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了一些通常占据整本书的主题。SOLID 原则是大多数严肃编码组织的指南星，但我很少看到它们被教授。初学者和中级程序员通常过于专注于语言和语法，以至于没有发展出规划和管理架构所需的肌肉。
- en: If this is you, the five principles of SOLID design are an excellent starting
    point and should be understood before diving into patterns.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你的情况，SOLID 设计原则的五个原则是一个极好的起点，并且在深入研究模式之前应该理解。
- en: We ended with a few pointers on performing code reviews.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些关于执行代码审查的要点结束。
- en: You are now ready for an adventure. You’ve got all your prepper gear and you’re
    ready for anything I might throw at you. In the next chapter, we’ll begin learning
    about patterns, starting with creation patterns.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在准备好开始一段冒险了。你已经准备好了所有的预备装备，并且准备好应对我可能向你抛出的任何挑战。在下一章中，我们将开始学习模式，从创建模式开始。
- en: Further reading
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Martin, R. C., & Martin, M. (2006.) *Agile principles, patterns, and practices
    in C#* (Robert C. Martin.) Prentice Hall PTR.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin, R. C., & Martin, M. (2006.) *敏捷原则、模式和 C# 实践* (Robert C. Martin.) Prentice
    Hall PTR.
- en: 'Martin, R. C. (2009.) *Clean code: a handbook of agile software craftsmanship.*
    Pearson Education.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Martin, R. C. (2009.) *Clean code: a handbook of agile software craftsmanship.*
    Pearson Education.'
- en: Schubert, B (2013.) *DIP in the Wild [Blog post.]* Retrieved from [https://martinfowler.com/articles/dipInTheWild.xhtml#YouMeanDependencyInversionRight.](https://martinfowler.com/articles/dipInTheWild.xhtml#YouMeanDependencyInversionRight.)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Schubert, B (2013.) *DIP in the Wild [博客文章].* 从 [https://martinfowler.com/articles/dipInTheWild.xhtml#YouMeanDependencyInversionRight.](https://martinfowler.com/articles/dipInTheWild.xhtml#YouMeanDependencyInversionRight.)
    获取。
- en: '![](img/part-2-getting-started.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/part-2-getting-started.jpg)'
- en: 'Part 2: Patterns You Need in the Real World'
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：你需要现实世界中的模式
- en: These chapters explain the most useful and popular patterns created by the Gang
    of Four. We’re strictly focused on the patterns that appear all the time in real-world
    projects – patterns you should definitely know to advance your craft, and your
    career, to the next level. In each case, we will provide a generic UML diagram,
    followed by a real-world application. The generic pattern diagram will be re-drawn
    to fit the problem and we will then write the coded solution as instructed by
    our diagram.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节解释了四人帮（Gang of Four）创建的最有用和最受欢迎的模式。我们严格关注那些在现实世界项目中经常出现的模式——这些模式你绝对应该知道，以便将你的技艺和职业生涯提升到下一个层次。在每种情况下，我们将提供一个通用的UML图，然后是实际应用。通用模式图将被重新绘制以适应问题，然后我们将根据图示编写代码解决方案。
- en: 'This part covers the following chapters:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖了以下章节：
- en: '[*Chapter 3*](B18605_03.xhtml#_idTextAnchor063), *Getting Creative with Creational
    Patterns*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B18605_03.xhtml#_idTextAnchor063), *用创建型模式激发创造力*'
- en: '[*Chapter 4*](B18605_04.xhtml#_idTextAnchor078), *Fortify Your Code with Structural
    Patterns*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18605_04.xhtml#_idTextAnchor078), *用结构型模式加固你的代码*'
- en: '[*Chapter 5*](B18605_05.xhtml#_idTextAnchor089), *Wrangling Problem Code by
    Applying Behavioral Patterns*'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18605_05.xhtml#_idTextAnchor089), *通过应用行为模式整理问题代码*'
