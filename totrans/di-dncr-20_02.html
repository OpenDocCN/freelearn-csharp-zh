<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Injection and IoC Containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This chapter is intended to cover the Dependency Inversion principle in more depth. </span><span class="koboSpan" id="kobo.2.2">This means coverage of how it is used in already popular frameworks with different languages, like C#, or JavaScript. </span><span class="koboSpan" id="kobo.2.3">We will see what are its main advantages and caveats are, together with a brief analysis of why it is gaining momentum and consensus among developers all over the world.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we'll cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">In all, we'll talk about the concepts and implementation of software artifacts like Factories and Service Locators, and how they relate to Dependency Injection. </span><span class="koboSpan" id="kobo.4.2">Factories and Service Locators--concepts, implementations, and how they relate to Dependency Injection</span></li>
<li><span class="koboSpan" id="kobo.5.1">We'll also cover how IoC containers implement this concept, and what the main points that these IoC containers have in common are, beyond the language they're implemented in</span></li>
<li><span class="koboSpan" id="kobo.6.1">Then, we'll go through a brief introduction to Object Composition, Object Lifetime, and the different types of injection, ending with some commentaries about those cases in which Dependency Injection is not the best choice</span></li>
<li><span class="koboSpan" id="kobo.7.1">We will end up with some demos about popular IoC containers in use today for .NET Framework and a brief introduction to how DI is used in JavaScript frameworks, like AngularJS</span></li>
</ul>
<p><span class="koboSpan" id="kobo.8.1">We'll cover the following topics in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Factories and Service Locators--Concepts, Implementations, and how they relate to Dependency Injection</span></li>
<li><span class="koboSpan" id="kobo.10.1">IoC containers</span></li>
<li><span class="koboSpan" id="kobo.11.1">Demos about popular IoC containers in use today for .NET Framework</span></li>
<li><span class="koboSpan" id="kobo.12.1">Introduction to Object Composition, Object Lifetime, and the different types of injection</span></li>
<li><span class="koboSpan" id="kobo.13.1">Brief introduction to how DI is used in JavaScript frameworks, like AngularJS</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Dependency Principle in more detail</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">But, before all that, let's remember that we postponed a more detailed explanation of the principle for this chapter. </span><span class="koboSpan" id="kobo.2.2">In </span><a href="d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml" target="_blank"><span class="koboSpan" id="kobo.3.1">Chapter 1</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">The SOLID Principles of Software Design</span></em><span class="koboSpan" id="kobo.6.1">, we discussed the five SOLID principles in general, so it's time to go deeper into the Dependency Principle. </span><span class="koboSpan" id="kobo.6.2">Actually, it's not that difficult. </span><span class="koboSpan" id="kobo.6.3">It only requires to properly understand the two basic points, which Robert Martin highlights, and express the idea by means of some source code. </span><span class="koboSpan" id="kobo.6.4">Recall:</span></p>
<div class="packt_quote"><span class="koboSpan" id="kobo.7.1">"High-level modules should not depend on low-level modules. </span><span class="koboSpan" id="kobo.7.2">Both should depend on abstractions.</span><br/><span class="koboSpan" id="kobo.8.1">
Abstractions should not depend upon details. </span><span class="koboSpan" id="kobo.8.2">Details should depend upon abstractions."</span></div>
<p><span class="koboSpan" id="kobo.9.1">Remember, also, that we explained the intuitive notion of high-level and low-level classes, depending on their functionality for the application. </span><span class="koboSpan" id="kobo.9.2">For this respect, you can think of an app as if it was an organization hierarchy, with its different levels which depend on their role in the company.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Let's look at an example</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So, let's see an example that violates the dependency principle, propose a solution, and see how that solution might take several flavors depending on the application's needs (or even the programmer's tastes, in many situations).</span></p>
<p><span class="koboSpan" id="kobo.3.1">We're going to use a basic .NET app to settle the initial scenario. </span><span class="koboSpan" id="kobo.3.2">It's just a classic console application that reads a file with a movie's information from a specific directory, and presents the content in the console.</span></p>
<p><span class="koboSpan" id="kobo.4.1">We'll start with a file called </span><kbd><span class="koboSpan" id="kobo.5.1">MovieDB.xml</span></kbd><span class="koboSpan" id="kobo.6.1"> (in the XML format and stored in the app's data subdirectory) with a data structure like the following:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    &lt;Movie&gt;
      &lt;ID&gt;1&lt;/ID&gt;
      &lt;Title&gt;Jurassic Park&lt;/Title&gt;
      &lt;OscarNominations&gt;3&lt;/OscarNominations&gt;
      &lt;OscarWins&gt;3&lt;/OscarWins&gt;
    &lt;/Movie&gt; </span></pre>
<p><span class="koboSpan" id="kobo.8.1">So, we can use LINQ to XML to easily read data from that file and iterate over the results to present a list of movie titles in the console. </span><span class="koboSpan" id="kobo.8.2">As a good practice, we'll define a class (the model) that represents the data to be read.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Consequently, we'll have the following:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    public class Movie
    {
      public string ID { get; set; }
      public string Title { get; set; }
      public string OscarNominations { get; set; }
      public string OscarWins { get; set; }
    } </span></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.11.1">Remember that you can use the </span><span class="packt_screen"><span class="koboSpan" id="kobo.12.1">Edit</span></span><span class="koboSpan" id="kobo.13.1"> menu in Visual Studio and select </span><span class="packt_screen"><span class="koboSpan" id="kobo.14.1">Paste Special</span></span><span class="koboSpan" id="kobo.15.1"> to get the options </span><span class="packt_screen"><span class="koboSpan" id="kobo.16.1">Paste XML as classes</span></span><span class="koboSpan" id="kobo.17.1"> and </span><span class="packt_screen"><span class="koboSpan" id="kobo.18.1">Paste JSON as classes</span></span><span class="koboSpan" id="kobo.19.1">, which will build a new class in the open editor page and insert a definition according to the data pasted, with the class name </span><kbd><span class="koboSpan" id="kobo.20.1">Rootobject</span></kbd><span class="koboSpan" id="kobo.21.1">.</span></div>
<p><span class="koboSpan" id="kobo.22.1">A first approach to the problem might end up with the following code (notice I'm using here the initial and simplest approach to have, both, a model to deal with, and the functionality required):</span></p>
<pre><span class="koboSpan" id="kobo.23.1">    class Program
    {
      static string url = @"Data";
      static XDocument films = XDocument.Load(url + "MoviesDB.xml");
      static List&lt;Movie&gt; movies = new List&lt;Movie&gt;();
      static void Main(string[] args)
      {
        var movieCollection =
            (from f in films.Descendants("Movie")
        select new Movie
        {
          ID = f.Element("Title").Value,
          Title = f.Element("Title").Value,
          OscarNominations = f.Element("OscarNominations").Value,
             OscarWins = f.Element("OscarWins").Value
        }).ToList();
        Console.WriteLine("Movie Titles");
        Console.WriteLine("------------");
        foreach (var movie in movieCollection.Take(10))
        Console.WriteLine(movie.Title);
        Console.ReadLine();
      }
    } </span></pre>
<p><span class="koboSpan" id="kobo.24.1">As you see, we end up with a </span><kbd><span class="koboSpan" id="kobo.25.1">List&lt;Movie&gt;</span></kbd><span class="koboSpan" id="kobo.26.1"> collection, and iterate over it, presenting the first ten results of the </span><kbd><span class="koboSpan" id="kobo.27.1">Title</span></kbd><span class="koboSpan" id="kobo.28.1"> field in the console (see the following screenshot):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.29.1"><img height="241" width="395" src="assets/0927f89d-2d97-4ce5-ba01-c4dd5b0fec53.png"/></span></div>
<p><span class="koboSpan" id="kobo.30.1">Obviously, that's fine for a single use, but not for extended purposes. </span><span class="koboSpan" id="kobo.30.2">Since the </span><kbd><span class="koboSpan" id="kobo.31.1">Program</span></kbd><span class="koboSpan" id="kobo.32.1"> class has several responsibilities, it should be decoupled accordingly. </span><span class="koboSpan" id="kobo.32.2">So, we can think of a </span><kbd><span class="koboSpan" id="kobo.33.1">MovieReader</span></kbd><span class="koboSpan" id="kobo.34.1"> class which takes care of reading data and apply the first SOLID principle (separation of concerns).</span></p>
<p><span class="koboSpan" id="kobo.35.1">The new </span><kbd><span class="koboSpan" id="kobo.36.1">MovieReader</span></kbd><span class="koboSpan" id="kobo.37.1"> class could look like this:</span></p>
<pre><span class="koboSpan" id="kobo.38.1">    public class XMLMovieReader
    {
      static string url = @"Data";
      static XDocument films = XDocument.Load(url + "MoviesDB.xml");
      static List&lt;Movie&gt; movies = new List&lt;Movie&gt;();
      public List&lt;Movie&gt; ReadMovies()
      {
        var movieCollection =
           (from f in films.Descendants("Movie")
        select new Movie
        {
          ID = f.Element("Title").Value,
          Title = f.Element("Title").Value,
          OscarNominations = f.Element("OscarNominations").Value,
          OscarWins = f.Element("OscarWins").Value
        }).ToList();
        return movieCollection;
      }
    } </span></pre>
<p><span class="koboSpan" id="kobo.39.1">So, we just moved the declarations required to access data to the new class and wrapped the reading functionality around a method </span><kbd><span class="koboSpan" id="kobo.40.1">ReadMovies</span></kbd><span class="koboSpan" id="kobo.41.1">, which reads and returns the required data.</span></p>
<p><span class="koboSpan" id="kobo.42.1">Our </span><kbd><span class="koboSpan" id="kobo.43.1">Main</span></kbd><span class="koboSpan" id="kobo.44.1"> entry point is now much simpler. </span><span class="koboSpan" id="kobo.44.2">Consider the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.45.1">    static void Main(string[] args)
    {
      XMLMovieReader mr = new XMLMovieReader();
      var movieCollection = mr.ReadMovies();
      Console.WriteLine("Movie Titles");
      Console.WriteLine("------------");
      foreach (var movie in movieCollection.Take(10))
      Console.WriteLine(movie.Title);
      Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.46.1">That's fine, but still, our </span><kbd><span class="koboSpan" id="kobo.47.1">Program</span></kbd><span class="koboSpan" id="kobo.48.1"> class depends on the </span><kbd><span class="koboSpan" id="kobo.49.1">XMLMovieReader</span></kbd><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">What happens if we (or somebody else) needs to read data in another format, like JSON, for example?</span></p>
<p><span class="koboSpan" id="kobo.51.1">This is where Dependency Injection comes in. </span><span class="koboSpan" id="kobo.51.2">It would be much better than if our </span><kbd><span class="koboSpan" id="kobo.52.1">Program</span></kbd><span class="koboSpan" id="kobo.53.1"> class could depend on an abstraction, not on a concrete class. </span><span class="koboSpan" id="kobo.53.2">It could be an abstract class, or it could be an interface.</span></p>
<p><span class="koboSpan" id="kobo.54.1">This implies another class in charge of deciding which concrete implementation has to be served, depending on the file format. </span><span class="koboSpan" id="kobo.54.2">In this manner, it could also be possible to add further methods of reading data (like accessing a web service or database) without changing the already working code.</span></p>
<p><span class="koboSpan" id="kobo.55.1">So we could have another specialized reader called </span><kbd><span class="koboSpan" id="kobo.56.1">JSONMovieReader</span></kbd><span class="koboSpan" id="kobo.57.1"> with this implementation:</span></p>
<pre><span class="koboSpan" id="kobo.58.1">    public class JSONMovieReader
    {
      static string file = @"Data\MoviesDB.json";
      static List&lt;Movie&gt; movies = new List&lt;Movie&gt;();
      static string cadMovies;
      public List&lt;Movie&gt; ReadMovies(string file)
      {
        var moviesText = File.ReadAllText(file);
        return JsonConvert.DeserializeObject&lt;List&lt;Movie&gt;&gt;(moviesText);
      }
    } </span></pre>
<p><span class="koboSpan" id="kobo.59.1">So, we just have to implement the appropriate class depending on the format we use. </span><span class="koboSpan" id="kobo.59.2">Besides that, given that both files include exactly the same data, we would obtain identical results in both cases (I omitted the output for that reason).</span></p>
<p><span class="koboSpan" id="kobo.60.1">Now, we should create an interface that defines the common operation that all readers will have in common; the </span><kbd><span class="koboSpan" id="kobo.61.1">ReadMovies()</span></kbd><span class="koboSpan" id="kobo.62.1"> method.</span></p>
<pre><span class="koboSpan" id="kobo.63.1">    interface IMovieReader
    {
      List&lt;Movie&gt; ReadMovies();
    } </span></pre>
<p><span class="koboSpan" id="kobo.64.1">This interface is the contract that both classes (and other possible candidates) implement, so, we just have to change both declarations to explicitly indicate that they indeed implement the </span><kbd><span class="koboSpan" id="kobo.65.1">IMovieReader</span></kbd><span class="koboSpan" id="kobo.66.1"> interface. </span><span class="koboSpan" id="kobo.66.2">In this way, the final definitions will be:</span></p>
<pre><span class="koboSpan" id="kobo.67.1">    public class XMLMovieReader : IMovieReader
    ...
    </span><span class="koboSpan" id="kobo.67.2">public class JSONMovieReader : IMovieReader
    ... </span></pre>
<p><span class="koboSpan" id="kobo.68.1">And the last step consists of the creation of the new class in charge of deciding which reader has to be used (the </span><kbd><span class="koboSpan" id="kobo.69.1">ReaderFactory</span></kbd><span class="koboSpan" id="kobo.70.1">, in this demo):</span></p>
<pre><span class="koboSpan" id="kobo.71.1">    public class ReaderFactory
    {
      public IMovieReader _IMovieReader { get; set; }
      public ReaderFactory(string fileType)
      {
        switch (fileType)
        {
          case "XML":
          _IMovieReader = new XMLMovieReader();
          break;
          case "JSON":
          _IMovieReader = new JSONMovieReader();
          break;
          default:
          break;
        }
      }
    }  </span></pre>
<p><span class="koboSpan" id="kobo.72.1">Notice that the constructor of </span><kbd><span class="koboSpan" id="kobo.73.1">ReaderFactory</span></kbd><span class="koboSpan" id="kobo.74.1"> decides which type of reader is assigned to the </span><kbd><span class="koboSpan" id="kobo.75.1">_IMovieReader</span></kbd><span class="koboSpan" id="kobo.76.1"> property. </span><span class="koboSpan" id="kobo.76.2">This could easily grow as needed. </span><span class="koboSpan" id="kobo.76.3">Our </span><kbd><span class="koboSpan" id="kobo.77.1">Program</span></kbd><span class="koboSpan" id="kobo.78.1"> class has a new definition but it is an extensible one, and we can add as many reading methods as required with few or no changes:</span></p>
<pre><span class="koboSpan" id="kobo.79.1">    class Program3
    {
     static IMovieReader _IMovieReader;
     static void Main(string[] args)
      {
       Console.SetWindowSize(60, 15);
       Console.WriteLine("Please, select the file type to read (1)</span><br/><span class="koboSpan" id="kobo.80.1">         XML, (2) JSON: ");
       var ans = Console.ReadLine();
       var fileType = (ans == "1") ? </span><span class="koboSpan" id="kobo.80.2">"XML" : "JSON";
       _IMovieReader = new ReaderFactory(fileType)._IMovieReader;
       var typeSelected = _IMovieReader.GetType().Name;
       var movieCollection = _IMovieReader.ReadMovies();
       Console.WriteLine($"Movie Titles ({typeSelected})");
       Console.WriteLine("------------");
       foreach (var movie in movieCollection.Take(10))
       Console.WriteLine(movie.Title);
       Console.ReadLine();
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.81.1">In this case, we offer an option to choose the file format, and, depending on the user's choice, the </span><kbd><span class="koboSpan" id="kobo.82.1">IMovieReader</span></kbd><span class="koboSpan" id="kobo.83.1"> returned deals with the peculiarities of the format (you can think as well in other formats, such as Excel spreadsheets, pure text formats, comma-delimited files, databases, web services, and so on).</span></p>
<p><span class="koboSpan" id="kobo.84.1">The </span><span class="packt_screen"><span class="koboSpan" id="kobo.85.1">Class Diagram</span></span><span class="koboSpan" id="kobo.86.1"> that Visual Studio generates from this architecture adopts the following aspect (just right-click on the name of the class--</span><kbd><span class="koboSpan" id="kobo.87.1">Program3</span></kbd><span class="koboSpan" id="kobo.88.1">, in this demo, and select </span><span class="packt_screen"><span class="koboSpan" id="kobo.89.1">View Class Diagram</span></span><span class="koboSpan" id="kobo.90.1">), to obtain a graphic structure like the following:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.91.1"><img height="285" width="552" src="assets/da9281ae-feb7-42e8-9130-b5d2960e0c2d.png"/></span></div>
<p><span class="koboSpan" id="kobo.92.1">In summary, the </span><kbd><span class="koboSpan" id="kobo.93.1">IMovieReader</span></kbd> <span><span class="koboSpan" id="kobo.94.1">interface</span></span><span class="koboSpan" id="kobo.95.1"> is the contract that both classes agree upon. </span><span class="koboSpan" id="kobo.95.2">As long as any other class implements this interface, we'll be able to extend the potential data access mechanisms with new ways, as mentioned above.</span></p>
<p><span class="koboSpan" id="kobo.96.1">An important part of this implementation is the fact that, from the user interface, we access to a read-only property, </span><kbd><span class="koboSpan" id="kobo.97.1">_IMovieReader</span></kbd><span class="koboSpan" id="kobo.98.1"> inside the </span><kbd><span class="koboSpan" id="kobo.99.1">ReaderFactory</span></kbd><span class="koboSpan" id="kobo.100.1"> class. </span><span class="koboSpan" id="kobo.100.2">In that fashion, we avoid further changes in the property, once assigned a value. </span><span class="koboSpan" id="kobo.100.3">Finally, we get the </span><kbd><span class="koboSpan" id="kobo.101.1">Name</span></kbd><span class="koboSpan" id="kobo.102.1"> property of the resulting type of </span><kbd><span class="koboSpan" id="kobo.103.1">_IMovieReader</span></kbd><span class="koboSpan" id="kobo.104.1">, to include it in the final output.</span></p>
<p><span class="koboSpan" id="kobo.105.1">The list is like the previous one, only this time the user can select the type of format (XML or JSON):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.106.1"><img height="322" width="535" src="assets/7572144e-243a-453f-9e91-4c45e0d87480.png"/></span></div>
<p><span class="koboSpan" id="kobo.107.1">At first sight, you might think that we have to write more code when using the DI approach, but, this only happens when we're dealing with simple demos, like in this case.</span></p>
<p><span class="koboSpan" id="kobo.108.1">In real applications, with thousands or tenths of thousands of lines of code, the amount of required code usually diminishes and it greatly facilitates other aspects of the lifecycle, like maintainability, testability, extensibility, parallel development, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Aspects of Dependency Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">However, before going on with the distinct aspects of Dependency Injection, it is advisable to recall some of the basic concepts that have a deep influence in the way this principle takes form, and that we should consider before its implementation. </span><span class="koboSpan" id="kobo.2.2">Concretely, there are three main points to evaluate--Object Composition, Object Lifetime, and Interception.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Since these three topics are crucial in software development in general (not just when talking about DI), we will go back to them in </span><a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank"><span class="koboSpan" id="kobo.4.1">Chapter 6</span></a><span class="koboSpan" id="kobo.5.1">, </span><em><span class="koboSpan" id="kobo.6.1">Object Lifetime</span></em><span class="koboSpan" id="kobo.7.1">, </span><a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank"><span class="koboSpan" id="kobo.8.1">Chapter 7</span></a><span class="koboSpan" id="kobo.9.1">, </span><em><span class="koboSpan" id="kobo.10.1">Interception</span></em><span class="koboSpan" id="kobo.11.1">, and </span><a href="795befd2-857f-40d2-ba05-cb2921168bcc.xhtml" target="_blank"><span class="koboSpan" id="kobo.12.1">Chapter 8</span></a><span class="koboSpan" id="kobo.13.1">, </span><em><span class="koboSpan" id="kobo.14.1">Patterns - Dependency Injection</span></em><span class="koboSpan" id="kobo.15.1">, but let's include now this light introduction to serving as a basic reminder of what is to come.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object Composition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the important notions behind Dependency Injection and other SOLID patterns is Object Composition, which, as Wikipedia (</span><a href="https://en.wikipedia.org/wiki/Object_composition"><span class="koboSpan" id="kobo.3.1">https://en.wikipedia.org/wiki/Object_composition</span></a><span class="koboSpan" id="kobo.4.1">) reminds, "</span><em><span class="koboSpan" id="kobo.5.1">is a way to combine simple objects or data types into more complex ones. </span><span class="koboSpan" id="kobo.5.2">Compositions are a critical building block of many basic data structures, including the tagged union, the linked list, and the binary tree, as well as the object used in object-oriented programming."</span></em></p>
<p><span class="koboSpan" id="kobo.6.1">It puts a quite a clear example; types can often be divided into composite and non-composite types, and composition can be regarded as a relationship between types: an object of a composite type (for example, a car) </span><em><span class="koboSpan" id="kobo.7.1">has an</span></em><span class="koboSpan" id="kobo.8.1"> object of a simpler type (for example, a wheel).</span></p>
<p><span class="koboSpan" id="kobo.9.1">As you know, these relations have been at the heart of OOP, since the very beginning. </span><span class="koboSpan" id="kobo.9.2">It also has to do with Aggregation and should not be confused with inheritance.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Actually, there is a well-known principle of the OOP called </span><em><span class="koboSpan" id="kobo.11.1">Composition over Inheritance</span></em><span class="koboSpan" id="kobo.12.1">, which states that "</span><em><span class="koboSpan" id="kobo.13.1">classes should achieve polymorphic behavior and code reuse by their composition (by containing instances of other classes that implement the desired functionality) rather than inheritance from a base or parent class."</span></em></p>
<p><span class="koboSpan" id="kobo.14.1">Thus, the recommendation is to favor object composition over class inheritance:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1"><img height="137" width="335" src="assets/1b34dfae-13e8-45a6-8560-ee849353b0d6.png"/></span></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1">(Image courtesy: </span><a href="https://atomicobject.com/resources/oo-programming/object-oriented-aggregation"><span class="koboSpan" id="kobo.17.1">https://atomicobject.com/resources/oo-programming/object-oriented-aggregation</span></a><span class="koboSpan" id="kobo.18.1">)</span></div>
<p><span class="koboSpan" id="kobo.19.1">The previous schema shows the difference between both approaches: composition and aggregation. </span><span class="koboSpan" id="kobo.19.2">The individual elements used to compose a car are part of the car. </span><span class="koboSpan" id="kobo.19.3">The object could not perform its tasks without them.</span></p>
<p><span class="koboSpan" id="kobo.20.1">In the second case, passengers could come and go (or even, now, since driverless cars don't require any), but they can eventually be managed by the car's instance.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Keep in mind that Wikipedia (</span><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance"><span class="koboSpan" id="kobo.22.1">https://en.wikipedia.org/wiki/Composition_over_inheritance</span></a><span class="koboSpan" id="kobo.23.1">) remarks that--"</span><em><span class="koboSpan" id="kobo.24.1">Classes implementing the identified interfaces are built and added to business domain classes as needed. </span><span class="koboSpan" id="kobo.24.2">Thus, system behaviors are realized without inheritance. </span><span class="koboSpan" id="kobo.24.3">In fact, business domain classes may all be base classes without any inheritance at all. </span><span class="koboSpan" id="kobo.24.4">Alternative implementation of system behaviors is accomplished by providing another class that implements the desired behavior interface. </span><span class="koboSpan" id="kobo.24.5">Any business domain class that contains a reference to the interface can easily support any implementation of that interface and the choice can even be delayed until</span></em> <em><span class="koboSpan" id="kobo.25.1">run time."</span></em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object Lifetime</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the previous demo, we've seen a way to get rid of a classes' dependencies by means of abstractions, and the possibilities that we have later on to change those abstractions as needed, along with the application's lifecycle.</span></p>
<p><span class="koboSpan" id="kobo.3.1">But, besides this fundamental ability, this practice allows us to determine abstractions' life: when they are born (instantiated) and when they go out of scope (and leave the Garbage Collector in charge of the task of finishing the useful life).</span></p>
<p><span class="koboSpan" id="kobo.4.1">You know, when an object is not referenced by any other object it automatically becomes eligible for destruction, liberating its associated memory.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The way the GC works is not trivial (although transparent to the user) and quite a few things should be considered, especially the way in which object generations are processed and the memory recovered, even in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">Simplified Model</span></span><span class="koboSpan" id="kobo.7.1"> (see the following image):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="288" width="366" src="assets/c1bfa354-214e-45de-8d0c-bf93a03090ad.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1">(Image courtesy: </span><a href="https://msdn.microsoft.com/en-us/library/ms973837.aspx"><span class="koboSpan" id="kobo.10.1">https://msdn.microsoft.com/en-us/library/ms973837.aspx</span></a><span class="koboSpan" id="kobo.11.1">)</span></div>
<div class="packt_tip"><span class="koboSpan" id="kobo.12.1">A little about Garbage Collection from Wikipedia (</span><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><span class="koboSpan" id="kobo.13.1">https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</span></a><span class="koboSpan" id="kobo.14.1">)--"</span><em><span class="koboSpan" id="kobo.15.1">In computer science, garbage collection (GC) is a form of automatic memory management. </span><span class="koboSpan" id="kobo.15.2">The garbage collector, or just collector, attempts to reclaim garbage</span></em> <em><span class="koboSpan" id="kobo.16.1">or memory occupied by objects that are no longer in use by the program. </span><span class="koboSpan" id="kobo.16.2">Garbage collection was invented by John McCarthy around 1959 to simplify manual memory management in Lisp</span></em><span class="koboSpan" id="kobo.17.1">."</span></div>
<p><span class="koboSpan" id="kobo.18.1">Bear in mind that problems might arise when two objects share an instance of the same interface, or when a new scenario shows up when we inject two distinct instances to different clients.</span></p>
<p><span class="koboSpan" id="kobo.19.1">The way those objects are managed in memory also depends on our code to a large extent. </span><span class="koboSpan" id="kobo.19.2">Therefore, we will explain those intricacies in </span><a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank"><span class="koboSpan" id="kobo.20.1">Chapter 7</span></a><span class="koboSpan" id="kobo.21.1">, </span><em><span class="koboSpan" id="kobo.22.1">Interception</span></em><span class="koboSpan" id="kobo.23.1">, so you can have a detailed picture of this behavior and the implications it might have in your code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Interception</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can consider Interception as an application of the Decorator design pattern. </span><span class="koboSpan" id="kobo.2.2">For some authors, Interception is the process of pre-filtering a given call, in a way that we can include (or exclude) certain information from its standard (original) behavior.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In the case of the IMovieReader implementation, the creation of a valid object capable of reading movies is redirected to the </span><kbd><span class="koboSpan" id="kobo.4.1">ReaderFactory</span></kbd><span class="koboSpan" id="kobo.5.1">, instead of the previous call to a concrete constructor. </span><span class="koboSpan" id="kobo.5.2">This is possible because abstractions allow us to defer instantiation and decide what to create depending on arguments, a system's configuration, configuration files, and so on.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Another typical usage of interception relates to Instrumentation: distinct aspects of the application that go beyond application domains, like logging, auditing, validation and many others.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Finally, we can find interception when we capture the default behavior of system components using the so-called sub-classing technique, which allows for interleaving system calls and, effectively, change the system's behavior, substituting it for our own.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Ways to implement DI</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this case, Dependency Injection is implemented by means of a constructor, which is the preferred way of today's implementation for many of the popular IoC containers we can find for the .NET Framework (and even, for other frameworks, like Angular).</span></p>
<p><span class="koboSpan" id="kobo.3.1">However, there are other two classical paths for DI implementation: via properties (also called setter injection) or methods.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In the Property Injection flavor, we're dealing with a scenario in which it makes sense to allow the user to change the dependency once the program is running. </span><span class="koboSpan" id="kobo.4.2">For instance, imagine that you start with a concrete implementation, and later on, the client or some program's condition, require change.</span></p>
<p><span class="koboSpan" id="kobo.5.1">There are situations in which that change doesn't require -strictly speaking- a new instance of the class, so it would not be coherent to create it just to change a given value. </span><span class="koboSpan" id="kobo.5.2">It's much better to keep the level of independence that DI promotes, but allow the client of the dependency to change that value once used.</span></p>
<p><span class="koboSpan" id="kobo.6.1">To achieve this goal we must create a writable property (not a read-only one, like we did before). </span><span class="koboSpan" id="kobo.6.2">But, there's a danger. </span><span class="koboSpan" id="kobo.6.3">We have to avoid null values. </span><span class="koboSpan" id="kobo.6.4">We can do this easily by creating a default value, something very easy and concise to implement using C# latest techniques, as we'll see in a demo. </span><span class="koboSpan" id="kobo.6.5">So, a change of a dependency's value is the key to determining if we have to use properties in the injection.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In Method Injection, the code block that requires the dependency is usually a parameter of some method, and the purpose of the dependency's argument is to provide a context, which determines how the method should behave.</span></p>
<p><span class="koboSpan" id="kobo.8.1">So, we can say that the scenario is scope-dependent. </span><span class="koboSpan" id="kobo.8.2">When the scope of the dependency is somehow local, as it happens when it is only being used in one concrete method (it does not affect the whole class), it's a good practice to limit the presence of the dependency exclusively to the method that it is going to use it.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Let's see a couple of samples about these two ways of implementing DI.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Property Injection in action</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's imagine something very simple for this demo. </span><span class="koboSpan" id="kobo.2.2">The code presents an initial configuration of color values for the current console, together with a message indicating those values. </span><span class="koboSpan" id="kobo.2.3">We offer the user the ability to change themes, to avoid unreadable combinations.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We reduce these combinations to light and dark, besides the initial one, which is black/white. </span><span class="koboSpan" id="kobo.3.2">We could define a very simple </span><kbd><span class="koboSpan" id="kobo.4.1">ConsoleDisplayFactory</span></kbd><span class="koboSpan" id="kobo.5.1"> class with two default values that are assigned in its instantiation:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">    public class ConsoleDisplayFactory
    {
     // Both properties asume a default (initial) configuration
     public ConsoleColor ForeColor { get; set; } = ConsoleColor.White;
     public ConsoleColor BackColor { get; set; } = ConsoleColor.Black;
     public ConsoleDisplayFactory ConfigureConsole (string theme)
     {
       switch (theme)
       {
         case "light":
         BackColor = ConsoleColor.Yellow;
         ForeColor = ConsoleColor.DarkBlue;
         break;
         case "dark":
         BackColor = ConsoleColor.DarkBlue;
         ForeColor = ConsoleColor.Yellow;
         break;
         default:
         break;
       }
       return this;
     }
    }</span></pre>
<p><span class="koboSpan" id="kobo.7.1">With this definition, every time we create an instance, both properties (</span><kbd><span class="koboSpan" id="kobo.8.1">ForeColor</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">BackColor</span></kbd><span class="koboSpan" id="kobo.11.1">) are assigned the default theme configuration. </span><span class="koboSpan" id="kobo.11.2">Our </span><kbd><span class="koboSpan" id="kobo.12.1">Program</span></kbd><span class="koboSpan" id="kobo.13.1"> class will depend on </span><kbd><span class="koboSpan" id="kobo.14.1">ConsoleDisplayFactory</span></kbd><span class="koboSpan" id="kobo.15.1">, but we make sure that both values hold a consistent color configuration.</span></p>
<p><span class="koboSpan" id="kobo.16.1">Now, our main entry point, located in </span><kbd><span class="koboSpan" id="kobo.17.1">Program4</span></kbd><span class="koboSpan" id="kobo.18.1">, would look like the following code:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    class Program4
    {
      static ConsoleDisplayFactory cdf = new ConsoleDisplayFactory();
      static void Main(string[] args)
      {
        // Initial config
        cdf.ConfigureConsole("default");
        Console.BackgroundColor = cdf.BackColor;
        Console.ForegroundColor = cdf.ForeColor;
        Console.WriteLine("Console Information");
        Console.WriteLine("-------------------");
        Console.WriteLine("Initial configuration: \n");
        Console.WriteLine($"Back Color: { cdf.BackColor}");
        Console.WriteLine($"Fore Color: { cdf.ForeColor }");
        // User's config
        Console.WriteLine("New theme ('light', 'dark',</span><br/><span class="koboSpan" id="kobo.20.1">            'Enter'=&gt;default):");
        var newTheme = Console.ReadLine();
        cdf.ConfigureConsole(newTheme);
        Console.BackgroundColor = cdf.BackColor;
        Console.ForegroundColor = cdf.ForeColor;
        Console.WriteLine("New configuration: \n");
        Console.WriteLine($"Back Color: { cdf.BackColor}");
        Console.WriteLine($"Fore Color: { cdf.ForeColor }");
        Console.ReadLine();</span><br/><span class="koboSpan" id="kobo.21.1">      }      
    }</span></pre>
<p><span class="koboSpan" id="kobo.22.1">Observe changes to console configuration that are performed via the </span><kbd><span class="koboSpan" id="kobo.23.1">ConsoleDisplayFactory</span></kbd><span class="koboSpan" id="kobo.24.1"> instance, which is a property of the </span><kbd><span class="koboSpan" id="kobo.25.1">Program4</span></kbd><span class="koboSpan" id="kobo.26.1"> class. </span><span class="koboSpan" id="kobo.26.2">For this initial version of the demo, we have opted for a method (which serves as a setter) that takes care of the values assigned.</span></p>
<p><span class="koboSpan" id="kobo.27.1">Another approach could be to code the </span><kbd><span class="koboSpan" id="kobo.28.1">ForeColor</span></kbd><span class="koboSpan" id="kobo.29.1"> and </span><kbd><span class="koboSpan" id="kobo.30.1">BackColor</span></kbd><span class="koboSpan" id="kobo.31.1"> properties of the </span><kbd><span class="koboSpan" id="kobo.32.1">ConsoleDisplayFactory</span></kbd><span class="koboSpan" id="kobo.33.1"> class in a way that the setters of each property would take care of assigning the suitable changes for each theme.</span></p>
<p><span class="koboSpan" id="kobo.34.1">Though pretty simple, this code shows the idea behind Property Injection. </span><span class="koboSpan" id="kobo.34.2">We don't need the whole class to be re-instantiated, so we allow the client to change the required properties, but taking care that the results are injected according to business rules.</span></p>
<p><span class="koboSpan" id="kobo.35.1">The fact that we use an injector method or program the setters directly will always depend on the architecture of the code and your necessities.</span></p>
<p><span class="koboSpan" id="kobo.36.1">(We omit the output since it is quite trivial in this case).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Method Injection in practice</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we previously mentioned, the key here is that the injected resource makes sense inside a method of the client class. </span><span class="koboSpan" id="kobo.2.2">There are two main reasons for this, which are the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">The injected parameter affects the way the method behaves and it can change along its life-runtime (in distinct method calls)</span></li>
<li><span class="koboSpan" id="kobo.4.1">The injected parameter's functionality affects the method's block of code and nothing else. </span><span class="koboSpan" id="kobo.4.2">Therefore, there's no need to create a class-scope dependency when it is only used inside that block</span></li>
</ul>
<p><span class="koboSpan" id="kobo.5.1">This scenario shows up when we are coding a method that has some functionality that is dynamic in nature (an HTTP context, access to a directory that contains files that might change during the execution, Web Sockets, and so on.).</span></p>
<p><span class="koboSpan" id="kobo.6.1">It is well-known that the .NET Framework already implements this feature in some classes belonging to a variety of namespaces. </span><span class="koboSpan" id="kobo.6.2">For example, in the </span><strong><span class="koboSpan" id="kobo.7.1">Base Class Libraries</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">BCL</span></strong><span class="koboSpan" id="kobo.10.1">), the </span><kbd><span class="koboSpan" id="kobo.11.1">System.ComponentModel</span></kbd><span class="koboSpan" id="kobo.12.1"> namespace allows using the </span><kbd><span class="koboSpan" id="kobo.13.1">TypeConverter</span></kbd> <span><span class="koboSpan" id="kobo.14.1">class</span></span><span class="koboSpan" id="kobo.15.1"> which is especially useful in contexts where WPF is involved, to allow conversions between pure CLR types and XAML types or other business logic types.</span></p>
<p><span class="koboSpan" id="kobo.16.1">Some of this classes' methods use an instance of </span><kbd><span class="koboSpan" id="kobo.17.1">ITypeDescriptorContext</span></kbd><span class="koboSpan" id="kobo.18.1"> that carries information about the context in which the execution takes place.</span></p>
<p><span class="koboSpan" id="kobo.19.1">But there's a simpler and much more common scenario in which this is happening all the time: the structure of the .NET's event system, and I think that understanding the way it works is very useful to realize how we can find implementations of this pattern in every-day situations, and how this is being used since the very beginning.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">.NET event architecture as Model Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's think of the event model for a second: in practice, method A calls method B and passes some arguments (two, by default). </span><span class="koboSpan" id="kobo.2.2">When you program a Click, </span><kbd><span class="koboSpan" id="kobo.3.1">SelectedItemChanged</span></kbd><span class="koboSpan" id="kobo.4.1">, of </span><kbd><span class="koboSpan" id="kobo.5.1">FormClosing</span></kbd><span class="koboSpan" id="kobo.6.1"> event in classic (and modern) .NET, a communication process takes place.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The process involves a method responsible for calling (the sender) and the callee (the receiver). </span><span class="koboSpan" id="kobo.7.2">This can be represented with the classic scheme of any other communication process that we all know from the first books of Information Theory:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="206" width="318" src="assets/0a08780c-c39b-4f75-87d0-4dc2a64d6876.png"/></span></div>
<div class="packt_tip"><span class="koboSpan" id="kobo.9.1">Aggregation is a simple collection, like a bag of marbles, while composition implies internal/functional dependencies, like the hinges on a box. </span><span class="koboSpan" id="kobo.9.2">Cars aggregate passengers; they get in and out without breaking the car's functionality but the tires are components; remove one and the car no longer functions correctly.</span><br/>
<br/><span class="koboSpan" id="kobo.10.1">
If you don't know these concepts (Composition and Aggregation), PACKT has excellent books to start with that, like </span><em><span class="koboSpan" id="kobo.11.1">Learning Object-Oriented Programming</span></em><span class="koboSpan" id="kobo.12.1"> by Gaston C. </span><span class="koboSpan" id="kobo.12.2">Hillar (</span><a href="https://www.packtpub.com/application-development/learning-object-oriented-programming"><span class="koboSpan" id="kobo.13.1">https://www.packtpub.com/application-development/learning-object-oriented-programming</span></a><span class="koboSpan" id="kobo.14.1">).</span></div>
<p><span class="koboSpan" id="kobo.15.1">There is a correspondence between the two schemes in the four elements implied:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">Issuer (sender): It is the method that makes the call</span></li>
<li><span class="koboSpan" id="kobo.17.1">Receiver: It is another class (or the same) responding in another method</span></li>
<li><span class="koboSpan" id="kobo.18.1">Channel: It is the environment, replaced by a managed environment in .NET</span></li>
<li><span class="koboSpan" id="kobo.19.1">Message: The set of values passed to the receiver (the EventArgs in .NET)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.20.1">Let's think of a Windows app in which the user interface generates events, as, for example, when we use a button to close the window. </span><span class="koboSpan" id="kobo.20.2">The piece of code that represents such a scenario is expressed with some code like this:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">    private void btnClose_Click(object sender, EventArgs e)
    {
      this.Close();
    } </span></pre>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img height="185" width="381" src="assets/324631da-adcb-4d77-80f8-0e36b697c692.png"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">Who launches the execution of this code? </span><span class="koboSpan" id="kobo.23.2">Well, the </span><span class="packt_screen"><span class="koboSpan" id="kobo.24.1">Button</span></span><span class="koboSpan" id="kobo.25.1"> object, when we program the click event includes the following code in the designer's section of the </span><kbd><span class="koboSpan" id="kobo.26.1">Form</span></kbd><span class="koboSpan" id="kobo.27.1"> class:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">    this.btnClose.Click += new System.EventHandler(this.btnClose_Click);</span></pre>
<p><span class="koboSpan" id="kobo.29.1">This creates a delegate of type </span><kbd><span class="koboSpan" id="kobo.30.1">EventHandler</span></kbd><span class="koboSpan" id="kobo.31.1"> (the default one) which is going to be in charge of calling the destination method, every time the user clicks on it. </span><span class="koboSpan" id="kobo.31.2">To avoid possible problems, that event is just a class with some characteristics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.32.1">Its signature is the same as the method to be called. </span><span class="koboSpan" id="kobo.32.2">In this manner, possible casting problems are avoided since there is no need for type conversions.</span></li>
<li><span class="koboSpan" id="kobo.33.1">The delegate checks for the presence and availability of the </span><kbd><span class="koboSpan" id="kobo.34.1">btnClose_Click</span></kbd><span class="koboSpan" id="kobo.35.1"> method before the call, so it guarantees there are no pointer-to-null problems.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">Given that casting and pointers-to-nowhere were the two of the main causes of the infamous BSODs (Blue Screens of Death), the implantation of this architecture was something crucial from the very beginning of .NET.</span></p>
<p><span class="koboSpan" id="kobo.37.1">However, there is something else here that implies Method Injection, if you analyze the code and, even in those cases, like in the next demo, when the delegate is not the default.</span></p>
<p><span class="koboSpan" id="kobo.38.1">To really appreciate this point, let's program the </span><kbd><span class="koboSpan" id="kobo.39.1">FormClosing</span></kbd><span class="koboSpan" id="kobo.40.1"> event that will be launched whenever the user clicks the </span><span class="packt_screen"><span class="koboSpan" id="kobo.41.1">Close</span></span><span class="koboSpan" id="kobo.42.1"> button or tries to close the window in any of the other available ways: </span><em><span class="koboSpan" id="kobo.43.1">Alt</span></em><span class="koboSpan" id="kobo.44.1"> + </span><em><span class="koboSpan" id="kobo.45.1">F4</span></em><span class="koboSpan" id="kobo.46.1">, the window's </span><span class="packt_screen"><span class="koboSpan" id="kobo.47.1">x</span></span><span class="koboSpan" id="kobo.48.1"> button, or the window's menu:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.49.1"><img src="assets/1b7a2985-0940-4f35-8ffe-c240ca1ab426.png"/></span></div>
<p><span class="koboSpan" id="kobo.50.1">As you can see, this time the second argument of the </span><kbd><span class="koboSpan" id="kobo.51.1">FormClosing</span></kbd><span class="koboSpan" id="kobo.52.1"> event is not the default, but an instance of an object that inherits from </span><kbd><span class="koboSpan" id="kobo.53.1">EventArgs</span></kbd><span class="koboSpan" id="kobo.54.1">, and encloses extra information providing the context, that we were talking about.</span></p>
<p><span class="koboSpan" id="kobo.55.1">Actually, that object holds two properties: </span><kbd><span class="koboSpan" id="kobo.56.1">Cancel</span></kbd><span class="koboSpan" id="kobo.57.1"> (which is assignable and forces a stop in the exit procedure), and </span><kbd><span class="koboSpan" id="kobo.58.1">CloseReason</span></kbd><span class="koboSpan" id="kobo.59.1">, a read-only property that indicates which mechanism really launched the closing process.</span></p>
<p><span class="koboSpan" id="kobo.60.1">So, we're not programming or instantiating this parameter: it is given to us via injection, every time we define an event procedure. </span><span class="koboSpan" id="kobo.60.2">And that internal injection system is responsible for providing the information relevant to the execution context. </span><span class="koboSpan" id="kobo.60.3">This is a clear sample of method injection.</span></p>
<p><span class="koboSpan" id="kobo.61.1">If you peek into the definition of the </span><kbd><span class="koboSpan" id="kobo.62.1">FormClosingEventArgs</span></kbd><span class="koboSpan" id="kobo.63.1"> parameter, you will see that it is, indeed, another class that inherits from </span><kbd><span class="koboSpan" id="kobo.64.1">CancelEventArgs</span></kbd><span class="koboSpan" id="kobo.65.1"> (which, in turn, inherits from EventArgs):</span></p>
<pre><span class="koboSpan" id="kobo.66.1">    public class FormClosingEventArgs : CancelEventArgs
    {
     //
     // Summary:
     // Initializes a new instance of the </span><br/><span class="koboSpan" id="kobo.67.1">            System.Windows.Forms.FormClosingEventArgs class.
     </span><span class="koboSpan" id="kobo.67.2">//
     // Parameters:
     // closeReason:
     // A System.Windows.Forms.CloseReason value that represents </span><br/><span class="koboSpan" id="kobo.68.1">         the reason why the form
     // is being closed.
     </span><span class="koboSpan" id="kobo.68.2">//
     // cancel:
     // true to cancel the event; otherwise, false.
     </span><span class="koboSpan" id="kobo.68.3">public FormClosingEventArgs(CloseReason closeReason, bool cancel);

     //
     // Summary:
     // Gets a value that indicates why the form is being closed.
     </span><span class="koboSpan" id="kobo.68.4">//
     // Returns:
     // One of the System.Windows.Forms.CloseReason enumerated values.
     </span><span class="koboSpan" id="kobo.68.5">public CloseReason CloseReason { get; }
   }  </span></pre>
<p><span class="koboSpan" id="kobo.69.1">It's interesting to note that </span><kbd><span class="koboSpan" id="kobo.70.1">ClosingEventArgs</span></kbd><span class="koboSpan" id="kobo.71.1"> also belongs to the namespace </span><kbd><span class="koboSpan" id="kobo.72.1">System.ComponentModel</span></kbd><span class="koboSpan" id="kobo.73.1"> that we mentioned previously.</span></p>
<p><span class="koboSpan" id="kobo.74.1">So, even when we're doing something as simple as closing a window, we're implicitly using method injection, that is at the heart of the .NET Framework.</span></p>
<p><span class="koboSpan" id="kobo.75.1">This architecture can be extended by the user in many ways, even using techniques like event chaining when we need to concatenate processes that depend on the user's choice and that are usually generated via events, for example.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.76.1">A typical case for even chaining is when a user's selection from a combo (Like </span><span class="packt_screen"><span class="koboSpan" id="kobo.77.1">Select a Country</span></span><span class="koboSpan" id="kobo.78.1">), generates code that fills up another combo, let's say </span><span class="packt_screen"><span class="koboSpan" id="kobo.79.1">Select a City</span></span><span class="koboSpan" id="kobo.80.1">. </span><span class="koboSpan" id="kobo.80.2">You first have to select the country if you want the cities combo to be filled with the cities belonging to a given country.</span></div>
<p><span class="koboSpan" id="kobo.81.1">One such case could be when the closing process of a window (something like the preceding code shown) requires an extra user intervention. </span><span class="koboSpan" id="kobo.81.2">For instance, imagine that you have to ask the user if he/she wants to save the audits (or perform any other action) but only in the case that a previous question is affirmative, like confirming that the user wants to exit the application (which might, in turn, depend on other conditions, like the </span><kbd><span class="koboSpan" id="kobo.82.1">CloseReason</span></kbd><span class="koboSpan" id="kobo.83.1"> expressed in the previous code of the FormClosing event.</span></p>
<p><span class="koboSpan" id="kobo.84.1">One possible approach would be to create a generic event on our own, that could be launched if the requested conditions apply. </span><span class="koboSpan" id="kobo.84.2">Let's say that only if </span><kbd><span class="koboSpan" id="kobo.85.1">ClosingReason</span></kbd><span class="koboSpan" id="kobo.86.1"> is </span><kbd><span class="koboSpan" id="kobo.87.1">CloseReason.UserClosing</span></kbd><span class="koboSpan" id="kobo.88.1">, we should ask the user to confirm application exit and, in case the answer is positive, ask him again if he/she wants to save the information.</span></p>
<p><span class="koboSpan" id="kobo.89.1">We could write the following:</span></p>
<pre><span class="koboSpan" id="kobo.90.1">    private void frmMethodInjection_FormClosing(object sender,</span><br/><span class="koboSpan" id="kobo.91.1">       FormClosingEventArgs e)
    {
      if(e.CloseReason == CloseReason.UserClosing)
      {
        var res = MessageBox.Show("Confirm application exit?", "Notice",
        MessageBoxButtons.YesNo, MessageBoxIcon.Question);
        if (res == DialogResult.Yes)
        FormClosingExtended?.Invoke(this, DateTime.Now.ToLongTimeString());
        else e.Cancel = true;
      }
    }
    public event EventHandler&lt;string&gt; FormClosingExtended; </span></pre>
<p><span class="koboSpan" id="kobo.92.1">So, we're invoking the event </span><kbd><span class="koboSpan" id="kobo.93.1">FormClosingExtended</span></kbd><span class="koboSpan" id="kobo.94.1"> only when the if block evaluates to true. </span><span class="koboSpan" id="kobo.94.2">But, using the new generic event handler we can pass login information to another event that jumps from there to a distinct event procedure:</span></p>
<pre><span class="koboSpan" id="kobo.95.1">    private void FrmMethodInjection_FormClosingExtended(object</span><br/><span class="koboSpan" id="kobo.96.1">       sender, string e)
    {
      var ans = MessageBox.Show($"Save Closing time: ({e})?","Notice",
      MessageBoxButtons.YesNo,MessageBoxIcon.Question);
      if (ans == DialogResult.Yes)
      {
         File.WriteAllText("ClosingTime.txt", e);
      }  
    } </span></pre>
<p><span class="koboSpan" id="kobo.97.1">This event procedure receives data in the e argument and also asks the user if he/she wants to save it as audit information. </span><span class="koboSpan" id="kobo.97.2">In this manner, we don't have to concatenate two </span><kbd><span class="koboSpan" id="kobo.98.1">MessageBox</span></kbd><span class="koboSpan" id="kobo.99.1"> calls and the code is clearly separated.</span></p>
<p><span class="koboSpan" id="kobo.100.1">Besides that, since the e argument could be a generic event handler of any kind, the type of information passed as the event argument, could also be of any kind, of any complexity level. </span><span class="koboSpan" id="kobo.100.2">For instance, it could be an object with its own methods suitable for validation purposes, security checking, etc.</span></p>
<p><span class="koboSpan" id="kobo.101.1">The only thing missing in the code is to define the event handlers for each of the events implied in the process, which we can do inside the </span><kbd><span class="koboSpan" id="kobo.102.1">MethodInjection</span></kbd><span class="koboSpan" id="kobo.103.1"> constructor:</span></p>
<pre><span class="koboSpan" id="kobo.104.1">    public frmMethodInjection()
    {
      InitializeComponent();
      this.FormClosing += frmMethodInjection_FormClosing;
      FormClosingExtended += FrmMethodInjection_FormClosingExtended;
    }</span></pre>
<p><span class="koboSpan" id="kobo.105.1">So, in terms of DI, we're using the internal injection engine inside .NET Framework in two different ways:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.106.1">In the first case, to obtain information passed to us by the framework in relation to the cause that provoked that event to happen (</span><kbd><span class="koboSpan" id="kobo.107.1">ClosingReason</span></kbd><span class="koboSpan" id="kobo.108.1">).</span></li>
<li><span class="koboSpan" id="kobo.109.1">In the second, because we have implemented our own event, that is executed in concatenation to the previous one and receives the required information expecting the user's approval.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.110.1">Note that, in case that no business logic argument is required for the second event handler, we could have registered it also for the FormClosing event, since events are multicast in .NET</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DI containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In everyday practice, a good part of the plumbing to have DI working is not done via manual coding, but using something called DI Containers (also called IoC Containers). </span><span class="koboSpan" id="kobo.2.2">The previous demo using the .NET Framework event's system implies the existence of some DI Container.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Basically, a DI Container is a software library that facilitates the use of Dependency Injection and its based methodologies, like object composition, lifetime management, and so on. </span><span class="koboSpan" id="kobo.3.2">This is quite convenient for the programmer, who doesn't have to worry about the details of creation, destruction, etc.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.4.1">Many people have some confusion with DI and IoC. </span><span class="koboSpan" id="kobo.4.2">You can refer to this website to clear out any confusions: </span><a href="http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection"><span class="koboSpan" id="kobo.5.1">http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection.</span></a></div>
<p><span class="koboSpan" id="kobo.6.1">In many cases, DI Containers enforce several good practices, like avoiding duplication of instances, by supplying singleton instances of the required component, like it happens in AngularJS since the initial versions.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In .NET, as we have mentioned, IoC is present in several scenarios, and the following image shows some of the main components that use this technique:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="270" width="443" src="assets/da9d1376-b23a-441a-b0ee-5602c2c34a19.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1">(Image courtesy: </span><a href="https://hotproton.com/category/dependency-injection/"><span class="koboSpan" id="kobo.10.1">https://hotproton.com/category/dependency-injection/</span></a><span class="koboSpan" id="kobo.11.1">)</span></div>
<p><span class="koboSpan" id="kobo.12.1">As you can see in the graphic, .NET (even in the previous versions), holds several components that provide Inversion of Control (IoC), either linked to Events and Delegates, as we've seen in previous demos, or as Service Locators, or DI Injection mechanisms.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Service locators</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Basically, a service locator is just a design pattern that instructs the implementer on how to construct DI containers capable of obtaining a service with a strong abstraction layer.</span></p>
<p><span class="koboSpan" id="kobo.3.1">There's a condition that all service locators require: services have to be registered, so they can be later found and served at the code's request.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Wikipedia (</span><a href="http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection"><span class="koboSpan" id="kobo.5.1">http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection</span></a><span class="koboSpan" id="kobo.6.1">) summarizes the advantages of Service Locators in three main points:</span></p>
<ul>
<li>
<p><span class="koboSpan" id="kobo.7.1">The service locator can act as a simple run-time linker. </span><span class="koboSpan" id="kobo.7.2">This allows code to be added at run-time without re-compiling the application, and in some cases without having to even restart it.</span></p>
</li>
<li>
<div><span class="koboSpan" id="kobo.8.1">Applications can optimize themselves at run-time by selectively adding and removing items from the service locator. </span><span class="koboSpan" id="kobo.8.2">For example, an application can detect that it has a better library for reading JPG images available than the default one, and alter the registry accordingly.</span></div>
</li>
<li>
<p><span class="koboSpan" id="kobo.9.1">Large sections of a library or application can be completely separated. </span><span class="koboSpan" id="kobo.9.2">The only link between them becomes the registry.</span></p>
</li>
</ul>
<p><span class="koboSpan" id="kobo.10.1">In general, we can say the application of the Dependency Inversion principle leads to the construction of IoC containers and they reflect in concrete DI techniques and Service Locators. </span><span class="koboSpan" id="kobo.10.2">(See the following diagram):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img height="274" width="398" src="assets/ae91c95e-f636-47b9-9073-e76f66fcfa59.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1">(Image courtesy: </span><a href="http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/"><span class="koboSpan" id="kobo.13.1">http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/</span></a><span class="koboSpan" id="kobo.14.1">)</span></div>
<p><span class="koboSpan" id="kobo.15.1">Of course, these advantages don't go without their counterparts. </span><span class="koboSpan" id="kobo.15.2">Possible problems include the registry acting like a black box for the rest of the application, uniqueness, security vulnerabilities, hiding class dependencies, adding some testing difficulties, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DI Containers for .NET</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Besides the internal functionality related to DI inside .NET, it is very common to use external containers that provide extra or extended functionality to programmers, and, being .NET--a very popular programming framework, many have proliferated in recent years.</span></p>
<p><span class="koboSpan" id="kobo.3.1">So, our criteria here will be showing the basic implementation of those that seem to have a greater acceptance in the community, like Unity, Castle Windsor, StructureMap, and Autofac.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Actually, the number of choices available has kept growing in the last few years, and some of them are pretty popular as well, like Ninject, Simple Injector, Dynamo, LinFu, Spring.NET, Hiro, and so on, so our choice, in this case, was mainly driven by the level of implementation in the community, their ease of use, their API's consistency, and the performance tests in the latest versions. </span><span class="koboSpan" id="kobo.4.2">Since I don't want to pronounce myself about any of those tests, you can take a look at different benchmarks available on the web, and you'll probably come to the same or similar conclusion as I did.</span></p>
<p><span class="koboSpan" id="kobo.5.1">These DI Containers (and others) share a few things in common: they all require a previous configuration, and they have the ability to resolve the required dependencies at runtime. </span><span class="koboSpan" id="kobo.5.2">The following schema shows an approach to this idea:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"><img height="130" width="332" src="assets/06bfc163-a1c4-4682-82a1-e65663472e37.png"/></span></div>
<p><span class="koboSpan" id="kobo.7.1">In practice, this means we will instantiate and configure a container object, and later on, we'll ask the container to resolve the required dependencies in one or more locations within our code.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Besides that, in most of the cases, components are resolved from the same instance that we initially instantiate.</span></p>
<p><span class="koboSpan" id="kobo.9.1">A common (and very simple) context for our demos:</span></p>
<p><span class="koboSpan" id="kobo.10.1">Since complications will show up themselves when coding real-life applications, I've chosen a very, very, simple starting point, that can serve us as a common scenario to solve the DI problems it presents. </span><span class="koboSpan" id="kobo.10.2">It's based on our previous idea of the </span><kbd><span class="koboSpan" id="kobo.11.1">MovieReader</span></kbd><span class="koboSpan" id="kobo.12.1"> but let's say in this case that we don't even read anything from disk (only display a message in the console), to focus on the code's architecture and not on the details of its implementation.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The demo proposes the existence of two classes in charge of reading some books' information from the disk, and they both share a common interface </span><kbd><span class="koboSpan" id="kobo.14.1">IBookReader</span></kbd><span class="koboSpan" id="kobo.15.1">, which implements a unique method </span><kbd><span class="koboSpan" id="kobo.16.1">ReadBooks()</span></kbd><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">These three elements comprise the </span><span class="packt_screen"><span class="koboSpan" id="kobo.18.1">Data Access Layer</span></span><span class="koboSpan" id="kobo.19.1">:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">     // Data Access Layer
     public interface IBookReader
     {
       void ReadBooks();
     }
     public class XMLBookReader : IBookReader
     {
       public void ReadBooks()
       {
         Console.WriteLine("Books read in XML Format");
       }
     }
     public class JSONBookReader : IBookReader
     {
       public void ReadBooks()
       {
         Console.WriteLine("Books read in JSON Format");
       }
     }</span></pre>
<p><span class="koboSpan" id="kobo.21.1">Pretty simple, right? </span><span class="koboSpan" id="kobo.21.2">Now, we build another succinct </span><span class="packt_screen"><span class="koboSpan" id="kobo.22.1">Business Layer</span></span><span class="koboSpan" id="kobo.23.1">, made up of a class called </span><kbd><span class="koboSpan" id="kobo.24.1">BookManager</span></kbd><span class="koboSpan" id="kobo.25.1">, whose only purpose is to perform business logic, so it exposes a public constructor that receives an instance of one of the two possible readers, and implements a call to the </span><kbd><span class="koboSpan" id="kobo.26.1">ReadBooks</span></kbd><span class="koboSpan" id="kobo.27.1"> method, that in turn, will refer to the reading method that corresponds to each case:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">    public class BookManager
    {
      public IBookReader bookReader;
      public BookManager(IBookReader reader)
      {
        bookReader = reader;
      }
      public void ReadBooks()
      {
        bookReader.ReadBooks();
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.29.1">Finally, in the user interface, that in this case is the </span><kbd><span class="koboSpan" id="kobo.30.1">Console</span></kbd><span class="koboSpan" id="kobo.31.1">, we ask the user to decide the reading mechanism and call the corresponding version of the </span><kbd><span class="koboSpan" id="kobo.32.1">BookManager</span></kbd><span class="koboSpan" id="kobo.33.1">, so we can call the </span><kbd><span class="koboSpan" id="kobo.34.1">ReadBooks</span></kbd><span class="koboSpan" id="kobo.35.1"> method:</span></p>
<pre><span class="koboSpan" id="kobo.36.1">    static void Main(string[] args)
    {
      UnityContainer uc = new UnityContainer();
      BookManager bm;
      Console.WriteLine("Please, select reading type (XML, JSON)");
      var ans = Console.ReadLine();
      if (ans.ToLower() == "xml")
      {
         bm = new BookManager(new XMLBookReader());
      }
      else { bm = new BookManager(new JSONBookReader()); }
        bm.ReadBooks();
      Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.37.1">Up to this point, it's a very simple code, already using some dependency inversion, but still stuck to the creation of the type of reader in the user interface. </span><span class="koboSpan" id="kobo.37.2">That's exactly what we obtain when we use an external creation mechanism that takes care of this work for us.</span></p>
<p><span class="koboSpan" id="kobo.38.1">Let's see now how we can change this using the distinct DI Containers mentioned previously.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using Unity Container</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The Unity container has been in place for quite a few years now. </span><span class="koboSpan" id="kobo.2.2">Somehow, it was the official Microsoft external container and has been linked to the </span><em><span class="koboSpan" id="kobo.3.1">Patterns &amp; Practices</span></em><span class="koboSpan" id="kobo.4.1"> initiative for many years.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.5.1">Please note that Unity is not an official Microsoft product or does not belong to the Patterns &amp; Practices team anymore. </span><span class="koboSpan" id="kobo.5.2">The project has been redirected to other people (Pablo Cibraro and Pedro Wood), as Immo Landwerth published in .NET Blog in 2015 (</span><a href="https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/"><span class="koboSpan" id="kobo.6.1">https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/</span></a><span class="koboSpan" id="kobo.7.1">), commenting: "</span><em><span class="koboSpan" id="kobo.8.1">Dependency injection containers for .NET have continued to mature and evolve significantly. </span><span class="koboSpan" id="kobo.8.2">In addition, open source components are now more accepted. </span><span class="koboSpan" id="kobo.8.3">The need for having an "official" container from Microsoft is no longer as widespread as it once was.</span></em><span class="koboSpan" id="kobo.9.1">"</span></p>
<p><span class="koboSpan" id="kobo.10.1">That said, Unity is still a very common feature in thousands of projects, and it has reached version 4.01, which you can install inside any project using the </span><kbd><span class="koboSpan" id="kobo.11.1">NuGet Package Manager</span></kbd><span class="koboSpan" id="kobo.12.1"> available from the contextual menu of the </span><kbd><span class="koboSpan" id="kobo.13.1">Solution Explorer,</span></kbd><span class="koboSpan" id="kobo.14.1"> or the </span><kbd><span class="koboSpan" id="kobo.15.1">Project</span></kbd><span class="koboSpan" id="kobo.16.1"> menu as well, either in V. </span><span class="koboSpan" id="kobo.16.2">Studio 2017 or other versions.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Once installed, you'll see that it really references two different libraries: Unity 4.01 and the CommonServiceLocator 1.30 library, as you can see in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"><img src="assets/e4df937a-fc0a-47b4-b4d9-00d687b67d88.png"/></span></div>
<p><span class="koboSpan" id="kobo.19.1">Once installed, you'll see four new references to DLL's in the Solution's Explorer: three of them belong to Unity and the fourth one to </span><kbd><span class="koboSpan" id="kobo.20.1">CommonServiceLocator</span></kbd><span class="koboSpan" id="kobo.21.1">:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img height="260" width="386" src="assets/f14847a3-8bd7-45c7-a3cd-d7c267bc37c3.png"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">Inside the </span><kbd><span class="koboSpan" id="kobo.24.1">Microsoft.Practices.Unity.Configuration</span></kbd><span class="koboSpan" id="kobo.25.1"> library, you have utilities that allow writing the configuration required in an XML file, so that it serves as the initial settlement for the DI Container. </span><span class="koboSpan" id="kobo.25.2">Classes in that namespace will allow you to read and configure a given execution context based on that XML.</span></p>
<p><span class="koboSpan" id="kobo.26.1">On the other side, the </span><kbd><span class="koboSpan" id="kobo.27.1">Microsoft.Practices.Unity.RegistrationByConvention</span></kbd><span class="koboSpan" id="kobo.28.1"> library is intended to provide a programmable way of configuration to register multiple types with the container automatically by using a set of rules and conventions, as the official documentation defines (</span><a href="https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx"><span class="koboSpan" id="kobo.29.1">https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx</span></a><span class="koboSpan" id="kobo.30.1">).</span></p>
<p><span class="koboSpan" id="kobo.31.1">Now, if we just want to register those classes belonging to our </span><span class="packt_screen"><span class="koboSpan" id="kobo.32.1">Business Layer</span></span><span class="koboSpan" id="kobo.33.1"> and </span><span class="packt_screen"><span class="koboSpan" id="kobo.34.1">Data Access Layer</span></span><span class="koboSpan" id="kobo.35.1">, the most evident way to include all elements in our business model and have our data ready, would be something like this:</span></p>
<pre><span class="koboSpan" id="kobo.36.1">    static void Main(string[] args)
    {
      UnityContainer uc = new UnityContainer();
      uc.RegisterType&lt;BookManager&gt;();
      uc.RegisterType&lt;IBookReader, XMLBookReader&gt;();
      uc.RegisterType&lt;IBookReader, JSONBookReader&gt;();
      BookManager bm = uc.Resolve&lt;BookManager&gt;();
      bm.ReadBooks();
      Console.ReadLine();
   }</span></pre>
<p><span class="koboSpan" id="kobo.37.1">Notice, however, that we're defining </span><kbd><span class="koboSpan" id="kobo.38.1">BookManager</span></kbd><span class="koboSpan" id="kobo.39.1"> together with </span><kbd><span class="koboSpan" id="kobo.40.1">XMLBookReader</span></kbd><span class="koboSpan" id="kobo.41.1"> and </span><kbd><span class="koboSpan" id="kobo.42.1">JSONBookReader</span></kbd><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">This means that if we run the code, we get an instance of the last registered class (</span><kbd><span class="koboSpan" id="kobo.44.1">JSONBookReader</span></kbd><span class="koboSpan" id="kobo.45.1">), which becomes the default option. </span><span class="koboSpan" id="kobo.45.2">The reason is that we're not naming these registrations, so they're assigned unnamed identifiers.</span></p>
<p><span class="koboSpan" id="kobo.46.1">You can test the demo inside </span><kbd><span class="koboSpan" id="kobo.47.1">Chapter02_02.Unity</span></kbd><span class="koboSpan" id="kobo.48.1"> namespace and insert breakpoints to prove it.</span></p>
<p><span class="koboSpan" id="kobo.49.1">To reproduce the initial situation in which the user selects the format, we need to register distinct aliases for registered types, so they can be resolved at runtime, passing the concrete version that we need.</span></p>
<p><span class="koboSpan" id="kobo.50.1">Besides that, notice that Unity plays the role that was previously playing the </span><kbd><span class="koboSpan" id="kobo.51.1">BookManager</span></kbd><span class="koboSpan" id="kobo.52.1"> class. </span><span class="koboSpan" id="kobo.52.2">So in this case, we don't need the </span><kbd><span class="koboSpan" id="kobo.53.1">BookManager</span></kbd><span class="koboSpan" id="kobo.54.1"> class anymore:</span></p>
<pre><span class="koboSpan" id="kobo.55.1">    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type (XML, JSON)");
      // we asume a predefault value
      var format = (Console.ReadLine() != "xml") ? </span><span class="koboSpan" id="kobo.55.2">"json" : "xml";
      UnityContainer uc = new UnityContainer();
      uc.RegisterType&lt;IBookReader, XMLBookReader&gt;("xml");
      uc.RegisterType&lt;IBookReader, JSONBookReader&gt;("json");
      IBookReader ibr = uc.Resolve&lt;IBookReader&gt;(format);
      ibr.ReadBooks();
      Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.56.1">Now, Unity resolves the dependency with the parameter we pass to the </span><kbd><span class="koboSpan" id="kobo.57.1">Resolve()</span></kbd><span class="koboSpan" id="kobo.58.1"> method, as we can see it by setting a breakpoint in this line, or simply, watching the output.</span></p>
<p><span class="koboSpan" id="kobo.59.1">The </span><kbd><span class="koboSpan" id="kobo.60.1">UnityContainer</span></kbd><span class="koboSpan" id="kobo.61.1"> class admits alternative registration mechanisms. </span><span class="koboSpan" id="kobo.61.2">For example, we could use a new business layer class entirely dedicated to Unity registration, with the following code (notice that we should reference </span><kbd><span class="koboSpan" id="kobo.62.1">Microsoft.Practices.Unity</span></kbd><span class="koboSpan" id="kobo.63.1"> in the </span><kbd><span class="koboSpan" id="kobo.64.1">using</span></kbd><span class="koboSpan" id="kobo.65.1"> section of our code):</span></p>
<pre><span class="koboSpan" id="kobo.66.1">    public class UnityRegistration
    {
      public void Register()
      {
        using (var container = new UnityContainer())
        {
          container.RegisterTypes(
          AllClasses.FromLoadedAssemblies(),
          WithMappings.FromAllInterfaces,
          WithName.Default,
          WithLifetime.ContainerControlled);
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.67.1">In this manner, all classes from the loaded assemblies are registered for Unity, all mappings (or correspondences) are defined between the existing interfaces and their implementing classes, their default names are used and their lifetime is assigned to be managed by the container, so it's the container itself which decides at runtime when to leave object's instances to the Garbage Collector.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using Castle Windsor</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the winners in benchmarks and usability tests, Castle Windsor has been around for quite some time, and now rallies all activities around its dedicated GitHub project site at </span><a href="https://github.com/castleproject/Windsor"><span class="koboSpan" id="kobo.3.1">https://github.com/castleproject/Windsor.</span></a></p>
<p><span class="koboSpan" id="kobo.4.1">The community around this project is very active and, at the time of writing these lines, has more than 500 stars and 265 forks, and they were preparing to release version 3.4. </span><span class="koboSpan" id="kobo.4.2">Of course, you can download it and install it separately, or use </span><kbd><span class="koboSpan" id="kobo.5.1">NuGet</span></kbd><span class="koboSpan" id="kobo.6.1"> and have it installed for your project in the usual manner:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img height="323" width="331" src="assets/c227ceb1-14f2-4b9c-9a8f-425c8c373af2.png"/></span></div>
<p><span class="koboSpan" id="kobo.8.1">The process of installation really installs two components: Castle.Core 3.3 and Castle.Windsor 3.4. </span><span class="koboSpan" id="kobo.8.2">Both work together, although they include several namespaces to cover many of the possible programming situations in which we might need dependency injection (and other features).</span></p>
<p><span class="koboSpan" id="kobo.9.1">Castle Windsor's API set is very rich in possibilities and the documentation in the official site lets you start quickly with some samples (see </span><a href="https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md"><span class="koboSpan" id="kobo.10.1">https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md</span></a><span class="koboSpan" id="kobo.11.1">).</span></p>
<p><span class="koboSpan" id="kobo.12.1">For our demo, we only have to reference those namespaces required to initialize the </span><kbd><span class="koboSpan" id="kobo.13.1">WindsorContainer</span></kbd><span class="koboSpan" id="kobo.14.1"> class and proceed with the registration:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    using Castle.Windsor;
    using Castle.MicroKernel.Registration; </span></pre>
<p><span class="koboSpan" id="kobo.16.1">The first one allows the creation of a new </span><kbd><span class="koboSpan" id="kobo.17.1">WindsorContainer</span></kbd><span class="koboSpan" id="kobo.18.1"> class, while the other defines the required classes for registration. </span><span class="koboSpan" id="kobo.18.2">The whole process is similar to the one we saw previously with Unity:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type (XML, JSON)");
      // we asume a predefault value
      var format = (Console.ReadLine() != "xml") ? </span><span class="koboSpan" id="kobo.19.2">"json" : "xml";
      var container = new WindsorContainer();
      container.Register(Component.For&lt;IBookReader&gt;().</span><br/><span class="koboSpan" id="kobo.20.1">         ImplementedBy&lt;XMLBookReader&gt;().Named("xml"));
      container.Register(Component.For&lt;IBookReader&gt;().</span><br/><span class="koboSpan" id="kobo.21.1">           ImplementedBy&lt;JSONBookReader&gt;().Named("json"));
      IBookReader ibr = container.Resolve&lt;IBookReader&gt;(format);
      ibr.ReadBooks();
      Console.ReadLine();
      // clean up, application exits
      container.Dispose();
    }</span></pre>
<p><span class="koboSpan" id="kobo.22.1">Notice how the Component class includes static, generic methods to allow definitions of any interface (</span><kbd><span class="koboSpan" id="kobo.23.1">IBookReader</span></kbd><span class="koboSpan" id="kobo.24.1">, here), and you can concatenate successive calls to indicate which class implements what interface and what name that we want to assign to each registration, so it can be solved at runtime later on.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Once the registration is completed, the way to resolve it in a concrete implementation accepts a format that is identical to the one we used with Unity.</span></p>
<p><span class="koboSpan" id="kobo.26.1">The code just runs exactly the same as in the previous demo.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using StructureMap</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The official site for this DI container defines precisely the differences and spirit behind this implementation:</span></p>
<p><kbd><span class="koboSpan" id="kobo.3.1">StructureMap</span></kbd><span class="koboSpan" id="kobo.4.1"> is the oldest, continuously used IoC/DI container for .NET dating back to its first public release and production usage all the way back in June 2004 on .NET 1.1. </span><span class="koboSpan" id="kobo.4.2">The current 4. </span><span class="koboSpan" id="kobo.4.3">release represents 12+ years of lessons learned in the StructureMap and greater .NET community--while also wiping away a lot of legacy design decisions that no longer make sense today.</span></p>
<p><span class="koboSpan" id="kobo.5.1">So, we're dealing with a veteran here, and that means stability, together with a wide presence in internet forums and coder's sites, like </span><kbd><span class="koboSpan" id="kobo.6.1">StackOverflow</span></kbd><span class="koboSpan" id="kobo.7.1">.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.8.1">The philosophy that lies behind usage and configuration is quite similar to the other two we've already seen, but it offers several ways to configure the application. </span><span class="koboSpan" id="kobo.8.2">As the official documentation states to this respect: "</span><em><span class="koboSpan" id="kobo.9.1">from release 3.0 onwards, StructureMap provides a streamlined fluent interface called the Registry DSL to configure a StructureMap Container with both explicit registrations and conventional auto-registrations.StructureMap no longer supports XML configuration or MEF-style attribute configuration -- but there is some facility for rolling your own attribute-based configuration support.</span></em><span class="koboSpan" id="kobo.10.1">"</span></p>
<p><span class="koboSpan" id="kobo.11.1">The main difference is that it recommends a configuration approach via lambda expressions, but still with similar mechanisms, as you can see in the following code used to create and configure the Container object in the same operation:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">    var container1 = new Container(c =&gt;
    {
      c.For&lt;IFoo&gt;().Use&lt;Foo&gt;();
      c.For&lt;IBar&gt;().Use&lt;Bar&gt;();
    });</span></pre>
<p><span class="koboSpan" id="kobo.13.1">The other main choice relies on creating a </span><kbd><span class="koboSpan" id="kobo.14.1">Registry</span></kbd><span class="koboSpan" id="kobo.15.1"> object and then configuring the container based on it. </span><span class="koboSpan" id="kobo.15.2">Something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">    public class FooBarRegistry : Registry
    {
      public FooBarRegistry()
      {
        For&lt;IFoo&gt;().Use&lt;Foo&gt;();
        For&lt;IBar&gt;().Use&lt;Bar&gt;();
      }
    }
    var container1 = new Container(new FooBarRegistry()); </span></pre>
<p><span class="koboSpan" id="kobo.17.1">All this depends on the architecture and complexity of the application to build. </span><span class="koboSpan" id="kobo.17.2">For our demo purposes, we will first reference the library (this time there is only one namespace), via NuGet, that presents this installation option:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"><img height="425" width="462" src="assets/10aa6b00-9d5f-4a77-a005-05e3df34616a.png"/></span></div>
<p><span class="koboSpan" id="kobo.19.1">And, for a basic configuration and usage, we only need to reference the basic </span><kbd><span class="koboSpan" id="kobo.20.1">StructureMap</span></kbd><span class="koboSpan" id="kobo.21.1"> namespace:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">     using StructureMap;</span></pre>
<p><span class="koboSpan" id="kobo.23.1">The source code equivalent to the previous demos would be (with identical results in execution):</span></p>
<pre><span class="koboSpan" id="kobo.24.1">    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type (XML, JSON)");
      // we asume a predefault value
      var format = (Console.ReadLine() != "xml") ? </span><span class="koboSpan" id="kobo.24.2">"json" : "xml";
      var container = new Container();

      // container configuration
      container = new Container(x =&gt; {
      x.For&lt;IBookReader&gt;().Add&lt;XMLBookReader&gt;().Named("xml");
      x.For&lt;IBookReader&gt;().Add&lt;JSONBookReader&gt;().Named("json");
    });
      var ibr = container.GetInstance&lt;IBookReader&gt;(format);
      ibr.ReadBooks();
      Console.ReadLine();
      // clean up, application exits
      container.Dispose();
    }</span></pre>
<p><span class="koboSpan" id="kobo.25.1">Notice how the container is configured by passing a lambda expression to the newly created instance of Container and, within the body expression, we use the following pattern:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">container à For &lt;Interface&gt; à Add(Class) à Named("alias")</span></pre>
<p><span class="koboSpan" id="kobo.27.1">The preceding pattern allows us to express as many registrations as we want in a single operation.</span></p>
<p><span class="koboSpan" id="kobo.28.1">There's only a slight variation in the way the </span><kbd><span class="koboSpan" id="kobo.29.1">IBookReader</span></kbd><span class="koboSpan" id="kobo.30.1"> instance is obtained because it doesn't use the resolve paradigm. </span><span class="koboSpan" id="kobo.30.2">In turn, we can find several methods of resolving instances, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.31.1"><img height="164" width="305" src="assets/ad0131e3-88bb-425f-a68b-a9e50357654d.png"/></span></div>
<p><span class="koboSpan" id="kobo.32.1">Of course, execution is the same as in the other cases and there is nothing really relevant in the output, which you can find in the source code for </span><kbd><span class="koboSpan" id="kobo.33.1">Chapter02_02.StructureMap</span></kbd><span class="koboSpan" id="kobo.34.1"> demo.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using Autofac</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We'll finish this short visit over .NET containers examining the basics of AutoFac, another DI Container well known in the community, and that claims to be up-to-date with versions that cover .NET Core, ASP.NET Core, Universal Windows Apps, and .NET Framework 4.5.1 and later versions. </span><span class="koboSpan" id="kobo.2.2">It also allows support for WCF-based applications.</span></p>
<p><span class="koboSpan" id="kobo.3.1">It has its own dedicated site (</span><a href="https://autofac.org/"><span class="koboSpan" id="kobo.4.1">https://autofac.org/</span></a><span class="koboSpan" id="kobo.5.1">) which serves as the starting point, although it is also referenced via </span><kbd><span class="koboSpan" id="kobo.6.1">NuGet</span></kbd><span class="koboSpan" id="kobo.7.1"> packages. </span><span class="koboSpan" id="kobo.7.2">Besides this, you will find references to several libraries, some specialized, in this page or NuGet.org at </span><a href="https://www.nuget.org/packages/Autofac/"><span class="koboSpan" id="kobo.8.1">https://www.nuget.org/packages/Autofac/.</span></a></p>
<p><span class="koboSpan" id="kobo.9.1">If you decide to keep on using </span><kbd><span class="koboSpan" id="kobo.10.1">NuGet</span></kbd><span class="koboSpan" id="kobo.11.1"> from Visual Studio, you should find the following reference, once you search for Autofac in the NuGet package editor:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="438" width="385" src="assets/a4622db5-fe37-4b33-a89d-fc3cf4d6d10c.png"/></span></div>
<p><span class="koboSpan" id="kobo.13.1">The standard architecture is similar to the other three we've already seen, with minor differences. </span><span class="koboSpan" id="kobo.13.2">For example, the container here is named </span><kbd><span class="koboSpan" id="kobo.14.1">ContainerBuilder</span></kbd><span class="koboSpan" id="kobo.15.1">.</span></p>
<p><span class="koboSpan" id="kobo.16.1">After its instantiation, we have to configure the required types and interfaces and, finally, we should call to the </span><kbd><span class="koboSpan" id="kobo.17.1">Build()</span></kbd><span class="koboSpan" id="kobo.18.1"> method of the </span><kbd><span class="koboSpan" id="kobo.19.1">ContainerBuilder</span></kbd><span class="koboSpan" id="kobo.20.1"> to have everything ready.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Although we might use an approach similar to the other demos, in this case, we decided to inject only the version chosen by the user. </span><span class="koboSpan" id="kobo.21.2">This can be easily accomplished with the following code:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type</span><br/><span class="koboSpan" id="kobo.23.1">         (XML, JSON)");
      // we asume a predefault value
      var builder = new ContainerBuilder();
      if (Console.ReadLine() != "json")
      {
        builder.RegisterType&lt;XMLBookReader&gt;().As&lt;IBookReader&gt;();
      }
      else
      {
        builder.RegisterType&lt;JSONBookReader&gt;().As&lt;IBookReader&gt;();
      }
      var container = builder.Build();
      var ibr = container.Resolve&lt;IBookReader&gt;();
      ibr.ReadBooks();
      Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.24.1">In short, we have many options regarding IoC containers, and many choices about the way to configure them, but all of them provide us with similar functionality: we can abstract dependencies that are resolved at a later time.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Of course, in this and other cases we could opt for other forms of configuration, like using XML or JSON files and also use more complex configuration classes to support all possible situations that our application requires.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Although this is only an introduction to IoC containers, if you are interested in these APIs, you will see that it is possible to handle the three aspects discussed at the beginning: Object Composition, Object Lifetime, and Interception.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Injection in other frameworks</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">.NET or Java are not the only programming environments in which we can find Dependency Injection containers. </span><span class="koboSpan" id="kobo.2.2">Many of the most popular JavaScript frameworks also support DI from its inception. </span><span class="koboSpan" id="kobo.2.3">This is the case for AngularJS.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DI in Angular</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">AngularJS (1.x) and Angular (2.x, 4.x, etc) are perhaps the most popular frameworks for JavaScript applications in use today. </span><span class="koboSpan" id="kobo.2.2">They are pretty different in their programming model and general purpose, so I will distinguish them both:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="180" width="180" src="assets/c9990bd7-3496-422d-91c2-305e39ce312b.png"/></span></div>
<p><span class="koboSpan" id="kobo.4.1">Angular frameworks are the result of a Google teamwork lead by Misko Hevery, Igor Minar, and Brad Green, which initially appeared in 2010. </span><span class="koboSpan" id="kobo.4.2">The project has bifurcated into two distinct branches: AngularJS 1.x for small/medium projects and Angular 2 (or just Angular) which is intended to cover the needs of big/complex projects and uses TypeScript as the programming language due to its strongly typed nature.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.5.1">In December 2016, they announced the adoption of a semantic versioning approach, together with a continuous delivery roadmap that will publish a new version every six months, very careful of breaking changes. </span><span class="koboSpan" id="kobo.5.2">The latest version is Angular 4, which appeared in March 2017, and is totally backward compatible with Angular 2.</span></div>
<p><span class="koboSpan" id="kobo.6.1">Both projects are also maintained by Google and, despite their different programming models and language, they share a few things in common: They promote the </span><strong><span class="koboSpan" id="kobo.7.1">Single Page Application</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">SPA</span></strong><span class="koboSpan" id="kobo.10.1">) model, and they use a </span><strong><span class="koboSpan" id="kobo.11.1">Model-view-controller</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong><span class="koboSpan" id="kobo.13.1">MVC</span></strong><span class="koboSpan" id="kobo.14.1">) architecture to provide a suitable separation of responsibilities from the first moment.</span></p>
<p><span class="koboSpan" id="kobo.15.1">AngularJS presents itself as a bunch of libraries so the user can choose only the ones needed for a given purpose, achieving that way a better granularity. </span><span class="koboSpan" id="kobo.15.2">All libraries are available via GitHub, NuGet, NPM, Bower, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Our first demo</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's get down to work with our first demo, and, from this initial approach, we will test how AngularJS provides an excellent, integrated dependency injection system, that facilitates programmers' work to a large extent.</span></p>
<p><span class="koboSpan" id="kobo.3.1">By the way, we can use any IDE to work with Angular, since the three languages implied (two in case we don't care about the visual aspects provided by CSS) are just HTML and JavaScript.</span></p>
<p><span class="koboSpan" id="kobo.4.1">However, I'll keep on using Visual Studio, which has a very good support for Angular programming and provides native Intellisense on Angular directives, and a pretty good debugging experience.</span></p>
<p><span class="koboSpan" id="kobo.5.1">So, let's start a new project or a new website (we don't need any compiled libraries). </span><span class="koboSpan" id="kobo.5.2">We can choose an </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">Empty Project</span></span><span class="koboSpan" id="kobo.7.1"> in the ASP.NET section. </span><span class="koboSpan" id="kobo.7.2">This creates a project with only a </span><kbd><span class="koboSpan" id="kobo.8.1">web.config</span></kbd><span class="koboSpan" id="kobo.9.1"> file in case we need to configure the </span><strong><span class="koboSpan" id="kobo.10.1">Internet Information Server</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong><span class="koboSpan" id="kobo.12.1">IIS</span></strong><span class="koboSpan" id="kobo.13.1">).</span></p>
<p><span class="koboSpan" id="kobo.14.1">Inside the project, we'll create a new HTML file, and once the project is saved we can add the Angular libraries in the usual manner, via the </span><kbd><span class="koboSpan" id="kobo.15.1">NuGet Package Manager</span></kbd><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">We should see that AngularJS is now in versions 1.6.x or higher (we should select Angular.Core for this demo, which is the basic module).</span></p>
<p><span class="koboSpan" id="kobo.17.1">Once we accept the installation, we'll see a new </span><kbd><span class="koboSpan" id="kobo.18.1">Scripts</span></kbd><span class="koboSpan" id="kobo.19.1"> folder containing the development (</span><kbd><span class="koboSpan" id="kobo.20.1">angular.js</span></kbd><span class="koboSpan" id="kobo.21.1">) and deployment (</span><kbd><span class="koboSpan" id="kobo.22.1">angular.min.js</span></kbd><span class="koboSpan" id="kobo.23.1">) versions of Angular 1.6, plus a Mock library for testing purposes.</span></p>
<p><span class="koboSpan" id="kobo.24.1">We just have to include the development library and create the minimum required plumbing to see Angular in action--just by including the library, some objects and services are loaded into memory and ready to go.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Especially, there is a </span><kbd><span class="koboSpan" id="kobo.26.1">$injector</span></kbd><span class="koboSpan" id="kobo.27.1"> object that will take care of retrieving object instances, instantiate types, load modules and invoke methods.</span></p>
<p><span class="koboSpan" id="kobo.28.1">Also, Angular creates an initial, basic model which serves as the root model for the application ($rootScope), and expects that the user marks an HTML element as the scope of the app. </span><span class="koboSpan" id="kobo.28.2">We'll do that in the </span><kbd><span class="koboSpan" id="kobo.29.1">&lt;body&gt; tag</span></kbd><span class="koboSpan" id="kobo.30.1">, name it </span><kbd><span class="koboSpan" id="kobo.31.1">app</span></kbd><span class="koboSpan" id="kobo.32.1">, and define a module with the same name, with the following syntax:</span></p>
<pre><span class="koboSpan" id="kobo.33.1">    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
     &lt;meta charset="utf-8" /&gt;
     &lt;title&gt;Dependency Injection Demo&lt;/title&gt;
     &lt;script src="Scripts/angular.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body ng-app="app"&gt;
     &lt;h1&gt;Dependency Injection Demo&lt;/h1&gt;
     &lt;h3&gt;Current time: {{ time }}&lt;/h3&gt;
     &lt;script&gt;
       var app = angular.module("app", []);
     &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;</span></pre>
<p><span class="koboSpan" id="kobo.34.1">Notice we use an Angular-specific attribute (</span><kbd><span class="koboSpan" id="kobo.35.1">ng-app</span></kbd><span class="koboSpan" id="kobo.36.1">) to mark the scope of our application. </span><span class="koboSpan" id="kobo.36.2">These attributes are called directives in Angular and they allow us to modify the DOM to suit our needs (All predefined directives start with </span><kbd><span class="koboSpan" id="kobo.37.1">ng-</span></kbd><span class="koboSpan" id="kobo.38.1">).</span></p>
<p><span class="koboSpan" id="kobo.39.1">Now, we want our page to show the local time when it loads in the browser. </span><span class="koboSpan" id="kobo.39.2">The angular mode to do this is to select a target area of the DOM and assign a controller to that area. </span><span class="koboSpan" id="kobo.39.3">We can do that including the </span><kbd><span class="koboSpan" id="kobo.40.1">ng-controller</span></kbd><span class="koboSpan" id="kobo.41.1"> directive inside the corresponding tag.</span></p>
<p><span class="koboSpan" id="kobo.42.1">As you can see in the code, next to the page's title we've included a </span><kbd><span class="koboSpan" id="kobo.43.1">&lt;h3&gt;</span></kbd><span class="koboSpan" id="kobo.44.1"> tag to hold that information, and inside that tag's text, a message, followed by </span><kbd><span class="koboSpan" id="kobo.45.1">{{ time }}</span></kbd><span class="koboSpan" id="kobo.46.1">.</span></p>
<p><span class="koboSpan" id="kobo.47.1">The double brackets syntax is one of the possible binding mechanisms that Angular uses to link data inside the model with the active view, and it's called </span><strong><span class="koboSpan" id="kobo.48.1">moustache syntax</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">Thus, we modify the tag in this way:</span></p>
<pre><span class="koboSpan" id="kobo.50.1">    &lt;h3 ng-controller="TimeController"&gt;Current time: </span><br/><span class="koboSpan" id="kobo.51.1">       {{ time }}&lt;/h3&gt;</span></pre>
<p><span class="koboSpan" id="kobo.52.1">Now we have a </span><kbd><span class="koboSpan" id="kobo.53.1">ng-controller</span></kbd><span class="koboSpan" id="kobo.54.1"> directive named </span><kbd><span class="koboSpan" id="kobo.55.1">TimeController</span></kbd><span class="koboSpan" id="kobo.56.1">, that we need to define inside the script. </span><span class="koboSpan" id="kobo.56.2">Controllers are defined by calling the app's main module, that we previously created, and passing a function as the second argument that will be in charge of the logic linked to that controller.</span></p>
<p><span class="koboSpan" id="kobo.57.1">And, here, we finally get to the Dependency Injection mechanism of AngularJS. </span><span class="koboSpan" id="kobo.57.2">This function should have access to the specific model created by Angular to hold the information managed by the controller. </span><span class="koboSpan" id="kobo.57.3">We do that via the </span><kbd><span class="koboSpan" id="kobo.58.1">$scope</span></kbd><span class="koboSpan" id="kobo.59.1"> object.</span></p>
<p><span class="koboSpan" id="kobo.60.1">Every controller has its own $scope (it's like a sub-model), which allows read/write operations in memory and permits binding between the moustache expressions in the DOM and data stored in that model.</span></p>
<p><span class="koboSpan" id="kobo.61.1">So, how does the user code access to that (or any other) service? </span><span class="koboSpan" id="kobo.61.2">Via DI, of course. </span><span class="koboSpan" id="kobo.61.3">The final code is surprisingly simple:</span></p>
<pre><span class="koboSpan" id="kobo.62.1">    &lt;body ng-app="app"&gt;
    &lt;h1&gt;Demo Dependency Injection&lt;/h1&gt;
    &lt;h3 ng-controller="TimeController"&gt;Current time: </span><br/><span class="koboSpan" id="kobo.63.1">       {{ time }}&lt;/h3&gt;
    &lt;script&gt;
      var app = angular.module("app", []);
      app.controller("TimeController", function ($scope) {
      $scope.time = new Date().toLocaleTimeString();
     });
    &lt;/script&gt;
    &lt;/body&gt;</span></pre>
<p><span class="koboSpan" id="kobo.64.1">As you see, the controller's definition receives a string to identify the controller's name, and an anonymous function, to hold the functionality linked to that controller.</span></p>
<p><span class="koboSpan" id="kobo.65.1">And, in that function, we just declared the $scope object: the Angular's injection system takes care of the rest. </span><span class="koboSpan" id="kobo.65.2">In the next line of code, we can use that object, with a total guarantee of its existence. </span><span class="koboSpan" id="kobo.65.3">Even further, Angular provides services and objects of this type using a Singleton approach, so there's no other $scope at the same time.</span></p>
<p><span class="koboSpan" id="kobo.66.1">Of course, the output is as expected, and every time we reload the page, the current time is updated:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.67.1"><img height="86" width="266" src="assets/bee9dac8-f393-4913-ae28-2b7d0891382c.png"/></span></div>
<p><span class="koboSpan" id="kobo.68.1">This philosophy is extended to any AngularJS object or service and even to those services that the user might want to create.</span></p>
<p><span class="koboSpan" id="kobo.69.1">In Angular (modern versions), the architecture is similar, only that it uses TypeScript and the preferred way for DI is the constructor-injection model we saw in other demos, given that TypeScript is a totally object-oriented language.</span></p>
<p><span class="koboSpan" id="kobo.70.1">In </span><a href="48b807a5-dcd8-479d-b71b-670d93f20cc8.xhtml" target="_blank"><span class="koboSpan" id="kobo.71.1">Chapter 10</span></a><span class="koboSpan" id="kobo.72.1">, </span><em><span class="koboSpan" id="kobo.73.1">Dependency Injection in Other JavaScipt Frameworks</span></em><span class="koboSpan" id="kobo.74.1">, we'll cover Dependency Injection in JavaScript (ES6, or ES 2015, to be precise), TypeScript and Angular 2, so you can have a wider sight of today's implementations of DI in modern web frameworks.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we have focused on the principles and advantages of Dependency Injection, and how to implement it in C# starting from a very simple application and modifying it to achieve decoupling of classes.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Once we saw the foundations of DI, we've covered briefly three programming aspects that influence the way these techniques are applied: Object Composition, Object Lifetime, and Interception, as a first approach that we'll cover in more detail in further chapters.</span></p>
<p><span class="koboSpan" id="kobo.4.1">And, finally, we've seen how some popular IoC containers implement these concepts, together with a brief introduction to its use in other frameworks, like AngularJS.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In </span><a href="087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml" target="_blank"><span class="koboSpan" id="kobo.6.1">Chapter 3</span></a><span class="koboSpan" id="kobo.7.1">, </span><em><span class="koboSpan" id="kobo.8.1">Introducing Dependency Injection in .NET Core 2.0</span></em><span class="koboSpan" id="kobo.9.1">, we will begin the study of the most interesting features about Dependency Injection included in .NET Core.</span></p>


            </article>

            
        </section>
    </body></html>