<html><head></head><body>
        

                            
                    <h1 class="header-title">Filter Pipeline</h1>
                
            
            
                
<p>In this chapter, we will cover another essential topic in ASP.NET Core: the filter pipeline. Filters are a vital component that we can use to achieve cross-cutting implementation in our services. Although we have already seen how to implement cross-functionalities using the middleware pipeline, filters are more specialized components that are linked to the MVC pipeline. Therefore, filters can be used to implement more specific logic, related to the controller's execution. This chapter will show you how to implement these filters and will describe some concrete use cases.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>An introduction to filters in ASP.NET Core</li>
<li>How to implement and apply filters to the filter pipeline</li>
<li>Some concrete use cases for filters</li>
<li>How to use resolve dependencies in the filter pipeline</li>
</ul>
<p>This chapter provides information about the filter stack in .NET Core and how to use filters to enhance the features of our web services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to filters</h1>
                
            
            
                
<p>Filters come in handy when we wish to build <em>cross-cutting concepts</em> in the MVC stack of ASP.NET Core. They are useful when we wish to implement features such as authorization or caching. ASP.NET Core provides some out-of-the-box filter types. Each of these can be used for a specific purpose in our service:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 27.9768%"><strong>Filter type</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 71.4424%"><strong>Type description</strong></td>
</tr>
<tr>
<td style="width: 27.9768%">Authorization</td>
<td style="width: 71.4424%">
<p>This kind of filter is related to the authorization of users. It is the first filter that's executed in the filter pipeline and can short-circuit the pipeline of requests.</p>
</td>
</tr>
<tr>
<td style="width: 27.9768%">
<p class="mce-root">Resource</p>
</td>
<td style="width: 71.4424%">
<p>Resource filters run immediately after authorization filters and after the rest of the pipeline has completed. They're useful when we wish to implement caching or for performance implementations.</p>
</td>
</tr>
<tr>
<td style="width: 27.9768%">Action</td>
<td style="width: 71.4424%">
<p>Action filters are focused on the life cycle of action methods. They intercept and change the arguments and the returning results of action methods.</p>
</td>
</tr>
<tr>
<td style="width: 27.9768%">Exception</td>
<td style="width: 71.4424%">
<p>Exception filters are used to intercept and apply cross-cutting policies to unhandled exceptions.</p>
</td>
</tr>
<tr>
<td style="width: 27.9768%">Result</td>
<td style="width: 71.4424%">
<p class="mce-root">Result filters are executed immediately before and after the execution of an action result. They are usually implemented to change the formatting of the outcome. It is essential to note that they are executed only when the action method is completed successfully.</p>
</td>
</tr>
</tbody>
</table>
<p>It is crucial to note that filters act in the domain of the MVC middleware, which implies that action filters are unable to operate outside the MVC context. Therefore, filters are more specific than middleware; they can be applied to a subset of requests, and they have access to some MVC components, for example, <kbd>ModelState</kbd>.</p>
<p>The following diagram shows the workflow of different types of action filters in a request-response workflow:</p>
<div><img src="img/28daf453-5ea7-445f-af69-e684ee2c4393.png" style=""/></div>
<p>As you can see, in a request-response pipeline, different types of filters act at various stages. <em>Authorization filters</em> act before everything else and block the requests in the event any of the privileges are wrong. <em>Resource filters</em> operate before model validation and model binding of the request and also when the results of our request come back from the server. The <em>action filter</em> type acts before and after an action's invocation. Furthermore, if an action throws an exception, the <em>exception filter</em> is triggered. At the end of the pipeline, the <em>result filter</em> operates on the <kbd>IActionResult</kbd> final object instance. Now that we know about the different filter types that are provided by ASP.NET Core, we will look at some concrete implementation examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Concrete filter implementations</h1>
                
            
            
                
<p>In general, filters can be implemented by extending the built-in types provided by ASP.NET Core. Let's walk through a simple declaration of a custom action filter:</p>
<pre>using Microsoft.AspNetCore.Mvc.Filters;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>        public class CustomActionFilter : IActionFilter<br/>        {<br/>            public void OnActionExecuting(ActionExecutingContext context)<br/>            {<br/>                // do something before the action executes<br/>            }<br/><br/>            public void OnActionExecuted(ActionExecutedContext context)<br/>            {<br/>                // do something after the action executes<br/>            }<br/>        }<br/>}</pre>
<p>The <kbd>CustomActionFilter</kbd> class implements the <kbd>IActionFilter</kbd> interface type, which offers two different methods:</p>
<ul>
<li>The <kbd>OnActionExecuting</kbd> method is triggered before the execution of the action.</li>
<li>The <kbd>OnActionExecuted</kbd> method is executed after the action.</li>
</ul>
<p>Both methods receive the execution <kbd>context</kbd> as a callback parameter, which provides some useful information about the <em>filter's stack metadata</em>, the <em>controllers</em>, the <em>action arguments</em>, and <em>route data</em>. Furthermore, the <kbd>context</kbd> parameter also provides access to the <kbd>HttpContext</kbd> attribute we looked at in previous chapters. The <kbd>HttpContext</kbd> provides all the necessary properties so that we can access dependency injection services and the request/response data. ASP.NET Core heavily uses the asynchronous stack. This means it also provides an interface that we can use to implement asynchronous filters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchronous filters</h1>
                
            
            
                
<p class="mce-root">Filters support both asynchronous and synchronous behaviors. As we saw in the previous example, <kbd>CustomActionFilter</kbd> implements two synchronous methods: <kbd>OnActionExecuting</kbd> and <kbd>OnActionExecuted</kbd>. In the case of an asynchronous filter, the implementation is different:</p>
<pre>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>    public class CustomActionFilterAsync : IAsyncActionFilter<br/>    {<br/>        public <strong>async </strong><strong>Task OnActionExecutionAsync(ActionExecutingContext <br/>         context, </strong><strong>ActionExecutionDelegate next)</strong><br/>        {<br/>            //Before <br/> <br/>            var resultContext = await next();<br/> <br/>            //After<br/>        }<br/>    }<br/>}</pre>
<p><kbd>CustomActionFilterAsync</kbd> implements the <kbd>async</kbd> version of the action filter class, that is, <kbd>IAsyncActionFilter</kbd>, and implements only one method, that is, <kbd>OnActionExecutionAsync</kbd>. This template is similar to a middleware implementation; the <kbd>next()</kbd> method triggers the execution of the rest of the pipeline. Therefore, everything before the <kbd>await next()</kbd> statement is executed before the execution of the action filter, while everything after the <kbd>await next()</kbd> statement is performed after the action's execution. It is essential to note that the framework searches for the <kbd>async</kbd> implementation first and then for the <em>synchronous</em> implementation. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">The scope of filters</h1>
                
            
            
                
<p>Filters inherit a different scope based on their initialization in our codebase. In practice, a filter may have three different scopes:</p>
<ul>
<li><strong>Global scope</strong>: This means that the filter covers the whole MVC pipeline. Every call to a specific MVC route will pass through that filter.</li>
<li><strong>Controller scope</strong>: In this case, the filter is initialized as an attribute in one or multiple controller classes. It will act only on requests that have been directed to the target controllers.</li>
<li><strong>Action scope:</strong> The filter is initialized as an attribute in one or multiple action methods. It will act only on requests that have been directed to the target methods.</li>
</ul>
<p>It is also essential to understand that filters are executed, depending on the scope, in a specific order: first of all, all <em>global scope filters</em> run, followed by <em>controller scope filters</em>, and finally <em>action scope filters</em>. In the next subsection, we will look at the implementation of the different scopes in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The use of filters</h1>
                
            
            
                
<p>As we mentioned previously, filters can have three different scopes: <em>global</em>, <em>controller</em>, and <em>action</em>. In the first case, the filter is applied globally in the <kbd>Startup</kbd> class. In the other two cases, the filter is used in the form of an attribute and is usually applied to the controller class definition or the action method definition. Let's take a closer look at these different approaches. The application of a filter in the <kbd>Startup</kbd> class means that the filter covers all the routes in the MVC pipeline, as follows:</p>
<pre>    public class Startup<br/>    {<br/>        ...<br/>        <br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            services<br/>                .AddControllers(config =&gt; <strong>config.Filters.Add(new <br/>                 CustomFilter()</strong>));<br/>        }<br/><br/>        ...<br/>    }</pre>
<p>In this case, <kbd>CustomFilter</kbd> has a <em>global scope.</em> The <kbd>config.Filters</kbd> attribute is a collection of <kbd>IFilterMetadata</kbd> interfaces. This interface is used to describe the filters that are present in our MVC pipeline. It should be noted that the collection doesn't check duplicates, which means that we may potentially add two filters of the same type.</p>
<p>Since <kbd>FilterCollection</kbd> doesn't consider duplicates, it is possible that, in a large codebase, a filter type is accidentally initialized more than once, which may affect the performance of our service. It is vital to pay attention to code merges, especially in a distributed team. By using pull requests and holding code review meetings, this kind of silent issue can be avoided.</p>
<p>On the other hand<em>,</em> the <em>controller scope</em> and the <em>action scope</em> are restricted to a specific controller or action. The best way to use a filter on a particular controller or action is by extending a filter attribute. ASP.NET Core provides some built-in filter attributes. For each filter type, the framework provides a corresponding class that provides methods for overriding. For example, this is the case for the <kbd>ActionFilterAttribute</kbd> type:</p>
<pre>using Microsoft.AspNetCore.Mvc.Filters;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>        public class <strong>CustomControllerFilter </strong>: ActionFilterAttribute<br/>        {<br/>            public <strong>override void </strong><strong>OnActionExecuting</strong>(ActionExecutingContext <br/>             context)<br/>            {<br/>                // do something before the action executes<br/>            }<br/><br/>            public <strong>override void </strong><strong>OnActionExecuted</strong>(ActionExecutedContext <br/>             context)<br/>            {<br/>                // do something after the action executes<br/>            }<br/>        }<br/>}</pre>
<p>The  <kbd>CustomControllerFilter</kbd> extends the <kbd>ActionFilterAttribute</kbd> type, which contains the <kbd>OnActionExecuting</kbd> and <kbd>OnActionExecuted</kbd> methods. The filter can be applied to a specific controller class or action method using the syntax of the attributes:</p>
<pre>...<br/>     [Route("api/order")]<br/>     <strong>[CustomControllerFilter]</strong><br/>     public class OrderController : ControllerBase<br/>     { <br/>...</pre>
<p>Under the hood, <kbd>ActionFilterAttribute</kbd> is an abstract class and implements the <kbd>IActionFilter</kbd> interface type, which we looked at previously. Therefore, by taking a quick look at the <kbd>ActionFilterAttribute</kbd> class, we can assume that this abstract class also provides the <kbd>IAsyncActionFilter</kbd>, <kbd>IResultFilter</kbd>, and <kbd>IAsyncResultFilter</kbd> methods:</p>
<pre>[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]<br/>public abstract class ActionFilterAttribute : <br/>Attribute, IActionFilter, IFilterMetadata, IAsyncActionFilter, IResultFilter, IAsyncResultFilter, IOrderedFilter<br/>{<br/>    ...<br/>}<br/></pre>
<p>The preceding code snippet describes how ASP.NET Core always provides an easy way for us to customize and extend the behavior of our frameworks. Furthermore, the user has full control over the code and the interfaces provided by the framework. Eventually, we can easily create a custom abstract type that implements a custom behavior for the filter and can be extended by other concrete filter classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Life cycle and dependency injection</h1>
                
            
            
                
<p class="p1">As we already said, Dependency injection is a core technique in ASP.NET Core. Filters usually rely on other components to provide the filter logic. Before discussing injecting dependencies in filters, we need to understand the life cycle process. In general, when we apply a filter as an attribute, the life cycle of the filter is restricted to the request, which means that it is reinitialized for each request. The <kbd>ServiceFilter</kbd> attribute provides a valid alternative to overriding this kind of behavior. Therefore, the <kbd>ServiceFilter</kbd> attribute uses the <em>service provider</em> to create filter objects, which means that our filter is managed just like any other service declared through the dependency injection system of ASP.NET Core.</p>
<p>For example, let's consider the implementation of the <kbd>CustomActionFilter</kbd> class we defined previously:</p>
<pre>using Microsoft.AspNetCore.Mvc.Filters;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>        public class CustomActionFilter : IActionFilter<br/>        {<br/>            public void OnActionExecuting(ActionExecutingContext context)<br/>            {<br/>                // do something before the action executes<br/>            }<br/><br/>            public void OnActionExecuted(ActionExecutedContext context)<br/>            {<br/>                // do something after the action executes<br/>            }<br/>        }<br/>}</pre>
<p>It is possible to initialize the <kbd>CustomActionFilter</kbd> type using the <kbd>AddSingleton</kbd> extension method in the <kbd>Startup</kbd> class:</p>
<pre>...<br/>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services<br/>        .AddSingleton&lt;IOrderRepository, MemoryOrderRepository&gt;()<br/>        <strong>.AddSingleton&lt;CustomActionFilter&gt;()</strong><br/> ...<br/>}<br/>...</pre>
<p>We can then use it in our controllers or action methods, as follows:</p>
<pre>...<br/><strong>[</strong><strong>ServiceFilter(typeof(CustomActionFilter))]</strong><br/>public class OrderController : ControllerBase<br/>{<br/>...<br/><br/></pre>
<p>This approach guarantees that we override the life cycle of the filters by explicitly defining the life cycle type in the <em>service provider</em>. Therefore, the filter pipeline is integrated and initialized using the dependency injection engine of ASP.NET Core. Moreover, it is also possible to resolve filter dependencies using the dependency injection engine. There are two injection techniques related to filters:</p>
<ul>
<li>Using the <kbd>ServiceFilter</kbd> technique</li>
<li>Using the <kbd>TypeFilterAttribute</kbd> technique</li>
</ul>
<p class="p1">As we saw previously, the <kbd>ServiceFilter</kbd> type adds the instance of filters in the service provider. It is possible to inject the dependency into a filter by adding it to the constructor. We can do this using <em>constructor injection</em>:</p>
<pre>using Microsoft.AspNetCore.Mvc.Filters;<br/>using Microsoft.Extensions.Logging;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>    public class CustomActionFilter: IActionFilter<br/>    {<br/>        <strong>private readonly ILogger _logger;</strong><br/>        <br/>        <strong>public CustomActionFilter(ILogger logger)</strong><br/>        {<br/>            _logger = logger;<br/>        }<br/>        <br/>        public void OnActionExecuting(ActionExecutingContext context)<br/>        {<br/>            _logger.LogInformation("Logging OnActionExecuting");<br/>        }<br/><br/>        public void OnActionExecuted(ActionExecutedContext context)<br/>        {<br/>            _logger.LogInformation("Logging OnActionExecuted");<br/>        }<br/>}</pre>
<p>The preceding code injects the <kbd>ILogger</kbd> interface into the constructor and uses the exposed <kbd>LogInformation</kbd> extension method. It is also possible to not pass through the <em>service provider</em> using <kbd>TypeFilterAttribute</kbd> by referring to our filter using the type and not the instance. We do this by declaring another class that extends <kbd>TypeFilterAttribute</kbd>, which passes the type of our filter to the base class:</p>
<pre>public class CustomActionFilterAttribute : <strong>TypeFilterAttribute</strong><br/>{<br/>    public CustomActionFilterAttribute() : <strong>base(typeof(CustomActionFilter))</strong><br/>    {<br/>    }<br/>}</pre>
<p>Then it applies the attribute to the target controller:</p>
<pre>...<br/><strong>[CustomActionFilterAttribute]</strong><br/>public class OrderController : ControllerBase<br/>{<br/>...<br/></pre>
<p>The <kbd>CustomActionFilterAttribute</kbd> class extends the <kbd>TypeFilterAttribute</kbd> base class and calls the base constructor by referring to the <kbd>CustomActionFilter</kbd> type. This approach enhances the usability of filter attributes that depend on other classes. Now that we have a complete understanding of filters and know how to apply them to the filter pipeline, we can take a look at some concrete use cases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Filter use cases</h1>
                
            
            
                
<p>This section will show some concrete use cases for filters. In general, each time you have to replicate the behavior in an action or a controller, you can use filters to centralize the logic. Filters also provide a declarative approach, which helps us keep your code clean and readable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Existing entity constraints</h1>
                
            
            
                
<p>Action methods of controllers usually perform constraints on incoming data. A common practice is to centralize that kind of logic in filters. Let's take, for example, <kbd>OrderController</kbd>, which we discussed in the previous chapter:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using Microsoft.AspNetCore.JsonPatch;<br/>using Microsoft.AspNetCore.Mvc;<br/>using SampleAPI.Filters;<br/>using SampleAPI.Models;<br/>using SampleAPI.Repositories;<br/>using SampleAPI.Requests;<br/><br/>namespace SampleAPI.Controllers<br/>{<br/>    [Route("api/order")]<br/>    [ApiController]<br/>    public class OrderController : ControllerBase<br/>    {<br/>        private readonly IOrderRepository _orderRepository;<br/><br/>        public OrderController(IOrderRepository ordersRepository)<br/>        {<br/>            _orderRepository = ordersRepository;<br/>        }<br/><br/>        ...<br/><br/>        [HttpPut("{id:guid}")]<br/>        [OrderExists]<br/>        public IActionResult Put(Guid id, OrderRequest request)<br/>        {<br/>            if (request.ItemsIds == null)<br/>            {<br/>                return BadRequest();<br/>            }<br/><br/>           <strong> var order = _orderRepository.Get(id);</strong><br/><br/><strong>            if (order == null)</strong><br/><strong>            {</strong><br/><strong>                return NotFound(new { Message = $"Item with id {id} <br/>                 not exist." });</strong><br/><strong>            }</strong><br/><br/>            order = Map(request, order);<br/><br/>            _orderRepository.Update(id, order);<br/>            return Ok();<br/>        }<br/><br/>        [HttpPatch("{id:guid}")]<br/>        [OrderExists]<br/>        public IActionResult Patch(Guid id, JsonPatchDocument&lt;Order&gt; <br/>         requestOp)<br/>        {<br/>            <strong>var order = _orderRepository.Get(id);</strong><br/><strong>            </strong><br/><strong>            if (order == null)</strong><br/><strong>            {</strong><br/><strong>                return NotFound(new { Message = $"Item with id {id} not <br/>                 exist." });</strong><br/><strong>            }</strong><br/><br/>            requestOp.ApplyTo(order);<br/>            _orderRepository.Update(id, order);<br/><br/>            return Ok();<br/>        }<br/><br/>        [HttpDelete("{id:guid}")]<br/>        [OrderExists]<br/>        public IActionResult Delete(Guid id)<br/>        {<br/>            <strong>var order = _orderRepository.Get(id);</strong><br/><br/><strong>            if (order == null)</strong><br/><strong>            {</strong><br/><strong>                return NotFound(new { Message = $"Item with id {id} not <br/>                 exist." });</strong><br/><strong>            }</strong><br/><br/>            _orderRepository.Delete(id);<br/>            return NoContent();<br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>Three out of five action methods perform the same <em>existing check</em> by calling <kbd>_orderRepository</kbd>:</p>
<pre><strong> </strong>var order = _orderRepository.Get(id);<br/> <br/> if (order == null)<br/> {<br/>   return NotFound(new { Message = $"Item with id {id} not exist." });<br/> }<strong><br/></strong></pre>
<p>A recommended practice is to extract this logic and put it somewhere else, possibly an action filter, so that it can be used across action methods. It is specific enough to be used only when necessary. Let's start by setting up our filter and adding the dependency with <kbd>IOrderRepository</kbd>:</p>
<pre>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/>using SampleAPI.Repositories;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>    public class OrderExistsAttribute : TypeFilterAttribute<br/>    {<br/>        public OrderExistsAttribute() : base(typeof<br/>            (OrderExistsFilterImpl)) { }<br/><br/>        private class OrderExistsFilterImpl : IAsyncActionFilter<br/>        {<br/>            private readonly IOrderRepository _orderRepository;<br/> <br/>            public OrderExistsFilterImpl(IOrderRepository orderRepository)<br/>            {<br/>                _orderRepository = orderRepository;<br/>            }<br/> <br/>            public async Task OnActionExecutionAsync(ActionExecutingContext <br/>            context, ActionExecutionDelegate next)<br/>            {<br/>                ...<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>OrderExistsFilterImpl</kbd> class provides the basic setup for an action filter. It accepts <kbd>IOrderRepository</kbd> as a dependency and implements <kbd>OnActionExecutionAsync</kbd>. This implementation class is contained in an attribute class that implements <kbd>TypeFilterAttribute</kbd>.</p>
<p>After declaring the attribute class, we can proceed by implementing the logic. <kbd>OrderExistsAttribute</kbd> has three purposes:</p>
<ul>
<li>To check whether the incoming request contains an <kbd>id</kbd></li>
<li>To check whether the requested <kbd>id</kbd> is a <kbd>Guid</kbd></li>
<li>To query <kbd>IOrderRepository</kbd> to check whether the entity exists</li>
</ul>
<p>Let's proceed by describing a possible implementation of the previous logic:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/>using SampleAPI.Repositories;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>    public class OrderExistsAttribute : TypeFilterAttribute<br/>    {<br/>        public OrderExistsAttribute() : base(typeof(OrderExistsFilterImpl))<br/>        {<br/>        }<br/><br/>        private class OrderExistsFilterImpl : IAsyncActionFilter<br/>        {<br/>            <strong>private readonly IOrderRepository _orderRepository;</strong><br/><br/>            public OrderExistsFilterImpl(IOrderRepository orderRepository)<br/>            {<br/>                _orderRepository = orderRepository;<br/>            }<br/><br/>            public async Task OnActionExecutionAsync(ActionExecutingContext <br/>            context, ActionExecutionDelegate next)<br/>            {<br/>            <strong>    if (!context.ActionArguments.ContainsKey("id"))</strong><br/><strong>                {</strong><br/><strong>                    context.Result = new BadRequestResult();</strong><br/><strong>                    return;</strong><br/><strong>                }</strong><br/><br/>                if (!(context.ActionArguments["id"] is Guid id))<br/>                {<br/>                    context.Result = new BadRequestResult();<br/>                    return;<br/>                }<br/><br/>               <strong> </strong><strong>var result = _orderRepository.Get(id);</strong><br/><br/>                if (result == null)<br/>                {<br/>                    context.Result = <br/>                     new NotFoundObjectResult(<br/>                     new {Message = $"Item with id {id} not exist."});<br/>                    return;<br/>                }<br/><br/>                await next();<br/>            }<br/>        }<br/>    }<br/>} </pre>
<p>First of all, the code checks whether our action arguments, which are populated by the model binder, contain any key by using the <kbd>!context.ActionArguments.ContainsKey("id")</kbd> statement. If the check is not true, the action filters interrupt the pipeline by adding a <kbd>BadRequestResult</kbd> to the response and exiting from the method. Secondly, the code checks whether the requested <kbd>id</kbd> is a <kbd>Guid</kbd> using <kbd>!(context.ActionArguments["id"] is Guid id)</kbd>. In this case, if the condition fails, it returns a <kbd>BadRequestResult</kbd> and interrupts the pipeline. Finally, the action filter calls <kbd>IOrderRepository</kbd> and checks whether the requested entity exists. If the test is positive, it continues the pipeline by calling the <kbd>await next();</kbd> method; otherwise, it returns a <kbd>BadRequestResult</kbd>.</p>
<p class="mce-root">In conclusion, we can add our attribute on top of methods that perform the actual checks and remove the previously replicated code that's inside each action method:</p>
<pre>[Route("api/order")]<br/>[ApiController]<br/>public class OrderController : ControllerBase<br/>{<br/>    ...<br/><br/>    [HttpGet("{id:guid}")]<br/>    <strong>[OrderExists]</strong><br/>    public IActionResult GetById(Guid id) { ... }<br/><br/>    [HttpPut("{id:guid}")]<br/>   <strong> [OrderExists]</strong><br/>    public IActionResult Put(Guid id, UpdateOrderRequest request) { ... }<br/><br/>    [HttpPatch("{id:guid}")]<br/>    <strong>[OrderExists]</strong><br/>    public IActionResult Patch(Guid id, JsonPatchDocument&lt;Order&gt; requestOp) <br/>    { ... }<br/><br/>    [HttpDelete("{id:guid}")]<br/>    <strong>[OrderExists]</strong><br/>    public IActionResult Delete(Guid id) { ... }<br/>    <br/>    ...<br/>}</pre>
<p>This kind of approach is compliant with the <em>DRY principle</em>. Furthermore, we can reuse the filter and handle the logic in a unique entry point.</p>
<p>Before ASP.NET Core 2.1, the same approach was used to check whether a model was valid. Instead of replicating the <kbd>Model.IsValid</kbd> <em>check-in</em> in each action, the logic was centralized in an action filter. With the introduction of the built-in <kbd>ApiController</kbd> attribute, the constraint has now become implicit.</p>
<p>Next, let's have a look at altering exceptions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Altering exceptions</h1>
                
            
            
                
<p>Another common use for filters is changing the response of a specific request. Filters are handy in these cases because they can only be applied to particular action methods. Some services need to return a custom format to the client, for example, when they are used by a legacy system that only accepts a specific format or when they need to provide a response that's been wrapped by a particular envelope. ASP.NET Core provides the <kbd>IExceptionFilter</kbd> interface for this, which allows us to overload the exceptions and send a custom response to the client.</p>
<p>Furthermore, if an exception is thrown, it follows two different behaviors, depending on the environment. If the API triggers an exception and it is running in a development environment, it returns a current detailed exception page, which looks as follows:</p>
<div><img src="img/522af6fe-6a31-491b-a5d1-24e2db25c19d.png" style=""/></div>
<p>If we are in a <em>production environment,</em> it merely returns a generic <kbd>500 Internal Server Error</kbd>. These two behaviors are defined by default in the out of the box Web API template of ASP.NET Core:</p>
<pre>public class Startup<br/>{<br/>    ....<br/>    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>    {<br/>      <strong>  if (env.IsDevelopment())</strong><br/><strong>            app.UseDeveloperExceptionPage();</strong><br/><strong>        else<br/>            app.UseHsts();</strong><br/><br/>       ...<br/>    }<br/><br/></pre>
<p>In a real-world application, it is usually necessary to provide detailed information to the client, thereby guaranteeing reliable communication between the server and the client.</p>
<p>In real-world applications, errors are an essential part of services. In some cases, companies institute an internal error code definition so that they can build more flexible APIs that can handle errors in a better way and establish resilient communication between themselves.</p>
<p>To implement custom exceptions, we should extend the <kbd>IExceptionFilter</kbd> interface. The following code is a possible implementation of this:</p>
<pre>using System.Net;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/>using Microsoft.Extensions.Hosting;<br/>using Microsoft.Extensions.Logging;<br/><br/>namespace SampleAPI.Filters<br/>{<br/>    public class CustomExceptionAttribute : TypeFilterAttribute<br/>    {<br/>        public CustomExceptionAttribute() : base(typeof<br/>            (HttpCustomExceptionFilterImpl))<br/>        {<br/>        }<br/><br/>        private class HttpCustomExceptionFilterImpl : IExceptionFilter<br/>        {<br/>            private readonly IWebHostEnvironment _env;<br/>            private readonly ILogger&lt;HttpCustomExceptionFilterImpl&gt; <br/>             _logger;<br/>            public HttpCustomExceptionFilterImpl(IWebHostEnvironment env,    <br/>              ILogger&lt;HttpCustomExceptionFilterImpl&gt; logger)<br/>            {<br/>                _env = env;<br/>                _logger = logger;<br/>            }<br/><br/>            public void OnException(ExceptionContext context)<br/>            {<br/>                _logger.LogError(new EventId(context.Exception.HResult),<br/>                    context.Exception,<br/>                    context.Exception.Message);<br/><br/>                var json = new JsonErrorPayload<br/>                {<br/>                    Messages = new[] {"An error occurred. Try it again."}<br/>                };<br/><br/>                if (_env.IsDevelopment())<br/>                {<br/>                    json.DetailedMessage = context.Exception;<br/>                }<br/><br/>                var exceptionObject = new ObjectResult(json) <br/>                {StatusCode = 500};<br/><br/>                context.Result = exceptionObject;<br/>                context.HttpContext.Response.StatusCode = <br/>                 (int) HttpStatusCode.InternalServerError;<br/>            }<br/>        }<br/>    }<br/>    <br/>    public class JsonErrorPayload<br/>    {<br/>        public string[] Messages { get; set; }<br/><br/>        public object DetailedMessage { get; set; }<br/>    }<br/>}</pre>
<p>The framework invokes the <kbd>HttpCustomExceptionFilterImpl</kbd> class each time an exception is thrown. The class has two dependencies: <kbd>ILogger</kbd> and <kbd>IWebHostEnvironment</kbd>. The <kbd>OnException</kbd> method logs the exception using the <kbd>ILogger</kbd> class and creates a new instance of <kbd>JsonErrorPayload</kbd>, which contains a generic message and some details about the exception. Finally, the <kbd>OnException</kbd> method returns the <kbd>500 Internal server error</kbd> status code, as well as the <kbd>exceptionObject</kbd> that was just created.</p>
<p>The detailed exception message may have some value, depending on <kbd>IWebHostEvinronment</kbd>. This kind of approach is useful in a production context to avoid revealing sensitive information about the service.</p>
<p>In conclusion, if our service throws an exception, our <kbd>IExceptionFilter</kbd> transforms it into a new JSON response:</p>
<pre class="mce-root">{<br/>    "messages": [<br/>        "An error occurred. Try it again."<br/>    ],<br/>    "detailedMessage": {<br/>        "ClassName": "System.Exception",<br/>        "Message": "My custom exception",<br/>        "Data": null,<br/>        "InnerException": null,<br/>        "HelpURL": null,<br/>        "StackTraceString": " at <br/>         Sample.API.Filters.Controllers.OrderController.Get() in               <br/>         /Projects/Sample.API.Filters/<br/>         Controllers/OrderController.cs:line 30\n at <br/>         lambda_method(Closure , Object , Object[] )\n ",<br/>        "RemoteStackTraceString": null,<br/>        "RemoteStackIndex": 0,<br/>        "ExceptionMethod": null,<br/>        "HResult": -2146233088,<br/>        "Source": "HandsOn.API.Filters",<br/>        "WatsonBuckets": null<br/>    }<br/>}<br/><br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at some filter concepts in ASP.NET Core. We introduced different types of filters, how they work, and the specific purpose of each kind in the MVC pipeline. We have also seen how to implement filters and explored some concrete use cases to understand and discover the power of filters so that we can achieve cross-cutting concerns.</p>
<p>The next chapter is dedicated to the data access layer methodologies in ASP.NET Core. You will be introduced to the repository pattern, which will describe the implementation of the data access layer using EF Core and Dapper. Furthermore, we will also describe some testing techniques that verify the data access layer part of an ASP.NET Core application.</p>


            

            
        
    </body></html>