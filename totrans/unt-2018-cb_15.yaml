- en: Editor Extensions and Immediate Mode GUI (IMGUI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Menu items to log messages and clear the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a panel with text data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interactive panel and persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating GameObjects, parenting and registering Undo actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with selected objects and deactivating menu items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu item to create 100 randomly positioned prefab clones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A progress bar to display proportion completed of Editor extension processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object's location in scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible class-based code architecture to manage complex IMGUIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect of game development in general (and inventories as our particular
    examples in this chapter) is the distinction about when we undertake an activity.
    Runtime is when the game is running (and when all our software and UI choices
    take effect). However, design-time is the time when different members of our game
    design team work on constructing a wide range of game components, including the
    scripts, audio and visual assets, and the process of constructing each game level
    (or scene in Unity-speak).
  prefs: []
  type: TYPE_NORMAL
- en: Unity's Editor extensions are scripting and multimedia components that enable
    a game software engineer to make design-time work easier and less likely to introduce
    errors. Editor extensions allow workflow improvements, thus allowing designers
    to achieve their goals quicker and more easily; for example, removing the need
    for any scripting knowledge when generating many randomly located inventory pickups
    in a scene via a menu choice or editing the type or properties of pickups being
    hand-placed in different locations in a level.
  prefs: []
  type: TYPE_NORMAL
- en: The Big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from plain text, there are four sections below will give you an idea of
    what this chapter is about.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Immediate Mode GUI (IMGUI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early versions of Unity, all **UI** components were created through code
    - there was no **Canvas**, or **Rect** Transform, or drag-and-drop **UI** control
    layout and so on. A few years ago (Unity 4.6), Unity introduced what we now know
    as the **UI** system. The new (play-mode) UI system is an example of a **Retained
    Mode UI**; the **UI** items we created are remembered frame-to-frame and don't
    need to be re-created/displayed by us as developers. However, the code-based GUI
    system still has an important role to play for Editor Extensions. The **IMGUI**
    system is called **Immediate Mode**, since its code executes one more times each
    frame. Therefore, there is no need to clear previous GUI displays, since that
    it automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and saving changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of serialization is raised in the Editor extension recipes, whereby
    we need to remember that, when we are editing item properties in the Inspector,
    each change needs to be saved to disk, so that the updated property is correct
    when we next use or edit that item. This is achieved in the `OnInspectorGUI()`
    method by first calling the `serializedObject.Update()` method and, after all
    changes have been made in the Inspector, finally calling the `serializedObject.ApplyModifiedProperties()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can detect when the user has made a change to a GUI control by interrogating
    Unity''s special public bool value: `GUI.changed`. This is set to true if a GUI
    control has changed input data (for example, if the user has been typing or clicking
    GUI controls). Here is a simple example of using `GUI.changed` to log a message
    when the content of a text input field has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Unity''s EditorGUI class provides `Begin-End ChangeCheck()` methods that will
    set GUI.changed to true if the user has changed one or more interactive GUI components
    in a block of statements delimited by these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If they have, we can save a statement, since `EditorGUI.EndChangeCheck()`,
    as well as declaring the end of the block of statements for GUI.change. This also
    returns the bool value of GUI.changed. So, we can actually use this method call
    in our if-statement instead of GUI.changed. In essence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Memory - EditorPrefs persistent storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An issue with Immediate Mode systems is that everything is temporary and forgotten.
    Unity provides **EditorPrefs,** similar to **PlayerPrefs,** a facility for storing
    data that is remembered between the closing of a panel and its reopening. Just
    as with **PlayerPrefs,** different **types** of values can be stored and retrieved
    using `Get<>()` and `Set<>()` methods, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetString(<key>, <value>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetString(<key>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also provided are methods to delete all stored EditorPrefs data (`DeleteAll()`),
    to delete just one item for a given key (`DeleteKey(<key>)`), and to check if
    an item exists for a given key (`HasKey(<key>)`).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `DeleteAll()` isn't something to be used without careful consideration.
    There is an example of `DeleteAll()` in the Unity documentation that ensures the
    game developer is first asked if they are sure they really want to delete all
    stored values: [https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html](https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, values are **loaded** from **EditorPrefs** using getters (if the
    `<key>`s exist) each time the panel gets the focus. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, when panels lose focus (`OnLostFocus()`) or are closed (`OnDestroy()`)
    we may wish to automatically save any values to EditorPrefs using setters.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions and further resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Editor extensions are quite an advanced topic, having someone on your
    team who can write custom editor components, such as those we illustrate, can
    greatly increase the productivity of a small team with only one or two members
    who are confident at scripting.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduce recipes demonstrating some Unity Editor extension
    scripts, illustrating how we can make things easier, less-script based, and less
    prone to errors, by limiting and controlling the properties of objects and how
    they are selected or changed via the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot to working with Editor Extensions and the IMGUI. Here is a list
    of resources to learn more about these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about EditorPrefs in the Unity Documentation: [https://docs.unity3d.com/ScriptReference/EditorPrefs.html](https://docs.unity3d.com/ScriptReference/EditorPrefs.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity blog post about IMGUI: [https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/](https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Video about IMGUI by Casey Muratori: [https://caseymuratori.com/blog_0001](https://caseymuratori.com/blog_0001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the Unity Immediate Mode GUI reference pages: [https://docs.unity3d.com/Manual/GUIScriptingGuide.html](https://docs.unity3d.com/Manual/GUIScriptingGuide.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Unity GUI event scripting reference page: [https://docs.unity3d.com/ScriptReference/Event.html](https://docs.unity3d.com/ScriptReference/Event.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity scripting OnGUI reference page: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ryan Meier's blog: [http://www.ryan-meier.com/blog/?p=72](http://www.ryan-meier.com/blog/?p=72)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tutsplus tutorials and custom scripts (including grids and color pickers): [http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047](http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gamasutra getting starting Editor Extensions article: [https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php](https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu items: [https://docs.unity3d.com/ScriptReference/MenuItem.html](https://docs.unity3d.com/ScriptReference/MenuItem.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EditorGUI.BeingChangeCheck: [https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html](https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu items to log messages and clear the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Custom menus are a great way to offer game developers easy access to your Editor
    Extension features. Logging actions is a good way to display and keep a record
    of actions performance and object properties that have been changed. In this recipe,
    we''ll create a new menu for the Unity Editor application and a menu item that
    when selected logs a simple message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83266c1e-2c0e-4c62-96d0-8d0956aba787.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a menu with a menu item to log messages to console, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a new folder, Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your new Editor folder, create a new C# script-class named `ConsoleUtilities.cs`,
    containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, you should now see a menu named My Utilities appear with
    two items Clear Console and Log a message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be able to clear the console and generate Log messages with these
    menu items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created an editor extension script-class in a folder Editor that extends
    the `EditorWindow` class. You defined two methods; each method was immediately
    preceded by an attribute to add a menu item to a menu named My Utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ClearLogConsole()` method was immediately preceded by an attribute declaring
    a new menu, My Utilities, and its single menu item `Clear Console`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The MenuItem **attribute** immediately precedes a **static** method, that implements
    the actions to be executed if the menu item is selected by the user. The menu
    path is in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: MenuName/MenuItemName or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MenuName/SubMenuName/MenuItemName and so on for submenus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LogHello()` method creates a new Log message each time it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `ClearLogConsole()` method gets a reference to the Unity logs and clears
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Editor Extensions for menus in the Unity tutorial
    on this topic: [https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items](https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items)'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that using Reflection is very slow and so generally only
    used for Editor scripts or scripts that are only executed once and a short delay
    will not impact upon the user's or game developer's quality of experience.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Special characters in the Menu Item string can be used to specify a keyboard
    shortcut for the menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '% indicates the CTRL-key (Windows) or CMD-key (Mac)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indicate the SHIFT-key
  prefs:
  - PREF_UL
  - PREF_H1
  type: TYPE_NORMAL
- en: <c> then the (lowercase) letter or character shortcut key (e.g. 'k' for the
    K-key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When keyboard shortcut has been defined, Unity also indicates this to the right
    of the menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15001952-a500-46a8-8342-4e63f2308462.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s add shortcuts so that *CTRL*/*CMD*-*L* logs a message and *CTRL*/*CMD*-*K*
    clears the log (keys *L* and *K* are next to each other on the keyboard):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Learn more about Unity Menu Item Keyboard Shortcuts at `https://docs.unity3d.com/ScriptReference/MenuItem.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create sub-menus by adding a third text item between forward slashes,
    in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to have a menu Utilities with a sub-menu Console and two items for that
    submenu, you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a panel with text data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to create and display a new panel as part of an Editor Extension.
    In this recipe, we create a menu item that creates and displays a new panel, displaying
    some text information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0f137bd-4fe3-40cb-bb0d-6bf2240af0b2.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display a panel with text data, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a new folder, Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your new Editor folder, create a new C# script-class named `InformationPanel.cs`,
    containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, you should now see a menu named My Game appear, with menu
    item Info Panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select menu item Info Panel - you should now see a new panel appear, entitled
    My Game and containing the two text messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You preceded the `ShowWindow()` method with an attribute to add a menu item
    Info Panel to a menu named My Game. The `GetWindow()` statement gets a reference
    to an InformationPanel object - if no such window-panel exists, it creates one.
    It searches for a window-panel of type (that is, for this script-class). The first
    argument is the title of the panel My Game. The true for the second argument tells
    Unity to make the window-panel have the focus (if a window panel already existed).
  prefs: []
  type: TYPE_NORMAL
- en: If a new window panel has been created it will always be given the focus.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnGUI()` method, which executes a least once every frame, uses `GUILayout`
    to display two text labels. Since `GUILayout` begins adding items at the top-left,
    the first message Hello editor world appears in the top-left of the panel. Then
    there is a `FlexibleSpace()` statement. This tells the GUI layout manager to fill
    up as much (default - vertical) space as it can, while allowing space in the panel
    for any other content. The third statement displays a second text label. The result
    is that the second text label is pushed to the bottom of the panel by the `FlexibleSpace()`.
  prefs: []
  type: TYPE_NORMAL
- en: Try resizing the panel; you'll see the second text label is always at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details that you won't want to miss throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical centering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we wanted to vertically center some text, we can have a `FlexibleSpace()`
    statement both before and after the content. For example, the following code would
    vertically center text `Here is some important information`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Vertical and horizontal centering (middle of an area)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To center horizontally, we need to change from the default vertical layout
    by starting (and ending) a horizontal layout, in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By the having `FlexibleSpace()` before and after the content in the horizontal
    layout, we can center content horizontally as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To center both vertically and horizontally, we use `FlexibleSpace()` before
    and after the horizontal layout, and also before and after the content inside
    the horizontal layout. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This use of flexible spacing is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a5319f2-cdbc-45f0-b8dd-af703305c03f.png)'
  prefs: []
  type: TYPE_IMG
- en: An interactive panel with persistent storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Immediate Mode, we have to store the values of interactive controls like
    buttons and text inputs at the time we display them. Also, we need to decide if,
    and when, to persistently store values to be remembered when the panel is out
    of focus or closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we display a text label saying hello to the player and using
    their name if it has been found in the EditorPrefs storage. We also offer a text
    input and a button and, when the button is clicked, we update the name being greeted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/510a539f-d625-4cec-a4f9-c8aa242d7a97.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To offer an interactive panel with persistent storage, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a new Editor folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your new Editor folder, create a new C# script-class named `Welcome.cs`
    containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, you should now see a menu named Welcome appear with menu
    item Hello Player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the menu item Hello Player. You should now see a new panel appear, entitled
    Welcome, displaying a hello message, a text input box, and a button labeled Update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your name in the text box and, when you press the button, you should see
    a message greeting you by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You preceded the `ShowWindow()`  method with an attribute to add a menu item,
    Hello Player, to a menu named Welcome. The `GetWindow()` statement gets a reference
    to an `EditorWindow` object of type (that is, for this script-class), creating
    a new one if no existing window-panel of this type can be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OnGUI()` method, which executes every frame, uses GUILayout to display
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A text label in the form Hello
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text input with the prompt Player name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Update button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is some `FlexibleSpace()` between the first item (greeting label) and
    the input box and button, so the input box and button appear at the bottom of
    the panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two private string variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`playerName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tempName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `playerName` variable is used to decide what greeting to display. If the
    length of this string is greater than zero (in essence, it's not an empty string),
    then the hello message will be Hello. If `playerName` was empty, then the message
    will be Hello (no name).
  prefs: []
  type: TYPE_NORMAL
- en: The second variable, `tempName`, is set to the value in the text box. This has
    to be re-assigned every frame (in `OnGUI()`), since the text box is redisplayed
    every frame. Each time the user types different text in the text box, the new
    text is immediately stored in the `tempName` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is an `if` statement that displays the Update button. If, during
    a frame, the button is clicked by the user, then the `if-`statement will be executed,
    which copies the `tempName` from the text box into the `playerName` variable.
    The very next frame, we'll see the greeting change to reflect the new value inside
    `playerName`.
  prefs: []
  type: TYPE_NORMAL
- en: We have used `EditorGUILayout.TextField(...)` for the text field entry, whereas
    the other methods are GUILayout methods. `The EditorGUILayout` methods make interactive
    controls easier, while the GUILayout methods make layout easier. For window-panels
    like this you can mix-and-match these GUI methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage with EditorPrefs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At present, if the panel is closed (for example, due to a new panel layout being
    invoked), then any name that was being shown will be lost. However, we can add
    some code that uses the EditorPrefs system to store the new name each time the
    Update button is clicked. Additional code can then check for an EditorPrefs value
    when the panel is newly displayed and initialize `playerName` to the stored value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when the panel is created/gets the focus, let''s attempt to read an
    EditorPrefs item with the key `"PlayerName"`. If found, we''ll retrieve that string
    and assign the `playerName` variable to the stored value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a method that will save the value in `playerName` into EditorPrefs,
    again using the key `"PlayerName"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two times we may wish to ensure the value is saved, when the panel
    loses focus and when it is closed (destroyed). So, for both these events, we''ll
    write methods that will invoke our `SavePrefs()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: GUILayout versus EditorGUILayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed there were two different `GUILayout` different method
    calls in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`GUILayout` and `EditorGUILayout` both perform very similar roles, in that
    they provide UI controls with some automated layout - that is, we don''t have
    to specify exact (x,y) values or rectangles for the window-panel size and position
    of each item. `GUILayout` offers some of the more flexible layout options, like
    `FlexibleSpace` and horizontal and vertical groups, which with `FlexibleSpace`
    can vertically and horizontally align items. However, `EditorGUILayout` offers
    easier and more powerful numeric and text input fields, as well as color selection
    widgets, foldout groups, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'DM Gregory, in a StackExchange post in 2017, lists many of the extra methods
    available when using `EditorGUILayout`: [https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout](https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating GameObjects, parenting, and registering Undo actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether from a menu item, or an Inspector view, there are times when we want
    to create a new GameObject in the scene from an Editor Extension. In this recipe,
    we''ll create a new GameObject and set its position and color randomly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c5ba467-2b3e-4745-bb68-6d273af200dd.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an object and change its value follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a new folder, Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your new Editor folder create a new C# script-class named `ObjectManager.cs`,
    containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, you'll see added to the GameObject menu a new sub-menu
    named MyObjectManager appear, with menu item Create New Empty Game Object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose menu: GameObject | MyObjectManager | Create New Empty Game Object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see a new GameObject named GameObject - custom - Empty created
    in the Hierarchy panel. If you select this object, it's position (x,y,z) values
    should be random, in the range -0.5 ... 0.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can Undo this create GameObject from the Edit menu (or *CTRL/CMD-Z*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb80dd6d-d551-41d9-ad44-547ba7ba622e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the new empty GameObject selected in the Hierarchy, right-mouse click
    to get the context menu for this object. Now, choose menu: Create | MyObjectManager
    | Create New Empty Game Object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see a second empty GameObject created as a child of the first
    one;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db175896-d0cd-4921-9cc7-11ad781235e8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You preceded the `CreateCustomEmptyGameObject(...)` method with an attribute
    to add to existing menu GameObject a sub-menu MyObjectManager with menu item Create
    New Empty Game Object.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateCustomEmptyGameObject(...)` method creates a new, empty GameObject
    with the name GameObject - custom - Empty. It then sets the position property
    to a Vector3 random location, returned from method `RandomPosition(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateCustomEmptyGameObject(...)` method then uses the `GameObjectUtility.SetParentAndAlign(...)`
    method to parent the new GameObject to the object selected in the Hierarchy, if
    the menu was invoked in the contents of a selected GameObject. Otherwise, the
    new GameObject will have no parent in the Hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The `RandomPosition(...)` method takes as input a float parameter <limit>, and
    generates three values (x,y,z) in the random range from negative to positive <limit>.
    It then creates and returns a new Vector3 object with these three values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we chose to add our action to the special GameObject menu, our sub-menu
    item appears in the Hierarchy panel''s content Create menu as: Create | MyObjectManager
    | Create New Empty Game Object.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Registering object changes to allow Undo'ing of actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we performance an object creation/deletion/change action in the Unity Editor,
    we should offer the user the change to Undo the action. Unity makes it very easy
    for us to facilitate this, through registration of the changed object by providing
    an Undo class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add to `CreateCustomEmptyGameObject(...)` a call to the `Undo.RegisterCreatedObjectUndo(...)`
    method. This registers the GameObject creation in the Unity system Undo register
    so that the action can be undone if the uses wishes to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Learn more about the Undo features in the Unity documentation pages: [https://docs.unity3d.com/ScriptReference/Undo.html](https://docs.unity3d.com/ScriptReference/Undo.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating primitive 3D GameObjects with random colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rather than creating empty GameObjects, we can create new GameObjects that
    are 3D primitives like cubes and spheres etc. We can do this using the `GameObject.CreatePrimitive(...)`
    method. By adding the following three methods, we''ll be able to create randomly
    positioned, randomly colored, random 3D GameObjects from a second menu item in
    our MyObjectManager sub-menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23903447-0d03-4556-a156-be5484f6ee2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s write a method to add a second menu item, which offers to create random
    GameObjects with 3D primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can choose a random integer from 0..3 to choose between Cube/Sphere/Capsule/Cylinder
    3D primitives for our new GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the final method we need to create a new Material with a random color,
    that can be assigned to the new primitives sharedMaterial property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Working with selected objects and deactivating menu items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we only want to execute some statements if an object is currently
    selected, related to those actions. In this recipe, we learn how to disable a
    menu item if nothing is selected. If a GameObject is selected, we''ll get a reference
    to that object and move it back to the origin (0,0,0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d2fce19-bada-4533-9dac-a2384ef117f4.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with selected objects and deactivate menu items follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a new folder, Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your new Editor folder create a new C# script-class named `SelectedObjectManager.cs`,
    containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, you'll see a new menu MyMenu created, with menu item Move
    To Origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no GameObject is selected in the Hierarchy, then the Move To Origin menu
    item should be greyed out (inactive).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new, empty GameObject and set its transform position to (5,6,7).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this new GameObject selected in the Hierarchy, choose menu: MyMenu | Move
    To Origin. The menu item should be active, and once chosen the position of the
    GameObject should be zeroed to (0,0,0).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You preceded the `ZeroPosition()` method with a MenuItem attribute to create
    a new menu MyMenu with menu item Move To Origin. This method gets a reference
    to the currently selected GameObject using the `Selection.activeTransform.gameObject`
    property. The object is registered to the Undo systems property change record,
    and then its transform position is set to (0,0,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a second method, `ValidateZeroPosition()`. This method is preceded
    by a MenuItem attribute with the same **menu path** as method `ZeroPosition()`.
    The MenuItem attribute is passed true to indicate this is a validation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Validation methods must be static methods, marked with the same MenuItem attribute
    as the item they are validating, and pass true to the validation argument. The
    method must return a bool true/false, to indicate whether the condition has been
    met for the menu item to be active.
  prefs: []
  type: TYPE_NORMAL
- en: '`ValidateZeroPosition()` returns the bool true/false value of the expression
    `Selection.activeTransform != null`. In other words, it returns true if there
    is a selected GameObject, and false if there is not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about Editor Extension menu items in the Unity tutorial: [https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items](https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items)'
  prefs: []
  type: TYPE_NORMAL
- en: Menu item to create 100 randomly positioned prefab clones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we want to create *lots* of pickups, randomly in our scene. Rather
    than doing this by hand, it is possible to add a custom menu and item to the Unity
    editor, which, when selected, will execute a script. In this recipe, we create
    a menu item that calls a script to create 100 randomly positioned star pickup
    prefabs in the Scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/799bffad-3fcb-4213-acdf-c4c0e3ff159d.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml)*,
    Inventory UI*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an editor extension to add 100 randomly located copies of a prefab
    with one menu click, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new folder named Prefabs. Inside this new folder,
    create a new empty prefab named `prefab_star`. Populate this prefab by dragging
    GameObject star from the Hierarchy panel over `prefab_star` in the Project panel.
    The prefab should now turn blue and have a copy of all of GameObject star's properties
    and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete GameObject star from the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new folder named Editor. Inside this new folder,
    create a new C# script class named `MyGreatGameEditor`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, depending on the speed of your computer, you should see
    a new menu appear, My Great Game, with a single menu item, Make 100 stars.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose this menu item and, as if by magic, you should now see 100 new `prefab_star(Clone)`
    GameObjects appear in the scene!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core aim of this recipe is to add a new menu, containing a single menu item
    that will execute the action we desire. `C# attribute [MenuItem("<menuName>/<menuItemName>")]`
    declares the menu name and the menu item name, and Unity will execute the static
    method that follows in the code listing, each time the menu item is selected by
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the `[MenuItem("My-Great-Game/Make 100 stars")]` statement declares
    the menu name as My-Great-Game and the menu item as Make 100 stars. The method
    immediately following this attribute is the `PlacePrefabs()` method. When this
    method is executed, it makes the `starPrefab` variable become a reference to the
    prefab found via the `Assets/Prefabs/prefab_star.prefab` path. Then, a For-loop
    is executed 100 times, each time calling the `CreateRandomInstance()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `RandomPosition()` method returns a Vector3 variable that is a random position,
    making use of `X_MAX` and `Y_MAX` constants (z is always zero).
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateRandomInstance()` method get a Vector3 randomPosition by calling
    the `RandomPosition()` method. The `Instantiate(...`) built-in method is then
    used to create a new GameObject in the scene, making a clone of the prefab and
    locating it at the position defined by randomPosition.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Childing each new GameObject to a single parent, to avoid filling up the Hierarchy
    with 100s of new objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rather than having hundreds of new object clones fill up our Hierarchy panel,
    a good way to keep things tidy is to have an empty "parent" GameObject and child
    a collection of related GameObjects to it. Let''s have a GameObject in the Hierarchy
    named Star-container and child all the new stars to this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85e72b55-0d08-4081-be7e-4035aa2043e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need a variable that will be a reference to our container object, starContainerGO.
    We also need a new method, `CreateStarContainerGO()`, which will find a reference
    to GameObject star-container, if such an object already exists it is deleted,
    and then the method will create a new empty GameObject and give it this name.
    Add the following variable and method to our script class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we create the prefab clones, we need to first ensure we have created
    our star container GameObject. So, we need to call our new method as the first
    thing we do when the `PlacePrefabs()` method is executed, so add a statement to
    call this method at the beginning of the `PlacePrefabs()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to modify the `CreateRandomInstance()` method so that it gets
    a reference to the new GameObject it has just created and can then child this
    new object to our star-container GameObject variable starContainerGO. Modify the
    `CreateRandomInstance()` method so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A progress bar to display proportion completed of Editor extension processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If an **Editor** task is going to take more than half a second or so, then
    we should indicate progress complete/remaining to the user via a progress bar
    so that they understand that something is actually happening and the application
    has not crashed and frozen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ca27244-3283-4684-a2bd-5b611289e806.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a progress bar during the loop (and then remove it after the loop is
    complete), replace the `PlacePrefabs()` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As can be seen, inside the for loop, we call the `EditorUtility.DisplayProgressBar(...)`
    method, passing three parameters. The first is a string title for the progress
    bar dialog window, the second is a string to show below the bar itself (usually
    a percentage is sufficient), and the final parameter is a value between 0.0 and
    1.0, indicating the percentage complete to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have loop variable i that is a number from 1 to 100, we can display
    this integer followed by a percentage sign for our second parameter and just divide
    this number by 100 to get the decimal value needed to specify how much of the
    progress bar should be shown as completed. If the loop were running for some other
    number, we'd just divide the loop counter by the loop total to get our decimal
    progress value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the loop has finished, we remove the progress bar with the `EditorUtility.ClearProgressBar()`
    statement. If we don't have this step, the progress bar window-panel will be left
    floating around - annoying the user!
  prefs: []
  type: TYPE_NORMAL
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of **enums** and corresponding drop-down menus in the Inspector panel
    to restrict changes to one of a limited set often works fine (for example, pickup
    types for a pickup object). However, the trouble with this approach is, when two
    or more properties are related and need to be changed together, there is a danger
    of changing one property, for example, pickup type from Heart to Key, but forgetting
    to change corresponding properties; for example, leaving the Sprite Renderer component
    still showing a Heart sprite. Such mismatches cause problems both in terms of
    messing up intended level design and, of course, the frustration for the player
    when they collide with something showing one pickup image, but a different kind
    of pickup type is added to the inventory!
  prefs: []
  type: TYPE_NORMAL
- en: If a class of GameObject has several related properties or components, which
    all need to be changed together, then a good strategy is to use Unity Editor extensions
    to do all the associated changes each time a different choice is made from a drop-down
    menu showing the defined set of enumerated choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we introduce an Editor extension for `PickUp` components of
    GameObjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0b3f7fc-bd92-4c7b-b8c9-a2135307ecc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you are starting with the `Simple2Dgame_SpaceGirl` project
    setup from the first recipe in *Chapter 3, Inventory UI*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an editor extension to allow pickup type (and parameters) to be changed
    at Design Time via a custom Inspector UI, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new folder named EditorSprites. Move the following
    images from folder Sprites into this new folder: star, healthheart, icon_key_green_100,
    icon_key_green_32, icon_star_32, and icon_heart_32:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b24734bd-643b-42d2-ba7e-8a8b6a53e77c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Hierarchy panel, rename GameObject star to be named pickup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the tags, changing tag Star to Pickup. Ensure the pickup GameObject now
    has the tag Pickup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create C# script-class `PickUp` and add an instance-object as a component to
    GameObject pickup in the Hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the Project panel, create a new folder named Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this new Editor folder, create a new C# script class named `PickUpEditor`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the Inspector panel, select GameObject pickup and choose different values
    of the drop-down menu PickUp Type. You should see corresponding changes in the
    image and icons in the Inspector for the Pick Up (Script) component (three icons
    with the name of the type in between). The Sprite property of the Sprite Renderer
    component for this GameObject should change. Also, in the Scene panel, you'll
    see the image in the scene change to the appropriate image for the pickup type
    you have chosen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22162569-212f-431a-9c3c-2979c10784a9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our script class `PickUp` has the enum `PickUpType` with the three values:
    `Star`, `Health`, and `Key`. Also, there is the variable type, storing the type
    of the parent GameObject. Finally, there is a `SetSprite(...)` method that sets
    the Sprite Renderer component of the parent GameObject to be set to the provided
    Sprite parameter. It is this method that is called from the editor script each
    time the pickup type is changed from the drop-down menu (with the corresponding
    sprite for the new type being passed).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vast majority of the work for this recipe is the responsibility of the
    script class `PickUpEditor`. While there is a lot in this script, its work is
    relatively straightforward: for each frame, via method `OnInspectorGUI()`, a dropdown
    list of PickUpType values is presented to the user. Based on the value selected
    from this drop-down list, one of three methods is executed: `InspectorGUI_HEALTH()`,
    `InspectorGUI_KEY()`, or `InspectorGUI_STAR()`. Each of these methods displays
    three icons and the name of the type in the Inspector beneath the drop-down menu
    and ends by calling the `SetSprite(...)` method of the GameObject being edited
    in the Inspector to update the Sprite Renderer component of the parent GameObject
    with the appropriate sprite.'
  prefs: []
  type: TYPE_NORMAL
- en: The C# attribute `[CustomEditor(typeof(PickUp))]` appearing before our class
    is declared, tells Unity to use this special editor script to display component
    properties in the Inspector panel for Pick Up (Script) components of GameObjects,
    rather than Unity's default Inspector which displays public variables of such
    scripted components.
  prefs: []
  type: TYPE_NORMAL
- en: Before and after its main work, the `OnInspectorGUI()` method first ensures
    that any variables relating to the object being edited in the Inspector have been
    updated - `serializedObject.Update()`. The last statement of this method correspondingly
    ensures that any changes to variables in the editor script have been copied back
    to the GameObject being edited - `serializedObject.ApplyModifiedProperties()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnEnable()` method of script class PickUpEditor loads the three small icons
    (for display in the Inspector) and the three larger sprite images (to update the
    Sprite Renderer for display in the Scene/Game panels). The `pickupObject`variable
    is set to be a reference to the PickUp scripted component, allowing us to call
    the `SetSprite(...)` method. The `pickUpType` variable is set to be linked to
    the type variable of the PickUp scripted component whose special Inspector editor
    view makes this script possible - `serializedObject.FindProperty ("type")`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Offer the custom editing of pickup parameters via Inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "Many pickups have additional properties, rather than simply being an item being\
    \ carried. \LFor example, a health pickup may add health points to the player's\
    \ character, a coin pickup may add money points to the character's bank balance,\
    \ and so on. So, let's add an integer points variable to our PickUp class and\
    \ offer the user the ability to easily edit this points value via a GUI slider\
    \ in our customer Inspector editor:"
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06fa225e-b993-4694-8e80-de8e7188c895.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add an editable points property to our `PickUp` objects, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extra line into C# script `PickUp` to create our new integer
    points variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer points variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following extra line into the `OnEnable()` method in C# script `PickUpEditor`
    to associate our new points variable with its corresponding value in the `PickUp`
    scripted component of the GameObject being edited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add an extra line into each GUI method for the different `PickUp`
    types. For example, we can add a statement to display an `IntSlider` to the user
    to be able to see and modify the points value for a Health PickUp object. We add
    a new statement at the end of the `InspectorGUI_HEALTH()` method in C# script
    `PickUpEditor` to display a modifiable `IntSlider` representing our new points
    variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We provide four parameters to the `IntSlider(...)` method. The first is the
    text label the user will see next to the slider. The second is the initial value
    the slider displays. The last two are the maximum and minimum values. In our example,
    we are permitting values from 0 to 100, but if health pickups only offer one,
    two, or three health points, then we'd just call with `EditorGUILayout.IntSlider`
    `("Health points, points.intValue, 1, 5")`. This method returns a new integer
    value based on where the slider has been positioned, and this new value is stored
    back into the integer value part of our `SerializedProperty` variable points.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the loading and saving of values from the scripted component in the
    GameObject and our editor script is all part of the work undertaken by our calls
    to the `Update()` method and the `ApplyModifiedProperties()` method on the serialized
    object in the `OnInspectorGUI()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, since points may not have any meaning for some pickups, for example,
    keys, then we simply would not display any slider for the GUI Inspector editor
    when the user is editing `PickUp` objects of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Offer a drop-down list of tags for key-pickup to fit via Inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the concept of points may have no meaning for a key pickup, the concept
    of the type of lock that a given key fits is certainly something we may wish to
    implement in a game. Since Unity offers us a defined (and editable) list of string
    tags for any GameObject, often it is sufficient, and straightforward, to represent
    the type of lock or door corresponding to a key via its tag. For example, a green
    key might fit all objects tagged LockGreen and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/311aa5a6-740a-4547-9412-0b2a02812fce.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, it is very useful to be able to offer a custom Inspector editor for
    a string property of key pickups that stores the tag of the lock(s) the key can
    open. This task combines several actions, including using C# to retrieve an array
    of tags from the Unity editor, then the building and offering of a drop-down list
    of these tags to the user, with the current value already selected in this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a selectable list of strings for the tag for lock(s) that a key fits,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extra line into C# Script `PickUp` to create our new integer
    `fitsLockTag` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer `fitsLockTag` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following extra line into the `OnEnable()` method in C# script `PickUpEditor`
    to associate our new `fitsLockTag` variable with its corresponding value in the
    `PickUp` scripted component of the GameObject being edited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add some extra lines of code into the GUI method for key PickUps.
    We need to add several statements to the end of method `InspectorGUI_KEY()` in
    C# script PickUpEditor to set up and display a selectable popup drop-down list
    representing our new `fitsLockTag` variable as follows. Replace the `InspectorGUI_KEY()`
    method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We've added several statements to the end of this method. First tags, an array
    of strings, is created (and sorted), containing the list of tags currently available
    in the Unity editor for the current game. We then attempt to find the location
    in this array of the current value of `fitsLockTag` - we can use the `BinarySearch(...)`
    method of built-in script class Array because we have alphabetically sorted our
    array (which also makes it easier for the user to navigate). If the string in
    `fitsLockTag` cannot be found in array tags, then the first item will be selected
    by default (index 0).
  prefs: []
  type: TYPE_NORMAL
- en: The user is then shown the drop-down list via the `GUILayout` method `EditorGUILayout.Popup(...)`
    and this method returns the index of whichever item is selected. The selected
    index is stored into `selectedTagIndex` and the last statement in the method extracts
    the corresponding string and stores that string into the `fitsLockTag` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Rather than displaying all possible tags, a further refinement might
    remove all items from array tags that do not have the prefix Lock. So the user
    is only presented with tags such as LockBlue and LockGreen, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Logic to open doors with keys based on fitsLockTag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our player collision logic, we can now search through our inventory to see
    if any key items fit the lock we have collided with. For example, if a green door
    was collided with, and the player was carrying a key that could open such doors,
    then that item should be removed from the inventory `List<>` and the door should
    be opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, you would need to add an if test inside the `OnTriggerEnter()`
    method to detected collision with the item tagged `Door`, and then logic to attempt
    to open the door, and, if unsuccessful, do the appropriate action (for example,
    play sound) to inform the player they cannot open the door yet (we''ll assume
    we have written a door animation controller that plays the appropriate animation
    and sounds and when a door is to be opened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OpenDoor()` method would need to identify which item (if any) in the inventory
    can open such a door, and, if found, then that item should be removed from the
    `List<>` and the door should be opened by the appropriate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for a method to find the inventory list key item
    fitting a door tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The need to add [SerializeField] for private properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that, if we wished to create editor extensions to work with private variables,
    then we'd need to explicitly add `[SerializeField]` in the line immediately before
    the variable to be changed by the editor script. Public variables are serialized
    by default in Unity, so this was not required for our public type variable in
    script class PickUp, although it's good practice to flag ALL variables that are
    changeable via an Editor Extension in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more from the Unity editor scripts documentation pages: [http://docs.unity3d.com/ScriptReference/Editor.html](http://docs.unity3d.com/ScriptReference/Editor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object location in scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a level designer wishes to place each pickup carefully "by hand", we can
    still make this easier than having to drag copies of prefabs manually from the
    Projects panel. In this recipe, we provide a "cross-hairs" GameObject, with buttons
    in the Inspector allowing the game designer to create instances of three different
    kinds of prefab at precise locations by clicking the appropriate button when the
    center of the cross-hairs is at the desired location.
  prefs: []
  type: TYPE_NORMAL
- en: A Unity Editor extension is at the heart of this recipe and illustrates how
    such extensions can allow less technical members of a game development team to
    take an active role in level creation within the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23016e79-f90b-4f6d-aea8-0b6a444af84c.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you are starting with the `Simple2Dgame_SpaceGirl` project
    setup from the first recipe in [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml)*,
    Inventory UI*.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the cross-hairs image you need in a folder
    named Sprites in the `18_09` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an object-creator GameObject, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, rename GameObject star as pickup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new folder named Prefabs. Inside this new folder,
    create three new empty prefabs named star, heart, and key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the star prefab by dragging GameObject pickup from the Hierarchy panel
    over star in the Project panel. The prefab should now turn blue and have a copy
    of all of the star GameObject's properties and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new tag Heart in the Inspector. Select GameObject pickup in the Hierarchy
    panel and assign it the tag Heart. Also, drag from the Project panel (folder Sprites)
    the healthheart image into the Sprite property of GameObject pickup so that the
    player sees the heart image on screen for this pickup item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the heart prefab by dragging GameObject pickup from the Hierarchy panel
    over heart in the Prefabs folder in the Project panel. The prefab should now turn
    blue and have a copy of all of the pickup GameObject's properties and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new tag Key in the Inspector. Select GameObject's pickup in the Hierarchy
    panel and assign it this tag Key. Also, drag from the Project panel (folder Sprites)
    image icon_key_green_100 into the Sprite property of GameObject's pickup so that
    the player sees the key image on screen for this pickup item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the key prefab by dragging GameObject pickup from the Hierarchy panel
    over key in the Prefabs folder in the Project panel. The prefab should now turn
    blue and have a copy of all of the pickup GameObject's properties and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete GameObject pickup from the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new folder named Editor. Inside this new folder,
    create a new C# script class named `ObjectBuilderEditor`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Our Editor script is expecting to find the three icons in a folder named EditorSprites,
    so let's do this. First, create a new folder named EditorSprites. Next, drag the
    three 32 x 32 pixel icons from the Sprites folder into this new EditorSprites
    folder. Our Editor script should now be able to load these icons for image-based
    buttons that it will be drawing in the Inspector, from which the user chooses
    which pickup prefab object to clone into the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af577152-388f-4dca-ab3c-8162c0884ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: From the Project panel, drag `sprite cross_hairs.fw` into the Scene. Rename
    this GameObject object-creator-cross-hairs, and in its Sprite Renderer component
    in the Inspector, set Sorting Layer to Foreground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the following C# script to GameObject object-creator-cross-hairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Select the Rect Tool (shortcut key T), and as you drag gameObject object-creator-cross-hairs
    and click on the desired icon in the Inspector, new pickup GameObjects will be
    added to the scene's Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script class `ObjectBuilderScript` has just two methods, one of which has
    just one statement - the `Awake()` method simply makes this GameObject become
    inactive when the game is running (since we don't want the user to see our cross-hairs
    created tool during gameplay). The `AddObjectToScene(...)` method receives a reference
    to a prefab as a parameter and instantiates a new clone of the prefab in the scene
    at the location of GameObject object-creator-cross-hairs at that point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Script class `ObjectBuilderEditor` has a C# attribute `[CustomEditor(typeof(ObjectBuilderScript))]`
    immediately before the class is declared, telling Unity to use this class to control
    how `ObjectBuilderScript` GameObject properties and components are shown to the
    user in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: There are six variables, three textures for the icons to form the buttons in
    the Inspector, and three GameObject references to the prefabs of which instances
    will be created. The `OnEnable()` method assigns values to these six variables
    using the built-in method `AssetDatabase.LoadAssetAtPath()`, retrieving the icons
    from the Project folder EditorSprites and getting references to the prefabs in
    the Project folder Prefabs.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnInspectorGUI()` method has a variable myScript, which is set to be a
    reference to the instance of scripted component `ObjectBuilderScript` in GameObject
    object-creator-cross-hairs (so we can call its method when a prefab has been chosen).
    The method then displays a mixture of empty text `Labels` (to get some vertical
    spacing) and `FlexibleSpace` (to get some horizontal spacing and centering) and
    displays three buttons to the user, with icons of star, heart, and key. The scripted
    GUI technique for Unity custom Inspector GUIs wraps an `if` statement around each
    button, and on the frame the user clicks the button, the statement block of the
    if statement will be executed. When any of the three buttons is clicked, a call
    is made to `AddObjectToScene(...)` of the scripted component `ObjectBuilderScript`,
    passing the prefab corresponding to the button that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Extensible class-based code architecture to manage complex IMGUIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For complex objects and editor interactions, you may find the number of GUI
    statements gets high, and code can quickly get hard to manage with very long `OnGUI()`
    methods. One approach to organise complex GUIs involves a list of items, and each
    item being an object-instance of a wrapper-class for a GUI control object. Each
    wrapper class will implement its own `OnGUI()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use this approach to create a complex GUI with well-organised
    code. This recipe is adapted from an example posted by Statement on answers.unity.com
    in 2013 to a question about the different IMGUI libraries: [https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html](https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We'll create IMGUI static labels, interactive text boxes and a button, and illustrate
    some flexible space and centering using `BeginHorizontal()` and `EndHorizontal()`,
    where the fiddly GUILayout statements are put into their own classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e71780bc-4b94-4685-99ac-9010da763561.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an extensible class-based code architecture to manage complex IMGUIs,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s create an **interface**, that is, a template script-class that
    defines a method all implementing-classes must have. Create a folder Editor. Inside
    that create a folder MyGUI. Inside that create a new C# script-class named `IMyGUI`
    containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define a FlexibleSpace class for our GUI library. Create a C# script
    class named `MyGUIFlexibleSpace` containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a button class. Create a C# script class named `MyGUIButton`
    containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create an input Text Field class. Create a C# script class named
    `MyGUITextField` containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a non-interactive text label class. Create a C# script class
    named `MyGUILabel` containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In Editor folder, we''ll now create a class to display an interactive custom
    panel, making use of our `MyGUI` classes above. Create `C# script-class MyEditorWindow`
    containing the following to start with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now add the method to display a menu item to open our window-panel.
    Add the following to `C# script-class MyEditorWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now add a method to setup our `MyGUI` objects and add them to our GUI
    list of objects. Add the following to C# script-class` MyEditorWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now add a method loop through and display all our GUI objects each frame.
    Add the following to C# script-class `MyEditorWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a method to respond to the button clicks (`LogUser`).
    Also a method to ensure we re-register this method when the window is disabled
    (to avoid memory leaks). Add these two methods to C# script-`class MyEditorWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, you should now see a menu named Example appear with a Show
    Window item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be able to display our custom registration panel by choosing
    this menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since there are several C# script-classes, each shall be separately described
    in the following.
  prefs: []
  type: TYPE_NORMAL
- en: Script-class MyEditorWindow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C# script-class `MyEditorWindow`, you preceded the `ShowWindow()` method
    with an attribute to add a menu item Show Window to a menu named Example. The
    `GetWindow()` statement gets a reference to an `MyEditorWindow` object - if no
    such window-panel exists, it creates one. The first argument is the title of the
    panel My Reg Panel. The true for the second argument tells Unity to make the window-panel
    have the focus (if a window panel already existed).
  prefs: []
  type: TYPE_NORMAL
- en: The `OnEnable()` method is executed when the window-panel first becomes enabled
    (active). It creates 2 `MyGUITextField` objects for username and real name, and
    a register `MyGUIButton`. Each of these objects are based on the MyGUI component
    script-classes in folder `MyGUI.` Then GUI objects are added in the sequence we
    wish, to the list variable `guiCompoennts`. The first GUI component added to the
    list is a new object-instance of an non-interactive `MyGUILabel` (passing the
    text string Unity 2018 is great and a true for full centering). Then, we add the
    two text input components (username and real name), then a new `MyGUIFlexible`
    space object-instance, and finally a `MyGUIButton` with the label Register, whose
    `OnClick` event will cause the invocation of the `LogUser()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `LogUser()` method logs the names in the two text fields to the Debug.Log.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnDisable()` method ensures that when the window-panel is being disabled/closed
    we de-register the `LogUser()` method from the OnClick event of the button object.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnGUI()` method, which executes every frame, simply loops through each
    GUI compoennt in list guiComponents, invoking the components' `OnGUI()` method.
    So each frame, our GUI is redisplayed.
  prefs: []
  type: TYPE_NORMAL
- en: Script-class IMyGUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This C# script-class declares an **interface named** IMyGUI. An interface is
    a template script-class that defines method(s) all implementing classes must implement.
    Our interface class is very simple, it simply requires all implementing classes
    must defined an `OnGUI()` method. There is a naming convention that recommends
    all interface classes have a capital letter I, before the upper-camel case class
    name.
  prefs: []
  type: TYPE_NORMAL
- en: By declaring this interface, we can now implement lots of different `IMyGUI`
    classes, which can all be treated the same way - that is, they can have their
    `OnGUI()` method invoked each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Script-class MyGUIFlexibleSpace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This simple script-class adds a `GUILayout.FlexibleSpace()` to the IMGUI system
    when its `OnGUI()` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Script-class MyGUITextField
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class declares two public items: a public string (for the text the user
    can see and edit), and a public label. Its `OnGUI()` method displays the labelled
    text field, and stores its value back into variable text.'
  prefs: []
  type: TYPE_NORMAL
- en: So our custom editor classes can set the initial text value and label, and also
    read any new value of the text from an object-instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Script-class MyGUILabel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class has two private values: the text to be displayed, and a bool, defining
    whether or not to fully center the text. Its `OnGUI()` method will add a `GUILayout.Lable()`
    to the GUI, and if the bool is true, it will add other GUILayout components before
    and after the label to ensure the label is both vertically and horizontally centered
    when displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of how some of the complexity of an interface can be delegated
    to its own class like this. By setting a single bool to true, several Begin/End/Vertical/Horizontal
    statements and FlexibleSpace statements are added to the GUI that is output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot illustrates how the flexible space and vertical/horizonal groups
    result in the desired alignment and spacing in the window-panel the user sees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/466a14ac-e0db-4fff-86f4-4accbd7ed5c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Script-class MyGUIButton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This class declares a public label, and also a public `OnClick` event. During
    the execution of its `OnGUI()` method, if the button has been clicked any methods
    that have been registered to listen for, `OnClick` events will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: There is a condition in the `OnGUI()` method, to ensure that if no methods are
    registered to list for `OnClick` events, then no statement is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `LogUser` method of the `MyEditorWindow` the window-panel object
    being registered for the `OnClick` event of the `registerButton` object, in its
    `OnEnable()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: While perhaps overkill for this simple window-panel, this recipe illusrtates
    how the use of an Interface and a list of GUI component objects, allows for an
    extensible system of custom GUI component classes to be created, while allowing
    the complexity of the `EditorWindow` classes to be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'NOTE: An alternative to C# events would be to use Unity Events and in some
    cases lambda expressions. You can read a discussion of such topics in these online
    articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://www.blockypixel.com/2012/09/c-in-unity3d-dynamic-methods-with-lambda-expressions/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://forum.unity.com/threads/how-to-use-an-action.339952/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
