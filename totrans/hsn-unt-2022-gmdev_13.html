<html><head></head><body>
  <div><h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-167" class="chapterTitle">Full-Screen Effects with Post-Processing</h1>
    <p class="normal">So far, we have created different objects to alter the visuals of our scene, such as meshes, particles, and lights. We can tweak the settings of those objects here and there to improve our scene quality, but you will always feel that something is missing when comparing it with modern game scenes, and that is post-processing effects. In this chapter, you will learn how to apply effects to the final rendered frame, which will alter the look of the overall scene.</p>
    <p class="normal">In this chapter, we will examine the following image effect concepts: </p>
    <ul>
      <li class="bulletList">Using post-processing </li>
      <li class="bulletList">Using advanced effects</li>
    </ul>
    <p class="normal">Let’s start by seeing how we can apply post-processing to our scene.</p>
    <h1 id="_idParaDest-168" class="heading-1">Using post-processing </h1>
    <p class="normal"><strong class="keyWord">Post-processing</strong> is a <a id="_idIndexMarker873"/>Unity feature that allows us to apply a stack of effects (several effects) one on top of the other that will alter the final look of an image. Each one will affect the finished frame, changing the colors in it based on different criteria. In <em class="italic">Figure 13.1</em>, you can see a scene before and after applying image effects. You will notice a dramatic difference, but that scene doesn’t have any change in its objects, including lights, particles, or meshes. </p>
    <p class="normal">The effects applied are based on a per-pixel level. Have a look at both scenes here:</p>
    <figure class="mediaobject"><img src="img/B18585_13_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.1: A scene without image effects (left) and the same scene with effects (right)</p>
    <p class="normal">Something to<a id="_idIndexMarker874"/> take into account is that the previous post-processing<a id="_idIndexMarker875"/> solution, <strong class="keyWord">Post Processing Stack version 2</strong> (<strong class="keyWord">PPv2</strong>) won’t work on the <strong class="keyWord">Universal Render Pipeline</strong> (<strong class="keyWord">URP</strong>); it has its own post-processing implementation, so <a id="_idIndexMarker876"/>we will see that one in this chapter. They are very similar, so even if you are using PPv2, you can still learn something from this chapter.</p>
    <p class="normal">In this section, we will discuss the following URP Post-Processing concepts:</p>
    <ul>
      <li class="bulletList">Setting up a profile</li>
      <li class="bulletList">Using basic effects</li>
    </ul>
    <p class="normal">Let’s start preparing our scene to apply effects.</p>
    <h2 id="_idParaDest-169" class="heading-2">Setting up a profile</h2>
    <p class="normal">To start <a id="_idIndexMarker877"/>applying effects, we need to create a <strong class="keyWord">profile</strong>, which is<a id="_idIndexMarker878"/> an asset containing all the effects and settings we want to apply. This is a separate asset for the same reason the Material is: because we can share the same post-processing profile across different scenes and parts of scenes. When we refer to parts of the scenes, we are referring to volumes or areas of the game that have certain effects applied. We can define a global area that applies effects regardless of the position of the player, or we can apply different effects—for example, when we are outdoors or indoors.</p>
    <p class="normal">In this case, we will use a global volume, one that we will use to apply a profile with our first effect, by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create<a id="_idIndexMarker879"/> a new empty GameObject (<strong class="screenText">GameObject | Create Empty</strong>) named <code class="inlineCode">PP Volume </code>(Post-Processing Volume).</li>
      <li class="numberedList">Add the <strong class="screenText">Volume</strong> component to it and make sure the <strong class="screenText">Mode</strong> is set to <strong class="screenText">Global</strong>.</li>
      <li class="numberedList">Click on the <strong class="screenText">New</strong> button at the right of the <strong class="screenText">Profile</strong> setting, which will generate a new <code class="inlineCode">Profile</code> asset with the same name as the GameObject that was selected when clicking the button (<strong class="screenText">PPVolume</strong> <strong class="screenText">Profile</strong>). Move that asset to its own folder, which is recommended for asset organization purposes. The process is illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.2: Volume component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">To test if the volume is working, let’s add an effect. Click the <strong class="screenText">Add Override</strong> button and select the <strong class="screenText">Post-Processing | Chromatic Aberration</strong> option.</li>
      <li class="numberedList">Check the <strong class="screenText">Intensity</strong> checkbox in the <strong class="screenText">Chromatic Aberration</strong> effect and set the intensity to <code class="inlineCode">0.25</code>, as illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.3: Chromatic aberration effect</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Now, you will see an aberration effect being applied in the corners of the image. Remember to look at this in the <strong class="screenText">Scene</strong> panel; we will make the effect applied to the Game view in the next step. This is illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.4: Chromatic aberration applied to the scene</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Now, if <a id="_idIndexMarker880"/>you hit <strong class="screenText">Play</strong> and see the game from the view of the Main Camera, you will see that the effect is not being applied, and that’s because we need to check the <strong class="screenText">Post Processing</strong> checkbox in the <strong class="screenText">Rendering</strong> section of our Main Camera, as illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.5: Enabling post-processing</p>
    <p class="normal">So, we have created a global volume, which will apply the effects specified as overrides to the entire scene regardless of the player’s position.</p>
    <p class="normal">Now that we have prepared our scene to use post-processing, we can start experimenting with different effects. Let’s start with the simplest ones in the next section.</p>
    <h2 id="_idParaDest-170" class="heading-2">Using basic effects</h2>
    <p class="normal">Now that<a id="_idIndexMarker881"/> we have post-processing in our scene, the only thing needed is to start adding effects and set them up until we have the desired look and feel. In order to do that, let’s explore several simple effects included in the system.</p>
    <p class="normal">Let’s start with <strong class="keyWord">Chromatic Aberration</strong>, the one<a id="_idIndexMarker882"/> we just used, which, as with most image effects, tries to replicate a particular real-life effect. All game-engine rendering systems use a simple mathematical approximation of how eye vision really works, and because of that, we don’t have some effects that occur in the human eyes or camera lenses. A real camera lens works by bending light rays to point them toward the camera sensors, but that bending is not perfect in some lenses (sometimes intentionally), and, hence, you can see a distortion, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B18585_13_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.6: Image without chromatic aberration (left) and the same image with chromatic aberration (right)</p>
    <p class="normal">This effect will be one of several that we will add to generate a cinematic feeling in our game, simulating the usage of real-life cameras. Of course, this effect won’t look nice in every kind of game; maybe a simplistic cartoonish style won’t benefit from this one, but you never know: art is subjective, so it’s a matter of trial and error. </p>
    <p class="normal">Also, we have exaggerated the intensity a little bit in the previous example to make the effect more noticeable, but I would recommend using an intensity of <code class="inlineCode">0.25</code> in this scenario. It is usually recommended to be gentle with the intensity of the effects; it’s tempting to have intense effects, but as you will be adding lots of them, after a while, the image will be bloated, with too many distortions. So, try to add several subtle effects instead of a few intense ones. But, again, this depends on the target style you are looking for; there are no absolute truths here (but common sense still applies).</p>
    <p class="normal">Finally, before moving on to discuss other effects, if you are used to using other kinds of post-processing effects frameworks, you will notice that this version<a id="_idIndexMarker883"/> of <strong class="keyWord">Chromatic Aberration</strong> has fewer settings, and that’s because the URP version seeks performance, so it will be as simple as possible.</p>
    <p class="normal">The next effect we<a id="_idIndexMarker884"/> are going to discuss is <strong class="keyWord">Vignette</strong>. This is another camera-lens imperfection where the image intensity is lost at the edges of the lens. This can be applied not only to simulate older cameras but also to draw the attention of the user toward the <a id="_idIndexMarker885"/>center of the camera—for example, during cinematics. </p>
    <p class="normal">Also, if you are developing <strong class="keyWord">virtual reality</strong> (<strong class="keyWord">VR</strong>) applications, this can be used to reduce motion sickness by reducing the peripheral vision of the player. In the following screenshot, you can see an example of vignetting on an old camera:</p>
    <figure class="mediaobject"><img src="img/B18585_13_07.png" alt="Image result for vignetting"/></figure>
    <p class="packt_figref">Figure 13.7: Photo taken with an old camera, with vignetting over the edges</p>
    <p class="normal">Just to try it, let’s apply some <a id="_idIndexMarker886"/>vignetting to our scene by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the <code class="inlineCode">PP Volume</code> GameObject.</li>
      <li class="numberedList">Add the <strong class="screenText">Postprocessing | Vignette</strong> effect by clicking on the <strong class="screenText">Add Override </strong>button.</li>
      <li class="numberedList">Check the <strong class="screenText">Intensity</strong> checkbox and set it to <code class="inlineCode">0.3</code>, increasing the effect.</li>
      <li class="numberedList">Check the <strong class="screenText">Smoothness </strong>checkbox and set it to <code class="inlineCode">0.5</code>; this will increase the spread of the effect. You can see the result in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.8: Vignette effect</p>
    <p class="normal">If you want, you can <a id="_idIndexMarker887"/>change the color by checking the <strong class="screenText">Color</strong> checkbox and setting it to another value; in our case, black is okay to reinforce the rainy-day environment. Here, I invite you to check other properties, such as <strong class="screenText">Center</strong> and <strong class="screenText">Rounded</strong>. You can create nice effects just by playing with the values.</p>
    <p class="normal">Another <a id="_idIndexMarker888"/>effect we are going to see is <strong class="keyWord">Motion Blur</strong>, and again, it<a id="_idIndexMarker889"/> simulates the way the cameras work. A real camera has an exposure time: the time it needs to capture photons into an image. When an object moves fast enough, the same object is placed in different positions during that brief exposure time, so it will appear blurred. In the following screenshot, you can see the effect applied to our scene. In the case of this image, we are rotating the camera up and down fast, with the following result:</p>
    <figure class="mediaobject"><img src="img/B18585_13_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.9: Motion Blur being applied to our scene</p>
    <p class="normal">One thing to consider is that this blur will only be applied to the camera movement and not the movement of the objects (still camera, moving objects), due to the fact that this URP doesn’t support motion vectors yet.</p>
    <p class="normal">In order to use <a id="_idIndexMarker890"/>this effect, follow these next steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the <strong class="screenText">Post-processing | Motion Blur</strong> override <a id="_idIndexMarker891"/>with the <strong class="screenText">Add override</strong> button.</li>
      <li class="numberedList">Check the <strong class="screenText">Intensity</strong> checkbox and set it to <code class="inlineCode">0.25</code>.</li>
      <li class="numberedList">Rotate the camera while looking at the Game view (not the Scene view). You can click and drag the <strong class="screenText">X</strong> property of the <strong class="screenText">Transform</strong> of the camera (not the value—the <strong class="screenText">X</strong> label), as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.10: Changing rotation</p>
    <p class="normal">As you can see, this effect cannot be seen in the Scene view, as well as other effects, so take that into account before concluding the effect is not working. Unity does this because it would be very annoying to have that effect while working in the scene.</p>
    <p class="normal">Finally, we are going to briefly <a id="_idIndexMarker892"/>discuss two final simple effects, <strong class="keyWord">Film Grain</strong> and <strong class="keyWord">White Balance</strong>. The <a id="_idIndexMarker893"/>first is pretty simple: add it, set the intensity to <code class="inlineCode">1</code>, and you will get the famous grain effect from the old movies. You can set the <strong class="screenText">Type</strong> with a different number of sizes to make it more subtle or harsh. <strong class="screenText">White Balance</strong> allows you to change the color temperature, making colors warmer or cooler depending on how you configure it. In our case, we are working in a cold, dark scene, so you can add it and set the temperature to <code class="inlineCode">-20</code> to adjust the <a id="_idIndexMarker894"/>appearance just slightly and improve the look and feel in this kind of scene.</p>
    <p class="normal">Now that we have seen a few of the simple effects, let’s check out a few of the remaining ones that are affected by some advanced rendering features.</p>
    <h1 id="_idParaDest-171" class="heading-1">Using advanced effects</h1>
    <p class="normal">The effects we are going<a id="_idIndexMarker895"/> to see in this section don’t differ a lot from the previous ones; they are just a little bit trickier and need some background to properly use them. So, let’s dive into them!</p>
    <p class="normal">In this section, we are going to see the following advanced effect concepts:</p>
    <ul>
      <li class="bulletList">High Dynamic Range (HDR) and Depth Map</li>
      <li class="bulletList">Applying advanced effects</li>
    </ul>
    <p class="normal">Let’s start by discussing some requirements for some of these effects to work properly.</p>
    <h3 id="_idParaDest-172" class="heading-3">High Dynamic Range (HDR) and Depth Map</h3>
    <p class="normal">Some effects not only work with the rendered image but also need additional data. We can first discuss the <strong class="keyWord">Depth Map</strong>, a concept we discussed in the previous chapter. </p>
    <p class="normal">To recap, a Depth Map<a id="_idIndexMarker896"/> is an image rendered from the point of view of the <a id="_idIndexMarker897"/>camera, but instead of generating a final image of the scene, it renders the scene objects’ depth, rendering the objects in shades of gray. The darker the color, the farthest from the camera the pixel is, and vice versa. In the following screenshot, you can see an example of a Depth Map:</p>
    <figure class="mediaobject"><img src="img/B18585_13_11.png" alt="Image result for depth buffer"/></figure>
    <p class="packt_figref">Figure 13.11: Depth map of a few primitive shapes</p>
    <p class="normal">We will see some effects<a id="_idIndexMarker898"/> such as <strong class="keyWord">Depth of Field</strong>, which will blur some parts of the image based on the distance of the camera, but it can be used for several purposes on custom effects (not in the base URP package). </p>
    <p class="normal">Another concept to discuss here that will alter how colors are treated and, hence, how some effects work is <strong class="keyWord"><a id="_idIndexMarker899"/></strong><strong class="keyWord">High Dynamic Range</strong> (<strong class="keyWord">HDR</strong>). In older<a id="_idIndexMarker900"/> hardware, color channels (Red, Green, and Blue) were encoded in a 0 to 1 range, 0 being no intensity and 1 being full intensity (per channel), so all lighting and color calculations were done in that range. That seems okay but doesn’t reflect how light actually works. You can see full white (all channels set to 1) in a piece of paper being lit by sunlight, and you can see full white when you look directly at a light bulb, but even if both light and paper are of the same color, the latter will, firstly, irritate the eye after a while, and secondly, will have some overglow due to an excess of light. The problem here is that the maximum value (1) is not enough to represent the most intense color, so if you have a high-intensity light and another with even more intensity, both will generate the same color (1 in each channel) because calculations cannot go further than 1. So, that’s why <strong class="keyWord">HDR Rendering</strong> was created.</p>
    <p class="normal">HDR is <a id="_idIndexMarker901"/>a way for colors to exceed the 0 to 1 range, so lighting and effects that work based on color intensity have better accuracy in this mode. It is the same idea as the new televisions models’ HDR feature, although in this case, Unity will do the calculations in HDR but the final image<a id="_idIndexMarker902"/> will still work using the previous color space (0 to 1, or <strong class="keyWord">Low Dynamic Range (LDR</strong>), so don’t confuse Unity’s <strong class="keyWord">HDR Rendering</strong> with the <strong class="keyWord">Display’s HDR</strong>. </p>
    <p class="normal">To convert the HDR calculations back to LDR, Unity (and also TVs) uses a concept called <strong class="keyWord">tonemapping</strong>. You can see an example of an LDR-rendered scene <a id="_idIndexMarker903"/>and tonemapping being used in an HDR scene in the following screenshots:</p>
    <figure class="mediaobject"><img src="img/B18585_13_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.12: An LDR-rendered scene (left) and an HDR scene with corrected overbrights using tonemapping (right)</p>
    <p class="normal">Tonemapping is<a id="_idIndexMarker904"/> a way to bring colors outside the 0-1 range back in to it. It basically uses curves to determine how each color channel should be mapped back. </p>
    <p class="normal">You can clearly see this in the typical darker-to-lighter scene transition, such as when you exit a building without windows to go out into a bright day. For a time, you will see everything lighter until everything goes back to normal. The idea here is that calculations are not different when you are inside or outside the building; a white wall inside the building will have a color near the 1 intensity, while the same white wall outside will have a higher value (due to sunlight). The difference is that tonemapping will take the higher-than-1 color back to 1 when you are outside the building, and maybe it will increase the lighting of the wall inside if all the scene is darker, depending on how you set it. That feature is called <strong class="keyWord">auto-exposure</strong>.</p>
    <p class="normal">Even if HDR is <a id="_idIndexMarker905"/>enabled by default, let’s just see how we can check that, by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit</strong> | <strong class="screenText">Project Settings</strong>.</li>
      <li class="numberedList">Click on the <strong class="screenText">Graphics</strong> section in the left panel.</li>
      <li class="numberedList">Click the asset referenced under the <strong class="screenText">Scriptable Render Pipeline Settings</strong> property.</li>
      <li class="numberedList">Click on the highlighted asset in the <strong class="screenText">Project</strong> panel. Ensure that this panel is visible before clicking the property in the <strong class="screenText">Graphics</strong> settings. Alternatively, you can double-click the asset reference in the <strong class="screenText">Graphics</strong> settings to select it.</li>
      <li class="numberedList">Under the <strong class="screenText">Quality</strong> section, ensure that <strong class="screenText">HDR</strong> is checked, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.13: Enabling HDR</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Ensure that the <strong class="screenText">HDR</strong> property of the <strong class="screenText">Camera</strong> component in the <strong class="screenText">Main Camera</strong> GameObject is set to <strong class="screenText">Use settings from Render Pipeline</strong> to ensure the change in the previous steps is respected.</li>
    </ol>
    <p class="normal">Of course, the fact that <a id="_idIndexMarker906"/>HDR is togglable means that there are scenarios where you don’t want to use it. As you can guess, not all hardware supports HDR, and using it incurs a performance overhead, so take that into account. Luckily, most effects work with both HDR and LDR color ranges, so if you have HDR enabled but the user device doesn’t support it, you won’t get any errors, just different results depending on the effect, such as brighter or darker images, or exaggerated effects, as we will see in the next section, <em class="italic">Applying advanced effects</em>.</p>
    <p class="normal">Now that we are sure we have HDR enabled, let’s explore some advanced effects that use this and Depth Mapping.</p>
    <h2 id="_idParaDest-173" class="heading-2">Applying advanced effects</h2>
    <p class="normal">Let’s see certain effects <a id="_idIndexMarker907"/>that use the previously described techniques, starting with the commonly used <strong class="keyWord">Bloom</strong>. This<a id="_idIndexMarker908"/> effect emulates the overglow that happens around a heavily lit object on a camera lens or even the human eye. In <em class="italic">Figure 13.14</em>, you can see the difference between the default version of our scene and an exaggerated Bloom version. </p>
    <p class="normal">You can observe how the effect is only applied to the brightest areas of our scene. Have a look at both effects here:</p>
    <figure class="mediaobject"><img src="img/B18585_13_14.png" alt=""/> </figure>
    <p class="packt_figref">Figure 13.14: The default scene (left) and the same scene with a high-intensity Bloom (right)</p>
    <p class="normal">This effect is actually very common and simple, but I considered it advanced because the results are drastically affected by HDR. This effect relies on calculating the intensity of each pixel’s color to detect areas where it can be applied. In LDR, we can have a white object that isn’t overbright, but due to the limitations in this color range, Bloom may cause an overglow over it. In HDR, due to its increased color range, we can detect if an object is white or if the object is maybe light blue but just overbright, generating the illusion that it is white (such as objects near a high-intensity lamp). In <em class="italic">Figure 13.15</em> screenshot, you can see the difference between our scene with HDR and without it. You will notice that the LDR version will have overglow in areas that are not necessarily overbright. The difference may be very subtle, but pay attention to the little details to note the difference. And remember, I exaggerated the effect here. Have a look at both scenes here:</p>
    <figure class="mediaobject"><img src="img/B18585_13_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.15: Bloom in an LDR scene (left) and Bloom in an HDR scene (right). Notice that the Bloom settings were changed to try to approximate them as much as possible</p>
    <p class="normal">For now, let’s stick with <a id="_idIndexMarker909"/>the HDR version of the scene. In order to enable <a id="_idIndexMarker910"/>Bloom, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the <strong class="screenText">Bloom</strong> override to the profile, as usual.</li>
      <li class="numberedList">Enable the <strong class="screenText">Intensity</strong> checkbox by checking it, and set the value to <code class="inlineCode">0.2</code>. This controls how much overglow will be applied.</li>
      <li class="numberedList">Enable <strong class="screenText">Threshold</strong> and set it to <code class="inlineCode">0.7</code>. This value indicates the minimum intensity a color needs to have to be considered for overglow. In our case, our scene is somewhat dark, so we need to reduce this value in the Bloom effect settings to have more pixels included. As usual, those values need to be adjusted to your specific scenario.</li>
      <li class="numberedList">You will notice that the difference is very subtle, but again, remember that you will have several effects, so all those little differences will sum up. You can see both effects in the following screenshots:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.16: Bloom effect</p>
    <p class="normal">As usual, it is<a id="_idIndexMarker911"/> recommended<a id="_idIndexMarker912"/> that you fiddle with the other values. Some interesting settings I recommend you test are the <strong class="screenText">Dirt Texture</strong> and <strong class="screenText">Dirt Intensity</strong> values, which will simulate dirty lenses in the overglow area.</p>
    <p class="normal">Now, let’s move to another <a id="_idIndexMarker913"/>common effect, <strong class="keyWord">Depth of Field</strong>. This one relies on the depth map we discussed earlier. It is not that obvious to the naked eye, but when you focus on an object within your sight, the surrounding objects became blurred because they are out of focus. We can use this to focus the attention of the player in key moments of the gameplay. This effect will sample the Depth Map to see if the object is within the focus range; if it is, no blur will be applied, and vice versa. </p>
    <p class="normal">In order to use it, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">This effect depends on the camera positioning of your game. To test it, in this case, we will put the camera near a column to try to focus on that specific object, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.17: Camera positioning</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Add<a id="_idIndexMarker914"/> the <strong class="screenText">Depth of Field</strong> override.</li>
      <li class="numberedList">Enable and<a id="_idIndexMarker915"/> set the <strong class="screenText">Mode</strong> setting to <strong class="screenText">Gaussian</strong>: the cheapest one in terms of performance to use.</li>
      <li class="numberedList">In my case, I have set <strong class="screenText">Start</strong> to <code class="inlineCode">10</code> and <strong class="screenText">End</strong> to <code class="inlineCode">20</code>, which will make the effect start at a distance behind the target object. The <strong class="screenText">End</strong> setting will control how the blur’s intensity will increase, reaching its maximum at a distance of <code class="inlineCode">20</code> meters. Remember to tweak these values to your case.</li>
      <li class="numberedList">If you want to exaggerate the effect a little bit, set <strong class="screenText">Max Radius</strong> to <code class="inlineCode">1.5</code>. The result is shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.18: Exaggerated effect</p>
    <p class="normal">Something to consider here is that our game will have a top-down perspective, and unlike the first-person camera where you can see distant objects, here, we will have objects near enough to not notice the effect, so we can limit the use of this effect just for cutscenes in our scenario.</p>
    <p class="normal">Now, most of the<a id="_idIndexMarker916"/> remaining effects are different ways to alter the actual colors of the scene. The idea is that the real color sometimes doesn’t give you the exact look and feel you are seeking. Maybe you need the dark zones to be darker to reinforce the sensation of a horror ambiance, or maybe you want to do the opposite: increase the dark<a id="_idIndexMarker917"/> areas to represent an open scene. Maybe you want to tint the highlights a little bit to get a neon effect if you are creating a futuristic game, or perhaps you want a sepia effect temporarily to do a flashback. We have a myriad of ways to <a id="_idIndexMarker918"/>do this, and in this case, I will use a simple but powerful effect<a id="_idIndexMarker919"/> called <strong class="keyWord">Shadow, Midtones, Highlights</strong>.</p>
    <p class="normal">This effect will apply different color corrections to—well —Shadows, Midtones, and Highlights, meaning that we can modify darker, lighter, and medium areas separately. Let’s try it by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the <strong class="screenText">Shadow</strong> <strong class="screenText">Midtones</strong> <strong class="screenText">Highlights</strong> override.</li>
      <li class="numberedList">Let’s start doing some testing. Check the three <strong class="screenText">Shadows</strong>, <strong class="screenText">Midtones</strong>, and <strong class="screenText">Highlights</strong> checkboxes.</li>
      <li class="numberedList">Move the <strong class="screenText">Shadow</strong> and <strong class="screenText">Midtones</strong> sliders all the way to the left and the one for <strong class="screenText">Highlights</strong> to the right. This will reduce the intensity of Shadows and Midtones and increase the intensity of Highlights. We did this so that you can see the areas that <strong class="screenText">Highlights</strong> will alter, based on their intensity. You can do the same with the rest of the sliders to check the other two areas. You can see the result in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.19: Isolating highlights</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Also, you can test moving the white circle at the center of the colored circle to apply a little bit of tinting to those areas. Reduce the intensity of the highlights by moving the slider a little bit to the left to make the tinting more noticeable. You can see the result in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.20: Tinting highlights</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">By doing this, you<a id="_idIndexMarker920"/> can explore how those controls work, but of course, those extreme values are useful for some edge cases. In our scene, the settings you can see in the following screenshot worked best for me. As always, it is better to use subtler values to not distort too much the original result, as illustrated here:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.21: Subtle changes</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">You can see the before-and-after effects in the following screenshots:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_13_22.png" alt=""/></figure>
    <figure class="mediaobject">Figure 13.22: Before-and-after effects</figure>
    <p class="normal">You have other simpler<a id="_idIndexMarker921"/> options such as <strong class="keyWord">Split Toning</strong>, which does something similar but just with <strong class="screenText">Shadows</strong> and <strong class="screenText"><a id="_idIndexMarker922"/></strong><strong class="screenText">Highlights</strong>, or <strong class="keyWord">Color Curves</strong>, which<a id="_idIndexMarker923"/> give you advanced control of how each color channel of the scene will be mapped, but the idea is the same—that is, to alter the actual color of the resulting scene to apply a specific color ambiance to your scene. If you remember the movie series <em class="italic">The Matrix</em> when the characters were in the Matrix, everything had subtle green tinting, and while outside it, the tinting was blue. </p>
    <p class="normal">Remember that the results of using HDR and not using it regarding these effects are important, so it is better to decide sooner rather than later whether to use HDR, excluding certain target platforms (which may not be important to your target audience), or not to use it (using LDR) and have less control over your scene lighting levels.</p>
    <p class="normal">Also, take into account that maybe you will need to tweak some objects’ settings, such as light intensities and material properties, because sometimes we use post-processing to fix graphics errors that may be caused by wrongly set objects, and that’s not okay. For example, increasing the <code class="inlineCode">Ambient Lighting</code> in our scene will drastically change the output of the effects, and we can use that to increase the overall brightness instead of using an effect if we find the scene too dark.</p>
    <p class="normal">This has covered the main image effects to use. Remember that the idea is not to use every single one but to use the ones that you feel are contributing to your scene; they are not free in<a id="_idIndexMarker924"/> terms of performance (although not that resource intensive), so use them wisely. Also, you can check for the already created profiles to apply them to your game and see how little changes can make a huge difference.</p>
    <h1 id="_idParaDest-174" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed basic and advanced full-screen effects to apply in our scene, making it look more realistic in terms of camera-lens effects and more stylish in terms of color distortions. We also discussed the internals of HDR and Depth Maps and how they are important when using those effects, which can immediately increase your game’s graphic quality with minimal effort.</p>
    <p class="normal">Now that we have covered most of the common graphics found in Unity systems, let’s start looking at how to increase the immersion of our scene by using sounds.</p>
  </div>
</body></html>