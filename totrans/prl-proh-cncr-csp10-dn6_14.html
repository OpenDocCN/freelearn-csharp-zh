<html><head></head><body>
<div><div><h1 id="_idParaDest-174"><em class="italic"><a id="_idTextAnchor173"/>Chapter 11</em>: Canceling Asynchronous Work</h1>
<p>In the previous chapters, we’ve looked at a few examples of how to cancel threads and tasks. This chapter will explore more of the methods available to cancel concurrent and parallel work with C# and .NET. The methods in this chapter will provide alternative ways to cancel background operations using callbacks, polling, and wait handles. You will gain a deeper<a id="_idIndexMarker564"/> understanding of how to safely cancel asynchronous work with a variety of methods using some practical scenarios.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Canceling managed threads</li>
<li>Canceling parallel work</li>
<li>Discovering patterns for thread cancellation</li>
<li>Handling multiple cancelation sources</li>
</ul>
<p>By the end of this chapter, you will understand how to cancel different types of asynchronous and parallel tasks.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.2 or later.</li>
<li>.NET 6.</li>
<li>To complete any WinForms or WPF samples, you will need to install the .NET desktop development workload for Visual Studio. These projects will only run on Windows.</li>
</ul>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11</a>.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Canceling managed threads</h1>
<p>Canceling <a id="_idIndexMarker565"/>asynchronous work in .NET is based on the use of a <code>CancellationTokenSource</code> object manages these requests and contains a token. If you want to cancel several operations with the same trigger, the same token should be provided to all of the threads to be canceled.</p>
<p>A <code>CancellationTokenSource</code> instance has a <code>Token</code> property to access the <code>CancellationToken</code> property and pass it to one or more asynchronous operations. The request to cancel can only be made from the <code>CancellationTokenSource</code> object. The <code>CancellationToken</code> property provided to the other operations receives the signal to cancel but cannot initiate a cancellation.</p>
<p><code>CancellationTokenSource</code> implements the <code>IDisposable</code> interface, so be sure to call <code>Dispose</code> when you are freeing your managed resources. A <code>using</code> statement or block to automatically dispose of the token source would be preferred if it is practical for your workflow.</p>
<p>It is important to understand that cancellation is not forced on the listening code. The asynchronous code that receives a cancellation request must determine whether it can currently cancel its work. It might decide to immediately cancel, cancel after finishing some intermediate tasks, or finish its work and ignore the request. There can be valid reasons why a routine will ignore a request to cancel. It is possible that the work is almost complete or that canceling in the current state will cause some data corruption. The decision to cancel must be mutual between the requestor and the listener.</p>
<p>Let’s look at an example of how to cooperatively cancel some work being processed on a background thread on the <code>ThreadPool</code> thread:</p>
<ol>
<li>In Visual Studio, create a new .NET 6 console application named <code>CancelThreadsConsoleApp.</code></li>
<li>Add a new class named <code>ManagedThreadsExample</code>.</li>
<li>Create a method named <code>ProcessText</code> in the <code>ManagedThreadsExample</code> class:<pre>public static void ProcessText(object? cancelToken)
{
    var token = cancelToken as CancellationToken?;
    string text = "";
    for (int x = 0; x &lt; 75000; x++)
    {
        if (token != null &amp;&amp; token.Value
            .IsCancellationRequested)
        {
            Console.WriteLine($"Cancellation request 
                received. String value: {text}");
            break;
        }
        text += x + " ";
        Thread.Sleep(500);
    }
}</pre></li>
</ol>
<p>This <a id="_idIndexMarker567"/>method appends the value of the iterator variable, <code>x</code>, to the <code>string</code> variable of <code>text</code> until a cancellation request is received. There is a <code>Thread.Sleep(500)</code> statement to allow the calling method some time to cancel the operation.</p>
<ol>
<li value="4">Next, create a method named <code>CancelThread</code>, in <code>Program.cs</code>:<pre>private static void CancelThread()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Starting operation.");
    ThreadPool.QueueUserWorkItem(new 
        WaitCallback(ManagedThreadsExample
            .ProcessText), tokenSource.Token);
    Thread.Sleep(5000);
    Console.WriteLine("Requesting cancellation.");
    tokenSource.Cancel();
    Console.WriteLine("Cancellation requested.");
}</pre></li>
</ol>
<p>This <a id="_idIndexMarker568"/>method calls <code>ThreadPool.QueueUserWorkItem</code> to queue the <code>ProcessText</code> method in the <code>ThreadPool</code> thread. The method also receives a cancellation token from <code>tokenSource.Token</code>. After waiting for five seconds, <code>tokenSource.Cancel</code> is called, and <code>ProcessText</code> will receive the cancellation request.</p>
<p>Notice that <code>tokenSource</code> is created in a <code>using</code> statement. This ensures that it will be properly disposed of when it goes out of scope.</p>
<ol>
<li value="5">Add a call to <code>CancelThread</code> to the <code>Main</code> method in <code>Program.cs</code>:<pre>static void Main(string[] args)
{
    CancelThread();
    Console.ReadKey();
}</pre></li>
<li>Finally, run the application and observe the console output:</li>
</ol>
<div><div><img alt="Figure 11.1 – Running the CancelThreadsConsoleApp project " height="297" src="img/Figure_11.1_B18852.jpg" width="936"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Running the CancelThreadsConsoleApp project</p>
<p>The <code>for</code> loop should <a id="_idIndexMarker569"/>have enough time to execute 9 or 10 times before receiving the request to cancel. How does your output match up?</p>
<p>Now that we have covered some basics of cancellation and worked with a common method of using a cancellation token, let’s create some examples of how to cancel parallel loops and PLINQ queries.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Canceling parallel work</h1>
<p>In this <a id="_idIndexMarker570"/>section, we will work with some examples of canceling parallel operations. There are a few operations that fall into this realm. There are static parallel operations that are part of the <code>System.Threading.Tasks.Parallel</code> class and there are PLINQ operations. Both of these types use a <code>CancellationToken</code> property, as we used in our managed threading example in the previous section. However, handling the cancellation request is slightly different. Let’s look at an example to understand the differences.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Canceling a parallel loop</h2>
<p>In this <a id="_idIndexMarker571"/>section, we will create a sample that illustrates how to cancel a <code>Parallel.For</code> loop. The same method of cancellation is leveraged for the <code>Parallel.ForEach</code> method. Perform the following steps:</p>
<ol>
<li value="1">Open the <code>CancelThreadsConsoleApp</code> project from the previous section.</li>
<li>In the <code>ManagedThreadsExample</code> class, create a new <code>ProcessTextParallel</code> method with the following implementation:<pre>public static void ProcessTextParallel(object? 
    cancelToken)
{
    var token = cancelToken as CancellationToken?;
    if (token == null) return;
    string text = "";
    ParallelOptions options = new()
    {
        CancellationToken = token.Value,
        MaxDegreeOfParallelism = 
            Environment.ProcessorCount
    };
    try
    {
        Parallel.For(0, 75000, options, (x) =&gt;
        {
            text += x + " ";
            Thread.Sleep(500);
        });
    }
    catch (OperationCanceledException e)
    {
        Console.WriteLine($"Text value: {text}. 
            {Environment.NewLine} Exception 
                encountered: {e.Message}");
    }
}</pre></li>
</ol>
<p>Essentially, the preceding code does the same thing as the <code>ProcessText</code> method in our last example. It appends a numeric value to the <code>text</code> variable until a <a id="_idIndexMarker572"/>cancellation is requested. Let’s examine the differences:</p>
<ul>
<li>First, we are setting <code>token.Value</code> to the <code>CancellationToken</code> property of a <code>ParallelOptions</code> object. These options are passed as the third parameter to the <code>Parallel.For</code> method.</li>
<li>The second major difference is that we handle the cancellation request by catching an <code>OperationCanceledException</code> type. This exception type will be thrown when our other code in <code>Program.cs</code> requests a cancellation.</li>
</ul>
<ol>
<li value="3">Next, add a method named <code>CancelParallelFor</code> to <code>Program.cs</code>:<pre>private static void CancelParallelFor()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Press a key to start, then 
        press 'x' to send cancellation.");
    Console.ReadKey();
    Task.Run(() =&gt;
    {
        if (Console.ReadKey().KeyChar == 'x')
            tokenSource.Cancel();
        Console.WriteLine();
        Console.WriteLine("press a key");
    });
    ManagedThreadsExample.ProcessTextParallel
        (tokenSource.Token);
}</pre></li>
</ol>
<p>In this<a id="_idIndexMarker573"/> method, the user is instructed to press a key to start the operation and to press the <em class="italic">X</em> key when they are ready to cancel the operation. The code to handle receiving <code>x</code> <code>KeyChar</code> from the console and sending a <code>Cancel</code> request is performed on another thread in order to keep the current thread free to call <code>ProcessTextParallel</code>.</p>
<ol>
<li value="4">Finally, update the <code>Main</code> method to call <code>CancelParallelFor</code> and comment out the call to <code>CancelThread</code>:<pre>static void Main(string[] args)
{
    //CancelThread();
    CancelParallelFor();
    Console.ReadKey();
}</pre></li>
<li>Now run the project. Follow the prompts to cancel the <code>Parallel.For</code> loop, and examine the output:</li>
</ol>
<div><div><img alt="Figure 11.2 – Canceling a Parallel.For loop from the console " height="373" src="img/Figure_11.2_B18852.jpg" width="1010"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Canceling a Parallel.For loop from the console</p>
<p>Notice how the numbers are not in sequence at all. In this case, it appears that the <code>Parallel.For</code> operation used two different threads. The first thread started at <code>0</code>, while the second thread was operating on integers starting with <code>37500</code>. This <a id="_idIndexMarker574"/>is the midway point of the maximum value of <code>75000</code> provided to the method parameter.</p>
<p>In the next section, we will briefly examine how to cancel a PLINQ query.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Canceling a PLINQ query</h2>
<p>Canceling a<a id="_idIndexMarker575"/> PLINQ query is also achieved by catching the <code>OperationCanceledException</code> type. However, instead of using the <code>ParallelOptions</code> object that is used with parallel loops, you can call <code>WithCancellation</code> as part of the query.</p>
<p>To learn how to cancel a PLINQ query, let’s walk through an example:</p>
<ol>
<li value="1">Start this example by adding a method named <code>ProcessNumsPlinq</code>, to the <code>ManagedThreadsExample</code> class:<pre>public static void ProcessNumsPlinq(object? 
    cancelToken)
{
    int[] input = Enumerable.Range(1, 
        25000000).ToArray();
    var token = cancelToken as CancellationToken?;
    if (token == null) return;
    int[]? result = null;
    try
    {
        result =
            (from value in input.AsParallel()
                .WithCancellation(token.Value)
                where value % 7 == 0
                orderby value
                select value).ToArray();
    }
    catch (OperationCanceledException e)
    {
        Console.WriteLine($"Exception encountered: 
            {e.Message}");
    }
}</pre></li>
</ol>
<p>This method<a id="_idIndexMarker576"/> creates an array of 25 million integers and uses the PLINQ query to determine which of them are divisible by seven. The <code>token.Value</code> is passed to the <code>WithCancellation</code> operation in the query. When an exception is thrown by a cancellation request, the exception details are written to the console.</p>
<ol>
<li value="2">Next, add <a id="_idIndexMarker577"/>a method named <code>CancelPlinq</code> to <code>Program.cs</code>:<pre>private static void CancelPlinq()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Press a key to start.");
    Console.ReadKey();
    Task.Run(() =&gt;
    {
        Thread.Sleep(100);
        Console.WriteLine("Requesting cancel.");
        tokenSource.Cancel();
        Console.WriteLine("Cancel requested.");
    });
    ManagedThreadsExample.ProcessNumsPlinq
        (tokenSource.Token);
}</pre></li>
</ol>
<p>This time, the cancellation will be triggered automatically after 100 milliseconds.</p>
<ol>
<li value="3">Update the <code>Main</code> method to call <code>CancelPlinq</code>, and run the application:</li>
</ol>
<div><div><img alt="Figure 11.3 – Canceling a PLINQ operation in the console application " height="398" src="img/Figure_11.3_B18852.jpg" width="1113"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Canceling a PLINQ operation in the console application</p>
<p>Unlike<a id="_idIndexMarker578"/> the previous examples, there is no query output to examine. You cannot get partial output from a PLINQ query. The <code>result</code> variable will be <code>null</code>.</p>
<p>In the next section, we will work with some different methods of cancellation.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/>Discovering patterns for thread cancellation</h1>
<p>There are<a id="_idIndexMarker579"/> different methods of listening for <a id="_idIndexMarker580"/>cancellation requests from a thread or task. So far, we have seen examples of managing these requests by either handling the <code>OperationCanceledException</code> type or checking the value of <code>IsCancellationRequested</code>. The pattern of checking <code>IsCancellationRequested</code>, usually inside a loop, is<a id="_idIndexMarker581"/> called <code>ManualResetEvent</code> or <code>ManualResetEventSlim</code>.</p>
<p>Let’s start by trying another <a id="_idIndexMarker582"/>example of handling a cancellation request by polling.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Canceling with polling</h2>
<p>In this<a id="_idIndexMarker583"/> section, we will create another example that <a id="_idIndexMarker584"/>uses polling to cancel a background task. The previous example of polling was running in a background thread on the <code>ThreadPool</code> thread. This example will also start a <code>ThreadPool</code> thread, but it will leverage <code>Task.Run</code> to start the background thread. We will create and process a million <code>System.Drawing.Point</code> objects, finding those with a <code>Point.X</code> value of less than <code>50</code>. Users will have the option to cancel processing by pressing the <em class="italic">X</em> key:</p>
<ol>
<li value="1">Start by creating a new .NET console application project named <code>CancellationPatterns</code></li>
<li>Add a new class to the project named <code>PollingExample</code></li>
<li>Add a private static method to <code>PollingExample</code> named <code>GeneratePoints</code>. This will generate the number of <code>Point</code> objects that we desire with random <code>X</code> values:<pre>private static List&lt;Point&gt; GeneratePoints(int count)
{
    var rand = new Random();
    var points = new List&lt;Point&gt;();
    for (int i = 0; i &lt;= count; i++)
    {
        points.Add(new Point(rand.Next(1, count * 2), 
            100));
    }
    return points;
}</pre></li>
<li>Don’t forget to add a <code>using</code> statement to use the <code>Point</code> type:<pre>using System.Drawing;</pre></li>
<li>Next, add <a id="_idIndexMarker585"/>a private static method <a id="_idIndexMarker586"/>named <code>FindSmallXValues</code> to <code>PollingExample</code>. This method loops through the list of points and outputs those with an <code>X</code> value of less than <code>50</code>. Each time through the loop, it checks the token for cancellation and breaks out of the loop when it occurs:<pre>private static void FindSmallXValues(List&lt;Point&gt; 
    points, CancellationToken token)
{
    foreach (Point point in points)
    {
        if (point.X &lt; 50)
        {
            Console.WriteLine($"Point with small X 
                coordinate found. Value: {point.X}");
        }
        if (token.IsCancellationRequested)
        {
            break;
        }
        Thread.SpinWait(5000);
    }
}</pre></li>
</ol>
<p>A <code>Thread.SpinWait</code> statement is added at the end of the loop to give users some time to cancel the operation.</p>
<ol>
<li value="6">Add a public static <a id="_idIndexMarker587"/>method to <code>PollingExample</code> named <code>CancelWithPolling</code>:<pre>public static void CancelWithPolling()
{
    using CancellationTokenSource tokenSource = new();
    Task.Run(() =&gt; FindSmallXValues(GeneratePoints
        (1000000), tokenSource.Token), tokenSource
            .Token);
    if (Console.ReadKey(true).KeyChar == 'x')
    {
        tokenSource.Cancel();
        Console.WriteLine("Press a key to quit");
    }
}</pre></li>
</ol>
<p>The <a id="_idIndexMarker588"/>preceding method creates the <code>CancellationTokenSource</code> object and passes it to <code>FindSmallXValues</code> and also <code>Task.Run</code>. If you wanted to cancel the <code>Task</code>, instead of breaking out of the loop when <code>IsCancellationRequested</code> becomes <code>true</code>, you would call <code>token.ThrowIfCancellationRequested</code>. This would throw an exception in the <code>Task</code>. The <code>CancelWithPolling</code> method would then require a <code>try</code>/<code>catch</code> block around the <code>Task.Run</code> call. It’s a best practice to use exception handling with all multithreaded code anyway. In this case, you would have two exception handlers: one to handle <code>OperationCanceledException</code> and a second to handle <code>AggregateException</code>.</p>
<p>Additionally, the <code>CancelWithPolling</code> method has code to determine when the user<a id="_idIndexMarker589"/> presses the <em class="italic">X</em> key to cancel the operation.</p>
<ol>
<li value="7">Finally, open <code>Program.cs</code> and add some code to execute the sample:<pre>using CancellationPatterns;
Console.WriteLine("Hello, World! Press a key to start, 
    then press 'x' to cancel.");
Console.ReadKey();
PollingExample.CancelWithPolling();
Console.ReadKey();</pre></li>
<li>Now run<a id="_idIndexMarker590"/> the application, and examine the output:</li>
</ol>
<div><div><img alt="Figure 11.4 – Running the cancellation polling example " height="536" src="img/Figure_11.4_B18852.jpg" width="911"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Running the cancellation polling example</p>
<p>Depending on how long you wait before canceling, you might have a different number of points found <a id="_idIndexMarker591"/>by the process.</p>
<p>In the next section, we will learn how you can register a callback method to handle cancellation requests.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Canceling with callbacks</h2>
<p>Some <a id="_idIndexMarker592"/>code in .NET <a id="_idIndexMarker593"/>supports the registration of a callback method to cancel processing. One class that supports cancellation with callbacks is <code>System.Net.WebClient</code>. In this example, we will use <code>WebClient</code> to start downloading a file. The download will be canceled after three seconds. To ensure the file download is large enough that it has not been completed after three seconds, we will download a large lossless audiobook file <a id="_idIndexMarker594"/>from <strong class="bold">Internet Archive</strong> (https://archive.org/). We will download the first part of the audiobook of <em class="italic">The Odyssey</em> by Homer. This file is 471.1 MB. You can view all of the free downloads for this book at https://archive.org/details/lp_the-odyssey_homer-anthony-quayle. Perform the following steps:</p>
<ol>
<li value="1">Open the <code>CallbackExample</code></li>
<li>Start by adding a method named <code>GetDownloadFileName</code> to build the path where the file will be downloaded. We will download it to the same folder where our assembly is executing:<pre>private static string GetDownloadFileName()
{
    string path = System.Reflection.Assembly
       .GetAssembly(typeof(CallbackExample)).Location;
    string folder = Path.GetDirectoryName(path);
    return Path.Combine(folder, "audio.flac");
}</pre></li>
<li>Next, add an <code>async</code> method named <code>DownloadAudioAsync</code>. This method will handle the file download and cancellation. There are several exception handlers to <a id="_idIndexMarker595"/> catch any type of exception that the <code>DownloadFileTaskAsync</code> method might throw. In turn, all of them throw an <code>OperationCanceledException</code> type to<a id="_idIndexMarker596"/> be handled by the parent method:<pre>private static async Task DownloadAudioAsync
    (CancellationToken token)
{
    const string url = "https://archive.org/download/
        lp_the-odyssey_homer-anthony-quayle/disc1/
            lp_the-odyssey_homer-anthony-quayle
                _disc1side1.flac";
    using WebClient webClient = new();
    token.Register(webClient.CancelAsync);
    try
    {
        await webClient.DownloadFileTaskAsync(url, 
            GetDownloadFileName());
    }
    catch (WebException we)
    {
        if (we.Status == WebExceptionStatus
            .RequestCanceled)
            throw new OperationCanceledException();
    }
    catch (AggregateException ae)
    {
        foreach (Exception ex in ae.InnerExceptions)
        {
            if (ex is WebException exWeb &amp;&amp;
                exWeb.Status == WebExceptionStatus
                    .RequestCanceled)
                throw new OperationCanceled
                    Exception();
        }
    }
    catch (TaskCanceledException)
    {
        throw new OperationCanceledException();
    }
}</pre></li>
<li>Add a <code>using</code> statement <a id="_idIndexMarker597"/>for the <code>WebClient</code> type:<pre>using System.Net;</pre></li>
<li>Now add a <a id="_idIndexMarker598"/> public <code>async</code> method named <code>CancelWithCallback</code>. This method calls <code>DownloadAudioAsync</code>, waits for three seconds, and calls <code>Cancel</code> on the <code>CancellationTokenSource</code> object. Awaiting the task in a <code>try</code> block means we can handle the <code>OperationCanceledException</code> type directly. If you used <code>task.Wait</code> instead, you would have to catch <code>AggregateException</code> and check whether one of the <code>InnerException</code> objects is an <code>OperationCanceledException</code> type:<pre>public static async Task CancelWithCallback()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Starting download");
    var task = DownloadAudioAsync(tokenSource.Token);
    tokenSource.Token.WaitHandle.WaitOne
        (TimeSpan.FromSeconds(3));
    tokenSource.Cancel();
    try
    {
        await task;
    }
    catch (OperationCanceledException ex)
    {
        Console.WriteLine($"Download canceled. 
            Exception: {ex.Message}");
    }
}</pre></li>
</ol>
<p>In this<a id="_idIndexMarker599"/> step, it might be necessary to <a id="_idIndexMarker600"/> adjust the number of seconds in the <code>tokenSource.Token.WaitHandle.WaitOne</code> call. The timing can vary based on your computer’s download speed and processing speed. Try adjusting the value if you do not see a <code>Download canceled</code> message in the console output.</p>
<ol>
<li value="6">Finally, comment out the existing code in <code>Program.cs</code>, and add the following code to <a id="_idIndexMarker601"/> call the <code>CallbackExample</code> class:<pre>using CancellationPatterns;
await CallbackExample.CancelWithCallback();
Console.ReadKey();</pre></li>
<li>Now run the application, and examine the output:</li>
</ol>
<div><div><img alt="Figure 11.5 – Canceling a download with CancellationToken and a callback " height="346" src="img/Figure_11.5_B18852.jpg" width="958"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Canceling a download with CancellationToken and a callback</p>
<p>You can<a id="_idIndexMarker602"/> verify that the download started and did not complete by looking in the folder where your assembly was running. You should see a file named <strong class="bold">audio.flac</strong> with a file size of <strong class="bold">0 KB</strong>. You can safely delete this file as it could cause exceptions if you try to download it again.</p>
<p>Now that we have seen how to cancel a background task with a callback method, let’s wrap up this section by working through<a id="_idIndexMarker603"/> an example with wait handles.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Canceling with wait handles</h2>
<p>In this <a id="_idIndexMarker604"/>section, we will use <code>ManualResetEventSlim</code> to cancel a background task that would not otherwise be responsive to<a id="_idIndexMarker605"/> user input. This object has <code>Set</code> and <code>Reset</code> events to start/resume or pause an operation. When operations have not yet started or have been paused, calling <code>ManualResetEventSlim.Wait</code> will cause the operation to pause on that statement until another thread calls <code>Set</code> to start or resume processing.</p>
<p>This example will iterate over 100,000 integers and output to the console for each even number. This process can be started, paused, resumed, or canceled thanks to the <code>ManualResetEventSlim</code> object and <code>CancellationToken</code>. Let’s try this example in our <a id="_idIndexMarker606"/>project:</p>
<ol>
<li value="1">Start by adding a <code>WaitHandleExample</code> class to the <strong class="bold">CancellationPatterns</strong> project.</li>
<li>Add a private variable named <code>resetEvent</code> to the new class:<pre>private static ManualResetEventSlim resetEvent = 
    new(false);</pre></li>
<li>Add a private static method named <code>ProcessNumbers</code> to the class. This method iterates over the numbers and only continues processing when <code>resetEvent.Wait</code> allows it to proceed:<pre>private static void ProcessNumbers(IEnumerable&lt;int&gt; 
    numbers, CancellationToken token)
{
    foreach (var number in numbers)
    {
        if (token.IsCancellationRequested)
        {
            Console.WriteLine("Cancel requested");
            token.ThrowIfCancellationRequested();
        }
        try
        {
            resetEvent.Wait(token);
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Operation canceled.");
            break;
        }
        if (number % 2 == 0)
            Console.WriteLine($"Found even number: 
                {number}");
        Thread.Sleep(500);
    }
}</pre></li>
<li>Next, add <a id="_idIndexMarker607"/>a public static async method <a id="_idIndexMarker608"/>named <code>CancelWithResetEvent</code> to the class. This method creates the list of numbers to process, calls <code>ProcessNumbers</code> within a <code>Task.Run</code> call, and uses a <code>while</code> loop to listen for user input:<pre>public static async Task CancelWithResetEvent()
{
    using CancellationTokenSource tokenSource = new();
    var numbers = Enumerable.Range(0, 100000);
    _ = Task.Run(() =&gt; ProcessNumbers(numbers, 
        tokenSource.Token), tokenSource.Token);
    Console.WriteLine("Use x to cancel, p to pause, or 
        s to start or resume,");
    Console.WriteLine("Use any other key to quit the 
        program.");
    bool running = true;
    while (running)
    {
        char key = Console.ReadKey(true).KeyChar;
        switch (key)
        {
            case 'x':
                tokenSource.Cancel();
                break;
            case 'p':
                resetEvent.Reset();
                break;
            case 's':
                resetEvent.Set();
                break;
            default:
                running = false;
                break;
        }
        await Task.Delay(100);
    }
}</pre></li>
<li>Finally, update <code>Program.cs</code> to <a id="_idIndexMarker609"/>contain<a id="_idIndexMarker610"/> the following code:<pre>using CancellationPatterns;
await WaitHandleExample.CancelWithResetEvent();
Console.ReadKey();</pre></li>
<li>Run the program to test it. Follow the console prompts to start, pause, resume, and cancel the process:</li>
</ol>
<div><div><img alt="Figure 11.6 – Testing the CancelWithResetEvent method in the console " height="381" src="img/Figure_11.6_B18852.jpg" width="865"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Testing the CancelWithResetEvent method in the console</p>
<p>You should<a id="_idIndexMarker611"/> see in the console output that several <a id="_idIndexMarker612"/>event numbers have been found before the operation is canceled. The amount of processing completed could vary based on your computer’s processors.</p>
<p>In the next section, we will wrap up cancellation by learning how to handle cancellation requests from multiple sources.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Handling multiple cancellation sources</h1>
<p>Background tasks <a id="_idIndexMarker613"/>can leverage <code>CancellationTokenSource</code> to receive cancellation requests from as many sources as necessary. The static <code>CancellationTokenSource.CreateLinkedTokenSource</code> method accepts an array of <code>CancellationToken</code> objects to create a new <code>CancellationTokenSource</code> object that will notify us of cancellation if any of the source tokens receives a request to cancel.</p>
<p>Let’s look at a<a id="_idIndexMarker614"/> quick example of how to implement this in our <strong class="bold">CancellationPatterns</strong> project:</p>
<ol>
<li value="1">First, open the <code>PollingExample</code> class. We are going to create an overload of the <code>CancelWithPolling</code> method that accepts a <code>CancellationTokenSource</code> parameter. The two overloads of <code>CancelWithPolling</code> will look like this:<pre>public static void CancelWithPolling()
{
    using CancellationTokenSource tokenSource = new();
    CancelWithPolling(tokenSource);
}
<strong class="bold">public static void CancelWithPolling</strong>
<strong class="bold">    (CancellationTokenSource tokenSource)</strong>
{
    Task.Run(() =&gt; FindSmallXValues(GeneratePoints
        (1000000), tokenSource.Token), 
            tokenSource.Token);
    if (Console.ReadKey(true).KeyChar == 'x')
    {
        tokenSource.Cancel();
        Console.WriteLine("Press a key to quit");
    }
}</pre></li>
<li>Next, add a new class named <code>MultipleTokensExample</code>.</li>
<li>Create a method named <code>CancelWithMultipleTokens</code> in the <code>MultipleTokensExample</code> class. This method accepts <code>parentToken</code> as a parameter, creates its own <code>tokenSource</code>, and then combines them into a <code>combinedSource</code> object<a id="_idIndexMarker615"/> to pass to the <code>CancelWithPolling</code> method:<pre>public static void CancelWithMultipleTokens
    (CancellationToken parentToken)
{
    using CancellationTokenSource tokenSource = new();
    using CancellationTokenSource combinedSource =  
        CancellationTokenSource.CreateLinked
           TokenSource(parentToken, tokenSource
               .Token);
    PollingExample.CancelWithPolling(combinedSource);
    Thread.Sleep(1000);
    tokenSource.Cancel();
}</pre></li>
</ol>
<p>We’re calling <code>tokenSource.Cancel</code>, but if <code>Cancel</code> is invoked on any of the three <code>CancellationTokenSource</code> objects, the processing in <code>CancellWithPolling</code> will receive a cancellation request.</p>
<ol>
<li value="4">Add some code to <code>Program.cs</code> to call <code>CancelWithMultipleTokens</code>:<pre>using CancellationPatterns;
CancellationTokenSource tokenSource = new();
MultipleTokensExample.CancelWithMultipleTokens
    (tokenSource.Token);
Console.ReadKey();</pre></li>
<li>Run the program, and you should see an output similar to what you saw in the subsection <em class="italic">Canceling with polling</em> of the section <em class="italic">Discovering patterns for thread cancellation</em>.</li>
</ol>
<p>Try <a id="_idIndexMarker616"/>changing which <code>CancellationTokenSource</code> object is used to invoke <code>Cancel</code>. The output should remain the same regardlesss of the source of the cancellation request.</p>
<p>A background <code>Task</code> will also end if you throw an exception within the <code>Task</code>. This has a similar effect of ending the background processing, but <code>TaskStatus</code> will be <code>Faulted</code> instead of <code>Canceled</code>.</p>
<p>This completes our review of cancellation requests from multiple sources and our tour of canceling tasks and threads with C# and .NET. Let’s review what we have learned in this chapter.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>Summary</h1>
<p>In this chapter, we learned a number of new ways to cancel background threads and tasks. It is important to provide your users with a method of canceling long-running tasks or automatically canceling them when users or the operating system closes or suspends your application. </p>
<p>After working through the examples in this chapter, you now understand how to use polling, callbacks, and wait handles to cooperatively cancel background tasks. Additionally, you learned how to handle cancellation requests from more than one source.</p>
<p>In the next chapter, we will look at how .NET developers can unit test code that employs multithreaded constructs.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Questions</h1>
<ol>
<li value="1">Which property of a <code>CancellationToken</code> object indicates whether a cancellation request has been made?</li>
<li>Which data type provides a <code>CancellationToken</code> object?</li>
<li>What exception type is thrown when <code>ThrowIfCancellationRequested</code> is invoked?</li>
<li>What cancellation pattern is used by the <code>WebClient</code> object in .NET?</li>
<li>Which .NET type can pause or resume operations with a <code>CancellationToken</code> object?</li>
<li>Which reset event is used to pause processing?</li>
<li>Which static method in <code>CancellationTokenSource</code> can combine multiple <code>CancellationToken</code> objects into a single source?</li>
</ol>
</div>
</div>
</body></html>