<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor012"/>1</h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor013"/>Fundamentals of Web APIs</h1>
<p>In today’s world, <strong class="bold">web APIs</strong> are the backbone of the web. Millions of people use web APIs every day to purchase commodities, book a flight, get weather information, and more. In this chapter, we will learn about the fundamentals of web APIs. You might be wondering why we will start with the fundamental concepts. The answer is simple – we need to understand the basic concepts of web APIs before we build one.</p>
<p>This chapter introduces a couple of different web API styles, such as a REST-based API, a <strong class="bold">remote procedure call</strong> (<strong class="bold">RPC</strong>)-based API, a GraphQL API, and a real-time API. We will also learn about how to design them. If you would like to start developing a web API, feel free to jump to the next chapter.</p>
<p> In this chapter, we’ll be covering the following topics:</p>
<ul>
<li>What is a web API?</li>
<li>What is a REST API?</li>
<li>Designing a REST-based API</li>
<li>What are RPC and GraphQL APIs?</li>
<li>What is a real-time API?</li>
</ul>
<p>After reading this chapter, you will have a basic understanding of web APIs and be able to pick the right style for your project. Let’s get started!</p>
<h1 id="_idParaDest-16"><a id="_idTextAnchor014"/>What is a web API?</h1>
<p><strong class="bold">API</strong> stands for <strong class="bold">application programming interface</strong>. A web API, as the name suggests, is a <a id="_idIndexMarker000"/>set <a id="_idIndexMarker001"/>of programming interfaces for the web. For example, when you book a flight on a website, the browser makes a request to the airline’s server through a web API to access the airline’s database. The airline’s server then returns the information about the flight to the browser, allowing you to book your flight in it.</p>
<p>APIs have been delivered by organizations for decades. With the appearance of the World Wide Web, people needed a way to communicate between the server and the client.</p>
<p>We can<a id="_idIndexMarker002"/> build web APIs using different technologies, such as Java, Python, Ruby, PHP, .NET, and so on. Also, they have various styles. You might have heard of <a id="_idIndexMarker003"/>terms such as <strong class="bold">SOAP</strong>, <strong class="bold">Web Service</strong>, and <strong class="bold">REST</strong>. They<a id="_idIndexMarker004"/> are all based on<a id="_idIndexMarker005"/> the <strong class="bold">HTTP</strong> protocol but communicate in different ways.</p>
<p>In this book, we consider web APIs as a wider concept than REST. In the digital world, the way machines communicate with each other changes as either the demands or the infrastructure evolves. In the 1990s, people focused on how to improve the internal networks that used the same platforms. TCP/IP came to be the standard for this kind of communication. After a few years, people needed to find a way to optimize communication across multiple platforms. Web Services appeared, and they used the <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>), which<a id="_idIndexMarker006"/> was defined for enterprises, and it ensured that programs built on different platforms could easily exchange data.</p>
<p>However, SOAP XML is quite heavy, which means it requires more bandwidth for its usage. In the<a id="_idIndexMarker007"/> early 2000s, <strong class="bold">Windows Communication Foundation</strong> (<strong class="bold">WCF</strong>) was released by Microsoft. This helped developers manage the complexities of working with SOAP. WCF is RPC-based but still uses SOAP as the underlying protocol. Over time, some old standards, such as SOAP, have been transitioned to REST APIs, which will be discussed in the next section. We will start with REST APIs and then move on to the other styles of web-based APIs, such as gRPC APIs, GraphQL APIs, and Signal<a id="_idTextAnchor015"/>R APIs.</p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>What is a REST API?</h1>
<p><strong class="bold">REST</strong>, also <a id="_idIndexMarker008"/>known as <strong class="bold">Representational State Transfer</strong>, is an architectural <a id="_idIndexMarker009"/>style of web APIs that was created by Roy Fielding in his Ph.D. dissertation <em class="italic">Architectural Styles and the Design of Network-based Software Architectures</em> in 2000. Today, generally speaking, REST APIs are based on HTTP, but actually, Roy Fielding’s paper just outlines the core concepts and constraints for understanding an architectural style, and it does not require any specific protocol for REST-based architecture, such as HTTP. However, since HTTP is the most widely used protocol for web APIs, we will use HTTP as the protocol for REST APIs.</p>
<p>Just keep in mind<a id="_idIndexMarker010"/> that REST is just a style, not a rule. When you build a web API, you do not have to follow the REST style. You can use any other style you like. You can build a web API that works well, but it might not be <em class="italic">REST enough</em>. REST is the recommended style because it helps us establish constraints, which contribute to the design of web APIs. It also helps developers easily integrate with other REST APIs if they follow the same style.</p>
<p>The core concept of REST is the term <em class="italic">representational state transfer</em>. Think about a web system, which is a collection of resources. For example, it might have a resource called <em class="italic">books</em>. The collection of books is a resource. A book is a resource too. When you request the list of the books, you select a link (for example, <a href="http://www.example.com/books">http://www.example.com/books</a>), which will return a JSON string that contains all the books, resulting in the next resource’s representation, such as the link of a specific book (for example, <a href="http://www.example.com/books/1">http://www.example.com/books/1</a>). You can continue to request the book with this link. In this process, the representation state is transferred to the client and rendered for the user.</p>
<p>There are loads of resources that explain REST. If you would like to know more about REST, you can read the following article on Wikipedia: <em class="italic">REST: The Web Framework for Representational State </em><em class="italic">Transfer</em> (<a href="https://en.wikipedia.org/wiki/Representational_state_transfer">https://en.wikipedia.org/wiki/Representational_state_transfer</a>).</p>
<p>Let’s take a look at the constraints of REST, following which we will show you a simple example of REST APIs.</p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>The constraints of REST</h2>
<p>Roy Fielding’s paper <a id="_idIndexMarker011"/>defines the following six constraints for REST APIs:</p>
<ul>
<li><strong class="bold">Client-server</strong>: This <a id="_idIndexMarker012"/>pattern enforces the principle of separation of concerns. The server and the client act independently. The client sends the request and the server responds, following which the client receives and interprets the response. The client does not need to know how the server works, and vice versa.</li>
<li><strong class="bold">Statelessness</strong>: The<a id="_idIndexMarker013"/> server does not maintain any state of the client. The client should provide the necessary information in the request. This stateless protocol is important to scale out the capacity of the server because it does not need to remember the session state of the clients.</li>
<li><strong class="bold">Cacheability</strong>: The<a id="_idIndexMarker014"/> response of the server must implicitly or explicitly contain information about whether the response is cacheable, allowing the client and intermediaries to cache the response. The cache can be performed on the client machine in memory, in browser cache storage, or<a id="_idIndexMarker015"/> in a <strong class="bold">content delivery network</strong> (<strong class="bold">CDN</strong>). It is also important to improve the scalability and performance of web APIs.</li>
<li><strong class="bold">The layered system</strong>: The<a id="_idIndexMarker016"/> client does not know how it is connected to the server. There may be multiple layers between the client and the server. For example, a security layer, a proxy, or a load balancer can be placed between the client and the server without impacting the client or server code.</li>
<li><strong class="bold">Code on demand (optional)</strong>: The<a id="_idIndexMarker017"/> client can request code from the server for client-side use. For example, the web browser can request JavaScript files to perform some tasks.</li>
<li><strong class="bold">Uniform interface</strong>: This<a id="_idIndexMarker018"/> one is essential for a RESTful system. It contains resource identification, resource manipulation through representations, self-descriptive messages, and hypermedia as the engine of the application state. It simplifies and decouples the architecture of the system, which enables each part to evolve independently.</li>
</ul>
<p>If you feel these principles are a little bit distant or theoretical, let’s l<a id="_idTextAnchor019"/>ook at an example.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>A REST API example</h2>
<p>The<a id="_idIndexMarker019"/> website <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a> is a fake REST API that generates fake JSON data. Open the following link in your browser: <a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a>. You will see a JSON string returned:</p>
<pre class="source-code">
[  {
    "userId": 1,
    "id": 1,
    "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
    "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
  },
  {
    "userId": 1,
    "id": 2,
    "title": "qui est esse",
    "body": "est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla"
  },
...
]</pre>
<p>From the preceding request, we can get the resource for the collection of the posts.</p>
<p>Now, we can request a specific post by its ID. For example, we can request the post with ID <code>1</code> using the following URL: <a href="https://jsonplaceholder.typicode.com/posts/1">https://jsonplaceholder.typicode.com/posts/1</a>. The response is as follows:</p>
<pre class="source-code">
{  "userId": 1,
  "id": 1,
  "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
  "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
}</pre>
<p>And that’s it! The<a id="_idIndexMarker020"/> URLs we used in the preceding examples are the identifiers of the resources. The responses (the JSON strings) are the representations of the resources. A resource is manipulated through hypertext representations that are transferred in messages between clients and servers.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Some documents use URI. A <code>http</code>, <code>https</code> or <code>ftp</code>. Nowadays, the term <em class="italic">URL</em> remains widely used, so, we will use that in this book. However, we should know they have different scopes. URI is the superset of URL.</p>
<p>To get a post resource, we send a <code>GET</code> request. There are some other methods for manipulating resources, such as <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>, as shown here:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">HTTP method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">URL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Operation</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p>Read</p>
</td>
<td class="No-Table-Style">
<p>Read the collection of the posts</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/1</code></p>
</td>
<td class="No-Table-Style">
<p>Read</p>
</td>
<td class="No-Table-Style">
<p>Read a post by its ID</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/1/comments</code></p>
</td>
<td class="No-Table-Style">
<p>Read</p>
</td>
<td class="No-Table-Style">
<p>Read the comments of the post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>POST</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p>Create</p>
</td>
<td class="No-Table-Style">
<p>Create a new post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/1</code></p>
</td>
<td class="No-Table-Style">
<p>Update</p>
</td>
<td class="No-Table-Style">
<p>Update a post by its ID</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PATCH</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/1</code></p>
</td>
<td class="No-Table-Style">
<p>Update (partial)</p>
</td>
<td class="No-Table-Style">
<p>Update part of a post by its ID</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>DELETE</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/1</code></p>
</td>
<td class="No-Table-Style">
<p>Delete</p>
</td>
<td class="No-Table-Style">
<p>Delete a post by its ID</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – HTTP methods and URLs for manipulating resources</p>
<p>There are other <a id="_idIndexMarker023"/>methods that are less frequently used, such as <code>HEAD</code>, <code>OPTIONS</code>, and <code>TRACE</code>.</p>
<p>As we can see, the HTTP <a id="_idIndexMarker024"/>methods are mapped to the <strong class="bold">create, update, read, and delete</strong> (<strong class="bold">CURD</strong>) operations. But was it always this way<a id="_idTextAnchor021"/>?</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor022"/>Is my web API RESTful?</h2>
<p>As already mentioned, REST is not a rule or a specification. There is no <em class="italic">official</em> standard for REST APIs. Contrary to popular opinion, it does not require JSON. Furthermore, it does not require the use of CRUD patterns. But REST implementation does make use of standards, such as HTTP, URL, JSON, XML, and so on. People apply HTTP methods and JSON to implement REST, but they may not intentionally apply the constraints as originally described in Fielding’s paper. This leads people to disagree on whether their APIs are RESTful or not. Many developers describe their APIs as RESTful, even though these APIs do not satisfy all of the constraints described in Fielding’s paper.</p>
<p>Frankly, it is not beneficial to argue whether a web API is <em class="italic">REST enough</em> or not. The goal is to make something work, rather than wasting time on a discussion of this kind of problem. Not everyone has read the original paper. Technology also evolves rapidly. There is a Chinese saying: <em class="italic">It doesn’t matter whether it is a white cat or a black cat; as long as it catches mice, it is a </em><em class="italic">good cat.</em></p>
<p>However, it would be ideal if we follow conventions when we start a greenfield project. Generally, a REST-based API is defined with the following aspects:</p>
<ul>
<li>A base URL, which is the root of the API, such as <code>http://api.example.com</code>.</li>
<li>Semantics of HTTP methods, such as <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and so on.</li>
<li>A media type, which defines state transition data elements, such as <code>application/json</code>, <code>application/xml</code>, and so on.</li>
</ul>
<p>In this book, we will try to follow these conventions when we develop the REST APIs with ASP.NET Core.</p>
<p>Now that we have had an overview of a REST API, let’s see how to design one following the conventions<a id="_idTextAnchor023"/>.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor024"/>Designing a REST-based API</h1>
<p>To build a<a id="_idIndexMarker025"/> REST-based API, there are many steps to take before we write code. The development team needs to communicate with stakeholders and analyze the requirements. Then, they need to write user stories (or job stories) to define the desired outcomes. This requires the insights of domain experts or subject matter experts. We will not cover this part in this book. Instead, next, we will focus on the API design, which is closer to what developers do.</p>
<p>In the past few years, the concept of <strong class="bold">API-first</strong> has gained more traction. The API-first approach means that the APIs are treated as first-class citizens for your project. This creates a contract for how the API is supposed to behave before any code is written. In this way, the development teams can work in parallel because the contract will be established first. Developers do not have to wait for the API to be released before integrating with frontend or mobile apps. They can mock and test the APIs based on the contract. Using tools such<a id="_idIndexMarker026"/> as <strong class="bold">Swagger</strong>, the process of building APIs can be automated, such as API documentation, mock APIs, SDKs, and so on. Automation can significantly speed up the development of APIs and applications, which helps to increase the speed to market.</p>
<p>Here are some steps <a id="_idIndexMarker027"/>we can follow to design a REST-based API:</p>
<ol>
<li>Identify the resources.</li>
<li>Define the relationships between resources.</li>
<li>Identify operation events.</li>
<li>Design the URL paths for resources.</li>
<li>Map API operations to HTTP methods.</li>
<li>Assign response codes.</li>
<li>Document the API.</li>
</ol>
<p>If you are familiar with the preceding steps, you can skip them. However, if you are not, read the following sections.</p>
<p>A popular <a id="_idIndexMarker028"/>API description format is <strong class="bold">OpenAPI Specification</strong> (<strong class="bold">OAS</strong>). We can use it to describe API modeling and other details of an API. We do not need to include the implementation details at this stage, because we just want to make a contract. SwaggerHub (<a href="https://app.swaggerhub.com/home">https://app.swaggerhub.com/home</a>) is a tool we can <a id="_idIndexMarker029"/>use to design a<a id="_idTextAnchor025"/>n API.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor026"/>Identifying the resources</h2>
<p>REST-based APIs <a id="_idIndexMarker030"/>center on resources. A resource is a collection of data, such as a collection of posts or a collection of users. A resource is identified by a URL. The client requests a resource using the URL, and the server responds with a representation of the resource. The representation of the resource is sent in the hypertext format, which can be interpreted by the widest possible range of clients.</p>
<p>It is important to identify the scope of the domain and the relationships between the resources. For example, if you are building a blog system, you may have a collection of posts, and each post has a collection of comments. The scope of an API may evolve as time goes by. More resources may be added to the current domain, or some resources will be removed. Also, relationships may change.</p>
<p>Let’s start small. We<a id="_idIndexMarker031"/> can use the blog system as an example. After the requirement analysis, we can identify the following resources:</p>
<ul>
<li>Posts</li>
<li>Categories</li>
<li>Comments</li>
<li>Users</li>
<li>Tags</li>
</ul>
<p>You may want to include some properties of each resource in this step. For example, a post has a title, a body, and a published datetime. A comment has a body, a publish datetime. A user has a name and an email. You may find more properties during deve<a id="_idTextAnchor027"/>lopment.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor028"/>Defining the relationships between resources</h2>
<p>Once the <a id="_idIndexMarker032"/>resources are identified, we can define the relationships between them. For example, a post has a collection of comments. A comment has a post. A user has a collection of posts.</p>
<p>The relationship is defined by how these resources relate to each other. Sometimes, these relationships exist in the database as well, but sometimes, they are specific to the REST resources only.</p>
<p>There are some terms we can use to describe the relationships:</p>
<ul>
<li><strong class="bold">Independent resource</strong>: This <a id="_idIndexMarker033"/>resource can exist independently. It does not require another resource to exist. An independent resource can reference other independent or dependent resources. For example, a post is an independent resource, and it can reference its author. The authors resource is also an independent resource.</li>
<li><strong class="bold">Dependent resource</strong>: This resource requires another resource to exist. It can still <a id="_idIndexMarker034"/>reference other independent or dependent resources, but it cannot exist without the existence of the parent resource. For example, a comment requires a post as its parent resource; otherwise, it cannot exist. A comment can reference its author, which is an independent resource.</li>
<li><code>Id</code> property, which can uniquely identify itself.</li>
<li><code>PostId</code> property, which references a post.</li>
</ul>
<p>There are three <a id="_idIndexMarker037"/>relationship types that these resources can have:</p>
<ul>
<li><strong class="bold">One-to-many</strong>: This is <a id="_idIndexMarker038"/>when a resource has many related resources. For example, a user has many posts, but a post has only one author. This is also called the <em class="italic">parent-child (children)</em> relationship, which is the most common pattern for relationships we can see in the REST-based API world.</li>
<li><strong class="bold">One-to-one</strong>: This is<a id="_idIndexMarker039"/> when a resource has one related resource. For example, a post has a single author, and one house has only one address. The one-to-one relationship is a special case of the one-to-many relationship.</li>
<li><strong class="bold">Many-to-many</strong>: This<a id="_idIndexMarker040"/> is when a resource has many related resources and vice versa. For example, a blog has many tags, and a tag has many blogs. A movie can have many genres, and a genre can have many movies. In many systems, a user can have many roles, and a role can<a id="_idTextAnchor029"/> have many users.</li>
</ul>
<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>Identifying operations</h2>
<p>Next, we <a id="_idIndexMarker041"/>can think about what operations are needed for each resource. These operations may come from user stories that are defined beforehand. Generally, each resource has its CRUD operations. Note that the operations may include more beyond CRUD. For example, a post can be published, or it can be unpublished. A comment can be approved, or it can be rejected. During this process, we may need to create a new resource or property to reflect the operation.</p>
<p>It is important to consider the scope of the domain. CRUD operations are easy to understand, but for some complicated relationships, we may need help from domain experts.</p>
<p>When we work on these operations, we need to include important input and output details. We will use them in the next steps. However, it is not necessary to include all the details of each resource. We have enough time later to capture the complete design.</p>
<p>For the example of the blog system, we can identify these operations for the <code>Post</code> resource (including but not limited to the following):</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Operation name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Resource(s)</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Input</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Output</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>createPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post, category, </code><code>user, tag</code></p>
</td>
<td class="No-Table-Style">
<p>Post detail</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Create a new post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post</code></p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>List all posts</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByCategory()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post </code><code>and category</code></p>
</td>
<td class="No-Table-Style">
<p>Category ID</p>
</td>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>List posts by category</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByTag()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post </code><code>and tag</code></p>
</td>
<td class="No-Table-Style">
<p>Tag or Tag ID</p>
</td>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>List posts by tag</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>searchPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post</code></p>
</td>
<td class="No-Table-Style">
<p>Search keyword</p>
</td>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>Search for Posts by title, author, and content</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>viewPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post, category, </code><code>and user</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style">
<p>Post detail</p>
</td>
<td class="No-Table-Style">
<p>View a post detail</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>deletePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Delete a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>updatePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post </code><code>and category</code></p>
</td>
<td class="No-Table-Style">
<p>Post detail</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Update a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>publishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Publish a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>unpublishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Unpublish a post</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.2 – Operations for the Post resource</p>
<p>For some<a id="_idIndexMarker042"/> operations, such as <code>createPost</code> and <code>deletePost</code>, the output is the results of the operation. This can be represented with the HTTP status code. We will discuss this later.</p>
<p>We can list more operations for other resources as well.<a id="_idTextAnchor031"/></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor032"/>Designing the URL paths for resources</h2>
<p>The next<a id="_idIndexMarker043"/> step is to design the URL paths for<a id="_idIndexMarker044"/> each resource. The clients use URLs to access the resources. Even though REST is not a standard, there are some guidelines or conventions for designing URL path<a id="_idTextAnchor033"/>s.</p>
<p>Using nouns instead of verbs</p>
<p>The<a id="_idIndexMarker045"/> operation events we identified in the previous step are some actions, such as <code>Create</code>, <code>List</code>, <code>View</code>, <code>Delete</code>, and so on. However, the URL paths are not usually presented by verbs. Because HTTP methods such as <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> are already verbs, it is not <a id="_idIndexMarker046"/>necessary to include verbs in the URL paths. Instead, we should use nouns to represent the resources – for example, <code>/po<a id="_idTextAnchor034"/>sts</code>.</p>
<h3>Using plural nouns to represent collections</h3>
<p>If a <a id="_idIndexMarker047"/>resource is a collection, we should use plural nouns to represent the resource. For example, <code>/posts</code> is the URL path for the collection of posts. To get a single post by its ID, we can use <code>/posts/{pos<a id="_idTextAnchor035"/>tId}</code>.</p>
<h3>Using logical nesting to represent relationships</h3>
<p>For the<a id="_idIndexMarker048"/> resources that have a relationship, normally, the child resource (i.e., the dependent resource) should be nested under the parent resource, and the path should include the parent identifier. However, this does not reflect the database structure. For example, a post can have a collection of comments; the URL looks like <code>/posts/{postId}/comments</code>. It clearly shows that the comments are related to the post.</p>
<p>However, if the relationships are too deep or complicated, the nesting URL path can be too long. In this case, we can rethink how to better represent those resources. For example, if we want to retrieve an author’s information from one comment, we could use <code>/posts/{postId}/comments/{commentId}/author</code>. But this goes too far. Instead, if we know the <code>UserId</code> of the author, we can use <code>/users/{userId}</code>. Avoid using deep nesting in URL paths because it makes an API more complicated and not rea<a id="_idTextAnchor036"/>dable.</p>
<h3>Allowing filtering, sorting, and pagination</h3>
<p>Returning<a id="_idIndexMarker049"/> all records simultaneously is not a <a id="_idIndexMarker050"/>good idea. We can use filtering, sorting, and pagination to return a subset of the <a id="_idIndexMarker051"/>records that a client needs. These operations can improve the performance of the APIs and provide a better user experience.</p>
<p>For example, if <a id="_idIndexMarker052"/>we want to search a list of posts <a id="_idIndexMarker053"/>for a specific keyword, we <a id="_idIndexMarker054"/>can use a query parameter, such as <code>/posts?search=keyword</code>. If we want to sort posts by the date, we can use <code>/posts?sort=date</code>. To get the second page of the posts, we can use <code>/posts?page=2</code>. These query parameters can be combined with<a id="_idTextAnchor037"/> each other.</p>
<h3>What if I cannot find a proper verb in HTTP methods for an operation?</h3>
<p>Generally, HTTP methods can represent CRUD operations. However, in the real world, there are many more complexities! For example, besides the basic CRUD operations, there are other operations, such as publishing or unpublishing a post. So, what HTTP methods should we use?</p>
<p>This is where things can get tricky. This subject is open to debate, but remember that we are not arguing whether an API is <em class="italic">RESTful</em> enough. We just want to make it work.</p>
<p>There are different approaches for these scenarios:</p>
<ul>
<li>One possible solution could be treating such operations like a sub-resource. So, you can use <code>/posts/{postId}/publish</code> to publish a post. GitHub uses the following URL to star a gist: <code>/gists/{gist_id}/star</code>. For more information, check out <a href="https://docs.github.com/en/rest/gists/gists#star-a-gist">https://docs.github.com/en/rest/gists/gists#star-a-gist</a>.</li>
<li>The post should have an <code>IsPublished</code> field to indicate whether it is published. So, actually, the <code>publish</code> action is an update action, which updates the <code>IsPublished</code> field only. Then, you can treat it the same as the <code>updatePost()</code> operation.</li>
</ul>
<p>Here are some resource URLs for the blog system:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Operation name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">URL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Input</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Output</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>createPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p>Post detail</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Create a new post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>List all posts</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByCategory()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?categoryId={categoryId}</code></p>
</td>
<td class="No-Table-Style">
<p>Category ID</p>
</td>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>List posts by category</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByTag()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?tag={tagId}</code></p>
</td>
<td class="No-Table-Style">
<p>Tag or Tag ID</p>
</td>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>List posts by tag</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>searchPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?search={keyword}</code></p>
</td>
<td class="No-Table-Style">
<p>Search keyword</p>
</td>
<td class="No-Table-Style">
<p>A list of posts</p>
</td>
<td class="No-Table-Style">
<p>Search for posts by title, author, and content</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>viewPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style">
<p>Post detail</p>
</td>
<td class="No-Table-Style">
<p>View a post detail</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>deletePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Delete a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>updatePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p>Post detail</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Update a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>publishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}/publish</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Publish a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>unpublishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}/unpublish</code></p>
</td>
<td class="No-Table-Style">
<p>Post ID</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Unpublish a post</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.3 – URLs for the Post resource</p>
<p>Some URLs are identical, such as <code>deletePost()</code> and <code>updatePost()</code>, because we will use HTTP methods to differentiate those operations.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor038"/>Mapping API operations to HTTP methods</h2>
<p>Next, we<a id="_idIndexMarker055"/> need to identify which HTTP method is appropriate for each operation. As we mentioned before, there are some common HTTP methods for CRUD operations. For example, when we request a resource, we should use the <code>GET</code> method. When we create a new resource, we should use the <code>POST</code> method.</p>
<p>When we map the API operations to HTTP methods, we also need to consider the safety of the operations and HTTP methods. There are three types of safety for HTTP operations:</p>
<ul>
<li><code>GET</code> request to <code>/posts/{postId}</code>, it will return the same result, no matter how many times the same request is sent. For some cases, the resource might be updated by a third party, and the next <code>GET</code> request will return the updated result. But this was not caused by the client, so it is important to understand whether the state change is caused by the client who sent the request.</li>
<li><code>DELETE</code> request to <code>/posts/{postId}</code> to delete it. If the request is a success, we will get a <code>200 OK</code> or a <code>204 No Content</code> response. If we send the same request to <code>/posts/{postId}</code> again, it may return a <code>404 Not found</code> response because the<a id="_idIndexMarker058"/> resource was already deleted, but it will not cause any other side effects. If an operation is idempotent and the client knows whether the previous request failed, it is safe to reissue the request without any side effects.</li>
<li><code>POST</code> request to <code>/posts</code> to create a new post. If we send the same <code>POST</code> request again, it will create another new post with the same title and content, and so on.</li>
</ul>
<p>All safe <a id="_idIndexMarker060"/>methods are also idempotent, but not all idempotent methods are safe. The following table lists the safety of each HTTP method:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">HTTP method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Safe</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Idempotent</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Common operations</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Read, list, view, search, show, and retrieve</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HEAD</code></p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p><code>HEAD</code> is used to check the availability of a resource without actually downloading it.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>OPTIONS</code></p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p><code>OPTIONS</code> is used to retrieve the available HTTP methods for a given resource.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>TRACE</code></p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p><code>TRACE</code> is used to get diagnostic information about a request/response cycle.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Update and replace</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>DELETE</code></p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Delete, remove, and clear</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>POST</code></p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
<td class="No-Table-Style">
<p>Create, add, and update</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PATCH</code></p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
<td class="No-Table-Style">
<p>Update</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.4 – Safety of HTTP methods</p>
<p>The <a id="_idIndexMarker061"/>following table shows how operations are mapped to HTTP methods:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table005">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Operation name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">URL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">HTTP method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>createPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p><code>POST</code></p>
</td>
<td class="No-Table-Style">
<p>Create a new post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p>List all posts</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByCategory()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?categoryId={categoryId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p>List posts by category</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByTag()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?tag={tagId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p>List posts by tag</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>searchPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?search={keyword}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p>Search for posts by title, author, and content</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>viewPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p>View a post detail</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>deletePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>DELETE</code></p>
</td>
<td class="No-Table-Style">
<p>Delete a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>updatePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p>Update a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>publishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}/publish</code></p>
</td>
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p>Publish a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>unpublishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}/unpublish</code></p>
</td>
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p>Unpublish a post</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.5 – Mapping HTTP methods for the Post resource</p>
<p>You may have<a id="_idIndexMarker062"/> seen some other cases, such as using <code>POST</code> to update a resource. That works, but it does not follow the HTTP standard. Generally speaking, we can state the following:</p>
<ul>
<li><code>GET</code> is used to read resources.</li>
<li><code>POST</code> is used to create child resources with a server-defined URL, such as <code>/posts</code>.</li>
<li><code>PUT</code> is used to create or replace the resource with a client-defined URL, such as <code>/posts/{postId}</code>.. In many cases, <code>PUT </code>can also be used to update a resource.</li>
<li><code>PATCH</code> is used to update parts of the resource with a client-defined URL, such as <code>/posts/{postId}</code>.<a id="_idTextAnchor039"/></li>
</ul>
<h2 id="_idParaDest-27"><a id="_idTextAnchor040"/>Assigning response codes</h2>
<p>It is time <a id="_idIndexMarker063"/>to assign the HTTP response codes for <a id="_idIndexMarker064"/>the operations. There are some main response code categories:</p>
<ul>
<li><code>2xx</code><strong class="bold"> codes – success</strong>: The action requested by the client was received, understood, and accepted.</li>
<li><code>3xx</code><strong class="bold"> codes – redirection</strong>: The client must take additional action to complete the request. It is often used to indicate that the client should be redirected to a new location.</li>
<li><code>4xx</code><strong class="bold"> code – client errors</strong>: The operation was not successful, but the client can try again.</li>
<li><code>5xx</code><strong class="bold"> codes – server errors</strong>: The server has encountered an error or is incapable of performing the request. The client can retry in the future.</li>
</ul>
<p>A common<a id="_idIndexMarker065"/> issue is that some developers invent their own response codes. For example, if we create a new post, we expect the server to return a <code>201 Created</code> response code. Some developers may use <code>200 OK</code> and include a status code in the response body. This is not a good idea. There are many layers between the server and the client. Using your own codes will probably cause problems for these middleware components. Make sure to use the right code for the right reason. Here are some common response codes:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table006">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">HTTP </strong><strong class="bold">response code</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>200 OK</code></p>
</td>
<td class="No-Table-Style">
<p>The standard response for successful HTTP requests.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>201 Created</code></p>
</td>
<td class="No-Table-Style">
<p>The request has been fulfilled, resulting in a new resource being created.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>202 Accepted</code></p>
</td>
<td class="No-Table-Style">
<p>The request has been accepted for processing, but processing has not been completed.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>204 </code><code>No Content</code></p>
</td>
<td class="No-Table-Style">
<p>The server has successfully processed the request but does not return any content. This is common for delete operations.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>400 </code><code>Bad Request</code></p>
</td>
<td class="No-Table-Style">
<p>The server cannot understand or process the request due to a client error, such as malformed syntax, a request size too large, or invalid input. The client should not repeat the request without modifications.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>401 Unauthorized</code></p>
</td>
<td class="No-Table-Style">
<p>The request requires user authentication.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>403 Forbidden</code></p>
</td>
<td class="No-Table-Style">
<p>The server understood the request but is refusing action. This may be due to the fact that the client does not have the necessary permissions or is attempting a prohibited action.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>404 </code><code>Not Found</code></p>
</td>
<td class="No-Table-Style">
<p>The requested resource could not be found.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>500 Internal </code><code>Server Error</code></p>
</td>
<td class="No-Table-Style">
<p>A generic error message. The server encountered an unexpected condition, so it cannot process the request, and no more specific messages are suitable at this time.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>503 </code><code>Service Unavailable</code></p>
</td>
<td class="No-Table-Style">
<p>The server is currently unable to handle the request due to temporary overloading or maintenance of the server. The response should contain a <code>Retry-After</code> header if possible so that the client can retry after the estimated time,</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.6 – Common HTTP response codes</p>
<p>Here is<a id="_idIndexMarker066"/> the table that <a id="_idIndexMarker067"/>shows the response codes for each operation:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table007">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Operation name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">URL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">HTTP method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Response</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>createPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p><code>POST</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post, 201</code></p>
</td>
<td class="No-Table-Style">
<p>Create a new post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post[], 200</code></p>
</td>
<td class="No-Table-Style">
<p>List all posts</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByCategory()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?categoryId={categoryId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post[], 200</code></p>
</td>
<td class="No-Table-Style">
<p>List posts by category</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>listPostsByTag()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?tag={tagId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post[], 200</code></p>
</td>
<td class="No-Table-Style">
<p>List posts by tag</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>searchPosts()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts?search={keyword}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post[], 200</code></p>
</td>
<td class="No-Table-Style">
<p>Search for posts by title, author, and content</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>viewPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p><code>Post, 200</code></p>
</td>
<td class="No-Table-Style">
<p>View a post detail</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>deletePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>DELETE</code></p>
</td>
<td class="No-Table-Style">
<p><code>204, 404</code></p>
</td>
<td class="No-Table-Style">
<p>Delete a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>updatePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p><code>200</code></p>
</td>
<td class="No-Table-Style">
<p>Update a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>publishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}/publish</code></p>
</td>
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p><code>200</code></p>
</td>
<td class="No-Table-Style">
<p>Publish a post</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>unpublishPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}/unpublish</code></p>
</td>
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p><code>200</code></p>
</td>
<td class="No-Table-Style">
<p>Unpublish a post</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor041"/>Table 1.7 – Response codes for the Post resource</p>
<p>It is <a id="_idIndexMarker068"/>essential to <a id="_idIndexMarker069"/>utilize the correct response code in order to prevent any misunderstandings. This will ensure that all communication is clear and concise, thus avoiding any potential confusion.</p>
<h3>What if I want to create my own status codes?</h3>
<p>Technically, you<a id="_idIndexMarker070"/> can create your own status codes, but in practice, please stick as closely to the standards as possible. If you invent your own status codes, that would be risky. Your users might be in trouble consuming your APIs because they do not know your status codes. You should think about what the benefits are to have your own status  codes. The convention is to respect the HTTP status codes defined in RFC. Before you create your own status codes, make sure you check the list of HTTP status codes first. Do not create your own status code unless you have strong reasons. You can find more information here: <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>.</p>
<p>However, there might be some special situations where you want to indicate a more specific status in the response. For example, you might have an API that can process a task, but it might fail for different reasons. You might want to indicate a more detailed message in the response to let your users know what happened, rather than returning a common <code>4xx</code> code. You should think about the business logic carefully and differentiate between HTTP status codes and business status codes. If you cannot find a proper code in the HTTP status codes, and you do want to show a business-related status in the response, you can choose the HTTP status code to indicate the category of the response, and then attach a response body that contains your business status code. For example, you can return a response as shown here:</p>
<pre class="source-code">
400 Bad Request{ "error_code": 1, "message": "The post is locked and cannot be updated."}</pre>
<p>So, the HTTP status <a id="_idIndexMarker071"/>code represents the common status of the operation, and in the response body, you can include some information that is specific to your system. We will discuss how to handle errors using the <code>Problem Details</code> object in <a href="B18971_16.xhtml#_idTextAnchor671"><em class="italic">Chapter 16</em></a>.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor042"/>Documenting the API</h2>
<p>OpenAPI is a<a id="_idIndexMarker072"/> popular REST API specification. It is a<a id="_idIndexMarker073"/> programming language-agnostic interface description for REST APIs, allowing both humans and computers to discover and understand the capabilities of a service without access to source code. Similar to an interface, it describes the inputs and outputs of an API, as well as how they should be transmitted. It is also known as the Swagger specification.</p>
<p class="callout-heading">Swagger versus OpenAPI</p>
<p class="callout">Sometimes, <em class="italic">Swagger</em> and <em class="italic">OpenAPI</em> are used interchangeably. The Swagger project was <a id="_idIndexMarker074"/>developed in early 2010s to define a simple contract for an API that contains everything needed to produce or consume an API. It was donated to the OpenAPI initiative in 2015. So, OpenAPI refers to the API specification, and Swagger refers to the open-source and commercial projects from SmartBear, which work with the OpenAPI specification. In short, OpenAPI is a specification, and Swagger is tooling that uses the OpenAPI specification. Swagger UI is also one of the Swagger tools. At the time of writing, the latest version of OpenAPI was 3.1.0.</p>
<p>We can use SwaggerHub to design an API based on the previous steps. Here is an example, which defines a simple API for a blog system:</p>
<pre class="source-code">
openapi: 3.0.0servers:
  - description: SwaggerHub API Auto Mocking
    url: https://virtserver.swaggerhub.com/yanxiaodi/MyBlog/1.0.0
info:
  description: This is a simple API
  version: '1.0.0'
  title: Sample Blog System API
  contact:
    email: you@your-company.com
  license:
    name: Apache 2.0
    url: 'http://www.apache.org/licenses/LICENSE-2.0.html'
tags:
  - name: admins
    description: Secured Admin-only calls
  - name: developers
    description: Operations available to regular developers
paths:
  /posts:
    get:
      tags:
        - developers
      summary: searches posts
      operationId: searchPost
      description: |
        By passing in the appropriate options, you can search for
        available blogs in the system
      parameters:
        - in: query
          name: searchString
          description: pass an optional search string for looking up post
          required: false
          schema:
            type: string
        - in: query
          name: skip
          description: number of records to skip for pagination
          schema:
            type: integer
            format: int32
            minimum: 0
        - in: query
          name: limit
          description: maximum number of records to return
          schema:
            type: integer
            format: int32
            minimum: 0
            maximum: 50
      responses:
        '200':
          description: search results matching criteria
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Post'
        '400':
          description: bad input parameter</pre>
<p>The other file of this file has been omitted.</p>
<p>The preceding <a id="_idIndexMarker075"/>API documentation is a YAML file, which defines two models (resources) – <code>Post</code> and <code>Category</code> – and two operations – <code>GET</code> for searching posts and <code>POST</code> for creating a new post. For each operation, there are details about the input and output, including the expected response codes.</p>
<p>After the API design is done, we can share the API documentation with other developers for integrations, as shown here:</p>
<div><div><img alt="Figure 1.1 – The SwaggerHub UI" src="img/B18971_01_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The SwaggerHub UI</p>
<p>Note that <a id="_idIndexMarker076"/>you might need to add more properties, based on your user stories and domains, before you share the API documentation with other teams. The API contract should be quite stable; otherwise, it will impact the consumers.</p>
<p>We have explained how to design a REST API. If you would like to learn how to start developing with ASP.NET Core, you can move on to <a href="B18971_02.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>.</p>
<p>REST API is one of the most popular API styles. In the next section, we will introduce other API styles, such as RPC APIs, GraphQL APIs, and real-tim<a id="_idTextAnchor043"/>e APIs.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor044"/>RPC and GraphQL APIs</h1>
<p>While REST-based APIs are widely used in many scenarios today, it is not the only style of web API. For some scenarios, RPC-based APIs or GraphQL APIs may be better suited. It is important to understand the advantages and disadvantages of each style of API so that you can choose the right styles for your sce<a id="_idTextAnchor045"/>narios.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor046"/>What is an RPC-based API?</h2>
<p>RPC has <a id="_idIndexMarker077"/>existed for many years. It is the earliest, simplest form of web interaction. It is like a local call in some other languages, but it executes over a network. The client is given a list of available methods. Each method takes pre-defined, typed, and ordered parameters, returning a structured response result. So, the client can run on a different machine or in a different process but still work with the server, such as in the same application.</p>
<p>In this way, the client is tightly coupled to the server. If the server changes these methods or any parameters, the client will be affected. Developers must update the code of the client to match the new server methods. This can be a disadvantage of RPC-based APIs, but it can offer better performance.</p>
<p>The remote procedures are defined <a id="_idIndexMarker078"/>with the <strong class="bold">interface definition language</strong> (<strong class="bold">IDL</strong>). The IDL defines the methods and parameters of the remote procedure. Normally, some code generators can generate the client and server stubs based on the IDL. The code is strongly typed, which provides better type safety and error handling.</p>
<p>To implement an RPC-based API, there are some specifications for different languages. For example,  WCF was a popular framework for RPC a couple of years ago. Some other popular frameworks include XML-RPC, SOAP PRC, JSON-RPC, and gRPC.</p>
<p>Because RPC is like a local method call, you often see verbs in the method names. Unlike REST, RPC supports various operations beyond CRUD. Here is an example of a JSON-RPC request and response:</p>
<p>Request:</p>
<pre class="source-code">
POST https://rpc.example.com/calculator-service HTTP/1.1Content-Type: application/json
Content-Length: ...Accept: application/json
{"jsonrpc": "2.0", "method": "subtract", "params": [42, 23], "id": 1}</pre>
<p>Response:</p>
<pre class="source-code">
{ "jsonrpc": "2.0", "result": 19, "id": 3 }</pre> <p>One of the <a id="_idIndexMarker079"/>most popular RPC frameworks is gRPC, which we will discuss in the nex<a id="_idTextAnchor047"/>t section.</p>
<h3>What is gRPC?</h3>
<p>One of <a id="_idIndexMarker080"/>the<a id="_idIndexMarker081"/> most popular RPC frameworks is gRPC. It is a high-performance, open-source modern RPC framework for building network services and distributed applications. gRPC was initially created by Google, which used a RPC framework called Stubby. In March 2015, Google decided to make it open-source, resulting in gRPC, which is now used in many organizations outside of Google.</p>
<p>gRPC has some <a id="_idIndexMarker082"/>awesome features, such as the following:</p>
<ul>
<li><strong class="bold">Interoperability</strong>: gRPC uses a <strong class="bold">Protocol Buffer</strong> (<strong class="bold">protobuf</strong>) file to declare services and messages, which <a id="_idIndexMarker083"/>enables gRPC to be completely language- and platform-agnostic. You can find gRPC tools and libraries for all major programming languages and platforms.</li>
<li><code>protobuf</code> is a binary format, which has a smaller size and faster performance than JSON. It is not readable by humans, but it is readable by computers. HTTP/2 also supports multiplexing requests over a single connection. It needs fewer resources, even in slower networks.</li>
<li><strong class="bold">Streaming</strong>: gRPC is based on the HTTP/2 protocol, which makes it support bidirectional streaming.</li>
<li><code>.proto</code>) to describe services with input and output. Then, they can use the <code>.proto</code> files to generate stubs for different languages or platforms. It is similar to the OpenAPI specification. Teams can focus on<a id="_idIndexMarker084"/> business logic and work on the same service in parallel.</li>
<li><strong class="bold">Security</strong>: gRPC is designed to be secure. HTTP/2 is built on top of <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) end-to-end <a id="_idIndexMarker085"/>encrypted connection. It also supports client certificate authentication.</li>
</ul>
<p>With these <a id="_idIndexMarker086"/>benefits, gRPC is a good choice for microservices-style architecture. It can efficiently connect services in and across data centers, even across load balancers. It is applicable in the last mile of distributed systems because service-to-service communication needs low latency and high performance. Also, the polyglot systems may have multiple languages or platforms, and gRPC can support different languages and platforms.</p>
<p>Here is an example of a gRPC <code>.</code><code>proto</code> file:</p>
<pre class="source-code">
syntax = "proto3";option csharp_namespace = "GrpcGreeter";
package greet;
service Greeter {
  // Sends a greeting message.
  rpc SayHello (HelloRequest) returns (HelloReply);
}
// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}
// The response message containing the greeting.
message HelloReply {
  string message = 1;
}</pre>
<p>ASP.NET Core <a id="_idIndexMarker087"/>provides great support for gRPC. With the <code>.proto</code> file, the .NET types for services, clients, and messages can be automatically generated in a .NET project. We will learn how to develop the gRPC service in <a href="B18971_11.xhtml#_idTextAnchor438"><em class="italic">Chapter 11</em></a>.</p>
<p>However, gRPC<a id="_idIndexMarker088"/> is not a silver bullet. There are several factors we need to consider before we choose gRPC:</p>
<ul>
<li><strong class="bold">Tight coupling due to protocol changes</strong>: The client and server are tightly coupled because of the protocol. Once the protocol changes, the client and server must be updated, even just changing the order of the parameters.</li>
<li><code>protobuf</code> is a non-human readable format, so debugging is not convenient. Developers need additional tools to analyze the payloads.</li>
<li><code>grpcweb</code>, that can provide a library to perform conversions between gRPC and HTTP/1.1.</li>
<li><code>POST</code> method, which is not cacheable for the clients.</li>
<li><strong class="bold">A steeper learning curve</strong>: Unlike REST, which is human-readable, many teams find gRPC challenging to learn. They need to learn protobuf and HTTP/2 and look for proper tools to deal with the message content.</li>
</ul>
<p>So, should we c<a id="_idTextAnchor048"/>hoose gRPC or REST?</p>
<h3>Should I use gRPC instead of a REST API?</h3>
<p>It is <a id="_idIndexMarker089"/>challenging to choose gRPC over REST for most server-client scenarios. A REST-based API is well supported by all browsers, so it has a wider adoption nowadays. If you need to support browser clients, REST is a better choice compared with gRPC. However, gRPC has some features that are useful in certain circumstances, such as high-performance communication, real-time communication, low bandwidth, and multiple language environments. So, it is a good choice for microservices-style architecture.</p>
<p>In a microservices architecture, the services are loosely coupled, and each one does a specific task or processes specific data. They need to be able to communicate with each other with simplicity and efficiency without considering browser compatibility. gRPC is suitable for this scenario because it is based on HTTP/2, which is a high-performance protocol and provides bidirectional streaming, binary messaging, and multiplexing. <strong class="bold">Dapr</strong>, which<a id="_idIndexMarker090"/> is a portable, event-driven runtime for microservices, implements gRPC APIs so that apps can communicate with each other via gRPC. We will not discuss Dapr in this book, but if you are interested, you can find more information here: <a href="https://dapr.io/">https://dapr.io/</a>.</p>
<p>In conclusion, using gRPC or REST depends on y<a id="_idTextAnchor049"/>our use-case demands.</p>
<h3>gRPC API design</h3>
<p>The<a id="_idIndexMarker091"/> gRPC API design process is very similar to the REST API design process. In fact, the first three steps are similar to the REST API design process. We need to identify the resources, define the relationships between resources, and identify operation events as well.</p>
<p>Next, use the information from the first three steps to design and document the gRPC API. When we convert the operation events to gRPC operations, there are some differences. REST API uses HTTP methods to represent the operations. In gRPC, these operations are like the methods of the service, which means we can use verbs in the method names. For example, the method to get a post can be represented as <code>GetPost()</code>.</p>
<p>gRPC uses protobuf as the IDL. When we design a gRPC API, we actually need to author the <code>.proto</code> files. These <code>.proto</code> files consist of two parts:</p>
<ul>
<li>The definition of the gRPC service</li>
<li>The messages that are used in the service</li>
</ul>
<p>This is similar to the REST OpenAPI definition but has a different syntax. Each request needs a type-defined message that includes the sorted input parameters. Each response returns a message, an array of messages, or an error status response. We can have a <code>.proto</code> file for<a id="_idIndexMarker092"/> the blog system, as shown here:</p>
<pre class="source-code">
option csharp_namespace = "GrpcMyBlogs";syntax = "proto3";
package myBlogs;
service Greeter {
  rpc GetPost(GetPostRequest) returns (Post);
  rpc CreatePost(CreatePostRequest) returns (Post);
  rpc UpdatePost(UpdatePostRequest) returns (Post);
  rpc SearchPosts(SearchPostsRequest) returns (SearchPostsResponse);
  // More methods...
  ...
}
message GetPostRequest {
  string post_id = 1;
}
message CreatePostRequest {
  string category_id = 1;
  string title = 2;
  string content = 3;
  // More properties below
  ...
}
message UpdatePostRequest {
  string post_id = 1;
  string category_id = 2;
  string title = 3;
  string content = 4;
  // More properties below
  ...
}
message SearchPostsRequest {
  string keyword = 1;
}
message Post {
  string post_id = 1;
  Category category = 2;
  string title = 3;
  string content = 4;
  // More properties below
  ...
}
message Category {
  string category_id = 1;
  string name = 2;
  // More properties below
  ...
}
message SearchPostsResponse {
  int32 page_number = 1;
  int32 page_size = 2 [default = 10];
  repeated Post posts = 3;
}</pre>
<p>That’s it! Now, the <code>.proto</code> file has a basic gRPC service definition, including the message <a id="_idIndexMarker093"/>definitions. Next, we can use various tools to generate the code for the gRPC service and the client. In the development stage, we may need to frequently change the gRPC protocol definition by updating the <code>.proto</code> files. The changes will be reflected in the generated code. So, please consider carefully before you publish the service for consumption. We will discuss more about gRPC in <a href="B18971_11.xhtml#_idTextAnchor438"><em class="italic">Chapter 11</em></a>. If you would like to start gRPC development with .NET 8 now, please jump to that chapter.</p>
<p>Next, let’s <a id="_idTextAnchor050"/>look at the GraphQL API.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor051"/>What is a GraphQL API?</h2>
<p>Think about <a id="_idIndexMarker094"/>the scenarios <a id="_idIndexMarker095"/>that use REST APIs. We may find some issues:</p>
<ul>
<li><code>/posts</code> endpoint, which returns a list of the posts. When we show a post list page, we only need some properties such as <code>Title</code>, <code>PublishDate</code>, and <code>Category</code>. But the posts returned from the endpoint may contain more information about the posts, such as <code>IsPublished</code>, which is useless for clients.</li>
<li><code>/posts/{postId}</code> endpoint that shows the post information and a <code>/posts/{postId}/related</code> endpoint that shows related posts. If we want to show a post detail, the client will need to call the <code>/posts/{postId}</code> endpoint, but<a id="_idIndexMarker096"/> the related posts are not provided in the response. So, the client will have to make another request to <code>/posts/{postId}/related</code> to get the related posts. The N+1 problem often refers to the parent-child relationship. The endpoint that returns the collection resource does not provide enough information about the child resources for the clients. For example, the <code>/posts</code> endpoint returns a list of posts, but the response does not have the content summary for each post. To show the content summary on the post list page, the client will have to call the <code>/posts/{postId}</code> endpoint for each post to get the content summary. So, the total number of requests will be <code>n + 1</code>, where <code>n</code> is the number of posts.</li>
</ul>
<p>The over- and under-fetching problems are some of the most common problems with REST-based APIs. Because REST-based APIs center on resources, for each endpoint, the response structure is fixed and encoded in the URL, so it is not flexible for client requirements.</p>
<p>These problems can be overcome with a GraphQL API. A GraphQL API is another API style, which offers powerful query capabilities. It supports fetching data with a flexible structure based on the client’s needs. It can fetch data by a resource identifier, paginated listing, filtering, and sorting. It also supports mutating data <a id="_idTextAnchor052"/>as well, like CRUD in REST.</p>
<h3>Introduction to GraphQL</h3>
<p>GraphQL is a <a id="_idIndexMarker097"/>powerful query language for executing queries with a flexible data structure. It was developed internally by Facebook in 2012, following which it was released publicly in 2015. Now, it is open-source and maintained by a large community of companies and individuals from all around the world.</p>
<p>GraphQL solves the over- and under-fetching problem by providing more flexibility and efficiency. It is not tied to any database or storage engine, nor to any specific languages. There are many libraries to implement GraphQL services and clients. A GraphQL service defines types and fields on your resource types, and then provides functions for each field on each type.</p>
<p>Unlike REST, which uses <em class="italic">resources</em> as its core concept and defines URLs that return a fixed data structure for each resource, the conceptual model of GraphQL is an entity graph. So, all GraphQL operations are performed through a single HTTP <code>POST</code>- or <code>GET</code>-based endpoint, which is usually <code>/graphql</code>. It is completely flexible and allows the client to decide what data structure it needs. The GraphQL service receives GraphQL queries to validate whether a query refers to the correct types and fields defined, and then it executes the functions to return the correct data structure. The format of requests and responses is JSON.</p>
<p>Besides <a id="_idIndexMarker098"/>solving the over- and under-fetching problem, GraphQL has some other advantages:</p>
<ul>
<li>GraphQL reduces the complexity of maintaining API versions. There is only one endpoint and one version of the graph. It allows the API to evolve without breaking the existing clients.</li>
<li>GraphQL uses a strong type system to define the types and fields in a schema using SDL. The schema behaves as the contract, which reduces the miscommunication between the client and the server. Developers can develop frontend applications by mocking the required data structures. Once the server is ready, they can switch to the actual API.</li>
<li>GraphQL does not define the specific application architecture, which means it can work on top of an existing REST API to reuse some code.</li>
<li>The payload is smaller because clients get what they exactly request without over-fetching.</li>
</ul>
<p>However, there are also<a id="_idIndexMarker099"/> some disadvantages of using GraphQL:</p>
<ul>
<li>GraphQL presents a high learning curve for REST API developers.</li>
<li>The implementation of the server is more complicated. The query could be complex.</li>
<li>GraphQL uses a single endpoint, which means it cannot leverage the full capabilities of HTTP. It does not support HTTP content negotiation for multiple media types beyond JSON.</li>
<li>It is challenging to enforce the authorization because, normally, the API gateway enforces access control based on URLs. Rate-limiting is also often associated with the path and HTTP methods. So, you need more consideration to adopt the new style.</li>
<li>Caching is <a id="_idIndexMarker100"/>complicated to implement because the service does not know what data clients need.</li>
<li>File uploads are not allowed, so a separate A<a id="_idTextAnchor053"/>PI for file handling is needed.</li>
</ul>
<h3>GraphQL API design</h3>
<p>A GraphQL query<a id="_idIndexMarker101"/> is flexible, so clients can send various queries based on their requirements. To design the GraphQL API, we need to define the GraphQL schema first, which is the core of every GraphQL API.</p>
<p>GraphQL uses the GraphQL SDL to define GraphQL schemas. SDL has a type system that allows us to define the data structure, like the other strongly typed languages, such as C#, Java, TypeScript, Go, and so on.</p>
<p>We can define the following types and fields in the GraphQL schema:</p>
<pre class="source-code">
type Query {  posts: [Post]
  post(id: ID!): Post
}
type Post {
  id: ID!
  title: String
  content: String
  category: Category
  publishDate: String
  isPublished: Boolean
  relatedPosts: [Post]
}
type Category {
  id: ID!
  name: String
}</pre>
<p>A GraphQL request<a id="_idIndexMarker102"/> uses a query language to describe the desired fields and structure the client needs. The following is a simple query:</p>
<pre class="source-code">
{  posts {
    id
    title
    content
    category {
      id
      name
    }
    publishDate
    // If we do not need the `isPublished` field, we can omit it.
    // isPublished
    relatedPosts {
      id
      title
      category {
        id
        name
      }
      publishDate
    }
  }
}</pre>
<p>In the preceding query, we can omit the <code>isPublished</code> field and include related posts in the response, so <a id="_idIndexMarker103"/>the client does not need to send more requests.</p>
<p>To modify data or perform a calculation logic, GraphQL establishes a convention called <em class="italic">mutation</em>. We can think of mutation as a way to update the data. The following request is a mutation:</p>
<pre class="source-code">
mutation {  createPost(
    categoryId: ID!
    title: String!
    content: String!
  ) {
    post {
      id
      title
      content
      category {
        id
        name
      }
      publishDate
      isPublished
    }
  }
}</pre>
<p>There are some tools to <a id="_idIndexMarker104"/>generate GraphQL documents and test the service, such as GraphiQL,GraphQL Playground, and so on. We will not discuss GraphQL much further now. In <a href="B18971_12.xhtml#_idTextAnchor484"><em class="italic">Chapter 12</em></a>, we will learn how to use ASP.NET Core 8 to develop GraphQL APIs.</p>
<p>Next, we will discuss another API<a id="_idTextAnchor054"/> style, which is the real-time API.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor055"/>Real-time APIs</h1>
<p>We have <a id="_idIndexMarker105"/>introduced some web API styles, such as REST-based APIs, gRPC APIs, and GraphQL APIs. They all follow the request/response pattern – the client sends a request to the server, and the server returns a response. This pattern is easy to understand. However, this pattern may not be suitable for some scenarios.</p>
<p>Let’s say we have an application that contains two parts – the server, which is a fire station, and the clients, which are the fire engines. How can we notify the fire engines when an incident occurs?</p>
<p>If we use the request/response pattern, the clients need to send requests to the server to get the latest notification regarding the incident. But what is the best frequency of sending requests? 1 minute, or 10 seconds? Think about how urgent the incident is. If the fire engine gets a notification after a 10-second delay, this might be a problem, as the fire might be more serious and urgent! So, what about sending requests every 1 second? Then, the server would be very busy, and most of the time, it just returns a <code>No incident</code> response. With the request/response pattern, the server cannot push the notifications to the clients, so it is not suitable for this case. This lea<a id="_idTextAnchor056"/>ds us to the problem of API polling.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor057"/>The problem with API polling</h2>
<p>The request/response pattern <a id="_idIndexMarker106"/>has limitations. The server cannot notify the clients about what changes are happening on the server side. If the client needs to get the latest data, it has to frequently send requests to the server before receiving any updates.</p>
<p>For example, if the client would like to know when a new post is published, it needs to call <code>/posts/latest</code> to get the latest post. The client may set up an interval to send the request periodically. This pattern is called API polling, which is a common solution for clients that need to be updated for resource changes.</p>
<p>API polling does not have many differences from the common REST APIs. It can be implemented based on the request/response pattern. However, it is not the ideal solution for this kind of scenario. Normally, the frequency of resource changes is not predictable, so it is hard to decide the frequency of the requests. If the interval is too short, the client may send too many unnecessary requests and the server will handle too many queries. However, if the interval is too long, the clients cannot get the latest changes in time. In particular, if the application needs to notify clients in real-time, then the system would be very busy.</p>
<p>There are more challenges when we use API polling:</p>
<ul>
<li>The logic to check the resource changes is complex. It may implement the logic in the server, so the server needs to check the timestamp in the request and then query the data, based on the timestamp. Alternatively, the client queries all the data and compares the collection with the data from the previous request. It brings a lot of complexity.</li>
<li>It is hard to check whether a specific event has occurred – for example, creating resources and updating resources.</li>
<li>Rate-limiting may block the client from sending too many requests at the desired intervals.</li>
</ul>
<p>The ideal way to solve the problem of API polling is to allow the server to send events to the clients in real-time, rather than constantly polling and implementing the logic to check for changes. This is a different pattern from the request/response pattern. It supports real-time communication between servers and clients, which enables new possibilities for the application.<a id="_idTextAnchor058"/> This is what a real-time API can do.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor059"/>What is a real-time API?</h2>
<p>A real-time API goes<a id="_idIndexMarker107"/> beyond the traditional REST APIs. It provides some benefits:</p>
<ul>
<li>The application can respond to internal events in real-time. For example, if a new post is published, the client can get the notification immediately.</li>
<li>It can improve API efficiency by reducing the number of requests. The clients do not need API polling to check the resource changes. Instead, the server sends messages to clients when some events occur. It reduces the resources required during communication.</li>
</ul>
<p>Some technologies can implement real-time APIs, such as long polling, <strong class="bold">Server-Sent Events</strong> (<strong class="bold">SSE</strong>), WebSocket, SignalR, and gRPC stream<a id="_idTextAnchor060"/>ing.</p>
<p>Let’s take a quick look at these.</p>
<h3>Long polling</h3>
<p>The <a id="_idIndexMarker108"/>API polling problem we described previously is called short polling or regular polling, which is easy to implement but less efficient. The client cannot receive an update from the server in real-time. To overcome this issue, long polling is another choice.</p>
<p>Long polling is a variation of short polling, but it is based on <em class="italic">Comet</em>, which is a web application model in which a long-held HTTPS request allows a web server to push data to a browser, without it having to request it explicitly. Comet contains multiple techniques to implement long polling. It also has many names, such as Ajax push, HTTP streaming, and HTTP server push.</p>
<p>To use long polling, the client sends the request to the server but with the expectation that the server may not respond immediately. When the server receives the request, if there is no new data for the client, the server will keep the connection alive. If there is something available, the server will send the response to the client and complete the open request. The client receives the response and usually makes a new request right away or after a pre-defined interval to establish the connection again. The operation is repeated. In this way, it can effectively emulate the server push feature.</p>
<p>There are some<a id="_idIndexMarker109"/> considerations when using long polling. The server needs to manage multiple connections and preserve the session state. If the architecture becomes more complex (for example, when multiple servers or load balancers are in use), then it leads to the session stickiness issue, which means the subsequent client requests with the same session must be routed to the same server to which the original request was handled. It is hard to scale the application. Also, it is hard to manage the message order. If the browser has two tabs open and sends multiple requests simultaneously to write data, the server will not know which request is the latest.</p>
<p>Long polling is supported by many web browsers. In recent years, SSE and WebSocket have been widely adopted, so long polling is not the first choice anymore. Now, it is usually accompanied by other technologies or as a fallback. For example, SignalR uses long polling as a fallback w<a id="_idTextAnchor061"/>hen WebSocket and SSE are not available.</p>
<h3>SSE</h3>
<p>SSE is a server<a id="_idIndexMarker110"/> push technology that allows the server to send events to the web browser. SSE was first proposed in 2004 as part of the <em class="italic">WHATWG Web Applications 1.0</em>. It is based on the EventSource API, which is a standard API of HTML5. The Opera web browser implemented this feature in 2006. Now, all modern browsers support SSE.</p>
<p>In SSE, the client behaves as a subscriber, initializing the connection by creating a new JavaScript <code>EventSource</code> object, passing the URL of the endpoint to the server over a regular HTTP <code>GET</code> request with the media type of <code>text/event-stream</code>. Once connected, the server keeps the connection open and pushes new events separated by a newline character to the client, until it has no more events to send, or until the client explicitly closes the connection by calling the <code>EventSource.close()</code> method.</p>
<p>If the client lost the connection for any reason, it could reconnect to receive new events. To recover from the failure, the client can provide a <code>Last-Event-ID</code> header to the server to specify the last event ID that the client received. Then, the server can use this information to determine whether the client missed any events.</p>
<p>SSE is suitable for scenarios where real-time notifications have to be sent to the client when the data changes from the server, in order to keep a user interface in sync with the latest data state. Examples include Twitter updates, stock price updates, news feeds, alerts, and so on.</p>
<p>The limitation of SSE is that it is unidirectional, so it cannot be used to send data from the client to the server. Once the client connects to the server, it can receive responses only, but it cannot send new requests on the same connection. If you need bidirectional communi<a id="_idTextAnchor062"/>cation, WebSocket may be a better option.</p>
<h3>WebSocket</h3>
<p>WebSocket is <a id="_idIndexMarker111"/>a protocol that provides full-duplex communication between a client and a server within a single TCP connection. It allows the client to send requests to the server, while the server can push events and responses back to the client in real-time. WebSocket was first referenced as a TCP-based socket API in the HTML5 specification. In 2008, the WebSocket protocol was standardized by W3C. Google Chrome was the first browser to support WebSocket in 2009. Now, WebSocket is supported in most modern browsers, including Google Chrome, Microsoft Edge, Firefox, Safari, and Opera.</p>
<p>Unlike the HTTP protocol, WebSocket enables a two-way ongoing conversation between the client and server. The communication is usually done over a TCP port <code>443</code> connection (or <code>80</code> if there is an unsecure connection), so it can be easily configured in a firewall.</p>
<p>From a WebSocket perspective, the message content is opaque. A subprotocol is required to specify an agreement between the client and server. WebSocket can support both text and binary format subprotocols. As part of the initial handshake process, the client can specify which subprotocols it supports. Then, the server must pick one of the protocols that the client supports. This is called subprotocol negotiation. You can find many subprotocols officially registered here: <a href="https://www.iana.org/assignments/websocket/websocket.xml">https://www.iana.org/assignments/websocket/websocket.xml</a>.</p>
<p>The WebSocket protocol defines <code>ws</code> and <code>wss</code> as the URI schemas that are used for unencrypted and encrypted connections, respectively. It is always recommended to use <code>wss</code> to make sure the transport security layer encrypts data. For example, we can use the following code to create a WebSocket connection in JavaScript:</p>
<pre class="source-code">
const socket = new WebSocket('wss://websocket.example.com/ws/updates');</pre> <p>WebSocket does not define how to manage the events for the connections, such as reconnection, authentication, and so on. The client and server would need to manage those events. There are various libraries to implement WebSocket for different languages. For example, <em class="italic">Socket.IO</em> (<a href="https://socket.io">https://socket.io</a>) is a popular library that implements WebSocket servers and clients in JavaScript, Java, Python, and so on.</p>
<p>WebSocket<a id="_idIndexMarker112"/> is a great choice for real-time communications, such as online games, sales updates, sports updates, online chat, real-time dashboards, and so on.</p>
<p class="callout-heading">Uni-directional versus bidirectional</p>
<p class="callout">Uni-directional communication is like a radio. SSE is uni-directional because the server broadcasts data to clients, but clients cannot send data to the server. Bidirectional communication supports two-way communication. There are two types of bidirectional communication – half-duplex and full-duplex.</p>
<p class="callout">Half-duplex communication is like a walkie-talkie. Both the server and client can send messages to each other, but only one party may send messages at a time.</p>
<p class="callout">Full-duplex communication is like a telephone. The message can be sent from either side <a id="_idTextAnchor063"/>at the same time. WebSocket is full-duplex.</p>
<h3>gRPC streaming</h3>
<p>We<a id="_idIndexMarker113"/> introduced gRPC in the previous section. As we mentioned, gRPC is based on the HTTP/2 protocol, which provides a foundation for long-lived, real-time communication. Unlike HTTP/1.1, which requires a new TCP socket connection for each request, one HTTP/2 connection can be used for one or more simultaneous requests, so this avoids the overhead of creating new connections for each request. Also, HTTP/2 supports pushing data to clients without them having to request it. It is a huge improvement over the request/response pattern of HTTP/1.1.</p>
<p>gRPC takes advantage of the HTTP/2 protocol to support bidirectional communication. A gRPC service supports these streaming combinations:</p>
<ul>
<li>Unary (No streaming)</li>
<li>Server-to-client streaming</li>
<li>Client-to-server streaming</li>
<li>Bidirectional streaming</li>
</ul>
<p>Both gRPC and <a id="_idIndexMarker114"/>WebSocket support full-duplex communication, but, unlike WebSocket, gRPC uses <code>protobuf</code> by default, so it does not need to select a subprotocol. However, browsers have no built-in support for gRPC, so gRPC streaming is oft<a id="_idTextAnchor064"/>en used for service-to-service communication.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor065"/>Which real-time communication technology is best for your application?</h2>
<p>There are a couple <a id="_idIndexMarker115"/>of choices for your real-time application. So, how do we choose? It is important to note that it depends on the circumstances and constraints of your application. For example, do you need a push-only application or bidirectional communication? Do you want to support most browsers or just server-to-service communication? Do you need to push data to multiple clients or just one client?</p>
<p>Fortunately, Microsoft <a id="_idIndexMarker116"/>provides <strong class="bold">SignalR</strong> in ASP.NET Core to implement real-time communication. SignalR is an open-source library that enables real-time communication between clients and servers. It can automatically manage the connections and allow servers to send messages to all connected clients or a specific group of clients. Note that SignalR encapsulates multiple technologies, including WebSocket, SSE, and long polling. It hides the details and the complex implementations of these protocols. As a result, we do not need to worry about which technology is used for real-time communication. SignalR automatically chooses the best transport method for your application. WebSocket is the default protocol. If WebSocket is unavailable, SignalR will fall back to SSE, and then long polling.</p>
<p>SignalR is a good<a id="_idIndexMarker117"/> choice for these scenarios:</p>
<ul>
<li>When clients require high-frequency updates or alerts/notifications from the server – for example, games, social networks, voting, auctions, maps, and so on</li>
<li>Dashboard and monitoring applications – for example, system dashboard applications, instant diagram applications, sales data monitoring applications, and so on</li>
<li>Collaborative applications – for example, chat applications,whiteboard applications, and <a id="_idIndexMarker118"/>so on</li>
</ul>
<p>ASP.NET Core also provides good support to gRPC. So, the next question is, how do you choose between gRPC and SignalR?</p>
<p>Here are some thoughts you may want to consider:</p>
<ul>
<li>If your need to build a real-time application that supports multiple clients (browsers), you may use SignalR because it is well-supported by browsers, and gPRC is not.</li>
<li>If you need to build a distributed application or a microservices architecture application where you want to communicate between multiple servers, you may use gRPC because it is more suitable for server-to-server communication, and<a id="_idTextAnchor066"/> is more efficient than SignalR in this scenario.</li>
</ul>
<h1 id="_idParaDest-36"><a id="_idTextAnchor067"/>Summary</h1>
<p>In this chapter, we introduced some different API styles, including REST-based APIs, gRPC APIs, and GraphQL APIs, and explored how to design them. We also introduced a couple of different ways to implement real-time communication, including WebSocket, gRPC streaming, and SignalR. So far, we have not touched on much code, but we have reviewed the basic concepts of web APIs.</p>
<p>In the next chapter, we will start to learn how to use ASP.NET Core to implement them.</p>
</div>
</body></html>