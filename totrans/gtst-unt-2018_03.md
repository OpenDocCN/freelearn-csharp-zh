# 游戏设计

在[第2章](bab37b44-932a-4277-884d-69b6bac37516.xhtml)《Unity界面》中，我们考察了Unity的用户界面，并特别关注了最常用的组件，包括：菜单、场景视图、游戏视图、项目窗口、层次结构窗口、检查器窗口、工具栏和布局。熟悉Unity的界面让我们有信心继续使用游戏引擎，并在引入创建游戏所需的新功能时探索额外的界面组件。

在本章中，我们将设计我们的游戏“黄瓜甲虫”，以便我们可以制定一个开发计划。我们的游戏设计将包括我们希望在游戏中拥有的所有功能、玩家角色、非玩家角色、游戏资产、动画等等。我们将使用屏幕草图以及叙事来记录我们的游戏设计。在过程中，我们将探讨与使用Unity进行游戏相关的概念。

具体来说，在本章中，我们将探讨以下概念：

+   游戏概念

+   游戏角色

+   游戏玩法

+   难度平衡

+   项目组织

# 游戏概念

为什么设计我们的游戏，而不是直接开始开发？这个问题源于对开发游戏的兴奋，尤其是使用Unity游戏引擎。所有游戏都始于一个想法。这个想法被转化为设计，而这个设计是开发和最终游戏的基础。

游戏的设计就像房子的蓝图。在没有蓝图的情况下建造房子是不可想象的，同样，在没有设计的情况下开发游戏也是一个同样糟糕的想法。这样做的原因是为了节省时间和挫折感。对于更大的项目，浪费的时间也意味着不必要的资金支出。想象一下，你雇佣了一个由十二名开发者、动画师和艺术家组成的项目团队。如果你分享了你的游戏想法，他们会有足够的依据去进行吗？他们会做出伟大的事情，但不会有一套连贯的游戏组件吗？我们通过我们的游戏设计所做的，就是在开始时尽可能多地记录下来，以便开发过程具有目的性。毫无疑问，你将在开发过程中不断修改你的游戏设计，因此有一个强大的基础开始至关重要。

我们的游戏设计将成为我们游戏外观的基础，玩家的目标是什么，游戏玩法将是什么，支持用户操作、动画、音频、人工智能和胜利条件。这需要考虑很多因素，也强调了将游戏想法转化为游戏设计的重要性。

在本书中，我们将涵盖一系列组件，然而，在本节中，我们将涵盖以下列出的组件：

+   游戏想法

+   输入控制

+   胜利与失败

# 游戏想法

我们*Cucumber Beetle*游戏的基本概念是它将是一款3D游戏，以黄瓜人为玩家角色。这个角色必须保护黄瓜地，抵御黄瓜甲虫的攻击。这些甲虫一心想要摧毁黄瓜地，以及任何挡在他们路上的东西，包括我们的黄瓜人。

黄瓜人将从樱桃树上收获樱桃，并将它们投向黄瓜甲虫。这将是我们黄瓜人对抗黄瓜甲虫的唯一防御形式，除了逃跑。

# 输入控制

考虑玩家如何与我们的游戏互动是很重要的。玩家将使用标准控制集控制黄瓜人。玩家期望游戏中的用户控制将遵循行业标准。因此，我们默认的用户输入控制集，如这里所示，将包括键盘和鼠标：

![](img/cbfa79de-693a-44fd-ac9e-61b43bf53398.png)

我们将配置和编程我们的游戏，以便用户从键盘输入与以下表格中的键和动作配对相匹配：

| **键盘输入** | **动作** |
| --- | --- |
| 上箭头 | 向前/上移动 |
| 下箭头 | 向后/下移动 |
| 左箭头 | 向左移动 |
| 右箭头 | 向右移动 |
| *W* | 向前/上移动 |
| *S* | 向后/下移动 |
| *A* | 向左移动 |
| *D* | 向右移动 |
| 空格键 | 跳跃 |

鼠标也将是用户输入的一个重要来源。我们将使用以下表格中所示的两个组件，利用鼠标实现：

| **鼠标输入** | **动作** |
| --- | --- |
| 鼠标移动 | 旋转角色 |
| 左键 | 投掷樱桃 |

左鼠标按钮将是我们操作按钮。我们需要确保只有当玩家剩下一个或多个樱桃时，才会投掷樱桃。

# 获胜与失败

我们获胜的条件是当所有黄瓜甲虫都被消灭时。玩家可能会以两种不同的方式输掉游戏。第一种失败条件是当所有黄瓜都被黄瓜甲虫吃掉时。第二种失败条件是如果玩家用完了生命值。

通过这个简短的描述，你可以知道将会有很多事情需要跟踪，包括以下内容：

+   黄瓜甲虫数量

+   黄瓜数量

+   黄瓜人生命值数量

# 游戏角色

我们的游戏将使用几个游戏对象，但只有两个游戏角色。第一个游戏角色是黄瓜人，将由玩家控制。第二个游戏角色是黄瓜甲虫。这是一个非玩家角色，由人工智能控制。让我们更详细地看看这两个角色。

# 黄瓜人

玩家将以黄瓜人的身份玩我们的游戏，这是游戏的主角。这是一个我们将导入用于游戏的角色。它使用Maya创建的，Maya是一款专业的3D建模和动画软件套件，以及Photoshop。以下是我们的黄瓜人的样子：

![](img/d26cced7-9dcb-42f0-aa9e-e1962d5fe27a.png)

那么，黄瓜人玩家角色能做什么呢？我们已经知道，我们将能够通过键盘和鼠标输入的组合在我们的游戏环境中移动他。我们还知道，空格键将使他跳跃，而左鼠标按钮，我们的动作按钮，将使他射击樱桃。

因为黄瓜人是由人类玩家控制的，所以它被称为**玩家角色**。

我们将为黄瓜人实现以下动画：

+   **空闲**：当角色没有被玩家移动时，将播放这个动画。

+   **行走**：当玩家使黄瓜人行走时，无论方向如何，都会播放这个动画。

+   **奔跑**：这个动画与行走动画类似。它更快，可以快速覆盖距离。

+   **跳跃**：每当按下空格键时，我们将实现跳跃。

+   **死亡**：如果我们的角色被黄瓜甲虫克服，我们将播放这个动画。

+   **投掷**：这是将使黄瓜人投掷樱桃的动画。

黄瓜人可以做的其他动作是收集樱桃。我们将通过自动收集系统来实现这一点。每当黄瓜人接触到樱桃树时，我们将增加他拥有的樱桃数量。

我们将在第7章[实现我们的玩家角色](6a3fb463-b0c2-4145-9096-bc52d55cf905.xhtml)中实现黄瓜人。

# 黄瓜甲虫

我们游戏中的反派将是黄瓜甲虫。我们将控制我们想要在游戏中放置多少个黄瓜甲虫以及它们的位置。我们还将通过人工智能控制它们的行为。黄瓜甲虫角色是使用Maya和Photoshop创建的，与创建黄瓜人的相同软件对。以下是我们的黄瓜甲虫的图片：

![](img/3cab4dc5-3d0e-4c2f-834a-ea84a9b38f3c.png)

黄瓜甲虫会寻找并消耗黄瓜。我们将确定黄瓜被消耗所需的时间。正如您在前面的插图中所见，有黄瓜甲虫在其正常状态下的图像，所有六条腿都着地，以及站立的状态。站立姿势将在它攻击黄瓜人时使用。

因为黄瓜甲虫是由人工智能控制的，而不是由人类玩家控制，所以它被称为**非玩家角色**。

我们将为黄瓜甲虫实现以下动画：

+   当在地面上时：

    +   **空闲**：当黄瓜甲虫不在搜索、进食或攻击时，将播放这个动画。

    +   **地面行走**：当黄瓜甲虫行走时，将播放这个动画。

    +   **进食**：当黄瓜甲虫找到黄瓜并正在吃它时，将播放这个动画。甲虫比黄瓜小，所以需要多咬几口。

    +   **地面攻击**：黄瓜甲虫将用其触角攻击黄瓜人。

    +   **站立后空闲**：这个动画将黄瓜甲虫从地面状态变为站立并保持空闲。

    +   **地面死亡动画**: 当黄瓜人将其黄瓜甲虫击败在地面上时，将播放此动画。

+   当站立时：

    +   **行走**: 我们将赋予我们的黄瓜甲虫用它们的后两条腿行走的本领

    +   **奔跑**: 黄瓜甲虫将能够用它们的后两条腿向黄瓜人奔跑

    +   **站立攻击**: 当站立时，黄瓜甲虫将能够用它们的前四条腿攻击黄瓜人

    +   **站立死亡动画**: 当黄瓜人将其黄瓜甲虫击败在站立位置时，将播放此动画。

我们需要仔细规划和脚本编写来创建所需的黄瓜甲虫行为。黄瓜甲虫的数量和位置是我们需要做出的决定。

我们将在[第8章](28e6a940-f5d3-49ba-8778-a0b533b4a83e.xhtml)“实现我们的非玩家角色”中实现黄瓜甲虫。

# 游戏玩法

游戏将从玩家位于游戏世界中心开始。由玩家控制的黄瓜人需要防御黄瓜地免受黄瓜甲虫的侵害。为了击退黄瓜甲虫，黄瓜人需要从附近的樱桃树上收集樱桃。目标是击败所有黄瓜甲虫，在黄瓜地中的黄瓜全部被吃掉之前。

让我们看看我们将如何实现这一切。本节涵盖了以下游戏玩法组件：

+   游戏世界布局

+   开始条件

+   积分系统

+   头戴式显示器

# 游戏世界布局

将在[第4章](f9370800-eaf9-4593-8a9c-8252c85e22ac.xhtml)“创建我们的地形”中创建我们的游戏世界，然后在[第5章](101c3b96-a362-4913-925c-f22503f0f8a1.xhtml)“灯光、摄像机和阴影”中添加摄像机和灯光效果。我们将创建一个基本的户外环境，由一个大岛和周围的水组成。水将用于美学和边界目的。我们不会使用水；毕竟，黄瓜不能游泳。

这里是我们游戏世界形状的模拟图：

![](img/5afb8154-bd93-48a4-8f70-7c3812d4afce.png)

前面的模拟图中说明了四个基本要素：

+   **水域**: 这将仅用于我们的游戏世界边界。

+   **出生点**: 有五个出生点，我们在失去生命后可以将我们的玩家角色随机放置到其中一个。

+   **樱桃树**: 我们将在游戏世界中放置四个较大的樱桃树簇。

+   **黄瓜地**: 在模拟图中没有标记，但由绿色涂鸦区域表示。这代表了大片黄瓜地大致的种植或放置位置。

我们模拟图中没有表示的是黄瓜甲虫的放置。我们将通过脚本随机放置甲虫。我们将在[第8章](28e6a940-f5d3-49ba-8778-a0b533b4a83e.xhtml)“实现我们的非玩家角色”中这样做。

# 开始条件

当我们的游戏首次启动时，我们将设置几个起始条件。以下是一份这些条件的清单：

+   黄瓜人生成点

+   黄瓜甲虫的数量和位置

+   黄瓜人持有的樱桃数量

+   黄瓜的数量和位置

让我们逐一查看这些起始条件。

第一个起始条件是黄瓜人的生成位置。正如你在我们早期的原型中看到的，游戏中有五个可能的生成点。我们将编写一个脚本，每次随机生成玩家。虽然只有五个位置，但这确实为游戏增加了足够的随机性，使其成为一个有趣且具有挑战性的组成部分。

黄瓜甲虫的数量和位置是第二个起始条件。这是一对重要的决策。如果我们决策不当，游戏可能会变得过于简单或过于困难，在这两种情况下，游戏都不会足够具有挑战性，以至于让人玩起来觉得有趣。我们将在本章后面的标题为*难度平衡*的部分更详细地探讨这个问题。

黄瓜人持有的樱桃数量是我们的第三个起始条件。黄瓜人将开始时没有樱桃，每次重生时也将没有樱桃。因此，如果黄瓜人有319个樱桃并被一个或多个黄瓜甲虫击败，黄瓜人将带着零樱桃重生，失去他之前拥有的319个樱桃。

我们的第四个和最后一个起始条件是黄瓜的数量和位置。这是一组重要的考虑因素，与黄瓜甲虫的位置和数量相关。我们将在本章后面的标题为*难度平衡*的部分检查我们关于这个问题的决策的可能性和可能的结果。

# 积分系统

到目前为止，我们已经确定我们将跟踪游戏中的几个组件。这些组件在此列出，并列出我们将在脚本中使用的变量名：

+   黄瓜甲虫数量：

    +   `numberOfCucumberBeetles`

+   黄瓜数量：

    +   `numberOfCucumbers`

+   黄瓜人生命值数量：

    +   `livesLeft`

根据我们之前关于游戏结束条件的决定，我们可以应用以下数学检查来确定游戏是否结束以及结果如何。以下表格列出了每个游戏结束条件及其结果：

| **条件编号** | **游戏结束条件** | **结果** |
| --- | --- | --- |
| 1 | `numberOfCucumbers == 0` | 黄瓜甲虫获胜 |
| 2 | `numberOfCucumberBeetles == 0` | 黄瓜人获胜 |
| 3 | `livesLeft == 0` | 黄瓜甲虫获胜 |

为了实现三个游戏结束条件，我们知道我们必须跟踪甲虫、黄瓜和生命值。这是不可选择的。在我们有灵活性的地方是我们向用户显示的内容。我们将在下一节*抬头显示*中做出这个决定。

由于我们正在跟踪涉及数字的关键信息，这使得我们很容易实现点数系统。例如，每当消灭一个黄瓜甲虫时，我们可以给玩家50分。我们也可以在黄瓜人被黄瓜甲虫咬一口时扣分。

我们将在“黄瓜甲虫”游戏中实施的点数系统将包括两种类型的事件，一种是增加分数的事件，另一种是减少分数的事件。以下是我们的点数系统详情表：

| **游戏内事件** | **分数** |
| --- | --- |
| 游戏开始 | + 1,500  |
| 黄瓜人摘樱桃 | + 5 |
| 黄瓜人用樱桃击中地面上的黄瓜甲虫 | + 10 |
| 黄瓜人消灭地面上的黄瓜甲虫 | + 25 |
| 黄瓜人用樱桃击中站立的黄瓜甲虫 | + 50 |
| 黄瓜人消灭站立的黄瓜甲虫  | +100 |
| 黄瓜人失去生命值 | - 500 |

如前表所示，我们将玩家的初始分数设为1,500分，每次生命值损失时减去500分。这将确保我们的分数不会变成负数，并且减少我们在脚本中需要检查的事项。这也为玩家每次保住的生命值提供奖励。

# **抬头显示**

我们决定在游戏过程中跟踪一些信息，这些信息在计算分数和游戏结束时具有价值。玩家会希望看到这些信息，因为它往往能提供动力，并增加游戏的乐趣。因此，我们将为玩家创建一个抬头显示（HUD），并动态更新游戏中的数据。

**抬头显示（HUD**）是一个始终显示在屏幕上的信息视觉层。

这里是我们“黄瓜甲虫”游戏中**抬头显示（HUD**）的模拟图：

![](img/ce94e2d8-a01c-4956-ac23-7d1d9b2a285e.png)

如您所见，我们的抬头显示（HUD）有六个组成部分。每个部分都进行了详细说明：

+   **健康值**：这包括一个文本标签和一个健康计。

+   **生命值**：位于“健康”文本标签下方的图标表示剩余的生命值。我们不会为这个图标添加标签，因为其功能对玩家来说应该是显而易见的。我们将使用黄瓜人的图像作为图标。

+   **得分**：得分将在屏幕右上角显示。

+   **樱桃**：我们将直接在得分下方显示樱桃的数量。

+   **黄瓜**：抬头显示（HUD）的左下角包含两个组件。第一个组件是游戏中剩余的黄瓜数量。

+   **黄瓜甲虫**：当前游戏中剩余的黄瓜甲虫数量将在抬头显示（HUD）的左下角显示，位于黄瓜数量下方。

# 难度平衡

在确定游戏难度时需要考虑很多因素。如果游戏太难，玩家可能会失去兴趣；如果游戏太简单，可能不会吸引目标受众。有些游戏为用户提供可选的难度级别。其他游戏有多个级别，每个级别难度逐渐增加。为了达到我们期望的难度平衡，我们必须应对几个问题。

在本节中，我们将首先探讨难度平衡问题，然后介绍我们的实施计划。

# 难度平衡问题

在我们的游戏设计中，有很多关于游戏的问题需要考虑。对本节中问题的回顾将帮助我们理解即使是像我们这样的简单游戏也必须应对哪些问题才能达到期望的难度平衡。

这一系列问题与我们游戏中难度的整体实施相关：

+   我们是否应该提供不同难度的选择，由玩家决定？

    +   应该有多少个不同的难度级别？

    +   难度级别应该叫什么名字？

    +   每个难度级别具体会有哪些不同？

+   我们是否应该有多个游戏级别，每个级别难度逐渐增加？

    +   游戏应该有多少不同的难度级别？

    +   游戏级别应该叫什么名字？

    +   每个游戏级别具体会有哪些不同？

考虑以下关于我们游戏中胡瓜甲虫的问题：

+   应该有多少只胡瓜甲虫？

+   胡瓜甲虫应该有多被动或多主动？

+   胡瓜甲虫在什么距离内应该意识到胡瓜人？

+   胡瓜甲虫在寻找胡瓜时应有多有效？

+   每次攻击中，胡瓜甲虫应该对胡瓜人造成多少伤害？

+   胡瓜甲虫在死亡前能承受多少伤害？

+   胡瓜甲虫是否应该进行沟通并相互协助进行协同攻击？

接下来的一系列问题涉及我们的可玩角色，胡瓜人：

+   角色应该有多少条命？

+   玩家从一只胡瓜甲虫的攻击中会受到多少伤害？

+   角色在死亡前能承受多少伤害？

+   角色是否能够跑得比胡瓜甲虫快？

+   角色应该持有多少樱桃？如果是的话，应该有多少？

+   玩家应该在哪个位置复活？在一个安全区域？

+   当角色失去生命时，它们是否应该在没有樱桃的情况下复活？

+   当角色复活时，应该恢复满血吗？

我们还必须在游戏中考虑胡瓜和樱桃。以下是关于我们将要实现的游戏资产的一些问题。

胡瓜：

+   一只胡瓜甲虫需要咬多少次才能吃掉一个胡瓜？

+   游戏中应该有多少个胡瓜？

+   胡瓜在游戏环境中的位置应该在哪里？

樱桃：

+   玩家应该以多快的速度收集樱桃？

+   黄瓜人最多能有多少樱桃？

+   樱桃会对黄瓜甲虫造成多少伤害？

+   游戏中会有多少樱桃可用？

如您所见，我们需要回答一些问题作为我们设计的一部分。其中一些问题可能看起来重复，因为它们与游戏中的多个组件相关。

# 实施计划

根据上一节提出的问题，我们必须给出一些答案。所以，让我们在这里做吧。这组答案将作为我们难度平衡的实施计划。

我们的第一组决策集中在整体游戏概念上。以下是这些决策：

+   实现一个游戏关卡。

+   为用户提供三个游戏难度设置。设置名称如下：

    +   我是小黄瓜（最简单）

    +   我能应付（中等）

    +   来吧！（最难）

既然我们决定创建三个游戏关卡，我们必须确定它们将如何不同。这可以通过使用矩阵轻松管理。当我们填写矩阵时，我们将能够记录大多数之前列出的问题的答案。以下是我们将称之为的*难度实施矩阵*：

| **组件** | **我是小黄瓜** | **我能应付** | **来吧！** |
| --- | --- | --- | --- |
| 黄瓜甲虫数量 | X | X * 2 | X * 5 |
| 黄瓜甲虫（对黄瓜人）造成的伤害 | 每秒减少5个健康点 | 每秒减少10个健康点 | 每秒减少20个健康点 |
| 黄瓜甲虫（对黄瓜）造成的伤害 | 每秒减少5分 | 每秒减少7分 | 每秒减少9分 |
| 黄瓜甲虫起始健康值 | X | X * 2 | X * 5 |
| 黄瓜人起始健康值 | X | X * .75 | X * .5 |
| 黄瓜起始健康值 | 300 | 400 | 500 |
| 黄瓜数量 | X | X * .75 | X * .5 |
| 樱桃收集速率 | 每秒1个樱桃 | 每两秒1个樱桃 | 每三秒1个樱桃 |
| 黄瓜人能持有的最大樱桃数 | 99 | 75 | 50 |
| 樱桃（对黄瓜甲虫）造成的伤害 | X | X * .75 | X * .50 |

还有一组决策将不会根据用户选择的难度级别而改变。以下是一份这些决策的清单：

+   黄瓜甲虫的攻击性不会改变。我们将编写脚本，如果它们意识到黄瓜人，就会攻击他。

+   我们将为黄瓜甲虫设定一个非常小的视野区域，这使得黄瓜人可以轻松地绕过它们，也许更重要的是，跑得比它们快。

+   黄瓜甲虫将能够轻松地找到黄瓜。

+   黄瓜甲虫不会相互沟通。因此，不会有协调攻击。这并不意味着一个以上的黄瓜甲虫不能同时攻击黄瓜人。所有在黄瓜人范围内的黄瓜甲虫都会攻击。

+   黄瓜人将开始时有三个生命。

+   我们不会限制玩家收集樱桃的数量，但它们都会在重生过程中作为一部分丢失。

+   重生将在游戏中先前确定的五个重生点之间随机进行。

+   黄瓜人重生后将拥有满血量。

+   黄瓜将在游戏中的黄瓜地内随机放置。

+   樱桃树和樱桃的数量不会随着不同难度级别而变化。

# 项目组织

我们的项目将包括大量的资产。到目前为止，我们已经确定并详细说明了我们计划使用的黄瓜人、玩家角色、黄瓜甲虫（非玩家角色）。我们还将使用樱桃树、樱桃和黄瓜地。让我们在下一节中简要看看这些，*自定义资产*。

# 自定义资产

我们已经使用Maya和Photoshop创建了一些自定义资产用于我们的游戏。第一套资产是两种黄瓜地形式，如下图中所示：

![图片](img/415cb1cc-0c91-48ad-9dfd-6ecce439fed9.png)

我们将使用这些黄瓜地来覆盖我们游戏环境中的大片区域，如本章前面所述。我们有两种不同的地块形状，以帮助创建一个真实且非重复的游戏环境外观。我们还将旋转地块，以增加地面覆盖的整体视觉变化。

我们的游戏中还将提供定制的黄瓜。虽然游戏中可能有数百个，但我们将使用一个基础黄瓜，如图所示，并在整个游戏环境中复制它。我们可以修改大小和旋转，以确保看起来有很多独特的黄瓜：

![图片](img/5b81e509-42da-43c8-8568-a8bcd77f5e35.png)

我们下一个自定义资产是一棵樱桃树。我们的基础树如图所示，具有独特的形状。我们可以改变这棵树的大小和旋转，以创建看起来有很多独特树木的视觉效果。当然，这并不是一棵真实的樱桃树，但它将适合我们的目的：

![图片](img/a8e50bd3-6060-4a77-9ea4-0fdcc3fe1353.png)

虽然我们的樱桃树上长有樱桃，但它们都是树的一部分，而不是单独的对象。因此，我们的玩家角色可以从樱桃树上收集樱桃，但不会有视觉提示表明樱桃已经被摘下。我们将更新我们的HUD来提供这种提示。对于向黄瓜甲虫投掷樱桃，我们将使用以下图片中的樱桃：

![图片](img/02cc3787-9dc3-409f-a385-14eb891fadb7.png)

# 标准资产

除了为这款游戏创建的自定义资源外，我们还将使用许多Unity的标准资源，包括纹理、材质和3D对象。我们将在[第4章](f9370800-eaf9-4593-8a9c-8252c85e22ac.xhtml)，*创建我们的地形*中开始使用纹理和材质。我们将在[第6章](04be4d7b-8c85-4d9e-baf2-43965183f99f.xhtml)，*为我们的游戏创建和导入3D对象*中使用Unity的本地工具创建我们自己的3D资源，并导入额外的资源。

# 组织结构

如果我们没有组织计划的计划，我们的项目可能会迅速失控。Unity对项目组件有很好的搜索支持，但我们更希望能够快速导航到我们的资源。以下是我们开始创建游戏时将构建的基本结构：

![图片](img/5128e255-4c28-46f3-8779-c2a55ad20bd2.png)

# 摘要

在本章中，我们完全设计了我们的游戏，*黄瓜甲虫*，并计划使用我们的设计来推动我们的开发工作。我们的游戏设计包括功能、玩家角色、非玩家角色、游戏资源、动画等等。我们使用屏幕草图来帮助记录我们的游戏设计。此外，我们还计划了游戏难度的平衡，以确保游戏根据用户选择具有适当的难度。

在下一章中，你将学习如何创建游戏的地形。你将接触到地形塑造工具和地形绘制。你还将学习如何将植被和水添加到我们的地形中。到下一章结束时，你将为*黄瓜甲虫*游戏创建游戏世界。
