- en: '*Chapter 12*: Responsive User Interfaces'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn to write responsive user interfaces. You will
    write responsive **Windows Forms** (**WinForms**), **Windows Presentation Foundation**
    (**WPF**), ASP.NET, .NET MAUI, and WinUI applications. Using background worker
    threads, you will see how you can update and work with the **User Interface**
    (**UI**) in real time by running long-running tasks in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be working through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a responsive UI with WinForms**: In this section, you will write
    a simple WinForms application that remains responsive to user interaction while
    performing multiple tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building a responsive UI with WPF**: In this section, you will be writing
    a simple WPF application that remains responsive to user interaction while performing
    multiple tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building a responsive UI with ASP.NET**: In this section, you will be writing
    a simple ASP.NET application that remains responsive to user interaction while
    performing multiple tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building a responsive UI with .NET MAUI**: In this section, you will be writing
    a simple Xamarin.Forms application that remains responsive to user interaction
    while performing multiple tasks. You will then migrate the projects from Xamarin.Forms
    to .NET MAUI by updating the library references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building a responsive UI with WinUI**: In this section, you will be writing
    a simple WinUI application that remains responsive to user interaction while performing
    multiple tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By working through this chapter, you will gain the skills to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use background worker threads to keep UIs responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use wait screens to provide updates when users are required to wait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use AJAX, WebSockets, SignalR, and gRPC/gRPC-Web to send and receive data and
    transfer assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write responsive desktop, web, and mobile UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For clarification, when speaking about responsive UIs in this chapter, we are
    not talking about the layout of the UI adapting to the device size or screen real
    estate. Instead, we are focused on making busy UIs responsive to user input instead
    of blocking the user from working during task execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2022 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter source code is available at [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH12](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH12).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a responsive UI with WinForms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be building a very simple WinForms application that
    is **Dots Per Inch** (**DPI**)-aware and enables the user to continue working
    during long-running operations. The application has a splash screen with a progress
    bar and an updated label that provides visual feedback to the user that the application
    is busy loading. Once the loading progress has been completed, the splash screen
    closes, and the main window is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: On the main window, there is a label that gets updated every time you click
    on the increment count button, a paged table that you can navigate through using
    the buttons provided, and a progress indicator for a long-running task that also
    has a cancel button.
  prefs: []
  type: TYPE_NORMAL
- en: While the long-running task is executing, you can move the window around, increment
    the label by clicking the increment count button, and you can page through the
    data. If you choose to, you can also cancel the long-running task.
  prefs: []
  type: TYPE_NORMAL
- en: When the long-running task is completed, canceled, or encounters an error, the
    task progress panel is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling DPI awareness and long file path awareness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will configure a WinForms application so that it looks
    good on high-DPI screens and normal-DPI large screens. We also configure it to
    be aware of long file paths. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6 WinForms application and call it `CH12_ResponsiveWinForms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new *application manifest* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `app.manifest` file and update the `compatibility` section as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This XML code enables DPI awareness in WinForms applications from Windows Vista
    upward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uncomment the following `application` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code informs the compiler that the application is aware of long paths and
    DPI settings. With these settings in place, the application will now scale for
    different screen DPI settings and will be able to handle long paths that are 256
    characters long.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add a splash screen with loading progress feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a splash screen that updates with loading progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications can load very quickly, or they can load quite slowly. When they
    are loading, the user is unaware of what the application is doing. You may choose
    to display a splash screen as part of your application branding. If your application
    loads fast, then you may need to add a delay for a short period such as 3 seconds
    to enable the user to see the splash screen. Otherwise, all the user may see is
    a quick screen flicker.
  prefs: []
  type: TYPE_NORMAL
- en: If the application has some heavy loading operations that take time to process,
    the user can think there is an issue and that the program has crashed. So, it
    is good practice to provide a splash screen that provides visual feedback to the
    user. This way, the user knows that the application is busy processing and has
    not crashed. When users see such feedback, they are more patient and will wait
    until the application has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we add a splash screen with visual feedback. The main window
    simulates several loading operations with a delay to the UI. Then, the splash
    screen is closed and the main window is displayed. We will now start adding the
    necessary code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new form called `SplashScreenForm`, and change its **FormBorderStyle**
    property to **None** and its **StartPosition** property to **CentreScreen**. Change
    the **BackColor** property to **ActiveCaptionText**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `LoadingProgressBar` to the form and dock it to the bottom of the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a label to `LoadingProgressLabel` and dock it to the bottom of the form
    so that it appears just above the progress bar. Set the **Text** property to **Loading.
    Please wait…** and **Font** | **Size** to **12**. Change the **ForeColor** property
    to **HighlightWhite**. Set **Margin** | **All** and **Padding** | **All** to **8**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another label to `TitleLabel` with the **Text** property set to **Responsive
    WinForms Example**, **ForeColor** set to **HighlightText**, **Font** | **Size**
    set to **32**, and **Location** set to **29, 126**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `MainForm` and open the form. Double-click on WindowsForm. This will
    open the code window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements to the `MainForm` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These `using` statements provide all that we need for our splash screen’s code
    to function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables to the `MainForm` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These member variables will be referenced by the various methods in our `MainForm`
    class to provide paging, in-memory data storage, and store the click count and
    operation number of the operation being processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `MainForm_Load` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code creates our splash screen and then iterates 100 times, simulating
    many loading operations. Each iteration causes the UI thread to sleep for half
    a second, updates the splash screen progress, and releases the thread so that
    other threads can do their work by calling `Application.DoEvents()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **SplashScreenForm** and view its code. Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code takes input from the `MainForm` class and updates the splash screen’s
    label and progress bar, providing feedback to the user that the application is
    loading and making progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now completed the progress bar. If you run the code, you will see the
    following splash screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The WinForms splash screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – The WinForms splash screen
  prefs: []
  type: TYPE_NORMAL
- en: Now that our splash screen is working, let’s add our label and button that displays
    an incremental count of button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the increment count button and label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate non-blocking of the UI when a long operation is executing, we
    will have a label that is updated with text every time a user clicks a button.
    We will need to perform the following tasks in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a label called `ClickCounterLabel` to `MainForm` and dock it to the top.
    Set its text to an empty string and its text properties to **Segoe UI** and **36pt**,
    with **TextAlign** set to **MiddleCenter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button called `IncrementCountButton` to the form and dock it to the top
    of the form. Set its text to **&Increment Text**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* on the button to generate its click event. Update the code of
    the click event with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each time the user clicks the button, the _`clickCounter` variable is incremented
    by one. The `ClickCounterLabel` text is then updated, informing the user of how
    many times they have clicked the button.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we will be doing is adding a table with paged navigation. We
    shall be doing that in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a table with paged data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be adding a table with paged navigation. This will
    demonstrate that the user can still interact with the page through data in a WinForms
    application, even when long operations are running in the background. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `DataTable`, and set its **Dock** property to **Fill**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `DataPagingPanel`, with its **Dock** property set to **Bottom**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to `FirstButton`, with the text set to **|<<**. *Double-click*
    the button to generate the click event. Then, return to the design window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to `PreviousButton` with the text set to **<<**. *Double-click*
    the button to generate the click event. Then, return to the design window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a textbox called `PageTextBox` to **FlowLayoutPanel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button called `NextButton` to **FlowLayoutPanel**, with the text set to
    **>>**. *Double-click* the button to generate its click event. Then, return to
    the design window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button called `LastButton` to **FlowLayoutPanel**, with the text set to
    **>>|**. *Double-click* the button to generate its click event. This time, stay
    in the code view, as we have completed what we need to do on the UI for this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `BuildCollection` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method builds a collection of `100` products.
  prefs: []
  type: TYPE_NORMAL
- en: Add the call to the `BuildCollection` method to the `MainForm_Load` method before
    the `SplashScreenForm` instantiation line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the line that closes the splash screen, add the following two lines of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code sets the data source for our `PagedProducts` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `PagedProducts` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a range from the `_products` collection. The `_offset` variable
    stores the index value that forms the starting point of the returned collection,
    and the `_pageSize` variable stores the number of records to be returned for a
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `PageCount` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the number of products contained within the `_products`
    collection, divides that number by the `_pageSize` variable, and then returns
    the result. The result is the number of data pages that we can navigate through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `FirstButton_Click` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code moves to the first page in the dataset and updates the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `PreviousButton_Click` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code moves to the previous page in the dataset and updates the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `NextButton_Click` method code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code moves to the next page of the dataset and updates the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LastButton_Click` method code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method moves to the last page of the dataset and updates the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the `Product` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class is the `Product` class that our `MainForm` uses to build its list
    of products within its `BuildCollection` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have now built our paged data table, and we have our increment button and
    label in place. The final thing to do with our form is to add our long-running
    task, to show that user interactions are still possible without being blocked
    by long-running tasks. This will be the topic of our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Running long-running tasks in the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to upgrade our UI to show the progress of a long-running
    task that is running in the background. The user will be able to cancel the long-running
    task at any time. When the task is completed, whatever state it is in, the long-running
    task update progress controls will be hidden from the user. Let’s start adding
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `LongRunningOperationCancelButton` and set its text to `&Cancel long running
    operation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `StatusBar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `TaskProgressBar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `StatusLabel` and make sure its text property is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `CollectionBuilderBackgroundWorker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `LongRunningProcessBackgroundWorker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainForm` class, add the following three lines to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds the handlers for our `BackgroundWorker`, which will be responsible
    for executing the long-running task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method call to the last line of the `MainForm_Load` method
    before the closing brace: `LongRunningProcess();`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `LongRunningProcess` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `LongRunningProcessBackgroundWorker` is not busy, then the `RunWorkerAsync`
    method called `LongRunningProcessBackground Worker_DoWork` is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `LongRunningProcessBackgroundWorker_DoWork` to the `MainForm` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are casting the sender as `BackgroundWorker` and assigning it to our local
    worker variable. Then, we iterate 100 times. Each time we iterate, we set the
    `_operationNumber` variable to the loop count variable value, sleep for 100 milliseconds,
    and then call the `ReportProgress` method of the worker passing in the percentage
    of work done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LongRunningProcessBackgroundWorker_ProgressChanged` method to the
    `MainForm` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code updates the UI with the progress of the long-running task. If all
    the operations have been completed, the task cancel button and status bar are
    hidden from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LongRunningProcessBackgroundWorker_RunWorkerCompleted` method to the
    `MainForm` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the long-running task is completed, this method executes `StatusLabel.Text`
    to the outcome of the method, with the outcomes being either `Cancelled`, `Error`,
    or `Done`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final piece of code to write before we complete and run our WinForms application
    is to add code to the `LongRunningOperationButton_Click` method to `MainClass`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code checks to see whether the task supports cancellation. If it does,
    then the task is canceled, and the cancel button and status bar are hidden from
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code. You should see the splash screen shown in *Figure 12.1*. Then,
    you should see the main window resembling what is shown in *Figure 12.2*. Move
    the window about and click on the increment count button. Also, click the paging
    buttons to move between data pages of the dataset, and cancel the task. You should
    see that the window is completely responsive to your input, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The Windows Forms main application window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – The Windows Forms main application window
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have written a WinForms application that has a lot going
    on. We have a splash screen that provides visual feedback to the user so that
    they do not think that the application has crashed in any way, and we have a UI
    that remains responsive to user input during a long-running task.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working WinForms application, let’s turn our attention to
    WPF. In the next section, we will apply what we have learned with our WinForms
    application to a WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Building a responsive UI with WPF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to build the same kind of interface as we did
    for the WinForms application, but this time, it will be using WPF. We will now
    start writing our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new WPF application called `CH12_ResponsiveWPF` and make sure to select
    **.NET 6.0** as the target framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Product` class to the project. It is the same code that we used in
    our WinForms application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Window called `SplashWindow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the **SplashWindow** XAML as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The XAML we have just updated declares a stack panel with two labels and a progress
    bar. The first label displays the title, and the second label displays loading
    progress along with the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the `SplashWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will be called by the `MainWindow` class and is responsible for updating
    the progress indicators on **SplashWindow**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` file and replace the existing XAML with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This XAML provides a status panel that will show the progress of any background
    tasks, an increment label and an increment button, a data grid, and a navigation
    panel for paging through different pages of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `using` statements to the `MainWindow.xaml.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These `using` statements are needed for our WPF window to function without error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables to the `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have the same variables that we had with our WinForms application,
    except we also declare a background worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `MainWindow` constructor with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code is pretty much the same as our WinForms load method. The only real
    difference is that all our initialization code is in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Worker_DoWork` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code simulates the work of 100 operations with a small delay for each operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Worker_ProgressChanged` method code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code updates the progress indicators for the long-running task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Worker_RunWorkerCompleted` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method reports the result of the long-running task and then hides the status
    panel from the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `PagedData` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a page of data whose index starts at `_offset`, with the
    number of returned rows defined by `_pageSize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DoEvents` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code performs like the WinForms `Application.DoEvents()` code. You can
    place your non-UI blocking code here, and update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BuildCollection` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BuildCollection` method builds our dataset of 100 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `PageCount` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `PageCount` method works out how many pages of data there are based on the
    dataset size, divided by the page size, and then returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `FirstButton_Click` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When executed, this method navigates to the first record in our dataset and
    upgrades the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `PreviousButton_Click` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will move to the previous page of the dataset and update the UI
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `NextButton_Click` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method moves to the next page of the dataset and updates the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LastButton_Click` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method moves to the last dataset page and updates the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `IncrementCounterButton_Click` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each time you click `IncrementCounterButton`, this method will increment the
    `_clickCounter` variable and report on the screen how many times you have clicked
    the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the final WPF method called `CancelTaskButton_Click`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method cancels the long-running task if it supports cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the WPF application. You will find that you are presented with the splash
    screen showing the loading progress, as displayed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – The WPF application’s splash screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.03_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – The WPF application’s splash screen
  prefs: []
  type: TYPE_NORMAL
- en: When the loading completes, the splash screen closes and you are presented with
    the main window. While a long-running task is in progress, you can move the window
    about, click on the increment counter button, navigate through the paged data,
    and cancel the long-running task.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following screenshot, we have everything in place that
    provides visual feedback of progress to end users and a UI that remains responsive
    to user input during a long-running task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – The WPF application’s main window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.04_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – The WPF application’s main window
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to keep ASP.NET UI responsive to user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Building a responsive UI with ASP.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at ways to assist ASP.NET applications in
    being quick and responsive. We will start by looking at memory and distributed
    caching. Then, we will look at how you can update a section of a page using AJAX.
    Next, we will move on to write a real-time chat application with SignalR. We will
    then take a look at using WebSockets in our ASP.NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will not be covering gRPC-Web in this chapter, as we have already covered
    that topic with example code in [*Chapter 9*](B16617_09_Final_SB_Epub.xhtml#_idTextAnchor168),
    *Enhancing the Performance of Networked Applications*, in which we looked at gRPC
    for non-web applications and gRPC-Web for web applications. In this chapter, we
    also implemented a simple Blazor web application using gRPC-Web, so you can refer
    to this chapter for gRPC/gRPC-Web.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin looking at a responsive ASP.NET application by focusing on caching.
    There are two kinds of caching we will be looking at. These are **memory caching**
    and **distributed caching**. In the next section, we will implement memory caching.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing memory caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web applications load resources over the network we all know as the internet.
    Accessing, downloading, and rendering resources from the internet takes varying
    degrees of time. Time can vary due to network traffic, the quality of the network,
    and computer system resources. Is there a way in which we can speed this process
    up? Well, yes. We can implement caching. But what exactly is caching?
  prefs: []
  type: TYPE_NORMAL
- en: '**Caching** is the local storage of frequently accessed resources for faster
    access and processing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will see how we can easily implement in-memory caching
    in ASP.NET. To implement in-memory caching, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new ASP.NET Core web app (`Model-View-Controller`) project and call
    it `CH12_ResponsiveASPNET`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Microsoft.Extensions.Caching.Memory` NuGet package. If Visual Studio
    cannot install it, run the following command in the Package Manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `HomeController` class, add the statement `using Microsoft.Extensions.Caching.Memory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code declares the variables that will store our logger and memory cache
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `HomeController` constructor, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, the logger and memory cache objects that we will be using are
    injected into our class, and we pass in variables to set our member variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetMemoryCacheTime` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are checking whether our `CachedTime` variable exists in the memory
    cache. If it does exist, then the out variable called `currentTime` is set and
    the cached time is returned. Otherwise, we get the current time and store it in
    the memory cache with a sliding expiration value, and then we return the cached
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Index` method with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Index` controller method returns a string. This string that is returned
    is the cached time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project and navigate to `https://localhost:5001/Home`. You should see
    something like the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Current Time: 12/07/221 20:18:25**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory Cache Time: 12/07/2021 20:18:25**'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the time did not exist in the cache, and so was added to the
    cache before it was returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The setting of port numbers is dependent on the availability of ports. Whatever
    port you choose, it will not work if it is in use by another program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, refresh the page, and you should see different values for the current
    time and the memory cache time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Current Time: 12/07/2021 20:21:21**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory Cache Time: 12/07/2021 20:18:25**'
  prefs: []
  type: TYPE_NORMAL
- en: You can clearly see that the memory cache time is older than the current time.
    This shows that we have stored the time in the in-memory cache and retrieved it
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing in-memory caching is really easy in ASP.NET, and you can enhance
    the page load and render time by storing and retrieving data from the in-memory
    cache. Now that we have looked at the in-memory cache, we will turn our attention
    to distributed cache.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing distributed caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be using the same ASP.NET web project and controller
    to implement distributed caching. What do we mean by distributed caching? Distributed
    caching extends the concept of local caching to include caching over several computers.
    Such caching enables the scaling of transactional data. You would mainly use distributed
    caching to store application data that resides in a database, and data related
    to web sessions. In this section, we use Redis for our caching. Redis is an in-memory
    data structure store, used as a distributed, in-memory key-value database, cache,
    and message broker, with optional durability. To implement distributed caching,
    perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Microsoft.Extensions.Caching.Redis` NuGet package to the web package.
    You can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `HomeController` class, add the `using Microsoft.Extensions.Caching.Distributed`
    statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following member variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This variable will hold our distributed cache object that gets injected via
    the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the constructor code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are injecting the distributed cache object and setting our member variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our distributed cache, we will need to encode and decode Base64 strings.
    Add the following two methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In these two methods, we are encoding a string as a Base64 encoded string, and
    we are also decoding strings from Base64 to UTF8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetDistriutedCacheString` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we obtain string data from the cache. If it exists, then we return
    it. If it does not exist, then we save the Base64 encoded version of the string
    to the cache with an absolute expiry being set and then return the Base64 decoded
    version of the string as a UTF encoded string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `HomeController.Index` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code obtains in-memory cache and distributed cache stored data and outputs
    it to the user, showing the current time, the in-memory cached time, and the data
    stored in the distributed cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program and navigate to `https://localhost:5001`. You should see the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that the memory cached time and distributed cache string have both
    just been added to the cache because they are the same as the current time. Now,
    refresh your browser. You should see that both cached values are older than the
    current time as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this and the previous section, you have seen how easy it is to add in-memory
    and distributed caching to our application. Both forms of caching can be really
    useful in improving the performance of your ASP.NET web applications. In the next
    section, we will look at how to update a small section of the currently displayed
    page using AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: Using AJAX to update part of the currently displayed page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will use AJAX to update a part of a page that is currently
    being displayed. This saves us from having to load the whole page. Let’s start
    writing our AJAX example:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Controllers` folder. From the context menu, select **Add**
    | **Controller…**. Then, select **MVC Controller – Empty**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the new controller `AjaxController` and open the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the controller by adding the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method when called will return a JSON result, which in our case is a simple
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on the `Index` method and select `index.cshtml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `Views/Ajax/index.cshtml` file with the following HTML and JavaScript
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have an HTML form. That form has a button that, when pressed, will execute
    JavaScript that will retrieve AJAX data by executing our `AjaxDemo` action method.
    This will result in our JSON string being displayed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project and navigate to `http://localhost:5001/Ajax`. You should see
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The AJAX demo before AJAX is retrieved'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.05_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – The AJAX demo before AJAX is retrieved
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, our page is loaded without our JSON string. Now, click the
    **Ajax Demonstration** button. You now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – The AJAX demo displaying the JSON string retrieved using AJAX'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.06_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – The AJAX demo displaying the JSON string retrieved using AJAX
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the button, we can see that the AJAX action retrieved our JSON
    string and displayed it on the page without a complete page load.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to update a portion of a page using AJAX, and before that,
    we saw how to implement in-memory and distributed caching. In the next section,
    we will look at how to implement WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing WebSockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be implementing **WebSockets**. You may have heard
    of WebSockets, but what are they? A WebSocket is a full-duplex communication protocol
    for communication over a single TCP connection. To find out more about the WebSocket
    specification, you can look up the IETF RFC 6455 from 2011 ([https://www.rfc-editor.org/rfc/rfc6455.txt](https://www.rfc-editor.org/rfc/rfc6455.txt)).
  prefs: []
  type: TYPE_NORMAL
- en: What do we use WebSockets for? Well, we can use them to open a single two-way
    interactive session between browsers and servers. That way, we can negate server
    polling, send messages to a server, and receive responses via events. Thus, making
    our applications event-driven.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our WebSockets demonstration, we will click a button. It will open a WebSocket,
    send a message, receive a response, and then close the connection. The communication
    between our browser and the server will be output to our web page. So, let’s get
    started with writing our WebSocket example:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new controller called `WebSocketsController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Index` method and select **Add View**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `Views/WebSockets/Index.cshtml` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a WebSocket is opened via the button click, the `messages` paragraph is
    updated with messages, and then a message is sent to the server. When the server
    responds, the messages paragraph is then updated to inform the user that the server
    has responded. If an error occurs, then a message is displayed to the user. The
    WebSocket is then closed and a message is displayed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and navigate to `http://localhost:5001/WebSockets`. Click on the
    button, and you should end up with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The end result of clicking on the button and executing our
    WebSocket example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.07_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – The end result of clicking on the button and executing our WebSocket
    example
  prefs: []
  type: TYPE_NORMAL
- en: There is not that much code to WebSockets. In this example, we have sent a simple
    message and received a response. All our code to do this exists in the `CSHTML`
    file of our view. In the next section, we will look at writing a real-time chat
    program using SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a real-time chat application using SignalR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to write real-time functionality in an ASP.NET
    web application using SignalR. We will demonstrate SignalR in action by writing
    a simple chat application. We will now begin writing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* the project and select **Add** | **Client-Side Library** from
    the context menu, and fill in the details as shown in *Figure 12.8*. Then, click
    the **Install** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The Add Client-Side Library configured to install SignalR'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.08_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – The Add Client-Side Library configured to install SignalR
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `wwwroot/lib/microsoft/signalr` library and paste it into the `wwwroot/js`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new controller called `SignalRController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a folder called `Hubs` under the main project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class to the `Hubs` folder called `ChatHub`. Then, update the `ChatHub`
    class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have our SignalR hub class in place, and our `SendMessage` method sends a
    message to the specified user asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on the `Index` method in the `SignalRController` class and select
    **Add View** from the context menu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Views/SignalR/Index.cshtml` file, replace the existing contents with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have put together a chat UI. The script uses SignalR. All we need to do now
    is add our JavaScript that makes our UI interactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `wwwroot/js` folder, add a file called `chat.js` with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have added JavaScript that makes our UI interactive. This code manages the
    sending of chat messages between users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program` class, add the following services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds SignalR to our available services so that we can pass SignalR
    requests to SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If using the new minimal template, the code is `builder.Services.AddRazorPages();
    builder.Services.AddSignalR();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Program` class to include the mapped route to our `ChatHub`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have included the route to our `ChatHub` so that our chat application knows
    how to handle incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and navigate to `https://localhost:5001/SignalR`. You will need
    two browser instances side by side. Enter usernames and messages in each browser
    and click on the **Send Message** button. Each time you enter text, it will appear
    on the receiver’s chat page, as you can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Our SignalR application in action'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.09_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – Our SignalR application in action
  prefs: []
  type: TYPE_NORMAL
- en: It was fairly straightforward setting up and running our SignalR. As you can
    see, SignalR is an excellent choice for real-time communication, and I am sure
    you will be able to take this knowledge further in the web applications you write.
    That concludes our work on ASP.NET in this chapter. So, let’s now move on to look
    at .NET MAUI in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building responsive UIs with .NET MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft .NET MAUI is the new version of Xamarin.Forms. There have been some
    significant changes between Xamarin.Forms version 5.0 and .NET MAUI (Xamarin.Forms
    version 6.0). The biggest change in MAUI has been to combine the Android, iOS,
    and macOS projects into a main project. While the code specific to Windows still
    resides in its own project, Microsoft is working to include the Windows code in
    the main project. This will lead to us having one single project for writing cross-platform
    applications using C# and XAML. Let’s have a look at some of the other improvements
    to building cross-platform applications using .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an early version of MAUI, to run the Windows project, you will
    need to set the Windows project as the startup project and deploy the project.
    Once the project is deployed, you can run the application from the Windows start
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another significant change made in .NET MAUI is that the original layouts used
    by Xamarin.Forms projects have been moved to `Microsoft.Maui.Controls.Compatibility`
    namespace. By default, MAUI will use new layouts. These layouts are based on a
    new `LayoutManager` that has been written for performance, consistency, and maintainability.
    The new layouts are `Grid`, `FlexLayout`, and `StackLayout` (`HorizontalStackLayout`
    and `VerticalStackLayout`). Microsoft encourages you to select the stack layout
    that best suits your needs. You are also encouraged to replace legacy layouts
    with new layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default spacing values for the new layouts have been standardized to the
    value of 0\. Having these values as 0 sets the expectation that you will set your
    own preferred values to meet your design requirements. It is best to set these
    values in your global styles as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let’s move on to look at accessibility improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft regularly meets with developers who are heavily invested in making
    applications that meet the highest accessibility rating. This led Microsoft to
    remove the `TabIndex` and `IsTabStop` properties, as they ended up being confusing
    and not meeting accessibility needs. For better accessibility, you can improve
    a screen reader’s ability to know the order of reading a UI by implementing a
    thoughtful design. If you need to take control over the order of UI components,
    Microsoft recommends that you use the `SemanticOrderView` component.
  prefs: []
  type: TYPE_NORMAL
- en: SetSemanticFocus and Announce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Screen readers are an essential part of an application that is accessible and
    friendly. To aid these applications’ performance in being able to read the correct
    components, there is a new `SemanticExtensions` class. As part of this class,
    there is a new method called `SetSematicFocus`. This method enables the setting
    of a screen reader’s focus to a specific element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, `SetSemanticFocus` and `Announce` are only available
    for iOS, Android, and Mac Catalyst.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a XAML example of setting semantic focus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In this XAML, we have an instruction label and a button for the user to press.
    When the button is pressed, the click event will set the semantic focus to `semanticFocusLabel`.
    Here is the click event code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code enables the screen reader to make an announcement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Another accessibility addition is automatic font scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Font scaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, all components now have automatic font scaling, and it is enabled
    by default. That means that when your users change their text scaling on the various
    platforms, your application’s text will scale to their chosen settings automatically.
    You can turn automatic font scaling off for control with the following markup:
    `FontAutoScalingEnabled=”False”`. Changing the attribute to `True` or removing
    it will turn font auto-scaling back on.'
  prefs: []
  type: TYPE_NORMAL
- en: BlazorWebView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using BlazorWebView, you can host Blazor websites in your Microsoft MAUI applications.
    This enables your Blazor website to make use of native platform functionality
    and various user controls. You can add `BlazorWebView` to a XAML page and point
    it to the root of your Blazor application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the XAML, the root of our Blazor application is `wwwroot/index.html`.
    In the next section, we will take a look at WinUI 3.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As of June 20, 2022, MAUI is generally available, but to develop MAUI applications,
    you will need to install a .NET 2022 preview.
  prefs: []
  type: TYPE_NORMAL
- en: Building a responsive UI with MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will build a simple responsive UI using MAUI. Until MAUI
    is included with Visual Studio 2022, you will need to ensure you use Visual Studio
    2022 Preview:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET MAUI app and call it `CH12_ResponsiveMAUI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Api` folder, add a class called `PropertyChangedNotifier` and replace
    its contents with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code is a base class that implements the `INotifyPropertyChanged` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new folder called `Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class to the `Data` folder called `BaseEntity` with the following
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are base properties for our entities that will inherit this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new interface to the `Data` folder called `IRepository` and replace the
    class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This interface will be implemented by all our repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a class called `BaseRepository` to the `Data` folder and update the class
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class is a generic base repository that implements the `IRepository` interface.
    The context for storing data is of type `ICollection`, and we set `Context` to
    the collection passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Add` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds an entity to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Count` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code returns the count of all the entities in our collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Filter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code takes a query and returns a filtered list of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `FilteredCount` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code returns the items in our filtered list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `FirstOrDefault` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns the first record to match our query. If there is no match,
    then the default value is returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetAll` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method returns all the items in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetById` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets an item from the list, as identified by its ID number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Remove` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method removes an entity from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method updates an entity in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class to the `Data` folder and call it `PeopleRepository`. Then,
    update the class definition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class creates a new repository of type `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new folder with a class called `Person`. Then, update the class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class inherits our `BaseEntity` class and adds the properties `FirstName`
    and `LastName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new folder called `ViewModels` and a new class called `ViewModelBase`.
    Update the class definition as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class is the base view model class for all our view models. It can be cast
    to any type, and it implements `PropertyChangeNotifer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `PeopleViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code seeds our collection with people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new page to the root of the project called `SplashPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `SplashPage` is a loading page that will display progress to the user in
    the form of a progress bar and label. The class inherits from the `Content` page
    and implements the `INotifyPropertyChanged` event. We have a timer whose callback
    is a method for reporting loading progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReportProgress` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method stops the timer and runs the code to update the application loading
    progress status. It uses a safe invoke method that will update the splash screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LoadMainPage` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method sets the application’s `MainPage` to `AppShell` and passes in a
    parameter of type `BaseEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `SaveInvokeInMaInThread` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code performs a safe invocation on the main thread to update the UI. The
    method checks the device the application is running on before calling the correct
    method for the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateProgress` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method updates the progress bar and the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SplashPage` XAML, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This markup contains our UI definition that will be updated by the code when
    it runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `MainPage` by replacing the current XAML with the following XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code updates the original source by adding a table of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `PeopleRepository` class variable and update the constructor of the `MainPage`
    class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code modifies our `MainPage` by setting its `BindingContext` to `PeopleViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, and you should see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – The splash page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – The splash page
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen is what you’ll see next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – The main form with a table in a scroll view with a button
    that responds to clicks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.11_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – The main form with a table in a scroll view with a button that
    responds to clicks
  prefs: []
  type: TYPE_NORMAL
- en: We have managed to build a responsive splash screen that also populates a table
    and responds to button clicks. That concludes our look at MAUI. We will now move
    on to WinUI 3.
  prefs: []
  type: TYPE_NORMAL
- en: Building a responsive UI with WinUI 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to provide user feedback using the `ProgressRing`
    component while performing a long-running operation in WinUI 3 applications. When
    your users trigger a long-running operation that holds up the UI, it is a good
    idea to provide user feedback until the operation completes. Let’s write a simple
    application that simulates a long-running operation using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new WinUI3 application and call it `CH12_ResponsiveWinUI3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `MainWindow.xaml` and replace the existing XAML between the Window tags
    with the following XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have used `OneWay` binding to bind our the `ProgressRing` class' `IsActive`
    and `Visibility` properties to the `IsWorking` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the code behind the class, implement the `INotifyPropertyChanged` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following members to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`_dispatcherTimer` will be used to simulate a long-running operation. The `PropertyChanged`
    event will be used to notify `ProgressRing` that the `IsWorking` property has
    changed, and the `_isWorking` variable will be updated to let `ProgressRing` know
    to either show or hide itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method to raise the `PropertyChanged` event if it is not `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we set the `IsWorking` property, we call this method so that the `PropertyChanged`
    event is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following three lines to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These three lines instantiate our `DispatcherTimer`, set its interval to `10`
    seconds, and add the `Tick` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add the `DispatcherTimer_Tick` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We stop the timer and remove the event handler to stop it from firing again
    and being held in memory. Then, we set the `IsWorking` property to `false`, which
    results in `ProgressRing` being hidden and made inactive. Then, we add a message
    to `MessageTextBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `IsWorking` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When setting our property, we call the `NotifyPropertyChanged` method that raises
    the `PropertyChanged` event to let `ProgressRing` know that the property has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the code for the button click:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We collapse our button, as it is no longer needed. Set the `IsWorking` property
    to `true`, and start our `DispatcherTimer`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code. You should see a single button that says `ProgressRing` for 10
    seconds. Then, `ProgressRing` should disappear and be replaced with the text **Work
    completed**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have concluded our look at responsive UIs, let’s summarize what
    we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with various UI frameworks to make
    UIs responsive. First, we looked at WinForms. With WinForms, we enabled DPI and
    long file path awareness. We also ensured that despite running long background
    tasks, we could page through data in a table and perform other UI operations,
    and we also added a splash screen that updates with the loading progress.
  prefs: []
  type: TYPE_NORMAL
- en: With WPF, we managed to produce a window that has a long-running task that can
    be canceled with progress indication. It also has a paged data table and button
    that, when clicked, updates the click count label.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at memory caching and distributed caching in ASP.NET. We also
    used AJAX to update part of the currently displayed page and looked at WebSockets
    and SignalR. We implemented a real-time ASP.NET chat application using SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to look at MAUI. In particular, we looked at layouts, accessibility,
    and `BlazorWebView`. Finally, we looked at WinUI 3 and how to provide user feedback
    when a long-running process is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at distributed systems. But first, try
    answering the questions in the next section, and then do some further reading
    to enhance your knowledge of responsive UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can you make a WinForms application scale properly on high-DPI screens or
    normal-DPI large screens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you cope with long file paths on Windows?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you keep users engaged when your application takes a long time to start?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you keep an application responsive to user input when you have a long-running
    process in operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What caching methods can you use to speed up access to resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you load only part of a web page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name two frameworks for performing network data transfer and real-time networked
    communication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three accessibility methods available in MAUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you include an existing Blazor web application in an MAUI project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your application is already loaded, and a user kicks off a long-running
    operation, what controls can you use to provide user feedback so that users don’t
    think your WinUI 3 application has crashed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Which is best? WebSockets or SignalR*: [https://dotnetplaybook.com/which-is-best-websockets-or-signalr/](https://dotnetplaybook.com/which-is-best-websockets-or-signalr/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why is SignalR/messagepack 2 times faster than gRPC/protobuf?*: [https://github.com/grpc/grpc-dotnet/issues/812](https://github.com/grpc/grpc-dotnet/issues/812
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tutorial: Get started with ASP.NET Core SignalR*: [https://docs.microsoft.com/aspnet/core/tutorials/signalr?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/aspnet/core/tutorials/signalr?view=aspnetcore-5.0&tabs=visual-studio
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WebSocket*: [https://javascript.info/websocket](https://javascript.info/websocket)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Migrate your app from Xamarin.Forms*: https://docs.microsoft.com/dotnet/maui/get-started/migrate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Xamarin.Forms Made Easy*: [https://winstongubantes.blogspot.com/2018/09/backgrounding-with-xamarinforms-easy-way.html](https://winstongubantes.blogspot.com/2018/09/backgrounding-with-xamarinforms-easy-way.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Xamarin – Working with threads*: [https://lukealderton.com/blog/posts/2016/october/xamarin-forms-working-with-threads/](https://lukealderton.com/blog/posts/2016/october/xamarin-forms-working-with-threads/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating Android emulators on Windows: [https://docs.microsoft.com/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&pivots=windows](https://docs.microsoft.com/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&pivots=windows)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing the Microsoft OpenJDK: [https://docs.microsoft.com/xamarin/android/get-started/installation/openjdk](https://docs.microsoft.com/xamarin/android/get-started/installation/openjdk
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Single-project MSIX Packaging Tools for VS 2022*: https://marketplace.visualstudio.com/items?itemName=ProjectReunion.MicrosoftSingleProjectMSIXPackagingToolsDev17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Improving rendering performance with Blazor component virtualization*: [https://www.daveabrock.com/2020/10/20/blazor-component-virtualization/#:~:text=Improve%20rendering%20performance%20with%20Blazor%20component%20virtualization%20Use,the%20entire%20HTML%20tree%20loads%20from%20the%20server](https://www.daveabrock.com/2020/10/20/blazor-component-virtualization/#:~:text=Improve%20rendering%20performance%20with%20Blazor%20component%20virtualization%20Use,the%20entire%20HTML%20tree%20loads%20from%20the%20server).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to Reuse Xamarin.Forms Custom Renderers in .NET MAUI*: [https://www.syncfusion.com/blogs/post/how-to-reuse-xamarin-forms-custom-renderers-in-net-maui.aspx](https://www.syncfusion.com/blogs/post/how-to-reuse-xamarin-forms-custom-renderers-in-net-maui.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Announcing .NET MAUI Preview 7*: [https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-7/](https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-7/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Multi-platform App UI*: [https://dotnet.microsoft.com/en-us/apps/maui](https://dotnet.microsoft.com/en-us/apps/maui)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
