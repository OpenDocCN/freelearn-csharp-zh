- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with Data in C# – Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned in *Chapter 7*, *Understanding the Different Domains in Software
    Solutions*, software systems are organized into layers that communicate with each
    other through interfaces and classes that don’t depend on how the peculiarities
    of each layer are implemented. When the software is a business/enterprise system,
    it usually contains at least three layers: the data layer, the business layer,
    and the presentation layer, if the software is based on a classical layer architecture
    (see the *Classic layers architecture* section of *Chapter 7*.'
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, the application is based on an onion architecture, an outermost
    layer contains presentation logic, drivers, and testing logic, then there is an
    application layer, and finally, a domain layer (see the *Onion architecture* section
    of *Chapter 7*). While, in the onion architecture, layers are defined in a slightly
    different way, the functionalities of the three layers of the onion architecture
    are basically the same as the ones of the three layers of the classical layer
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: However, notwithstanding the differences among all possible architectural choices,
    experience has proved that the main functionalities needed to handle data efficaciously
    are quite standard.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, in all architectures described in *Chapter 7**,* data-processing
    layers have the main purpose of mapping data from a data storage subsystem into
    objects and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the classical data layer, these objects are plain objects with
    no methods, while in the case of the domain layer, they are rich objects whose
    methods implement the application’s domain logic. Data layers, instead, implement
    the application’s domain logic within repository classes that are associated with
    their plain objects (see the *The Repository and Unit of Work patterns* section
    of *Chapter 7*).
  prefs: []
  type: TYPE_NORMAL
- en: This led to the conception of general-purpose frameworks for implementing data
    layers in a substantially declarative way. These tools are called **Object-Relational
    Mapping** (**ORM**) tools since they are data storage subsystems based on relational
    databases. However, they also work well with modern non-relational storage classified
    as NoSQL databases (such as MongoDB and Azure Cosmos DB) since their data model
    is closer to the target object model than a purely relational model.
  prefs: []
  type: TYPE_NORMAL
- en: ORMs improve and simplify the whole development process since they factor out
    and take away the burden of mapping data into objects and vice versa, so developers
    can focus just on the peculiarity of the business domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ORM basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Entity Framework Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity Framework Core migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiled models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying and updating data with Entity Framework Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying your data layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Entity Framework Core advanced features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter describes ORMs and how to configure them, and then focuses on Entity
    Framework Core, the ORM included in .NET 8.
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into ORM basics, let’s look at the technical requirements needed
    to follow the practical examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2022 Community Edition or better
    with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: All the concepts in this chapter will be clarified with practical examples.
    You will find the code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ORM basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ORMs map relational DB tables into in-memory collections of objects where object
    properties correspond to DB table columns. Types from C#, such as Booleans, numeric
    types, and strings, have corresponding DB types. If GUIDs are not available in
    the mapped DB, then types such as GUIDs are mapped to their equivalent string
    representations. All date and time types are mapped either to C# `DateTime` when
    the date/time contains no time zone information, to `DateTimeOffset` when the
    date/time also contains explicit time zone information, to `DateOnly` when the
    type contains just date information, or to `TimeOnly` when the type contains just
    time information. Any DB time duration is mapped to a `TimeSpan`. Finally, single
    characters should not be mapped at all to DB fields.
  prefs: []
  type: TYPE_NORMAL
- en: Since the string properties of most object-oriented languages have no length
    limits associated with them (while DB string fields usually have length limits),
    the DB limits are taken into account in the DB mapping configuration. In general,
    when the mapping between DB types and object-oriented language types needs options
    to be specified, these options are declared in the mapping configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the whole configuration is defined depends on the specific ORM. Entity
    Framework Core offers three options:'
  prefs: []
  type: TYPE_NORMAL
- en: Data annotations (property attributes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fluent configuration interface based on configuration objects and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the fluent interface can be used to specify any configuration option,
    the data annotations and name conventions can be used for a smaller subset of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I prefer using the fluent interface for most settings. I use name
    conventions only for specifying the principal key with an ID property name since
    I find that relying on name conventions for more complex settings is very dangerous.
    In fact, there are no compilation-time checks on name conventions, so a re-engineering
    operation might erroneously change or destroy some ORM settings.
  prefs: []
  type: TYPE_NORMAL
- en: I use data annotations mainly for specifying constraints on the possible values
    of properties, such as the maximum length of a value or the fact that a property
    is obligatory and can’t be null. In fact, these constraints restrict the type
    specified in each property, so placing them next to the properties they are applied
    to increases the code’s readability.
  prefs: []
  type: TYPE_NORMAL
- en: All other settings are better grouped and organized by using the fluent interface
    in order to increase code readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Each ORM adapts to a specific DB type (Oracle, MySQL, SQL Server, and so on)
    with DB-specific adapters called **providers** or **connectors**. Entity Framework
    Core has providers for most of the available DB engines.
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of providers can be found at [https://docs.microsoft.com/en-US/ef/core/providers/](https://docs.microsoft.com/en-US/ef/core/providers/).
  prefs: []
  type: TYPE_NORMAL
- en: Adapters are necessary for the differences in DB types, for the way transactions
    are handled, and for all other features that are not standardized by the SQL language.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships among tables are represented with object pointers. For instance,
    in a one-to-many relationship, the class that’s mapped to the *one* side of the
    relationship contains a collection that is populated with the related objects
    on the *many* side of the relationship. On the other hand, the class mapped to
    the *many* side of the relationship has a simple property that is populated with
    a uniquely related object on the *one* side of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: While, in the case of a one-to-one relationship, both classes have a property
    populated with the companion object, in the case of many-to-many relationships,
    both classes contain a collection that is populated with the related objects.
  prefs: []
  type: TYPE_NORMAL
- en: The whole database (or just a part of it) is represented by an in-memory cache
    class that contains a collection for each mapped DB table. First, the query and
    update operations are performed on an instance of an in-memory cache class, and
    then this instance is synchronized with the database.
  prefs: []
  type: TYPE_NORMAL
- en: The in-memory cache class that’s used by Entity Framework Core is called `DbContext`
    and it also contains the mapping configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can customize the `DbContext` class furnished by Entity Framework
    Core by inheriting from it and by adding their database-mapping instructions inside
    overridden methods.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, `DbContext` subclass instances contain partial snapshots of the
    DB that are synchronized with the database to get/update the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: DB queries are performed with a query language made of method calls on the collections
    of the in-memory cache class. The actual SQL is created and executed during the
    synchronization stage. For instance, Entity Framework Core performs **Language
    Integrated Query** (**LINQ**) queries on the collections mapped to the DB tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, LINQ queries produce `IEnumerable` instances, that is, collections
    whose elements are not computed when the is created at the end of the query, but
    when you actually attempt to retrieve the collection elements from the. This is
    called lazy evaluation or deferred execution. It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ queries that start from a mapped collection of a `DbContext` create a specific
    subtype of `IEnumerable` called `IQueryable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `IQueryable` contains all the information that’s needed to issue a query
    to the database, but the actual SQL is produced and executed when the first element
    of the `IQueryable` is retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, each Entity Framework query ends with a `ToListAsync` or `ToArrayAsync`
    operation that transforms the `IQueryable` into a list or array, thereby causing
    the actual execution of the query on the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the query is expected to return just a single element or no element at all,
    we typically execute a `SingleOrDefaultAsync` operation that returns a single
    element, if any, or `null`. This operation may be used also when several results
    are expected but we need just one. In this case, we might also use `LastOrDefaultAsync`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we need just to count the total results, for instance, for adequately organizing
    paging information, we can use `CountAsync()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, updates, deletions, and the addition of new entities to a DB table are
    performed by mimicking these operations on a `DbContext` collection property that
    represents the database table. However, entities may only be updated or deleted
    this way after they have been loaded in that memory collection by means of a query.
    Typically, an update query requires the in-memory representation of the entity
    to be modified as needed, while a delete query requires the in-memory representation
    of the entity to be removed from its in-memory mapped collection. In Entity Framework
    Core, the removal operation is performed by calling the `Remove(entity)` method
    of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of a new entity has no further requirements. It is enough to add
    the new entity to the in-memory collection. Updates, deletions, and additions
    that are performed on various in-memory collections are actually passed to the
    database with an explicit call to a DB synchronization method.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, Entity Framework Core passes all the changes that are performed
    on a `DbContext` instance to the database when you call the `DbContext.SaveChangesAsync()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Changes that are passed to the database during a synchronization operation are
    executed in a single transaction. Moreover, for ORMs, such as Entity Framework
    Core, that have an explicit representation of transactions, if a synchronization
    operation is executed in the scope of a transaction then it uses that transaction
    instead of creating a new transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining sections in this chapter explain how to use Entity Framework Core,
    along with some example code based on this book’s WWTravelClub use case.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since, as detailed in *Chapter 7, Understanding the Different Domains in Software
    Solutions*, database handling is confined within a dedicated application layer,
    it is good practice to define your Entity Framework Core (`DbContext`) in a separate
    library. Accordingly, we need to define a .NET class library project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two different kinds of library projects: **.NET Standard** and **.NET
    Core**. Please refer to *Chapter 5, Implementing Code Reusability in C# 12,* for
    a discussion on the various kinds of libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: While .NET libraries are tied to a specific .NET Core version, .NET Standard
    2.0 libraries have a wide range of applications since they work with any .NET
    version greater than 2.0 and also with the old .NET Framework 4.7 and above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our library is not a general-purpose library (it’s just a component of
    a specific .NET 8 application), instead of choosing a .NET Standard library project,
    we can simply choose a .NET 8 library. Our .NET 8 library project can be created
    and prepared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio, click **Create new project** and then select **Class Library**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new project `WWTravelClubDB` and accept the same name for the whole
    Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that follows, choose .NET 8 as the target framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must install all Entity Framework Core-related dependencies. The simplest
    way to have all the necessary dependencies installed is to add the NuGet package
    for the provider of the database engine we are going to use – in our case, SQL
    Server – as we mentioned in *Chapter 10*, *Deciding on the Best Cloud-Based Solution*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In fact, any provider will install all the required packages since it has all
    of them as dependencies. So, let’s add the latest stable version of `Microsoft.EntityFrameworkCore.SqlServer`.
    If you plan to use several database engines, you can also add other providers
    since they can work side by side. Later in this chapter, we will install other
    NuGet packages that contain tools that we need to process our Entity Framework
    Core configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s rename the default `Class1` class to `MainDbContext`. The `Class1` class
    is automatically added to the class library. Now, let’s replace its content with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We inherit from `DbContext`, and we pass a `DbContextOptions` to the `DbContext`
    constructor. `DbContextOptions` contains creation options, such as the database
    connection string, which depends on the target DB engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the collections that have been mapped to database tables will be added as
    properties of `MainDbContext`. The mapping configuration will be defined inside
    of the overridden `OnModelCreating` method with the help of the `ModelBuilder`
    object passed as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is the creation of all the classes that represent the tables.
    These are called entities. We need an entity class for each DB table we want to
    map. Let’s create a `Models` folder in the project root for all of them. The next
    subsection explains how to define all the required entities.
  prefs: []
  type: TYPE_NORMAL
- en: Defining DB entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DB design, like the whole application design, is organized in iterations (see
    *Chapter 1, Understanding the Importance of Software Architecture*). Let’s suppose
    that, in the first iteration, we need a prototype with two database tables: one
    for all the travel packages and another one for all the locations referenced by
    the packages. Each package covers just one location, while a single location may
    be covered by several packages, so the two tables are connected by a one-to-many
    relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start with the location database table. As we mentioned at the end
    of the previous section, we need an entity class to represent the rows of this
    table. Let’s call the entity class `Destination`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, all the DB fields must be represented by read/write C# properties.
    Since both the `Name` and `Country` properties are obligatory but we are not going
    to define a constructor, we added the `required` keyword to instruct the compiler
    to signal an error whenever an instance is created without initializing them.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that each destination is something like a town or a region that can
    be defined by just its name and the country it is in and that all the relevant
    information is contained in its `Description`. In future iterations, we will probably
    add several more fields. `Id` is an auto-generated key.
  prefs: []
  type: TYPE_NORMAL
- en: However, now, we need to add information about how all the fields are mapped
    to DB fields. In Entity Framework Core, all the primitive types are mapped automatically
    to DB types by the DB engine-specific provider that’s used (in our case, the SQL
    Server provider).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our only preoccupations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Length limits on the string**: They can be taken into account by applying
    adequate `MaxLength` and `MinLength` attributes to each string property. All the
    attributes that are useful for the entity’s configuration are contained in the
    `System.ComponentModel.DataAnnotations` and `System.ComponentModel.DataAnnotations.Schema`
    namespaces. Therefore, it’s good practice to add both of them to all the entity
    definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specifying which fields are obligatory and which ones are optional**: If
    the project is not using the new **Nullable Reference Type** feature, by default,
    all the reference types (such as all the strings) are assumed to be optional,
    while all the value types (numbers and GUIDs, for instance) are assumed to be
    obligatory. If we want a reference type to be obligatory, then we must decorate
    it with the `Required` attribute. On the other hand, if we want a `T` type property
    to be optional, and `T` is a value type, or the Nullable Reference Type feature
    is on, then we must replace `T` with `T?`. As a default, .NET 8 projects have
    the new Nullable Reference Type feature set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specifying which property represents the primary key**: The key may be specified
    by decorating a property with the `Key` attribute. However, if no `Key` attribute
    is found, a property named `Id` (if there is one) is taken as the primary key.
    In our case, there is no need for the `Key` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since each destination is on *one* side of a one-to-many relationship, it must
    contain a collection of the related package entities; otherwise, it will be difficult
    to refer to the related entities in the clauses of our LINQ queries. This collection
    will have a fundamental role in our LINQ queries and will be populated by Entity
    Framework Core. However, as we will see later in this chapter, it must be ignored
    in most of the database update operations. Therefore, the best option to avoid
    compiler warnings is to assign them the null-forgiving fake default value: `null!`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting everything together, the final version of the `Destination` class is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `Description` property has no length limits, it will be implemented
    with a SQL Server `nvarchar(MAX)` field of indefinite length. We can write the
    code for the `Package` class in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each package has a duration in days, as well as optional start and stop dates
    in which the package offer is valid. `MyDestination` connects packages with their
    destinations in the many-to-one relationship that they have with the `Destination`
    entity, while `DestinationId` is the external key of the same relation.
  prefs: []
  type: TYPE_NORMAL
- en: While it is not obligatory to specify the external key, it is good practice
    to do so since this is the only way to specify some properties of the relationship.
    For instance, in our case, since `DestinationId` is an `int` (not nullable type),
    it is obligatory.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the relationship here is one-to-many and not (0, 1)-to-many. Defining
    `DestinationId` as `int?` instead of `int` would turn the one-to-many relationship
    into a (0, 1)-to-many relationship. Moreover, as we will see later in this chapter,
    having an explicit representation of the foreign key simplifies the update operations
    a lot, and some queries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explain how to define the in-memory collection
    that represents the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the mapped collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have defined all the entities that are object-oriented representations
    of the database rows, we need to define the in-memory collections that represent
    the database tables themselves. As we mentioned in the *Understanding ORM basics*
    section, all the database operations are mapped to the operations on these collections
    (the *Querying and updating data with Entity Framework Core* section of this chapter
    explains how). It is enough to add a `DbSet<T>` collection property to our `DbContext`
    for each entity, `T`. Usually, the name of each of these properties is obtained
    by pluralizing the entity name. Thus, we need to add the following two properties
    to our `MainDbContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Up until now, we’ve translated database stuff into properties, classes, and
    data annotations. However, Entity Framework needs further information to interact
    with a database. The next subsection explains how to provide it.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the mapping configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mapping configuration information that we couldn’t specify in the entity
    definitions must be added with configuration code based on a fluent interface.
    The simplest way to add this configuration information is to add it using the
    `OnModelCreating DbContext` method. Each piece of configuration information relative
    to an entity, `T`, starts with `builder.Entity<T>()` and continues with a call
    to a method that specifies that kind of constraint. Further nested calls specify
    further properties of the constraint. For instance, our one-to-many relationship
    may be configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The two sides of the relationship are specified through the navigation properties
    that we added to our entities. `HasForeignKey` specifies the external key. Finally,
    `OnDelete` specifies what to do with packages when a destination is deleted. In
    our case, it performs a cascade delete of all the packages related to that destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same configuration can be defined by starting from the other side of the
    relationship, that is, starting with `builder.Entity<Package>()`. Clearly, the
    developer must choose just one of the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that the previous statement’s `HasMany-WithOne` methods
    are replaced by the `HasOne-WithMany` methods since we started from the other
    side of the relationship. Here, we can also choose the precision with which each
    decimal property is represented in its mapped database field. As a default, decimals
    are represented by 18 digits and 2 decimals. You can change this setting for each
    property with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ModelBuilder builder` object allows us to specify database indexes with
    something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Multi-property indexes are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting from version 5, indexes can also be defined with attributes applied
    to the class. The following is the case of a single property index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the case of a multi-property index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuration options that are specific to an entity can also be grouped into
    separate configuration classes, one for each entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these classes must implement the `IEntityTypeConfiguration<>` interface,
    whose unique method is `Configure`. Then, the configuration class can be declared
    with a class-level attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration class can also be recalled from within the `OnModelCreating`
    method of the context class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to add all configuration information defined in the assembly
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add all the necessary configuration information, then our `OnModelCreating`
    method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Together with the two configuration classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I prefer to define just general configuration and relationships in the context
    class. It is also convenient to use data annotation just for restricting property
    values (maximum and minimum length, required fields, and so on). This way, entities
    don’t depend on the specific ORM used and can be exported outside of the data
    layer, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The best place for other entity-specific configurations is the configuration
    class. I also avoid using the `EntityTypeConfiguration` attribute and call entity
    configuration classes from within the context class since this attribute ties
    the entity to a specific ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example shows a one-to-many relationship, but Entity Framework
    Core 8 also supports many-to-many relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding case, the join entity and the database join table are created
    automatically, but you can also specify an existing entity as the join entity.
    In the previous example, the join entity might be the course that the teacher
    teaches in each classroom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve configured Entity Framework Core, we can use all the configuration
    information we have to create the actual database and put all the tools we need
    in place in order to update the database’s structure as the application evolves.
    The next section explains how.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve configured Entity Framework and defined our application-specific
    `DbContext` subclass, we can use the Entity Framework Core design tools to generate
    the physical database and create the database structure snapshot that’s needed
    by Entity Framework Core to interact with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entity Framework Core design tools must be installed in each project that needs
    them as NuGet packages. There are two equivalent options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tools that work in any operating system console**: These are available through
    the `Microsoft.EntityFrameworkCore.Design` NuGet package. All Entity Framework
    Core commands are in `dotnet ef .....` format since they are contained in the
    `ef` command line’s .NET Core application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tools that are specific to the Visual Studio Package Manager Console**: These
    are contained in the `Microsoft.EntityFrameworkCore.Tools` NuGet package. They
    don’t need the `dotnet ef` prefix since they can only be launched from the **Package
    Manager Console** inside Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entity Framework Core’s design tools are used within the design/update procedure.
    This procedure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We modify `DbContext` and the entities’ definitions as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We launch the design tools to ask Entity Framework Core to detect and process
    all the changes we made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once launched, the design tools update the database structure snapshot and generate
    a new *migration*, that is, a file containing all the instructions we need in
    order to modify the physical database to reflect all the changes we made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We launch another tool to update the database with the newly created migration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We test the newly configured DB layer, and if new changes are necessary, we
    go back to *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the data layer is ready, it is deployed in staging or production, where
    all the migrations are applied once more to the actual staging/production database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is repeated several times in the various software project iterations and
    during the lifetime of the application.
  prefs: []
  type: TYPE_NORMAL
- en: If we operate on an already existing database, we need to configure `DbContext`
    and its models to reflect the existing structure of all the tables we want to
    map. This can be done automatically with the `Scaffold-DbContext` command (see
    [https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs](https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: All classes generated by .NET are partial classes, so the user can enrich them
    with further methods without modifying the scaffolded classes by adding the new
    methods to partial classes with the same names.
  prefs: []
  type: TYPE_NORMAL
- en: Then, if we want to start using migration instead of continuing with direct
    database changes, we can call the design tools with the `IgnoreChanges` option
    so that they generate an empty migration. Also, this empty migration must be passed
    to the physical database so that it can synchronize a database structure version
    associated with the physical database with the version that’s been recorded in
    the database snapshot. This version is important because it determines which migrations
    must be applied to a database and which ones have already been applied.
  prefs: []
  type: TYPE_NORMAL
- en: However, developers may also choose to continue manually modifying the database
    and repeating the scaffold operation after each change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole design process needs a test/design database, and if we operate on
    an existing database, the structure of this test/design database must reflect
    the actual database – at least in terms of the tables we want to map. To enable
    design tools so that we can interact with the database, we must define the `DbContextOptions`
    options that they pass to the `DbContext` constructor. These options are important
    at design time since they contain the connection string of the test/design database.
    The design tools can be informed about our `DbContextOptions` options if we create
    a class that implements the `IDesignTimeDbContextFactory<T>` interface, where
    `T` is our `DbContext` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`connectionString` will be used by Entity Framework to create a new database
    in the local SQL Server instance that’s been installed in the development machine
    and connects with Windows credentials. You are free to change it to reflect your
    needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to create our first migration! Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go to the **Package Manager Console** and ensure that **WWTravelClubDB**
    is selected as our default project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, type `Add-Migration initial` and press *Enter* to issue this command. Verify
    that you added the `Microsoft.EntityFrameworkCore.Tools` NuGet package before
    issuing this command; otherwise, you might get an “unrecognized command” error:![Graphical
    user interface, text, application  Description automatically generated](img/B19820_13_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.1: Adding the first migration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial` is the name we gave our first migration. So, in general, the command
    is `Add-Migration <migration name>`. When we operate on an existing database,
    we must add the `-IgnoreChanges` option to the first migration (and just to that)
    so that an empty migration is created. References to the whole set of commands
    can be found in the *Further reading* section.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If, after having created the migration but before having applied the migration
    to the database, we realize we made some errors, we can undo our action with the
    `Remove-Migration` command. If the migration has already been applied to the database,
    the simplest way to correct our error is to make all the necessary changes to
    the code and then apply another migration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As soon as the `Add-Migration` command is executed, a new folder appears in
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Files created by the Add-Migration command'
  prefs: []
  type: TYPE_NORMAL
- en: '`20210924143018_initial.cs` is our migration expressed in an easy-to-understand
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: You may review the code to verify that everything is okay. You may also modify
    the migration content (only if you are enough of an expert to do it reliably)
    or simply undo the migration with the `in` `Remove-Migration Remove-Migration`
    command, which is the advised way to proceed when we discover errors.
  prefs: []
  type: TYPE_NORMAL
- en: Each migration contains an `Up` method and a `Down` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Up` method implies the migration, while the `Down` method undoes its changes.
    Accordingly, the `Down` method contains the reverse actions of all the actions
    included in the `Up` method in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: '`20210924143018_initial.Designer.cs` is the Visual Studio designer code, which
    you must not modify, while `MainDbContextModelSnapshot.cs` is the overall database
    structure snapshot. If you add further migrations, new migration files and their
    designer counterparts will appear, and the unique `MainDbContextModelSnapshot.cs`
    database structure snapshot will be updated to reflect the database’s overall
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: The same command can be issued in an operating system console by typing `dotnet
    ef migrations add initial`. This command must be issued from within the project’s
    root folder (not from within the solution’s root folder).
  prefs: []
  type: TYPE_NORMAL
- en: However, if `Microsoft.EntityFrameworkCore.Design` is installed globally with
    `dotnet tool install --global dotnet-ef`, then we can use it in a project after
    adding it to that project by typing `dotnet add package –-project <project path>
    Microsoft.EntityFrameworkCore.Design`. In this case, commands can be issued from
    any folder by specifying the `--project <project path>` option.
  prefs: []
  type: TYPE_NORMAL
- en: Migrations can be applied to the database by typing `Update-Database` in the
    Package Manager Console. The equivalent console command is `dotnet ef database
    update`. Let’s try using this command to create the physical database!
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how to create database stuff that Entity Framework
    is unable to create automatically. After that, in the next section, we will use
    Entity Framework’s configuration and the database we generated with `dotnet ef
    database update` to create, query, and update data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stored procedures and direct SQL commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some database structures, like, for instance, stored procedures, can’t be generated
    automatically by the Entity Framework Core commands and declarations we described
    previously. Stored procedures such as generic SQL strings can be included manually
    in the `Up` and `Down` methods through the `migrationBuilder.Sql("<sql command>")`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The safest way to do this is by adding a migration without performing any configuration
    changes so that the migration is empty when it’s created. Then, we can add the
    necessary SQL commands to the empty `Up` method of this migration and their converse
    commands in the empty `Down` method. It is good practice to put all the SQL strings
    in the properties of resource files (`.resx` files).
  prefs: []
  type: TYPE_NORMAL
- en: 'Stored procedures should replace `Entity` `Framework` commands in the following
    circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: When we need to perform manual SQL optimizations to increase the performance
    of some operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `Entity` `Framework` doesn’t support the SQL operation, we need to perform.
    A typical example is the increment or decrement of a numeric field that occurs
    in all booking operations (air travel, hotels, and so on). Actually, we might
    replace the increment/decrement operation with a database read, an in-memory increment/decrement,
    and finally, a database update, all enclosed in the same transaction scope. However,
    this might be overkill for performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before starting to interact with our database, we can perform a further optional
    step: model optimizations.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiled models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from version 6, Entity Framework Core introduced the possibility to
    create precompiled data structures that improve Entity Framework Core’s performance
    by about 10 times in the case of models with hundreds of entities (see the reference
    in the *Further reading* section for more details). This step is accomplished
    by generating some code that, once compiled together with the data layer project,
    creates data structures that our context classes can use to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of pre-compilation is advised just after you verify the system experiences
    slow-downs and also on very simple queries. In other words, it is better to start
    without pre-compilation and then possibly add it in case of slow-downs caused
    by the EF infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code is generated with the `Optimize-DbContext` command provided by the `Microsoft.EntityFrameworkCore.Tool`
    NuGet package that we already installed. The command accepts the folder name to
    place the code and the namespace to place all classes. In our case, let’s choose
    the `Optimization` folder and the `WWTravelClubDB.Optimization` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `–Context` parameter must be passed the name of our context class.
    The `Optimization`folder is automatically created and filled with classes.
  prefs: []
  type: TYPE_NORMAL
- en: The optimization code depends on the ORM configuration, so the `Optimize-DbContext`
    command must be repeated each time a new migration is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimizations are enabled by passing the root of our optimization model as
    an option when an instance of the context class is created. Let’s open the `LibraryDesignTimeDbContextFactory.cs`
    file and add the line below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are ready to interact with the database through Entity Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: Querying and updating data with Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our DB layer, we need to add a console project based on the same .NET
    Core version as our library to the solution. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s call the new console project `WWTravelClubDBTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to add our data layer as a dependency of the console project by
    right-clicking on the **Dependencies** node of the console project and selecting
    **Add Project Reference**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the content of the `Program.cs` file and start by writing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following namespaces at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have finished preparing our test project, we can experiment with
    queries and data updates. Let’s start by creating some database objects, that
    is, some destinations and packages. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create an instance of our `DbContext` subclass with an appropriate
    connection string. We can use the same `LibraryDesignTimeDbContextFactory` class
    that’s used by the design tools to get it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New rows can be created by simply adding class instances to the mapped collections
    of our `DbContext` subclass. If a `Destination` instance has packages associated
    with it, we can simply add them to its `Packages` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no need to specify primary keys since they are auto-generated and will
    be filled in by the database. In fact, after the `SaveChangesAsync()` operation
    synchronizes our context with the actual DB, the `firstDestination.Id` property
    has a non-zero value. The same is true for the primary keys of `Package`. Key
    auto-generation is the default behavior for all integer types.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we declare that an entity (in our case, `Package`) is a child of another
    entity (in our case, `Destination`) by inserting it in a parent entity collection
    (in our case, the `Packages` collection), there is no need to explicitly set its
    external key (in our case, `DestinationId`) since it is inferred automatically
    by Entity Framework Core. Once created and synchronized with the `firstDestination`
    database, we can add further packages in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Package` class instance, set its `DestinationId` external key to `firstDestination.Id`,
    and add it to `context.Packages`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `Package` class instance, with no need to set its external key, and
    then add it to the `Packages` collection of its parent `Destination` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter approach should be preferred when the two entities do not belong
    to the same aggregate since, in this case, the whole aggregate must be loaded
    in memory before operating on it to be sure all business rules are correctly applied
    and to prevent incoherences caused by simultaneous operations on different parts
    of the same aggregates (see the *Aggregates* subsection of *Chapter 7, Understanding
    the Different Domains in Software Solutions*).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the latter option is the only possibility when a child entity (`Package`)
    is added with its parent entity (`Destination`) and the parent entity has an auto-generated
    principal key since, in this case, the external key isn’t available at the time
    we perform the additions.
  prefs: []
  type: TYPE_NORMAL
- en: In most of the other circumstances, the former option is simpler since the second
    option requires the parent `Destination` entity to be loaded in memory, along
    with its `Packages` collection, that is, together with all the packages associated
    with the `Destination` object (by default, connected entities aren’t loaded by
    queries).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say we want to modify the `Florence` destination and give a 10%
    increment to all `Florence` package prices. How do we proceed? Follow these steps
    to find out how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, comment out all previous instructions for populating the database while
    keeping the `DbContext` creation instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we need to load the entity into memory with a query, modify it, and call
    `await SaveChangesAsync()` to synchronize our changes with the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to modify, say, just its description, a query such as the following
    is enough:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to load all the related destination packages that are not loaded by
    default. This can be done with the `Include` clause, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can modify the description and package prices, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If entities included with the `Include` method themselves contain a nested
    collection we would like to include, we can use `ThenInclude`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Entity Framework always tries to translate each LINQ into a single SQL
    query, sometimes the resulting query might be too complex and slow. In such cases,
    starting from version 5, we can give Entity Framework the permission to split
    the LINQ query into several SQL queries, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Performance issues can be addressed by inspecting the SQL generated by a LINQ
    query with the help of the `ToQueryString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting from version 5, the included nested collection can also be filtered
    with `Where`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So far, we’ve performed queries whose unique purpose is to update the retrieved
    entities. Next, we will explain how to retrieve information that will be shown
    to the user and/or used by complex business operations.
  prefs: []
  type: TYPE_NORMAL
- en: Returning data to the presentation layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep the layers separated and to adapt queries to the data that’s actually
    needed by each *use case*, DB entities aren’t sent as they are to the presentation
    layer. Instead, the data is projected into smaller classes that contain the information
    that’s needed by the *use case*. These are implemented by the presentation layer’s
    `caller` method. Objects that move data from one layer to another are called **Data
    Transfer Objects** (**DTOs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s create a DTO containing the summary information that is
    worth showing when returning a list of packages to the user (we suppose that,
    if needed, the user can get more details by clicking the package they are interested
    in):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a DTO to our `WWTravelClubDBTest` project that contains all the information
    that needs to be shown in a list of packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don’t need to load entities in memory and then copy their data into the DTO,
    but database data can be projected directly into the DTO, thanks to the LINQ `Select`
    clause. This minimizes how much data is exchanged with the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, we can populate our DTOs with a query that checks all the packages
    that are available around August 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Select` clause, we can also navigate to any related entities to get
    the data we need. For instance, the preceding query navigates to the related `Destination`
    entity to get the `Package` destination name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The programs stop at each `Console.ReadKey()` method, waiting for you to hit
    any key. This way, you have time to analyze the output that’s produced by all
    the code snippets that we added to the `Main` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the `WWTravelClubDBTest` project in Solution Explorer and
    set it as the start project. Then, run the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will learn how to handle operations that can’t be efficaciously mapped
    to the immediate operations in the in-memory collections that represent the database
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing direct SQL commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all database operations can be executed efficiently by querying the database
    with LINQ and updating in-memory entities. For instance, counter increments can
    be performed more efficiently with a single SQL instruction. Moreover, some operations
    can be executed with acceptable performance if we define adequate stored procedures/SQL
    commands. In these cases, we are forced to either issue direct SQL commands to
    the database or call database-stored procedures from our Entity Framework code.
    There are two possibilities: SQL statements that perform database operations but
    do not return entities, and SQL statements that do return entities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL commands that don’t return entities can be executed with the `DbContext`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Parameters can be referenced in the string as `{0}, {1}, ..., {n}`. Each `{m}`
    is filled with the object contained at the `m` index of the `parameters` array,
    which is converted from a .NET type into the corresponding SQL type. The method
    returns the number of affected rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL commands that return collections of entities must be issued through the
    `FromSqlRaw` method of the mapped collection associated with those entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, for instance, a command that returns `Package` instances would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL strings and parameters work like this in the `ExecuteSqlRaw` method. The
    following is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use string interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In case the objects to be returned by the SQL query are not mapped objects
    represented by a collection added to the DB context, like `context.Packages`,
    we can use a new method added in .NET 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`SqlQueryRaw` is a method of the `Database` property of the `DbContext` object,
    and it accepts the class of the objects to return as a generic parameter (`TResult`).
    However, in this case, Entity Framework Core is able to transform the SQL tuples
    returned by the database into objects only if the column names in the tuples are
    equal to the property names in `TResult`. Name mismatches in some properties can
    be overcome by decorating these properties with the names of the columns they
    must be mapped from with the `[Column("<column name")]` attribute. This is also
    possible using fluent API configuration: `.HasColumnName(<column name")`.'
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to put all the SQL strings in resource files and encapsulate
    all the `ExecuteSqlRawAsync` and `FromSqlRaw` calls inside the public methods
    that you defined in your `DbContext` subclasses, in order to keep the dependence
    from a specific database inside of your Entity Framework Core-based data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Handling transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the changes that are made to a `DbContext` instance are passed in a single
    transaction at the first `SaveChangesAsync` call. However, sometimes, it is necessary
    to include queries and updates in the same transaction. In these cases, we must
    handle the transaction explicitly. Several Entity Framework Core commands can
    be included in a transaction if we put them inside a `using` block associated
    with a transaction object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `context` is an instance of our `DbContext` subclass.
    Inside the `using` block, the transaction can be aborted and committed by calling
    its `Rollback` and `Commit` methods. Any `SaveChanges` calls that are included
    in the transaction block use the transaction they are already in, instead of creating
    new ones.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your data layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your database layer is deployed in production or in staging, usually, an
    empty database already exists, so you must apply all the migrations in order to
    create all the database objects. This can be done by calling `context.Database.Migrate()`.
    The `Migrate` method applies the migrations that haven’t been applied to the databases
    yet, so it may be called safely several times during the application’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: '`context` is an instance of our `DbContext` class that must be passed through
    a connection string with enough privileges to create tables and perform all the
    operations included in our migrations. Thus, typically, this connection string
    is different from the string we will use during normal application operations.'
  prefs: []
  type: TYPE_NORMAL
- en: During the deployment of a web application on Azure, we are given the opportunity
    to check migrations with a connection string we provide. We can also check migrations
    manually by calling the `context.Database.Migrate()` method when the application
    starts. This will be discussed in detail in *Chapter 18*, *Implementing Frontend
    Microservices with ASP.NET Core*, which is dedicated to frontend applications
    based on ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: In some production environments, it is not possible to apply migrations during
    the application deployment because the person in charge of the deployment doesn’t
    have enough privileges to create a new database and/or to create and modify tables.
    In this case, we must transform migrations into SQL commands and pass them to
    the database administrator who, after having verified they will not damage the
    existing database and data, applies them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transform all migrations in a given interval into SQL with the `Script-Migration`
    command (see [https://learn.microsoft.com/en-us/ef/core/cli/powershell](https://learn.microsoft.com/en-us/ef/core/cli/powershell)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For desktop applications, we can apply migrations during the installation of
    the application and its subsequent updates.
  prefs: []
  type: TYPE_NORMAL
- en: At the first application installation and/or in subsequent application updates,
    we may need to populate some tables with initial data. For web applications, this
    operation can be performed at application startup, while for desktop applications,
    this operation can be included in the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database tables can be populated with Entity Framework Core commands. First,
    though, we need to verify whether the table is empty in order to avoid adding
    the same table rows several times. This can be done with the `Any()` LINQ method,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at a few advanced features that Entity Framework Core has
    to share.
  prefs: []
  type: TYPE_NORMAL
- en: How data and domain layers communicate with other layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in *Chapter 7, Understanding the Different Domains in Software
    Solutions*, classical layer architectures use plain objects and repositories to
    communicate with the other layers.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the entities that define Entity Framework Core configuration themselves
    can be used as they are to communicate with other layers, since they are just
    record-like lists of public properties, as prescribed for plain objects.
  prefs: []
  type: TYPE_NORMAL
- en: The case of domain layers and onion architectures is slightly more complex,
    since, in this case, the domain layer communicates with the application layer
    through rich objects whose methods represent application domain rules. Accordingly,
    in general, the remainder of the application can’t access all domain layer objects’
    properties but is forced to modify them through their own methods, in order to
    enforce domain rules.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Entity Framework entities are record-like lists of public properties
    with almost no methods, while DDD entities should have methods that encode domain
    logic, more sophisticated validation logic, and read-only properties. While further
    validation logic and methods can be added without breaking Entity Framework’s
    operations, adding read-only properties that must not be mapped to database properties
    can create problems that must be handled adequately. Preventing properties from
    being mapped to the database is quite easy–all we need to do is decorate them
    with the `NotMapped` attribute or, using the fluent API, as `.Ignore(e => e.PropertyName).`
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues that read-only properties have are a little bit more complex and
    can be solved in three fundamental ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Map Entity Framework entities to different classes**: Define the DDD entities
    as different classes and copy data to/from them when entities are returned/passed
    to repository methods. This is the easiest solution, but it requires that you
    write some code so that you can convert the entities between the two formats.
    DDD entities are defined in the domain layer, while the Entity Framework entities
    continue to be defined in the data layer. This is the cleaner solution, but it
    causes a non-trivial overhead in both code writing and maintenance. I recommend
    it when you have complex aggregates with several complex methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map table fields to private properties**: Let Entity Framework Core map fields
    to private class fields so that you can decide how to expose them to properties
    by writing custom getters and/or setters. It is sufficient to give either the
    `_<property name>` name or the `_<property name in camel case>` name to these
    private fields, and Entity Framework will use them instead of their associated
    properties. In this case, DDD entities defined in the domain layer are also used
    as data layer entities. The main disadvantage of this approach is that we can’t
    use data annotations to configure each property because DDD entities can’t depend
    on how the underlying data layer is implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we must configure all database mapping in the `OnModelCreating` `DbContext`
    method, or in configuration classes associated with each entity (see *Chapter
    13*, *Interacting with Data in C# – Entity Framework Core*). Both options look
    less readable than data annotations to me, so I don’t like this technique, but
    other professionals use it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hide Entity Framework entities behind interfaces**: Hide each Entity Framework
    entity with all its public properties behind an interface that, when needed, only
    exposes property getters. Entities are defined as `internal` so outer layers can
    access them just through the interfaces they implement. This way, we can force
    the usage of methods that implement business logic rules to modify entity properties.
    Also, `DbContext` is defined as `internal`, so it can be accessed through the
    `IUnitOfWork` interface that it implements from the outer levels. Interfaces can
    be defined in a different library for better decoupling from the outer layers.
    In terms of the onion architecture, the library that defines all interfaces is
    the next layer in from the Entity Framework layer. As usual, interfaces are coupled
    with their implementations in the dependency injection engine. This is the solution
    I prefer when there are several simple entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s suppose that we would like to define a DDD interface called `IDestination`
    for the `Destination` entity, and suppose we would like to expose the `Id`, `Name`,
    and `Country` properties as read-only since, once a destination is created, it
    can’t be modified anymore. Here, it is sufficient to let `Destination` implement
    `IDestination` and to define `Id`, `Name`, `Country`, and `Description` as read-only
    in `IDestination`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Another difference between DDD with onion architectures and a classical data
    layer is that, in classical data layers, all operations and queries on data are
    exposed as repository methods, while in domain layers, repository methods just
    encode creations, deletions, and queries, while modification operations are performed
    by methods of the rich domain layer classes.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example of domain layer implementation is described in *Chapter 18*,
    *Implementing Frontend Microservices with ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Entity Framework Core advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting Entity Framework advanced feature that is worth mentioning is
    global filters, which were introduced at the end of 2017\. They enable techniques
    such as soft delete and multi-tenant tables that are shared by several users,
    where each user just *sees* its records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Global filters are defined with the `modelBuilder` object, which is available
    in the `DbContext` `OnModelCreating` method. The syntax for this method is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, if we add an `IsDeleted` property to our `Package` class, we
    may soft delete a `Package` without removing it from the database by defining
    the following filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, filters contain `DbContext` properties. Thus, for instance, if we
    add a `CurrentUserID` property to our `DbContext` subclass (whose value is set
    as soon as a `DbContext` instance is created), then we can add a filter like the
    following one to all the entities that refer to a user ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding filter in place, the currently logged-in user can only access
    the documents they own (the ones that have their `UserId`). Similar techniques
    are very useful in the implementation of multi-tenant applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature that is worth mentioning is mapping entities to
    un-updatable database queries, which was introduced in version 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define an entity, you can define explicitly either the name of the
    mapped database table or the name of a mapped updatable view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When an entity is mapped to a view, no table is generated by database migration,
    so the database view must be defined manually by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the view we would like to map our entity in is not updatable, LINQ cannot
    use it to pass updates to the database. In this case, we can map the same entity
    simultaneously to a view and a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Entity Framework will use the view for the queries and the table for the updates.
    This is useful when we create a newer version of a database table but we want
    to also take data from the old version of the table in all queries. In this case,
    we may define a view that takes data from both the old and the new tables but
    passes all updates only on the new table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The option to set property defaults is also interesting. This can be done by
    specifying an override for the `ConfigureConventions` `DbContext` method. For
    instance, we can set a default precision for all decimal properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying a default maximum length for all string properties is also useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting feature that was gradually introduced in the last versions
    of Entity Framework Core is the mapping of JSON database columns. In particular,
    JSON data contained in a single JSON column can be queried, and the JSON objects
    mapped to .NET types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that an `Author` class that must be mapped to a database table has
    a `Contact` property containing a complex object, and suppose we would like to
    store this object in a database JSON column of the `Author` table. We can do it
    with the help of the `OwnsOne` configuration method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After this configuration, the `contact` object can be queried as a standard
    navigation property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can recursively also map sub-objects contained in the `contact` object,
    such as a collection of addresses, but in this case, we must use `OwnsMany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the nested Addresses JSON collection can also be queried with the
    usual LINQ syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The above query returns all authors with a nonempty addresses list.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the essentials of ORM basics and why they are
    so useful. Then, we described Entity Framework Core. In particular, we discussed
    how to configure database mappings with class annotations and other declarations
    and commands that are included in `DbContext` subclasses, and in configuration
    classes associated with each entity.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed how to create data structures for improving ORM performance
    and how to automatically create and update the physical database with the help
    of migrations, as well as how to query and pass updates to the database through
    Entity Framework Core. Finally, we learned how to pass direct SQL commands and
    transactions through Entity Framework Core, as well as how to deploy a data layer
    based on Entity Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also reviewed some advanced features that were introduced in the
    latest Entity Framework Core releases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we move on to microservices orchestrators and will learn
    how to deploy and manage microservices on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Entity Framework Core adapt to several different database engines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are primary keys declared in Entity Framework Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a string field’s length declared in Entity Framework Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are indexes declared in Entity Framework Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are relations declared in Entity Framework Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two important migration commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, are related entities loaded by LINQ queries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to return database data in a class instance that isn’t a database
    entity? If yes, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are migrations applied in production and staging?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More details about migration commands can be found at [https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index](https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index)
    and the other links contained there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details about Entity Framework Core compiled models can be found in the
    official Microsoft documentation: [https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models](https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details about Entity Framework Core can be found in the official Microsoft
    documentation: [https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An exhaustive set of examples of complex LINQ queries can be found here: [https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/](https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
