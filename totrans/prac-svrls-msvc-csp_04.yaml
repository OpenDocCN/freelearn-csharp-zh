- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions and Triggers Available
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first three chapters of the book covered the background of serverless and
    microservices, focusing on how to use these technologies to design an application
    that works with a microservice-based architecture. This and the following chapters
    will go deep into the options you have for writing code for this, using the car-sharing
    example presented in [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038), *Demystifying
    Microservices Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, in this chapter, we will present the different triggers available
    in Azure Functions. The point here is not just to write about it, but to also
    test it with each of the triggers presented. In [*Chapter 1*](Chapter_1.xhtml#_idTextAnchor022),
    *Demystifying Serverless Application*, we covered its basis, but we did not have
    the opportunity to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on three important triggers that we can use when
    implementing Azure Functions – the HTTP, SQL, and Cosmos DB triggers. Together
    with their implementation, we will discuss their advantages, disadvantages, and
    when they are a good approach to be used. We will also see how they work using
    the car-sharing example as a basis for understanding the purpose of each trigger
    better. Let’s start!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free *Community edition* of Visual Studio 2022, or
    Visual Studio Code. You will also need an Azure account to create the sample environment.
    You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  prefs: []
  type: TYPE_NORMAL
- en: HTTP trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most used trigger in Azure Functions is certainly the HTTP trigger. The
    basis of this option is to enable you to have HTTP requests, so you can build
    APIs, webhooks, and integrations in a very fast way. The idea is that a method
    in Azure Functions is triggered as soon as an HTTP request is made, enabling the
    appropriate function to return the corresponding response.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages, disadvantages, and when to use the HTTP trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main advantage of the HTTP trigger is its ease of use. It is straightforward
    to implement and can be set up quickly. So, even if you are new to Azure Functions,
    you can get started with it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, it supports multiple HTTP methods, such as `GET`, `POST`, `PUT`,
    and `DELETE`, allowing you to handle a variety of web requests and actions. You
    can also have more than one function running on the same application, so it is
    a great way of delivering a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Another great advantage of HTTP triggers is that they can integrate with other
    Azure services and third-party APIs, so you can handle complex logic. All these
    benefits come on top of the scalability and cost-effectiveness delivered by Azure
    Functions, so your application will remain responsive under high traffic and you
    will only pay for the executions that you carry out.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to security, HTTP triggers enable us to implement different levels
    of authorization. These levels range from anonymous access up to the admin level,
    as described in the `AuthorizationLevel` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Authorization level – source: Microsoft Learn](img/B31916_04_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Authorization level – source: Microsoft Learn'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that these keys are managed inside an Azure Functions
    app, as we can see in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Azure Functions – App keys](img/B31916_04_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Azure Functions – App keys'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the disadvantages of HTTP triggers, there is what is called
    **cold-start latency**, where there must be a delay the first time the function
    is invoked after a period of inactivity. Also, you must consider that the idea
    of this kind of application is to deliver stateless solutions, so handling stateful
    operations or long-running processes can be more challenging with HTTP triggers
    alone. For this, you may consider using Azure Durable Functions.
  prefs: []
  type: TYPE_NORMAL
- en: You may also encounter some resource limits, such as execution timeouts and
    memory used, but these limits usually mean that you are encountering a design
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Considering all the information provided, the HTTP trigger is best used in scenarios
    where you need to create lightweight, stateless functions that respond to web
    requests. This may include RESTful APIs to expose an application’s functionality
    or a microservice, webhooks for handling real-time notifications, or even drive
    integrations. HTTP triggers can also be great for rapidly testing a scenario,
    using it as a prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing HTTP trigger example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038), *Demystifying
    Microservices Applications*, the carholders’ requests can be called by a user
    throughout CRUD operations. The sample code provided in this chapter will give
    you an Azure Functions project with four HTTP trigger functions that represent
    these CRUD operations. Also, it is important to mention that today it is good
    practice to deliver APIs with OpenAPI documentation attached. To do so, this example
    will make use of the **OpenAPI extension for Azure Functions**. The result can
    be seen in the following figure, where we have described each Azure Functions
    HTTP trigger created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Car Holding API sample](img/B31916_04_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Car Holding API sample'
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about delivering APIs with this pattern is that you will be
    following the most common scenarios of APIs that the current industry is requesting.
    Also, delivering versioned APIs is considered a great practice to follow, so you
    can guarantee compatibility with other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages, disadvantages, and when to use the Azure SQL trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine the possibility of having a function trigger as soon as an Azure SQL
    Database change happens. This is where the Azure SQL trigger can help you. With
    the possibility of monitoring rows that are inserted, updated, or deleted, this
    function is invoked as soon as the event happens, enabling real-time data processing
    and integration.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that this trigger is only available if you have SQL
    Server change tracking enabled in your database and in the table that you define
    to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Considering this possibility, real-time processing using this functionality
    is a great advantage. Since Azure Functions in general is a great way of achieving
    scalability only when needed, this functionality also gives us great architecture
    with great cost-efficiency, allowing us to integrate different scenarios and applications
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you need to pay attention to the complexity of setting these
    triggers. You must consider what will be easier to design, a timer trigger monitoring
    your data or the option provided by this kind of trigger. Latency can also be
    a problem, so be careful with that.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, the Azure SQL trigger is great to use in real-time data processing,
    where database changes can be critical to some operations. If you want to synchronize,
    audit, or even transform data, this can also be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing SQL trigger example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this demo, an Azure SQL database was created called `CarShareDB`. In addition,
    a table called `Carholder` was also created, and both the database and table were
    enabled to track their changes, as you can see in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The idea behind this kind of Azure function is to be able to audit the changes
    made in the table that is being tracked. So, an Azure function with a SQL trigger
    was created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important things to observe in this code. The first one is
    that this Functions app needs a variable called `WEBSITE_SITE_NAME`. This variable
    needs to be placed in the `local.settings.json` file for debugging locally and
    will be stored in the environment variables of the app when published. The code
    block shown below is the content of the `json` file we have mentioned, defining
    the `WEBSITE_SITE_NAME` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Second, there is a connection between the code and SQL Server using the `CarShareConnectionString`
    variable, which is stored in the local user secret, as we can see in the following
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Managing user secrets locally](img/B31916_04_4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Managing user secrets locally'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to observe is that you need to define the class that represents
    the entity that is monitored so that every single change made in the table will
    be triggered and the data related to the change will be available for usage. In
    the example that we are presenting, the class was named `Carholder`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Function trigger](img/B31916_04_5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Function trigger'
  prefs: []
  type: TYPE_NORMAL
- en: The result of each trigger can be checked above. Notice that inserts and updates
    are sent with the object totally filled, while deletes returns only the ID of
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages, disadvantages, and when to use the Cosmos DB trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that we have discussed the benefits and downsides when using
    Azure SQL triggers, we can also discuss Cosmos DB triggers. This is a powerful
    feature that allows you to execute serverless functions in response to changes
    in your Cosmos DB data. Regardless of whether the items are added, updated, or
    deleted in a Cosmos DB collection, the trigger will automatically invoke your
    function, which enables real-time data processing and integration.
  prefs: []
  type: TYPE_NORMAL
- en: Considering this scenario, it is important to mention that Azure Cosmos DB gives
    you more flexibility with the data you are handling since it enables non-structured
    data. For instance, suppose you want to process telemetry sent by the car that
    is being shared. This kind of data would be a bit strange to be handled in Azure
    SQL Database. On the other hand, using this data in Cosmos DB can be a good approach.
  prefs: []
  type: TYPE_NORMAL
- en: These great advantages can be analyzed together with some concerns that you
    may have while developing a solution using a Cosmos DB trigger. The most important
    one to consider is cost since Cosmos DB applications can be extremely expensive
    depending on the solution that is developed.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing Cosmos DB trigger example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For high performance and globally distributed data storage, suppose the car-sharing
    app uses Cosmos DB to store real-time car telemetry data, with user activity logs
    and location information.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows how an Azure Functions app was created to enable
    the connection to Azure Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Creating an Azure Cosmos DB trigger function](img/B31916_04_6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Creating an Azure Cosmos DB trigger function'
  prefs: []
  type: TYPE_NORMAL
- en: It is great to mention that there is an Azure Cosmos DB emulator that you can
    use to test and debug your solution, saving costs for this step of development.
    For that, you will need to install Docker. It is important to remember that this
    is an alternative for testing only; production environments must use Azure Cosmos
    DB itself.
  prefs: []
  type: TYPE_NORMAL
- en: However, it should also be noted that Visual Studio can also help you create
    your Azure Cosmos DB. As you can see in the following figure, there is a wizard
    where you can set the common variables needed to create the resource in your Azure
    account inside the Visual Studio environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Creating Azure Cosmos DB](img/B31916_04_7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Creating Azure Cosmos DB'
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes a while to create Azure Cosmos DB. Once this step is done, it is time
    to analyze exactly how the function trigger works. Notice that it also works based
    on the connecting string to the database and the information you want to monitor.
    In the case of the example, `car-telemetry` is being monitored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To test the function, you can use the user interface provided by Azure Cosmos
    DB in the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Inserting data into Azure Cosmos DB](img/B31916_04_8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Inserting data into Azure Cosmos DB'
  prefs: []
  type: TYPE_NORMAL
- en: The result can be checked by inserting a breakpoint in the code of the Azure
    function, where we can check that the data sent can be seen in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Azure Cosmos DB trigger](img/B31916_04_9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Azure Cosmos DB trigger'
  prefs: []
  type: TYPE_NORMAL
- en: Although the Azure Cosmos DB trigger is very similar to the Azure SQL trigger,
    it is important to mention that the Azure Cosmos DB trigger only monitors inserts
    and updates in Cosmos DB. So, if you need to monitor deletions, you will not have
    this option in this kind of trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Bus trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important components in a microservices solution is a service
    bus for enabling communication between the microservices. Azure Service Bus is
    one of the options presented on the market to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions provides two ways of connecting to Azure Service Bus. You can
    monitor a specific queue or a general topic. The concept behind the Azure Service
    Bus queue service is to deliver a solution that enables reliable communication
    between distributed applications and services. It operates on a **first-in, first-out**
    (**FIFO**) basis, ensuring that messages are processed in the order they were
    sent. If you need to decouple an application, enhance scalability, and maintain
    high availability by buffering messages during peak loads, you may decide to use
    it. It is important to remember that messages sent to the queue are stored until
    they are retrieved and processed by the receiving application, guaranteeing delivery
    even in the face of transient failures. It is great to mention that the Service
    Bus queue supports features such as message sessions for ordered processing, dead-letter
    queues for handling message failures, and duplicate detection to prevent the processing
    of duplicate messages.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Azure Service Bus topics are designed for scenarios that
    require a publish/subscribe model. This feature enables multiple subscribers to
    receive copies of the same message, allowing for greater flexibility and scalability
    in your messaging infrastructure. With topics, you can filter messages based on
    specific criteria, ensuring that each subscriber only receives the messages relevant
    to them. This is particularly useful in complex workflows where different components
    or services need to react to different types of events.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Service Bus trigger also enables scalability, reliability, integration,
    and flexibility for your solution, since this is something delivered by default
    for any Azure function. As a point of concern, again, the cost must be considered.
    It is worth noting that queues are cheaper than topics, so you may analyze if
    topics are really needed for your solution. Also, do not forget to check that
    the performance you need for your application will not be degraded with the service
    bus you have selected.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Service Bus trigger can be used when you are developing an event-driven
    solution and you want to process messages or even design a workflow automation.
    For instance, in the car-sharing example, we will use the trigger to represent
    when someone is searching for a car.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with the Kafka trigger and the RabbitMQ trigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Azure Functions Service Bus trigger, Kafka trigger, and RabbitMQ trigger
    all serve similar purposes. However, depending on the scenario you are working
    on, you may decide to select a different bus.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Kafka is well known for scenarios where distributed streaming is
    required, and where you will have high throughput with real-time data processing.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, RabbitMQ is easier to use, and it is better for lightweight
    and flexible messages, especially if you need compatibility with multiple messaging
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Bus is well integrated with Azure services, although it supports
    various message patterns. If you need reliable delivery and processing, this may
    be the best option.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each of these buses has its advantages and is suited for different
    types of applications. The triggers available in Azure Functions for them are
    very similar, so choosing the right trigger depends more on the specific requirements
    of the application you are designing.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing example with the Azure Service Bus trigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Azure Service Bus trigger is used in our example for the subscription of
    the message that indicates a car-seeking request. The idea behind using a topic
    here is that many microservices of the solution may want to know that a car-seeking
    request is being made. The service that we are simulating in the example is the
    one that will start the route planner for the car that is needed, as we can see
    in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Route handling subsystem of a car-sharing application](img/B31916_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Route handling subsystem of a car-sharing application'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, an Azure function for monitoring the Service Bus trigger in the topic
    `car-seeking-requests` is created. The messages that are subscribed from this
    topic are the ones named `routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once a message is sent for a route, the function is automatically triggered,
    and all the information presented in the body of the message, together with information
    about the content type of the message and its ID, is available in the Azure function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Message triggered after Azure Service Bus received the content](img/B31916_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Message triggered after Azure Service Bus received the content'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that once the message is processed by the Azure function,
    since there is no other subscriber, the message is cleared from the bus. It is
    also necessary to remember that if the function is not running, the bus service
    will retain them according to the settings configured in Azure Service Bus.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a comprehensive overview of various triggers available
    in Azure Functions, focusing on their advantages, disadvantages, and practical
    use cases. It then delved into specific triggers, starting with the HTTP trigger,
    which was highlighted for its ease of use and versatility in handling web requests.
    The support for multiple HTTP methods and integration with other Azure services
    were also advantages presented in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also covered Azure SQL triggers, emphasizing their real-time data
    processing capabilities and the requirement for SQL Server change tracking. Similarly,
    the Cosmos DB trigger was explained, with its benefits in handling non-structured
    data and real-time processing presented.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, the chapter compared the Azure Service Bus, Kafka, and RabbitMQ services,
    presenting a demo using an Azure Service Bus trigger for the car-sharing application
    presented in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the main advantages of using HTTP triggers in Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP triggers offer a straightforward and standardized way of exposing your
    functions as web endpoints, making it easy to create APIs and webhooks. They allow
    rapid development and integration with other web services and client applications,
    leveraging familiar HTTP methods and status codes for communication.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, HTTP triggers enable automatic scaling, so your functions can handle
    varying loads efficiently. This helps ensure that your applications remain responsive
    under fluctuating traffic while benefiting from a pay-as-you-go pricing model
    that optimizes costs.
  prefs: []
  type: TYPE_NORMAL
- en: What are some potential disadvantages of using HTTP triggers, and how can they
    be mitigated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One potential disadvantage is the occurrence of cold starts, particularly on
    the Consumption plan, which may cause delays during initial HTTP requests. Additionally,
    exposing functions via HTTP requires careful attention to security, as misconfigured
    endpoints could become vulnerable to unauthorized access or abuse.
  prefs: []
  type: TYPE_NORMAL
- en: These concerns can be mitigated by implementing strategies such as using Premium
    or Dedicated plans to reduce cold start delays, adding warm-up triggers, or enforcing
    robust authentication and authorization policies. Leveraging API Management or
    other gateway solutions can also help secure and manage HTTP-triggered functions
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: How does the Azure SQL trigger enable real-time data processing, and what are
    its requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although Azure Functions does not include a native SQL trigger, real-time data
    processing can be achieved by combining database change detection (using SQL change
    tracking or change data capture) with a function that polls or listens for changes.
    This approach enables the system to react to data modifications almost immediately,
    triggering processing workflows as soon as a change is detected.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, your Azure SQL database must have change tracking or CDC
    enabled, and you need to configure a reliable mechanism for querying changes at
    regular intervals. Proper connectivity, efficient query design, and handling of
    potential latency issues are key requirements for ensuring that real-time processing
    is both accurate and performant.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits and concerns associated with using Cosmos DB triggers
    in Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cosmos DB triggers provide near real-time processing of data changes by leveraging
    the Cosmos DB change feed. This integration allows your functions to automatically
    respond to new or updated documents, enabling event-driven workflows and scalable
    data processing without requiring manual polling.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are concerns such as potential throttling and cost implications
    if the throughput is not properly managed. Moreover, ensuring data consistency
    and handling high-volume change feeds can be challenging. These issues can be
    addressed through careful planning of request units (RUs), partitioning strategies,
    and monitoring the performance and load of your Cosmos DB account.
  prefs: []
  type: TYPE_NORMAL
- en: How do Azure Service Bus triggers compare with Kafka and RabbitMQ triggers,
    and in what scenarios are they best used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Service Bus triggers are part of a fully managed messaging service that
    offers features like reliable message delivery, dead-lettering, sessions, and
    auto-scaling. They integrate seamlessly with the Azure ecosystem, making them
    ideal for enterprise scenarios where robust, secure, and managed message processing
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, Kafka and RabbitMQ are often chosen for their high throughput (Kafka)
    or lightweight, flexible messaging (RabbitMQ) in environments where you might
    require more control over the infrastructure. Azure Service Bus triggers are best
    suited for scenarios that benefit from a managed service with deep integration
    into Azure, particularly when the application requires enterprise-level messaging
    reliability and scalability without the overhead of managing the messaging infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Function HTTP trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Function SQL trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-sql](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-sql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL Server change tracking: [https://learn.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server](https://learn.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions Cosmos DB trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions Service Bus trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Queue design pattern: [https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling](https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Publisher-Subscriber design pattern: https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storing secrets: [https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets](https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
