- en: Displaying Data with Core UI Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用核心UI元素显示数据
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Displaying a "Hello World" UI text message
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示“Hello World”UI文本消息
- en: Displaying a digital clock
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数字时钟
- en: Displaying a digital countdown timer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数字倒计时计时器
- en: Creating a message that fades away
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个逐渐消失的消息
- en: Displaying a perspective 3D Text Mesh
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示透视3D文本网格
- en: Creating sophisticated text with TextMeshPro
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TextMeshPro创建复杂的文本
- en: Displaying an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示图像
- en: Creating UIs with the Fungus open source dialog system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fungus开源对话框系统创建UI
- en: Creating a Fungus character dialog with images
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图像创建Fungus角色对话框
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A key element contributing to the entertainment and enjoyment of most games
    is the quality of the visual experience, and an important part of this is the
    **User Interface** (**UI**). UI elements involve ways for the user to interact
    with the game (such as buttons, cursors, and text boxes), as well as ways for
    the game to present up-to-date information to the user (such as the time remaining,
    current health, score, lives left, or location of enemies). This chapter is filled
    with UI recipes to give you a range of examples and ideas for creating game UIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数游戏娱乐和享受贡献关键因素的是视觉体验的质量，而这其中重要的部分是**用户界面**（**UI**）。UI元素包括用户与游戏交互的方式（例如按钮、光标和文本框），以及游戏向用户展示最新信息的方式（例如剩余时间、当前生命值、得分、剩余生命或敌人位置）。本章充满了UI食谱，为您提供一系列创建游戏UI的示例和想法。
- en: The big picture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体概念
- en: Every game is different, and so this chapter attempts to fulfill two key roles.
    The first aim is to provide step-by-step instructions on how to create a range
    of the Unity 2018 basic UI elements and, where appropriate, associate them with
    game variables in code. The second aim is to provide a rich illustration of how
    UI elements can be used for a variety of purposes so that you can get good ideas
    about how to make the Unity UI set of controls deliver the particular visual experience
    and interactions for the games that you are developing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都是不同的，因此本章试图完成两个关键角色。第一个目标是提供逐步指导，说明如何创建一系列Unity 2018基本UI元素，并在适当的情况下，将它们与代码中的游戏变量关联。第二个目标是提供丰富的示例，说明UI元素可以用于各种目的，以便您可以获得关于如何使Unity
    UI控件集为正在开发的游戏提供特定视觉体验和交互的灵感。
- en: The basic UI elements can provide static images and text to just make the screen
    look more interesting. By using scripts, we can change the content of these images
    and text objects, so that the players' numeric scores can be updated, or we can
    show stickmen images to indicate how many lives the player has left. Other UI
    elements are interactive, allowing users to click on buttons, choose options,
    enter text, and so on. More sophisticated kinds of UI can involve collecting and
    calculating data about the game (such as percentage time remaining or enemy hit
    damage; or the positions and types of key GameObjects in the scene, and their
    relationship to the location and orientation of the player), and then displaying
    these values in a natural, graphical way (such as progress bars or radar screens).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基本UI元素可以提供静态图像和文本，仅使屏幕看起来更有趣。通过使用脚本，我们可以更改这些图像和文本对象的内容，以便更新玩家的数字得分，或者我们可以显示棍人图像来指示玩家剩余的生命。其他UI元素是交互式的，允许用户点击按钮、选择选项、输入文本等。更复杂的UI类型可能涉及收集和计算有关游戏的数据（例如剩余时间的百分比或敌人击中伤害；或场景中关键游戏对象的位置和类型，以及它们与玩家位置和方向的关系），然后以自然、图形化的方式显示这些值（例如进度条或雷达屏幕）。
- en: 'Core GameObjects, components, and concepts relating to Unity UI development
    include:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 核心游戏对象、组件以及与Unity UI开发相关的概念包括：
- en: '**Canvas**: Every UI element is a child to a **Canvas**. There can be multiple
    **Canvas** GameObjects in a single scene. If a **Canvas** is not already present,
    then one will automatically be created when a new UI GameObject is created, with
    that UI object as the child to the new **Canvas** GameObject.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画布**：每个UI元素都是**画布**的子元素。单个场景中可以有多个**画布**游戏对象。如果一个**画布**尚未存在，那么在创建新的UI游戏对象时，将自动创建一个，该UI对象作为新**画布**游戏对象的子元素。'
- en: '**EventSystem**: An **EventSystem** GameObject is required to manage the interaction
    events for UI controls. One will automatically be created with the first UI element.
    Unity generally only allows one **EventSystem** in any Scene (some proposed code
    for multiple event systems can be found at [https://bitbucket.org/Unity-Technologies/ui/pull-requests/18/support-for-multiple-concurrent-event/diff](https://bitbucket.org/Unity-Technologies/ui/pull-requests/18/support-for-multiple-concurrent-event/diff)))'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件系统**：需要一个**事件系统**GameObject来管理UI控件的交互事件。当第一个UI元素被创建时，会自动创建一个。Unity通常在任何场景中只允许一个**事件系统**（一些支持多个并发事件系统的代码可以在[https://bitbucket.org/Unity-Technologies/ui/pull-requests/18/support-for-multiple-concurrent-event/diff](https://bitbucket.org/Unity-Technologies/ui/pull-requests/18/support-for-multiple-concurrent-event/diff)找到）。'
- en: '**Visual UI** **controls**: The visible UI controls themselves include **Button,
    Image, Text,** and **Toggle******.****'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉UI控件**：可见的UI控件包括**按钮**、**图像**、**文本**和**切换**。'
- en: '**The Rect Transform component**: UI GameObjects can exist in a different space
    from that of the 2D and 3D scenes, which cameras render. Therefore, UI GameObjects
    all have the special **Rect Transform** component, which has some different properties
    to the scene''s GameObject Transform component (with its straightforward X/Y/Z
    position, rotation, and scale properties). Associated with **Rect Transforms**
    are pivot points (reference points for scaling, resizing, and rotations) and anchor
    points.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩形变换组件**：UI GameObject可以存在于与2D和3D场景渲染的相机不同的空间中。因此，UI GameObject都拥有特殊的**矩形变换**组件，它具有与场景GameObject变换组件（具有其直接的X/Y/Z位置、旋转和缩放属性）不同的属性。与**矩形变换**相关的是中心点（缩放、调整大小和旋转的参考点）和锚点。'
- en: 'The following diagram shows the four main categories of UI controls, each in
    a **Canvas** GameObject and interacting via an **EventSystem** GameObject. UI
    Controls can have their own Canvas, or several UI controls can be in the same
    **Canvas.** The four categories are: **static** (display-only) and **interactive
    UI** controls, **non-visible** components (such as ones to group a set of mutually
    exclusive radio buttons), and **C# script** classes to manage UI-control behavior
    through logic written in the program code. Note that UI controls that are not
    a child or descendant of a Canvas will not work properly, and interactive UI controls
    will not work properly if the **EventSystem** is missing. Both the **Canvas**
    and **EventSystem** GameObjects are automatically added to the Hierarchy as soon
    as the first UI GameObject is added to a scene:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了UI控件的主要四个类别，每个类别都在一个**画布**GameObject中，并通过一个**事件系统**GameObject进行交互。UI控件可以有自己的画布，或者几个UI控件可以在同一个**画布**中。这四个类别是：**静态**（仅显示）和**交互式UI**控件、**不可见**组件（例如用于分组一组互斥的单选按钮的组件），以及通过程序代码中编写的逻辑来管理UI控件行为的**C#脚本**类。请注意，不是Canvas的子或后代的UI控件将无法正常工作，如果缺少**事件系统**，交互式UI控件也将无法正常工作。一旦将第一个UI
    GameObject添加到场景中，**画布**和**事件系统**GameObject就会自动添加到层次结构中：
- en: '![](img/4d81c94e-7e3e-4490-8aa6-5f39ee7e8660.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d81c94e-7e3e-4490-8aa6-5f39ee7e8660.png)'
- en: '**Rect Transforms** for UI GameObjects represent a rectangular area rather
    than a single point, which is the case for scene GameObject Transforms. **Rect
    Transforms** describe how a UI element should be positioned and sized relative
    to its parent. Rect Transforms have a width and height that can be changed without
    affecting the local scale of the component. When the scale is changed for the
    **Rect Transform** of a UI element, this will also scale font sizes and borders
    on sliced images, and so on. If all four anchors are at the same point, resizing
    the Canvas will not stretch the Rect Transform. It will only affect its position.
    In this case, we''ll see the Pos X and Pos Y properties, and the Width and Height
    of the rectangle. However, if the anchors are not all at the same point, Canvas
    resizing will result in stretching the element''s rectangle. So instead of the
    Width, we''ll see the values for Left and Right—the position of the horizontal
    sides of the rectangle to the sides of the **Canvas,** where the Width will depend
    on the actual Canvas width (and the same for Top/Bottom/Height).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rect Transforms** 用于 UI 游戏对象表示一个矩形区域，而不是单个点，这与场景 GameObject Transforms 的情况不同。**Rect
    Transforms** 描述了 UI 元素相对于其父元素应该如何定位和大小。**Rect Transforms** 具有可以更改的宽度和高度，而不会影响组件的局部缩放。当更改
    UI 元素的 **Rect Transform** 的缩放时，这也会缩放字体大小和切片图像的边框等。如果所有四个锚点都位于同一点，调整 **Canvas**
    大小不会拉伸 **Rect Transform**。它只会影响其位置。在这种情况下，我们将看到 Pos X 和 Pos Y 属性，以及矩形的宽度和高度。然而，如果锚点不在同一点，**Canvas**
    调整大小将导致元素矩形的拉伸。因此，我们将看到 Left 和 Right 的值——矩形的水平边相对于 **Canvas** 边的位置，其中宽度将取决于实际的
    **Canvas** 宽度（同样适用于 Top/Bottom/Height）。'
- en: 'Unity provides a set of preset values for pivots and anchors, making the most
    common values very quick and easy to assign to an element''s **Rect Transform**.
    The following screenshot shows the 3 x 3 grid that allows you quick choices about
    the left, right, top, bottom, middle, horizontal, and vertical values. Also, the
    extra column on the right offers horizontal stretch presets, and the extra row
    at the bottom offers vertical stretch presets. Using the *Shift*+*Alt *keys sets
    the pivot and anchors when a preset is clicked:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 为枢轴和锚点提供了一套预设值，使得最常见的值可以非常快速和容易地分配给元素的 **Rect Transform**。以下截图显示了 3 x
    3 的网格，它允许您快速选择左、右、上、下、中间、水平方向和垂直方向的值。此外，右侧的额外列提供了水平拉伸预设，底部额外的行提供了垂直拉伸预设。使用 *Shift*+*Alt *键在点击预设时设置枢轴和锚点：
- en: '![](img/d559845b-f490-409a-aa12-45c260f0f5dc.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d559845b-f490-409a-aa12-45c260f0f5dc.png)'
- en: 'The Unity manual provides a very good introduction to the **Rect Transform**.
    In addition, Ray Wenderlich''s two-part Unity UI web tutorial also presents a
    helpful overview of the Rect Transform, pivots, and anchors. Both parts of Wenderlich''s
    tutorial make great use of animated GIFs to illustrate the effect of different
    values for pivots and anchors:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 手册为 **Rect Transform** 提供了一个非常好的介绍。此外，Ray Wenderlich 的两篇 Unity UI 网络教程也提供了关于
    Rect Transform、枢轴和锚点的有用概述。Wenderlich 教程的两部分都很好地使用了动画 GIF 来说明枢轴和锚点不同值的效应：
- en: '[http://docs.unity3d.com/Manual/UIBasicLayout.html](http://docs.unity3d.com/Manual/UIBasicLayout.html)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/UIBasicLayout.html](http://docs.unity3d.com/Manual/UIBasicLayout.html)'
- en: '[http://www.raywenderlich.com/78675/unity-new-gui-part-1](http://www.raywenderlich.com/78675/unity-new-gui-part-1)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.raywenderlich.com/78675/unity-new-gui-part-1](http://www.raywenderlich.com/78675/unity-new-gui-part-1)'
- en: 'There are three **Canvas** render modes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种 **Canvas** 渲染模式：
- en: '**Screen Space: Overlay**: In this mode, the UI elements are displayed without
    any reference to any camera (there is no need for any **Camera** in the scene).
    The UI elements are presented in front of (overlaying) any sort of camera display
    of the scene contents.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕空间：叠加**：在此模式下，UI 元素显示时无需参考任何相机（场景中不需要任何 **Camera**）。UI 元素显示在场景内容显示的任何类型的相机之前（叠加）。'
- en: '**Screen Space**: **Camera**: In this mode, the **Canvas** is treated as a
    flat plane in the frustum (viewing space) of a **Camera** scene – where this plane
    is always facing the camera. So, any scene objects in front of this plane will
    be rendered in front of the UI elements on the **Canvas.** The **Canvas** is automatically
    resized if the screen size, resolution, or camera settings are changed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕空间**：**相机**：在此模式下，**Canvas** 被视为位于 **Camera** 场景视锥体（观察空间）中的平面——其中此平面始终面向相机。因此，位于此平面之前的所有场景对象都将渲染在
    **Canvas** 上的 UI 元素之前。如果屏幕大小、分辨率或相机设置发生变化，**Canvas** 将自动调整大小。'
- en: '**World Space**: In this mode, the **Canvas** acts as a flat plane in the frustum
    (viewing space) of a **Camera** scene – but the plane is not made to always face
    the **Camera.** How the **Canvas** appears is just as with any other objects in
    the scene, relative to where (if anywhere) in the camera''s viewing frustum the
    **Canvas** plane is located and oriented.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界空间**：在此模式下，**画布**作为**摄像机**场景视锥体内的一个平面——但该平面并非总是面向**摄像机**。**画布**的显示方式与场景中任何其他对象一样，相对于（如果有的话）在摄像机的视锥体内**画布**平面的位置和方向。'
- en: In this chapter, we have focused on the Screen Space:Overlay mode. But all these
    recipes can be used with the other two modes as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于屏幕空间：叠加模式。但所有这些配方也可以与其他两种模式一起使用。
- en: Be creative! This chapter aims to act as a launching pad of ideas, techniques,
    and reusable C# scripts for your own projects. Get to know the range of Unity
    UI elements, and try to work smart. Often, a UI element exists with most of the
    components that you may need for something in your game, but you may need to adapt
    it somehow. An example of this can be seen in the recipe that makes a UI Slider
    non-interactive, instead using it to display a red-green progress bar for the
    status of a countdown timer. See this in the *Displaying a countdown timer graphically
    with a UI Slider* recipe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 发挥创意！本章旨在作为想法、技术和可重用C#脚本发射台，用于您的项目。了解Unity UI元素的范围，并尝试聪明地工作。通常，一个UI元素已经包含了您可能需要的所有组件，但您可能需要对其进行某种调整。一个例子可以在使UI滑动条非交互式的配方中看到，它使用它来显示倒计时计时器的红色-绿色进度条。请参阅*使用UI滑动条图形显示倒计时计时器*配方。
- en: Many of these recipes involve C# script classes that make use of the Unity scene-start
    event sequence of `Awake()` to all game objects, `Start()` to all GameObjects,
    then `Update()` every frame to every GameObject. Therefore, you'll see many recipes
    in this chapter (and the whole book) where we cache references to GameObject components
    in the `Awake()` method, and then make use of these components in `Start()` and
    other methods, once the scene is up and running.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些配方都涉及使用Unity场景启动事件序列的C#脚本类，即`Awake()`对所有游戏对象，`Start()`对所有GameObject，然后每帧对每个GameObject调用`Update()`。因此，您将在本章（以及整本书）中看到许多配方，我们在`Awake()`方法中缓存GameObject组件的引用，然后在场景启动并运行后，在`Start()`和其他方法中使用这些组件。
- en: Displaying a "Hello World" UI text message
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示“Hello World”UI文本消息
- en: 'The first traditional problem to be solved with a new computing technology
    is to display the Hello World message. In this recipe, you''ll learn to create
    a simple UI Text object with this message, in large white text with a selected
    font, in the center of the screen:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新计算技术要解决的第一个传统问题是显示Hello World消息。在这个配方中，您将学习如何创建一个简单的UI Text对象，带有此消息，以选定的字体显示大号白色文本，位于屏幕中央：
- en: '![](img/a8d1df96-386a-406b-a0ab-a7146417ef98.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8d1df96-386a-406b-a0ab-a7146417ef98.png)'
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the font that you need in a folder named `Fonts`
    in the `01_01` folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`01_01`文件夹中的`Fonts`文件夹中准备了您需要的字体。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display a Hello World text message, follow these steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示“Hello World”文本消息，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Import the provided `Fonts` folder.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`Fonts`文件夹。
- en: 'In the Hierarchy panel, add a UI | Text GameObject to the scene—choose menu:
    GameObject | UI | Text. Name this GameObject `Text-hello`.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中，向场景添加一个UI | Text GameObject——选择菜单：GameObject | UI | Text。将此GameObject命名为`Text-hello`。
- en: 'Using the Create menu : Alternatively, use the Create menu immediately below
    the Hierarchy tab, choosing menu: Create | UI | Text.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用创建菜单：或者，使用位于层次结构标签下的创建菜单，选择菜单：创建 | UI | Text。
- en: Ensure that your new `Text-hello` GameObject is selected in the Hierarchy panel.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次结构面板中已选择新的`Text-hello`GameObject。
- en: 'Now, in the Inspector, ensure the following properties are set:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在检查器中，确保以下属性已设置：
- en: Text set to read `Hello World`
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本设置为读取`Hello World`
- en: Font set to `Xolonium-Bold`
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体设置为`Xolonium-Bold`
- en: Font size as per your requirements (large—this depends on your screen—try `50`
    or `100`)
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体大小根据您的需求设置（大——这取决于您的屏幕——尝试`50`或`100`）
- en: Alignment set to horizontal and vertical center
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐设置为水平和垂直居中
- en: '`Horizontal` and `Vertical Overflow` set to `Overflow`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平**和**垂直溢出**设置为**溢出**'
- en: '**Color** set to white'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**设置为白色'
- en: 'The following screenshot shows the **Inspector** panel with these settings:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了具有这些设置的**检查器**面板：
- en: '![](img/9858d847-95e5-4875-97e6-675ac47d9894.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9858d847-95e5-4875-97e6-675ac47d9894.png)'
- en: In the Rect Transform, click on the Anchor Presets square icon, which should
    result in several rows and columns of preset position squares appearing. Hold
    down  *Shift*+*Alt *and click on the center one (middlerow and center column).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Rect Transform**中点击锚点预设的方形图标，这将导致出现几行几列的预设位置方块。按住  *Shift*+*Alt *并点击中心的一个（中间行和 中心列）。
- en: The screenshot of the **Rect Transform** in the *Introduction* highlights the
    middle-center preset needed for this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*简介*中的**Rect Transform**截图突出了本菜谱所需的中间中心预设。
- en: Your Hello World text will now appear, centered nicely in the Game panel.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的Hello World文本现在将出现在游戏面板中，居中显示。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have added a new `Text-hello` GameObject to a scene. A parent Canvas and
    **UI EventSystem** will also have been automatically created.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将一个新的 `Text-hello` 游戏对象添加到场景中。同时，也会自动创建一个父级画布和**UI EventSystem**。
- en: You set the text content and presentation properties and used the Rect Transform
    anchor presets to ensure that whatever way the screen is resized, the text will
    stay horizontally and vertically centered.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您设置了文本内容和展示属性，并使用Rect Transform锚点预设来确保无论屏幕如何调整大小，文本都将保持水平和垂直居中。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some more details you don't want to miss.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些您不想错过的更多细节。
- en: Styling substrings with Rich Text
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用富文本样式化子字符串
- en: 'Each separate **UI Text** component can have its own color, size, boldness
    styling, and so on. However, if you wish to quickly add some highlighting style
    to part of a string to be displayed to the user, the following are examples of
    some of the HTML-style markups that are available without the need to create separate
    UI Text objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的**UI Text**组件都可以有自己的颜色、大小、粗体样式等。然而，如果您想快速为要显示给用户的字符串的一部分添加一些高亮样式，以下是一些不需要创建单独UI
    Text对象的HTML样式标记的示例：
- en: 'Embolden text with the "b" markup: I am `<b>bold</b>`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“b”标记加粗文本：我是 `<b>加粗</b>`
- en: 'Italicize text with the "i" markup: I am `<i>italic</i>`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“i”标记来斜体化文本：我是 `<i>斜体</i>`
- en: 'Set the text color with hex values or a color name: I am `<color=green>green`
    text `</color>`, but I am `<color=#FF0000>red</color>`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用十六进制值或颜色名称设置文本颜色：我是 `<color=green>绿色</color>` 文本 `</color>`, 但我是 `<color=#FF0000>红色</color>`
- en: Learn more from the Unity online manual's Rich Text page at [http://docs.unity3d.com/Manual/StyledText.html](http://docs.unity3d.com/Manual/StyledText.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity在线手册的富文本页面[http://docs.unity3d.com/Manual/StyledText.html](http://docs.unity3d.com/Manual/StyledText.html)了解更多信息。
- en: Displaying a digital clock
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示数字时钟
- en: Whether it is the real-world time, or an in-game countdown clock, many games
    are enhanced by some form of clock or timer display. The most straightforward
    type of clock to display is a string composed of the integers for hours, minutes,
    and seconds, which is what we'll create in this recipe.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是现实世界的时间，还是游戏中的倒计时时钟，许多游戏都通过某种形式的时钟或计时器显示来增强。最直接的时钟显示类型是由小时、分钟和秒的整数组成的字符串，这正是我们在本菜谱中要创建的。
- en: 'The following screenshot shows the kind of clock we will be creating in this
    recipe:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将在这个菜谱中创建的时钟类型：
- en: '![](img/2ece3c61-1197-4299-9e57-82aa47be3795.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ece3c61-1197-4299-9e57-82aa47be3795.png)'
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the font that you need in a folder named `Fonts`
    in the `01_01` folder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在`01_01`文件夹中的`Fonts`文件夹中准备了您需要的字体。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a digital clock, follow these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数字时钟，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Import the provided `Fonts` folder.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`Fonts`文件夹。
- en: In the **Hierarchy** panel, add a UI | Text game object to the scene named Text-clock.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将一个UI | Text游戏对象添加到场景中，命名为Text-clock。
- en: 'Ensure that the `Text-clock` GameObject is selected in the Hierarchy panel.
    Now, in Inspector, ensure that the following properties are set:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次结构面板中选择了`Text-clock` GameObject。现在，在检查器中，确保以下属性已设置：
- en: Text set to read as time goes here (this placeholder text will be replaced by
    the time when the scene is running)
  id: totrans-83
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本设置为随时间读取（此占位文本将在场景运行时被时间替换）
- en: Font type set to `Xolonium Bold`
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体类型设置为`Xolonium Bold`
- en: Font Size set to `20`
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体大小设置为`20`
- en: Alignment set to horizontal and vertical center
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐设置为水平和垂直居中
- en: Horizontal and Vertical Overflow settings set to `Overflow`
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平和垂直溢出设置设置为`Overflow`
- en: Color set to white
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色设置为白色
- en: In the **Rect Trans****form**, click on the Anchor Presets square icon, which
    will result in the appearance of several rows and columns of preset position squares.
    Hold down *Shift*+*Alt *and click on the top and center column rows.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Rect Trans****form** 中，点击锚点预设的方形图标，这将导致出现几行几列的预设位置方块。按住 *Shift*+*Alt *并点击顶部和中心的列行。
- en: 'Create a folder named `_Scripts` and create a C# script class called `ClockDigital`
    in this new folder:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `_Scripts` 的文件夹，并在该新文件夹中创建一个名为 `ClockDigital` 的 C# 脚本类：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Underscore prefix so items appear first in sequence
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线前缀使项目按顺序首先出现
- en: Since scripts and scenes are things that are most often accessed, prefixing
    their folder names with an underscore character, `_as _Scenes` and `_Scripts`, means
    they are always at the top in the Project panel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本和场景是最常访问的东西，因此使用下划线字符作为文件夹名称的前缀，即 `_as _Scenes` 和 `_Scripts`，意味着它们总是在项目面板的顶部。
- en: 'Although the preceding code is useful for illustrating how to access the time
    component of a `DateTime` object individually, the `Format(...)` method of the
    `String` class can be used to format a `DateTime` object all in a single statement,
    for example, the preceding could be written more succinctly in a single statement:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码对于说明如何单独访问 `DateTime` 对象的时间组件很有用，但 `String` 类的 `Format(...)` 方法可以用来在单个语句中格式化
    `DateTime` 对象，例如，前面的代码可以更简洁地写成一个语句：
- en: '`String.Format("HH:mm:ss", DateTime.Now)`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.Format("HH:mm:ss", DateTime.Now)`'
- en: For more examples, see[ http://www.csharp-examples.net/string-format-datetime/](http://www.csharp-examples.net/string-format-datetime/).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 想要查看更多示例，请参阅[http://www.csharp-examples.net/string-format-datetime/](http://www.csharp-examples.net/string-format-datetime/).
- en: Ensure the `Text-clock` GameObject is selected in the Hierarchy panel.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次结构面板中选择 `Text-clock` GameObject。
- en: 'In the Inspector panel, add an instance of the `ClockDigital` script class as
    a component by clicking the Add Component button, selecting Scripts, and choosing
    the `Clock Digital` script class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，通过点击添加组件按钮，选择脚本，然后选择 `Clock Digital` 脚本类，添加 `ClockDigital` 脚本类的实例作为一个组件：
- en: '![](img/4f1ae827-ed6c-4d5b-a530-d603a3ecc5a0.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f1ae827-ed6c-4d5b-a530-d603a3ecc5a0.png)'
- en: Add script components through drag and drop
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拖放添加脚本组件
- en: Script components can also be added to GameObjects via drag and drop. For example,
    with the `Text-clock` GameObject selected in the Hierarchy panel, drag your `ClockDigital`
    script onto it to add an instance of this script class as a component to the `Text-clock` GameObject.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本组件也可以通过拖放添加到 GameObject 中。例如，在层次结构面板中选择 `Text-clock` GameObject，将你的 `ClockDigital`
    脚本拖放到它上面，以将此脚本类的实例作为组件添加到 `Text-clock` GameObject。
- en: When you run the scene, you will now see a digital clock that shows hours, minutes,
    and seconds at the top-center part of the screen.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行场景时，你现在将看到一个数字时钟，显示在屏幕的顶部中央部分的小时、分钟和秒。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added a Text GameObject to a scene. You added an instance of the `ClockDigital`
    C# script class to that GameObject.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将一个 Text GameObject 添加到场景中。你已将 `ClockDigital` C# 脚本类的实例添加到该 GameObject。
- en: Notice that as well as the standard two C# packages (`UnityEngine` and `System.Collections`)
    that are written by default for every new script, you have added the using statements
    for two more C# script packages, `UnityEngine.UI` and `System`. The **UI package**
    is needed, since our code uses the UI Text object; and the `System` package is
    needed, since it contains the `DateTime` class that we need to access the clock
    on the computer where our game is running.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了默认为每个新脚本编写的标准两个 C# 包（`UnityEngine` 和 `System.Collections`）之外，你还添加了两个额外的
    C# 脚本包的 using 语句，即 `UnityEngine.UI` 和 `System`。**UI 包**是必需的，因为我们的代码使用了 UI 文本对象；而
    `System` 包是必需的，因为它包含我们需要的 `DateTime` 类，以便访问运行游戏的计算机上的时钟。
- en: There is one variable, `textClock`, which will be a reference to the `Text`
    component, whose text content we wish to update in each frame with the current
    time in hours, minutes, and seconds.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个变量，`textClock`，它将是一个对 `Text` 组件的引用，我们希望在每一帧中用当前的小时、分钟和秒来更新其文本内容。
- en: The `Awake()` method (executed when the scene begins) sets the `textClock` variable
    to be a reference to the `Text` component in the GameObject, to which our scripted
    object has been added. Storing a reference to a component in this way is referred
    to as caching—it means that code executed later does not need to repeat the computationally-expensive
    task of searching the GameObject hierarchy for a component of a particular type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()` 方法（在场景开始时执行）将 `textClock` 变量设置为对添加了我们的脚本对象的 GameObject 中的 `Text`
    组件的引用。以这种方式存储组件的引用称为缓存——这意味着稍后执行的代码不需要重复搜索 GameObject 层次结构以查找特定类型的组件的计算密集型任务。'
- en: Note that an alternative approach would be to make `textClock` a public variable.
    This will allow us to assign it via drag and drop in the Inspector panel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，另一种方法是将 `textClock` 设置为公共变量。这将允许我们在检查器面板中通过拖放来分配它。
- en: The `Update()` method is executed in every frame. The current time is stored
    in the time variable, and strings are created by adding leading zeros to the number
    values for the hours, minutes, and seconds properties of variable time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法在每一帧执行。当前时间存储在时间变量中，通过为时间变量的小时、分钟和秒属性添加前导零来创建字符串。'
- en: This method finally updates the text property (that is, the letters and numbers
    that the user sees) to be a string, concatenating the hours, minutes, and seconds
    with colon
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法最终将文本属性（即用户看到的字母和数字）更新为字符串，通过冒号连接小时、分钟和秒。
- en: separator characters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔字符。
- en: The `LeadingZero(...)` method takes as input an integer and returns a string
    of this number with leading zeros added to the left, if the value was less than
    `10`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeadingZero(...)` 方法接受一个整数作为输入，并返回一个字符串，如果该值小于 `10`，则在左侧添加前导零。'
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are some details you don't want to miss.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节您不要错过。
- en: The Unity tutorial for animating an analog clock
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 教程：如何动画模拟时钟
- en: Unity has published a nice tutorial on how to create 3D objects, and animate
    them through a C# script to display an analog clock, at [https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock](https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 发布了一个关于如何创建 3D 对象并通过 C# 脚本动画它们以显示模拟时钟的精彩教程，请参阅 [https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock](https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock)。
- en: Displaying a digital countdown timer
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示数字倒计时计时器
- en: 'This recipe will show you how to display a digital countdown clock, as shown
    here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将向您展示如何显示一个数字倒计时时钟，如下所示：
- en: '![](img/0d4de1c2-3df9-4fde-a244-410a751602e7.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d4de1c2-3df9-4fde-a244-410a751602e7.png)'
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe adapts the previous one. So, make a copy of the project for the
    previous recipe, and work on this copy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方修改了之前的配方。因此，请复制之前配方的项目，并在此副本上工作。
- en: For this recipe, we have prepared the script that you need in a folder named
    `_Scripts` in the `01_03` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此配方，我们在 `01_03` 文件夹中的 `_Scripts` 文件夹中准备了您需要的脚本。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create a digital countdown timer, follow these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数字倒计时计时器，请按照以下步骤操作：
- en: Import the provided `_Scripts` folder.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的相关 `_Scripts` 文件夹。
- en: In the Inspector panel, remove the scripted component, `ClockDigital`, from
    the `Text-clock` GameObject.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，从 `Text-clock` GameObject 中移除脚本组件 `ClockDigital`。
- en: In the Inspector panel, add an instance of the `CountdownTimer` script class as
    a component by clicking the `Add Component` button, selecting **Scripts,** and
    choosing the `CountdownTimer` script class.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，通过点击 `添加组件` 按钮，选择 **脚本**，然后选择 `CountdownTimer` 脚本类，添加 `CountdownTimer`
    脚本类的实例。
- en: 'Create a `DigitalCountdown` C# script class that contains the following code,
    and add an instance as a scripted component to the `Text-clock` GameObject:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的 `DigitalCountdown` C# 脚本类，并将其实例作为脚本组件添加到 `Text-clock` GameObject
    中：
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run the **Scene,** you will now see a digital clock counting down from
    30\. When the countdown reaches zero, the message countdown has finished will
    be displayed.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行 **场景** 时，您现在将看到一个从 30 开始倒计时的数字时钟。当倒计时达到零时，将显示消息“倒计时完成”。
- en: '**Automatically add components with** `[RequireComponent(...)]`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 `[RequireComponent(...)]` 自动添加组件**'
- en: The `DigitalCountdown` script class requires the same GameObject to also have
    an instance of the `CountdownTimer` script class. Rather than having to manually
    attach an instance of a require script, you can use the `[RequireComponent(...)]` C#
    attribute immediately before the class declaration statement. This will result
    in Unity automatically attaching an instance of the required script class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`DigitalCountdown` 脚本类要求同一个游戏对象也要有一个 `CountdownTimer` 脚本类的实例。而不是手动附加一个需要脚本的实例，您可以在类声明语句之前立即使用
    `[RequireComponent(...)]` C# 属性。这将导致 Unity 自动附加所需的脚本类实例。'
- en: 'For example, by writing the following, Unity will add an instance of `CountdownTimer`
    as soon as an instance of the `DigitalCountdown` script class has been added as
    a component of a GameObject:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过编写以下代码，Unity 将在 `DigitalCountdown` 脚本类实例作为游戏对象的组件添加后立即添加 `CountdownTimer`
    实例：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Learn more from the Unity documentation at [https://docs.unity3d.com/ScriptReference/RequireComponent.html](https://docs.unity3d.com/ScriptReference/RequireComponent.html).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 文档中了解更多信息，请访问 [https://docs.unity3d.com/ScriptReference/RequireComponent.html](https://docs.unity3d.com/ScriptReference/RequireComponent.html)。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have added instances of the `DigitalCountdown` and `CountdownTimer` C# script
    classes to your scene's UI Text GameObject.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将 `DigitalCountdown` 和 `CountdownTimer` C# 脚本类实例添加到场景的 UI Text 游戏对象中。
- en: The `Awake()` method caches references to the Text and `CountdownTimer` components
    in the `countdownTimer` and `textClock` variables. The `textClock` variable will
    be a reference to the **UI Text** component, whose text content we wish to update
    in each frame with a time-remaining message (or a timer-complete message).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()` 方法将 Text 和 `CountdownTimer` 组件的引用缓存到 `countdownTimer` 和 `textClock`
    变量中。`textClock` 变量将是一个指向 **UI Text** 组件的引用，我们希望在每一帧中用剩余时间消息（或计时器完成消息）更新其文本内容。'
- en: The `Start()` method calls the countdown timer object's `CountdownTimerReset(...)`
    method, passing an initial value of 30 seconds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法调用计时器对象的 `CountdownTimerReset(...)` 方法，并传递一个初始值为 30 秒的值。'
- en: The `Update()` method is executed in every frame. This method retrieves the
    countdown timer seconds remaining and stores this value as an integer (whole number)
    in the `timeRemaining` variable. This value is passed as a parameter to the `TimerMessage()`  method,
    and the resulting message is stored in the string (text) variable message. This
    method finally updates the text property (that is, the letters and numbers that
    the user sees) of the `textClock` UI Text GameObject to equal to the string message
    about the remaining seconds.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法在每一帧中执行。此方法检索剩余的计时器秒数，并将其作为整数（整数）存储在 `timeRemaining` 变量中。此值作为参数传递给
    `TimerMessage()` 方法，并将结果消息存储在字符串（文本）变量 `message` 中。此方法最终将 `textClock` UI Text
    游戏对象的文本属性（即用户看到的字母和数字）更新为剩余秒数的字符串消息。'
- en: The `TimerMessage()` method takes an integer as input, and if the value is zero
    or less, a message stating the timer has finished is returned. Otherwise (if greater
    than zero seconds remain) a message stating the number of remaining seconds is
    returned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimerMessage()` 方法接受一个整数作为输入，如果值为零或更小，则返回一个表示计时器已完成的消息。否则（如果剩余时间大于零秒），则返回一个表示剩余秒数的消息。'
- en: Creating a message that fades away
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个逐渐消失的消息
- en: Sometimes, we want a message to display just for a certain time, and then fade
    away and disappear.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望消息只显示一段时间，然后逐渐消失并消失。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adapts the previous one. So, make a copy of the project for the
    that recipe, and work on this copy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方修改了之前的配方。因此，请复制该项目的副本，并在此副本上工作。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To display a text message that fades away, follow these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示一个逐渐消失的文本消息，请按照以下步骤操作：
- en: In the **Inspector** panel, remove the scripted component, `DigitalCountdown`,
    from the `Text-clock` GameObject.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 面板中，从 `Text-clock` 游戏对象中移除脚本组件 `DigitalCountdown`。
- en: 'Create a C# script class, `FadeAway`, that contains the following code, and
    add an instance as a scripted component to the `Text-hello` GameObject:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的 C# 脚本类 `FadeAway`，并将其作为一个脚本组件添加到 `Text-hello` 游戏对象中：
- en: '[PRE3]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you run the **Scene,** you will now see that the message on the screen
    slowly fades away, disappearing after five seconds.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行 **场景** 时，您现在将看到屏幕上的消息会逐渐消失，在五秒后消失。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added an instance of the `FadeAway` scripted class to the `Text-hello` GameObject.
    Due to the `RequireComponent(...)` attribute, an instance of the `CountdownTimer` script
    class was also **automatically** added.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您将`FadeAway`脚本类的一个实例添加到了`Text-hello`游戏对象中。由于`RequireComponent(...)`属性，还自动添加了一个`CountdownTimer`脚本类的实例。
- en: The `Awake()` method caches references to the `Text` and `CountdownTimer` components
    in the `countdownTimer` and `textUI` variables.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()`方法将`Text`和`CountdownTimer`组件的引用缓存到`countdownTimer`和`textUI`变量中。'
- en: The `Start()` method reset the countdown timer to start counting down from five
    seconds.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法将倒计时计时器重置为从五秒开始倒计时。'
- en: The `Update()` method (executed every frame) retrieves the proportion of time
    remaining in our timer by calling the `GetProportionTimeRemaining()` method. This
    method returns a value between `0.0` and `1.0`, which also happens to be the range
    of values for the alpha (transparency) property of the color property of a UI
    Text game object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`方法（每帧执行）通过调用`GetProportionTimeRemaining()`方法检索我们计时器剩余时间的比例。此方法返回一个介于`0.0`和`1.0`之间的值，这恰好也是UI
    Text游戏对象颜色属性alpha（透明度）属性的值范围。'
- en: '**Flexible range of `0.0`**–**`1.0`**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围灵活，从`0.0`到`1.0`**'
- en: It is often a good idea to represent proportions as values between 0.0 and 1.0\.
    Either this will be just the value we want for something, or we can multiply the
    maximum value by our decimal proportion, and we get the appropriate value. For
    example, if we wanted the number of degrees of a circle for a given `0.0`–`0.1`
    proportion, we just multiply by the maximum of 360, and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将比例表示为0.0到1.0之间的值是个好主意。这将是我们要找的值，或者我们可以将最大值乘以我们的十进制比例，从而得到适当的值。例如，如果我们想要给定`0.0`到`0.1`比例的圆的度数，我们只需将其乘以360的最大值，依此类推。
- en: The `Update()` method then retrieves the current color of the text being displayed
    (via `textUI.color`), updates its alpha property, and resets the text object to
    have this updated color value. The result is that each frame in the text object's
    transparency represents the current value of the proportion of the timer remaining
    until it fades to fully transparent when the timer gets to zero.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`Update()`方法检索正在显示的文本的当前颜色（通过`textUI.color`），更新其alpha属性，并将文本对象重置为具有此更新的颜色值。结果是，文本对象中每一帧的透明度代表计时器剩余比例的当前值。当计时器达到零时，文本将完全透明。
- en: Displaying a perspective 3D Text Mesh
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示透视3D文本网格
- en: Unity provides an alternative way to display text in 3D via the Text Mesh component.
    While this is really suitable for a text-in-the-scene kind of situation (such
    as billboards, road signs, and generally wording on the side of 3D objects that
    might be seen close up), it is quick to create and is another way of creating
    interesting menus or instruction scenes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Unity通过Text Mesh组件提供了一种在3D中显示文本的替代方法。虽然这非常适合场景中的文本（如广告牌、路标以及通常在可能近距离看到的3D对象旁边的文字），但它创建起来很快，是创建有趣菜单或指示场景的另一种方式。
- en: 'In this recipe, you''ll learn how to create a scrolling 3D text, simulating
    the famous opening credits of the movie Star Wars, which looks something like
    this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何创建一个滚动3D文本，模拟电影《星球大战》著名的开场字幕，看起来就像这样：
- en: '![](img/7deed535-6c0f-47e9-88d0-03d9adb41118.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7deed535-6c0f-47e9-88d0-03d9adb41118.png)'
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the fonts that you need in a folder named
    `Fonts,` and the text file that you need in a folder named `Text`, in the `01_07`
    folder.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`01_07`文件夹中准备了一个名为`Fonts`的文件夹，以及您需要的文本文件位于名为`Text`的文件夹中。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display perspective 3D text, follow these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示透视3D文本，请按照以下步骤操作：
- en: Create a new Unity 3D project (this ensures that we start off with a **Perspective**
    camera, suitable for the 3D effect we want to create).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目（这确保了我们从一个**透视**相机开始，适合我们想要创建的3D效果）。
- en: If you need to mix 2D and 3D scenes in your project, you can always manually
    set any camera's **Camera Projection** property to **Perspective** or **Orthographic**
    via the **Inspector** panel.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在项目中混合2D和3D场景，您始终可以通过**检查器**面板手动设置任何相机的**相机投影**属性为**透视**或**正交**。
- en: 'In the Hierarchy panel, select the Main Camera item, and, in the Inspector
    panel, set its properties as follows: Camera Clear Flags to solid color, Field
    of View to `150`, and Background color to black.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中，选择主相机项目，然后在检查器面板中设置其属性如下：相机清除标志为纯色，视野为`150`，背景颜色为黑色。
- en: Import the provided `Fonts` and `Text` folders.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的 `Fonts` 和 `Text` 文件夹。
- en: 'In the Hierarchy panel, add a UI | Text game object to the scene—choose menu:
    GameObject | UI | Text. Name this GameObject as Text-star-wars.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 面板中，将 UI | Text 游戏对象添加到场景中 - 选择菜单：GameObject | UI | Text。将此 GameObject
    命名为 Text-star-wars。
- en: Set UI Text Text-star-wars Text Content to Star Wars (with each word on a new
    line). Then, set its Font to `Xolonium Bold`, its Font Size to `50`, and its **Color**
    to White. Use the anchor presets in Rect Transform to position this UI Text object
    at the top-center of the screen. Set Vertical Overflow to `Overflow`. Set Alignment
    Horizontal to center (leaving Alignment Vertical as top).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 UI Text Text-star-wars Text Content 设置为 Star Wars（每个单词占一行）。然后，将其字体设置为 `Xolonium
    Bold`，字体大小设置为 `50`，并将其 **颜色** 设置为白色。使用 Rect Transform 中的锚点预设将此 UI Text 对象定位在屏幕的顶部中心。设置垂直溢出为
    `Overflow`。设置水平对齐为居中（垂直对齐保留为顶部）。
- en: 'In the Hierarchy panel, add a 3D Text game object to the scene – choose menu:
    GameObject | 3D Object | 3D Text. Name this GameObject Text-crawler.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 面板中，将一个 3D Text 游戏对象添加到场景中 - 选择菜单：GameObject | 3D Object | 3D Text。将此
    GameObject 命名为 Text-crawler。
- en: 'In the Inspector panel, set the Transform properties for the Text-crawler GameObject
    as follows: Position (`100, -250, 0`), Rotation (`15, 0, 0`).'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Inspector 面板中，按照以下方式设置 Text-crawler GameObject 的 Transform 属性：位置 (`100, -250,
    0`)，旋转 (`15, 0, 0`)。
- en: 'In the Inspector panel, set the **Text Mesh** properties for the `Text-crawler`
    GameObject as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Inspector 面板中，按照以下方式设置 `Text-crawler` GameObject 的 **Text Mesh** 属性：
- en: Paste the content of the provided text file, `star_wars.txt`, into Text.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将提供的文本文件 `star_wars.txt` 的内容粘贴到 Text 中。
- en: Set Offset Z = `-20`, Line Spacing = `1`, and Anchor = `Middle center`
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Offset Z = `-20`，Line Spacing = `1`，和 Anchor = `Middle center`
- en: Set Font Size = `200`, Font = `SourceSansPro-BoldIt`
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Font Size = `200`，Font = `SourceSansPro-BoldIt`
- en: When the **Scene** is made to run, the Star Wars story text will now appear
    nicely squashed in 3D perspective on the screen.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 **场景** 开始运行时，星球大战的故事文本现在将很好地以 3D 视角显示在屏幕上。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have simulated the opening screen of Star Wars, with a flat UI Text object
    title at the top of the screen, and 3D Text Mesh with settings that appear to
    be disappearing into the horizon with 3D perspective "squashing."
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经模拟了星球大战的开场屏幕，屏幕顶部有一个平面的 UI Text 对象标题，以及具有看似消失在地平线上的 3D 视角“挤压”设置的 3D Text
    Mesh。
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: There are some details you don't want to miss.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: We have to make this text crawl like it does in the movie
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们必须使这段文本像电影中那样滚动
- en: 'With a few lines of code, we can make this text scroll in the horizon just
    as it does in the movie. Add the following C# script class, `ScrollZ,` as a component
    to the `Text-crawler` GameObject:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几行代码，我们可以使这段文本在水平方向上滚动，就像在电影中一样。将以下 C# 脚本类 `ScrollZ` 作为组件添加到 `Text-crawler`
    GameObject：
- en: '[PRE4]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In each frame via the `Update()` method, the position of the 3D text object
    is moved in the direction of this GameObject's local up-direction.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中，通过 `Update()` 方法，3D 文本对象的位置会移动到该 GameObject 的局部向上方向。
- en: Where to learn more
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪里可以了解更多
- en: Learn more about 3D Text and Text Meshes in the Unity online manual at [http://docs.unity3d.com/Manual/class-TextMesh.html](http://docs.unity3d.com/Manual/class-TextMesh.html).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 在线手册中了解更多关于 3D Text 和 Text Meshes 的信息，请访问 [http://docs.unity3d.com/Manual/class-TextMesh.html](http://docs.unity3d.com/Manual/class-TextMesh.html)。
- en: An alternative way of achieving perspective text like this would be to use a
    Canvas with the World Space render mode.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类似这种透视文本的另一种方法是将 Canvas 与 World Space 渲染模式一起使用。
- en: Creating sophisticated text with TextMeshPro
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TextMeshPro 创建复杂的文本
- en: In 2017, Unity purchased the **TextMeshPro Asset Store** product, with a view
    to integrate it into Unity as a free core feature. **TextMeshPro** uses a **Signed
    Distance Field** (**SDF**) rendering method, resulting in clear and sharply-drawn
    characters at any point size and resolution. Therefore, you will need SDF fonts
    to work with this resource.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2017 年，Unity 购买了 **TextMeshPro Asset Store** 产品，目的是将其集成到 Unity 中作为一个免费的核心功能。**TextMeshPro**
    使用 **Signed Distance Field** （**SDF**）渲染方法，在任何点大小和分辨率下都能产生清晰且轮廓鲜明的字符。因此，你需要 SDF
    字体来使用此资源。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: At the time of writing, **TextMeshpro** is a free **Asset Store** download and
    **Unity Essentials Beta**, so the first step is still to import it via the asset
    store. By the time you read this, you'll probably find **TextMeshPro** as a standard
    GameObject type that you can create in the Scene panel, with no downloading required.
    So, if required, open the Asset Store panel, search for **TextMeshPro,** and import
    this free asset package.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，**TextMeshpro**是免费的**Asset Store**下载和**Unity Essentials Beta**，所以第一步仍然是通过资产商店导入。当你阅读这篇文章时，你可能会发现**TextMeshPro**作为一个标准的GameObject类型，你可以在场景面板中创建，无需下载。所以，如果需要，打开资产商店面板，搜索**TextMeshPro**，导入这个免费资产包。
- en: For this recipe, we have prepared the fonts that you need in a folder named
    Fonts & Materials in the `01_08` folder.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`01_08`文件夹中的Fonts & Materials文件夹中准备了所需的字体。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To display a text message with sophisticated **TextMeshPro** visual styling,
    follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示具有复杂的**TextMeshPro**视觉样式的文本消息，请按照以下步骤操作：
- en: Create a new Unity 3D project.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: 'Add a new UI TextMeshPro **Text** GameObject in the scene – choose menu:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个新的UI TextMeshPro **Text** GameObject – 选择菜单：
- en: GameObject | UI | TextMeshPro **– text**. Name this GameObject Text-sophisticated.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GameObject | UI | TextMeshPro **– text**. 将此GameObject命名为Text-sophisticated。
- en: '**TextMeshPro** GameObjects do not have to be part of the UI Canvas. You can
    add a **TextMeshPro** GameObject to the Scene directly by choosing the Scene panel
    menu **Create** | **3D Object** | **TextMeshPro – text**.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMeshPro** GameObject不必是UI Canvas的一部分。你可以通过选择场景面板菜单**创建** | **3D对象** |
    **TextMeshPro – text**直接将**TextMeshPro** GameObject添加到场景中。'
- en: Ensure that your new **Text-sophisticated** GameObject is selected in the Hierarchy
    panel. In the Inspector for the Rect Transform, click on the Anchor Presets square
    icon, hold down *Shift* + *Alt*, and click on the top and stretch rows.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次面板中选中了新的**Text-sophisticated** GameObject。在Rect Transform的检查器中，点击锚点预设的方形图标，按住*Shift*
    + *Alt*，然后点击顶部并拉伸行。
- en: 'Ensure the following properties are set:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以下属性已设置：
- en: '**Font Settings:**'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**字体设置：**'
- en: Font Asset set to `Anton SDF`
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体资产设置为`Anton SDF`
- en: Material Preset set to `Anton SDF - Outline`
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质预设设置为`Anton SDF - Outline`
- en: Font size `200`
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体大小`200`
- en: Alignment set to horizontal center
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐设置为水平居中
- en: '**Face:**'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**面：**'
- en: Color set to `white`
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色设置为`white`
- en: Dilate set to `0`
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展设置为`0`
- en: '**Outline:**'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮廓：**'
- en: Color set to `Red`
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色设置为`Red`
- en: Thickness set to `0.1`
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 厚度设置为`0.1`
- en: '**Underlay (shadow):**'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**底纹（阴影）：**'
- en: Offset X set to `1`
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: X偏移量设置为`1`
- en: Offset Y set to `-1`
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y偏移量设置为`-1`
- en: Dilate set to `1`
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展设置为`1`
- en: 'The following screenshot shows the **Inspector** panel with these settings:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了具有这些设置的**检查器**面板：
- en: '![](img/d5109162-7213-412d-acd9-38ce3ff1a38b.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5109162-7213-412d-acd9-38ce3ff1a38b.png)'
- en: The **Text-sophisticated** GameObject will now appear as very large, with a
    white inner, red outline, and a drop shadow to the lower right.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Text-sophisticated** GameObject现在将显示为非常大，内部为白色，轮廓为红色，右下角有阴影。'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have added a new **UI TextMeshPro Text** GameObject to a scene. You chose
    one of the SDF fonts, and an outline material preset. You then adjusted settings
    for the face (inner part of each character), outline, and drop shadow (Underlay).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经向场景中添加了一个新的**UI TextMeshPro Text** GameObject。你选择了一个SDF字体和一个轮廓材质预设。然后调整了面（每个字符的内部部分）、轮廓和下阴影（底纹）的设置。
- en: There are hundreds of settings for a **TextMeshPro** component, and therefore
    much experimentation may be required to achieve a particular effect.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMeshPro**组件有数百种设置，因此可能需要大量实验才能达到特定的效果。'
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some more details you don't want to miss.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不想错过的更多细节。
- en: Rich Text substrings for colors, effects, and sprites
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色、效果和精灵的富文本子串
- en: '**TextMeshPro** offers over 30 HTML-style markups to substrings. The following
    code illustrates some, including the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMeshPro**提供了超过30种HTML风格的标记来对子串进行标记。以下代码演示了一些，包括以下内容：'
- en: '[PRE5]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One powerful markup is the `<page>` tag, this allows a single set of text to
    be made interactive and presented to the user as a sequence of pages.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强大的标记是`<page>`标签，这允许一组文本成为交互式，并以一系列页面呈现给用户。
- en: Learn more from the online manual Rich Text page at [http://digitalnativestudios.com/textmeshpro/docs/rich-text/](http://digitalnativestudios.com/textmeshpro/docs/rich-text/).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://digitalnativestudios.com/textmeshpro/docs/rich-text/](http://digitalnativestudios.com/textmeshpro/docs/rich-text/)的在线手册富文本页面了解更多信息。
- en: Displaying an image
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示图像
- en: There are many cases where we wish to display an image onscreen, including logos,
    maps, icons, and splash graphics. In this recipe, we will display an image centered
    at the top of the screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下我们希望在屏幕上显示图像，包括标志、地图、图标和启动图形。在这个食谱中，我们将显示屏幕顶部的图像。
- en: 'The following screenshot shows Unity displaying an image:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Unity显示的图像：
- en: '![](img/724fabd6-99c5-493c-b156-1666187f7c89.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/724fabd6-99c5-493c-b156-1666187f7c89.png)'
- en: Getting ready
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the image that you need in a folder named
    `Images` in the `01_07` folder.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`01_07`文件夹中的`Images`文件夹中准备了您需要的图像。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display an image, follow these steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示图像，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: 'Set the Game panel to a 400 x 300 size. Do this by first displaying the **Game**
    panel, and then creating a new **Resolution** in the drop-down menu at the top
    of the panel. Click the plus symbol at the bottom of this menu, setting **Label**
    = **Chapter 2**, **Width** = **400**, and **Height** = **300.** Click **OK** and
    the **Game** panel should be set to this new resolution:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏面板设置为400 x 300的大小。首先显示**游戏**面板，然后在面板顶部的下拉菜单中创建一个新的**分辨率**。点击此菜单底部的加号符号，设置**标签**
    = **第2章**，**宽度** = **400**，**高度** = **300**。点击**确定**，**游戏**面板应设置为这个新分辨率：
- en: '![](img/dcb90848-9116-442a-9e6a-5f90667af272.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcb90848-9116-442a-9e6a-5f90667af272.png)'
- en: Alternatively, you can set the default **Game** panel resolution through menu
    **Edit** | **Project Settings** | **Player** and then the Resolution and Presentation
    width and height in the Inspector (having turned off the Full Screen option).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过菜单**编辑** | **项目设置** | **玩家**来设置默认的**游戏**面板分辨率，然后在检查器中的分辨率和展示宽高（已关闭全屏选项）。
- en: Import the provided `Images` folder. In the **Inspector** tab, ensure that the
    `unity_logo` image has the **Texture Type** set to **Default**. If it has some
    other type, then choose **Default** from the drop-down list, and click on the
    Apply button.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`Images`文件夹。在**检查器**选项卡中，确保`unity_logo`图像的**纹理类型**设置为**默认**。如果它有其他类型，则从下拉列表中选择**默认**，然后点击应用按钮。
- en: In the **Hierarchy** panel, add a UI | RawImage GameObject named `RawImage-logo` to
    the scene.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，将一个UI | 原始图像GameObject命名为`RawImage-logo`添加到场景中。
- en: 'Ensure that the `RawImage-logo` GameObject is selected in the **Hierarchy**
    panel. In the **Inspector** for the **RawImage (Script)** component, click the
    file viewer circle icon at the right side of the **Texture** property, and select
    **image unity_logo**, as shown in the following screenshot:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次**面板中选择`RawImage-logo`GameObject。在**原始图像（脚本）**组件的**检查器**中，点击**纹理**属性右侧的文件查看器圆形图标，并选择**image
    unity_logo**，如图所示：
- en: '![](img/36d8b75b-f8d6-4edb-96bd-51bd87260d48.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36d8b75b-f8d6-4edb-96bd-51bd87260d48.png)'
- en: An alternative way of assigning this Texture is to drag the unity_logo image from
    your **Project** folder (Images) into the **Raw Image (Script)** public property **Texture.**
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将此纹理分配的另一种方法是，从您的**项目**文件夹（图像）中拖动`unity_logo`图像到**原始图像（脚本）**公共属性**纹理**。
- en: Click on the **Set Native Size** button to resize the image so it is no longer
    stretched and distorted.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置原生大小**按钮以调整图像大小，使其不再拉伸和扭曲。
- en: In **Rect Transform,** click on the **Anchor Presets** square icon, which will
    result in several rows and columns of preset position squares appearing. Hold
    down *Shift* + *Alt* and click on the top row and the center column.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**矩形变换**中，点击**锚点预设**方框图标，这将导致出现几行几列的预设位置方块。按住*Shift* + *Alt*并点击顶部行和中心列。
- en: The image will now be positioned neatly at the top of the **Game** panel, and
    will be horizontally centered.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，图像将整齐地定位在**游戏**面板的顶部，并且将水平居中。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have ensured that an image has the **Texture Type** set to **Default.**
    You added a **UI RawImage** control to the scene. The **RawImage** control has
    been made to display the `unity_logo` image file.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您已确保图像的**纹理类型**设置为**默认**。您已向场景中添加了一个**UI原始图像**控件。**原始图像**控件被设置为显示`unity_logo`图像文件。
- en: The image has been positioned at the top-center of the **Game** panel.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图像已定位在**游戏**面板的顶部中心。
- en: There's more...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are some details you don''t want to miss:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节您不应该错过：
- en: Working with 2D Sprites and UI Image components
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与2D精灵和UI图像组件一起工作
- en: If you simply wish to display non-animated images, then Texture images and **UI
    RawImage** controls are the way to go. However, if you want more options on how
    an image should be displayed (such as tiling, and animation), the UI Image control
    should be used instead. This control needs image files to be imported as the Sprite
    (2D and UI) type.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Once an image file has been dragged into the UI Image control's **Sprite** property,
    additional properties will be available, such as **Image Type**, and options to
    preserve the aspect ratio.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to prevent the distortion and stretching of a UI Sprite GameObject,
    then in the Inspector panel, check the **Preserve Aspect** option, in its **Image
    (Script)** component.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An example of tiling a Sprite image can be found in the *Revealing icons for
    multiple object pickups by changing the size of a tiled image* recipe in [Chapter
    3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml), *Inventory UIs*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Creating UIs with the Fungus open source dialog system
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than constructing your own UI and interactions from scratch each time,
    there are plenty of UI and dialogue systems available for Unity. One powerful,
    free, and open source dialog system is called Fungus, which uses a visual flowcharting
    approach to dialog design.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create a very simple, one-sentence dialogue, to illustrate
    the basics of Fungus. The following screenshot shows the Fungus-generated dialog
    for the sentence **How are you today?**:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f72f0e8f-6278-460c-ae85-0aa4c1af8ae5.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a one-sentence dialog using **Fungus**, follow these steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Asset Store** panel, search for **Fungus,** and Import this free
    asset package (search for Fungus and free).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **Fungus** Flowchart GameObject by choosing menu: **Tools** |
    **Fungus** | **Create** | **Flowchart.**'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display and dock the Fungus Flowchart window panel by choosing menu: **Tools**
    | **Fungus** | **Flowchart Window.**'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There will be one block in the **Flowchart Window**. Click on this block to
    select it (a green border appears around the block to indicate that it is selected).
    In the **Inspector** panel, change the **Block Name** of this block to Start:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbaa1b6c-bf56-45bd-914c-5690af28518e.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '**Each Block** in a **Flowchart** follows a sequence of commands. So in the
    **Inspector,** we are now going to create a sequence of (Say) commands to display
    two sentences to the user when the game runs.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Start** block is still selected in the **Flowchart** panel.
    Click on the plus (**+**) button at the bottom section of the **Inspector** panel
    to display the menu of **Commands,** and select the **Narrative** | Say **command:**
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/399c705e-0666-47fa-9b50-99d5cfbe396b.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'Since we only have one command for this block, that command will automatically
    be selected (highlighted green) in the top part of the **Inspector.** The bottom
    half of the Inspector presents the properties for the currently-selected **Command,**
    as shown in the following screenshot. In the bottom half of the Inspector, for
    the **Story Text** property, enter the text of the question that you wish to be
    presented to the user, which is **How are you today?**:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们只为这个块有一个命令，因此该命令将自动在**检查器**的顶部部分被选中（高亮绿色）。检查器的下半部分显示了当前选定的**命令**的属性，如下面的截图所示。在检查器的下半部分，对于**故事文本**属性，输入您希望向用户展示的问题文本，即**你今天怎么样？**：
- en: '![](img/de5d0fac-6aaf-4bf3-ad4a-73364da2f1ab.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de5d0fac-6aaf-4bf3-ad4a-73364da2f1ab.png)'
- en: 'Create another **Say Command**, and type the following for its **Story Text
    property**: **Very well thank you**.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个**说命令**，并为其**故事文本属性**输入以下内容：**非常好，谢谢**。
- en: 'When you run the game, the user will first be presented with the **How are
    you today?** text (hearing a clicking noise as each letter is typed on screen).
    After the user clicks on the **continue** triangle button (at the bottom-right
    part of the dialog window), they will be presented with the second sentence: **Very
    well thank you**.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行游戏时，用户首先会看到**你今天怎么样？**的文本（在屏幕上逐字输入时会听到点击声）。在用户点击对话框窗口右下角的**继续**三角形按钮后，他们将看到第二句话：**非常好，谢谢**。
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have created a new Unity project, and imported the **Fungus** asset package,
    which contains the **Fungus Unity** menus, windows, and commands, and also the
    example projects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建一个新的 Unity 项目，并导入了**Fungus**资产包，其中包含**Fungus Unity**菜单、窗口和命令，以及示例项目。
- en: You have added a **Fungus Flowchart** to your scene with a single **Block**
    that you have named **Start.** Your block starts to execute when the game begins
    (since the default for the first block is to be executed upon receiving the Game
    Started event).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将一个名为**开始**的**Block**添加到场景中，这是一个**Fungus 流程图**。当游戏开始时（因为第一个块的默认行为是在接收到游戏开始事件时执行），您的块开始执行。
- en: In the **Start** block, you added a sequence of two **Say Commands**. Each command
    presents a sentence to the user, and then waits for the continue button to be
    clicked before proceeding to the next **Command.**
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在**开始**块中，您添加了一系列两个**说命令**。每个命令向用户展示一句话，然后等待点击继续按钮才能继续到下一个**命令**。
- en: 'As can be seen, the **Fungus** system handles the work of creating a nicely-presented
    panel to the user, displaying the desired text and continue button. **Fungus**
    offers many more features, including menus, animations, and control of sounds
    and music, the details of which can be found in the next recipe, and by exploring
    their provided example projects, and their websites:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，**Fungus**系统负责为用户创建一个展示良好的面板，显示所需的文本和继续按钮。**Fungus**提供许多其他功能，包括菜单、动画以及控制和音乐，这些细节可以在下一道菜谱中找到，并通过探索他们提供的示例项目和网站：
- en: '[http://fungusgames.com/](http://fungusgames.com/)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://fungusgames.com/](http://fungusgames.com/)'
- en: '[https://github.com/FungusGames/Fungus](https://github.com/FungusGames/Fungus)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/FungusGames/Fungus](https://github.com/FungusGames/Fungus)'
- en: Creating a Fungus character dialog with images
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有图像的 Fungus 角色对话
- en: 'The **Fungus** dialog system introduced in the previous recipe supports multiple
    characters, whose dialogs can be highlighted through their names, colors, sound
    effects, and even portrait images. In this recipe, we''ll create a two-character
    dialog between Sherlock Holmes and Watson to illustrate the system:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中引入的**Fungus**对话系统支持多个角色，其对话可以通过其名称、颜色、音效甚至肖像图像来突出显示。在这个菜谱中，我们将创建一个 Sherlock
    Holmes 和 Watson 之间的双角色对话来展示该系统：
- en: '![](img/d9b77b0f-a641-4f4a-a20e-4f9a63ab968b.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b77b0f-a641-4f4a-a20e-4f9a63ab968b.png)'
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To create a character dialog with portrait images using Fungus, follow these
    steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Fungus 创建带有肖像图像的角色对话，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目。
- en: Open the **Asset Store** panel, and **Import** the **Fungus** dialogue asset
    package (this includes the **Fungus** Examples, whose images we’ll use for the
    two characters).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**资产商店**面板，并**导入****Fungus**对话资产包（这包括**Fungus**示例，我们将使用这些示例图像的两个角色）。
- en: 'Create a new **Fungus Flowchart** GameObject by choosing menu: **Tools** |
    **Fungus** | **Create** | **Flowchart.**'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：**工具** | **Fungus** | **创建** | **流程图**，创建一个新的**Fungus 流程图** GameObject。
- en: 'Display and dock the **Fungus Flowchart** window panel by choosing menu: **Tools**
    | **Fungus** | **Flowchart Window.**'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：**工具** | **Fungus** | **流程图窗口**来显示并停靠**Fungus流程图**窗口面板。
- en: Change the name of the only **Block** in the **Flowchart** to The case of the
    missing violin.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**流程图**中唯一的**块**的名称更改为“失踪小提琴案”。
- en: 'Create a new Character by choosing menu: **Tools** | **Fungus** | **Create**
    | **Character.**'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：**工具** | **Fungus** | **创建** | **角色**来创建一个新的角色。
- en: You should now see a new **Character** GameObject in the **Hierarchy****.**
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该在**层次结构**中看到一个新**角色**GameObject。
- en: 'With GameObject **Character** 1 – Sherlock selected in the **Project** panel,
    edit its properties in the Inspector:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中选择GameObject **Character** 1 – **Sherlock**，然后在**检查器**中编辑其属性：
- en: Rename this GameObject **Character** 1 – **Sherlock.**
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此GameObject重命名为**Character** 1 – **Sherlock**。
- en: In its **Character(Script)** component, set the **Name Text** to **Sherlock**
    and the **Name Color** to green.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其**角色（脚本）**组件中，将**名称文本**设置为**Sherlock**并将**名称颜色**设置为绿色。
- en: In the **Inspector,** click the **Add Portrait** button (the plus sign "**+**"),
    to get a "slot" into which to add a portrait image.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**检查器**中，点击**添加肖像**按钮（加号“**+**”），以获得一个可以添加肖像图像的“槽”。
- en: 'Drag the appropriate image into your new portrait image slot (in this screenshot,
    we used the "confident" image from the Sherlock example project: **Fungus Examples**
    | **Sherlock** | **Portraits** | **Sherlock):**'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将适当的图像拖放到你的新肖像图像槽中（在这个屏幕截图中，我们使用了Sherlock示例项目中的“自信”图像：**Fungus Examples** |
    **Sherlock** | **Portraits** | **Sherlock**）：
- en: '![](img/df6f6ee2-6ec6-43d7-912c-9615e7586bbb.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df6f6ee2-6ec6-43d7-912c-9615e7586bbb.png)'
- en: Repeat steps 6-8 above to create a second character, John, using **Name Color**
    = blue, and **Portrait Image** = annoyed.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上述6-8步来创建第二个角色John，使用**名称颜色** = 蓝色和**肖像图像** = 恼怒。
- en: Select your **Block** in the **Fungus Flowchart,** so you can add some **Commands**
    to be executed.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的**流程图**中的**块**，以便你可以添加一些要执行的**命令**。
- en: 'Create a **Say** command, for **Character 1 - Sherlock**, saying Watson, have
    you seen my violin? and choose the **confident** portrait (since this is the only
    one we added to the character):'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**说**命令，为**Character 1 - Sherlock**，说“华生，你看到我的小提琴了吗？”并选择**自信**的肖像（因为这是我们为角色添加的唯一一个）：
- en: '![](img/5ac06adc-4300-464b-aaf5-d2b0b97b43b3.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ac06adc-4300-464b-aaf5-d2b0b97b43b3.png)'
- en: 'Add a second **Say** command, this time for **Character 2 – John**, saying
    No, why don''t you find it yourself using your amazing powers of deduction.. and
    choose the **annoyed** portrait:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个**说**命令，这次是为**Character 2 – John**，说“不，你为什么不自己用你惊人的推理能力去找呢...”并选择**恼怒**的肖像：
- en: '![](img/39ecda34-c9c7-4b93-acb5-2eddb5501710.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39ecda34-c9c7-4b93-acb5-2eddb5501710.png)'
- en: Run the scene you should see a sequence of statements, clearly showing who is
    saying both with (colored) name text **AND** the portrait image you selected for
    each Say command (after Sherlock’s text has finished appearing, click the box
    to start John’s sentence).
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景，你应该会看到一系列陈述，清楚地显示谁在说（带有颜色的）名称文本**以及**为每个**说**命令所选的肖像图像（在Sherlock的文本出现完毕后，点击框开始John的句子）。
- en: How it works...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have created a new Unity project with the **Fungus** asset package.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个包含**Fungus**资产包的新Unity项目。
- en: You have added a **Fungus Flowchart** to your scene, and also added two characters
    (each with a text color and a portrait image).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将**Fungus流程图**添加到场景中，并且还添加了两个角色（每个角色都有一个文本颜色和肖像图像）。
- en: For the **Block** in the **Flowchart,** you added to **Say** commands, stating
    which character was saying each sentence, and which portrait to use (if you had
    added more portrait images, you could select different images to indicate the
    emotion of the character speaking).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于添加到**说**命令中的**流程图**中的**块**，指定了哪个角色在说每句话，以及使用哪个肖像（如果你添加了更多肖像图像，你可以选择不同的图像来表示说话角色的情绪）。
- en: There's more...
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: There are some details you don't want to miss.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Data-driven conversations
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据驱动对话
- en: Fungus offers a data-driven approach to conversations. The character and portrait
    (and facing direction, and movement onto-off the stage, and so on) can be defined
    through text in a simple format, using the Say command’s **Narrative** | **Conversation**
    option. This recipe’s conversation with portrait images can be declared with just
    two lines of text in a **Conversation:**
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Fungus提供了一种数据驱动的对话方法。角色和肖像（以及面向方向、舞台上的移动与否等）可以通过使用**说**命令的**叙事** | **对话**选项的简单格式中的文本来定义。此菜谱的带有肖像图像的对话可以用**对话**中的两行文本来声明：
- en: '[PRE6]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Learn more about the Fungus conversation system on their documentation pages:
    [http://fungusdocs.snozbot.com/conversation_system.html](http://fungusdocs.snozbot.com/conversation_system.html).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的文档页面上了解更多关于真菌对话系统的信息：[http://fungusdocs.snozbot.com/conversation_system.html](http://fungusdocs.snozbot.com/conversation_system.html).
