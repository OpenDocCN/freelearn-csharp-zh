<html><head></head><body>
<div><div><h1 id="_idParaDest-147"><em class="italic"><a id="_idTextAnchor146"/>Chapter 9</em>: Working with Concurrent Collections in .NET</h1>
<p>This chapter will dive deeper into some of the <code>System.Collections.Concurrent</code> namespace. These<a id="_idIndexMarker474"/> specialized collections help to preserve data integrity when using concurrency and parallelism in your C# code. Each section of this chapter will provide practical examples of how to use a specific concurrent collection provided by .NET.</p>
<p>We have seen some basic use of parallel data structures in .NET. We have already covered the basics of each of the concurrent collections in the <em class="italic">Introduction to concurrency</em> section of <a href="B18552_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>. So, we will quickly jump into the examples of their use in this chapter and learn more about their application and inner workings.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Using <code>BlockingCollection</code></li>
<li>Using <code>ConcurrentBag</code></li>
<li>Using <code>ConcurrentDictionary</code></li>
<li>Using <code>ConcurrentQueue</code></li>
<li>Using <code>ConcurrentStack</code></li>
</ul>
<p>By the end of this chapter, you will have a deeper understanding of how these collections protect your shared data from being mishandled while multithreading.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later.</li>
<li>.NET 6.</li>
<li>To complete any WinForms or WPF samples, you will need to install the .NET desktop development workload for Visual Studio. These projects will run only on Windows.</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09</a>.</p>
<p>Let’s get started by learning more about <code>BlockingCollection&lt;T&gt;</code> and walk through a sample project that leverages the collection.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Using BlockingCollection</h1>
<p><code>BlockingCollection&lt;T&gt;</code> is one of <a id="_idIndexMarker475"/>the most useful concurrent collections. As we saw in <a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, <code>BlockingCollection&lt;T&gt;</code> was created to be an implementation<a id="_idIndexMarker476"/> of the <strong class="bold">producer/consumer pattern</strong> for .NET. Let’s review some of the specifics of this <a id="_idIndexMarker477"/>collection before creating a different kind of sample project.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>BlockingCollection details</h2>
<p>One of the <a id="_idIndexMarker478"/>major draws of <code>BlockingCollection&lt;T&gt;</code> for developers working with parallel code implementations is that it can be swapped to replace <code>List&lt;T&gt;</code> without too many additional modifications. You can use the <code>Add()</code> method for both. The difference with <code>BlockingCollection&lt;T&gt;</code> is that calling <code>Add()</code> to add an item will block the current thread if another read or write operation is in process. If you want to specify a timeout<a id="_idIndexMarker479"/> period on the operation, you can use <code>TryAdd()</code>. The <code>TryAdd()</code> method optionally supports both timeouts and cancellation tokens.</p>
<p>Removing items from <code>BlockingCollection&lt;T&gt;</code> with <code>Take()</code> has an equivalent <code>TryTake()</code>, which allows timed operations and cancellation. The <code>Take()</code> and <code>TryTake()</code> methods will take and remove the first remaining item that was added to the collection. This is because the default underlying collection type within <code>BlockingCollection&lt;T&gt;</code> is <code>ConcurrentQueue&lt;T&gt;</code>. Alternatively, you can specify that the collection uses <code>ConcurrentStack&lt;T&gt;</code>, <code>ConcurrentBag&lt;T&gt;</code>, or any collection that implements the <code>IProducerConsumerCollection&lt;T&gt;</code> interface. Here’s an example of <code>BlockingCollection&lt;T&gt;</code> being initialized to use <code>ConcurrentStack&lt;T&gt;</code>, with its capacity limited to <code>100</code> items:</p>
<pre class="source-code">var itemCollection = new BlockingCollection&lt;string&gt;(new </pre>
<pre class="source-code">    ConcurrentStack&lt;string&gt;(), 100);</pre>
<p>If your application needs to iterate over the items in <code>BlockingCollection&lt;T&gt;</code>, the <code>GetConsumingEnumerable()</code> method can be used in a <code>for</code> or <code>foreach</code> loop. However, keep in mind that this iteration over the collection is also removing items, and it will complete the collection if the enumeration continues until the collection is empty. This is the <em class="italic">consuming</em> part of the <code>GetConsumingEnumerable()</code> method name.</p>
<p>If you need to use multiple <code>BlockingCollection&lt;T&gt;</code> classes of the same type, you can add to or take from them as one by adding them to an array. An array of <code>BlockingCollection&lt;T&gt;</code> makes the <code>TryAddToAny()</code> and <code>TryTakeFromAny()</code> methods available. These methods will succeed if any of the collections in the array are in the proper state to accept or provide objects to the calling code. Microsoft Docs has an example of how to use an array of <code>BlockingCollection&lt;T&gt;</code> in a pipeline: https://docs.microsoft.com/dotnet/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.</p>
<p>Now that we have covered the details needed to understand <code>BlockingCollection&lt;T&gt;</code>, let’s dive into a sample project.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Using BlockingCollection with Parallel.ForEach and PLINQ</h2>
<p>We already covered <a id="_idIndexMarker480"/>an example that implements the producer/consumer pattern in <a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, so let’s try something a little different in this section. We are going to create a WPF application that loads the contents of a book from a 1.5 MB text file and searches for words that start with a particular letter:</p>
<p class="callout-heading">Note</p>
<p class="callout">This sample uses a .NET Standard NuGet package created from a Microsoft extension sample that was originally built on .NET Framework 4.0. The extension is called <code>ParallelExtensionsExtras</code>, and the original source is available on GitHub: https://github.com/dotnet/samples/tree/main/csharp/parallel/ParallelExtensionsExtras. The extension method that we will be using from the package makes <code>Parallel.ForEach</code> operations and PLINQ queries run more efficiently with concurrent collections. To read more about the extensions, you can check out this post on the <em class="italic">.NET Parallel Programming</em> blog: https://devblogs.microsoft.com/pfxteam/parallelextensionsextras-tour-4-blockingcollectionextensions/.</p>
<ol>
<li>Start by creating a new WPF application in Visual Studio. Name the project <code>ParallelExtras.BlockingCollection</code>.</li>
<li>On the NuGet Package Manager page, search for and add the latest stable version of the <strong class="bold">ParallelExtensionsExtras.NetFxStandard</strong> package to your project:</li>
</ol>
<div><div><img alt="Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package " height="116" src="img/Figure_9.1_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package</p>
<ol>
<li value="3">We are going to read text from the book <em class="italic">Ulysses</em> by James Joyce. This book is public domain in the United States and most countries around the world. It can be downloaded in UTF-8 plain text format from <code>ulysses.txt</code>, and place it in the main folder with your other project files.</li>
<li>In Visual Studio, right-click <code>ulysses.txt</code> and select <strong class="bold">Properties</strong>. In the <strong class="bold">Properties</strong> window, update<a id="_idIndexMarker481"/> the <strong class="bold">Copy to Output Directory</strong> property to <strong class="bold">Copy if newer</strong>.</li>
<li>Open <code>Grid.RowDefinitions</code> and <code>Grid.Columndefinitions</code> to the <code>Grid</code> control, as follows:<pre>&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    &lt;RowDefinition Height="*"/&gt;
&lt;/Grid.RowDefinitions&gt;
&lt;Grid.ColumnDefinitions&gt;
    &lt;ColumnDefinition/&gt;
    &lt;ColumnDefinition/&gt;
&lt;/Grid.ColumnDefinitions&gt;</pre></li>
<li>Add <code>ComboBox</code> and <code>Button</code> inside the <code>Grid</code> definition following the <code>Grid.ColumnDefinitions</code> element. These controls will be in the first row of <code>Grid</code>:<pre>&lt;ComboBox x:Name="LettersComboBox"
            Grid.Row="0" Grid.Column="0"
            Margin="4"&gt;
    &lt;ComboBoxItem Content="A"/&gt;
    &lt;ComboBoxItem Content="D"/&gt;
    &lt;ComboBoxItem Content="F"/&gt;
    &lt;ComboBoxItem Content="G"/&gt;
    &lt;ComboBoxItem Content="M"/&gt;
    &lt;ComboBoxItem Content="O"/&gt;
    &lt;ComboBoxItem Content="A"/&gt;
    &lt;ComboBoxItem Content="T"/&gt;
    &lt;ComboBoxItem Content="W"/&gt;
&lt;/ComboBox&gt;
&lt;Button Grid.Row="0" Grid.Column="1"
        Margin="4" Content="Load Words"
        Click="Button_Click"/&gt;</pre></li>
</ol>
<p><code>ComboBox</code> will contain nine different letters from which to choose. You can add as<a id="_idIndexMarker482"/> many of these as you like. <code>Button</code> contains a <code>Click</code> event handler that we will add to <code>MainWindow.xaml.cs</code> soon.</p>
<ol>
<li value="7">Finally, add <code>ListView</code> named <code>WordsListView</code> to the second row of <code>Grid</code>. It will span both of the columns:<pre>&lt;ListView x:Name="WordsListView" Margin="4"
            Grid.Row="1" Grid.ColumnSpan="2"/&gt;</pre></li>
<li>Now, open <code>MainWIndow.xaml.cs</code>. The first thing we will do here is to create a method named <code>LoadBookLinesFromFile()</code>, which reads each line of text from <code>ulysses.txt</code> into <code>BlockingCollection&lt;string&gt;</code>. There is only a single thread reading from the file, so using the <code>Add()</code> method instead of <code>TryAdd()</code> is best:<pre>private async Task&lt;BlockingCollection&lt;string&gt;&gt; 
    LoadBookLinesFromFile()
{
    var lines = new BlockingCollection&lt;string&gt;();
    using var reader = File.OpenText(Path.Combine(
        Path.GetDirectoryName(Assembly
            .GetExecutingAssembly().Location), 
                "ulysses.txt"));
    string line;
    while ((line = await reader.ReadLineAsync()) != 
        null)
    {
        lines.Add(line);
    }
    lines.CompleteAdding();
    return lines;
}</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Remember, it is important to call <code>lines.CompleteAdding()</code> before the end of the method. Otherwise, subsequent queries of this collection will hang and continue waiting for more items to be added to the stream.</p>
<ol>
<li value="9">Now, create<a id="_idIndexMarker483"/> a method named <code>GetWords()</code> that takes the lines from the text file and<a id="_idIndexMarker484"/> uses a <code>BlockingCollection&lt;string&gt;</code>. In this method, we’re parsing multiple lines simultaneously with a <code>Parallel.ForEach</code> loop. The <code>GetConsumingPartitioner()</code> extension method, which tells the <code>Parallel.ForEach</code> loop that <code>BlockingCollection</code> will be doing its own blocking, so the loop does not need to do any. This makes the whole process <a id="_idIndexMarker485"/>more efficient:<pre>private BlockingCollection&lt;string&gt; 
    GetWords(BlockingCollection&lt;string&gt; lines)
{
    var words = new BlockingCollection&lt;string&gt;();
    Parallel.ForEach(lines.GetConsumingPartitioner(), 
        (line) =&gt;
    {
        var matches = Regex.Matches(line, 
            @"\b[\w']*\b");
        foreach (var m in matches.Cast&lt;Match&gt;())
        {
            if (!string.IsNullOrEmpty(m.Value))
            {
                words.TryAdd(TrimSuffix(m.Value, 
                    '\''));
            }
        }
    });
    words.CompleteAdding();
    return words;
}
private string TrimSuffix(string word, char 
    charToTrim)
{
    int charLocation = word.IndexOf(charToTrim);
    if (charLocation != -1)
    {
        word = word[..charLocation];
    }
    return word;
}</pre></li>
</ol>
<p>The <code>TrimSuffix()</code> method<a id="_idIndexMarker486"/> will remove specific characters from the end of a word; in this case, we’re passing the apostrophe character to be removed.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you are unfamiliar with regular expressions, you can read about how to use them with .NET on Microsoft Docs: <a href="https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions">https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions</a>. They are an extremely efficient way to parse text.</p>
<ol>
<li value="10">Next, create a method named <code>GetWordsByLetter()</code> to call the other methods we just created. Once <code>BlockingCollection&lt;string&gt;</code> containing all the words from the book has been fetched, this method will use PLINQ and <code>GetConsumingPartitioner()</code> to find all words that start with the uppercase or lowercase versions of the selected letter:<pre>private async Task&lt;List&lt;string&gt;&gt; GetWordsByLetter(char 
    letter)
{
    BlockingCollection&lt;string&gt; lines = await 
        LoadBookLinesFromFile();
    BlockingCollection&lt;string&gt; words = 
        GetWords(lines);
    // 275,506 words in total
    return words.GetConsumingPartitioner()
        .AsParallel()
        .Where(w =&gt; w.StartsWith(letter) || 
            w.StartsWith(char.ToLower(letter)))
        .ToList();
}</pre></li>
<li>Finally, we’ll add the <code>Button_Click</code> event to kick off the loading, parsing, and querying<a id="_idIndexMarker487"/> of the book’s text. Don’t forget to mark the event handler as <code>async</code>:<pre>private async void Button_Click(object sender, 
    RoutedEventArgs e)
{
    if (LettersComboBox.SelectedIndex &lt; 0)
    {
        MessageBox.Show("Please select a letter.");
        return;
    }
    WordsListView.ItemsSource = await 
        GetWordsByLetter(
        char.Parse(GetComboBoxValue(LettersComboBox
            .SelectedValue)));
}
private string GetComboBoxValue(object item)
{
    var comboxItem = item as ComboBoxItem;
    return comboxItem.Content.ToString();
}</pre></li>
</ol>
<p>The <code>GetComboBoxValue()</code> helper method will take the object from <code>LettersComboBox.SelectedValue</code> and find <code>string</code> with the selected letter within.</p>
<ol>
<li value="12">The<a id="_idIndexMarker488"/> following <code>using</code> declarations are required in <code>MainWindow.xaml.cs</code> to compile and run the project:<pre>using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;</pre></li>
<li>Now, run the project, select a letter, and click <strong class="bold">Load Words</strong>:</li>
</ol>
<div><div><img alt="Figure 9.2 – Displaying words that begin with T from ulysses.txt " height="709" src="img/Figure_9.2_B18552.jpg" width="1074"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Displaying words that begin with T from ulysses.txt</p>
<p>The <a id="_idIndexMarker489"/>whole process runs very quickly considering the book contains over 275,000 total words. Try adding some sorting to the PLINQ query and see how the performance is impacted.</p>
<p>Let’s continue by learning about <code>ConcurrentBag&lt;T&gt;</code>.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Using ConcurrentBag</h1>
<p>The <code>ConcurrentBag&lt;T&gt;</code> is an <a id="_idIndexMarker490"/>unordered collection of <a id="_idIndexMarker491"/>objects that can be safely added, peeked at, or removed concurrently. Keep in mind that, as with all of the concurrent collections, the methods exposed by <code>ConcurrentBag&lt;T&gt;</code> are thread-safe, but any extension methods are not guaranteed to be safe. Always implement your own synchronization when leveraging them. To review a list of safe methods, you can review this Microsoft Docs page: https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentbag-1#methods.</p>
<p>We are going to create a sample application that simulates working with a pool of objects. This scenario can be useful if you have some processing that leverages a stateful object that is memory-intensive. You want to minimize the number of objects created but cannot reuse one until the previous iteration has finished using it and returned it to the pool.</p>
<p>In our<a id="_idIndexMarker492"/> example, we will use a mocked-up PDF processing class that is assumed to be memory-intensive. In reality, document-processing libraries can be quite heavy, and they often rely on document states in each instance. The console application will iterate in parallel 15 times to create these fake PDF objects and append some text to each of them. Each time through the loop, we will output the text contents and the current count of PDF processors in the pool. If the current count remains low, then the application is working as intended:</p>
<ol>
<li value="1">Start by creating a new .NET console application in Visual Studio named <code>ConcurrentBag.PdfProcessor</code>.</li>
<li>Add a new class to represent the mocked-up PDF data. Name the class <code>ImposterPdfData</code>:<pre>public class ImposterPdfData
{
    private string _plainText;
    private byte[] _data;
    public ImposterPdfData(string plainText)
    {
        _plainText = plainText;
        _data = System.Text.Encoding.ASCII.GetBytes
            (plainText);
    }
    public string PlainText =&gt; _plainText;
    public byte[] PdfData =&gt; _data;
}</pre></li>
</ol>
<p>We are storing the plain text and an ASCII-encoded version of the text that we will pretend is PDF format. This avoids implementing any third-party libraries in our sample application. If you have any PDF libraries with which you are familiar, you are welcome to adapt this sample to use them.</p>
<ol>
<li value="3">Next, add a <a id="_idIndexMarker493"/>new class named <code>PdfParser</code>. This class will be the one that is taken from and returned to <code>ConcurrentBag&lt;PdfParser&gt;</code>. We will create the host for that collection in an upcoming step:<pre>public class PdfParser
{
    private ImposterPdfData? _pdf;
    public void SetPdf(ImposterPdfData pdf) =&gt; 
        _pdf = pdf;
    public ImposterPdfData? GetPdf() =&gt; _pdf;
    public string GetPdfAsString()
    {
        if (_pdf != null)
            return _pdf.PlainText;
        else
            return "";
    }
    public byte[] GetPdfBytes()
    {
        if (_pdf != null)
            return _pdf.PdfData;
        else
            return new byte[0];
    }
}</pre></li>
</ol>
<p>This stateful class holds an instance of an <code>ImposterPdfData</code> object and can return the data as a string or the ASCII-encoded byte array.</p>
<ol>
<li value="4">Add a <a id="_idIndexMarker494"/>method to <code>PdfParser</code> named <code>AppendString</code>. This method will add some additional text to <code>ImposterPdfData</code> on a new line:<pre>public void AppendString(string data)
{
    string newData;
    if (_pdf == null)
    {
        newData = data;
    }
    else
    {
        newData = _pdf.PlainText + Environment.NewLine 
            + data;
    }
    _pdf = new ImposterPdfData(newData);
}</pre></li>
<li>Now, add a class named <code>PdfWorkerPool</code>:<pre>public class PdfWorkerPool
{
    private ConcurrentBag&lt;PdfParser&gt; _workerPool = 
        new();
    public PdfWorkerPool()
    {
        // Add initial worker
        _workerPool.Add(new PdfParser());
    }
    public PdfParser Get() =&gt; _workerPool.TryTake(out 
        var parser) ? parser : new PdfParser();
    public void Return(PdfParser parser) =&gt; 
        _workerPool.Add(parser);
    public int WorkerCount =&gt; _workerPool.Count();
}</pre></li>
</ol>
<p>Be <a id="_idIndexMarker495"/>sure to also add a <code>using System.Collections.Concurrent;</code> statement to <code>PdfWorkerPool.cs</code>. The pool stores <code>ConcurrentBag&lt;PdfParser&gt;</code> named <code>_workerPool</code>. When <code>PdfWorkerPool</code> is initialized, it adds a new instance to <code>_workerPool</code>. The <code>Get</code> method will return an existing instance from the pool with <code>TryTake</code> if one exists. If the pool is empty, a new instance is created and returned to the caller. The <code>Return</code> method adds <code>PdfParser</code> back to the pool when the consumer is finished. We will use the <code>WorkerCount</code> property to track the number of objects in the pool at any time.</p>
<ol>
<li value="6">Finally, replace the contents of <code>Program.cs</code> with the following code:<pre>using ConcurrentBag.PdfProcessor;
Console.WriteLine("Hello, ConcurrentBag!");
var pool = new PdfWorkerPool();
Parallel.For(0, 15, async (i) =&gt;
{
    var parser = pool.Get();
    var data = new ImposterPdfData($"Data index: {i}");
    try
    {
        parser.SetPdf(data);
        parser.AppendString(DateTime.UtcNow
            .ToShortDateString());
        Console.WriteLine($"
           {parser.GetPdfAsString()}");
        Console.WriteLine($"Parser count: 
            {pool.WorkerCount}");
        await Task.Delay(100);
    }
    finally
    {
        pool.Return(parser);
        await Task.Delay(250);
    }
});
Console.WriteLine("Press the Enter key to exit.");
Console.ReadLine();</pre></li>
</ol>
<p>After creating a new <code>PdfWorkerPool</code>, we’re using a <code>Parallel.For</code> loop to iterate 15 times. Each time through the loop, we get <code>PdfParser</code>, set the text, append <code>DateTime.UtcNow</code>, and write the contents to the console, along with the<a id="_idIndexMarker496"/> current count of parsers in the pool.</p>
<ol>
<li value="7">Run the application and examine the output:</li>
</ol>
<div><div><img alt="Figure 9.3 – Running the PdfProcessor console application " height="691" src="img/Figure_9.3_B18552.jpg" width="871"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Running the PdfProcessor console application</p>
<p>In my case, the parser count got to a maximum number of seven. If you tweak the <code>Task.Delay</code> intervals or remove them entirely, you are likely to see the count never exceed one. This kind of pool can be configured to be very efficient.</p>
<p>This application is an example where we do not care which instance of the collection is returned, so <code>ConcurrentBag&lt;T&gt;</code> is a perfect choice. In the next section, we will create a drug lookup example using <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Using ConcurrentDictionary</h1>
<p>In this <a id="_idIndexMarker497"/>section, we<a id="_idIndexMarker498"/> will create a WinForms application to load United States <code>ConcurrentDictionary</code>, we can perform fast lookups with a <code>product.txt</code> file and moved about half of the records to a <code>product2.txt</code> file, duplicating the header row in the second file. You can get these files in the <a id="_idIndexMarker499"/>GitHub repository for the chapter at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup</a>:</p>
<ol>
<li value="1">Start by creating a new WinForms project in Visual Studio targeting .NET 6. Name the project <code>FdaNdcDrugLookup</code>.</li>
<li>Open the WinForm designer for <code>Form1.cs</code>. Lay out two <code>TextBox</code> controls, two <code>Button</code> controls, and <code>Label</code>:</li>
</ol>
<div><div><img alt="Figure 9.4 – The layout of Form1.cs " height="524" src="img/Figure_9.4_B18552.jpg" width="1056"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The layout of Form1.cs</p>
<p>The <code>btnLoad</code> and <code>txtNdc</code>. The <code>btnLookup</code>, <code>txtDrugName</code> and <strong class="bold">ReadOnly</strong> – <strong class="bold">True</strong>.</p>
<ol>
<li value="3">Next, add the <code>product.txt</code> and <code>product2.txt</code> files to your project by right-clicking<a id="_idIndexMarker500"/> the project in <strong class="bold">Solution Explorer</strong> and choosing <strong class="bold">Add</strong> | <strong class="bold">Existing Item</strong>. </li>
<li>In the <strong class="bold">Properties</strong> panel, change <strong class="bold">Copy to Output Directory</strong> to <strong class="bold">Copy if newer</strong> for both of the text files we just added.</li>
<li>Add a new class to the project named <code>Drug</code> and add the following implementation:<pre>public class Drug
{
    public string? Id { get; set; }
    public string? Ndc { get; set; }
    public string? TypeName { get; set; }
    public string? ProprietaryName { get; set; }
    public string? NonProprietaryName { get; set; }
    public string? DosageForm { get; set; }
    public string? Route { get; set; }
    public string? SubstanceName { get; set; }
}</pre></li>
</ol>
<p>This will contain the data for each record loaded from the NDC drug files.</p>
<ol>
<li value="6">Next, add a class to the project named <code>DrugService</code> and begin with the following implementation. To start, we only have <code>private</code> <code>ConcurrentDictionary&lt;string, Drug&gt;</code>. We will add a method to load the data in the next step:<pre>using System.Collections.Concurrent;
using System.Data;
using System.Reflection;
namespace FdaNdcDrugLookup
{
    public class DrugService
    {
        private ConcurrentDictionary&lt;string, Drug&gt; 
            _drugData = new();
    }
}</pre></li>
<li>Next, add a <a id="_idIndexMarker501"/>public method to <code>DrugService</code> named <code>LoadData</code>:<pre>public void LoadData(string fileName)
{
    using DataTable dt = new();
    using StreamReader sr = new(Path.Combine(
        Path.GetDirectoryName(Assembly
            .GetExecutingAssembly().Location), 
               fileName));
    var del = new char[] { '\t' };
    string[] colheaders = sr.ReadLine().Split(del);
    foreach (string header in colheaders)
    {
        dt.Columns.Add(header); // add headers
    }
    while (sr.Peek() &gt; 0)
    {
        DataRow dr = dt.NewRow(); // add rows
        dr.ItemArray = sr.ReadLine().Split(del);
        dt.Rows.Add(dr);
    }
    foreach (DataRow row in dt.Rows)
    {
        Drug drug = new(); // map to Drug object
        foreach (DataColumn column in dt.Columns)
        {
            switch (column.ColumnName)
            {
                case "PRODUCTID":
                    drug.Id = row[column].ToString();
                    break;
                case "PRODUCTNDC":
                    drug.Ndc = row[column].ToString();
                    break;
<strong class="bold">...</strong>
<strong class="bold">// REMAINING CASE STATEMENTS IN GITHUB</strong>
            }
        }
        _drugData.TryAdd(drug.Ndc, drug);
    }
}</pre></li>
</ol>
<p class="callout-heading">Note</p>
<pre>https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup</a>.</pre>
<p>In this <a id="_idIndexMarker502"/>method, we are loading data from the provided <code>fileName</code> to <code>StreamReader</code>, adding the column headers to <code>DataTable</code>, populating its rows from the file, and then iterating over the rows and columns of <code>DataTable</code> to create <code>Drug</code> objects. Each <code>Drug</code> object is added to <code>ConcurrentDictionary</code> with a call to <code>TryAdd</code>, using the <code>Ndc</code> property as the key.</p>
<ol>
<li value="8">Now, add a <code>GetDrugByNdc</code> method to <code>DrugService</code> to complete the class. This method will return <code>Drug</code> for the provided <code>ndcCode</code>, if found:<pre>public Drug GetDrugByNdc(string ndcCode)
{
    bool result = _drugData.TryGetValue(ndcCode, out 
        var drug);
    if (result &amp;&amp; drug != null)
        return drug;
    else
        return new Drug();
}</pre></li>
<li>Open the code for <code>Form1.cs</code> and add a private variable for the <code>DrugService</code>:<pre>private DrugService _drugService = new();</pre></li>
<li>Open the<a id="_idIndexMarker503"/> designer for <code>Form1.cs</code> and double-click the <code>btnLoad_Click</code> event handler. Add the following implementation. Note that we made the <code>async</code> event handler to allow us to use the <code>await</code> keyword:<pre>private async void btnLoad_Click(object sender, 
    EventArgs e)
{
    var t1 = Task.Run(() =&gt; _drugService.LoadData
        ("product.txt"));
    var t2 = Task.Run(() =&gt; _drugService.LoadData
        ("product2.txt"));
    await Task.WhenAll(t1, t2);
    btnLookup.Enabled = true;
    btnLoad.Enabled = false;
}</pre></li>
</ol>
<p>To load the two text files, we are creating two tasks to run in parallel before using <code>Task.WhenAll</code> to await them both. Then, we can safely enable the <code>btnLookup</code> button and disable the <code>btnLoad</code> button to prevent a second load.</p>
<ol>
<li value="11">Next, switch back to the designer view for <code>Form1.cs</code> and double-click the <code>btnLookup_Click</code> event handler. Add the following implementation to that handler to find a drug name based on the NDC code entered in the UI:<pre>private void btnLookup_Click(object sender, 
    EventArgs e)
{
    if (!string.IsNullOrWhiteSpace(txtNdc.Text))
    {
        var drug = _drugService.GetDrugByNdc
           (txtNdc.Text);
        txtDrugName.Text = drug.ProprietaryName;
    }
}</pre></li>
<li>Now, run<a id="_idIndexMarker504"/> the application and click the <code>70518-1120</code> NDC code. Click <strong class="bold">Lookup Drug</strong>:</li>
</ol>
<div><div><img alt="Figure 9.5 – Looking up the drug Prednisone by its NDC code " height="512" src="img/Figure_9.5_B18552.jpg" width="1226"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Looking up the drug Prednisone by its NDC code</p>
<ol>
<li value="13">Try some other NDC codes and see how quickly each record loads. Here are a few random NDC<a id="_idIndexMarker505"/> codes taken from each file. If they all succeed, you know that both files loaded successfully in parallel: <strong class="bold">0002-0800</strong>, <strong class="bold">0002-4112</strong>, <strong class="bold">43063-825</strong>, and <strong class="bold">51662-1544</strong>.</li>
</ol>
<p>That’s it! You now have your own quick-and-dirty drug lookup application. Try replacing the drug name <code>TextBox</code> with <code>DataGrid</code> on your own to display an entire <code>Drug</code> record.</p>
<p>In the next section, we will work with customer orders in <code>ConcurrentQueue&lt;T&gt;</code>.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Using ConcurrentQueue</h1>
<p>In this section, we <a id="_idIndexMarker506"/>will create a sample project that is <a id="_idIndexMarker507"/>a simplified version of a realistic scenario. We are going to create an order queuing system using <code>ConcurrentQueue&lt;T&gt;</code>. This application will be a console application that enqueues orders for two customers in parallel. We will create five orders for each customer, and to mix up the order of the queue, each customer queuing process will use a different <code>Task.Delay</code> between calls to <code>Enqueue</code>. The final output should <a id="_idIndexMarker508"/>show a mix of orders dequeued for the first customer and the second customer. Remember that <code>ConcurrentQueue&lt;T&gt;</code> employs <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) logic:</p>
<ol>
<li value="1">Let’s start by opening Visual Studio and creating a .NET console application named <code>ConcurrentOrderQueue</code>.</li>
<li>Add a new class to the project named <code>Order</code>:<pre>public class Order
{
    public int Id { get; set; }
    public string? ItemName { get; set; }
    public int ItemQty { get; set; }
    public int CustomerId { get; set; }
    public decimal OrderTotal { get; set; }
}</pre></li>
<li>Now, create a new class named <code>OrderService</code> containing a private <code>ConcurrentQueue&lt;Order&gt;</code> named <code>_orderQueue</code>. This class is where we will enqueue<a id="_idIndexMarker509"/> and dequeue orders for our two customers:<pre>using System.Collections.Concurrent;
namespace ConcurrentOrderQueue
{
    public class OrderService
    {
        private ConcurrentQueue&lt;Order&gt; _orderQueue = 
            new();
    }
}</pre></li>
<li>Let’s start with the implementation of <code>DequeueOrders</code>. In this method, we will use a <code>while</code> loop to call <code>TryDequeue</code> until the collection is empty, adding each order to <code>List&lt;Order&gt;</code> to be returned to the caller:<pre>public List&lt;Order&gt; DequeueOrders()
{
    List&lt;Order&gt; orders = new();
    <strong class="bold">while (_orderQueue.TryDequeue(out var order))</strong>
    {
        orders.Add(order);
    }
    return orders;
}</pre></li>
<li>Now, we will create public and private <code>EnqueueOrders</code> methods. The public parameterless method will call the private method twice, once for each <code>customerId</code>. The two <a id="_idIndexMarker510"/>calls will be made in parallel, followed by a <code>Task.WhenAll</code> call to await them:<pre>public async Task EnqueueOrders()
{
    var t1 = EnqueueOrders(1);
    var t2 = EnqueueOrders(2);
    await Task.WhenAll(t1, t2);
}
private async Task EnqueueOrders(int customerId)
{
    for (int i = 1; i &lt; 6; i++)
    {
        var order = new Order
        {
            Id = i * customerId,
            CustomerId = customerId,
            ItemName = "Widget for customer " + 
                customerId,
            ItemQty = 20 - (i * customerId)
        };
        order.OrderTotal = order.ItemQty * 5;
        <strong class="bold">_orderQueue.Enqueue(order);</strong>
        await Task.Delay(100 * customerId);
    }
}</pre></li>
</ol>
<p>The private <code>EnqueueOrders</code> method iterates five times to create and <code>Enqueue</code> orders for the given <code>customerId</code>. This is also used to vary <code>ItemName</code>, <code>ItemQty</code>, and the duration of <code>Task.Delay</code>.</p>
<ol>
<li value="6">Finally, open <code>Program.cs</code> and add the following code to enqueue and dequeue<a id="_idIndexMarker511"/> the orders, and output the resulting list to the console:<pre>using ConcurrentOrderQueue;
Console.WriteLine("Hello, World!");
var service = new OrderService();
await service.EnqueueOrders();
var orders = service.DequeueOrders();
foreach(var order in orders)
{
    Console.WriteLine(order.ItemName);
}</pre></li>
<li>Run the program and view the list of orders in the output. How does yours match up?</li>
</ol>
<div><div><img alt="Figure 9.6 – Viewing the output of the order queue " height="517" src="img/Figure_9.6_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Viewing the output of the order queue</p>
<p>Try varying the delay<a id="_idIndexMarker512"/> factor or changing <code>customerId</code> for one or both customers in the <code>EnqueueOrders</code> method to see how the order of the output changes.</p>
<p>Next, in the final section of the chapter, we will perform a quick experiment with the <code>ConcurrentStack&lt;T&gt;</code> collection.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Using ConcurrentStack</h1>
<p>In this<a id="_idIndexMarker513"/> section, we<a id="_idIndexMarker514"/> are going to experiment with <code>BlockingCollection&lt;T&gt;</code> and <code>ConcurrentStack&lt;T&gt;</code>. In the first example in this chapter, we used <code>BlockingCollection&lt;T&gt;</code> to read the words that started with a specific letter from the book <em class="italic">Ulysses</em>. We are going to make a copy of that project and change the code that reads the lines of text to use <code>ConcurrentStack&lt;T&gt;</code> inside <code>BlockingCollection&lt;T&gt;</code>. This will make the lines output in <a id="_idIndexMarker515"/>reverse order because a stack uses <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>) logic. Let’s get started!</p>
<ol>
<li value="1">Make a copy of the <strong class="bold">ParallelExtras.BlockingCollection</strong> project from this chapter or modify the existing project if you prefer.</li>
<li>Open <code>MainWindow.xaml.cs</code> and modify the <code>LoadBookLinesFromFile</code> method<a id="_idIndexMarker516"/> to pass a new <code>ConcurrentStack&lt;string&gt;</code> to the constructor of <code>BlockingCollection&lt;string&gt;</code>:<pre>private async Task&lt;BlockingCollection&lt;string&gt;&gt; 
    LoadBookLinesFromFile()
{
    <strong class="bold">var lines = new BlockingCollection&lt;string&gt;(new </strong>
<strong class="bold">        ConcurrentStack&lt;string&gt;());</strong>
<strong class="bold">    ...</strong>
    return lines;
}</pre></li>
</ol>
<p>Note that the preceding method was truncated to emphasize the modified code. View the complete method on GitHub: <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack</a>.</p>
<ol>
<li value="3">Now, when you run the application and search for the same letter as before (in our case, <code>T</code>), you will see a different set of words at the beginning of the list:</li>
</ol>
<div><div><img alt="Figure 9.7 – Searching for words that start with T in Ulysses " height="710" src="img/Figure_9.7_B18552.jpg" width="1076"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Searching for words that start with T in Ulysses</p>
<p>If you <a id="_idIndexMarker517"/>scroll to the bottom of the list, you should see the words from the beginning of the book. Note that the list is not completely reversed because we didn’t use <code>ConcurrentStack&lt;string&gt;</code> when parsing the words from each line. You can try this on your own as another experiment.</p>
<p>That concludes our tour of the .NET concurrent collections. Let’s wrap up by summarizing what we have learned in this chapter.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Summary</h1>
<p>In this chapter, we delved into five of the collections in the <code>System.Collections.Concurrent</code> namespace. We created five sample applications in the chapter to get some hands-on experience with each of the concurrent collection types available in .NET 6. Through a mix of WPF, WinForms, and .NET console application projects, we examined some real-world methods of leveraging these collections in your own applications.</p>
<p>In the next chapter, we will explore the rich set of tools provided by Visual Studio for multithreaded development and debugging. We will also discuss some techniques for analyzing and improving the performance of parallel .NET code.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Questions</h1>
<ol>
<li value="1">Which concurrent collection can implement different types of collections under the covers?</li>
<li>What is the default internal collection type implemented by the collection in question 1?</li>
<li>Which collection type is frequently used as an implementation of the producer/consumer pattern?</li>
<li>Which concurrent collection contains key/value pairs?</li>
<li>Which method is used to add values to <code>ConcurrentQueue&lt;T&gt;</code>?</li>
<li>Which methods are used to add and get items in <code>ConcurrentDictionary</code>?</li>
<li>Are extension methods used with the concurrent collections thread-safe?</li>
</ol>
</div>
</div>
</body></html>