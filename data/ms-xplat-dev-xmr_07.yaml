- en: Chapter 7. View Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 视图元素
- en: 'In this chapter, you will find introductory information about **User Experience**
    (**UX**) design concepts and explanations on the differences and similarities
    of design principles on Xamarin platforms. Correlation between the UI elements
    will be illustrated and useful design patterns will be demonstrated with real-life
    examples to create a consistent user experience across platforms without compromising
    the native look-and-feel. This chapter is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将找到关于**用户体验**（**UX**）设计概念的简介信息，以及Xamarin平台上设计原则的异同解释。将通过实例说明UI元素之间的关联，并使用实际案例展示有用的设计模式，以在平台间创建一致的用户体验，同时不牺牲原生外观和感觉。本章分为以下部分：
- en: Design philosophy
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计理念
- en: Design elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计元素
- en: User interaction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户交互
- en: Design philosophy
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计理念
- en: One of the biggest pitfalls while designing an application for cross-platform
    use is to impose the design patterns from one OS to the other one. In the mobile
    world, each platform and users of those platforms have certain expectations from
    an application. These expectations can be as insignificant as an icon on a common
    feature access button (for example, the share button on iOS and Android), or as
    important as the layout of a view (for example, tab buttons on the bottom and
    top of a view on iOS and Windows Phone, respectively). In this paradigm, the designer's
    responsibility becomes much more complex, since the design, while creating a brand
    for the application, would need to be inviting and appealing for the users of
    the platform.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在为跨平台应用设计时，最大的陷阱之一是将一个操作系统的设计模式强加给另一个操作系统。在移动世界中，每个平台及其用户都对应用程序有一定的期望。这些期望可能微不足道，比如一个常见功能访问按钮上的图标（例如，iOS和Android上的分享按钮），或者非常重要，比如视图布局（例如，iOS和Windows
    Phone上视图底部和顶部的标签按钮）。在这个范式下，设计师的责任变得更加复杂，因为设计在创建应用程序品牌的同时，还需要对平台用户有吸引力。
- en: User expectations
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户期望
- en: Mobile platform users are creatures of habit. One of the key deciding factors
    of the adoption rate of a mobile application is how easy it is to use and how
    discoverable the features are for the platform users. It is important to remember
    that when users become acquainted with a specific platform, they will expect certain
    patterns and behaviors while interacting with that device. Trying to change these
    habits and forcing the users into usage patterns that they are not accustomed
    to might be costly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平台用户是习惯性动物。一个移动应用程序采用率的关键决定因素之一是它使用起来有多容易，以及平台用户发现功能有多容易。重要的是要记住，当用户熟悉了特定的平台时，他们会在与该设备交互时期望某些模式和行为。试图改变这些习惯并强迫用户进入他们不习惯的使用模式可能会代价高昂。
- en: Platform imperatives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台要求
- en: Both iOS and Windows Runtime have well-defined design guidelines that were refined
    over the years with the help of Microsoft's and Apple's experience on various
    software platforms. Android, being an open source development platform, has been
    searching for an identity since the early versions and it was a general implementation
    principle to design first on iOS and port the design to Android. However, with
    the release of Material Design guidelines by Google, the Android platform and
    app developers finally seem to have found a scheme to adhere to and create a unified
    experience on the Android platform across different applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: iOS和Windows Runtime都有经过多年微软和苹果在各个软件平台上的经验而精炼的明确设计指南。Android作为一个开源开发平台，自早期版本以来一直在寻找自己的身份，并且最初的一般实现原则是在iOS上设计，然后将设计移植到Android。然而，随着谷歌发布Material
    Design指南，Android平台和应用程序开发者似乎终于找到了一个可以遵循的方案，并在不同的应用程序上为Android平台创建统一体验。
- en: With the emergence of minimalism and flat design patterns in software design,
    Microsoft was the pioneer to release the Microsoft design language (the Modern
    UI, codenamed Metro). Modern UI design heavily depended on typograph and geometry.
    The motto of this design pattern is "content over chrome", and application developers
    were encouraged to use the content itself to provide the interactivity and remove
    any unnecessary ornaments that are not crucial to the content or the functionality.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着极简主义和平面设计模式在软件设计中的出现，微软是第一个发布微软设计语言（现代UI，代号Metro）的先驱。现代UI设计严重依赖于字体和几何形状。这种设计模式的理念是“内容优于装饰”，并鼓励应用程序开发者使用内容本身来提供交互性，并移除任何对内容或功能不重要的不必要的装饰。
- en: '![Platform imperatives](img/B04693_07_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![平台要求](img/B04693_07_01.jpg)'
- en: Panorama View from Windows Phone 7
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Phone 7的全景视图
- en: With the release of iOS 7, Apple joined the minimalist movement with an overhaul
    of their user interface, which is described by Jonathan Ive (Senior VP of Design)
    as bringing order to complexity. Translucency, typography, and layering were the
    highlighted features of this new design. It was a major change of Apple's design
    direction which, at the time, was famous for its skeuomorphic designs on various
    applications and platforms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 iOS 7 的发布，苹果通过对其用户界面的全面改革加入了极简主义运动，这一改革被设计高级副总裁乔纳森·艾夫（Jonathan Ive）描述为将复杂化为秩序。透明度、字体和分层是这种新设计的亮点。这是苹果设计方向的一次重大转变，当时它以其在各种应用程序和平台上的拟物化设计而闻名。
- en: '![Platform imperatives](img/B04693_07_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![平台要求](img/B04693_07_02.jpg)'
- en: iOS 7 Home Page and an Android dialog
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 7 主页和 Android 对话框
- en: Google's take on flat design principles, Material Design (codenamed Quantum
    Paper), tries to address the same type of design concerns by reducing the design
    elements to their very basics and recreating interactive surfaces with strong
    typography resembling paper and ink in essence.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌对扁平化设计原则的看法，即 Material Design（代号量子纸），试图通过将设计元素简化到其基本要素，并重新创建具有类似纸张和墨水本质的强烈字体的交互表面来解决相同类型的设计问题。
- en: Hardware dependency
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件依赖性
- en: Similar to web applications, on Xamarin target platforms, especially on Windows
    and Android, the hardware that the Xamarin application is going to be running
    or displayed on varies greatly. An application designed for a specific platform
    can be used on a low-end touchscreen device with a mediocre resolution or on a
    high-end phablet with an HD display on landscape or portrait rotations. This hardware
    dependency should be one of the main concerns while designing the UI for mobile
    applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络应用程序类似，在 Xamarin 目标平台上，尤其是在 Windows 和 Android 上，Xamarin 应用程序将要运行或显示的硬件差异很大。为特定平台设计的应用程序可以在具有中等分辨率的低端触摸屏设备上使用，也可以在具有高清显示的平板电脑上使用，无论是横向还是纵向旋转。这种硬件依赖性在设计移动应用程序的用户界面时应是主要关注点之一。
- en: For instance, pre-Android 3.0 phones used to have hardware buttons that helped
    with the navigation throughout the application and the OS itself. These buttons
    consisted of a back, menu, search, and home buttons. Even though the hardware
    buttons were replaced with the bottom system navigation bar (software buttons)
    on later devices, this trait is followed by Windows Phone devices that still have
    the back, Windows, and search hardware buttons. On iOS, the navigation hierarchy
    implementation is completely up to the application and generally handled by the
    back button placed on the top navigation bar.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Android 3.0 之前的手机通常有硬件按钮，这些按钮有助于在应用程序和操作系统本身中进行导航。这些按钮包括返回、菜单、搜索和主页按钮。尽管后来的设备将硬件按钮替换为底部的系统导航栏（软件按钮），但这一特性在仍然具有返回、Windows
    和搜索硬件按钮的 Windows Phone 设备上得到了延续。在 iOS 上，导航层次结构的实现完全取决于应用程序，通常由放置在顶部导航栏上的返回按钮处理。
- en: Design metrics on Android
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android上的设计指标
- en: For varying resolutions, in order to create an adaptive user interface, each
    platform uses different methodologies. However, in each platform, the important
    metric unit is the pixel density. Pixel density can be defined as the number of
    pixels that can fit into an inch in length. According to the pixel density (PPI
    or pixels per inch), independent from the total physical width and height of the
    screen, developers can create consistent views across various mobile devices.
    In other words, total screen resolution (pixel density multiplied by screen dimensions)
    is a declining trait that is taken into consideration while designing cross device/platform
    applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的分辨率，为了创建自适应的用户界面，每个平台使用不同的方法。然而，在每个平台上，重要的指标单位是像素密度。像素密度可以定义为在一英寸长度内可以容纳的像素数量。根据像素密度（PPI或每英寸像素数），独立于屏幕的总物理宽度和高度，开发者可以在各种移动设备上创建一致的视图。换句话说，总屏幕分辨率（像素密度乘以屏幕尺寸）是设计跨设备/平台应用程序时考虑的一个下降特性。
- en: On the Android platform, to create a uniform experience on different pixel densities,
    developers and designers are encouraged to use density-independent pixels (dp)
    unit for expressing various dimensions and measurements of UI controls. Density-independent
    pixels are calculated by considering the 160 pixel density as a norm and calculating
    the display size in normalized pixel values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 平台上，为了在不同像素密度上创建统一的使用体验，开发者和设计师被鼓励使用密度无关像素（dp）单位来表示 UI 控件的各个尺寸和测量值。密度无关像素是通过将
    160 像素密度作为标准来计算的，并使用归一化像素值来计算显示尺寸。
- en: 'Check out the following table for more information on Android density-independent
    pixels:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下表格以获取有关 Android 密度无关像素的更多信息：
- en: '| Screen Density | Density Bucket | Screen Resolution (pixels) | Screen Resolution
    (dp) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 屏幕密度 | 密度桶 | 屏幕分辨率（像素） | 屏幕分辨率（dp） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 120 | LDPI | 360 x 480 | 480 x 640 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 120 | LDPI | 360 x 480 | 480 x 640 |'
- en: '| 160 | MDPI | 480 x 640 | 480 x 640 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 160 | MDPI | 480 x 640 | 480 x 640 |'
- en: '| 240 | HDPI | 720 x 960 | 480 x 640 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 240 | HDPI | 720 x 960 | 480 x 640 |'
- en: '| 320 | XHDPI | 960 x 1280 | 480 x 640 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 320 | XHDPI | 960 x 1280 | 480 x 640 |'
- en: '*Android Density-Independent pixels (dp)*'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Android 密度无关像素（dp）*'
- en: 'In order to demonstrate the scaling and density independent pixels, we can
    compare the following views on different devices. Using the pixels to design the
    content would be visualized differently on different devices:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示缩放和密度无关像素，我们可以比较不同设备上的以下视图。使用像素设计的内容将在不同设备上以不同的方式可视化：
- en: '![Design metrics on Android](img/B04693_07_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Android 上的设计指标](img/B04693_07_03.jpg)'
- en: Using pixels to design the UI
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像素设计 UI
- en: However, if we were to use the same design elements with dp as the measurement
    unit, the UI would be much more uniform.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用 dp 作为测量单位来使用相同的设计元素，UI 将会更加统一。
- en: '![Design metrics on Android](img/B04693_07_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Android 上的设计指标](img/B04693_07_04.jpg)'
- en: Using dp to design the UI
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 dp 设计 UI
- en: Similar to dp, another density-independent measure unit on Android is "sp",
    or scalable pixels. The main difference between dp and sp is that sp is scaled
    according to the user's font settings and generally associated with text content,
    while dp is managed by the operating system and the user generally does not have
    any control over it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与 dp 类似，Android 上另一个密度无关的度量单位是 "sp"，或可缩放像素。dp 和 sp 之间的主要区别在于 sp 是根据用户的字体设置进行缩放的，通常与文本内容相关联，而
    dp 由操作系统管理，用户通常无法对其进行任何控制。
- en: For media resources (for example, images) and layouts, the Android solution
    structure supports creating specialized design elements. Icons and other graphics
    can be provided in alternative sizes and resolutions using the correct density
    bucket identifier as a suffix to the `drawable` folder (for example, `drawable-xhdpi`
    for extra high density). Similarly, if needed, multiple alternative layouts can
    be provided according to the screen size groups in the layouts folder (for example,
    `layout-xlarge` or `layout-xlarge-land` for portrait and landscape displays on
    an extra-large screen).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于媒体资源（例如，图像）和布局，Android 解决方案结构支持创建专门的设计元素。可以使用正确的密度桶标识符作为 `drawable` 文件夹的后缀来提供不同大小和分辨率的图标和其他图形（例如，`drawable-xhdpi`
    用于超高密度）。同样，如果需要，可以根据布局文件夹中的屏幕尺寸组提供多个替代布局（例如，`layout-xlarge` 或 `layout-xlarge-land`
    用于超大屏幕上的纵向和横向显示）。
- en: Design metrics on iOS
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iOS 上的设计指标
- en: In the iOS ecosystem, there are only a handful of devices and screen resolutions.
    On this platform, the identifier on display scaling is the point (pt) notation.
    A point is displayed as one physical pixel on a non-retina display. On retina
    display and higher configurations (iPhone 6 Plus), the scaling factor is calculated
    as 2x and 3x, respectively, while the point measurements are kept as they are.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 生态系统中，只有少数设备和屏幕分辨率。在这个平台上，显示缩放的标识符是点（pt）表示法。点在非视网膜显示器上显示为一个物理像素。在视网膜显示器和更高配置（iPhone
    6 Plus）上，缩放因子分别计算为 2x 和 3x，而点测量值保持不变。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: iPhone 6 Plus has the scale factor of 3 and screen resolution of 414 x 736 points.
    This would translate to 1242 x 2208 pixel resolution. However, the physical supported
    resolution on this device is 1080 x 1920\. For this reason, images rendered (or
    rasterized) with the 3x scale factor are then down-sampled with a ratio of 1:1.15
    on this device.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 6 Plus 的缩放因子为 3，屏幕分辨率为 414 x 736 点。这相当于 1242 x 2208 像素分辨率。然而，该设备上支持的物理分辨率是
    1080 x 1920。因此，使用 3x 缩放因子渲染的图像在此设备上以 1:1.15 的比例进行下采样。
- en: Design metrics on Windows Runtime
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows Runtime上的设计度量
- en: On Windows Runtime, the scaling of the application view is taken care of by
    the scaling algorithms that normalize the size of controls, fonts, and other UI
    elements. This normalization process occurs on the runtime and developers generally
    do not need to deal with it. When designing Windows Runtime applications, the
    measurement unit is pixels. However, the pixels are referred to as effective pixels.
    Effective pixels are the normalized size unit of the operating system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Runtime上，应用视图的缩放由缩放算法负责，这些算法将控件、字体和其他UI元素的大小标准化。这个过程发生在运行时，开发者通常不需要处理它。当设计Windows
    Runtime应用程序时，度量单位是像素。然而，像素被称为有效像素。有效像素是操作系统的标准化尺寸单位。
- en: '![Design metrics on Windows Runtime](img/B04693_07_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Runtime上的设计度量](img/B04693_07_05.jpg)'
- en: Effective Pixels on Windows Runtime
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Runtime上的有效像素
- en: A common example for the effective pixels is to consider a font of size 24px.
    Text visualized with this font is displayed the same way on a phone 5-10 cm away
    from the user and on a surface hub couple of meters away.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有效像素的一个常见例子是考虑一个24px大小的字体。使用这个字体可视化的文本在用户距离手机5-10厘米处和距离几米远的surface hub上显示方式相同。
- en: Design elements
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计元素
- en: In order to create a consistent layout across platforms, while conforming to
    the platform requirements, developers and designers need to familiarize themselves
    with each platform and draw parallels between the layouts and UI controls on these
    platforms. We will discuss this in the next chapter within the scope of Xamarin.Forms.
    The existence of parallels between these platforms makes the foundation of the
    Xamarin.Forms framework.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在各个平台上创建一致的布局，同时符合平台要求，开发者和设计师需要熟悉每个平台，并在这些平台的布局和UI控件之间建立联系。我们将在下一章中讨论Xamarin.Forms范围内的这个问题。这些平台之间的联系构成了Xamarin.Forms框架的基础。
- en: The basic layout
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本布局
- en: The main layout elements in all three platforms are very similar to each other.
    However, the placement of these elements differs greatly according to the platform.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个平台上，主要的布局元素彼此非常相似。然而，这些元素的位置根据平台的不同而有很大差异。
- en: '![The basic layout](img/B04693_07_06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![基本布局](img/B04693_07_06.jpg)'
- en: The User Interface Layout
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面布局
- en: On each platform, the status bar displaying the system information is located
    at the top of the screen (marked as "1" in the preceding screenshot). This section
    is one of the constant elements that should be kept in mind when designing applications
    for Xamarin target platforms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个平台上，显示系统信息的状态栏都位于屏幕顶部（如前一张截图中所标记的“1”所示）。这部分是设计适用于Xamarin目标平台的应用程序时应牢记的常量元素之一。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Windows 10 operating system, the system bar can be expanded on user's initiative
    to give detailed information about the system. This expansion causes the elements
    to be hidden on the application canvas. However, this does not cause elements
    to offset, and the expansion occurs on a different layer of the screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 10操作系统上，系统栏可以根据用户的主动操作来扩展，以提供有关系统的详细信息。这种扩展会导致应用画布上的元素被隐藏。然而，这并不会导致元素偏移，扩展发生在屏幕的不同层上。
- en: On all three platforms, the second element is generally the navigation bar (marked
    as "2" on the screenshot). This element is only used to display information about
    the current view on Windows Phone. However, on iOS and especially on Android,
    the navigation bar has additional functions. The navigation bar on iOS applications
    can be used for hierarchical navigational items. However, on the Android platform,
    the so-called app-bar contains the context-related commands and navigation items.
    The context menu presenting the additional context-related commands that do not
    fit on the main app-bar (navigation panel on the right-hand side) and the Navigation
    Drawer that reveals the left navigation panel are the functional and structural
    elements of the main app-bar on Android applications. Having application and content-related
    buttons or links on the title area on Windows Phone applications has been discouraged.
    However, on Windows 10, similar to the Navigation Drawer on the Android platform,
    developers can implement an application-level switch.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个平台上，第二个元素通常是导航栏（在屏幕截图上标记为“2”）。此元素仅用于显示有关当前视图的信息。然而，在iOS和特别是Android上，导航栏具有额外的功能。iOS应用程序中的导航栏可用于分层导航项。然而，在Android平台上，所谓的应用栏包含与上下文相关的命令和导航项。在Android应用程序的主要应用栏（右侧的导航面板）上显示的上下文菜单以及显示不适用于主应用栏（右侧的导航面板）的额外上下文相关命令的上下文菜单和显示左侧导航面板的导航抽屉是Android应用程序主要应用栏的功能和结构元素。在Windows
    Phone应用程序的标题区域放置与应用程序和内容相关的按钮或链接已被不推荐。然而，在Windows 10上，类似于Android平台上的导航抽屉，开发者可以实现应用程序级别的切换。
- en: On Windows platform, context-related application commands and the additional
    items that are displayed inside a context menu are generally located at the bottom
    of the screen on the application bar (marked as "5"). Even though the application
    bar can be created on the top of the screen, this is generally a use case for
    applications that use the peer-to-peer/horizontal navigation patterns (refer to
    the next section, *Navigation*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows平台上，与上下文相关的应用程序命令和显示在上下文菜单中的附加项通常位于应用程序栏底部（标记为“5”）。尽管可以在屏幕顶部创建应用程序栏，但这通常适用于使用对等/水平导航模式的应用程序（参考下一节，*导航*）。
- en: The system navigation bar (marked as "4") is located at the bottom of the screen
    on the Android platform. This bar contains three buttons, namely Back, Home, and
    History. These buttons used to be hardware buttons prior to Android 4.0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 系统导航栏（标记为“4”）位于Android平台屏幕底部。此栏包含三个按钮，即返回、主页和历史记录。在Android 4.0之前，这些按钮曾是硬件按钮。
- en: Instead of the bottom app-bar on Windows Phone and the system navigation bar
    on Android, on iOS this area is generally occupied by the tab bar (marked as "3").
    The tab bar provides the main navigation functionality in iOS applications and
    should be available on each screen of the application (similar to the peer-to-peer
    navigation app-bar on Windows Phone).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows Phone上的底部应用栏和Android系统导航栏不同，在iOS上，这个区域通常由标签栏（标记为“3”）占据。标签栏提供了iOS应用程序的主要导航功能，并且应该在应用程序的每个屏幕上可用（类似于Windows
    Phone上的对等导航应用栏）。
- en: Navigation
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航
- en: In application design, the navigation strategy should be one of the first decision
    items. According to the requirements of the application or the elements to focus
    on, developers can adopt different navigations strategies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序设计中，导航策略应该是首要决策事项之一。根据应用程序的要求或要关注的元素，开发者可以采用不同的导航策略。
- en: 'While building the navigation tree and preparing the flowchart for the application,
    you can make use of two types of traverses: hierarchical (vertical) and peer-to-peer
    (horizontal). Horizontal navigation occurs when the user wants to navigate between
    pages that are on the same level of the navigation tree. Hierarchical navigation
    can be on either direction on the vertical path. As a rule of thumb, as the user
    navigates deeper, the number of similarly typed objects on the screen decreases
    and the details about a single object increases. In other words, it is rare to
    see list views in the lower nodes of a sub-tree in an app navigation hierarchy.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建导航树和准备应用程序的流程图时，你可以使用两种类型的遍历：分层（垂直）和对等（水平）。当用户想要在导航树同一级别的页面之间导航时，会发生水平导航。分层导航可以在垂直路径的任一方向上。一般来说，随着用户导航的深入，屏幕上类似类型的对象数量减少，单个对象的细节增加。换句话说，在应用程序导航层次结构的子树的低层节点中很少看到列表视图。
- en: '![Navigation](img/B04693_07_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![导航](img/B04693_07_07.jpg)'
- en: Navigation Hierarchy
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 导航层次结构
- en: On top of the traditional navigation methods, jump links among the pages on
    various levels and sub-trees can also be used to provide easy access to these
    nodes (for example, a Home link navigating from the bottom of the hierarchy back
    to the main page).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的导航方法之上，可以在不同级别和子树之间的页面之间使用跳转链接，以便轻松访问这些节点（例如，一个从层次结构底部导航回主页的“首页”链接）。
- en: In order to demonstrate the navigation design, we will be creating an interface
    for the TravelTrace application that was used as an example for functional implementations
    in the previous chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示导航设计，我们将为TravelTrace应用程序创建一个界面，该界面在上一章中作为功能实现的示例。
- en: Horizontal navigation
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平导航
- en: Navigation between peers or siblings can provide an easy way to switch context
    between the items on the *top level*. In this case, peers would be representing
    the main features of an application that should generally be accessible to the
    user at all times. On this level, the navigation can be implemented with tabbed
    controls or application-level navigation providers such as the Navigation Drawer
    on the Android platform. The homepage should have clear design and focus; it should
    make a statement about what your app is tailored to do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在同级或兄弟之间进行导航可以提供一种轻松切换上下文的方法，以便在*顶级*项目之间切换。在这种情况下，同级将代表应用程序的主要功能，这些功能通常应始终对用户可用。在这一级别，导航可以通过标签控件或Android平台上的导航抽屉等应用程序级导航提供者来实现。主页应具有清晰的设计和焦点；它应该说明您的应用程序旨在做什么。
- en: For instance, if we were to use our travel application to demonstrate the top-level
    peers, we would first need to decide on the main features that the application
    has to offer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想用我们的旅行应用程序来展示顶级同级项，我们首先需要确定应用程序必须提供的主要功能。
- en: 'Possible features of this travel companion application could be:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这款旅行伴侣应用程序的可能功能包括：
- en: Get detailed information on nearby attractions
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取附近景点的详细信息
- en: Allow users to plan their trips
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户规划他们的旅行
- en: Create and share travel memorabilia (photos, notes, tips, and so on)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并分享旅行纪念品（照片、笔记、提示等）
- en: 'Identifying features of the application could be:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的功能可能包括：
- en: Creating a social medium to share and re-use travel experience
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个社交平台来分享和重用旅行体验
- en: Assisting the user before and during travels and cultural visits
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在旅行和文化访问前后协助用户
- en: Overall, we want to emphasize the social aspect and also provide personal assistance
    for users during their visits. In the light of this "decision", we can start designing
    the initial concept for our application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们希望强调社交方面，并在用户访问期间提供个人协助。鉴于这个“决定”，我们可以开始为我们的应用程序设计初始概念。
- en: '![Horizontal navigation](img/B04693_07_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![水平导航](img/B04693_07_08.jpg)'
- en: Home Screen Sample
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕示例
- en: On the Windows Phone platform, the home screen can be either implemented as
    a hub or a pivot view. Although each view has similar navigational properties,
    pivot control is generally used to display segregated groups of content that carry
    similar traits.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Phone平台上，主屏幕可以是中心视图或枢轴视图。尽管每个视图都有类似的导航属性，但枢轴控件通常用于显示具有相似特性的内容分组。
- en: Hence, it is generally preferable to use a hub view as a homepage to make different
    top level sections of the application available and sub-nodes easily discoverable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常更倾向于使用中心视图作为主页，以便使应用程序的不同顶级部分可用，并且子节点易于发现。
- en: '![Horizontal navigation](img/B04693_07_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![水平导航](img/B04693_07_09.jpg)'
- en: Hub View (Windows Phone)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 中心视图（Windows Phone）
- en: When considering Windows Phone and `HubView`, the only possible way of navigating
    between the top-level items in the hierarchy is a swipe gesture, while it is possible
    to tap on the tab bar buttons on the other platforms.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑Windows Phone和`HubView`时，在层次结构中的顶级项之间导航的唯一可能方式是滑动手势，而在其他平台上则可以点击标签栏按钮。
- en: Another type of horizontal navigation can occur when navigating through different
    categories or filtered views of content items. On the Android platform, the main
    app-bar can host a filter dropdown to select the proper category to display content
    items. On iOS, the navigation bar, or a secondary bottom tool bar, can be used
    to create a button to display a picker (aka spinner) to select the proper sibling
    on the navigation tree. Another possible horizontal navigation provider control
    on iOS would be the `SegmentedView` control, which can be used to display different
    perspectives of the same type of content (for example, previous trips as opposed
    to future plans or recent guides and recent albums).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航不同类别或内容项的过滤视图时，也可能发生另一种类型的水平导航。在Android平台上，主应用栏可以托管一个过滤器下拉菜单，以选择显示内容项的正确类别。在iOS上，导航栏或次要底部工具栏可以用来创建一个按钮，显示选择器（也称为旋转按钮），以选择导航树上的正确兄弟节点。iOS上另一个可能的水平导航提供者控件是`SegmentedView`控件，它可以用来显示同一类型内容的不同视角（例如，与未来计划相比的过往旅行或最近的指南和专辑）。
- en: '![Horizontal navigation](img/B04693_07_10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![水平导航](img/B04693_07_10.jpg)'
- en: SegmentedView control on iOS
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: iOS上的SegmentedView控件
- en: On the Windows platform, it is generally a better idea to choose a master/detail
    type of implementation for use-cases with more than "several" categories where
    the possible categories are always visible and displayed side-by-side with the
    content area. It is also possible to use a drop-down menu on a fly-out attached
    to one of the command bar buttons. If the number of categories is limited, the
    `PivotView` control can be employed in the view implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows平台上，对于具有“几个”以上类别且可能类别始终可见并显示在内容区域旁边的用例，选择主/详细类型的实现通常是一个更好的主意。也可以在附加到命令栏按钮之一的飞出菜单中使用下拉菜单。如果类别数量有限，可以在视图实现中使用`PivotView`控件。
- en: '![Horizontal navigation](img/B04693_07_11.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![水平导航](img/B04693_07_11.jpg)'
- en: Command bar flyout on Windows Phone
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Phone上的命令栏飞出
- en: It is also possible, on all platforms, to include in-content selection controls
    that help the user navigate between the categories (dropdowns, pickers, spinners,
    hyperlinks, buttons, and so on).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有平台上，也可以包含内容内的选择控件，帮助用户在类别之间导航（下拉菜单、选择器、旋转按钮、超链接、按钮等）。
- en: For instance, a catalog view for our travel application that allows users to
    browse the uploaded content freely would need to categorize the country items
    on different continents.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的旅行应用程序的目录视图允许用户自由浏览上传的内容，需要将不同大陆的国家项目进行分类。
- en: '![Horizontal navigation](img/B04693_07_12.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![水平导航](img/B04693_07_12.jpg)'
- en: Main App Bar Filter on Android
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Android上的主应用栏过滤器
- en: Finally, the Next/Previous buttons used on the top navigation bar and the main
    app-bar on iOS and Android, respectively, together with the swipe left/right gestures
    on Windows Phone, can create a pleasant experience when navigating between the
    siblings and/or collection items. This type of navigation is generally used at
    the bottom of the hierarchical navigation tree or at the bottom of a sub-tree.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，iOS和Android顶部导航栏和主应用栏上使用的Next/Previous按钮，以及Windows Phone上的左右滑动手势，可以在在兄弟节点和/或集合项之间导航时创造一个愉快的体验。这种类型的导航通常用于层次导航树底部或子树底部。
- en: Vertical navigation
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直导航
- en: Elements that have a parent-child relationship (for example, the parent page
    can be the country view and the child views can be the city details) can use the
    vertical traversal of the navigation tree. The simplest and most common way of
    vertical traversal is navigating to the details view of a content element when
    the user clicks on the item.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 具有父子关系的元素（例如，父页面可以是国家视图，子视图可以是城市详情）可以使用导航树的垂直遍历。最简单和最常见的方式是当用户点击项目时导航到内容元素的细节视图。
- en: A common mistake related to the details concept is to make it a two-step process
    where the user first needs to select the item and then click on a details command
    button. In modern applications, it is crucial to make the UI intuitive by means
    of using the content elements themselves as interaction elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与细节概念相关的一个常见错误是将它变成一个两步过程，其中用户首先需要选择项目，然后点击一个细节命令按钮。在现代应用程序中，通过使用内容元素本身作为交互元素，使UI直观至关重要。
- en: Once the user is in the details view, backward navigation to ascend in the navigation
    tree is implemented either with a back button on the main app-bar (on Android)
    and the navigation bar (on iOS), or by using the hardware back button (on Windows
    Phone) and the soft back button on the system bar (on Android). It is not recommended
    to use an additional back button on the Windows Phone platform since the design
    real estate is already limited and the same functionality can be implemented with
    the hardware button, as opposed to its desktop counterpart where there is no hardware
    button and the design canvas is relatively generous.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户处于详细信息视图，向上导航到导航树中的上一级可以通过在主应用栏（在Android上）和导航栏（在iOS上）上的返回按钮，或者使用Windows
    Phone上的硬件返回按钮和系统栏上的软返回按钮来实现。不建议在Windows Phone平台上使用额外的返回按钮，因为设计空间已经有限，并且可以使用硬件按钮实现相同的功能，这与桌面版本不同，桌面版本没有硬件按钮，设计画布相对宽敞。
- en: '![Vertical navigation](img/B04693_07_13.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![垂直导航](img/B04693_07_13.jpg)'
- en: Semantic Zoom on Windows Phone
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Phone上的语义缩放
- en: On the Windows Phone platform, another way of creating a different perspective
    on the content elements without having to implement a secondary view is to use
    the `SemanticZoom` control. The `SemanticZoom` control provides two views of the
    same list of content elements where the first one is generally a categorized view
    with a smaller number of elements and the second one is the full list view with
    additional details on content items. The navigation between the two views is generally
    implemented with pinch-in and pinch-out gestures (see the *Gestures* section for
    details).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Phone平台上，在不实现二级视图的情况下，创建对内容元素的不同视角的另一种方法是使用`SemanticZoom`控件。`SemanticZoom`控件提供了同一列表内容元素的两个视图，其中第一个通常是一个分类视图，元素数量较少，第二个是包含内容项额外详细信息的完整列表视图。两个视图之间的导航通常通过捏入和捏出手势来实现（有关详细信息，请参阅*手势*部分）。
- en: Jump navigation
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳转导航
- en: Jump or cross navigation occurs when the application navigates between different
    nodes without conforming to the navigation hierarchy (for example, it is possible
    to navigate to the details view of an item that is on the third-level from the
    hub page that is on the top level of a Windows Phone application).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在未遵守导航层次结构的情况下在不同节点之间导航时，就会发生跳转或交叉导航（例如，可以导航到位于Windows Phone应用程序顶层中心页面的第三级项的详细信息视图）。
- en: This type of navigation is generally used with very particular features that
    do not relate to the general outline of the application. The navigation commands
    can be included on the navigation bar or as hyperlinks embedded into the content.
    It is also common to use the command bars to create item related navigation links.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的导航通常与非常特定的功能一起使用，这些功能与应用程序的一般轮廓无关。导航命令可以包含在导航栏中，或者作为嵌入到内容中的超链接。使用命令栏创建与项目相关的导航链接也很常见。
- en: '![Jump navigation](img/B04693_07_14.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![跳转导航](img/B04693_07_14.jpg)'
- en: Navigation Drawer on Android
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Android上的导航抽屉
- en: Another possible way to create navigation access points for switching the context
    in an easy way is to use the Navigation Drawer type functionality on Android.
    A similar experience can be achieved with the persistent tab bar on iOS. As mentioned
    before, comparable functionality was added to the Windows Phone platform with
    the release of Windows 10.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，创建用于轻松切换上下文的导航访问点的另一种可能方式是使用导航抽屉类型的功能。在iOS上，可以通过持续标签栏获得类似体验。如前所述，随着Windows
    10的发布，类似的功能被添加到了Windows Phone平台。
- en: Content elements
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容元素
- en: Each Xamarin target platform puts forward certain strategies and guidelines
    to visualize the content. Although developers are given the freedom to create
    appealing and innovative design blocks, especially on the Android and Windows
    Phone platforms, there are strict guidelines to adhere to. We can group these
    content blocks and controls in several categories.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Xamarin目标平台都提出了一些策略和指南来可视化内容。尽管开发人员被赋予了创建吸引人和创新的设计块的自由，尤其是在Android和Windows
    Phone平台上，但必须遵守严格的指南。我们可以将这些内容块和控制项分为几个类别。
- en: Collection views
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收藏视图
- en: Collection views provide an efficient way to display collection-based content
    elements. In most implementation use cases, collection elements are interactive
    and display attributes of the content items with text and image controls. It is
    also common to add item-related commands or flags on the content items themselves
    in the shape of tokens (for example, the command to add an item to favorites,
    display a status icon, and so on).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 集合视图提供了一种高效的方式来显示基于集合的内容元素。在大多数实现用例中，集合元素是交互式的，并使用文本和图像控件显示内容项的属性。在内容项本身上添加与项目相关的命令或标志也很常见，形式为标记（例如，将项目添加到收藏夹的命令、显示状态图标等）。
- en: UITableView (iOS)
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`UITableView (iOS)`'
- en: On the iOS platform, `UITableView` provides a flexible way to display collection
    data on a customizable layout. On a table view, each cell can be customized to
    display a batch of attributes from the content items and developers are free to
    make use of the inbuilt events and commands to implement additional command logic
    (for example, row actions).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 平台上，`UITableView` 提供了一种灵活的方式来在可自定义的布局上显示集合数据。在表格视图中，每个单元格都可以自定义以显示来自内容项的一批属性，并且开发者可以自由使用内置的事件和命令来实现额外的命令逻辑（例如，行操作）。
- en: '![UITableView (iOS)](img/B04693_07_15.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![UITableView (iOS)](img/B04693_07_15.jpg)'
- en: Grouped table view & table view with details
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 分组表格视图和带有详细信息的表格视图
- en: Another out-of-the-box feature of the `UITableView` and the associated controller
    (`UITableViewSource`) is the so-called indexing of the content elements. Indexing
    works in a similar way as the jump lists on the Windows platform and provides
    an easy way to catalog the content items and enables the user to easily jump into
    the correct section or the group.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 和相关控制器 (`UITableViewSource`) 的另一个开箱即用的功能是内容元素所谓的索引。索引的工作方式与 Windows
    平台上的跳转列表类似，提供了一种轻松的方式来对内容项进行编目，并使用户能够轻松跳转到正确的部分或组。'
- en: A search display controller can also be associated with a `UITableView`, creating
    a standard iOS search experience on a collection of items.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索显示控制器也可以与 `UITableView` 关联，在项目集合上创建标准的 iOS 搜索体验。
- en: 'Some of the possible artefacts that can be included in a table view cell by
    default are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下可以包含在表格视图单元格中的可能的艺术品如下：
- en: '| ![UITableView (iOS)](img/B04693_07_16-a.jpg) | Checkmark | Signifies that
    the row is selected |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| ![UITableView (iOS)](img/B04693_07_16-a.jpg) | 复选标记 | 表示行被选中 |'
- en: '| ![UITableView (iOS)](img/B04693_07_16-b.jpg) | Disclosure indicator | Signifies
    that another table is associated with the row |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| ![UITableView (iOS)](img/B04693_07_16-b.jpg) | 揭示指示器 | 表示与行关联的另一个表格 |'
- en: '| ![UITableView (iOS)](img/B04693_07_16-c.jpg) | Detail disclosure indicator
    | Identifies that the user can click tosee details about the current row (for
    example, Popover) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| ![UITableView (iOS)](img/B04693_07_16-c.jpg) | 详细信息揭示指示器 | 标识用户可以点击以查看当前行的详细信息（例如，弹出视图）|'
- en: '| ![UITableView (iOS)](img/B04693_07_16-d.jpg) | Row reorder | Identifies that
    the row can be dragged to re-order |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| ![UITableView (iOS)](img/B04693_07_16-d.jpg) | 行重排 | 标识行可以被拖动以重新排序 |'
- en: '| ![UITableView (iOS)](img/B04693_07_16-e.jpg) | Row insert | Adds a new row
    to the table |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| ![UITableView (iOS)](img/B04693_07_16-e.jpg) | 行插入 | 向表格中添加新行 |'
- en: '| ![UITableView (iOS)](img/B04693_07_16-f.jpg) | Delete view/hide | Reveals
    or hides the delete button for the current row |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| ![UITableView (iOS)](img/B04693_07_16-f.jpg) | 删除视图/隐藏 | 显示或隐藏当前行的删除按钮 |'
- en: '| ![UITableView (iOS)](img/B04693_07_16-g.jpg) | Delete button | Deletes the
    row |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| ![UITableView (iOS)](img/B04693_07_16-g.jpg) | 删除按钮 | 删除行 |'
- en: '*Table view artifacts*'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*表格视图艺术品*'
- en: UICollectionView (iOS)
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`UICollectionView (iOS)`'
- en: '`UICollectionView` is used to create a grid-like layout on the iOS platform.
    Collection views are also customizable using the in-built properties and base-classes.
    Collection views are more flexible in nature compared to the table views which
    are inherently bound by the table structure and contained cells.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`UICollectionView` 用于在 iOS 平台上创建类似网格的布局。集合视图也可以通过内置属性和基类进行自定义。与本质上受表格结构和包含单元格限制的表格视图相比，集合视图在本质上更灵活。'
- en: Collection views are also made up of cells that can be displayed in numerous
    layouts. The default layout can be customized using a `UICollectionViewFlowLayout`.
    The flow layout can define parameters such as the minimum line spacing between
    the rows, the minimum interim spacing between the items, item sizes, and section
    insets (margins assigned to the sections in the collection).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 集合视图也由可以在多种布局中显示的单元格组成。默认布局可以使用 `UICollectionViewFlowLayout` 进行自定义。流布局可以定义行之间的最小行间距、项目之间的最小临时间距、项目大小和部分内边距（分配给集合中各部分的边距）。
- en: 'The following code sample creates a simple flow layout structure:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例创建了一个简单的流布局结构：
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another option for customizing the layout of a collection view is to inherit
    the `UICollectionViewLayout` class and implement a custom layout. In the custom
    layout implementation, the class is responsible for providing the layout attributes
    such as the size and the location of the cells according to the collection size
    and available layout area.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种自定义集合视图布局的方法是继承 `UICollectionViewLayout` 类并实现自定义布局。在自定义布局实现中，该类负责根据集合大小和可用布局区域提供布局属性，如单元格的大小和位置。
- en: '`UICollectionViewController` is used to normalize the data that is to be presented
    and act as a delegate for the collection and item level events such as cell selection
    and context menus.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`UICollectionViewController` 用于标准化要呈现的数据，并作为集合和单元格级别事件（如单元格选择和上下文菜单）的代理。'
- en: Additionally, the `SupplementaryView` and `DecorationView` classes provide additional
    customizations by giving section related details and UI customizations on the
    collection view layer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`SupplementaryView` 和 `DecorationView` 类通过提供与部分相关的详细信息和集合视图层的UI自定义来提供额外的自定义。
- en: ListView (Android)
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ListView (Android)
- en: '`Listview` is one of the most overused components on the Android Platform.
    While it can be used to display a relatively small list of menu items, with adapters
    it can also be used to visualize data from other applications and services. It
    is possible to compare the `ListView` control to the `UITableView` control on
    the iOS platform and the data provider interfaces. Adapters on Android can be
    compared to `UITableViewSource` on iOS.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 是 Android 平台上使用最频繁的组件之一。虽然它可以用来显示相对较小的菜单项列表，但通过适配器，它也可以用来可视化来自其他应用程序和服务的数据。可以将
    `ListView` 控件与 iOS 平台上的 `UITableView` 控件和数据提供者接口进行比较。Android 上的适配器可以与 iOS 上的 `UITableViewSource`
    相比较。'
- en: By default, `ListView` has 12 built-in views that can be accessed through the
    `Android.Resource.Layout` class. These layouts vary from simple single line of
    text to expandable grouped category views. Each layout uses several control references
    such as Text1, Text2, and Icon, which should be populated by the adapter assigning
    the values to the content fields. Implementing a custom layout is also possible
    by creating an AXML markup file and later referencing the markup in the adapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ListView` 包含12个内置视图，可以通过 `Android.Resource.Layout` 类访问。这些布局从简单的单行文本到可展开的分组类别视图不等。每个布局都使用几个控件引用，如
    Text1、Text2 和 Icon，这些应由适配器通过将值分配给内容字段来填充。通过创建AXML标记文件并在适配器中引用该标记，也可以实现自定义布局。
- en: 'A sample custom layout implementation could look like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例自定义布局实现可能如下所示：
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can also extend the style by adding visual state selectors (see the background
    color assignment in the previous sample).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过添加视觉状态选择器来扩展样式（参见前一个示例中的背景颜色分配）。
- en: 'The custom visual state selector implementation could be defined as the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义视觉状态选择器的实现可以定义为以下内容：
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, the list adapter implementation would look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，列表适配器的实现可能如下所示：
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code should generate a view similar to the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应生成类似于以下截图的视图：
- en: '![ListView (Android)](img/B04693_07_17.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![ListView (Android)](img/B04693_07_17.jpg)'
- en: List View with custom layout
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自定义布局的列表视图
- en: GridView (Android)
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GridView (Android)
- en: Other than the `ListView` control, on the Android platform, collections can
    be visualized in `ViewGroup`. View groups are used to bundle different visual
    trees and display the items in a scrollable view element. The most common implementation
    of the `ViewGroup` is the `GridView` widget. `GridView` is a scrollable grid control
    where content items are again provided with a `ListAdapter` implementation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ListView`控件外，在Android平台上，集合可以通过`ViewGroup`进行可视化。视图组用于捆绑不同的视觉树，并在可滚动的视图元素中显示项目。`ViewGroup`最常见实现是`GridView`小部件。`GridView`是一个可滚动的网格控件，其中内容项再次提供了`ListAdapter`实现。
- en: '`GridView` is generally used with a homogenous set of content items. These
    content items consist of a set of text content and a related image item. Content
    items are generally referred to as tiles and they can also include several content
    related commands.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView`通常与一组同质的内容项一起使用。这些内容项由一组文本内容和相关的图像项组成。内容项通常被称为磁贴，它们还可以包括几个与内容相关的命令。'
- en: Tiles are conceptually similar to the live tile blocks of Modern UI design of
    Windows applications. They are made up of primary and secondary content. The primary
    content fills the entire cell (for example, album cover in a photo gallery application),
    while the secondary is represented by icons or text. The primary action is, in
    most cases, a vertical descending navigation command (navigating to the details
    view). Context actions related to the content item are generally considered to
    be the secondary content on a tile.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 磁贴在概念上类似于Windows应用程序现代UI设计的动态磁贴块。它们由主要内容和次要内容组成。主要内容填充整个单元格（例如，相册应用中的专辑封面），而次要内容则由图标或文本表示。主要操作通常是垂直下降的导航命令（导航到详细视图）。与内容项相关联的上下文操作通常被认为是磁贴上的次要内容。
- en: If the amount of actions on a content item or the content is not homogenous,
    it is advised to consider using cards rather than tiles in a grid view.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内容项上的操作量或内容不是同质的，建议考虑在网格视图中使用卡片而不是磁贴。
- en: CardView (Android)
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CardView（Android）
- en: The `CardView` control was introduced in Android 5.0, and it can be described
    as a self contained content unit. The term self-contained here would refer to
    the fact that cards generally include multiple actions and various content-related
    items. Users generally do not need to resort to secondary actions (select and
    then use the context menu) to interact with these content items.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`CardView`控件是在Android 5.0中引入的，它可以被描述为一个自包含的内容单元。这里的自包含是指卡片通常包括多个操作和多种与内容相关的项目。用户通常不需要求助于二级操作（选择然后使用上下文菜单）来与这些内容项交互。'
- en: '![CardView (Android)](img/B04693_07_18.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![CardView（Android）](img/B04693_07_18.jpg)'
- en: A standard card layout
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 标准卡片布局
- en: Cards are generally used when there is neither the need nor the possibility
    for direct comparison between the collection elements and the content consists
    of various types of data. Cards can be interactive through the use of action buttons
    or, in some cases, in-content input controls. They can be expandable and generally
    have a fixed width.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有直接比较集合元素的需求和可能性，且内容由各种类型的数据组成时，通常使用卡片。卡片可以通过使用操作按钮或在某些情况下，使用内容内的输入控件来交互。它们可以是可展开的，并且通常具有固定的宽度。
- en: '`CardView` is implemented as a `FrameLayout` widget and can be used in association
    with a `ListView` or `GridView` to represent content elements.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`CardView`作为一个`FrameLayout`小部件实现，可以与`ListView`或`GridView`一起使用来表示内容元素。'
- en: ListView and ListBox (Windows Phone)
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ListView和ListBox（Windows Phone）
- en: '`ListView` and `ListBox` are the main collection visualization controls on
    the Windows Phone platform. `ListView` is a more specialized implementation of
    `ListBox`, and it is primarily used for displaying text-based content. Its counterpart
    `ListBox` is highly customizable and can be adopted to display content composed
    of multiple data types.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`和`ListBox`是Windows Phone平台上的主要集合可视化控件。`ListView`是`ListBox`的一个更专业的实现，主要用于显示基于文本的内容。它的对应物`ListBox`高度可定制，可以用于显示由多种数据类型组成的内容。'
- en: Both of these containers can be used for item-level context actions. However,
    `ListBox`, similar to `CardViews` on the Android platform, is used to create interactive
    content elements that might include actions and input controls.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个容器都可以用于项目级别的上下文操作。然而，`ListBox`类似于Android平台上的`CardViews`，用于创建可能包括操作和输入控件的可交互内容元素。
- en: Two-way data binding is available for both of these controls and items can be
    styled and customized using behaviors, item templates, and/or control styles.
    Orientation is vertical by default for both controls, but this can be set to horizontal
    if the content items are desired to be displayed on a horizontal line.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个控件都支持双向数据绑定，并且可以使用行为、项目模板和/或控件样式来对项目进行样式化和自定义。默认情况下，这两个控件的方向都是垂直的，但如果希望内容项目在水平线上显示，则可以将方向设置为水平。
- en: In case there is the need for more customization on the template level and how
    the items are laid out, developers can also use the `ItemsControl`, which is the
    base implementation for most of the collection views on the Windows Phone platform.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在模板级别进行更多自定义以及如何布局项目，开发者还可以使用 `ItemsControl`，这是 Windows Phone 平台上大多数集合视图的基础实现。
- en: In order to customize how the items are displayed on a `ListView`, we would
    first need to create the `DataTemplate` that will be the template used for `ListViewItems`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自定义在 `ListView` 上显示的项目，我们首先需要创建一个 `DataTemplate`，它将是用于 `ListViewItems` 的模板。
- en: 'A sample DataTemplate declaration could look like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例 DataTemplate 声明可能如下所示：
- en: '[PRE4]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once our template is ready, we can assign the template to our `ListView` together
    with the collection data source, which is a list of simple `SampleItem` objects
    with the properties described in the `DataTemplate`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的模板准备就绪，我们可以将模板分配给我们的 `ListView`，同时附带集合数据源，这是一个包含简单 `SampleItem` 对象的列表，这些对象的属性在
    `DataTemplate` 中进行了描述。
- en: 'The code is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE5]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, the content items are displayed in the `ListView` in a two-column style
    with an image, title, and description text.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内容项目在 `ListView` 中以两列样式显示，包括图片、标题和描述文本。
- en: GridView (Windows Phone)
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GridView (Windows Phone)
- en: '`GridView` is another implementation of the `ItemsControl` on the Windows Phone
    platform, which allows the developers to create collection views in a flow layout.
    `GridView` should generally be preferred over `ListBox` or `ListView` when dealing
    with media elements.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView` 是 Windows Phone 平台上 `ItemsControl` 的另一种实现，它允许开发者以流布局创建集合视图。在处理媒体元素时，通常应首选
    `GridView` 而不是 `ListBox` 或 `ListView`。'
- en: '![GridView (Windows Phone)](img/B04693_07_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![GridView（Windows Phone）](img/B04693_07_19.jpg)'
- en: ListView versus GridView
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ListView 与 GridView 的比较
- en: Similar to the previously defined elements, `GridView` supports two-way data
    binding and can be customized using standard methodologies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前定义的元素类似，`GridView` 支持双向数据绑定，并且可以使用标准方法进行自定义。
- en: Virtualizing panels (Windows Phone)
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 虚拟化面板（Windows Phone）
- en: It is important to realize the fact that mobile platforms are not as performant
    as desktop or tablet devices. Especially when dealing with big sets of data, even
    though applications can perform well visually on a desktop workstation, memory
    resources might cause the UI to flicker, lag, or even block on a mobile device.
    In order to decrease the memory usage and improve performance by means of loading
    only the needed data, Windows Runtime provides the virtualizing panel controls
    (for example, `VirtualizingStackPanel`). `ItemsControl`, which is the base for
    most of the collection view controls described here, supports both data and UI
    virtualizations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到移动平台的性能不如桌面或平板设备。特别是当处理大量数据时，尽管应用程序在桌面工作站上可以很好地进行视觉表现，但内存资源可能会在移动设备上导致
    UI 闪烁、延迟，甚至阻塞。为了通过仅加载所需数据来减少内存使用并提高性能，Windows Runtime 提供了虚拟化面板控件（例如，`VirtualizingStackPanel`）。`ItemsControl`
    是大多数在此描述中提到的集合视图的基础，它支持数据和 UI 虚拟化。
- en: '![Virtualizing panels (Windows Phone)](img/B04693_07_20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟化面板（Windows Phone）](img/B04693_07_20.jpg)'
- en: UI Virtualization on Windows Runtime
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Runtime 上的 UI 虚拟化
- en: UI virtualization deals with the controls being rendered on the application
    viewport. The application list view bound to a large number of items, in this
    case, does not need to render and keep the controls in the runtime memory but
    only deal with the ones that are in the viewport. In this paradigm, controls that
    are removed from the screen with a scrolling action need to be destroyed and redrawn
    if the user scrolls back.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: UI 虚拟化处理的是在应用程序视图中渲染的控件。当应用程序的列表视图绑定到大量项目时，在这种情况下，不需要在运行时内存中渲染和保持控件，而只需处理视口中的控件。在这个范例中，通过滚动操作从屏幕上移除的控件，如果用户滚动回来看，需要被销毁并重新绘制。
- en: Data virtualization deals with paged data sources. For instance, with a "virtualizable"
    data source (a collection that implements `ISupportIncrementalLoading`), only
    the data needed for the current viewport is loaded into the application and additional
    batches are requested from the data source when the UI control needs to display
    additional items. Random access virtualization lets developers retrieve a subset
    of data on any random ordinal. For this type of data virtualization, the data
    source needs to implement `INotifyCollectionChanged` and `IObservableVector`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数据虚拟化处理分页数据源。例如，对于“可虚拟化”的数据源（实现`ISupportIncrementalLoading`的集合），只有当前视口所需的数据被加载到应用程序中，当UI控件需要显示更多项目时，会从数据源请求额外的批次。随机访问虚拟化允许开发者在任何随机序号上检索数据子集。对于这种类型的数据虚拟化，数据源需要实现`INotifyCollectionChanged`和`IObservableVector`。
- en: Modal views
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模态视图
- en: Modal views are temporary view components that can provide an interactive interface
    to get the user's input on a certain task or decide on the execution path of a
    workflow. It is also common to use alert dialogs to inform the user about critical
    information that is crucial for the execution of the application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 模态视图是临时视图组件，可以提供交互式界面以获取用户对特定任务的输入或决定工作流程的执行路径。使用警告对话框通知用户关于对应用程序执行至关重要的关键信息也是常见的。
- en: Popover and alerts (iOS)
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弹出视图和警告（iOS）
- en: The iOS platform provides various modal dialogs to display, edit, and manipulate
    data in different scenarios. Each of these dialog types look different but the
    common denominator is the fact that they always get the focus and are displayed
    on the highest layer on the screen, while the content under the dialog is hidden
    with a translucent overlay layer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: iOS平台提供了各种模态对话框，用于在不同场景下显示、编辑和操作数据。这些对话框类型的外观各不相同，但共同点是它们总是获得焦点，并显示在屏幕的最高层，而对话框下的内容则通过半透明覆盖层隐藏。
- en: Action sheets are one of the most-frequently used modal dialogs. This dialog
    type is generally used to give the user an option before starting a task or cancelling
    the task. It is generally displayed as a list of buttons; the last of which is
    generally the "cancel" button, at the bottom of the screen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 操作表是使用频率最高的模态对话框之一。这种对话框类型通常用于在开始任务或取消任务之前给用户一个选项。它通常以按钮列表的形式显示；最后一个按钮通常是屏幕底部的“取消”按钮。
- en: '![Popover and alerts (iOS)](img/B04693_07_21.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Popover 和警告（iOS）](img/B04693_07_21.jpg)'
- en: Action sheet display on iOS
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: iOS上的操作表显示
- en: Action sheets can be initialized using a `UIAlertController` and specifying
    the `UIAlertControllerStyleActionSheet`. If the screen size permits (on a horizontally
    regular environment), action sheets are displayed as a popover.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`UIAlertController`并指定`UIAlertControllerStyleActionSheet`来初始化操作表。如果屏幕尺寸允许（在水平规则的环境中），操作表将以弹出视图的形式显示。
- en: Alert dialogs are another type of modal dialogs on iOS. Alerts are generally
    used to inform or ask consent from the user about an issue that affects the execution
    of the application. Unlike action sheets, alert dialogs can contain descriptive
    text, a title, and even a text input field.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 警告对话框是iOS上另一种类型的模态对话框。警告通常用于通知或请求用户同意影响应用程序执行的问题。与操作表不同，警告对话框可以包含描述性文本、标题，甚至文本输入字段。
- en: '![Popover and alerts (iOS)](img/B04693_07_22.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Popover 和警告（iOS）](img/B04693_07_22.jpg)'
- en: Alert dialog with input field and with only description and title
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 带输入字段且只有描述和标题的警告对话框
- en: Alert dialogs can be invoked with `UIAlertController`, using the `UIAlertControllerStyleAlert`.
    Alert dialogs should avoid any kind of redundant, informal, and negative content.
    If the title provides enough information for the user to continue with the execution,
    description text could be omitted.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`UIAlertController`和指定`UIAlertControllerStyleAlert`来调用警告对话框。警告对话框应避免任何形式的冗余、非正式和负面内容。如果标题提供了足够的信息让用户继续执行，则可以省略描述性文本。
- en: Popovers are another type of temporary context views on the iOS platform. However,
    popovers only are displayed on a horizontally regular environment (in both portrait
    and landscape in iPad, and only in landscape rotation in iPhone 6 Plus). In horizontally
    compact environments, they are displayed as full screen modal dialogs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出视图是iOS平台上的另一种临时上下文视图。然而，弹出视图仅在水平规则的环境中显示（在iPad的纵向和横向，以及iPhone 6 Plus的横向旋转中）。在水平紧凑的环境中，它们作为全屏模态对话框显示。
- en: In order to initialize a popover, `UIPopoverPresentationController` can be used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化弹出视图，可以使用`UIPopoverPresentationController`。
- en: Modal dialogs are another type of temporary view display used on iOS. Modal
    dialogs can be used in scenarios where a self-contained and compact view is needed
    to execute a very particular task or workflow.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 模态对话框是 iOS 上使用的另一种类型的临时视图显示。模态对话框可用于需要执行非常特定任务或工作流程的自包含和紧凑视图的场景。
- en: '![Popover and alerts (iOS)](img/B04693_07_23.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![弹出和警报（iOS）](img/B04693_07_23.jpg)'
- en: Modal dialog with page sheet style
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 页面表单样式的模态对话框
- en: Modal dialogs can be created using the `UIPresentationController` with various
    modal presentation styles (full screen, page sheet, form sheet, and current context).
    However, the presentation styles associated with modal dialogs behave almost the
    same on horizontally compact environments (all iPhone models except iPhone 6 Plus
    in landscape orientation).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 模态对话框可以使用 `UIPresentationController` 创建，具有各种模态呈现样式（全屏、页面表单、表单表单和当前上下文）。然而，与模态对话框关联的呈现样式在水平紧凑环境中几乎表现相同（所有
    iPhone 模型，除了横向模式下的 iPhone 6 Plus）。
- en: Flyout, popups, and menus (Windows Phone)
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弹出菜单、弹出和菜单（Windows Phone）
- en: Flyouts are the main modal dialogs on the Windows Phone platform. They can be
    used in various scenarios, including showing a context menu, showing additional
    details of an item, or getting consent from the user. The common behavior of different
    types of flyouts is that they are always displayed with the highest z-index on
    screen and the elements underneath are disabled with a translucent overlay. Flyouts
    have, by default, a light-dismiss mechanism. In other words, they can be dismissed
    if the user taps anywhere outside the flyout control's borders.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单是 Windows Phone 平台上的主要模态对话框。它们可用于各种场景，包括显示上下文菜单、显示项目的附加详细信息或获取用户的同意。不同类型弹出菜单的共同行为是它们总是以最高的
    z-index 在屏幕上显示，并且下面的元素通过半透明覆盖被禁用。弹出菜单默认具有轻触关闭机制。换句话说，如果用户在弹出控件边界外任何地方轻触，它们可以被关闭。
- en: Flyouts are generally associated with another control on the current view either
    by using the attached properties or using the `ShowAt` function of the `Flyout`
    class. The Content property of the Flyout class is used to assign a `UIElement`
    to display on screen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单通常与当前视图上的另一个控件相关联，要么通过使用附加属性，要么通过使用 `Flyout` 类的 `ShowAt` 函数。`Flyout` 类的内容属性用于分配一个
    `UIElement` 以在屏幕上显示。
- en: '[PRE6]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding sample code would create a flyout which has text content, an
    input field, and a button as its content:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例代码将创建一个包含文本内容、输入字段和按钮的弹出菜单：
- en: '![Flyout, popups, and menus (Windows Phone)](img/B04693_07_24.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![弹出菜单、弹出和菜单（Windows Phone）](img/B04693_07_24.jpg)'
- en: Simple flyout menu on Windows Phone
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Phone 上的简单弹出菜单
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In spite of the fact that flyouts are always attached to a `UIElement` (either
    using XAML or through code) and the dialog should be displayed in the vicinity
    of the associated element, on Windows Phone, flyouts behave like message dialogs
    displaying on the top of the screen.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管弹出菜单始终附加到一个 `UIElement`（无论是使用 XAML 还是代码）并且对话框应该显示在相关元素附近，但在 Windows Phone
    上，弹出菜单的行为类似于显示在屏幕顶部的消息对话框。
- en: In Windows Runtime, it is possible to use the derived types of flyouts for specific
    scenarios. `MenuFlyout`, `TimePickerFlyout`, and `DateTimePickerFlyout` are examples
    for these implementations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 运行时，可以使用弹出菜单的派生类型来处理特定场景。`MenuFlyout`、`TimePickerFlyout` 和 `DateTimePickerFlyout`
    是这些实现的示例。
- en: '![Flyout, popups, and menus (Windows Phone)](img/B04693_07_25.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![弹出菜单、弹出和菜单（Windows Phone）](img/B04693_07_25.jpg)'
- en: Menu Flyout Usage
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单弹出菜单使用
- en: Other than flyouts, popup control can also be used to display a temporary view
    or details of a content item. Popups are generally stand-alone controls and can
    directly be included in the view XAML. They can optionally use light-dismiss and
    can be shown or hidden using the `IsOpen` property.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了弹出菜单之外，弹出控制还可以用来显示临时视图或内容项的详细信息。弹出菜单通常是独立的控件，可以直接包含在视图 XAML 中。它们可以选择使用轻触关闭，并可以使用
    `IsOpen` 属性来显示或隐藏。
- en: 'For alert dialogs or critical input requirements, the `MessageDialog` class
    provides developers a familiar implementation tool. `MessageDialog` is a simple
    dialog used to display text content and numerous UI commands. The `UICommand`
    class represents a button and the associated action (if any) and is used to display
    actions on the dialog and provide a result to the dialog once selected by the
    user. The following implementation creates a message dialog with a text field
    and two commands:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于警报对话框或关键输入要求，`MessageDialog`类为开发者提供了一个熟悉的实现工具。`MessageDialog`是一个简单的对话框，用于显示文本内容和众多UI命令。`UICommand`类代表一个按钮及其相关的动作（如果有），用于在对话框上显示动作，并在用户选择后为对话框提供一个结果。以下实现创建了一个带有文本字段和两个命令的消息对话框：
- en: '[PRE7]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This would be shown on the UI similar to how flyouts are visualized:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这在UI上显示的方式类似于飞出视图的视觉表示：
- en: '![Flyout, popups, and menus (Windows Phone)](img/B04693_07_26.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Flyout, popups, and menus (Windows Phone)](img/B04693_07_26.jpg)'
- en: MessageDialog example on Windows Phone
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Phone上的MessageDialog示例
- en: Dialogs (Android)
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对话框（Android）
- en: Dialogs on Android can be implemented as simple as an alert dialog or a full
    screen dialog that retrieves the required form data to continue the current task.
    Dialogs behave the same way as modal dialog implementations on other platforms;
    they interrupt the current task and are displayed on top of the underlying layer.
    The content underneath is hidden with a translucent grey overlay layer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上的对话框可以简单实现，如警报对话框或全屏对话框，用于检索所需表单数据以继续当前任务。对话框的行为与其他平台上的模态对话框实现相同；它们中断当前任务，并显示在底层之上。底层内容通过半透明的灰色覆盖层隐藏。
- en: Simple alert dialogs, like their parallel implementations on other platforms,
    consist of a title, a descriptive content, and confirmation actions. They are
    invoked on critical scenarios where the user's input is crucial to continue with
    the execution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的警报对话框，类似于其他平台上的并行实现，由标题、描述性内容和确认操作组成。它们在用户输入对执行至关重要的情况下被调用。
- en: '![Dialogs (Android)](img/B04693_07_27.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Dialogs (Android)](img/B04693_07_27.jpg)'
- en: Android Alert Dialog
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Android警报对话框
- en: It is important to be careful to avoid any ambiguity in the descriptive content
    and the action button contents.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述性内容和动作按钮内容中避免任何歧义是很重要的。
- en: Another popular dialog used in Android applications are the context menu dialogs.
    This type of dialog does not require any confirmation once the item from the list
    is selected. They also have the light dismiss behavior. If the dialogs have additional
    information about the selection item and maybe additional actions, they are referred
    to as simple dialogs. The selection on these dialogs do not require confirmation
    either.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android应用程序中使用的另一种流行对话框是上下文菜单对话框。这种类型的对话框在选择列表中的项目后不需要任何确认。它们也有轻量级消失的行为。如果对话框有关于选择项的附加信息以及可能的其他操作，它们被称为简单对话框。这些对话框上的选择也不需要确认。
- en: '![Dialogs (Android)](img/B04693_07_28.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![Dialogs (Android)](img/B04693_07_28.jpg)'
- en: Android Dialogs
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Android对话框
- en: If the dialog implementation requires the user to explicitly confirm the choice
    made, these dialogs are generally referred to as confirmation dialogs. It is common
    to have a "cancel" button at the bottom of the dialog screen so the previous selected
    option can be kept.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对话框实现需要用户明确确认所做的选择，这些对话框通常被称为确认对话框。在对话框屏幕底部通常有一个“取消”按钮，以便保留之前选定的选项。
- en: Text views
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本视图
- en: On all three platforms, with the emergence of the minimalist design inclinations,
    typography and text content items became the focus of UX design. Each platform
    has well-defined guidelines on font sizes and typefaces for different scenarios.
    More importantly, each of these platforms has specialized ways to display and
    edit rich text formats.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个平台上，随着极简设计倾向的出现，排版和文本内容项成为了用户体验设计的焦点。每个平台都有针对不同场景的字体大小和字体的明确指南。更重要的是，这些平台中的每一个都有专门的方式来显示和编辑富文本格式。
- en: '**Windows**: On the Windows Phone platform, Run elements are used to define
    specific sections of text that have a certain formatting applied to. Run elements
    can then be included in `TextBlock` elements or `RichTextBlock` controls. In addition
    to the Runs, `RichTextBlocks` can be used in conjunction with html-like styling
    elements (for example, bold, span, italics, and so on). Using the `RichTextBlocks`
    and `RichTextBlockOverflow` as a container, any shape and style text displays
    can be supported in Windows Phone applications.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: 在 Windows Phone 平台上，Run 元素用于定义应用特定格式化的文本部分。Run 元素可以包含在 `TextBlock`
    元素或 `RichTextBlock` 控件中。除了 Runs，`RichTextBlocks` 还可以与类似 html 的样式元素（例如，粗体、span、斜体等）结合使用。使用
    `RichTextBlocks` 和 `RichTextBlockOverflow` 作为容器，Windows Phone 应用程序可以支持任何形状和样式的文本显示。'
- en: '**Android**: On the Android platform, text formatting is achieved using the
    so-called spans. There are numerous pre-styled span implementations such as `RelativeSizeSpan`,
    `ForegroundColorSpan`, and `ClickableSpan`. These span implementations are used
    to set certain sections of a `SpannableString` with the described styles. There
    is a `SpannableStringBuilder` class that can be used to create the styled paragraphs/text
    content. Once the `SpannableString` is complete, it can be used as content for
    the `TextView` control.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**: 在 Android 平台上，使用所谓的 spans 实现文本格式化。有大量的预定义样式 span 实现，例如 `RelativeSizeSpan`、`ForegroundColorSpan`
    和 `ClickableSpan`。这些 span 实现用于设置 `SpannableString` 中某些部分的描述样式。有一个 `SpannableStringBuilder`
    类可以用来创建带样式的段落/文本内容。一旦 `SpannableString` 完成，它就可以用作 `TextView` 控件的内容。'
- en: '**iOS**: On the iOS platform, text-related features and controls are introduced
    by the Core Text library. The `UITextView` control is the visualization element
    in this library. Text formatting is achieved by using the `NSMutableAttributedText`
    class. For attributed text content, different text ranges can be set to use certain
    attributes such as `NSUnderlineStyleAttribute`, `NSBackgroundColorAttribute`,
    and so on. When displaying attributed text blocks a `NSTextContainer` can be used
    to describe a shape as line fragments in which the text should be displayed.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**: 在 iOS 平台上，文本相关功能和控件由 Core Text 库引入。`UITextView` 控件是该库中的可视化元素。通过使用
    `NSMutableAttributedText` 类实现文本格式化。对于带属性的文本内容，可以设置不同的文本范围以使用某些属性，例如 `NSUnderlineStyleAttribute`、`NSBackgroundColorAttribute`
    等。在显示带属性的文本块时，可以使用 `NSTextContainer` 来描述一个形状，其中文本应该以行片段的形式显示。'
- en: Web views
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网页视图
- en: Web view controls are used to display rich HTML content on Xamarin target platforms.
    These web view controls build their own navigation stack independent from the
    application runtime. On Android and Windows phone, it is also possible to inject
    JavaScript into the HTML content that is being displayed on the control.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin 目标平台上，网页视图控件用于显示丰富的 HTML 内容。这些网页视图控件构建自己的导航堆栈，独立于应用程序运行时。在 Android
    和 Windows Phone 上，还可以将 JavaScript 注入到控件上显示的 HTML 内容中。
- en: On all the platforms, it is possible to load not only remote, but also local
    web applications from the application resources.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有平台上，不仅可以从远程加载，还可以从应用程序资源中加载本地网络应用程序。
- en: Feedback
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反馈
- en: One of the pillars of modern application design is keeping the user informed
    at all times about the actions being executed by the application and the progress
    of these tasks. Even if the application is dealing with a blocking call (the execution
    cannot continue before finishing the task), displaying a progress ring creates
    the illusion that the application is still responsive.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序设计的支柱之一是确保用户始终了解应用程序正在执行的操作以及这些任务的进度。即使应用程序正在处理阻塞调用（在完成任务之前无法继续执行），显示进度环也能营造出应用程序仍然响应的错觉。
- en: 'Progress indicators can be categorized into two groups: indeterminate and determinate.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 进度指示器可以分为两组：不确定的和确定的。
- en: Indeterminate progress
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不确定进度
- en: Indeterminate tasks and the associated progress indicators are related to the
    operations where the application cannot provide neither an estimated completion
    time nor progress information. These operations might depend on completion of
    multiple sub-procedures and might be related to the whole application or only
    a single UI element.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定的任务及其相关的进度指示器与那些应用程序无法提供估计完成时间或进度信息的操作相关。这些操作可能依赖于多个子程序的完成，可能与整个应用程序或单个 UI
    元素相关。
- en: With indeterminate processes, we first need to decide on how crucial the process
    is for the application. If the application cannot continue without completing
    the current process, this would be an application-level blocking call. In cases
    of blocking calls (involving single step or multiple steps), it is a good idea
    to use a progress ring on the main content area. A good example for this scenario
    would be a main client trying to retrieve e-mail messages from the server without
    knowing how many items there are on the server. If there are multiple steps involved
    in this process, you can additionally show an information text near or over the
    progress ring.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不确定过程，我们首先需要决定该过程对于应用程序有多重要。如果应用程序无法在没有完成当前过程的情况下继续，这将是一个应用程序级阻塞调用。在涉及阻塞调用（包括单步或多步）的情况下，使用主内容区域上的进度环是一个好主意。这种场景的一个好例子是主客户端试图从服务器检索电子邮件消息，而不知道服务器上有多少条消息。如果此过程中涉及多个步骤，你还可以在进度环附近或上方显示信息文本。
- en: This implementation on Android can be achieved with the `ProgressDialog` class.
    Instantiating this control provides a modal dialog with the possibility to include
    a descriptive text. It is important to set the indeterminate flag to true before
    displaying it on the UI.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，可以使用`ProgressDialog`类实现此实现。实例化此控件提供了一个模态对话框，可以包含描述性文本。在将其显示在UI上之前，将不确定标志设置为true是很重要的。
- en: '![Indeterminate progress](img/B04693_07_29.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![不确定进度](img/B04693_07_29.jpg)'
- en: Progress rings on Android, iOS and Windows Phone
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Android、iOS和Windows Phone上的进度环
- en: On iOS, the same visualization is achieved with the `UIActivityIndicatorView`.
    You can modify the behavior to animate and change the color.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，使用`UIActivityIndicatorView`可以实现相同的可视化。你可以修改其行为以实现动画和颜色变化。
- en: On Windows Phone, the `ProgressRing` class provides the same type of functionality.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Phone上，`ProgressRing`类提供了相同类型的功能。
- en: In indeterminate scenarios where the process being executed does not stop the
    user from continuing with application interaction, it is better to give a more
    subtle indication about the process and the controls involved in the execution.
    This can be achieved by using a progress ring or a bar in the vicinity of or over
    the control where the process started. On iOS, the only distinction between the
    progress bar and the ring is the process being determinate or indeterminate. However,
    on Android and Windows Phone, a progress bar can also act as an indeterminate
    task indicator. On the Windows Phone platform, it is also general practice to
    display an indeterminate progress bar on top of the screen if the process is an
    application level task, but the interaction with the application can continue
    without waiting for the result of this process.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在不确定的场景中，如果正在执行的过程不会阻止用户继续与应用程序交互，最好给出关于过程和执行中涉及的控件更微妙的指示。这可以通过使用位于或覆盖过程开始处的进度环或进度条来实现。在iOS上，进度条和环之间的唯一区别是过程是确定性的还是不确定性的。然而，在Android和Windows
    Phone上，进度条也可以作为不确定任务指示器。在Windows Phone平台上，如果过程是应用程序级任务，通常也会在屏幕顶部显示不确定进度条，但与应用程序的交互可以继续，无需等待此过程的完成结果。
- en: Determinate progress
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定进度
- en: Determinate tasks and associated indicators are related to processes where the
    application can provide a current state information to the user. A determinate
    progress indicator of choice on Xamarin target platforms is the progress bar.
    Progress bars, while providing a visual indication of the current completion state
    of the process, can also include a label giving a text description of the current
    state of the task.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 确定任务及其相关指示器与应用程序可以提供当前状态信息给用户的过程相关。在Xamarin目标平台上，首选的确定进度指示器是进度条。进度条在提供过程当前完成状态的视觉指示的同时，还可以包括一个标签，给出任务当前状态的文本描述。
- en: It is important to also provide a cancellation method (for example, a cancel
    button near the progress bar) if the process is relatively long.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过程相对较长，提供取消方法（例如，进度条附近的取消按钮）也很重要。
- en: '![Determinate progress](img/B04693_07_30.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![确定进度](img/B04693_07_30.jpg)'
- en: Android determinate progress bar displays
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Android确定进度条显示
- en: On the Android platform, in addition to the progress indication, a buffering
    percentage can also be displayed on the progress bar.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上，除了进度指示外，进度条上还可以显示缓冲百分比。
- en: User interaction
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户交互
- en: Another important element in cross-platform development projects is the set
    of user interaction patterns for the application. Users already using the application
    on other platforms would want to find the same interaction patterns on clients
    running on another platform. This decision process gets even more complicated
    with platform specific interaction patterns, since the application should provide
    a familiar interface for platform users. It is important to achieve a balanced
    compromise between platform nativity and application identity in such scenarios
    and find the optimum solution.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台开发项目中，应用程序的用户交互模式集合是另一个重要元素。已经在其他平台上使用应用程序的用户希望在其他平台运行的客户端上找到相同的交互模式。当涉及到特定平台的交互模式时，这个决策过程变得更加复杂，因为应用程序应该为平台用户提供一个熟悉的界面。在这种情况下，实现平台原生性和应用程序身份之间的平衡妥协非常重要，并找到最佳解决方案。
- en: A good example for branding by means of using an interaction pattern, would
    be the "pull-to-refresh" interactive pattern used in iOS applications. Most application
    providers dealing with information feeds (for example, Facebook, Twitter, and
    so on) used this implementation in their iOS applications. Even though this is
    not a native interaction pattern on Android and Windows Phone, a similar approach
    quickly became popular on these platforms; hence, most developers and users are
    now adopting this use-case on various platforms.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互模式进行品牌的一个好例子是iOS应用程序中使用的“下拉刷新”交互模式。大多数处理信息流（例如，Facebook、Twitter等）的应用程序提供商都在他们的iOS应用程序中使用了这种实现。尽管这不是Android和Windows
    Phone上的原生交互模式，但类似的方案在这些平台上迅速流行起来；因此，大多数开发者和用户现在在各种平台上都采用了这种用例。
- en: Interactive controls
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互控件
- en: In most cases, applications built for Xamarin target platforms would require
    input and other interactive controls to collect necessary information from the
    user. By interactive, we are referring to almost all the UI controls that can
    be used in a Xamarin application. In this case, even a simple filter dropdown
    control to select a different view perspective would be an interaction control,
    requesting information from the user display appropriate data or perspective.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，为Xamarin目标平台构建的应用程序需要输入和其他交互控件来收集用户必要的信息。通过交互，我们指的是几乎可以在Xamarin应用程序中使用的所有UI控件。在这种情况下，甚至一个简单的筛选下拉控件，用于选择不同的视图视角，也会是一个交互控件，请求用户显示适当的数据或视角。
- en: Text input
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本输入
- en: Text input fields are one of the most used type of input fields. Text fields
    can be implemented as a single line of text or as a multiline. An important aspect
    of text fields is the fact that as soon as a text input field gets selected on
    a touch-enabled device, the virtual keyboard appears on the screen. It is generally
    a good idea to keep this in mind while designing the user interface and implementing
    it later on.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输入字段是使用最频繁的一种输入字段类型。文本字段可以设计为单行文本或多行文本。文本字段的一个重要方面是，一旦在触摸设备上选中文本输入字段，虚拟键盘就会出现在屏幕上。在设计用户界面并在之后实现时，牢记这一点通常是一个好主意。
- en: On iOS, while the `UITextField` provides an input mechanism for single line
    of text requirements, `UITextView` can be used to create editable rich text content.
    Both of these controls provide options such as capitalization and correction.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，虽然`UITextField`提供了单行文本输入的机制，但`UITextView`可以用来创建可编辑的富文本内容。这两个控件都提供了诸如大写和纠错等选项。
- en: '![Text input](img/B04693_07_31.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![文本输入](img/B04693_07_31.jpg)'
- en: UITextView Edit and Read-only Views
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: UITextView 编辑和只读视图
- en: Additionally, `UITextView` provides detectors that can transform Internet addresses
    to links, addresses to map links, phone numbers into deep-links to make a phone
    call, and date/time values to calendar event items.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`UITextView`提供了可以将互联网地址转换为链接、地址转换为地图链接、电话号码转换为拨打电话的深度链接以及日期/时间值转换为日历事件项的检测器。
- en: Android text input fields are similar to the ones on iOS platform. The key difference
    is that on Android, instead of two different controls, only the `EditText` control
    exists for multiline and single line text inputs. This is achieved by settings
    the `InputType` property of the control (or `inputType` attribute in AXML). Other
    input scopes, besides the text format, can be set such as postal address, capitalized
    words, autocorrect, and capitalized sentence beginnings. Note that these scope
    parameters are bit-wise combinations. Another specialized control that provides
    auto suggestions is the `AutoCompleteTextView`, to which developers can assign
    an `ArrayAdapter` as a source for suggestions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Android文本输入字段与iOS平台上的类似。主要区别在于，在Android上，除了两个不同的控件外，只有`EditText`控件用于多行和单行文本输入。这是通过设置控件的`InputType`属性（或在AXML中的`inputType`属性）来实现的。除了文本格式之外，还可以设置其他输入范围，例如邮政地址、首字母大写、自动更正和句子开头大写。请注意，这些范围参数是位组合。另一个提供自动建议的专用控件是`AutoCompleteTextView`，开发者可以将`ArrayAdapter`分配为建议的源。
- en: On Windows Phone, `TextBox` is the most commonly used text input control. It
    can be highly customized to meet the previously mentioned requirements. Moreover,
    the input scope field lets developers control the virtual keyboard displayed for
    entering the value. For instance, setting the scope to be a telephone number would
    display a keyboard with only digits. `AutoSuggestBox`, `PasswordBox`, and `RichEditBox`
    are other controls that can be used for more specialized scenarios.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Phone上，`TextBox`是最常用的文本输入控件。它可以高度定制以满足之前提到的要求。此外，输入范围字段允许开发者控制用于输入值的虚拟键盘。例如，将范围设置为电话号码将显示仅包含数字的键盘。"AutoSuggestBox"、"PasswordBox"和"RichEditBox"是其他可以用于更专业场景的控件。
- en: Dropdown selection
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下拉选择
- en: Dropdown elements can be used, on each platform, utilizing the specialized controls.
    While the `UIPickerView` is used on iOS, the same implementation is achieved on
    Android by so-called spinners. Spinners, very much like other content-driven controls,
    are populated with a `SpinnerAdapter`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个平台上，可以使用专门的控件来使用下拉元素。在iOS上使用`UIPickerView`，而在Android上通过所谓的旋转器实现相同的功能。旋转器与其他内容驱动的控件非常相似，它们通过`SpinnerAdapter`进行填充。
- en: '![Dropdown selection](img/B04693_07_32.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![下拉选择](img/B04693_07_32.jpg)'
- en: Dropdown controls on iOS, Android and Windows Phone
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: iOS、Android和Windows Phone上的下拉控件
- en: In addition to the spinner control, simple menu dialogs can also be used for
    users' input. Windows Runtime provides additional specialized controls, the `ComboBox`
    and `ListView`, for different selection use cases.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除了旋转器控件外，简单的菜单对话框也可以用于用户的输入。Windows Runtime为不同的选择用例提供了额外的专用控件，即`ComboBox`和`ListView`。
- en: Option selection
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项选择
- en: Similar to the radio or check boxes on HTML forms, each platform provides options
    related UI elements. On Android, specialized controls for this scenario are Checkbox,
    RadioButton, and ToggleButton. Starting with Android 4.0 (API 14), Switch control
    can also be used. Other than the visual difference between these controls, the
    behavior is the same. On iOS, the main toggle control for Boolean data types is
    the Switch. Similar to Android, Windows Phone offers checkbox, radio button, and
    toggle switch control with option selections and Boolean types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML表单中的单选按钮或复选框类似，每个平台都提供了相关的UI元素选项。在Android上，针对此场景的专用控件有复选框、单选按钮和切换按钮。从Android
    4.0（API 14）开始，也可以使用开关控制。除了这些控件之间的视觉差异外，行为是相同的。在iOS上，布尔数据类型的主要切换控件是开关。类似于Android，Windows
    Phone提供复选框、单选按钮和切换开关控件，以及选项选择和布尔类型。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many other controls on each platform, and each provides a specific
    use case for different UI interaction scenarios. UX guides for Windows Runtime
    and Material Design are great resources for the respective platforms. Even though
    the Apple human interface design documents do not provide extensive UX guidelines
    as the other platforms, they are great resources to learn about user control use
    cases.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都有许多其他控件，每个控件都为不同的UI交互场景提供了特定的用途。Windows Runtime和Material Design的用户体验指南是相应平台上的优秀资源。尽管苹果的人机界面设计文档没有像其他平台那样提供广泛的用户体验指南，但它们仍然是了解用户控件用例的宝贵资源。
- en: Gestures
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势
- en: When developing for Xamarin target platforms, you should always keep in mind
    that the devices that are going to run the application will most probably have
    a touchscreen.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当为Xamarin目标平台开发时，你应该始终记住，将要运行应用程序的设备很可能具有触摸屏。
- en: Touchscreen devices, apart from the classic pointer-like gestures (for example,
    tap, double tap, scroll, and so on), also provide various interaction gestures
    that help developers create an interface that can interact with the user in a
    more natural way.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸屏设备除了经典的指针式手势（例如，点击、双击、滚动等）外，还提供了各种交互手势，这些手势有助于开发者创建能够以更自然方式与用户交互的界面。
- en: '| ![Gestures](img/B04693_07_33.jpg) | Tap | In most scenarios, the tap gesture
    is analogous to a single click with a pointer device. It is primarily used to
    select a control. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| ![手势](img/B04693_07_33.jpg) | 点击 | 在大多数场景中，点击手势与指针设备的单次点击类似。它主要用于选择控件。'
- en: '| Long Press | Long press or tap and hold is used to access a context menu
    on Windows Phone. It is used for item selection on Android. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 长按 | 长按或点击并保持用于在Windows Phone上访问上下文菜单。在Android上，它用于项目选择。'
- en: '| Double-Tap | Double tap is generally used for scaling up / zooming-in on
    a control. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 双击 | 双击通常用于放大/缩小控件。'
- en: '| Swipe Down | Swipe down or pan down is used on vertical scroll scenarios.
    Also, list controls support swipe down for selection on Windows. It is also common
    to be used with "Pull to Refresh" implementations. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 向下滑动 | 向下滑动或平移向下用于垂直滚动场景。此外，列表控件在Windows上支持滑动向下进行选择。它也常与“下拉刷新”实现一起使用。'
- en: '| Swipe Right | Similar to swipe down, swipe right is used on vertical scroll
    scenarios and sibling navigation scenarios. It is called "flick" if the gesture
    is fast. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 向右滑动 | 与向下滑动类似，向右滑动用于垂直滚动场景和同级导航场景。如果手势快速，则称为“轻扫”。'
- en: '| Swipe Left | This is same as other pan gestures. It can also be used to delete
    a list item on iOS and Windows Phone 10. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 向左滑动 | 这与其他平移手势相同。它也可以用于在iOS和Windows Phone 10上删除列表项。'
- en: '| Swipe Up | This is another panning gesture. It can additionally be used to
    reveal a bottom sheet on Android applications. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 向上滑动 | 这是一种另一种平移手势。它还可以用于在Android应用程序上显示底部面板。'
- en: '| Tap & Drag | This is generally used as an active gesture to interact with
    draggable components. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 点击与拖动 | 这通常用作与可拖动组件交互的主动手势。'
- en: '| Pinch Out | This is used in active canvas application patterns. It is used
    to zoom in on a view. On Windows, semantic zoom control makes use of this. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 向外捏合 | 这用于活动画布应用模式。它用于放大视图。在Windows上，语义缩放控件就利用了这一点。'
- en: '| Pinch In | This is similar to the Pinch-Out gesture and is used to zoom out
    of an active content area of application screen (for example, zoom in on a photo).
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 向内捏合 | 这与向外捏合手势类似，用于缩小应用程序屏幕活动内容区域（例如，放大照片）。'
- en: '| Rotate | This is another gesture used on active canvas applications (for
    example, a map client). It is used to rotate the current view-port. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 旋转 | 这是另一种在活动画布应用程序（例如，地图客户端）上使用的手势。它用于旋转当前视口。'
- en: '*Common Gestures*'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*常见手势*'
- en: While some of these gestures are already implemented by out-of-box controls
    on Xamarin platforms, there might be scenarios where you need to use them to create
    a new interaction use case in your application. For these type of requirements,
    specialized implementations can be found on respective frameworks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些手势中的一些已经在Xamarin平台上的内置控件中实现，但可能存在需要使用它们来在应用程序中创建新的交互用例的场景。对于这类需求，可以在相应的框架中找到专门的实现。
- en: On the iOS platform, the starting point for gesture recognizer implementation
    is the abstract class `UIGestureRecognizer`. There are numerous implementations
    of gesture recognizer in the `UIKit` and they can be combined and used with delegate
    implementations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS平台上，手势识别器实现的起点是抽象类`UIGestureRecognizer`。`UIKit`中有许多手势识别器的实现，它们可以与代理实现结合使用。
- en: On Android, the `GestureDetector` class and the `IOnGestureListener` interface
    can be used to provide implementations for various gesture events and user actions.
    Classic interaction events such as pan gestures and tap actions can already be
    accessed through the `OnTouchEvent` method of any `Activity` implementation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，可以使用`GestureDetector`类和`IOnGestureListener`接口来提供各种手势事件和用户动作的实现。经典的交互事件，如平移手势和点击动作，可以通过任何`Activity`实现的`OnTouchEvent`方法访问。
- en: On the Windows Phone platform, most of the default controls provide interaction
    with pointer or touch events for classic manipulation scenarios. However, for
    more complicated gestures, the `GestureRecognizer` class available in the `Windows.UI.Input`
    namespace can be used.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Phone平台上，大多数默认控件都提供了与指针或触摸事件进行交互的功能，用于经典操作场景。然而，对于更复杂的手势，可以使用`Windows.UI.Input`命名空间中可用的`GestureRecognizer`类。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented an overview of the design philosophy of, and patterns
    on, Xamarin target platforms. The design elements section outlined the main controls
    and layouts that are at the disposal of designers and developers while providing
    various content display strategies. There were additional sections about interactive
    and modern user interface design.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了Xamarin目标平台的设计理念以及设计模式。设计元素部分概述了设计师和开发者可用的主要控件和布局，同时提供了各种内容显示策略。还有关于交互式和现代用户界面设计的附加部分。
- en: Even though each platform provides its own UI design patterns and guidelines,
    the main focus of the design effort in a cross-platform application is to find
    an optimal compromise between native look-and-feel and application brand design.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个平台都提供了自己的UI设计模式和指南，但在跨平台应用程序的设计工作中，主要目标是找到一个在本地外观和感觉与应用程序品牌设计之间的最佳折衷方案。
- en: In the next chapter, we will discuss the Xamarin.Forms framework and make use
    of the correlation between the design elements that are outlined here.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Xamarin.Forms框架，并利用这里概述的设计元素之间的相关性。
