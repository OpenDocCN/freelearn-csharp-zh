<html><head></head><body>
		<div><h1 id="_idParaDest-17" class="chapter-number"><a id="_idTextAnchor016"/>1</h1>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Introduction to CLI Applications</h1>
			<p>In <a id="_idIndexMarker000"/>the realm of computing, <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) applications exemplify the enduring power and efficiency of text-based user interfaces. Unlike their graphical counterparts, CLI applications offer a streamlined, no-frills approach to interacting with software, allowing users to execute commands, manipulate files, and perform a myriad of tasks right from the terminal, or automate them so these tasks do not require user interaction at all!</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>An IT professional’s typical day</li>
				<li>What CLI applications are, what their benefits are, and when to use them</li>
				<li>Popular CLI applications</li>
			</ul>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>A day in the life of an IT professional</h1>
			<p>It’s a beautiful Monday morning. Today, my team and I are starting a new project.</p>
			<p>The <a id="_idIndexMarker001"/>project is to <a id="_idIndexMarker002"/>build a web<a id="_idIndexMarker003"/> application using <strong class="bold">ASP.NET</strong> with <strong class="bold">Entity Framework</strong> as an <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>), <strong class="bold">NuGet</strong> for <a id="_idIndexMarker004"/>managing dependencies, <strong class="bold">Git</strong> as a <a id="_idIndexMarker005"/>code versioning system, and, since the application is to be deployed on Azure, <strong class="bold">Bicep</strong> as an<a id="_idIndexMarker006"/> infrastructure scripting language.</p>
			<p>A few years ago, I <a id="_idIndexMarker007"/>would have used <a id="_idIndexMarker008"/>GUI applications for <a id="_idIndexMarker009"/>this, such as the full-fledged <strong class="bold">Visual Studio</strong>, <strong class="bold">GitHub Desktop</strong>, or <strong class="bold">GitKraken</strong>, and<a id="_idIndexMarker010"/> the <strong class="bold">Azure portal</strong>.</p>
			<p>Today, I doing most of my work<a id="_idIndexMarker011"/> in <strong class="bold">Visual Studio Code</strong> and its integrated terminal.</p>
			<p>So, I use commands such as <code>mkdir</code> to <a id="_idIndexMarker012"/>create my project directory, <code>cd</code> to <a id="_idIndexMarker013"/>position myself into this<a id="_idIndexMarker014"/> directory, <code>dotnet new</code> to create my project, <code>git init</code> to <a id="_idIndexMarker015"/>initialize the<a id="_idIndexMarker016"/> Git repository, <code>dotnet add package</code> to add NuGet packages as dependencies to my project, <code>dotnet ef dbcontext scaffold</code> to <a id="_idIndexMarker017"/>generate a database context and all the entity type classes for my<a id="_idIndexMarker018"/> database, <code>dotnet build</code> to compile my <a id="_idIndexMarker019"/>application, and <code>dotnet run</code> to run it. When comes the time to deploy my application to Azure, I use commands such as <code>az login</code> to log <a id="_idIndexMarker020"/>into my Azure <a id="_idIndexMarker021"/>account, <code>az account set</code> to position myself onto the appropriate subscription, and finally, <code>az deployment group create</code> to <a id="_idIndexMarker022"/>deploy my Azure infrastructure as declared in my Bicep script.</p>
			<p>When I realized that, I paused to pay careful attention to the situation. Wow, CLI applications are everywhere! They are truly part of our daily operations, no matter the role we play in an IT team.</p>
			<p>I wondered how I missed that… then it hit me. This might be because<a id="_idIndexMarker023"/> CLI applications are a bit shy (they have no flashy UIs), and for that reason, we may not always notice them, so let me tell you about some common ones:</p>
			<ul>
				<li>If you are a developer, you have certainly used the .NET CLI (<code>dotnet</code>), the Node.js CLI (<code>node</code>), the npm package manager (<code>npm</code>), the Angular CLI (<code>ng</code>), Python (<code>python</code>), Git (<code>git</code>), Docker (<code>docker</code>), Kubernetes (<code>kubectl</code>), and many more.</li>
				<li>If you are a DevOps engineer, you may be using Git (<code>git</code>), GitHub (<code>gh</code>), Azure DevOps (<code>az</code> <code>devops</code>), Docker (<code>docker</code>), Kubernetes (<code>kubectl</code>), Ansible (<code>ansible</code>), and so on.</li>
				<li>If you are a system administrator, you may be regularly using package managers on various operating systems, such as <code>apt</code> on Linux, <code>brew</code> on macOS, or even <code>choco</code> or <code>winget</code> on Windows. You also most likely use shells, automation, and configuration tools such as PowerShell or Bash.</li>
				<li>If you are a cloud administrator or architect, you may be using the Azure CLI (<code>az</code>), the AWS CLI (<code>aws</code>), Terraform (<code>terraform</code>), or Bicep (<code>bicep</code>), among others.</li>
				<li>If you are a data scientist, you might be using Python (<code>python</code>), R (<code>R</code>), Pandas (<code>pandas</code>), SQL (<code>sql</code>), or Jupyter Notebooks (<code>jupyter notebook</code>).</li>
				<li>If you are a video or audio producer, a content creator, or simply a multimedia enthusiast, you are probably using <code>FFmpeg</code> (yes, it is a CLI application) to manipulate, convert, and analyze media files.</li>
				<li>And the list goes on and on…</li>
			</ul>
			<p>Then, I started wondering why this happened. How come we switched from those beautiful UIs with their shiny colors and animations, inviting us to do all sorts of tasks and activities, to the blinking cursor inside of that terminal that is waiting for us to tell it what to do? This might seem like a big leap backward, right?</p>
			<p>I know I struggled with that feeling until I figured out why CLI applications are so great! Sure, they make us look cool and smart in front of our Muggle friends and relatives. But it’s not about that. Okay… not only about that. Because, when we are alone working on our project, there are not many people to impress.</p>
			<p>So…</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Why care about CLI applications?</h1>
			<p>Because<a id="_idIndexMarker024"/> they improve our productivity by keeping us focused on the task at hand.</p>
			<p>You see, when we switch contexts between different applications, the chances are that we lose sight of what we were doing and get derailed from our task by some other unrelated activity.</p>
			<p>By relying on CLI applications, all the commands that we type and execute happen to be within the same terminal, so we have a better chance of staying focused on what we are doing, thus achieving more.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>To CLI or not to CLI?</h1>
			<p>That is the question. And the answer is quite simple: you don’t have to choose. In some scenarios, CLI applications make perfect sense, while in others they make no sense. Imagine using Microsoft Teams, Slack, or any tool of the Adobe Creative Suite. Would it make sense to interact with these applications as CLI applications? Of course not! (unless it is for installing and configuring them).</p>
			<p>So, the point here is that you become aware of the power of CLI applications, and you start taking advantage of them in your everyday workflow. They are not meant to replace those outstanding GUI applications.</p>
			<p>As my wife, Lamia Rarrbo (who is an executive coach) says: “This is not an <strong class="bold">or</strong> situation but rather an <strong class="bold">and</strong> situation.”</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>CLI applications as the building block for creating workstation profiles</h1>
			<p>Let me tell you a <a id="_idIndexMarker025"/>true story. A few years ago, one of my customers asked me to come up with a solution to build workstation configuration profiles for different roles within their company.</p>
			<p>This is nothing new, you may say, and you are exactly right!</p>
			<p>So, what makes this situation worth mentioning? What makes it special?</p>
			<p>For many years, this used to be achieved using customized OS images, depending on the role you have in the organization. However, this comes at a cost:</p>
			<ul>
				<li>The cost of storage: These images tend to be large and hence require a lot of disk space to store them.</li>
				<li>The cost of OS updates: When a new OS version is introduced, the IT department must recreate all images.</li>
				<li>The cost of tools updates: When new versions of the tools utilized by the various profiles are introduced, the IT department must recreate the impacted images.</li>
				<li>The cost of frustration: Since computers are configured using these images, and because this activity is solely performed by the IT department, it causes frustrations at both ends. First, users accuse the IT department of being slow at providing them with their new machine (“<em class="italic">3 weeks to configure a new laptop?! You gotta be kidding me!</em>”. We have all heard this at some point, right?). Second, the IT people have to configure these computers <em class="italic">in addition</em> to their other tasks.</li>
			</ul>
			<p>The solution I <a id="_idIndexMarker026"/>proposed is to leverage CLI applications to provide users with more autonomy while ensuring that the IT department still has control over what is deployed on the workstations.</p>
			<p>So, I built configuration profiles for each role as a PowerShell script. This script relies on <em class="italic">Chocolatey</em> (and, later, on <em class="italic">WinGet</em>) to install all the necessary tools for a given user role. These scripts were stored on a file share that users had access to according to their role (so, for example, if you are an analyst, you don’t have access to the developer profile, and so on).</p>
			<p>This solution provided multiple advantages:</p>
			<ul>
				<li>The IT department now only installs the OS, configures the user account, and hand the workstation to the user</li>
				<li>The user can now navigate to the file share and start the installation of their software based on their profile</li>
				<li>The IT department can update the configuration profiles, or provide new ones, without having an impact on the users and without making them wait</li>
			</ul>
			<p>Hence, by leveraging CLI tools, we were able to automate workstation configuration in a personalized manner, according to users’ profiles. Imagine how tedious this would have been if we had to install each and every application through its GUI assistant!</p>
			<p>By relying on CLI tools, we were able to improve both the IT department’s productivity and users’ satisfaction.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Even heavy graphical applications have a CLI tool!</h1>
			<p>Why is the preceding story interesting?</p>
			<p>It’s not because of the use of PowerShell, WinGet, or Chocolatey. These are clearly CLI tools.</p>
			<p>It is because we designed a way to install software from the command line without involving any GUI. This means that even if we are installing graphical applications (such as the Microsoft Office suite, internet browsers, and the Adobe suite), we are doing so by relying on their own CLI tools.</p>
			<p>Yes, these graphical applications provide a CLI tool allowing us to install (and sometimes also configure) these applications.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Even ChatGPT has a CLI!</h1>
			<p>A quick Google search and I found that there are even CLI applications <a id="_idIndexMarker027"/>for <strong class="bold">ChatGPT</strong>! Can you believe that?!</p>
			<p>You can check out some of them at <a href="https://github.com/kardolus/chatgpt-cli">https://github.com/kardolus/chatgpt-cli</a> and <a href="https://github.com/marcolardera/chatgpt-cli">https://github.com/marcolardera/chatgpt-cli</a>.</p>
			<p>I am telling you: CLI applications are truly everywhere, and once you start caring about them, you start noticing how much they are part of your day!</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Summary</h1>
			<p>If you work in IT, you have most likely already used at least one CLI application of some sort (and the chances are that you use many of them!), and you may even be using it on a daily basis.</p>
			<p>I am sure that, by now, you have understood the value of CLI applications and the role they play in your everyday job.</p>
			<p>In this book, we will explore every aspect of building our very own CLI applications, that serve our needs and those of our users and customers.</p>
			<p>Feeling excited? Then, grab your keyboard, fire up your terminal, and let’s start coding!</p>
			<p>We have only scratched the surface of what CLI applications can do and why they’re an essential tool in today’s tech landscape. I want this book to be your roadmap and your guide in this exciting journey.</p>
			<p>Oh, and by the way, do not simply read this book, experience it!</p>
			<p>Now, turn this page, and let’s continue our journey together. The world of CLI applications awaits you!</p>
			<p>Enjoy the journey.</p>
		</div>
	</body></html>