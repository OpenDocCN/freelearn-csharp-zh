- en: Advanced Database Design and Application Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about reactive programming by discussing
    its principles and models. We also discussed and looked at examples of how reactive
    programming is all about data streams.
  prefs: []
  type: TYPE_NORMAL
- en: Database designing is a complex task and needs a lot of patience. In this chapter,
    we will discuss advanced database and application techniques, including applying
    **Command Query Responsibility Segregation** (**CQRS**) and ledger-style databases.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to previous chapters, a requirement gathering session will be illustrated
    in order to determine the **Minimum Viable Product** (**MVP**). In this chapter,
    several factors will be used to lead the design to CQRS. We will be using a ledger-style
    approach that consists of increased tracking of changes to inventory levels, as
    well as wanting to provide public APIs for retrieving inventory levels. This chapter
    will cover why developers use ledger-style databases and why we should focus on
    CQRS implementation. In this chapter, we will see why we adapt the CQRS pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Use case discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ledger-style databases for inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the CQRS pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demo purposes. Most of the examples involve a .NET
    Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: To run and execute the code, Visual Studio 2019 is a prerequisite (you can also
    use Visual Studio 2017 to run the application).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run these code examples, you need to install Visual Studio (preferred IDE).
    To do so, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Visual Studio 2017 (or version 2019) from the following download link:
    [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions that are accessible through the previous
    link. Multiple options are available for Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download .NET Core for Windows: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have SQL Server installed, you need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the installation instructions at [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For troubleshooting and for more information, refer to the following link:
    [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: Use case discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue with our FlixOne inventory application. Throughout
    this chapter, we will discuss CQRS patterns and extend the web application that
    we developed in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter continues with the web application that was developed in the previous
    chapter. If you skipped the previous chapter, please revisit it in order to aid
    your understanding of the current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through the process of requirement gathering, and
    then discuss the various challenges with our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Project kickoff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml), *Implementing Design
    Patterns for Web Applications â€“ Part 2*, we extended FlixOne Inventory and added
    authentication and authorization to the web application. We extended the application
    after considering the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The current application is open for all; therefore, any user can visit any page,
    even restricted pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should not access pages that require access or special access rights;
    these pages are also known as restricted pages or pages with limited access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should be able to access pages/resources as per their roles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 10](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml), *Reactive Programming
    Patterns and Techniques*, we further extended our FlixOne Inventory application
    and added paging, filtering, and sorting to all pages that show listings. The
    following points were considered while we extended the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item filtering**: Currently, users are unable to filter items by their categories.
    To extend this feature, users should be able to filter product items based on
    their categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Item sorting**: Currently, items are appearing in the order in which they
    have been added to the database. There is no mechanism that enables the user to
    sort items based on categories such as item name or price.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After several meetings and discussions with management, **Business Analyst**
    (**BA**), and pre-sales staff, management decided to work on the following high-level
    requirements: business requirements and technical requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Business requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the basis of discussions with stakeholders and endusers, and as per the
    market survey, our business team has listed the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product expansion**: The product is reaching different users. This is a good
    time to expand the application. The application will robust to expand after having
    expanded it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product model**: Being an inventory management application, users should
    feel freedom (this mean no restriction at model level, without complicated validations)
    and there should not be any restriction while users are interacting with the application.
    Every screen and page should be self-explanatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database design**: The application''s database should be designed in such
    a way that the expansion should not take much time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The actual requirements that meet business needs are now ready for development.
    After several discussions with business staff, we concluded that the following
    are the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the requirements for the **landing** or **home page**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should be a dashboard that contains various widgets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Should show an at-a-glance picture of the store
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the requirements for the **product page**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should have the capability to add, update, and delete products
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Should have the capability to add, update, and delete product categories
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The FlixOne Inventory Management web application is an imaginary product. We
    are creating this application to discuss the various design patterns that are
    required/used in web projects.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have extended our existing web application, it has various challenges
    for both developers and businesses. In this section, we will discuss these challenges
    and then we will find out the solutions to overcome these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges for developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the challenges that arose due to a big change in the application.
    They were also a result of the major extensions associated with upgrading a console
    application to a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No support for RESTful services**: Currently, there is no support for RESTful
    services because no APIs have been developed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited security**: In the current application, there is only one mechanism
    that can restrict/permit the user from/to gaining access to a particular screen
    or module of the application: that is, by the login.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges for businesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following challenges occur as we adapt a new technology stack, and there
    are plenty of changes in the code. Therefore, it takes time to achieve the final
    output, which delays the product, resulting in a loss for the business:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loss of clientele**: Here, we are still in the development stage but the
    demand for our business is very high. However, the development team is taking
    longer than expected to deliver the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It takes more time to roll out the production updates**: Development efforts
    are time-consuming at the moment and this delays the subsequent activities, leading
    to a delay in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a solution to the problems/challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After several meetings and brainstorming sittings, the development team came
    to the conclusion that we have to stabilize our web-based solution. To overcome
    these challenges and provide the solution, the tech team and business team got
    together to identify the various solutions and points.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the points supported by the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Evolve RESTful webservicesâ€”there should be one API dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strictly following **T****est-Driven Development** (**TDD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-designing the **user interface** (**UI**) to meet the user experience expectations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start with the database discussion we have to consider the following
    pointsâ€”a big picture of our FlixOne web application:'
  prefs: []
  type: TYPE_NORMAL
- en: One part of our application is inventory management, but another part of it
    is an e-commerce web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The challenging part is that our application would also serve as a **Point Of
    Sale** (**POS**). In this part/module, the user can pay for the items they have
    purchased from offline counters/outlets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the inventory part, we need to address which approach we will be taking
    to calculate and maintain accounts and transactions, and to determine the cost
    of any item sold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To maintain stock for inventories, various options are available, with the two
    most commonly used options being **First In First Out** (**FIFO**) and **Last
    In First Out** (**LIFO**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the transactions involve financial data, hence these transactions require
    historical data. Every record should have the following information: current value,
    the value before current changes, and the changes made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we're maintaining inventory, we are also required to maintain the items
    purchased.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more points that are important when designing a database for any e-commerce
    web application. We are limiting our scope for the FlixOne application in order
    to showcase the inventory and stock management.
  prefs: []
  type: TYPE_NORMAL
- en: Database processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the other topics we have covered in this book, there are a large
    number of databases ranging from basic patterns concerning the schema of a database
    to patterns that govern how database systems are put together. This section will
    cover two system patterns, **Online Transaction Processing** (**OLTP**) and **Online
    Analytical Processing** (**OLAP**). To further understand database design patterns,
    we will explore a specific pattern, ledger-style databases, in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: A database schema is another word for the collection of tables, views, stored
    procedures, and other components that make up a database. Think of this as the
    *blueprint* of the database.
  prefs: []
  type: TYPE_NORMAL
- en: OLTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An OLTP database has been designed to handle large numbers of statements that
    cause changes to the database. Basically, the `INSERT`, `UPDATE`, and `DELETE`
    statements all cause changes and behave very differently from the `SELECT` statement.
    OLTP databases have been designed with this in mind. Because these databases record
    changes, they are typically the *main* or *master*database, meaning that they
    are the repositories that hold the current data.
  prefs: []
  type: TYPE_NORMAL
- en: The `MERGE` statement also qualifies as a statement that causes change. This
    is because it provides a convenient syntax for the insertion of a record when
    a row does not exist, and the insertion of an update when a row does exist. It
    will update when a row does exist. The `MERGE` statement is not supported in all
    database providers or versions.
  prefs: []
  type: TYPE_NORMAL
- en: OLTP databases are typically designed to process change statements quickly.
    This is normally done by the careful planning of table structures. A simple way
    of viewing this is to consider a database table. This table can have fields for
    storing data, keys for looking up the data efficiently, indexes to other tables,
    triggers to respond to specific situations, and other table constructs. Each one
    of these constructs has a performance penalty. The design of OLTP databases is,
    therefore, a balance between using the minimum number of constructs on a table
    versus the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a table that records the books in our inventory system. Each
    book might record the name, quantity, date published, and have references to author
    information, publishers, and other related tables. We could put an index on all
    columns and even add indexes for the data in related tables. The problem with
    this approach is that each index has to be stored and maintained for each statement
    that causes change. Database designers have to carefully plan and analyze databases
    in order to determine the optimal combination of adding and, just as importantly,
    not adding indexes and other constructs to tables.
  prefs: []
  type: TYPE_NORMAL
- en: A table index can be thought of like a virtual lookup table that provides the
    relational database with a faster way of looking up data.
  prefs: []
  type: TYPE_NORMAL
- en: OLAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases designed using the OLAP pattern are expected to have more `SELECT`
    statements than statements that cause change. These databases usually have a consolidated
    view of the data of one or more databases. Because of this, these databases are
    usually not the master database, but a database used to provide reporting and
    analysis separate from the master database. In some situations, this is provided
    on infrastructure isolated from other databases so as to not impact the performance
    of operational databases. This type of deployment is often referred to as a **data
    warehouse**.
  prefs: []
  type: TYPE_NORMAL
- en: A data warehousecan be used to provide a consolidated view of a system or collection
    of systems within an enterprise. The data is traditionally fed with slower periodical
    jobs to refresh the data from other systems, but with modern database systems,
    this is trending towards near real-time consolidation.
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between OLTP and OLAP is around how the data is stored
    and organized. In many situations, this would require tables or persistent viewsâ€”depending
    on the technology usedâ€”to be created in the OLAP database that supports specific
    reporting scenarios and duplicates the data. In OLTP databases, duplication of
    data is undesirable as it then introduces multiple tables that need to be maintained
    for a single statement that causes change.
  prefs: []
  type: TYPE_NORMAL
- en: Ledger-style databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ledger-style database design will be highlighted, as it is both a pattern
    that has been used in many financial databases for decades and it may not be known
    to some developers. The ledger-style database stems from an accountant''s ledger,
    where transactions were added to a document and the quantities and/or amounts
    are tallied in order to arrive at a final quantity or amount. The following table
    shows a ledger of the sale of apples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1a0135c-e2a0-406c-8ce9-2c20c019ee12.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a couple of things to point out about the example. The Purchaser information
    is written on separate rows instead of erasing their amounts and entering a new
    amount. Take the two purchases and one credit for West Country Produce. This is
    typically different from many databases in which a single row contains the Purchaser
    information with separate fields for the Amount and Price.
  prefs: []
  type: TYPE_NORMAL
- en: A ledger-style database takes this concept by having a separate row per transaction,
    thus removing the `UPDATE` and `DELETE` statements and only relying on `INSERT`
    statements. This has several benefits. Similarly to a ledger, once each transaction
    has been written it cannot be removed or changed. If a mistake or a change occurs,
    such as the credit to West Country Produce, a new transaction needs to be written
    in order to arrive at the desired state. An interesting benefit of this is that
    the source table now has the immediate value of providing a detailed log of the
    activity. If we were to add a *modified by* column, we could then have a comprehensive
    log of who or what made the change and what the change was.
  prefs: []
  type: TYPE_NORMAL
- en: This example is for a single-entry ledger, but in the real world, a double-entry
    ledger would be used. The difference is that in a double-entry ledger, each transaction
    is recorded as a credit in one table and a debit in another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next challenge is capturing the final or rolled-up version of the table.
    In this example, that is that amount of apples that have been purchased and for
    how much. The first approach could use a `SELECT` statement that simply performs
    `GROUP BY` on the purchaser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While this would be fine for smaller data sizes, the issue here is that the
    performance of the query would degrade over time as the number of rows increases.
    An alternative would be to aggregate the data into another form. There are two
    main ways of achieving this. The first is to perform this activity at the same
    time as you write the information from the ledger table into another table (or
    persistent view if supported) that holds the data in an aggregate form.
  prefs: []
  type: TYPE_NORMAL
- en: A **persistent** or **materialized view** is similar to a database view, but
    the results of the view are cached. This gives us the benefit of not requiring
    the view to be recalculated on each request, and it is either refreshed periodically
    or when the underlying data changes.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach relies on another mechanism that is separate from the `INSERT`
    statement to retrieve the aggregated view when required. In some systems, the
    primary scenario of writing changes to a table and retrieving the result is performed
    less frequently. In this case, it would make more sense to optimize the database
    so that writes are faster than reads, therefore limiting the amount of processing
    required when new records are inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The next section deals with an interesting pattern CQRS that can be applied
    at the database level. This could be used in the ledger-style database design.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CQRS pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CQRS simply works on the separation between queries (to read) and commands (to
    modify). **Command-Query Separation** (**CQS**) is an approach to **Object-oriented
    Design** (**OOD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'CQRS was introduced for the first time by Bertrand Meyer ([https://en.wikipedia.org/wiki/Bertrand_Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer)).
    He mentioned this term in his book, *Object-Oriented Software Construction*, during
    the late 1980s: [https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554](https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554).'
  prefs: []
  type: TYPE_NORMAL
- en: 'CQRS does fit well with some scenarios and has some useful factors to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model separation**: In modeling terms, we are able to have multiple representations
    for our data model. The clear separation allows for choosing different frameworks
    or techniques over others that are more suitable for query or command. Arguably,
    this is achievable with **create, read, update, and delete** (**CRUD**)-style
    entities, although the single data layer assembly often emerges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration**: In some enterprises, a separation between query and command
    would benefit the teams involved in building complex systems, particularly when
    some teams are more suited for different aspects of an entity. For example, a
    team that is more concerned about presentation could concentrate on the query
    model, while another team that is more focused on data integrity could maintain
    the command model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent scalability**: Many solutions tend to either require more reads
    against the model, or more writes, depending on the business requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For CQRS, remember that commands update data and queries read data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important things to note while working on CQRS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Commands should be placed asynchronously rather than as synchronous operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases should never be modified with queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CQRS simplifies the design with the use of separate commands and queries. Also,
    we can physically separate read data from write data operations. In this arrangement,
    a read database could use a separate database schema, or in other words, we can
    say that it could use a read-only database that is optimized for queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the database uses a physical separation approach, we can visualize the CQRS
    flow of the application, as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a303ee36-9fb8-411d-a49c-26b3f526b63d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts an imaginary workflow of the CQRS application,
    in which an application has physically separate databases for write operations
    and read operations. This imaginary application is based on RESTful web services
    (.NET Core APIs). No APIs have been exposed directly to the client/end user who
    is consuming these APIs. There is an API gateway exposed to users, and any requests
    for applications will come through the API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: The API Gateway provides an entry point to groups with similar types of services.
    You can also simulate it with the facade pattern, which is part of the distributed
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous diagram, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User interface**: This could be any client (who is consuming the APIs), web
    application, desktop application, mobile application, or any other application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Gateway**: Any request from UI and response to UI is delivered from the
    API Gateway. This is the main part of CQRS, as business logic can be incorporated
    by using the Commands and Persistence layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database(s)**: The diagram shows two physically separated databases. In real
    applications, this depends upon the requirements of the product, and you can use
    the database for both write and read operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries are generated with `Read` operations that are **Data Transfer Objects**
    (**DTOs**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can now go back to the *Use case* section, in which we discussed the new
    features/extensions of our FlixOne inventory application. In this section, we
    will create a new FlixOne application with the features discussed previously using
    the CQRS pattern. Please note that we will be developing APIs first. If you did
    not install the pre-requisites, I suggest revisiting the *Technical requirements*
    section, gathering all of the required software, and installing them onto your
    machine. If you have completed the pre-requisites, then let''s start by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click File | New Project to create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the New Project window, select Web and then select ASP.NET Core Web Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a name to your project. I have named our project `FlixOne.API` and ensured
    that the Solution Name is `FlixOne`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the Location of your `Solution` folder, then click on the OK button
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/914c131b-65df-48fc-8f20-228eee0db8f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you should be on the New ASP.NET Web Core Application - FlixOne.API screen.
    Make sure that on this screen, you select ASP.NET Core 2.2\. Select Web Application
    (Model-View-Controller) from the available templates, and uncheck the Configure
    for HTTPS checkbox, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90477786-80eb-41aa-b030-2bf74fa836dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see a default page appear, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/193efeb2-573e-4ed9-a6d9-49ec51d1d571.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expand Solution Explorer and click on Show All files. You will see the default
    folders/files created by Visual Studio. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/40563f44-0662-4c1b-aa6e-4901e13813ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have selected the ASP.NET Core Web (Model-View-Controller) template. Therefore,
    we have the default folders, Controllers, Models, and Views. This is a default
    template provided by Visual Studio. To check this default template, hit *F5* and
    run the project. Then, you will see the following default page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61edea34-6458-48cb-b002-75bcbfa738a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot is the default Home screen of our web application.
    You may be thinking *is it a website?* and be expecting an API documentation page
    here instead of a web page. This is because, when we select the template, Visual
    Studio adds MVC Controller instead of API Controller by default. Please note that
    in ASP.NET Core, both MVC Controller and API Controller use the same Controller
    Pipeline (see the Controller class: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before discussing API projects in detail, let''s first add a new project to
    our FlixOne solution. To do so, expand Solution Explorer, right-click on the Solution
    Name, and then click on Add New Project. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b9834e5-e012-4982-932b-057a6510b41e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the New Project window, add the new `FlixOne.CQRS` project, and click on
    the `OK` button. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87ee0e48-d801-44b4-9c68-6e9201eb48e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot is of the Add New Project window. On it, select .NET
    Core and then select the Class Library(.NET Core) project. Enter the name `FlixOne.CQRS`
    and click the OK button. A New Project has been added to the solution. You can
    then add folders to the new solution, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb3a872f-4b1b-486f-b858-b04df8b0855e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot is showing that I have added four new folders: `Commands`,
    `Queries`, `Domain`, and `Helper`. In the `Commands` folder, I have the `Command`
    and `Handler` sub-folders. Similarly, for the `Queries` folder, I have added sub-folders
    called `Handler` and `Query`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the project, let''s first add two Domain Entities in the
    project. The following is the required code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a `Product` domain entity that has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id`: A unique identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: A product name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description`: A product description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image`: An image of the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Price`: The price of the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also need to add the `CommandResponse` database. This plays an important
    role when interacting with database/repository, in that it ensures that the system
    gets a response. The following is the code-snippet of the `CommandResponse` Entity
    Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `CommandResponse` class contains the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id`: Unique identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Success`: With values of `True` or `False`, it tells us whether the operation
    is successful or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message`: A message as a response to the operation. If `Success` if false,
    this message contains `Error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it''s time to add interfaces for a query. To add interfaces, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From Solution Explorer, right-click on the `Queries` folder, click on Add,
    and then click on New Item, as per the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7b79ebb-67b7-49ff-a003-26a089491ba5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Add New Item window, choose Interface, name it IQuery, and click on
    the Add button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e055b30e-23f0-49bd-b246-49d682935ed7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow the previous steps and add the `IQueryHandler` interface as well. The
    following is the code from the `IQuery` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous interface works as a skeleton for querying for any kind of operation.
    This is a generic interface using an `out` parameter of the `TResponse` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is code from our `ProductQuery` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is code from our `ProductQueryHandler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is code from our `ProductQueryHandlerFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similarly to `Query` interfaces and `Query` classes, we need to add interfaces
    for commands and their classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the point by which we have created CQRS for a product domain entity, you
    can follow this workflow and add more entities as many times as you like. Now,
    let''s move on to our `FlixOne.API` project and add a new API controller by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, right-click on the `Controllers` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add | New Item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select API Controller Class and name it `ProductController`; refer to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9088f70-6e1b-4b33-a49f-2cff8620875d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code in the API controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for saving the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for deletion of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have created Product APIs, and we are not going to creates UI in this section.
    To view what we have done, we will be adding **Swagger** support to our API project.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger is a tool that can be used for documentation purposes, and provides
    all of the information regarding the API endpoints on one screen, where you can
    visualize the API and test it by setting parameters as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the implementation of Swagger in our API project, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Nuget Package Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to Nuget Package Manager | Browse and search for `Swashbuckle.ASPNETCore`;
    refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1704e800-d6c6-4e30-b6aa-ff6e38bde866.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `Startup.cs` file and add the following code to the `ConfigureService`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code to the `Configure` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now completed all of the changes that serve to showcase the power of
    CQRS in the application. Hit *F5* in Visual Studio and open the Swagger documentation
    page by accessing the following URL: [http://localhost:52932/swagger/](http://localhost:52932/swagger/)
    (please note that port number `52932` may vary as per your setting of the project).
    You will see the following Swagger Documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a67a98c-096c-4475-8258-7a0ace3abfbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can test Product APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the CQRS pattern, which we then implemented into our
    application. The aim of the chapter was to go through the database techniques
    and look at how ledger-style databases work for inventory systems. To showcase
    the power of CQRS, we have created Product APIs and added support for Swagger
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss cloud services and look at microservices
    and serverless techniques in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a ledger-style database?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is CQRS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should we use CQRS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
