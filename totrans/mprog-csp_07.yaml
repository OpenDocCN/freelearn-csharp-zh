- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reasoning about Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve looked at the powerful metadata that is captured and how we can
    access it using reflection. We’ve also looked at how we can leverage this same
    metadata and generate code on the fly at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using reflection and generating code as techniques in metaprogramming are extremely
    powerful, but they’re not applicable to all scenarios. It can also be very involved
    and produce hard-to-read and maybe even hard-to-maintain code going deep with
    reflection and proxy generation.
  prefs: []
  type: TYPE_NORMAL
- en: C# expressions can, for a lot of scenarios, represent a better approach or an
    additional approach for specific scenarios for doing runtime discovery and extraction
    of metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are expressions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing an expression tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using expressions as descriptors of members on types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this chapter, you should understand what expressions are and how you can
    leverage them as a technique to reason about the running code at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7)),
    and it builds on top of the **Fundamentals** code that is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Both the **GetMemberExpression()** and **GetPropertyInfo()** methods can be
    found in the **ExpressionExtensions.cs** file in **Fundamentals** in the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: What are expressions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**C# 3.0** was introduced in late 2007, and its killer feature was something
    called **Language-Integrated Query** (**LINQ**). With the underlying API model
    and combination of new capabilities in C#, it introduced a programming paradigm
    that bridges into the more functional programming space. The fluent interfaces
    and its use of lambdas can feel foreign if you’re used to more object-oriented
    approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: What it brought to the table was a way of expressing queries for data in a more
    natural native C# way. Not only does it do this for your in-memory collections,
    but also for any other data source, such as a database. It basically gave developers
    a uniform way of expressing queries, filters, and projections.
  prefs: []
  type: TYPE_NORMAL
- en: 'It did this by recognizing that a query operation consists of the following
    three distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at an example without LINQ and compare it to how you could do the
    same with LINQ in a more expressive way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running this would print out **42, 84, 37**, as expected. The challenge with
    something like this is that it is very verbose and coupled to the data source
    and gives no room for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: With LINQ and the recognition of the three distinct parts mentioned earlier
    that make up a query, there is a concept of **deferred execution**. The actual
    execution of the query does not happen until you start enumerating it. That means
    you can build on the query while its final execution won’t occur until we really
    need the data. The execution is performed by the query provider, which could be
    the default in-memory one or something that represents a data source such as a
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing the previous sample with LINQ is much more expressive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code becomes much more readable, but what happens behind the scenes is that
    it also becomes much more flexible in how it runs and makes it possible to optimize
    the execution as it sees fit for the data source the query is running against.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ is a language feature of C#, and it can’t work without support from the
    .NET class libraries and the .NET runtime. This is where expressions come in.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the base class libraries that were released at the same time, there
    was a new namespace called **System.Linq** and another within it called **System.Linq.Expressions**.
    This is where the *magic* *sauce* lies.
  prefs: []
  type: TYPE_NORMAL
- en: The C# compiler translates the native LINQ code using another feature that was
    introduced in C# 3.0 called extension methods. Extension methods are just static
    methods that look like they’re members of the actual type they extend, they can
    be used to form a fluent interface that can chain method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the previous LINQ code, we can express it using expressions and the
    extension methods that are found in the **System.Linq** namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All three approaches discussed so far do the same thing and print out the same
    result. The biggest difference is readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our data source is just an in-memory array, the extension methods will
    reflect that and you’ll notice the signature of the **.Where()** method it uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the source it extends, **IEnumerable<TSource>**, and
    the second parameter is **Func<int, bool>**. This means that you’re giving it
    a callback that will be called to decide whether or not the specific value, while
    it iterates through them, should be included or not.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t really bring out the topic of this chapter. Let’s change it up
    a little to bring out the real magic.
  prefs: []
  type: TYPE_NORMAL
- en: Expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For LINQ to work as intended with regard to different data sources and deferred
    execution, there is an interface called **IQueryable**. The **IQueryable** interface
    is something a data source can implement, and instead of having an imperative
    approach to just iterating the data source, it can now get the query represented
    as an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'An **IQueryable** interface gives us different extension methods that expose
    **Expression** as a type. Let’s change the array filtering up a little bit and
    introduce the concept of a queryable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The **.AsQueryable()** array changes from an array, or more exactly, **IEnumerable<int>**
    becomes **IQueryable<int>**. That means we get access to a whole set of LINQ extension
    methods that are extending **IQueryable<>**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closer at the **.Where()** method, you’ll notice that one of the
    extension methods now has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the source it extends, and the second parameter is **Expression<Func<TSource,
    bool>>**. This is the most significant part. The C# compiler recognizes anything
    that is an expression type, and instead of just creating a callback that gets
    called, it expands it into an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for us to investigate what the compiler does, we can take the **where**
    clause and separate it into its own line of code, enabling us to set a breakpoint
    in the debugger and look at what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the expression extracted into its own line of code, we can easily see
    what the compiler generates for us. By setting a breakpoint after the **filter**
    variable construction and looking at the **filter** variable in the watch view
    of your debugger, you can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The filter expression
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it is no longer just a callback. It has captured all the details
    of what you are expressing. Notice the **Body** property. This is the inner expression.
    The type, in our case, is translated into **LogicalBinaryExpression**, which holds
    three things of importance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Left**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NodeType**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Left** property represents what is on the left-hand side of the expression,
    and the **Right** property represents what is on the right-hand side. And in the
    middle of this, the operator, **NodeType**, tells us the action it will be performing.
  prefs: []
  type: TYPE_NORMAL
- en: For both the **Left** and **Right** properties, you also see that their type
    is **Expression**. The **Left** expression, in this case, is **PrimitiveParameterExpression**,
    representing the parameter, the value that will be passed if we are iterating
    or calling the expression. While the **Right** expression becomes **ConstantExpression**,
    holding the concrete value, the **NodeType** property is set to **GreaterThanOrEqual**,
    which is what was expressed by **>=**.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the **=>** notation, you form what is known as a **lambda expression**.
    Lambda expressions are anonymous functions. Lambda expressions are divided into
    the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Expression lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statement lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expression lambdas are characterized by having the right side express an expression.
    An expression lambda returns the result of the expression and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the type of expression used in the expression you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Its signature is defined by **Func<int, bool>**, where the first generic argument
    is the type of the parameter used, and the last generic argument is the return
    type. You can have multiple parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Statement lambdas are characterized by it being enclosed in braces, **{}**,
    and typically having multiple statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be something like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With a statement, a lambda is typically something that is not possible to reason
    about, as it will not form an expression tree but rather have multiple statements
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas represent a very powerful construct that can be used to gain insight
    into what is going on. It’s also a great way to help understand how expressions
    work and can be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing an expression tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Expression** is a simple construct that represents a node in a tree. The
    expression has a node type, and the implementation decides what the node type
    expresses and means. This forms a tree that can be recursively traversed and reasoned
    about.
  prefs: []
  type: TYPE_NORMAL
- en: 'For lambda expressions, it means it has a body that consists of an expression
    that is of a specific type; this type could be a **Binary Expression** that holds
    a left and a right and the node itself representing the operand (equals, not equals,
    and so forth):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Binary expression
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the example of the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Visually it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 - A parameter larger than the constant expression
  prefs: []
  type: TYPE_NORMAL
- en: The operand is **greater than or equal**, the left-hand side accesses the parameter
    passed into it, and the right-hand side holds the constant value of **37**.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions can also represent accessing a member on the type being passed in
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have an object called **Employee** that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A filter accessing the first name and looking for a person called **Jane**
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Dissecting the expression tree, we will see that it now changes into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Member access equal constant expression
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re now accessing a member, the left-hand expression is now **MemberAccessExpression**.
    **MemberAccessExpression** has an expression on it that represents the source
    that holds the member, in our case, a parameter being passed in. To get the actual
    member, **MemberAccessExpression** holds a property called **Member**. Since the
    member we’re accessing is a property, it will be the actual **PropertyInfo**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expressions are not just used for filters; they can represent other operations
    as well. We could have an expression that represents adding values, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The expression itself now returns **int** instead of **bool**, takes the parameter
    passed to it, and adds **42**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression tree is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Parameter adding constant expression
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the node type is **Add**. This is just one of many types of
    expressions you can use. You can create really complex structures and represent
    in an abstract way the core functionality of what the .NET runtime itself is capable
    of running. We will see more of the different types in [*Chapter 8*](B19418_08.xhtml#_idTextAnchor132),
    *Building and* *Executing Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: Using expressions as descriptors of members on types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions represent a way of describing intent in a declarative fashion. Rather
    than with an imperative approach where we tell the computer exactly what to do,
    we can declaratively describe it and let the code decide the best way to approach
    it.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier with the filtering of numbers, the imperative approach using
    **foreach** does not open for any other execution than what we have put in. While
    with the LINQ and expression approach, we describe what we want, and the execution
    is deferred, how it is handled and executed, we don’t know – but the results are
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: This type of declarative thinking can be a very powerful way to describe what
    you want for your system and can also make your code more readable and easier
    for others to reason about. Imperative code requires you to thoroughly read and
    understand what the code does, while a declarative approach describes the desired
    outcome and is much easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, a declarative model is limited in its capabilities, while an imperative
    approach is fully flexible, and you can leverage the full power of the C# language.
    Combining the two methods is best if you can declaratively describe things using
    something such as a fluent interface and take full advantage of the C# extension
    methods to hold methods that represent the imperative actions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at a library called **FluentValidation** ([https://docs.fluentvalidation.net/en/latest/](https://docs.fluentvalidation.net/en/latest/)).
    It is a library that lets you fluently write validation of input. It takes full
    advantage of expressions and gives you a declarative model that is extensible
    using extension methods for describing your intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample from their documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The validator inherits from a base type called **AbstractValidator<>**, and
    on this type, there is a method called **RuleFor()**. This method is the starting
    point for describing rules for properties on the type passed in as a generic argument
    to **AbstractValidator<>**. The **RuleFor()** signature looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the parameter for **RuleFor()** is an expression. The expected
    expression is one that takes the type that was passed to **AbstractValidator<>**
    as a parameter and returns any type. **TProperty** will automatically be inferred
    by the C# compiler from the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**FluentValidation** uses this expression to know what property you’re validating
    by inspecting the expression.'
  prefs: []
  type: TYPE_NORMAL
- en: In **Fundamentals** part of the code for the book, you’ll find a class called
    **ExpressionExtensions** that has helper extension methods for doing the same
    type of inspection that **FluentValidation** does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since expressions can describe all kinds of members and the code for finding
    the member it represents is the same, there is a method for getting the expression
    that represents the member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code assumes that the incoming expression is **LambdaExpression** and then
    checks whether this is a **UnaryExpression** that holds the member. If it is not
    **UnaryExpression**, we assume it is **MemberExpression**.
  prefs: []
  type: TYPE_NORMAL
- en: If it is not **MemberExpression**, this will cause an invalid cast exception.
    You might want to consider checking types and throw a more specific exception.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the check for **UnaryExpression** is that for expressions that
    have the type of the value as **object** and the actual value is a type that needs
    converting, casting, or unboxing for it to become the **object** type, the compiler
    can decide to put in a unary expression that performs this action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the member expression, we can get the actual member as the **System.Reflection**
    type that represents a property, **PropertyInfo**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code calls **GetMemberExpression()** and casts **Member** to **PropertyInfo**.
    If the member is not **PropertyInfo**, this will throw an exception. You might
    want to check for correctness and throw a more specific exception.
  prefs: []
  type: TYPE_NORMAL
- en: With **PropertyInfo** returned, you now have all the information you need about
    the described property, its name and type, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about a valuable member of the .NET class libraries
    called expressions. Thanks to the symbiosis of the C# compiler and the runtime,
    you get another approach to reason about the running code.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions represent a structured approach for representing, well, expressions.
    There is somewhat of a resemblance to an abstract syntax tree, which all code
    compilers produce when parsing code. Something we’ll get more familiar with in
    [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn* *Compiler Extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen in this chapter, the type of expressions can be for just capturing
    information, but they can also be more powerful and capture operations that can
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into expressions and see how you can
    build out expressions at runtime that you can then execute dynamically.
  prefs: []
  type: TYPE_NORMAL
