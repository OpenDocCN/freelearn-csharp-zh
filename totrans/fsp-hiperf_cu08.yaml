- en: Chapter 8. Optimizing Computation Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most-used and unique features of F# is asynchronous workflow, and
    we have discussed this with the introduction to concurrency optimization in [Chapter
    4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction to Concurrency in
    F#"), *Introduction to Concurrency in F#*. The asynchronous workflow itself is
    actually an implementation of a computation expression, a feature that enables
    us to have a computation. This computation is, in fact, a sequence of workflows
    of functions that is composed sequentially and has bindings to bind or combine
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The computation expression has many kinds of helper methods to implement, but
    using these helpers can be overkill, and it may have some overheads as well if
    it is not constructed properly. It is not as subtle and hard as the previous discussion
    on language constructs in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus our optimization on the implementation of computation
    workflows with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Quick introduction to F# computation workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walkthrough of an example implementation of simple computation workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design consideration in planning the computation workflow implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations of computation expression optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick introduction to F# computation expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the quite subtle, but quite common, traits of a functional programming
    language is the availability of features to combine and compose functions into
    more sophisticated conceptual techniques that also encapsulate some side effects
    when combining functions. Some of these techniques are known as Monoids and Monads.
    These two come from the world of a subset of algebra, the category theory. This
    mathematical foundation gives the inspiration and also powerful concepts when
    composing and combining functions, including side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more gentle introduction and information to Monads in functional programming,
    you could watch this MSDN Channel 9 interview with Microsoft''s developer Brian
    Beckman:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads](https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads)'
  prefs: []
  type: TYPE_NORMAL
- en: The best sample of F# computation expression is the asynchronous workflow. The
    term workflow in asynchronous workflow comes from the fact that it is implemented
    from the use of the computation expression feature to provide asynchronous computation.
    Asynchronous workflow is itself composed from functions with side effects such
    as switching the context execution of the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already have discussed these F# concurrencies including asynchronous workflow
    cases in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#* that asynchronous
    computations do not always equate to the needs of multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, the composition of functions is done using builders. These builders are
    actually methods that help us construct a composition of functions. From the perspective
    of design patterns in OOP, these methods can be seen as helper methods or builder
    methods because they focus on building computation expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the composition of functions might contain conditional logic to handle
    side effects, such as threads, execution context (such as asynchronous workflow),
    I/O, and many more. The conditional logic is quite similar to workflow concepts
    whereas execution is always implemented as a sequence of steps. When conditional
    logic is needed, the execution always follows the branches of conditional logic
    based on the expression evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, F# language specification and MSDN Library mentioned computation expression
    as getting mixed with computation workflow. Since F# 3.0, the language specification
    is consistent and stricter to focus on computation expressions, not workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the official F# 4.0 language specification, the computation workflow
    syntax is often used by starting to have a construct using `builder-name` and
    the enclosing curly brackets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The expression itself might be functions as defined (and also governed) by the
    builders of the computation expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an initial example of the computation expression syntax, let''s revisit
    our own sample code for `async` workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample code uses `Control.AsyncBuilder`, a builder of `async`.
    The F# compiler will translate `AsyncBuilder` to a computation expression of `async`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now go deeper into the fabric of computation expressions: builders
    of computation expressions. We will also create a simpler computation expression
    than asynchronous workflow as a starting sample in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to builders of computation expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The notion, *builder*, also means that we construct a computation workflow by
    using the available builders when composing functions. These builders are actually
    methods that can be used when composing functions as a computation expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table briefly explains the commonly used builders in F# 4.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Typical Signature** | **Remark** |'
  prefs: []
  type: TYPE_TB
- en: '| `Bind` | `M<''T> * (''T -> M<''U>) -> M<''U>` | Provide `let!` and `do!`
    in a computation expression. It is a basic method to compose functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `Delay` | `(unit -> M<''T>) -> M<''T>` | Wraps a computation expression as
    a function. |'
  prefs: []
  type: TYPE_TB
- en: '| `Return` | `''T -> M<''T>` | Equivalent to `return` in computation expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ReturnFrom` | `M<''T> -> M<''T>` | Equivalent to `return!` in computation
    expressions. |'
  prefs: []
  type: TYPE_TB
- en: '| `Run` | `M<''T> -> M<''T> or M<''T> -> ''T` | Executes a computation expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TryWith` | `M<''T> * (exn -> M<''T>) -> M<''T>` | Called for `try..with`
    to catch exception (`exn`) in a computation expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `TryFinally` | `M<''T> * (unit -> unit) -> M<''T>` | Called for `try..finally`
    in computation expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `Using` | `''T * (''T -> M<''U>) -> M<''U> when ''U :> IDisposable` | Called
    from `use` binding in computation expression. It is equivalent to `using!` in
    computation expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `Yield` | `''T -> M<''T>` | Called for `yield` in computation expression.
    It is conceptually the same as `yield` in C#/VB, but the semantic is different.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `YieldFrom` | `M<''T> -> M<''T>` | Called for `yield!` in computation expression.
    It is conceptually the same as `yield` in C#/VB, but the semantic is different.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Zero` | `unit -> M<''T>` | Called when there is an empty `else` in the `if`
    condition (if there is an `if` statement in the computation expression). It is
    also called when the computation expression has an empty expression. |'
  prefs: []
  type: TYPE_TB
- en: 'For more information about computation expression and the full list of builder
    methods, consult the official MSDN F# computation expression on the new Microsoft''s
    docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have to implement all of the builder methods because there are no
    definitive minimum requirements of a computation expression. However, we should
    have the basic requirements of understanding in order to use a computation expression
    implementation to be used easily. The following are the common requirements in
    terms of usage requirement with builder methods:'
  prefs: []
  type: TYPE_NORMAL
- en: A bind to compose functions. This `Bind` method will contain a composition of
    functions. An implementation of `Bind` is recommended because the expressions
    supported inside a computation expression are governed by the types defined in
    the `Bind` method. For example, composing functions that have the same generic
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type to return. This requirement enforces us to implement `Return` or `ReturnFrom`.
    This is important because computation expressions must return a type, and it is
    recommended not to return `unit` (or `void` in .NET and C#).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delay`, to wrap a computation expression as a function. It is also quite common
    to call the `Delay` method as a wrapper method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Using`, to leverage the use of a type that implements `IDisposable`. This
    will be translated as `use` binding inside the computation workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryWith`, to handle exceptions inside a composition of functions of `Bind`
    or explicitly handle exceptions outside `Bind`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bind` method is crucial because it governs the type of generic type in
    the functions we are going to compose, but it is also enforcing all the types
    of the `let!` and `do!` functions inside a computation expression. Omitting `Bind`
    will make the computation expressions to be less complete because the main goal
    of a computation expression is the ability to compose expressions, not just returning
    the underlying type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of our previous sample code for asynchronous workflow, the following
    is the illustration of `Bind` as `let!` in an asynchronous workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to builders of computation expression](img/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The default distribution of the F# core library already has samples of implementations
    of computation expressions with its own underlying type:'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ query expressions support that returns `System.Linq.Enumerable<'T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous workflow returns `Async<'T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F# LINQ query expression is a little bit subtle, but actually it has implementation
    details similar to LINQ used in C#/VB. It is semantically the same; therefore,
    the performance characteristics are also similar to running LINQ in C#/VB. The
    difference between F# and C#/VB implementation is the type of delegates used:
    `FastFunc` in F#, `Func` in C#/VB.'
  prefs: []
  type: TYPE_NORMAL
- en: This strong recommendation of F# function over `Func` is crucial and important
    because the method signature of all method builders use F# curried functions instead
    of the normal .NET method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Using F# function/delegate over .NET Func
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usage of F# delegate instead of a normal .NET `Func` is also more efficient
    and more functional because of the immediate feature to have F# delegate as a
    function that supports currying; this allows for a higher order function after
    the availability of a partial function application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are developing applications that use our own implementation of computation
    expressions, of course, it is faster and highly recommended to use F# function/delegate
    instead of using .NET `Func`. It is highly compatible with the rest of F# constructs/features,
    and it is faster to compile in F#. It is highly recommended due to the availability
    of function currying.
  prefs: []
  type: TYPE_NORMAL
- en: Proof that F# functions are optimized for supporting currying functions is available
    in the way F# supports higher order functions. Microsoft has documented this,
    and it is wrapped in a very nice walkthrough guide for functional programming
    traits/characteristics, focusing on function as first class values. The concept
    of function as first class values is then compared to classes and method as first
    class values of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting information about function as first class values and F# currying
    is available in this MSDN docs page of F# functional programming traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values)'
  prefs: []
  type: TYPE_NORMAL
- en: 'On that page, we focus on the implied currying of F# in the section on curried
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Currying is a process that transforms a function that has more than one parameter
    into a series of embedded functions, each of which has a single parameter. In
    F#, functions that have more than one parameter are inherently curried.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The implications of currying highly influence the language design of F#; hence,
    a special or unique F# function/delegate is needed. In the general .NET BCL, this
    F# unique implementation of a curried function is becoming very important and
    critical from the perspective of functional programming language architecture
    because `Func` does not support currying.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not going to dive deeper into the discussion of what is functional programming
    and the traits of functional programming language. Consult more of functional
    programming concepts in F# and the functional programming support in F# in the
    preceding MSDN docs page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s examine the common (typical) signature of the `Bind` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This signature means that the function returns `M<'U>` as its result, as indicated
    by the type signature after the last `->`. The `*` between two types before the
    last `->` means that the method takes two arguments-one is a normal type and the
    second parameter is a function that takes a generic `T` returns a type with a
    type of `M<'U>`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `*` in the signature of a method member of a class means that the
    types (before the resulting type) are seen as the arguments of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function of `(''T -> M<''U>)` means a function that takes one argument
    of `''T` and returns a result. This argument does not have to be one argument.
    We can also use more functions that have more than one argument, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `M<'V'>` is the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of `''T -> ''U` before the last -> means that the function has
    two arguments, typed generic `T` and `U`. We can then change and adapt the signature
    of `Bind` to be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can then start to implement our `Bind` method. However, be careful as the
    `let!` and `do!` constructs are altered quite large, and it's better for us to
    implement computation expressions as simply as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Relation of F# function computation expressions with arguments restriction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use many arguments, but it is quite common to only use a function
    with one argument as long as the type is lined up well. If we use more than one
    argument, our `Bind` method implementation will be more complex, and it will always
    be harder to construct semantically correct computation expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Not just the generic types have to be aligned carefully; it is also more complex
    to implement `Bind` with many parameters. The F# language specification also implies
    that the current F# 4.0 compiler (especially the lexer and parser) is preferred
    instead of using `Func`.
  prefs: []
  type: TYPE_NORMAL
- en: This complexity of having an implementation of `Bind` method with parameters
    will become clearer by having samples of computation expressions with `Bind`.
    The next section is the starting point of a sample of computation expression.
  prefs: []
  type: TYPE_NORMAL
- en: Walkthrough of planning and writing a computation expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start writing a very simple functional way of creating a **WPF** (**Windows
    Presentation Foundation**) window and composing WPF controls.
  prefs: []
  type: TYPE_NORMAL
- en: WPF is basically a UI framework implemented on top of DirectX 9.0c that starts
    from the release of .NET 3.0 as libraries of UI. It is still aggressively developed
    by Microsoft, and with the release of WPF comes the innovation of XAML as a declarative
    UI. It has been heavily supported since Visual Studio 2008, and now it is beginning
    to replace Windows Forms.
  prefs: []
  type: TYPE_NORMAL
- en: This slightly unfortunate fate of Windows Forms becomes more apparent with the
    introduction of Visual Studio 2012 and .NET 4.5; Windows Forms are no longer developed
    (although they are still supported in terms of bug fixes), but they have not yet
    been deprecated or become obsolete. It is considered as replacing Windows Forms
    because WPF is still developed heavily, at least not just in Visual Studio 2015/.NET
    4.6.1, but it is also evident in the upcoming version of Visual Studio 2015, the
    Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about WPF, visit the official home page of WPF on MSDN
    at [https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting to implement WPF composition using computation expressions,
    we need to have some basic idea to understand the following (as design consideration
    plans) before having code implementations of WPF:'
  prefs: []
  type: TYPE_NORMAL
- en: All WPF control derives from `System.Windows.FrameworkElement`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WPF window is called `System.Windows.Window`.
  prefs: []
  type: TYPE_NORMAL
- en: On the `Window`, all of the controls (typed as `UIElement`) to be put are usually
    laid on a container panel that is inherited from `System.Windows.Controls.Panel`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The adding of controls on `Panel` has to be carefully designed to exclude `Window`
    as it will not make sense if we add `Window` on to `Panel`, although `Window`
    inherits `System.Windows.Controls.Control` and `System.Windows.UIElement`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are special treatments of a `Panel` to be taken into account: the knowledge
    of what a `Panel` is and why it is not available to be used directly.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the proof that we cannot use `Panel` directly because `Panel` is implemented
    as an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `System.Windows.Controls.Panel` declaration in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AbstractClass` attribute is the same semantic as marking the class as
    abstract class. Abstract class in F# is treated using the `AbstractClass` attribute,
    not as a keyword as in C#/VB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To avoid confusion, we should know the OOP concept and keywords in F#, while
    at the same time relating and interoperating with OOP in C#/VB. This conceptual
    knowledge is increasingly relevant because it's quite common that in developing
    WPF application, we rely on inheritances and componentizations of OOP controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start utilizing WPF, ensure that the following assemblies are referenced
    or registered (if you are in the scripting interactive mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '`WindowsBase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PresentationCore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PresentationFramework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Xaml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For scripting mode, these assemblies have to be registered first by directly
    registering the location of the DLL. In the following sample, we register the
    assemblies with 32-bit assemblies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After registering all the required DLL assemblies, we should tell the F# compiler
    to scope the namespace of WPF to be available in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The open namespace is also useful because it will shorten our naming of WPF
    type not to use full type name with the namespace. It is semantically similar
    to the `Using` keyword in C# and `Import` in VB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start from just creating `Window` with `Panel`, but we can also use
    an abstract class as a template for `Window` with `Panel` and `Panel` with controls
    because both `Window` and `Panel` extend `FrameworkElement`, as illustrated in
    this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Walkthrough of planning and writing a computation expression](img/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are going to implement our abstract class as a template for our builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the knowledge that `Window` and `Panel` inherit from the same `FrameworkElement`,
    we can continue to have the implementation of our own `Window` builder as a computation
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the implementation of `PanelBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `PanelBuilder` implementation, we add type checking for `c` (as highlighted).
    If it is typed as `Window`, we should raise `System.ArgumentException` to inform
    us further that we cannot use `Window` to be added onto `Panel`. We can also return
    `null` as an option instead of `Exception`, but returning `null` is not recommended
    in F#, and it also adds more confusion on what is being added. Also, the code
    is not composed well. Any bad composition in `Bind` will always increase the unpredictability
    of the computation expression. Further information on this consideration is described
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the fact that we derive `WindowBuilder` and `PanelBuilder` from the
    `IComposableControl` abstract class, we must also implement all of the abstract
    methods of `IComposableControl`. The implemented method must have an override
    modifier to denote that the method is an implementation of abstract methods from
    `IComposableControl`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not going to have a full discussion on OOP features of F# because it
    is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on abstract method and overrides, consult MSDN docs at [https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the builders implemented, we can set the builders in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Walkthrough of planning and writing a computation expression](img/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To test for `Zero`, we can simply test it by having an empty expression in the
    computation expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of `Zero` in our `WindowBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a subtle feature, but we have used it and most of us are unaware:
    the builder object; when it is instantiated, the F# compiler will treat the instance
    as a keyword!'
  prefs: []
  type: TYPE_NORMAL
- en: This translation of a computation expression instance becoming a keyword is
    already demonstrated by asynchronous workflow by instantiating `AsyncBuilder`
    as `async`. Therefore, the usage of `async` instance will be treated as a keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `WindowBuilder`, the instance of `WindowBuilder` will be treated
    as a keyword too. For example, the following is a sample instance of `WindowBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In Visual Studio, the preceding treatment of `windowexp` as a keyword is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Walkthrough of planning and writing a computation expression](img/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have `windowexp` as an instance of `WindowBuilder()`, and we can use
    it as a `windowexp` computation expression keyword. This is shown by having a
    blue color just like the other F# keywords.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a simple computation expression that has `Bind`, `Return`, and
    `Zero`. Let's peek into the implementation of a computation expression inside
    an asynchronous workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `AsyncBuilder` for an asynchronous computation also follows
    the same pattern as the implementation of `WindowBuilder` and `PanelBuilder`;
    it defines the method builder first, although the implementation does not use
    an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite easy to examine the implementation of F# asynchronous workflow
    because we can directly examine the source code. The following is the landing
    page of F# core libraries (`FSharp.Core`) source code, including the F# compiler
    implementation and F# tooling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Microsoft/visualfsharp/tree/master/src](https://github.com/Microsoft/visualfsharp/tree/master/src)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the type declaration and the code of `AsyncBuilder` in the `control.fs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All the members are implicitly `public static` methods, so it is again very
    succinct to quickly implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s visit the `Bind` method implementation, the `bindA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to check the signature of `AsyncBuilder.Bind`, the signature is
    in the `Controls.fsi` file. The following is the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bind` signature defines that the method takes two arguments: computation
    and binder. The computation argument is typed as `Async<''T>`, the binder is typed
    as `''T -> Async<''U>`, and the return type is `Async<''U>`, the generic parameter
    of `''U` is the underlying type. This `Bind` method is then called if we are using
    `let!` within the asynchronous workflow construct.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the use of type returned in computation expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is an apparent pattern of `let!`, `return`, and `return!` expressions
    in the computation expression. The use of the bang sign `!` as a suffix means
    that these expressions return the underlying type directly without any wrapper
    type. For example, `return!` will call the `ReturnFrom` method and `return` will
    call the `Return` method. In the case of F# asynchronous workflow, we can just
    see the signature comparison of `Return` and `ReturnFrom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the explanation of the implication of the underlying type:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ReturnFrom` will return the resulting type immediately without the wrapping
    type. In practice, it returns `'T` instead of `Async<'T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Return` method will return a type that wraps the underlying type. In the
    case of asynchronous workflow, `Return` will return `Async<'T>`, whereas the `Async`
    type wraps the type of `` `T ``.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of `ReturnFrom` is similar in .NET TPL to having `T` as the result
    of an operation of `Task<'T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The F# way of composing a computation expression makes it easier to reason about
    returning the underlying type, but in .NET TPL, to get the `T` in `Task<T>`, we
    have to access the property as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this type wrap is shown when getting the result of `Task<T>` (in
    C#):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As highlighted in the preceding code, the underlying result is contained in
    `t.Result` instead of `t` because `t` is typed as `Task<int>`. Therefore, the
    underlying type is typed as `int`; it is matched with the property declaration
    of `Task<T>`. `Result` documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Other expressions such as `yield` and `yield!` have the same intention and behavior
    as `return`/`return!` and `let`/`let!` in terms of the type they return.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous workflow and our own WPF computation expressions are samples
    of the common nature (also called *common behavior* in the realm of practical
    software engineering) of computation expressions. It is strongly recommended to
    follow this common nature of computation expression. Therefore, these traits of
    common nature of computation expression are not just best practices but also make
    more sense as predefined specifications for implementations. The predefined specifications
    for common code programming implementations are often called **design considerations**.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the design considerations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: General computation expression design considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented a very simple computation expression using `Bind`, `Return`,
    and `Zero` as a starting sample.
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude that the use of `Bind` will translate into `let!` as the result
    of `let!` expression will be composed nicely. The other translations are available
    on the official MSDN docs page of computation expression.
  prefs: []
  type: TYPE_NORMAL
- en: The translation of builder methods into syntaxes of language constructs such
    as `let!`, `return`, `return!`, and  `do!` are samples of syntactic sugar. The
    **syntactic sugar** of a computation expression is the ability to translate the
    builder methods into very neat declarative expressions to combine expressions
    and functions nicely. It is quite easier to have computation expressions instead
    of directly calling the method builder after instantiating the builder object's
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the discussion in the previous sections, we have concluded that there
    are some aspects of best practices and some advice that must be taken into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The appropriate term for these aspects is *design considerations* because they
    serve as best practices and some initial actions to be avoided at the beginning
    of the implementation of a computation expression. The design considerations also
    include the related information on avoiding the pitfalls of computation expression
    because the design considerations include the related implementation patterns
    or background reasons behind each of the design considerations. Most of the reasons
    include pitfalls to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the design considerations of computation expression implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: Always begin with the planned results and general outcomes of what you want
    to achieve. Not all builder methods have to be implemented because while any builder
    method implementation provides more powerful syntactic sugar and also more declarative
    constructs, it also adds compilation overheads, and therefore the generated IL
    could be more complex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signature of the used builder method must follow the same pattern recommendation
    as described in MSDN docs for F# computation expressions. This is crucial because
    any computation expression must have a high degree of predictability in the beginning
    by obeying or complying with the same signature recommendation of the builder
    method. For example, `Bind` must follow the signature of `M<'T> * ('T -> M<'U>)
    -> M<'U>` in order to have a predictable result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*The focus of the computation expression is usually differentiated into three
    main focuses: on the requirement to return underlying type, on only combining
    operations in expressions/functions that usually return nothing or return F# Unit
    (void in C#), and on combining side effects*. This condition especially applies
    to the case of `Zero` method. The nature of computation workflow does not require
    to implement `Zero` for all cases. For example, a query computation expression
    (the `query { ... }` expression) does not require `Zero`, because it does not
    make sense to implement the `Zero` method because the main focus of a query expression
    is on not the underlying type, but rather on combining query expressions/functions
    of LINQ and trying to avoid side effects as much as possible. It makes sense in
    the case of asynchronous workflows and for `WindowBuilder`/`PanelBuilder` as combining
    asynchronous computations and adding UI controls have side effects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding support for `Zero` means that we should be aware that the computation
    of `Zero` support might contain side effects. Therefore, the `Zero` method support
    should be added for computation expressions that have the predefined goal to include
    any side effect instead of composing pure functions or composing objects with
    a strict hierarchy. Asynchronous workflow is intended to combine functions and
    operations in a manner so as to have side effects; therefore we can safely include
    `Zero` support as well. `WindowBuilder`/`PanelBuilder` might not have side effects,
    but *all of the leverage in GUI layer, such as Windows Forms and WPF, always has
    side effects*. Sequence computation workflow, the `seq { ... }`, might have side
    effects, but the main goal is to focus on returning the underlying type. Therefore,
    `seq` computation expression does not have the requirement or necessity to implement
    `Zero`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding support for `Combine` means that it is strongly recommended to add support
    for `Delay` because it is required based on the implementation body of the `Combine`
    method. But implementations of the `Delay` method builder will add more complexity
    because the result is not evaluated immediately. Such a behavior of not having
    evaluated immediately happens because the `Delay` method is always executed before
    the `Return`/`ReturnFrom` method. It can be optimized to be implemented with less
    complexity only if the method body of `Delay` contains simple expressions or if
    it simply contains a function because the nature of the `Delay` method is to wrap
    a function that contains our computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To shorten the instantiation of the computation expression builder, we can instantiate
    it under a module using the normal `let` syntax. F# will treat the instance of
    the builder as a keyword. *It is therefore strongly recommended to have only one
    instance that will be used as a keyword because it is bad practice to have many
    instances of a builder to have many keywords with the same semantic*. For example,
    we use `windowexp` as our instance of `WindowBuilder`, which can then be used
    by other F# library (DLL) or executable applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instantiation of a computation expression must not be the same keyword in
    the existing pool of F# keywords. Otherwise, we will have unpredictable results
    and compile errors. This is crucial because we should not add more keywords in
    form of the name of type builders freely without checking the existing F# keywords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use an F# delegate/function (`FSharpFunc`) instead of .NET `Func` as much as
    possible, unless we are going to have an explicit use of .NET `Func` inside the
    implementation of the computation expression. For example: a query computation
    expression contains calls to LINQ''s static methods, such as `Enumerable.Where`
    and `Orderable.OrderBy`, which requires .NET `System.Func` delegates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The use of `Using` method builder is optional but we should use `Using` as much
    as possible if we are allowing the use of types (for the underlying type) that
    should be disposed immediately. The type that fits into this model is the type
    that implements `IDisposable`. But having this `Using` will add more complexity
    to our computation expression, and not all of the planning focuses (as described
    in point 3) require us to have implementations of `Using` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not use an implicit type as the underlying type of a computation expression
    for a type that has an implicit reference counting of events as part of event
    driven programming mode.. An example of this is the use of any `EventHandler`
    type (or a derived type) for the underlying type of a computation expression.
    Although there is no restriction on using event handler objects as the underlying
    type, there is no guarantee that we can always dereference the events from an
    event handler as the underlying type. Any event might have been added during the
    running of the computation expression, unless we also remember to dereference
    all of the referenced event objects, and this always adds more complexity to the
    implementation of the computation expression itself. Using the `IDisposable` pattern
    will not guarantee that any handled events are deregistered when the type is disposed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we use an implicit type as underlying type that is derived from reference-counting
    type such as `EventHandler`, the event registration (reference) and dereference
    have to be handled explicitly. This explicit reference/dereference implementation
    will guarantee that the reference to outside events that are referenced outside
    as delegates are registered and deregistered correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not use inline functions on method builders. The context of inline functions
    does not fit into the context of a computation expression because inline functions
    will be inlined for every use of our method builder, and this is against the F#
    language specification. However, the nature of method builders prefers to have
    normal generic type parameters, which are then generalized instead of having an
    early optimization on the generic type inlined. Also, all of the method builders
    cannot be inlined easily because these methods only live within the type set by
    the computation expression builder type definition and can be used only within
    the scope of the computation expression when its instance is used. Fortunately,
    the F# compiler will catch this inline usage on builder methods early as a compile
    error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is good for us to have the preceding design guidelines when we are going
    to implement computation expressions, but they have their own implications and
    there are additional sub notes and more explanations on some points of the design
    consideration. The next section describes these implications with the additional
    explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Implications of the design considerations of computation expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The points in the design consideration are quite self-explanatory, but some
    points have to be explored further because they have some implications not just
    on the correctness and the clarity of the intention of the computation expression
    when used outside the scope of the assembly but also on the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the points of the design considerations that have additional implications
    to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Point 2 defines that we must meet the specifications based on the signature
    of the commonly used method builder. This is important, especially on the crucial
    (required) methods that define the core intention and the requirement of the computation
    expression's focus as described in point 3 of computation expression focus. In
    the case of asynchronous workflow and `WindowBuilder`/`PanelBuilder`, all of them
    have to deal with the side effects, and therefore the implementation of `Bind`,
    `Return`, and `ReturnFrom` methods has to be implemented using the respective
    signature guidelines. Failing to comply with these signature guidelines will result
    as compile errors.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we try to have `yield` in our use of `PanelBuilder`, we will
    get a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following faulty code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The Visual Studio editor will display squiggle on the line with the `yield`
    declaration and also will complain that `yield` method has not been implemented
    yet, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implications of the design considerations of computation expression](img/image00331.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This error information from the F# compiler is crucial as currently, we have
    not yet implemented yield for `PanelBuilder`, although `yield` itself is a valid
    keyword in F# when used in a `for` loop outside a computation expression.
  prefs: []
  type: TYPE_NORMAL
- en: This simple quick test is also useful to prove that consistency in the implementation
    of a computation expression is very important so that we can be sure that our
    implementation of computation expression is correct in the sense that we have
    done the implementations based on the initial intention and design considerations.
    This is also why it is called *correctness*, not just consistency of the implementation
    and the usage.
  prefs: []
  type: TYPE_NORMAL
- en: Point 3 in the aspect of computation expression focuses implies that there is
    a certain deciding plan before implementing a computation expression. This focus
    plan will also provide guidelines on what method builder we should strongly implement
    and what method should not be implemented mainly based on how we are going to
    handle the side effects first.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there are no officially defined guidelines for computation expression
    method builder implementation in F# language specification. The main goal of the
    focus guideline is to have a starting focus plan on the implementation of computation
    expressions, which is then easily translated to what method builders we should
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: Having the mindset to first focus on side effects is also critical and helpful.
    It also complies with the functional programming language common practices that
    we should treat side effects explicitly and identify them early in the beginning
    of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then simplify the narrative description of point 3 with this illustration
    as the deciding flow (using UML 2 diagram notation):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implications of the design considerations of computation expression](img/image00332.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding Unified Modeling Language (UML) activity diagram illustration
    is not meant to limit the creativity of the developer. In fact, there are no restrictions
    for the minimum method builders for many specific purposes beyond what we have
    in the illustration.
  prefs: []
  type: TYPE_NORMAL
- en: We leverage the UML activity diagram because we need to document or illustrate
    the flow of the deciding factor. UML itself is a software development standard diagram
    that focuses on documenting processes and system development (including application
    development), under the supervision of **Object Management Group** (**OMG**),
    a non-profit organization for standardizing documented processes and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about UML 2 diagram, visit the official UML page at: [http://www.uml.org/](http://www.uml.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the landing page of UML 2 standards with various version histories
    at OMG: [http://www.omg.org/spec/UML/](http://www.omg.org/spec/UML/).'
  prefs: []
  type: TYPE_NORMAL
- en: The UML activity diagram is part of the UML 2.1 standard diagrams and notations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The UML activity diagram is easier to understand than a flowchart because it
    can accommodate more conditional concerns (not just yes/no or true/false) and
    provides more support for event-driven and message passing agents. The most frequently
    used UML diagram is the activity diagram. Activity diagram is one of the many
    diagrams under the UML 2.1 umbrella standards. Currently, the UML standard has
    version 2.5, but still the widely used version in 2016 is UML 2.1\. This book
    does not focus on how to create and use UML diagrams because it is beyond the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: When we discuss the side effects in point 3, we should be aware that side effects
    are not just I/O or any other kind of outside API calls, such as interoperability
    with Win32 API; side effects such as exceptions, event-driven model, and any GUI
    library have to be taken into account as well to be carefully handled. When an
    event handler is instantiated within a computation expression, it is recommended
    to clear all event handlers of any events that we want to handle by setting them
    to `None` (`null` in C# semantic, `Nothing` in VB semantic). Otherwise, we will
    have occurrences of memory leaks even after we are done executing computation
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Point 5 about the instantiation of computation expression is also a simple but
    meaningful proof of how we can easily add keywords to the existing F# keywords.
    It can lead to confusion because more keywords means more semantic and more contexts
    to be understood.
  prefs: []
  type: TYPE_NORMAL
- en: Point 8 about leveraging the `Using` method in a computation expression has
    to be implemented carefully. It is nice to have a use pattern for disposable objects,
    but many uses of disposable objects might lead to having additional overhead on
    garbage collector (GC) because of the overhead when disposing objects at the end
    of the computation expression lifetime. Also, having the `Using` method only can
    work for `IDisposable` objects, and this constraint will put a restriction on
    what kind of types to be used in the implementation of the `Using` method.
  prefs: []
  type: TYPE_NORMAL
- en: Point 9 is also important, although it is the last point in our design considerations
    because any use of types that have implicit reference counting as the underlying
    type (such as event handler) might be dangerous. Not that we cannot have the guarantee
    of always dereferencing references to other objects, such as events, but any action
    of dereferencing itself is always synchronous and it may slow down the running
    performance a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Although dereferencing events of an event handler is as easy as setting it to
    `None`, but because of its sequential nature of synchronous executions, it cannot
    be used nicely in a parallel execution at all. This means that there is no option
    for parallelism when we have to do dereferencing.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations of computation expression optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computation expressions can be further optimized if we carefully implement the
    design planning. We have discussed the design considerations of a computation
    workflow in the previous section of this chapter, and we shall carry the considerations
    as a quick foundation to perform optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optimization of computation expression is quite hard because of the following
    factors as consequences of computation expression syntax translations:'
  prefs: []
  type: TYPE_NORMAL
- en: Construction of computation expressions depends heavily on syntactic sugar that
    becomes language constructs. For example, `ReturnFrom` method is translated to
    a method that returns a result of the underlying type of a computation expression.
    Therefore, we must follow the strict guidelines of the asynchronous method builders
    to express translation; otherwise, we will get unpredictable results or even exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Composing the sequence of `let!` requires some wirings of a chained `Bind` method
    builder in the form of chaining `Bind` methods. This chaining of `Bind` method
    might be error-prone and it cannot be optimized further. Fortunately, we have
    a method builder in a computation expression called `Combine` to sequence multiple
    expressions (also called *sequencing expression* in the MSDN documentation of
    F#). However, the `Combine` method has to be carefully rewritten to match the
    signature requirement specification for `Combine`, then all of the necessary requirements
    of the related builder methods such as `Bind`, `Return`, and `ReturnFrom` must
    be aligned to match the type signature as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the expression returned by expressions within a computation expression
    is not returned immediately because the order of execution might change based
    on what the implementation body of `Combine` and `Delay` is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Points 2 and 3 are closely related to the design considerations, particularly
    to point 5 of the design considerations of computation expression that we discussed
    previously in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand `Delay` and also to prove that it changes the execution order,
    we could compare two implementations of computation expressions: the first one
    without `Delay`, and the second one that has `Delay`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This following code is implemented without the `Delay` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this `ComputeExpression1Builder` builder, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using **F# Interactive** mode, execute the preceding code. The **F# Interactive**
    window will display the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Considerations of computation expression optimization](img/image00333.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code is the same code as the previous one, but now it has the
    `Delay` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Delay` method in the preceding code is implemented with type annotations.
    This is important because without type annotation, F# will set the signature to
    be generalized; this generalization is caused by automatic generalization. We
    need to minimize automatic generalization because we want to prevent type checking
    at the runtime when the generic parameter is bound because we already know that
    the method body of `Combine` will infer that the type of the underlying result
    type is `Int32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to test `ComputeExpression2Builder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following display of **F# Interactive** window proves that the `Delay`
    method wraps a function in a computation expression and affects the evaluation
    (as shown by the display of **Test** from `Console.WriteLine`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Considerations of computation expression optimization](img/image00334.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code has proved that the `Delay` method should be used carefully,
    and it may contain side effects that not just change the order of execution of
    `Yield` (or other returning result methods, such as `Return`/`ReturnFrom`), but
    it also might terminate the execution before returning the result of `Yield` because
    of the possibility of catching an exception.
  prefs: []
  type: TYPE_NORMAL
- en: This simple sample optimization case combined with the design considerations
    provides us careful and predictable behaviors. We now have increased awareness
    of what is going on inside a computation expression and how to minimize the overhead
    of having unnecessary or overkill usage of method builders.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The knowledge of the computation expression correctness is also useful as we
    are not sacrificing performance as well, while at the same time keeping the functional
    programming's best practices in place. Although the nature of builder methods
    in a computation expression implementation is mostly implemented using the object
    oriented principle, using instantiated computation expression gives us more expressiveness
    to make our code cleaner and better composed.
  prefs: []
  type: TYPE_NORMAL
- en: We have the knowledge of the optimization of F# code or applications, starting
    from identifying the performance aspects of the .NET runtime to the detail of
    F# performance characteristics, measurement with .NET tooling ecosystem, and optimization
    of all the aspects of the F# language ecosystem-from the compiler to the existing
    F# features.
  prefs: []
  type: TYPE_NORMAL
- en: We not only have an understanding of the general language features but also
    the knowledge of aligning compilers with concurrency, data structures, language
    constructs, and other sophisticated and powerful features, such as computation
    expression.
  prefs: []
  type: TYPE_NORMAL
