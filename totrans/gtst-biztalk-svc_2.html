<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Messages and Transforms</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Hello BizTalk Services">Chapter 1</a>, <em>Hello BizTalk Services</em>, we discussed the basics of <strong>BizTalk Services</strong> and the central concept of a bridge providing the vehicle for receiving and sending data via endpoint adapters (sources and destinations) through its built-in pipeline. In this chapter, we'll discuss messaging aspects, focusing on one particular aspect of messaging: transformation, or mapping. One of the most common aspects of integration is the need to turn one message format into another; what we referred to as structural impedance in <a class="link" href="ch01.html" title="Chapter 1. Hello BizTalk Services">Chapter 1</a>, <em>Hello BizTalk Services</em>. It's the bread and butter of any integrator's toolbox, and BizTalk Services provides a brand new, modern mapping engine with graphical tooling to build sophisticated and powerful transforms. In this chapter, we'll look at BizTalk Service's mapping and transformation capabilities in detail and the flexibility it provides. To summarize, this chapter will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why transformation and mapping is important</li><li class="listitem" style="list-style-type: disc">Mapping capabilities in BizTalk Services</li><li class="listitem" style="list-style-type: disc">Creating your first map</li><li class="listitem" style="list-style-type: disc">Understanding mapping operations</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>The problem</h1></div></div></div><p>BizTalk Services' job is to let you connect this to that. What this and that actually are may not <a id="id90" class="indexterm"/>always be clear, well defined, or standardized into some internationally recognized protocol. A mapping capability is therefore crucial—a way to convert this into that. On many occasions, mapping requirements may be complex; the need to fundamentally change the shape or structure of a message, for example, or the need to replace data values from the source message with something that makes sense to the receiver. We can break this down into two classes of problems: one that needs to address the structure of a message, transformation; and one that needs to address its content, transcoding or translating it. The two types of mapping, transformation and translation, are both possible with BizTalk Services, as we'll see in this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>The mapper</h1></div></div></div><p>So far, we're <a id="id91" class="indexterm"/>being deliberately vague, and with good reason. Often, mapping requirements are not well known and change as more is discovered about the nuances of the messaging formats involved and their variations. It often surprises people familiar with dealing with XML-based messages that describing their validity simply in<a id="id92" class="indexterm"/> terms of schema by using XML Schema Definition (<a class="ulink" href="http://www.w3.org/XML/Schema">http://www.w3.org/XML/Schema</a>) can turn out to be more complicated than it first appears. This is unfortunately sometimes to do with the different productions or instances of XML messages that can be created or produced by a single schema, often unintentionally. XSD is sometimes not precise enough, and integration is therefore often messy, requiring good tools to make things fit, while the purity of standards and specifications doesn't go far enough to avoid ambiguity in implementation. This is a theme we'll come back to many times during this book: to be successful, any integration technology must be flexible to bend to the problem at hand, to fit into that, to not be changed, to adapt, to transform, and to integrate. Mapping is one tool in the box, and is a very important one to meet these requirements. As such, it deserves a chapter all to itself.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>The map designer</h1></div></div></div><p>Take<a id="id93" class="indexterm"/> a look at the following screenshot. This shows the new graphical mapping designer that is accessible from Visual Studio 2012. For those familiar with <strong>BizTalk Server</strong>, don't be fooled. While it may have a similar look and feel to the BizTalk Server mapper, this tool has significant differences; the overriding design aesthetic was to make common mapping tasks as simple as possible, and as such, the mapper has undergone a significant overhaul.</p><div><img src="img/7401EN_02_01.jpg" alt="The map designer"/><div><p>Graphical mapping designer</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Schema</h1></div></div></div><p>However, we're<a id="id94" class="indexterm"/> getting ahead of ourselves. In order to map one message format or structure to another, to translate its contents for example, we first need to understand the messages themselves. Fundamental to this is schema.</p><p>BizTalk Services differentiates between two types of messages: XML and non-XML. All XML message formats are expressed using XSD, and all non-XML message formats are expressed using XSD. So, XSD is important! The purpose of this book is not to provide a primer in XSD; we'll refer to other references if you need some background on the technologies we mention. Instead, we'll provide just enough to show how BizTalk Services uses such technologies so that the less familiar can still understand what is going on.</p><p>Now, you're probably wondering how any message formats you can think up can be defined in XSD. Let's look at an example.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>An example</h1></div></div></div><p>Let's expand <a id="id95" class="indexterm"/>on the example we looked at in <a class="link" href="ch01.html" title="Chapter 1. Hello BizTalk Services">Chapter 1</a>, <em>Hello BizTalk Services</em>. If you recall, this example received a file via SFTP and routed it to a Service Bus endpoint. Now we'll add a map to the solution. The map will transform the incoming message into a different format expected by the recipient. However, as noted previously, if we're to turn one message format into another, we need to define the schema of the target message first in order for us to be able to map to it.</p><p>To do this, right-click on the project, navigate to <strong>Add</strong> | <strong>New Item</strong>, select <strong>Schema</strong> from the list of items, and provide the name <code class="literal">OrderUS.xsd</code>. Click on <strong>Add</strong> to create the schema and add it to the solution.</p><p>The schema designer will now be open. As you did in <a class="link" href="ch01.html" title="Chapter 1. Hello BizTalk Services">Chapter 1</a>, <em>Hello BizTalk Services</em>, add nodes to the schema to build it up, as shown in the following screenshot:</p><div><img src="img/7401EN_02_02.jpg" alt="An example"/><div><p>Changing the Order schema</p></div></div><p>Now, <a id="id96" class="indexterm"/>right-click on the project and navigate to <strong>Add</strong> | <strong>New Item</strong>. Select <strong>Map</strong> from the list of items and provide the name <code class="literal">FFtoUS.trfm</code>. Click on <strong>Add</strong> to create the map and add it to the solution.</p><p>The map designer will now open; the first task is to set the schemas. As a map's job is to convert one format to another, a minimum of two schemas are required: the input and the output.</p><p>Click on the <strong>Open Source Schema</strong> link, expand the tree, select <code class="literal">OrderFF.xsd</code>, and click on <strong>OK</strong>. Now click on the <strong>Open Destination Schema</strong> link, select the <code class="literal">OrderUS.xsd</code> schema, and click on <strong>OK</strong>.</p><p>The designer will now look like the following screenshot:</p><div><img src="img/7401EN_02_03.jpg" alt="An example"/><div><p>Selecting schema with the designer</p></div></div><p>Now we need to map one format to another. We do this by connecting the nodes together, usually working from left to right.</p><p>Join the <code class="literal">OrderId</code> node on the left-hand side to the <code class="literal">OrderNumber</code> node on the right-hand side by clicking and holding the left mouse button while dragging across to the right-hand side and releasing the button when the pointer is over the target field.</p><p>Now<a id="id97" class="indexterm"/> notice that the customer information is different in the target schema and the source; only the element names are different, but the structure is the same. The mapper provides a shortcut for mapping fields quickly to avoid having to connect them one by one. To do this, click and hold the left mouse button down on the parent <code class="literal">Customer</code> node in the left-hand side source schema and drag across to the target's <code class="literal">CustomerDetails</code> node. The context menu shown in the next screenshot will pop up. Here, we are presented with a number of options as shown in the following screenshot. Select <strong>Link by Structure</strong> and notice that all the nodes are connected together automatically even though their names differ. This is because this option connects fields in the order they appear, regardless of the node names, and is useful when the structure of both schemas is the same. You can use the same approach for mapping where the field names match too (<strong>Link by Name</strong>) or select <strong>Simple Link</strong> which will simply connect the top-level nodes together. This technique is very useful <a id="id98" class="indexterm"/>when mapping a large number of fields.</p><div><img src="img/7401EN_02_04.jpg" alt="An example"/><div><p>Linking options</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Mapping operations</h1></div></div></div><p>We can proceed like this for as many nodes as we like, connecting them individually or in groups. However, we often need to do more than just map one node's value to another. For this, we can turn to mapping operations. For those acquainted with BizTalk Server, you will be<a id="id99" class="indexterm"/> familiar with <strong>functoids</strong>; the concept is similar in BizTalk <a id="id100" class="indexterm"/>Services. However, despite the similarities, there are many differences in how they are realized. One of the primary goals of the product group is to simplify common tasks, such as looping, which were often difficult or time consuming to achieve previously. This is where we will now focus our attention.</p><p>BizTalk Services provides a total of 37 mapping operations that are functionally grouped into categories in the toolbox. There isn't room here to cover every mapping operation, so we'll focus<a id="id101" class="indexterm"/> on some of the most useful. For a complete reference, check the MSDN documentation at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx">http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx</a>. The idea is that all mapping operations are configured and connected in the same way; so, once you've learnt the operations available, it becomes a straightforward case of using a combination of them to get the mapping job done. The mapping operation categories are listed in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p><strong>Category</strong></p>
</th><th style="text-align: left" valign="bottom">
<p><strong>Purpose</strong></p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>String operations</p>
</td><td style="text-align: left" valign="top">
<p>Manipulate<a id="id102" class="indexterm"/> node values<a id="id103" class="indexterm"/> as strings such as concatenation, trimming, and substring operations</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Loop operations</p>
</td><td style="text-align: left" valign="top">
<p>Operations<a id="id104" class="indexterm"/> to loop round <a id="id105" class="indexterm"/>repeating nodes in source</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Expressions</p>
</td><td style="text-align: left" valign="top">
<p>Arithmetic <a id="id106" class="indexterm"/>and logical expressions<a id="id107" class="indexterm"/> to perform calculations or decisions</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>List operations</p>
</td><td style="text-align: left" valign="top">
<p>Processing<a id="id108" class="indexterm"/> for lists of items<a id="id109" class="indexterm"/> that can be created from node content in a conditional way for further processing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Cumulative operations</p>
</td><td style="text-align: left" valign="top">
<p>Operations<a id="id110" class="indexterm"/> to accumulate <a id="id111" class="indexterm"/>values such as sums, counts, and averages</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Date and time operations</p>
</td><td style="text-align: left" valign="top">
<p>Manipulate date <a id="id112" class="indexterm"/>and time<a id="id113" class="indexterm"/> values</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Miscellaneous operations</p>
</td><td style="text-align: left" valign="top">
<p>Various operations for <a id="id114" class="indexterm"/>retrieving context properties, formatting numbers, and<a id="id115" class="indexterm"/> incorporating C# in your maps</p>
</td></tr></tbody></table></div><p>A very common type of transformation is flattening. This is where a number of repeating items (usually a list) needs to be consolidated (or flattened) into a single value, often with some calculation<a id="id116" class="indexterm"/> applied (for example, a summation). BizTalk Services provides several mapping operations to achieve this in a straightforward way.</p><p>Take a look at the following XML and you can see that the <code class="literal">&lt;Product&gt;</code> element repeats, that is, there can be more than one product specified. Let's say we want to calculate the sum of all the product prices (<code class="literal">Price</code>) multiplied by the quantity (<code class="literal">Qty</code>) ordered to work out the total value of the order:</p><div><pre class="programlisting">&lt;ns0:Order &gt;
  &lt;OrderId&gt;OrderId_0&lt;/OrderId&gt;
  &lt;PaymentType&gt;PaymentType_0&lt;/PaymentType&gt;
  &lt;OrderDate&gt;OrderDate_0&lt;/OrderDate&gt;
  &lt;Products&gt;
    &lt;Product&gt;
      &lt;Code&gt;Code_0&lt;/Code&gt;
      &lt;Qty&gt;Qty_0&lt;/Qty&gt;
      &lt;Price&gt;Price_0&lt;/Price&gt;
    &lt;/Product&gt;
    &lt;Product&gt;
      &lt;Code&gt;Code_0&lt;/Code&gt;
      &lt;Qty&gt;Qty_0&lt;/Qty&gt;
      &lt;Price&gt;Price_0&lt;/Price&gt;
    &lt;/Product&gt;
    &lt;Product&gt;
      &lt;Code&gt;Code_0&lt;/Code&gt;
      &lt;Qty&gt;Qty_0&lt;/Qty&gt;
      &lt;Price&gt;Price_0&lt;/Price&gt;
    &lt;/Product&gt;
  &lt;/Products&gt;
  &lt;Customer&gt;
    &lt;Name&gt;Name_0&lt;/Name&gt;
    &lt;Email&gt;Email_0&lt;/Email&gt;
    &lt;Phone&gt;Phone_0&lt;/Phone&gt;
  &lt;/Customer&gt;
  &lt;ShippingAddress&gt;
    &lt;Recipient&gt;Recipient_0&lt;/Recipient&gt;
    &lt;Number&gt;Number_0&lt;/Number&gt;
    &lt;Street&gt;Street_0&lt;/Street&gt;
    &lt;City&gt;City_0&lt;/City&gt;
    &lt;State&gt;State_0&lt;/State&gt;
    &lt;Country&gt;Country_0&lt;/Country&gt;
    &lt;Postcode&gt;Postcode_0&lt;/Postcode&gt;
  &lt;/ShippingAddress&gt;
&lt;/ns0:Order&gt;</pre></div><p>The final result, the total value of the order, then needs to be mapped to a single field in the target <a id="id117" class="indexterm"/>schema. We can use mapping operations to easily achieve this. The key to using mapping operations successfully is to break down the requirements and select the most appropriate mapping operations to achieve the goal. As my explanation has already hinted at, there are several parts to this problem. The first of these is to realize that we need to keep a running total of each of the <code class="literal">Qty * Price</code> field calculations—one for each <code class="literal">Product</code> element. Let's deal with that first.</p><p>BizTalk Services provides a set of list-based mapping operations that allow the creation of a temporary list to store items and manipulate the items in the list.</p><p>First drag a <strong>Create List</strong> mapping operation onto the design surface. Perhaps the first obvious change to a BizTalk Server developer is that mapping operations in BizTalk Services provide nesting. This is the key to simplifying complex tasks as this nesting behavior provides a natural way to group and organize the mapping task required.</p><p>The <strong>Create List</strong> operation will be used to hold the temporary results from our calculations. We will push each product's total to the list and then calculate the sum of these list item values later. Double-click on <strong>Create List</strong> to configure it. In the dialog, type a <strong>Member Name</strong>, say <code class="literal">total</code>, and select <strong>Number</strong> from the dropdown for the <strong>Member Type</strong>, as shown in the following screenshot. This is a variable that will be used to store the value of our calculations. Click on <strong>OK</strong> to close the dialog.</p><div><img src="img/7401EN_02_05.jpg" alt="Mapping operations"/><div><p>Configuring the Create List operation</p></div></div><p>The next step is to loop round all the <code class="literal">Product</code> elements. To do this, drag a <strong>ForEach</strong> mapping operation and drop it inside the <strong>Create List</strong> operation. Notice how we can place additional operations inside this operation too. This is where we'll put the calculation of each line item's total.</p><p>Now wire <a id="id118" class="indexterm"/>up the <code class="literal">Product</code> node in the left-hand schema to the <strong>ForEach</strong> operation. This tells the operation to loop round each <code class="literal">Product</code> node within <code class="literal">Products</code>.</p><p>Drag an <strong>Arithmetic Expression</strong> operation across to the designer and drop it in the <strong>ForEach</strong> operation. Now wire up the <code class="literal">Qty</code> and <code class="literal">Price</code> fields to this operation. These will be our input parameters; the nodes from the input message we want to use the data from. Taking each node in turn, drag a connection onto the <strong>Arithmetic Expression</strong> operation on the canvas. Now double-click on the new <strong>Arithmetic Expression</strong> to configure it. Here we can specify a calculation based on the fields that are connected to the operation, in this case <code class="literal">Qty</code> and <code class="literal">Price</code>. Enter the expression shown in the following screenshot:</p><div><img src="img/7401EN_02_06.jpg" alt="Mapping operations"/><div><p>Configuring the Arithmetic Expression operation</p></div></div><p>We now<a id="id119" class="indexterm"/> need to store this result; to do this, we'll add it to the outer list operation. Drag an <strong>Add Item to List</strong> operation and drop it to the right of the <strong>Arithmetic Expression</strong> operation, within the <strong>ForEach</strong> operation. Then, connect the <strong>Arithmetic Expression</strong> operation to the <strong>Add Item to List</strong> operation by dragging a line from one to the other. Double-click on the <strong>Add Item to List</strong> operation to configure it. The dialog should be pre-populated already, so we can just click on <strong>OK</strong> to save the settings. The map should now look as shown in the following screenshot:</p><div><img src="img/7401EN_02_07.jpg" alt="Mapping operations"/><div><p>Partially-completed map</p></div></div><p>OK, the first <a id="id120" class="indexterm"/>part of the task is done; we are calculating the total value for each product. We now need to add these totals together to obtain the grand total for the order. This is very straightforward. Drag a <strong>Select Entries</strong> mapping operation and drop it to the right of the <strong>Create List</strong> operation. Connect the <strong>Create List</strong> operation to <strong>Select Entries</strong>. Double-click on <strong>Select Entries</strong> to open it, check the <strong>Selected</strong> checkbox next to <code class="literal">total</code>, and click on <strong>OK</strong> as shown in the following screenshot. Here, we are specifying what variables we want to extract from the list we've created. As we only have one in this case, the choice is easy.</p><div><img src="img/7401EN_02_08.jpg" alt="Mapping operations"/><div><p>Configuration of the Select Entries operation</p></div></div><p>Finally, drag<a id="id121" class="indexterm"/> a <strong>Cumulative Sum</strong> operation and drop it to the right of the <strong>Select Entries</strong> operation. Connect the <strong>Select Entries</strong> operation to the <strong>Cumulative Sum</strong> operation. Now connect the <strong>Cumulative Sum</strong> operation to the <code class="literal">TotalValue</code> field in the target schema. Double-click on the <strong>Cumulative Sum</strong> operation you just added and enter <code class="literal">item.total</code> in the expression textbox, as shown in the following screenshot. Here, we are specifying our total variable from the list entries passed from the <strong>Select Entries</strong> operation:</p><div><img src="img/7401EN_02_09.jpg" alt="Mapping operations"/><div><p>Configuration of the Cumulative Sum operation</p></div></div><p>The<a id="id122" class="indexterm"/> completed map should look the same as the following screenshot:</p><div><img src="img/7401EN_02_10.jpg" alt="Mapping operations"/><div><p>Map with looping and calculated node</p></div></div><p>We're nearly <a id="id123" class="indexterm"/>there with our map. Let's tackle the <code class="literal">ShippingAddress</code> node. Notice that there are more fields on the left-hand side than the right. We're therefore going to consolidate these by concatenating some of them. There are a few ways to do this; we could use the <strong>String Concatenate</strong> mapping operation, for example, that can take any number of inputs and produce a concatenated single string as output.</p><p>However, let's look at something a little more interesting. When there isn't an operation that meets your need, you can turn to the <strong>CSharp Scripting</strong> operation. As its name implies, this operation allows you to include C# in its configuration, giving you the full power of the .NET framework to be able to implement whatever mapping functionality you need.</p><p>Drag a <strong>CSharp Scripting</strong> operation to the mapping design surface and drop it somewhere below the <strong>Create List</strong> operation. Connect the <code class="literal">Number</code>, <code class="literal">Street</code>, <code class="literal">City</code>, <code class="literal">State</code>, and <code class="literal">Country</code> nodes to it. As you've probably realized by now, this is the way operations can work on specific data items, and the same is true for the scripting operation. By connecting these items to it, they become available to the scripts we write. Double-click on the <strong>CSharp Scripting</strong> operation to open its configuration.</p><p>In the dialog, notice that there is a <strong>Script Text</strong> multiline textbox. Here, we can define a function in C# that will take the nodes as input parameters and return a value. In this simple case, you can see from the next screenshot that I am just concatenating the input parameters with some formatting and returning the result back to the map. Enter the following code to do the same:</p><div><pre class="programlisting">public string CreateAddress (string Number, string Street, string City, string State, string Country)
{
   return Number + " " +
          Street + "," +
          City + "," +
          State + "," +
          Country;
}</pre></div><p>Note that<a id="id124" class="indexterm"/> the names of the input nodes to the scripting operation must match the argument names in the code. If the names differ, the map won't compile. Once we've saved this by clicking on <strong>OK</strong>, we can connect the operation to the target schema's <code class="literal">Address</code> node.</p><p> </p><div><img src="img/7401EN_02_11.jpg" alt="Mapping operations"/><div><p>Using C# with mapping</p></div></div><p>There are only a few fields left to map now. Simply connect <code class="literal">Recipient</code> to <code class="literal">FullName</code> and <code class="literal">PostCode</code> to <code class="literal">Zip</code>. The final operation we'll look at to complete this map is the <strong>DateTime Reformat</strong> operation. Drag this onto the design surface above the <strong>Create List</strong> operation. Connect<a id="id125" class="indexterm"/> the <code class="literal">OrderDate</code> node from both schemas to this operation, then double-click on the <strong>DateTime Reformat</strong> operation to configure it. This operation is useful when dealing with date formatting requirements that differ between sender and receiver. The nice thing about this operation is that it doesn't only support a fixed set of date and time formats, but you can enter your own as well. For the <strong>Input Format</strong> field, enter <code class="literal">d/M/yyyy</code> in the <strong>Format</strong> field. Note that this is not one of the provided options in the dropdown, so you'll need to enter it in the textbox, as shown in the following screenshot. Also, make sure that the letter <code class="literal">M</code> is capitalized, as is shown. Then, select <strong>M/d/yyyy</strong> for the <strong>Output Format</strong> field. This will interpret the input date in day/month/year format, for example, <code class="literal">2/9/2013</code>, and change to month/day/year format for the output, for example, <code class="literal">9/2/2013</code>.</p><div><img src="img/7401EN_02_12.jpg" alt="Mapping operations"/><div><p>Formatting dates</p></div></div><p>The map is now complete. It should look similar to the following screenshot:</p><div><img src="img/7401EN_02_13.jpg" alt="Mapping operations"/><div><p>The completed map</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Testing</h1></div></div></div><p>Phew! This may seem quite complex, but it's really quite simple once you break it down. The next step is<a id="id126" class="indexterm"/> to test the map and see if it looks like it's producing the right results. Testing is built right into Visual Studio, so there's no need to compile and deploy the solution to Windows Azure in order to see if it works. This is important as creating anything other than trivial maps is a very iterative process. It's made easier by building up the functionality in the map gradually and examining the test results along the way. This way, any mistakes are much more obvious and easily corrected.</p><p>To test a map, we need some input. This is most easily generated in Visual Studio itself. Right-click on the <code class="literal">OrderFF.xsd</code> schema in the <strong>Solution Explorer</strong> window and select <strong>Generate Instance</strong>. Open the file that's created and edit the values to match the one shown in the<a id="id127" class="indexterm"/> following code (don't forget, you can just download the source for this example from the website):</p><div><pre class="programlisting">&lt;ns0:Order &gt;
  &lt;OrderId&gt;123&lt;/OrderId&gt;
  &lt;PaymentType&gt;ACCOUNT&lt;/PaymentType&gt;
  &lt;OrderDate&gt;2/9/2013&lt;/OrderDate&gt;
  &lt;Products&gt;
    &lt;Product&gt;
      &lt;Code&gt;AB12&lt;/Code&gt;
      &lt;Qty&gt;4&lt;/Qty&gt;
      &lt;Price&gt;1.50&lt;/Price&gt;
    &lt;/Product&gt;
    &lt;Product&gt;
      &lt;Code&gt;AC01&lt;/Code&gt;
      &lt;Qty&gt;2&lt;/Qty&gt;
      &lt;Price&gt;3.99&lt;/Price&gt;
    &lt;/Product&gt;
    &lt;Product&gt;
      &lt;Code&gt;DE4&lt;/Code&gt;
      &lt;Qty&gt;10&lt;/Qty&gt;
      &lt;Price&gt;12.25&lt;/Price&gt;
    &lt;/Product&gt;
  &lt;/Products&gt;
  &lt;Customer&gt;
    &lt;Name&gt;John Doe&lt;/Name&gt;
    &lt;Email&gt;john.doe@contoso.com&lt;/Email&gt;
    &lt;Phone&gt;425-123456&lt;/Phone&gt;
  &lt;/Customer&gt;
  &lt;ShippingAddress&gt;
    &lt;Recipient&gt;Jane Smith&lt;/Recipient&gt;
    &lt;Number&gt;1&lt;/Number&gt;
    &lt;Street&gt;East Street&lt;/Street&gt;
    &lt;City&gt;New York&lt;/City&gt;
    &lt;State&gt;New York&lt;/State&gt;
    &lt;Country&gt;USA&lt;/Country&gt;
    &lt;Postcode&gt;NY12345&lt;/Postcode&gt;
  &lt;/ShippingAddress&gt;
&lt;/ns0:Order&gt;</pre></div><p>The <strong>Generate Instance</strong> action creates an XML-format message by default—which is what you need for the map itself. However, this schema is a flat file schema, and if we want to generate a message to pass into the bridge, we need to generate a message in this format. In the schema properties, there is a property called <strong>Generate Instance Output Type</strong> that can be set to <strong>Native</strong> instead of <strong>XML</strong>. When <strong>Native</strong> is selected, the schema will create a test message according to its type, flat file or XML. The following screenshot shows the results of setting this to <strong>Native</strong> when compared with the <code class="literal">OrderFF.xsd</code> schema:</p><div><img src="img/7401EN_02_14.jpg" alt="Testing"/><div><p>Generate Instance: Native</p></div></div><p>Once we<a id="id128" class="indexterm"/> have a test message, we can assign it to the map to try it. Click on the <code class="literal">FFtoUS.trfm</code> map in the <strong>Solution Explorer</strong> window; in the <strong>Properties</strong> window, enter <a id="id129" class="indexterm"/>the path to the file in the <strong>Test Map Input File</strong> property. Now right-click on the map and select <strong>Test Map</strong>. With any luck, you should see something similar to the following snippet in the output window. This means that the map execution worked!</p><div><pre class="programlisting">Test Map succeeded.
Output is written to the file 'C:\Users\Jon\AppData\Local\Temp\tmp3817.xml'.</pre></div><p>Open the file from the <strong>File</strong> menu by navigating to <strong>Open</strong> | <strong>File</strong> and browsing to the to the file location in the preceding output (in this case: <code class="literal">C:\Users\Jon\AppData\Local\Temp\tmp3817.xml</code>). If you did everything right, it should look the same as the following XML code:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ns1:USOrder  &gt;
  &lt;OrderNumber&gt;123&lt;/OrderNumber&gt;
  &lt;OrderDate&gt;9/2/2013&lt;/OrderDate&gt;
  &lt;OrderValue&gt;136.48&lt;/OrderValue&gt;
  &lt;CustomerDetails FullName="John Doe" EmailAddress="john.doe@contoso.com" Telephone="425-123456"&gt;
  &lt;/CustomerDetails&gt;
  &lt;ShippingDetails FullName="Jane Smith" Address="1 East Street,New York,New York,USA" Zip="NY12345" /&gt;
&lt;/ns1:USOrder&gt;</pre></div><p>Notice how different this XML document is from the one you used as input and you can hopefully start to appreciate the power of the BizTalk Services mapper.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Configuring a bridge</h1></div></div></div><p>A map<a id="id130" class="indexterm"/> is no good on its own though. We need to be able to use it in an integration solution. It should hopefully come as no surprise that the way we do this is by configuring a bridge. The next screenshot shows part of the bridge configuration. This configuration represents the pipeline of processing that can be configured. There are multiple stages to this pipeline, as mentioned in <a class="link" href="ch01.html" title="Chapter 1. Hello BizTalk Services">Chapter 1</a>, <em>Hello BizTalk Services</em>. In the middle of the pipeline, there is a <strong>Transform</strong> stage; it is here that we can specify a map to execute.</p><div><img src="img/7401EN_02_15.jpg" alt="Configuring a bridge"/><div><p>Configuring a bridge with a map</p></div></div><p>Double-click on the <code class="literal">MessageFlowItinerary.bcs</code> file in the <strong>Solution Explorer</strong> window to open it. In the designer, open the <code class="literal">OrderProcessing</code> bridge configuration by double-clicking on it. Click on the <strong>Transform</strong> stage and look at the <strong>Properties</strong> window. Here, we can choose a map by clicking on the ellipsis (<strong>…</strong>) next to the <strong>Maps</strong> property to open<a id="id131" class="indexterm"/> up the configured maps. This will show us all the maps the solution contains.</p><p>We can select the map that we created earlier by checking the <strong>Selected</strong> checkbox next to it, as shown in the following screenshot. Clicking on <strong>OK</strong> will return to the bridge configuration, which should now show the selected map, <code class="literal">FFtoUS</code>, in the <strong>Transform</strong> stage.</p><div><img src="img/7401EN_02_16.jpg" alt="Configuring a bridge"/><div><p>Select map dialog</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Putting it all together</h1></div></div></div><p>The solution is now ready. Build and deploy as before, and once deployed, point your browser to <code class="literal">https://&lt;yourdeployment&gt;/default/OrderProcessingBridge</code> and you should see a 401 HTTP error code stating that a manage claim is required for this operation.</p><p>Now you will use two tools provided as a part of the BizTalk Services SDK. These are MessageSender and MessagerReceiver which you can download from the following links. These tools allow you to send messages to and receive messages from the bridge you created:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64">http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f">http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f</a></li></ul></div><p>Unzip both solutions and open the MessageReceiver sample in Visual Studio 2012 and build it. Run it from the command prompt by typing the following and pressing the <em>Enter</em> key<a id="id132" class="indexterm"/>.</p><div><pre class="programlisting">
<strong>&lt;path&gt;MessageReceiver.exe ServiceBusNS owner &lt;issuerkey&gt; USAddressRelay OneWayRelay</strong>
</pre></div><p>In the preceding command, <code class="literal">&lt;path&gt;</code> is the path to the exe from the build output of Visual Studio, <code class="literal">ServiceBusNS</code> is the namespace where the relay is running and <code class="literal">USAddressRelay</code> is the endpoint information configured in the bridge configuration. Note that you will also need to replace the <code class="literal">&lt;issuerkey&gt;</code> value with your own subscription details.</p><p>Now open the MessageSender sample (downloaded from the previous link) in Visual Studio 2012 and build it. Run it as shown in the following code to send a message to the bridge:</p><div><pre class="programlisting">
<strong>&lt;path&gt;MessageSender.exe BizTalkSvcACS owner issuerkey https://&lt;yourdeployment&gt;/default/OrderProcessingBridge instance.xml application/xml</strong>
</pre></div><p>In the preceding code, <code class="literal">BizTalkSvcACS</code> is the ACS namespace of the BizTalk Service deployment. As before, <code class="literal">owner</code> and <code class="literal">issuerkey</code> are the ACS credentials of that namespace, and <code class="literal">instance.xml</code> is the <code class="literal">OrderFF.xsd</code> instance in XML format.</p><p>Ensure<a id="id133" class="indexterm"/> that output is observed in the MessageReceiver sample of the relay. Examine the output message and notice how the map has transformed it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>More on mapping</h1></div></div></div><p>We've<a id="id134" class="indexterm"/> covered a lot of ground so far, but there is much more to mapping in BizTalk Services besides the other 27 operations we've not used here. There are two other groups of operations that deserve some discussion.</p><p>The<a id="id135" class="indexterm"/> first of these is the <strong>Get Context Property</strong> mapping operation. This provides an often-asked-for feature in BizTalk Server—the ability to retrieve properties from the message context and include them in a map. The way this works is by configuring it, specifying the property name to retrieve it, and then connecting it to a target node; no input nodes are required. We haven't covered context properties in detail yet, but for now, remember that they are a set of name/value pairs that hold contextual information about the current message flow; for example, the transport details (for example, a filename) of the message received, or even properties of the message itself that have been extracted. If you're wondering how you can test this from within Visual Studio as we did earlier, the team has thought of this too. A property, <strong>Context Property Test Data</strong>, is provided on the map and allows you to specify the test name/value properties to execute the map with. The dialog is shown in the following screenshot. The ability to use context properties in BizTalk Services maps is a very welcome addition. This dialog can also be shown when the map is tested to change the values used.</p><div><img src="img/7401EN_02_17.jpg" alt="More on mapping"/><div><p>Select map dialog</p></div></div><p>The second <a id="id136" class="indexterm"/>area of improvement is in expression operations. For example, an <strong>If-Then-Else</strong> <strong>Expression</strong> operation is provided. This greatly simplifies the common requirement of testing a condition; if it evaluates to true, one path is taken, otherwise another. In BizTalk Server, this was complex to achieve, requiring a lot of functoids. This highlights the effort that the product group has put in here to simplify common tasks, as I mentioned at the beginning of this chapter. The same goes for other logical operations such as the <strong>Logical</strong> <strong>Expression</strong>. Here, an expression can be provided that evaluates to true or false. Again, for those familiar with BizTalk Server, this operation replaces a large number of functoids with just one that is simple to configure and use.</p><p>One issue that was starting to become obvious, referring to the map in the earlier screenshot, is complexity. The mapper provides the concept of pages to allow the splitting up of operations and links on different pages. You can add a new page by right-clicking on the area next to the tab at the bottom of the designer, as shown in the following screenshot:</p><div><img src="img/7401EN_02_18.jpg" alt="More on mapping"/><div><p>Working with pages</p></div></div><p>Splitting the map<a id="id137" class="indexterm"/> up into different pages is a trade-off between readability and complexity. Ideally, you would see as much detail as is clearly readable in a single page to avoid having to jump between different pages all the time. With complex maps that perhaps have thousands of links and operations, this isn't possible; adding pages can greatly reduce complexity and improve clarity, especially for those left to maintain the solution.</p><p>One final point is that, as you may have already noticed, the new BizTalk Services mapper is not based on the Extensible Stylesheet Language and XSLT (as the BizTalk Server one was). However, it is still possible to include XSLT (1.0 only) in a map, which is useful when you have an existing transformation in XSLT that you wish to reuse. The XSLT property is accessed by clicking on the designer grid and opening the <strong>XSLT</strong> property in the <strong>Properties</strong> window. On the subject of reuse, another useful tool provided with BizTalk Services is the BizTalk Server map converter. This will convert a BizTalk Server <code class="literal">.btm</code> map file to the BizTalk Services mapping format, saving time when you have existing maps that you wish to reuse and avoiding the need to start from scratch. Because of the differences in functionality between the two, it cannot perform a 100 percent conversion, but is a great time-saver nevertheless.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Dealing with failure</h1></div></div></div><p>One<a id="id138" class="indexterm"/> very important point a developer must consider is how to deal with failures that occur. In integration solutions, failure is particularly important as it can be hard to isolate and diagnose. On a map, it is possible to configure what action to take should a particular operation fail, usually due to bad data provided to it. The <strong>Settings</strong> button<a id="id139" class="indexterm"/> at the top of the designer displays the dialog, as shown in the following screenshot, when clicked.</p><p>Here, each operation (or group of operations in some cases) can be set to either <strong>Fail Map</strong> on an error occurrence or continue and output a null value. This is very useful; we'll look at error handling in much more detail in a later chapter.</p><div><img src="img/7401EN_02_19.jpg" alt="Dealing with failure"/><div><p>Setting runtime properties</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we have looked at the mapping features of BizTalk Services. You've seen how to create maps, use many of the powerful operations provided, and test them. While we haven't been able to cover every operation, many are self-explanatory and easy to understand; after all, the whole point of the mapper is to make the job of format and content conversion easier. We urge you to experiment on your own and see what you can come up with.</p><p>In the next chapter, we'll look at the different types of bridges BizTalk Services provides, starting with EDI.</p></div></body></html>