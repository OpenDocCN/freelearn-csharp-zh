# DNS和资源定位

上一章花费了大量时间剖析网络，以至于大多数读者可能永远不会再次考虑它们。在本章中，我们将探讨这些概念，并查看它们的实际应用。我们将从查看互联网规模上解决资源分配问题开始。如果没有能力从您的网络中访问资源，分配资源是没有用的，本章将向您介绍使这成为可能的技术系统和标准。在我们调查这些主题时，我们最终将动手编写一些代码。在本章中，我们将查看软件示例，让您熟悉利用.NET Core框架中可用的工具。

本章将涵盖以下主题：

+   如何在从您的家庭Wi-Fi网络到互联网的任何设备上公开和提供数据和服务

+   用于识别您网络不同级别的资源的特定标准，从URL和域名到设备名称和本地目录访问

+   使用.NET Core中的DNS类访问外部资源并解决网络内数据请求

# 技术要求

要跟随本章内容，您需要拥有Visual Studio Code或Visual Studio Community Edition。这两个都是可以在Visual Studio网站上免费下载的，网址为[https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)。

观看以下视频，了解代码的实际应用：[http://bit.ly/2HVSHad](http://bit.ly/2HVSHad)

我们还将使用.NET Core **命令行界面**（**CLI**）。这将使我们能够直接从命令提示符调用一系列程序。为了跟上进度，您需要确保您已经在本地上安装了.NET Core SDK，可以从[https://www.microsoft.com/net/download](https://www.microsoft.com/net/download)下载。

源代码可在[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core)找到。

# 海量信息中的针——互联网上的数据

使用网络上公开的资源的第一步是找到它们。虽然这个问题在只有四台计算机的局域网中很容易解决，但您可以想象当您的环境扩展到数十亿个活跃连接到互联网的设备时，这会变成多么艰巨的挑战。为了确保网络广播请求的可靠交付，网络上的每个设备都必须有唯一的地址，并且任何想要与设备通信的软件都必须知道目标设备的地址。考虑到这一点，让我们看看在规模上是如何解决这个问题，并考虑我们如何可以将这种解决方案应用到我们更相关的本地用例中，使用.NET Core。

# 第一网络地址

正如我提到的，网络上的每个设备都必须具有唯一的可识别性，这样在任何给定时间，针对特定设备的请求都可以被送达。同样，唯一的地址意味着任何响应都可以可靠地返回到原始设备，无论两个设备之间有多少网络节点。如果有人编写了一个解决你问题的服务，只有当你实际上可以使用该服务时，它对你才有用。这意味着要么知道托管该服务的设备的地址，要么至少知道如何询问地址。

幸运的是，这个问题在互联网的最早形态出现之前就已经得到了解决。我当然是指电信网络，以及它们为地址和地址查找建立的成熟系统。在早期的电信网络中，工程师需要为需要唯一标识的大量设备解决问题。然而，无论他们提出什么系统，都必须展现出以下特性，才能在长期内保持其可行性：

+   可用性：该系统将由任何想要通过电信网络进行通信的人使用，因此该系统不能过于复杂。

+   可扩展性：最终目标是连接全国每个家庭，使用一个单一、统一的网络。向该网络添加节点的解决方案需要随着人口和地理区域的扩大而增长。

+   性能：如果电话通话需要像邮政服务一样长时间来回传递信息，没有人会使用它。虽然这种情况永远不会发生，但客户在速度和可靠性方面所能容忍的极限肯定存在。

幸运的是，他们提出的解决方案是一个可持续的解决方案，它已经扩展并运行了几十年。

电信工程师设计的系统是电话号码系统。通过为电信网络上的每一部电话分配10位地址，工程师确保了一个能够唯一标识高达9,999,999,999个设备的网络。再加上两位数的国家代码，理论上这个网络可以支持高达万亿个设备，或者为地球上每个人提供超过100个独特的地址，还有大约240亿个地址是多余的。

你可能已经注意到，我指出电话号码系统在理论上只支持高达万亿个设备。然而，电信寻址系统的一些局限性使得达到理论上的最大值变得困难。正如你们大多数人所意识到的，美国电话号码的前三位数字被称为**区号**。这些数字最初是由电话所在的特定地理位置决定的。这有助于快速路由号码，但也意味着电信网络能够支持的设备总数受到这些设备在地理区域分布的限制。在一个区号内，理论上最多只能有9,999,999个可能的设备；这几乎超过了纽约市总人口。

我在这里过于简化了解决方案，但这个权衡为电信工程师提供了一个简单机制，以便尽可能快地将物理电话的可能范围缩小到地址所解析的地址。通过仅检查前三位数字，就可以将电话路由到一个实质上受限的区域。这通过将语义意义应用于句法标准提供了明显的性能优势。电话号码系统简单地指定一个物理电话通过10位地址进行寻址。这是一个句法要求。然而，该地址前三位数字所传达的地理信息是一个语义标准。这些前三位数字中蕴含着一种基本含义，它传达了整个地址应该如何处理。

这个数字寻址系统的可扩展性有助于网络设备准确引导流量。然而，对于人类用户来说，一串任意排列的七到十个数字可能难以记忆，且使用时容易出错。那些在智能手机和内置联系人列表出现之前成长起来的人可能还记得，需要有一个罗罗德克斯（Rolodex）或联系簿来组织并随时备好那些经常需要但难以记忆的电话号码。然而，通常情况下，你需要拨打一个你不方便存储的电话号码。这时电话簿就派上用场了。它提供了一种简单的方法，将易于记忆的唯一标识符（特别是全名和街道地址）映射到对应的网络友好地址（他们的电话号码）。

所有这些特性综合起来，为电信行业提供了成功网络实施的标志：易用性（通过电话簿的简单性）、可扩展性（通过广泛的合法地址范围）和性能（通过将语义意义嵌入地址的语法标准中实现的改进路由速度）。然而，到现在，你可能已经正确地猜到了，我们不会用C#为电话网络编程。那么，让我们看看电信工程师做出的设计决策是如何转化为现代计算机网络的。

# DNS – 现代的电话簿

正如我暗示的那样，设计现代计算机网络工程师面临的问题与电信工程师相同：定义一个标准化的语法，以便他们可以为网络上的每一台设备创建唯一的地址。幸运的是，尽管如此，那些计算机网络工程师可以站在巨人的肩膀上（用艾萨克·牛顿爵士的话来说）。

电话号码系统表明，一个简单的固定长度数字地址系统可以快速解析和路由。此外，纯数字地址可以用二进制表示。这意味着不需要额外的标准来一致地表示非数字字符。然而，这在易用性上是一个权衡。用于使用这些地址的软件仍然需要由人类编写。正如经常发生的那样，对计算机来说更容易（且性能更好）的解决方案，对人类来说却更困难。这意味着计算机网络工程师需要设计自己的电话簿。幸运的是，他们做到了。

在所有现代计算网络上，你可以通过可靠的固定长度数字地址来定位外部设备，那就是**互联网协议（IP）地址**。同时，你可以从可靠的系统中获取特定设备的地址，那就是**域名系统（DNS）**。这个DNS，就是计算机网络中的电话簿。它本质上是一个复杂的、分布式的映射，将可读的域名映射到其底层的IP地址。

互联网上的每一台设备（或任何本地网络）都将拥有自己的IP地址。然而，关于如何确定该IP地址的具体细节，以及这些地址语法的优势和局限性，将在本书的后续章节中进行讨论。目前，我们关注的是这些地址如何通过更有意义、易于阅读的域名来解析。在接下来的这一节中，我们将全面探讨每次通过URL查找资源时这一过程是如何发生的。

# 网址、域名和设备地址

在对网络中资源定位必须解决的主要问题有了一个坚实的理解之后，让我们更详细地看看这些问题是如何被解决的。首先，让我们考虑一下，为什么相对较少出错的URL命名约定使得访问远程资源更加容易。然后我们将探讨DNS如何成为URL或域名可用性和IP地址速度及可靠性之间的桥梁。

# URLs – 用户友好的寻址

我到目前为止一直采用一个非常基本的解释方法来解释定位资源的本质。我当然知道，你们中的大多数人可能至少对在至少一个高级环境中它是如何发生的有一些了解。实际上，你们很可能使用了一个网络浏览器来找到这本书，并且对浏览器地址栏中串联在一起的看似随机的单词和字母实际上是URL的事实有一个相当清晰的认识。然而，我确实遇到了一些开发者，他们对URL的构建和使用方式感到惊讶。所以，就像我们到目前为止所做的那样，我们将从对URL究竟是什么以及我们如何使用它们来找到我们所需的东西进行一个非常基本的解释开始。

**统一资源定位符**（**URL**）是一个普遍认可的标准，用于（不出所料）在网络上定位资源。它通过指定检索资源的方式以及检索它的具体路径来实现这一点。它通过指定定义任何资源特定物理位置的特定组件的顺序和分隔符来实现这一点。这个规范一开始可能看起来很复杂，但随着我们对组件及其所承担的责任进行详细阐述，它将变得更加直观。

# URL组件

每个URL都以一个方案开始，该方案指定了定位资源时应使用的传输机制或位置类型。你可以指定一系列普遍有效的方案，包括http、ftp，甚至对于本地托管资源，还有file。方案后面总是跟着一个冒号（`:`）分隔符。在方案指定之后，一个URL可以包含一个可选的权限指定，它本身包含一小部分子组件。

# 权限组件

权限有一个指定的前缀：两个连续的斜杠（`//`）特殊分隔符，其存在表示随后应按照URL权限的规范进行解析。这个前缀后面可以跟访问凭证或用户信息，它将可选的用户ID和/或密码传输到目标主机。如果包含这些值，它们将始终用冒号（`:`）作为分隔符彼此分开，并用一个at符号（`@`）分隔符与权限组件的其余部分分开。

无论访问凭证是否作为权威机构的一部分，它都将始终包含主机域名。这始终跟随双正斜杠（`//`）前缀，或者在存在访问凭证的情况下，跟随（`@`）分隔符。主机域名指定了托管资源的硬件的物理地址。它可以指定为注册的域名，或者硬件的底层IP地址。

最后，权威机构可能会指定主机上的监听端口。这由冒号（`:`）字符与主机域名或IP地址分隔，并指示硬件上请求指定资源的唯一端口。

# 路径组件

路径组件指定了一系列路径段，请求必须通过这些路径段到达要搜索的资源。路径的每个段都由一个正斜杠（`/`）字符单独分隔。在技术上，可以将空段作为路径的一部分，从而产生两个连续的正斜杠字符（`//`）。

# 查询组件

在路径的最后一个部分之后，URL可能包含一个可选的查询组件，由问号字符（`?`）分隔符表示。查询组件允许用户为请求的资源指定额外的参数，以获得更具体的结果。每个不同的查询都采用参数的形式，由等号（`=`）分隔符，以及查询参数的请求值。最后，每个参数由分号（`;`）或和号（`&`）分隔符与任何两个查询参数及其值之间的分隔符。

# 片段组件

URL的最后一部分，至少通常情况下，是片段组件。它是一个可选的URL字符串部分，其存在由保留的井号或哈希（`#`）前缀表示。片段组件通常用于标识最终返回的资源的一个子组件，并且通常由网络浏览器用于导航到搜索的HTML文档的特定片段。

# 将所有这些放在一起

明确列举了URL的所有相关组件后，我们可以通过基本的语法规范来简化问题。每个URL最终都可以分解为以下结构，其中可选组件用方括号`[]`表示：

[PRE0]

因此，在这里，我们可以清楚地看到，URL的唯一必需组件是方案和随后的冒号分隔符，以及路径。其他所有内容都是可选的，并且你会注意到每个可选组件在URL中的存在都由其独特的分隔符字符表示。当然，我们还可以扩展以下组件。

# 权威指定

正如我们之前指定的，权威机构可以分解如下：

[PRE1]

因此，如果存在权威组件，它将始终以双斜杠（`//`）分隔符为前缀，并且始终包含主机域名。同时，访问凭证组件也被分解如下：

[PRE2]

在这里，只需要一个组件。然而，如果任一组件存在，那么分隔访问凭证和主机域的`(@)`字符就成为一个必需项。而且，如果`user_id`和`password`功能都存在，那么两个组件之间的冒号(`:`)分隔符也将是必需的。

# 查询规范

最后，对于查询组件，有一个明确的规范说明其如何组成。它可以分解如下：

[PRE3]

附加分隔符和键值对的序列可以一直延伸到有效URL的最大允许长度。

通过遵循这些语法规范，你可以将你遇到的任何URL分解为其组成部分，并有效地利用它来访问它所标识的资源。

# URL作为URI的子类型

我们在本节的大部分内容中专门讨论了URL。然而，你可能没有意识到的是，URL实际上是一种称为**统一资源标识符**（**URI**）的单个、特定类型的对象，它是一系列遵循良好定义语法的字符，可以在网络上唯一地标识资源。

URL和URI之间的区别是微妙的，几乎完全是概念性的。最简单的方式来描述这种区别是，通过使用URL，我们保证能够识别和定位请求的资源。给定一个简单的URI，我们保证的唯一能力是识别它，即区分该资源与任何其他任意资源。

实际上，URL和URI这两个术语经常被互换使用。这是因为，由于URL是URI的一种特定类型，因此将其描述为URI总是有效的。同时，通常将URI描述为URL就足够了，因为在网络环境中知道资源的特定标识通常足以定位该资源。

如果你想知道我为什么要提及这样一个看似微不足道的话题，那是为了清晰起见。在本书的整个过程中，我将会一致地谈论资源是通过其URL来标识的。然而，.NET Core暴露的用于构建、分解和利用这些地址的类是以更通用的URI规范命名的。事实上，让我们现在快速看一下这个类。

# `System.Net.UriBuilder`类

如果你已经完整地阅读了关于URL规范的定义，你可能想知道如何在实际代码中利用这些知识来访问资源，尤其是当你已经知道具体位置时。亲爱的读者们，请允许我介绍`UriBuilder`类！

在`System.Net`命名空间中，`UriBuilder`类是一个用于生成`Uri`类实例的工厂类。它为用户提供几个重载的构造函数，允许逐步指定更多有效URL的组件。它还提供了访问器，用于表示每个组件的属性。最后，它提供了一个函数，可以从组件部分生成格式良好的`Uri`类实例。

让我们从一个非常简单的例子开始。我们将使用`UriBuilder`来组合一个只包含`Scheme`和`Host`组件的`Uri`实例，如下所示：

[PRE4]

使用这种方法，我们可以看到`UriBuilder`类如何将我们指定的组件部分组合成一个格式良好且语法正确的`Uri`，如下面的代码片段所示：

[PRE5]

通过运行此程序，当您的控制台开启十秒钟后，您应该看到`http://packt.com`输出，然后程序关闭并终止。

在这里，我们不需要指定URL的`http`组件后面应该跟一个冒号字符。我们没有提到我们指定的主机前面应该有`//`前缀字符。`UriBuilder`类为我们做了这件事。这个工厂类为我们提供了一个干净的方式来逐步构建一个更具体的期望位置，而无需我们作为开发者，总是要在脑海中记住分隔符、前缀和后缀的琐碎细节。

在这个例子中，我们利用了`UriBuilder`类提供了对所有属性的公共`get`访问权限的事实，以便封装`Uri`的每个组件。然而，如果您在构造时知道它们的值，您也可以通过一系列重载的构造函数应用许多这些属性。

`UriBuilder`类有七个重载的构造函数。我们已经看到了默认构造函数，它不接受任何参数，但现在让我们看看一个利用每个构造函数的程序，并看看它们提供了什么。鉴于我们知道我们打算查找的传输方案和域名，我们可以简化我们的初始方法，如下所示：

[PRE6]

通过这个更改，我们的`TestUriProgram`的输出将打印出我们之前看到的相同字符串，但生成该输出的代码大小只有原来的三分之一。在可能的情况下，我建议使用构造函数重载来实例化`UriBuilder`类。这样做可以缩小我们的代码体积，并在实例化类时使我们的意图更加明确。在可能的情况下，始终使您的代码更加明确。

# 主机 - 域名和IP

在我对URL的主机部分的描述中，我指定了主机域名可以是域名或IP地址。正如我之前提到的，IP地址是路由硬件和软件用于在网络中导航到资源的基础数字地址。它是特定位置上特定硬件的唯一ID。然而，域名是由人类可读的单词和字母数字字符组成的字符串，用于使寻址更加容易和一致。它比原始IP地址更一致、更容易记忆且更不容易出错。然而，有趣的是，域名及其IP地址在功能上是可互换的。在任何可以使用一个的地方，你都可以安全地替换另一个。

由于IP地址可以直接由网络传输层解析，并且在使用过程中不需要在节点之前进行解析，所以我们现在暂时忽略它们。我们将在本书的后面部分探讨使用设备IP地址的语法、限制和优势。然而，目前我们更关注的是如何首先找到IP地址。这就是为什么，至少在本章中，我们只关注域名以及它们是如何通过DNS进行解析的。

我敢打赌，在阅读这本书的所有人中，没有一个人认识一个没有在浏览器地址栏中输入[google.com](http://google.com)或[en.wikipedia.org](https://en.wikipedia.org/wiki/Main_Page)的人。我们使用域名的普遍性是毋庸置疑的，然而，我们中的大多数人并不知道它们是如何创建或使用的。即使对我来说，直到我被明确要求编写用于解析内部网络上域名的软件时，我才终于花时间理解是什么让这个系统工作。那时，我了解到DNS服务器网络如何促进人类用户的网络使用。虽然我之前已经提到过，现在是时候更深入地考虑DNS是什么，以及我们如何使用它了。

DNS是一个分布式的、去中心化的权威服务器网络，它托管着所有子域名服务器以及可以被该权威服务器解析的任何域名。任何已经注册到认证域名注册商的域名，并且符合域名语法标准（且尚未被注册），都被认为是有效的。有效的域名被添加到由权威服务器托管的分布式注册表中。在您的计算机和您希望使用有效注册域名与之交互的任何其他网络节点之间，您的请求将必须与这些名称服务器中的一个或多个进行交互。

每个服务器将检查提供的域名，并在其自己的域名和IP地址映射目录中查找该域名。自然地，服务器将首先确定该服务器是否能够解析该域名，或者至少通过其下属服务器之一进行解析。如果是这样，权威服务器只需将请求中的域名替换为它所映射的IP地址，并相应地转发请求。然而，如果当前服务器无法解析域名，它将沿着名称服务器层次结构向上转发，直到根名称服务器，或者直到域名被解析。

# C#中的DNS

有时，在软件的上下文中识别域名的基础IP地址是必要的。为此，.NET Core提供了`System.Net`命名空间中的静态`Dns`类。使用`Dns`类，我们可以访问由能够解析给定名称的最近下游名称服务器返回的目录信息。我们可以请求`IPHostEntry`类的实例，其中包含DNS条目的所有相关目录信息，或者简单地请求一个IP地址数组，这些IP地址已注册以解析针对域名的请求。

要查看此操作的实际效果，只需在示例程序中调用静态`Dns`类公开的任何方法，如下所示：

[PRE7]

使用此程序，我们应该看到以下输出：

[PRE8]

当然，当您查找解析`google.com`域名的主机条目时，解析出的IP地址可能会有所不同。谷歌的服务器分布广泛，距离您的网络位置最近的特定服务器切片（及其关联的IP地址）将解析该域名的查找。

如果您想验证返回的IP地址确实是该域名的注册地址，您实际上可以通过修改计算机的hosts文件在本地拦截主机条目查找。在Windows操作系统上，该文件位于`C:\Windows\System32\drivers\etc\hosts`目录，并且没有文件扩展名。在macOS和*nix系统上，它简单地位于`\etc\hosts`。

此文件是针对由主机名地址的网络资源的任何出站请求的第一个停止点。技术上讲，它是您计算机的内部名称服务器，您可以使用它以任何您想要的方式引导流量。为了演示这一点，按照以下方式向您的hosts文件添加条目：

[PRE9]

现在，打开您的命令提示符，导航到一个空文件夹，并使用以下CLI命令启动一个新的.NET Core Web API项目：

[PRE10]

您的控制台应打印有关.NET Core、遥测、ASP.NET Core的信息，最后，以以下行结束执行：

[PRE11]

假设这成功了，您可以直接从创建项目的同一目录中执行以下命令来运行应用程序：

[PRE12]

之后，您应该看到应用程序正在运行并监听，如下面的截图所示：

![图片](img/07246658-3674-4d45-96bf-e0e89da8e0af.png)

注意应用程序监听的具体端口。

如果我们查看空白Web API应用程序内部，我们可以看到.NET Core启动了一个名为`ValuesController`的单个控制器，并且它公开了多个REST端点。我们现在所关心的只是API指定的路由和监听HTTP GET请求的端点，如下所示：

[PRE13]

这告诉我们，如果我们导航到本地机器监听端口上的`/api/values/{id}`路径，我们应该期望看到`"value"`结果。

确实如此，如果你打开你选择的浏览器并在地址栏中输入应用程序的URL，附加控制器中指定的路径，你应该能在浏览器中看到显示的值字符串，如下面的截图所示：

![图片](img/a1aebff3-3c6a-4132-b7d4-76aed2098e0d.png)

然而，有趣的是，localhost本身是`127.0.0.1` IP地址的一个别名。按照惯例，该地址始终解析为当前本地机器。然而，由于我们修改了hosts文件，因此我们应该能够将URL中的`localhost`替换为新的域名`fun.with.dns.com`。在浏览器中进行更改，你将看到相同的响应！

现在我们已经看到了如何在本地设置自己的域名条目，我们可以使用我们的hosts文件来更详细地探索`Dns`类，并验证响应。

首先，在hosts文件中添加一个具有新IP地址的新条目，但与之前相同的假域名。你的新hosts文件应如下所示：

[PRE14]

在这里，地址本身并不重要，因为我们不会在那些位置查找资源。重要的是有两个地址。有了这些条目，你可以更具体地看到.NET中的`Dns`类如何从最近的域名服务器中公开一个可以解析的主机条目。我们可以修改之前的程序如下：

[PRE15]

我们现在可以看到以下输出：

[PRE16]

这演示了我们可以如何使用`Dns`类访问给定域名或IP地址的主机信息。请注意，`Dns`类的方法返回的`HostEntry`类实例总是包含在命名服务器中记录的所有IP地址。即使我们通过特定的IP地址查找`HostEntry`类，`Dns`类仍然解析并返回与原始查找IP地址匹配的域名注册的所有其他IP地址。这提供了灵活性，可以在注册的地址之一无响应的情况下，能够访问和使用替代硬件资源。你将在工作中利用这个类到什么程度可能会有所不同，但我希望你现在能看到它可以是一个有用的工具，可以放在你的工具箱里。

# 摘要

在本章中，我们探讨了网络工程师识别为使网络可行的必要的主要特征。我们在定义网络寻址的标准语法时，考虑了路由硬件的可用性与人类可读性之间的权衡。考虑到这一点，我们研究了前一代电信工程师的工作如何极大地贡献于今天所有现代网络最终标准化的解决方案。

在这个背景下，我们研究了网络硬件如何使用IP地址定位资源，以及DNS如何促进URL和URI更易记、更易读的寻址方案。我们通过实现自己的域名服务器，使用操作系统的hosts文件，学习了那些域名名是如何明确映射到其底层IP地址的。使用我们自包含的DNS服务器沙盒，我们探索了System.Net命名空间提供的C#类，以促进构建语法正确的URL，并利用DNS查找给定URL的底层IP地址，或解析相同的请求。

在这个基础上，我们将使用下一章来探索允许数据从一个主机传输到另一个主机的通信协议。我们将研究标准化模型如何促进实体之间的通信，并仔细研究在那种通信中最常用的协议。 

# 问题

1.  网络工程师寻求实现网络寻址标准长期可行性的三个特征是什么？

1.  电信工程师是如何牺牲电信网络可能的最大规模以实现更高的路由性能的？

1.  现代互联网的电话号码和电话簿是什么？

1.  URL是如何在网络上定位资源的？

1.  URL的有效组成部分有哪些？其中哪些是可选的？

1.  什么是完全合格域名？

1.  设备是如何获得域名名的？

# 进一步阅读

关于URL、域名和网络上的资源定位的更多信息，请考虑阅读*马克·E·杰夫托维奇的《管理关键任务域名和DNS》*。它提供了对与DNS合作的更深入和更周到的分析，以及利用该系统在构建自己的网络时获得优势的策略。
