["```cs\nstatic void UseLowLevelAPI()\n{\n    WSAData wsaData;\n    if (WSAStartup(0x0202, out wsaData) != 0)\n    {\n        Console.WriteLine(\"WSAStartup failed\");\n        return;\n    }\n    IntPtr sock = socket(2 /* AF_INET */, 1 /* SOCK_STREAM */, 0);\n    if (sock == new IntPtr(-1))\n    {\n        Console.WriteLine(\"socket() failed\");\n        WSACleanup();\n        return;\n    }\n    sockaddr_in sin = new sockaddr_in();\n    sin.sin_family = 2; // AF_INET\n    sin.sin_port =(ushort)IPAddress.HostToNetworkOrder((short)8000);     // Port 8000\n    sin.sin_addr = BitConverter.ToUInt32(IPAddress.Parse(\"127.0.0.1\")    .GetAddressBytes(), 0);\n    if (connect(sock, ref sin, Marshal.SizeOf(typeof(        sockaddr_in))) != 0)\n    {\n        Console.WriteLine(\"connect() failed\");\n        closesocket(sock);\n        WSACleanup();\n        return;\n    }\n    byte[] data = Encoding.ASCII.GetBytes(\"Hello, server!\");\n    if (send(sock, data, data.Length, 0) == -1)\n    {\n        Console.WriteLine(\"send() failed\");\n    }\n    closesocket(sock);\n    WSACleanup();\n}\n```", "```cs\nstatic void UseHighLevelAPI()\n{\n    try\n    {\n        // Connect to server at 127.0.0.1:8000\n        using (TcpClient client = new TcpClient(\"127.0.0.1\", 8000))\n        using (NetworkStream stream = client.GetStream())\n        {\n            // Prepare the message\n            byte[] data = Encoding.ASCII.GetBytes(\"Hello, server!\");\n            // Send the message\n            stream.Write(data, 0, data.Length);\n            Console.WriteLine(\"Sent: Hello, server!\");\n        }\n    }\n    catch (SocketException e)\n    {\n        Console.WriteLine($\"SocketException: {e}\");\n    }\n    catch (IOException e)\n    {\n        Console.WriteLine($\"IOException: {e}\");\n    }\n    catch (Exception e)\n    {\n        Console.WriteLine($\"Exception: {e}\");\n    }\n}\n```", "```cs\nConsole.WriteLine(\"Hello, System Programmers!\");\n```", "```cs\n.method private hidebysig static void  '<Main>$'(string[] args) cil managed\n{\n  .entrypoint\n  // Code size       12 (0xc)\n  .maxstack  8\n  IL_0000:  ldstr      \"Hello, System Programmers!\"\n  IL_0005:  call       void\n  [System.Console]System.Console::WriteLine(string)\n  IL_000a:  nop\n  IL_000b:  ret\n} // end of method Program::'<Main>$'\n```", "```cs\n00007FF9558C06B0  push        rbp\n00007FF9558C06B1  push        rdi\n00007FF9558C06B2  push        rsi\n00007FF9558C06B3  sub         rsp,20h\n00007FF9558C06B7  mov         rbp,rsp\n00007FF9558C06BA  mov         qword ptr [rbp+40h],rcx\n00007FF9558C06BE  cmp         dword ptr [7FF95597CFA8h],0\n00007FF9558C06C5  je\nProgram.<Main>$(System.String[])+01Ch (07FF9558C06CCh)\n00007FF9558C06C7  call        00007FF9B54D7A10\n00007FF9558C06CC  mov         rcx,1A871002068h\n00007FF9558C06D6  mov         rcx,qword ptr [rcx]\n00007FF9558C06D9  call        qword ptr\n[CLRStub[MethodDescPrestub]@00007FF9559C17E0\n(07FF9559C17E0h)]\n00007FF9558C06DF  nop\n00007FF9558C06E0  nop\n00007FF9558C06E1  lea         rsp,[rbp+20h]\n00007FF9558C06E5  pop         rsi\n00007FF9558C06E6  pop         rdi\n00007FF9558C06E7  pop         rbp\n```", "```cs\n01: using System.Runtime.InteropServices;\n02:\n03: [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError =         true)]\n04: static extern bool WriteConsole(\n05:     IntPtr hConsoleOutput,\n06:     string lpBuffer,\n07:     uint nNumberOfCharsToWrite,\n08:     out uint lpNumberOfCharsWritten,\n09:     IntPtr lpReserved);\n10:\n11: [DllImport(\"kernel32.dll\", SetLastError = true)]\n12: static extern IntPtr GetStdHandle(int nStdHandle);\n13:\n14: const int STD_OUTPUT_HANDLE = -11;\n15:\n16: IntPtr stdHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n17: if (stdHandle == IntPtr.Zero)\n18: {\n19:     Console.WriteLine(\"Could not retrieve standard output           handle.\");\n20:     return;\n21: }\n22:\n23: string output = \"Hello, System Programmers!\";\n24: uint charsWritten;\n25:\n26: if (!WriteConsole(\n27:     stdHandle,\n28:     output,\n29:     (uint)output.Length,\n30:     out charsWritten,\n31:     IntPtr.Zero))\n32: {\n33:     Console.WriteLine(\"Failed to write using Win32 API.\");\n34: }\n```", "```cs\nBOOL WINAPI WriteConsole(\n  _In_             HANDLE  hConsoleOutput,\n  _In_       const VOID    *lpBuffer,\n  _In_             DWORD   nNumberOfCharsToWrite,\n  _Out_opt_        LPDWORD lpNumberOfCharsWritten,\n  _Reserved_       LPVOID  lpReserved\n);\n```", "```cs\n[DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n```", "```cs\nstatic extern bool WriteConsole(\n    IntPtr hConsoleOutput,\n    string lpBuffer,\n    uint nNumberOfCharsToWrite,\n    out uint lpNumberOfCharsWritten,\n    IntPtr lpReserved);\n```", "```cs\n[DllImport(\"kernel32.dll\", SetLastError = true)]\nstatic extern IntPtr GetStdHandle(int nStdHandle);\n```", "```cs\nif (!WriteConsole(\n    stdHandle,\n    output,\n    (uint)output.Length,\n    out charsWritten,\n    IntPtr.Zero))\n{\n    Console.WriteLine(\"Failed to write using Win32 API.\");\n}\n```", "```cs\n[DllImport(\"kernel32.dll\")]\nstatic extern uint GetLastError();\n```", "```cs\nif(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))\n{\n    var lastError = Marshal.GetLastWin32Error();\n    Console.WriteLine($ something went wrong. Error code:\n        {lastError}\");\n}\n```", "```cs\nif(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))\n{\n    var lastError = Marshal.GetLastWin32Error();\n    var errorMessage = Marshal.GetPInvokeErrorMessage(lastError);\n    Console.WriteLine($\"Something went wrong. Error message:         {errorMessage}\");\n}\n```", "```cs\ntry\n{\n    if(!WriteConsole(stdHandle, output, (uint)output.Length, out         charsWritten, IntPtr.Zero))\n    {\n        var lastError = Marshal.GetLastWin32Error();\n        throw new Win32Exception(lastError);\n    }\n}\ncatch(Win32Exception e)\n{\n    Console.WriteLine($\"Error: {e.Message}\");\n};\n```", "```cs\n[DllImport(\"kernel32.dll\")]\nstatic extern uint FormatMessage(\n    uint dwFlags,\n    IntPtr lpSource,\n    uint dwMessageId,\n    uint dwLanguageId,\n    [Out] StringBuilder lpBuffer,\n    uint nSize,\n    IntPtr Arguments);\n```", "```cs\nvar lastError = Marshal.GetLastWin32Error();\nint bufferSize = 256;\nvar errorBuffer = new StringBuilder(bufferSize);\nvar res = FormatMessage(\n    0x00001000,\n    IntPtr.Zero,\n    (uint)lastError,\n    0,\n    errorBuffer,\n    (uint)bufferSize,\n    IntPtr.Zero);\nif(res != IntPtr.Zero)\n{\n    var formattedError = errorBuffer.ToString();\n    Console.WriteLine(formattedError);\n}\n```", "```cs\nConsole.WriteLine(\"Hello {0}\", 42);\n```", "```cs\nif(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))\n{\n    var lastError = Marshal.GetLastWin32Error();\n    var errorMessage = new Win32Exception(lastError).Message;\n    Console.WriteLine($\"Error: {errorMessage}\");\n}\n```", "```cs\n[DllImport(\"msvcrt.dll\", CallingConvention = CallingConvention.Cdecl)]\nstatic extern int printf(string format, int i, double d);\nprintf(\"Hello, System Programmers!\\n\", 1, 2.0);\n```"]