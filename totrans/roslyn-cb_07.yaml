- en: C# Interactive and Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple C# script and evaluating it within the Visual Studio interactive
    window
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using script directives and REPL commands in the C# interactive window
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using keyboard shortcuts for evaluating and navigating through script sessions
    in the C# interactive window
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a C# interactive session from an existing C# project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a C# script on a Visual Studio developer command prompt using `csi.exe`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Roslyn scripting API to execute C# code snippets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter gives a basic introduction to one of the most powerful features/tools
    based on the Roslyn compiler API: **C# interactive and scripting.** You can read
    an overview about C# scripting at [https://msdn.microsoft.com/en-us/magazine/mt614271.aspx](https://msdn.microsoft.com/en-us/magazine/mt614271.aspx).
    Here is a small gist of this feature from the preceding article:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: C# scripting is a tool for testing out your C# and .NET snippets without the
    effort of creating multiple unit testing or console projects. It provides an easy
    means to explore and understand an API without the overhead of a yet another `CSPROJ`
    file in your `%TEMP%` directory. The C# read-evaluate-print-loop (REPL) is available
    as an interactive window within Visual Studio 2015 and after and as a new command-line
    interface (CLI) called CSI.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the C# interactive window in Visual Studio:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eae90547-838c-4402-89ae-f66ac39072c0.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'The following is a screenshot of the C# interactive command-line interface
    (`csi.exe`) executed from a Visual Studio 2017 developer command prompt:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb41acbf-d61f-4a28-a65e-2ee2dd022322.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Writing a simple C# script and evaluating it within the Visual Studio interactive
    window
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will walk you through the basics of C# scripting and show
    you how to use the Visual Studio interactive window to evaluate a C# script.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have Visual Studio 2017 Community edition installed on your
    machine to execute this recipe. You can install a free community edition from
    [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open Visual Studio and start the C# Interactive window by clicking on View
    | Other Windows | C# Interactive:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee52c0cc-4925-43f6-8040-2c3cece4c648.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: Type `Console.WriteLine("Hello, World!")` in the interactive window and hit
    the *Enter* key to evaluate the C# expression.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that `Hello, World!` is output as a result in the interactive window:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e6ac3c5f-ea5d-4e64-b429-9780f12769af.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Now, type a variable declaration statement of type `List<int>` with a collection
    initializer: `var myList = new List<int> { 3, 2, 7, 4, 9, 0 };` and press the
    *Enter* key.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, type an expression statement that accesses the `myList` variable declared
    in the previous statement and filter the list to all the even numbers in the list
    using a linq expression: `myList.Where(x => x % 2 == 0)`.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入一个表达式语句，该语句访问先前语句中声明的 `myList` 变量，并使用 linq 表达式过滤列表中的所有偶数：`myList.Where(x
    => x % 2 == 0)`。
- en: 'Press the *Enter* key to evaluate the expression and verify that a nicely formatted
    enumerable list is output as the result of the evaluation: `Enumerable.WhereListIterator<int>
    { 2, 4, 0 }`.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Enter* 键来评估表达式并验证评估结果输出为一个格式良好的可枚举列表：`Enumerable.WhereListIterator<int>
    { 2, 4, 0 }`.
- en: Type the command `$"The current directory is { Environment.CurrentDirectory
    }."`. This accesses the current directory environment variable and verifies your
    current directory output.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令 `$"The current directory is { Environment.CurrentDirectory }."`。这访问当前目录环境变量并验证当前目录输出。
- en: 'Now, type the following commands into the interactive window and verify that
    pressing the *Enter* key leads to a 10-second UI delay as per the entered `await`
    expression:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下命令输入到交互窗口中，并验证按下 *Enter* 键会导致根据输入的 `await` 表达式出现 10 秒的 UI 延迟：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Type the following class declaration in the interactive window and press the
    *Enter* key:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互窗口中输入以下类声明并按下 *Enter* 键：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instantiate type `C` declared earlier and invoke method `M` on the instance
    by evaluating the following statement: `new C().M();`.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化之前声明的类型 `C` 并通过评估以下语句在实例上调用方法 `M`：`new C().M();`.
- en: 'Verify that the output in the interactive window is: `C.M invoked`.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证交互窗口中的输出为：`C.M invoked`。
- en: You can view the entire contents of the interactive window for this recipe in
    the attached text file `InteractiveWindowOutput.txt`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在附带的文本文件 `InteractiveWindowOutput.txt` 中查看本食谱的整个交互窗口内容。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we wrote a simple set of C# interactive script commands to
    perform a bunch of operations that are common in regular C# code, but without
    having to declare a stub type/main method or having to create a source file/project.
    The operations performed during the interactive session were:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们编写了一组简单的 C# 交互脚本命令，以执行在常规 C# 代码中常见的多项操作，但无需声明存根类型/主方法或创建源文件/项目。交互会话期间执行的操作包括：
- en: Evaluating an expression that outputs a string to the console (`Console.WriteLine(...)`).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估一个输出字符串到控制台的表达式 (`Console.WriteLine(...)`).
- en: Declaring a local variable for the lifetime of the interactive session and initialize
    it with a collection `initializer (myList)`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个在交互会话期间存在的局部变量，并用集合 `initializer (myList)` 初始化它。
- en: Accessing the preceding declared variable in a subsequent linq statement and
    evaluating the resultant value (`myList.Where(...)`).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后续的 linq 语句中访问先前声明的变量并评估结果值 (`myList.Where(...)`).
- en: Accessing environment variables in C# expression evaluations (`Environment.CurrentDirectory`).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C# 表达式评估中访问环境变量 (`Environment.CurrentDirectory`).
- en: Importing namespace in the session through a using declaration (`using System.Threading.Tasks;`).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用声明在会话中导入命名空间 (`using System.Threading.Tasks;`).
- en: Awaiting an async expression (`await Task.Delay(10000)`).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待异步表达式 (`await Task.Delay(10000)`).
- en: Declaring a C# class with a method (`class C` and `method M`) for the lifetime
    of the interactive session.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互会话期间声明一个具有方法的 C# 类 (`class C` 和 `method M`)。
- en: Instantiating the preceding declared class and invoking the method in a subsequent
    statement (`new C().M()`).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后续语句中实例化先前声明的类并调用方法 (`new C().M()`).
- en: Let's briefly walk through the implementation of the C# interactive compiler
    that enables all the preceding regular C# operations in the interactive mode.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下 C# 交互编译器的实现，它使得在交互模式下执行所有前面的常规 C# 操作成为可能。
- en: '`Csi.main` ([http://source.roslyn.io/#csi/Csi.cs,14](http://source.roslyn.io/#csi/Csi.cs,14))
    is the primary entry point into the C# interactive compiler. After initialization
    of the compiler, the control eventually reaches `CommandLineRunner.RunInteractiveLoop`
    ([http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/Hosting/CommandLine/CommandLineRunner.cs,7c8c5cedadd34d79](http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/Hosting/CommandLine/CommandLineRunner.cs,7c8c5cedadd34d79)),
    which is, the REPL, or read-evaluate-print-loop, that reads interactive commands
    and evaluates them in a loop until the user exits by pressing *Ctrl* + *C*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Csi.main` ([http://source.roslyn.io/#csi/Csi.cs,14](http://source.roslyn.io/#csi/Csi.cs,14))
    是 C# 交互编译器的入口点。在编译器初始化后，控制最终会到达 `CommandLineRunner.RunInteractiveLoop` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/Hosting/CommandLine/CommandLineRunner.cs,7c8c5cedadd34d79](http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/Hosting/CommandLine/CommandLineRunner.cs,7c8c5cedadd34d79))，即
    REPL，或读取-评估-打印循环，它读取交互命令并在循环中评估它们，直到用户通过按 *Ctrl* + *C* 退出。'
- en: For each entered line, the REPL loop executes `ScriptCompiler.ParseSubmission`
    ([http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/ScriptCompiler.cs,54b12302e519f660](http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/ScriptCompiler.cs,54b12302e519f660))
    to parse the given source text into a syntax tree. If the submission is incomplete
    (for example, if the first line of a class declaration has been entered), then
    it outputs `.` and continues waiting for more text for the submission. Otherwise,
    it creates a script using the current submission text chained to the end of the
    prior submissions and runs the new submission by invoking into the core C# compiler
    APIs. The result of the submission is output to the interactive window.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条输入的行，REPL 循环会执行 `ScriptCompiler.ParseSubmission` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/ScriptCompiler.cs,54b12302e519f660](http://source.roslyn.io/#Microsoft.CodeAnalysis.Scripting/ScriptCompiler.cs,54b12302e519f660))
    来将给定的源文本解析成一个语法树。如果提交不完整（例如，如果类声明的第一行已经输入），则输出 `.` 并继续等待更多文本以完成提交。否则，它使用当前提交文本连接到先前的提交并运行新的提交，通过调用核心
    C# 编译器 API。提交的结果输出到交互窗口。
- en: Further details on how the submission chains to the prior submissions and executes
    within the interactive compiler are out of the scope of this chapter. You may
    navigate the script compiler's code base at ([http://source.roslyn.io/#q=RunSubmissionsAsync](http://source.roslyn.io/#q=RunSubmissionsAsync))
    to understand the internal workings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提交如何链接到先前的提交并在交互编译器中执行的更多详细信息超出了本章的范围。您可以通过 ([http://source.roslyn.io/#q=RunSubmissionsAsync](http://source.roslyn.io/#q=RunSubmissionsAsync))
    导航到脚本编译器的代码库以了解其内部工作原理。
- en: Using script directives and REPL commands in the C# interactive window
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 交互窗口中使用脚本指令和 REPL 命令
- en: In this section, we will walk you through the common directives and REPL commands
    available in C# interactive scripting and show you how to use them in the Visual
    Studio interactive window.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍 C# 交互脚本中可用的常见指令和 REPL 命令，并展示如何在 Visual Studio 交互窗口中使用它们。
- en: Getting started
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You will need to have the Visual Studio 2017 Community edition installed on
    your machine to execute this recipe. You can install a free community edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 社区版才能执行此菜谱。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装免费的社区版。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Visual Studio and start the C# Interactive window by clicking on View |
    Other Windows | C# Interactive.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并通过点击视图 | 其他窗口 | C# 交互来启动 C# 交互窗口。
- en: Copy `Newtonsoft.Json.dll` from the attached sample for the recipe into your
    temp directory `%TEMP%`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将附带的示例菜谱中的 `Newtonsoft.Json.dll` 复制到您的临时目录 `%TEMP%`。
- en: 'Execute the following `#r` directive to load this assembly into the interactive
    session:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下 `#r` 指令以将此程序集加载到交互会话中：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Verify that you can now reference types from this assembly as well as create
    objects and invoke methods. For example, type the following code snippet into
    the interactive window:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您现在可以引用此程序集中的类型以及创建对象和调用方法。例如，将以下代码片段输入到交互窗口中：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Verify the string representation of the array that is the output to the interactive
    window:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输出到交互窗口的数组字符串表示：
- en: '![](img/273b2757-5621-4487-85df-5361864399e7.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/273b2757-5621-4487-85df-5361864399e7.png)'
- en: Execute the REPL command `#clear` (or `#cls`) and verify this clears all the
    text from the interactive window.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行REPL命令`#clear`（或`#cls`），并验证这清除了交互窗口中的所有文本。
- en: Copy `MyScript.csx` from the attached sample for the recipe into your temp directory
    `%TEMP%`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将附带的示例菜谱中的`MyScript.csx`复制到您的临时目录`%TEMP%`。
- en: 'Execute the following `#load` directive to load and execute this script in
    the interactive session:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下`#load`指令以在交互会话中加载并执行此脚本：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Verify that the script executes, and you get the following output from the
    execution:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证脚本是否执行，并从执行中获得以下输出：
- en: '![](img/36cbf5c2-5ef2-4ec4-b1fd-352b8a8e597c.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36cbf5c2-5ef2-4ec4-b1fd-352b8a8e597c.png)'
- en: Execute the `#reset` REPL command to reset the interactive session.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`#reset` REPL命令以重置交互会话。
- en: 'Now, attempt to refer to the `Newtonsoft.Json` namespace in the interactive
    session, which was added prior to the reset, and verify that you get an error,
    as the assembly is no longer loaded in the session:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试在交互会话中引用之前重置之前添加的`Newtonsoft.Json`命名空间，并验证您是否得到错误，因为程序集已不再在会话中加载：
- en: '![](img/882c3609-67a6-48b6-889e-17da609bed02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/882c3609-67a6-48b6-889e-17da609bed02.png)'
- en: 'Finally, execute the `#help` REPL command to print the help text for available
    keyboard shortcuts, directives, and REPL commands in the interactive window:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行`#help` REPL命令以打印交互窗口中可用的键盘快捷键、指令和REPL命令的帮助文本：
- en: '![](img/b894f5a4-4f72-43e5-9bee-9a9d579e48ed.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b894f5a4-4f72-43e5-9bee-9a9d579e48ed.png)'
- en: You can view the entire contents of the interactive window for this recipe in
    the attached text file `InteractiveWindowOutput.txt`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在附带的文本文件`InteractiveWindowOutput.txt`中查看此菜谱的交互窗口的完整内容。
- en: Using keyboard shortcuts for evaluating and navigating through script sessions
    in the C# interactive window
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#交互窗口中使用键盘快捷键评估和导航脚本会话
- en: In this section, we will walk you through the common keyboard shortcuts available
    in C# interactive scripting and show you how to use them in the Visual Studio
    interactive window.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍C#交互脚本中常见的键盘快捷键，并展示如何在Visual Studio交互窗口中使用它们。
- en: As demonstrated in the last step of the previous recipe, you can use the *#help*
    REPL command in the interactive window to see the entire list of keyboard shortcuts
    available in the C# interactive window.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一道菜谱的最后一步所示，您可以在交互窗口中使用*#help* REPL命令查看C#交互窗口中可用的所有键盘快捷键的完整列表。
- en: Getting started
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: You will need to have the Visual Studio 2017 Community edition installed on
    your machine to execute this recipe. You can install a free community edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15.](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装Visual Studio 2017社区版才能执行此菜谱。您可以从[https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15.](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)安装免费的社区版。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Visual Studio and open the C# Interactive window by clicking on View| Other
    Windows | C# Interactive*.*
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，通过点击视图|其他窗口|C#交互窗口*.*打开C#交互窗口。
- en: Type the string constant `"World!"` and hit the *Enter* key to evaluate and
    output the string.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入字符串常量`"World!"`并按*Enter*键以评估和输出字符串。
- en: Type `"Hello, " +` and move the cursor to the previous submission from the step
    2, and hit the *Ctrl* + *Enter* keys to append the text from the previous submission
    to the current submission. The current submission text should change to `"Hello,
    " + "World!"`, and pressing the *Enter* key should output the text `"Hello, World!"`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`"Hello, "`并将光标移至步骤2中的上一个提交，然后按*Ctrl* + *Enter*键将上一个提交的文本附加到当前提交。当前提交的文本应更改为`"Hello,
    " + "World!"`，按*Enter*键应输出文本`"Hello, World!"`。
- en: 'Type `@"Hello, World` and press the *Shift* + *Enter* keys to add a new line
    within the current submission. Typing `with a new line!"` on the next line and
    hitting the *Enter* key should output the text `"Hello, World\r\nwith a new line!"`,
    as shown here:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`@"Hello, World`并按*Shift* + *Enter*键在当前提交中添加新行。在下一行输入`with a new line!"`并按*Enter*键，应输出文本`"Hello,
    World\r\nwith a new line!"`，如下所示：
- en: '![](img/1fefa632-013e-4858-b970-b4d91bb1d6da.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fefa632-013e-4858-b970-b4d91bb1d6da.png)'
- en: Type `Hello` and press the *Esc* key; this should clear the text on the current
    line.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Hello`并按*Esc*键；这应该清除当前行的文本。
- en: Press the *Alt* + Up arrow keys together; this should change the current submission
    text to be the same as the previous submission, in our case, `@"Hello, World`
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时按下 *Alt* + 向上箭头键；这应该将当前提交的文本更改为与上一个提交相同，在我们的例子中，是 `@"Hello, World`
- en: '`. with a new line!"`.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`. 在新的一行!"`.'
- en: Press the *Enter* key to output `"Hello, World\r\nwith a new line!"` again.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Enter* 键再次输出 `"Hello, World\r\nwith a new line!"`。
- en: Press the quote key *"*. This should automatically add another quote for the
    string. Press the *Delete* key to remove this automatically and add the second
    quote.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下引号键 *"*. 这应该自动添加另一个引号。按 *Delete* 键删除这个自动添加的引号并添加第二个引号。
- en: Now, press the *Ctrl* + *Alt* + Up arrow keys together; this should change the
    current submission text to be the same as the last among the previous submissions
    that started with the same character, that is, *"*. In our case, this was the
    submission `"Hello, " + "World!"`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，同时按下 *Ctrl* + *Alt* + 向上箭头键；这应该将当前提交的文本更改为与之前提交中相同字符的最后一个提交相同，即 *"*. 在我们的例子中，这是提交
    `"Hello, " + "World!"`.
- en: Press the *Enter* key to output `"Hello, World!"`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Enter* 键输出 `"Hello, World!"`.
- en: Now, place the cursor on our very first submission in the session, that is,
    the submission at step 2.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将光标放在会话中的第一个提交上，即步骤 2 中的提交。
- en: Press the *Ctrl* + *A* keys together to select the entire text in the first
    submission, that is, `"World!"`. Then, press the *Ctrl* + *Enter* keys together
    to copy this text into the current submission.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时按下 *Ctrl* + *A* 键以选择第一个提交中的全部文本，即 `"World!"`。然后，同时按下 *Ctrl* + *Enter* 键以将此文本复制到当前提交。
- en: Press the *Enter* key to output `"World!"`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Enter* 键输出 `"World!"`.
- en: Place the cursor back on the previous submission and press the *Ctrl* + *A*
    keys twice to select the entire contents of the interactive window.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移回之前的提交，并连续两次按下 *Ctrl* + *A* 键以选择交互窗口的全部内容。
- en: You can view the entire contents of the interactive window for this recipe in
    the attached text file `InteractiveWindowOutput.txt`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在附带的文本文件 `InteractiveWindowOutput.txt` 中查看此菜谱的交互窗口的全部内容。
- en: Initializing the C# interactive session from the existing C# project
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有 C# 项目初始化 C# 交互会话
- en: In this section, we will walk you through the steps to initialize a C# interactive
    scripting session from an existing C# project and then use the types from the
    project in the Visual Studio interactive window.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何从现有的 C# 项目初始化 C# 交互式脚本会话，然后在使用 Visual Studio 交互窗口中的项目类型。
- en: Getting started
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You will need to have Visual Studio 2017 Community edition installed on your
    machine to execute this recipe. You can install a free community edition from
    [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15.](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 社区版才能执行此菜谱。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15.](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    免费安装社区版。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Visual Studio and start the C# Interactive window by clicking on View |
    Other Windows | C# Interactive.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并通过单击“视图”|“其他窗口”|“C# 交互”来启动 C# 交互窗口。
- en: Declare a local variable `int x = 0;` in the interactive window and press the
    *Enter* key.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互窗口中声明一个局部变量 `int x = 0;` 并按下 *Enter* 键。
- en: Execute `Console.WriteLine(x)` and verify the output `0` to confirm that the
    variable `x` is declared in the current session.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `Console.WriteLine(x)` 并验证输出 `0` 以确认变量 `x` 已在当前会话中声明。
- en: Create a new C# class library project, say `ClassLibrary`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 类库项目，例如 `ClassLibrary`。
- en: 'Add the following method `M` to type `Class1` in the created project:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法 `M` 添加到创建的项目中的 `Class1` 类型：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Right-click on the project in the solution explorer and click on Initialize
    Interactive with Project:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击项目，然后单击“使用项目初始化交互”：
- en: '![](img/3948a6dd-e7ba-442c-a196-020065aa464a.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3948a6dd-e7ba-442c-a196-020065aa464a.png)'
- en: 'Verify that the project build has started, and that the C# interactive session
    has been reset with the project references and output assembly (`ClassLibrary.dll`):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证项目构建是否开始，以及 C# 交互会话是否已使用项目引用和输出程序集（`ClassLibrary.dll`）重置：
- en: '![](img/b9b1a12d-5e11-4ecf-8cfa-c559885de8ad.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9b1a12d-5e11-4ecf-8cfa-c559885de8ad.png)'
- en: Type the following text `new Class1().M();` in the interactive window and press
    the *Enter* key to execute the submission.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互窗口中输入以下文本 `new Class1().M();` 并按下 *Enter* 键以执行提交。
- en: Verify that `Executing ClassLibrary.Class1.M()` is output as a result, confirming
    that the interactive session was initialized with the `ClassLibrary` project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `Executing ClassLibrary.Class1.M()` 作为结果输出，确认交互会话是用 `ClassLibrary` 项目初始化的。
- en: Attempt to reference the variable *x* that was defined in step2, that is, prior
    to initializing the interactive session with the project by executing `Console.WriteLine(x);`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试引用在步骤2中定义的变量 *x*，即在通过执行 `Console.WriteLine(x);` 初始化项目交互会话之前。
- en: 'Verify that this leads to the following compile time error, confirming that
    the session state was completely reset when we initialized it from the project:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证这导致以下编译时错误，确认当我们从项目初始化会话时，会话状态已完全重置：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can view the entire contents of the interactive window for this recipe in
    the attached text file `InteractiveWindowOutput.txt`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在附带的文本文件 `InteractiveWindowOutput.txt` 中查看此配方的整个交互窗口内容。
- en: Executing the C# script on a Visual Studio developer command prompt using csi.exe
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual Studio 开发者命令提示符中使用 csi.exe 执行 C# 脚本
- en: In this section, we will show you how to use the command-line interface for
    executing C# scripts and their interactive mode. `csi.exe` (CSharp Interactive)
    is the CLI executable for C# interactive that ships with the C# compiler toolset,
    along with Visual Studio.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何使用命令行界面执行 C# 脚本及其交互模式。`csi.exe`（CSharp Interactive）是 C# 交互的 CLI
    可执行文件，它随 C# 编译器工具集和 Visual Studio 一起提供。
- en: Getting started
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You will need to have the Visual Studio 2017 Community edition installed on
    your machine to execute this recipe. You can install a free community edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 社区版才能执行此配方。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装免费的社区版。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start the Visual Studio 2017 develop command prompt and execute the command
    `csi.exe` to start the C# interactive session*.*
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2017 开发命令提示符并执行命令 `csi.exe` 以启动 C# 交互会话*.*。
- en: 'Type `Console.WriteLine("Hello, World!")` on the console and click on the *Enter*
    key to execute the command in interactive mode:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输入 `Console.WriteLine("Hello, World!")` 并按 *Enter* 键以交互模式执行命令：
- en: '![](img/c7852ad9-4c20-4356-b701-d9c5e7528d17.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7852ad9-4c20-4356-b701-d9c5e7528d17.png)'
- en: Press *Ctrl* + *C* to exit the interactive mode.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 退出交互模式。
- en: 'Create a script file `MyScript.csx` with the following code to output the arguments
    to the script:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyScript.csx` 的脚本文件，包含以下代码以输出脚本参数：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Execute the script with arguments `1 2 3` and verify the following output.
    Also, note that after executing the script, we return back to the command prompt,
    not the interactive session:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数 `1 2 3` 执行脚本并验证以下输出。注意，执行脚本后，我们返回到命令提示符，而不是交互会话：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, execute the same script with an additional `-i` argument prepended and
    verify the same output as earlier, this time however, we return to an interactive
    prompt:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在脚本前添加一个额外的 `-i` 参数并执行，验证与之前相同的输出，不过这次我们返回到交互式提示符：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Execute `Console.WriteLine(t.Length)` and verify that the output is `6`, confirming
    that the variable *t* declared in the script and initialized with the command-line
    arguments is still alive in the current interactive session.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `Console.WriteLine(t.Length)` 并验证输出为 `6`，确认在当前交互会话中，脚本中声明的并使用命令行参数初始化的变量
    *t* 仍然存在。
- en: Press *Ctrl* + *C* to exit the interactive mode.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 退出交互模式。
- en: 'Execute `csi -i` to start `csi.exe` in interactive mode and execute the *#help*
    command to get the list of available keyboard shortcuts, REPL commands, and script
    directives:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `csi -i` 以以交互模式启动 `csi.exe` 并执行 *#help* 命令以获取可用键盘快捷键、REPL 命令和脚本指令列表：
- en: '![](img/24dd68e6-500d-48ba-be68-2ef98b2a8a9b.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24dd68e6-500d-48ba-be68-2ef98b2a8a9b.png)'
- en: Note that the set of available keyboard shortcuts, REPL commands, and script
    directives in `csi.exe` is a subset of the corresponding sets in the Visual Studio
    interactive window. Refer to the earlier recipes *Using script directives and
    REPL commands in the C# interactive window* and *Using keyboard shortcuts for
    evaluating and navigating through script sessions in the C# interactive window*,
    in this chapter for available shortcuts, commands, and directives in the Visual
    Studio interactive window.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *C* to exit the interactive mode.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attempt to execute `csi.exe` with arguments, but no script name, and verify
    error *CS2001* about missing source file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can read more about the command-line REPL and the arguments to `csi.exe`
    at [https://github.com/dotnet/roslyn/wiki/Interactive-Window#repl](https://github.com/dotnet/roslyn/wiki/Interactive-Window#repl).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Using the Roslyn scripting API to execute C# code snippets
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to to write a C# console application that
    uses Roslyn scripting APIs to execute C# code snippets and consume their output.
    The scripting APIs enable .NET applications to instantiate a C# engine and execute
    code snippets against host-supplied objects. The scripting APIs can also be used
    directly in an interactive session.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have the Visual Studio 2017 Community edition installed on
    your machine to execute this recipe. You can install a free community edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`*.*
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis.CSharp.Scripting` NuGet package (at the
    time of writing, the latest stable version is *2.1.0*). For guidance on how to
    search for and install the NuGet package to a project, refer to the recipe, *Searching
    and installing analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs.`
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *F5* to build and start the project `.exe` without debugging.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the first output from the evaluation of `EvaluateSimpleAsync`*:*
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Press any key to continue the execution.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the second output from the evaluation of `EvaluateWithReferencesAsync`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Press any key to continue the execution.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the third output from the evaluation of `EvaluateWithImportsAsync`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Press any key to continue the execution.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify last output from the evaluation of `EvaluateParameterizedScriptInLoopAsync`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Press any key to exit the console.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the article ([https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples](https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples))
    for more examples of the scripting API.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅文章 ([https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples](https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples))
    以获取脚本 API 的更多示例。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we wrote a C# console application based on Roslyn scripting
    APIs to perform various common scripting operations. The rich scripting APIs provides
    a powerful object model for the evaluation, creation, and execution of scripts
    with configuration options.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们基于 Roslyn 脚本 API 编写了一个 C# 控制台应用程序，以执行各种常见的脚本操作。丰富的脚本 API 为评估、创建和执行具有配置选项的脚本提供了一个强大的对象模型。
- en: 'Let us walk through the code in this recipe and understand how we implemented
    some of these operations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这个菜谱中的代码，了解我们是如何实现这些操作的：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Main` method invokes individual methods to perform following operations:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法调用单个方法以执行以下操作：'
- en: '`EvaluateSimpleAsync`: A simple evaluation of a binary add expression'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EvaluateSimpleAsync`: 对二进制加法表达式的简单评估'
- en: '`EvaluateWithReferencesAsync`: An evaluation involving a reference assembly
    passed down to the script options'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EvaluateWithReferencesAsync`: 一个涉及传递给脚本选项的引用程序集的评估'
- en: '`EvaluateWithImportsAsync`: An evaluation involving the importing of a system
    namespace and invoking an API from the namespace'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EvaluateWithImportsAsync`: 一个涉及导入系统命名空间并从该命名空间调用 API 的评估'
- en: '`EvaluateParameterizedScriptInLoopAsync`: A creation and evaluation of a script
    parameterized by parameters and invoked over a loop of values.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EvaluateParameterizedScriptInLoopAsync`: 通过参数化脚本并在值循环中调用创建和评估脚本'
- en: '`EvaluateSimpleAsync` invokes the most common scripting API, `CSharpScript.EvaluateAsync`
    ([http://source.roslyn.io/#q=CSharpScript.EvaluateAsync](http://source.roslyn.io/#q=CSharpScript.EvaluateAsync)),
    with an expression as the argument to evaluate that expression. In our case, we
    pass in `1 + 2` as the argument to `EvaluateAsync`, which outputs the result `3`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`EvaluateSimpleAsync` 调用最常用的脚本 API，即 `CSharpScript.EvaluateAsync` ([http://source.roslyn.io/#q=CSharpScript.EvaluateAsync](http://source.roslyn.io/#q=CSharpScript.EvaluateAsync))，并使用一个表达式作为评估该表达式的参数。在我们的例子中，我们将
    `1 + 2` 作为参数传递给 `EvaluateAsync`，输出结果 `3`：'
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`EvaluateWithReferencesAsync` invokes the same `CSharpScript.EvaluateAsync`
    API ([http://source.roslyn.io/#q=CSharpScript.EvaluateAsync](http://source.roslyn.io/#q=CSharpScript.EvaluateAsync)),
    but using an additional reference assembly passed down through the script options
    with the `ScriptOptions.WithReferences` API ([http://source.roslyn.io/#q=ScriptOptions.WithReferences](http://source.roslyn.io/#q=ScriptOptions.WithReferences)).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`EvaluateWithReferencesAsync` 调用相同的 `CSharpScript.EvaluateAsync` API ([http://source.roslyn.io/#q=CSharpScript.EvaluateAsync](http://source.roslyn.io/#q=CSharpScript.EvaluateAsync))，但使用通过脚本选项传递的额外引用程序集，通过
    `ScriptOptions.WithReferences` API ([http://source.roslyn.io/#q=ScriptOptions.WithReferences](http://source.roslyn.io/#q=ScriptOptions.WithReferences))。'
- en: 'In our case, we pass in `typeof(System.Net.Dns).Assembly` as an additional
    reference for the evaluation of `System.Net.Dns.GetHostName()`, which outputs
    the machine name:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们传递 `typeof(System.Net.Dns).Assembly` 作为评估 `System.Net.Dns.GetHostName()`
    的额外引用，输出机器名：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`EvaluateWithImportsAsync` invokes the `CSharpScript.EvaluateAsync` API ([http://source.roslyn.io/#q=CSharpScript.EvaluateAsync](http://source.roslyn.io/#q=CSharpScript.EvaluateAsync))
    with a namespace import passed down through the script options with the `ScriptOptions.WithImports`
    API ([http://source.roslyn.io/#q=ScriptOptions.WithImports](http://source.roslyn.io/#q=ScriptOptions.WithImports)).
    In our case, we pass in `System.Math` as an additional namespace import for the
    evaluation of `Sqrt(2)`, which outputs the result `1.4142135623731`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`EvaluateWithImportsAsync` 使用通过脚本选项传递的命名空间导入调用 `CSharpScript.EvaluateAsync`
    API ([http://source.roslyn.io/#q=CSharpScript.EvaluateAsync](http://source.roslyn.io/#q=CSharpScript.EvaluateAsync))，通过
    `ScriptOptions.WithImports` API ([http://source.roslyn.io/#q=ScriptOptions.WithImports](http://source.roslyn.io/#q=ScriptOptions.WithImports))。在我们的例子中，我们将
    `System.Math` 作为评估 `Sqrt(2)` 的额外命名空间导入，输出结果 `1.4142135623731`：'
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`EvaluateParameterizedScriptInLoopAsync` creates a parameterized C# script
    using the `CSharpScript.Create` API ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp.Scripting/CSharpScript.cs,3beb8afb18b9c076](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp.Scripting/CSharpScript.cs,3beb8afb18b9c076)),
    which takes the script code to execute and a global type as arguments:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`EvaluateParameterizedScriptInLoopAsync` 使用 `CSharpScript.Create` API ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp.Scripting/CSharpScript.cs,3beb8afb18b9c076](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp.Scripting/CSharpScript.cs,3beb8afb18b9c076))
    创建一个参数化的 C# 脚本，该脚本接受要执行的脚本代码和一个全局类型作为参数：'
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It then invokes the `Script.Compile` API ([http://source.roslyn.io/#q=Script.Compile](http://source.roslyn.io/#q=Script.Compile))
    to compile the script. The compiled script is then executed in a loop using the
    `Script.RunAsync` API ([http://source.roslyn.io/#q=Script.RunAsync](http://source.roslyn.io/#q=Script.RunAsync))
    with different instances of global type Globals, with incremented values of fields
    *X* and *Y*. Each iteration computes the result of the expression `X * Y`, which
    in our case is just square of all the numbers in the loop from zero to nine.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用 `Script.Compile` API ([http://source.roslyn.io/#q=Script.Compile](http://source.roslyn.io/#q=Script.Compile))
    来编译脚本。编译后的脚本随后在循环中使用 `Script.RunAsync` API ([http://source.roslyn.io/#q=Script.RunAsync](http://source.roslyn.io/#q=Script.RunAsync))
    执行，循环中使用不同实例的全局类型 Globals，字段 *X* 和 *Y* 的值递增。每次迭代计算表达式 `X * Y` 的结果，在我们的例子中，这只是从零到九的循环中所有数字的平方。
