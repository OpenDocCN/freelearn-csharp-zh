- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Applying Event Sourcing Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用事件源模式
- en: In the previous chapter, we explored a prolific pattern in CQRS. This pattern
    encourages us to create a clear separation between code and data sources that
    govern read and write operations. With this kind of separation, we risk having
    our data out of sync in between operations, which introduces the need for additional
    techniques to ensure data consistency.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了CQRS中的一个流行模式。这个模式鼓励我们创建代码和数据源之间的清晰分离，这些数据源控制读写操作。有了这种分离，我们可能会在操作之间出现数据不同步的情况，这引入了需要额外技术来确保数据一致性的需求。
- en: Even without CQRS, we must contend with the typical microservices pattern where
    each service is expected to have its own data store. Recall that there will be
    situations where data needs to be shared between services. There needs to be some
    mechanism that will adequately transport data between services so that they will
    remain in sync.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有CQRS，我们也必须应对典型的微服务模式，其中每个服务都期望有自己的数据存储。回想一下，将会有需要在不同服务之间共享数据的情况。需要有一种机制能够充分地在服务之间传输数据，以便它们保持同步。
- en: '**Event sourcing** is touted as a solution to this issue, where a new data
    store is introduced that keeps track of all the command operations as they happen.
    The records in this data store are considered events and contain enough information
    for the system to track what happens with each command operation. These records
    are called events and they act as an intermediary store for event-driven or asynchronous
    services architecture. They can also act as an audit log as they will store all
    the necessary details for replaying changes being made against the domain.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件源**被誉为解决这一问题的方案，其中引入了一个新的数据存储，它跟踪所有发生的命令操作。这个数据存储中的记录被认为是事件，并包含足够的信息，以便系统跟踪每个命令操作发生的情况。这些记录被称为事件，它们充当事件驱动或异步服务架构的中间存储。它们还可以作为审计日志，因为它们将存储所有必要的详细信息，以便回放对领域所做的更改。'
- en: In this chapter, we will explore the event sourcing pattern and justify its
    use as a solution to our potentially out-of-sync databases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨事件源模式，并证明其作为解决我们可能不同步数据库的解决方案的合理性。
- en: 'After reading this chapter, you will be able to do the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将能够做到以下事项：
- en: Understand what events are and what event sourcing can do for you
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解事件是什么以及事件源能为你做什么
- en: Apply event sourcing patterns in your application code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序代码中应用事件源模式
- en: Use the CQRS pattern to create events and read states in between events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CQRS模式在事件之间创建事件和读取状态
- en: Create an event store using a relational or non-relational database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关系型或非关系型数据库创建事件存储
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch06](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch06).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在GitHub上的项目仓库中找到，该仓库托管在[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch06](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch06)。
- en: What are events?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是事件？
- en: 'An event, within the context of software development, refers to something that
    happens because of an action being completed. Events are then used to carry out
    actions in the background, such as the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发背景下，事件指的是由于某个动作完成而发生的事情。然后，事件被用来执行后台操作，如下所示：
- en: Storing data for analytics purposes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分析目的存储数据
- en: Notification of completed actions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成动作的通知
- en: Database auditing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库审计
- en: Key attributes of events
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件的关键属性
- en: 'Events can be used to build the foundation of any application’s core functionality.
    While the concept can be suitable for many situations, it is important for us
    to understand some key attributes of events and properly scope the need for their
    introduction, as well as uphold certain standards in our implementations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以用来构建任何应用程序核心功能的基础。虽然这个概念可能适用于许多情况，但了解事件的一些关键属性，以及正确界定引入它们的需求，并在我们的实现中保持某些标准，对我们来说非常重要：
- en: '**Immutability**: This word refers to the unchangeable nature of an object.
    Within the context of an event, once something has happened, it becomes a fact.
    That means we cannot change it or the outcome in the real world. We extend this
    same feature to our events and ensure that they cannot be changed after they are
    generated.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：这个词指的是对象的不变性。在事件的上下文中，一旦某件事情发生，它就变成了事实。这意味着我们无法改变它或现实世界中的结果。我们将这个相同的特性扩展到我们的事件中，并确保它们在生成后不能被更改。'
- en: '**Single occurrence**: Each event is unique. Once it has been generated, it
    cannot be repeated. Even if the same thing happens later, it should be recognized
    as a new event.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单次发生**：每个事件都是唯一的。一旦生成，它就不能重复。即使后来发生相同的事情，也应该被视为一个新的事件。'
- en: '**Historical**: An event should always represent a point in time. This way,
    we can trace what happened and when in the past. This discipline is also displayed
    in the way that we name our events, where we use the past tense to describe the
    event.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史性**：事件应该始终代表一个时间点。这样，我们可以追溯过去发生了什么以及何时发生。这种纪律也体现在我们命名事件的方式上，我们使用过去时来描述事件。'
- en: Events at their best do not contain any behavior or business logic. They generally
    only serve as a point-in-time data collection unit and help us to track what is
    happening at different points in our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在其最佳状态下不包含任何行为或业务逻辑。它们通常只作为时间点的数据收集单元，并帮助我们跟踪应用程序中不同时间点发生的事情。
- en: Now that we have a good idea of what events are and why they are used at a high
    level, let us focus on more practical uses of events and event sourcing patterns.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对事件是什么以及为什么在高级别使用它们有了很好的了解，让我们专注于事件和事件源模式的更多实际用途。
- en: What can event sourcing patterns do for me?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源模式能为我做些什么？
- en: Applications built with microservices architecture are structured to have a
    set of loosely coupled and independent services. Using the **database-per-service
    pattern**, we further segregate each service by giving it an individual data store.
    This now presents a unique challenge to keep the data in sync between services.
    It becomes more difficult given that we need to compromise on our ACID principles.
    We can recall that the acronym **ACID** stands for **atomicity, consistency, isolation,
    and durability**. We are most concerned about the principle of atomicity in this
    context. We cannot guarantee that all our write operations will be completed as
    a unit. The atomic principle dictates that all data operations should complete
    or fail as a unit. Given the allowance for different technologies to be used for
    the data stores, we cannot absolutely guarantee that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构构建的应用程序被设计成有一组松散耦合且独立的微服务。采用**数据库-服务模式**，我们进一步将每个服务隔离，为它提供一个独立的数据存储。这现在给我们在服务之间保持数据同步带来了独特的挑战。考虑到我们需要在ACID原则上进行妥协，这变得更加困难。我们可以回忆一下，ACID这个缩写代表**原子性、一致性、隔离性和持久性**。在这个上下文中，我们最关心的是原子性原则。我们无法保证所有的写操作都将作为一个单元完成。原子原则规定，所有数据操作应该作为一个单元完成或失败。鉴于允许使用不同的技术来处理数据存储，我们无法绝对保证这一点。
- en: 'Considering all these factors, we turn to a new pattern called event sourcing,
    which allows us to persist messages that keep track of all the activities occurring
    against data in each service. This pattern is especially useful for asynchronous
    communication between services where we can keep track of all changes in the form
    of **events**. These events can act as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，我们转向一个新的模式，称为事件源，它允许我们持久化跟踪每个服务中数据发生的所有活动的消息。这个模式对于服务之间的异步通信特别有用，我们可以以**事件**的形式跟踪所有变化。这些事件可以充当以下角色：
- en: '**Persistent events**: Events contain enough detail to inform and recreate
    domain objects'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久事件**：事件包含足够的信息来通知和重新创建领域对象'
- en: '**Audit log**: Events are generated with each change, so they can double as
    audits'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计日志**：每次更改都会生成事件，因此它们可以双重作为审计'
- en: '**Entity state identification**: We can use events to view the point-in-time
    state of an entity on demand'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体状态识别**：我们可以使用事件按需查看实体的即时状态'
- en: 'The idea of tracking changes against entities is called **replaying**. We can
    replay events in two steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪实体变化的想法被称为**重放**。我们可以分两步重放事件：
- en: Grab all or partial events stored for a given aggregate.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取为给定聚合存储的所有或部分事件。
- en: Iterate through all events and extract the relevant information to freshen up
    the instance of the aggregate.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有事件并提取相关信息以刷新聚合实例。
- en: Event sourcing is essentially all about querying records in some way using an
    **aggregate ID** and **timestamp**. The aggregate ID represents the unique identifier
    column, or primary key value, for the original record for which the event was
    raised. The timestamp represents the point in time that the event was raised.
    The queries required for this look similar for relational and non-relational event
    stores. The event replay operation requires that we iterate through all the events,
    grab information, and then change the state of the target aggregate. In addition
    to the aggregate ID and timestamp, we will also have all the information needed
    to fill in the bits of data needed for the aggregate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源本质上是通过使用**聚合ID**和**时间戳**以某种方式查询记录。聚合ID代表原始记录的唯一标识符列，或主键值，该记录引发了事件。时间戳代表事件被引发的时间点。为此所需的查询对于关系型和非关系型事件存储看起来相似。事件回放操作要求我们遍历所有事件，获取信息，然后改变目标聚合的状态。除了聚合ID和时间戳之外，我们还将拥有填充聚合所需数据位所需的所有信息。
- en: Now, let us review some of the benefits of using events in our systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下在我们的系统中使用事件的一些好处。
- en: Pros of event sourcing
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件溯源的优点
- en: We have been looking into the idea of tracking the history of operations that
    happen against our data, particularly our aggregates. We have encountered the
    concepts of events and replays. Now let us look at what event replays are, how
    they may benefit us, and what other benefits exist from using events.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究跟踪针对我们的数据发生的操作历史记录的想法，特别是我们的聚合。我们已经遇到了事件和回放的概念。现在让我们看看事件回放是什么，它们可能如何对我们有益，以及使用事件的其他好处。
- en: Event replays and the way that we conduct our updates depend on whether the
    aggregate is a domain class or not. If the aggregate relies on domain services
    for manipulation, we need to be clear that replays are not about repeating or
    redoing commands. A command, based on our understanding of CQRS, changes the state
    and data in the database. This also has the potential of being a long-running
    operation with event-data-generating side effects, which we may not want. A replay
    is about looking at data and performing logic to extract information. On the other
    hand, event replays copy the effects of events and apply them to fresh instances
    of the aggregate. Altogether, stored events may be processed differently relative
    to the application employing the technique.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事件回放以及我们执行更新的方式取决于聚合是否为领域类。如果聚合依赖于领域服务进行操作，我们需要明确，回放并不是关于重复或重做命令。根据我们对CQRS的理解，命令会改变数据库中的状态和数据。这也可能是一个可能产生事件数据的长期运行操作，我们可能不希望这样。回放是关于查看数据并执行逻辑以提取信息。另一方面，事件回放复制事件的效果并将它们应用到聚合的新实例上。总的来说，存储的事件相对于采用该技术的应用程序可能会有不同的处理方式。
- en: Events are bits of data that are stored at a lower level than the plain state.
    This means that we can reuse them to build any projection of the data that we
    need. Ad hoc projects of the data can be used for the read data store in a CQRS
    project structure, data analytics, business intelligence, and even artificial
    intelligence and simulations. Contextually, if we have a stream of events and
    can extract a specific subset, then we can replay them and perform ad hoc calculations
    and processes to generate custom and potentially new information. Events are constant
    and will always be the same now and later. This is an additional benefit in that
    we can always be sure that we will be able to count on the data for consistency.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是存储在比纯状态更低级别的数据。这意味着我们可以重复使用它们来构建我们需要的任何数据投影。在CQRS项目结构中的读取数据存储、数据分析、商业智能，甚至人工智能和模拟都可以使用这些数据的具体项目。从上下文来看，如果我们有一个事件流并且可以提取一个特定的子集，那么我们可以回放它们并执行即兴的计算和流程以生成定制和可能的新信息。事件是恒定的，现在和将来始终相同。这是一个额外的优点，因为我们始终可以确信我们可以依赖数据的一致性。
- en: As in life, for every set of benefits, there is a lingering set of downsides.
    Let us explore some of the general concerns around event sourcing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生活中一样，每一组好处都伴随着一些持续存在的弊端。让我们来探讨一下关于事件溯源的一些普遍关注点。
- en: Cons of event sourcing
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件溯源的缺点
- en: In exploring event sourcing, we must bear in mind that we need to introduce
    an additional data store and additional services that might impede the application’s
    performance. Let us review some concerns.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索事件溯源时，我们必须牢记，我们需要引入额外的数据存储和可能妨碍应用程序性能的额外服务。让我们回顾一些关注点。
- en: Performance is always important in an application. So, when introducing a new
    pattern or set of processes, it is prudent of us to ensure that the performance
    impact is minimal. What happens when we need to process too many events to rebuild
    data? This can quickly become an intensive operation based on the number of logged
    events, which is only going to grow since the event store will be an **append-only**
    data store.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 性能在应用程序中始终很重要。因此，当我们引入新的模式或一系列流程时，我们应谨慎确保性能影响最小。当我们需要处理大量事件以重建数据时会发生什么？这可能会迅速变成一个基于已记录事件数量的密集型操作，而这个数量只会增长，因为事件存储将是一个**只读**的数据存储。
- en: To address this, we take snapshots of the aggregate state and business entities
    that have recently been amended. We can then use these snapshots as a stored version
    of the record and use them as a recent version of the data, sparing the need to
    iterate through potentially many events. This operation is best complimented by
    having a **read-only** data store to pair with our CQRS pattern. The snapshot
    will be used for read operations going forward.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们会对最近修改过的聚合状态和业务实体进行快照。然后我们可以使用这些快照作为记录的存储版本，并作为数据的最新版本使用，从而避免需要迭代大量事件。这个操作最好与我们的CQRS模式配对的**只读**数据存储相辅相成。快照将用于未来的读取操作。
- en: Now that we have looked at some of the more serious implications of this pattern
    and techniques that can be used to reduce the impact it might have on our application,
    let us review how event sourcing and domain events relate to each other so that
    we can strengthen our foundational knowledge.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了该模式的一些更严重的后果以及可以用来减少它对我们应用程序可能产生影响的技巧，让我们回顾一下事件溯源和领域事件是如何相互关联的，以便我们能够加强我们的基础知识。
- en: What are domain events?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是领域事件？
- en: Earlier in this book, we discussed the use of DDD as a design pattern that helps
    us to scope the different services that might be required as we develop our microservices
    application. Events can be employed in the implementation of this pattern to help
    us to model expected outcomes within our bounded contexts. Events are scoped based
    on the ubiquitous language that has been established within the bounded context
    and is informed by decisions within the domain.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期部分，我们讨论了将领域驱动设计（DDD）用作设计模式，帮助我们确定在开发我们的微服务应用程序时可能需要的不同服务。事件可以用于实现此模式，帮助我们在我们限定的上下文中建模预期的结果。事件的范围基于在限定的上下文中建立的通用语言，并受到领域内决策的影响。
- en: 'Within the domain, aggregates are responsible for creating domain events and
    our domain events are usually raised based on the outcome of some user action,
    or command. It is important to note that domain events are not raised based on
    actions such as the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域内，聚合负责创建领域事件，我们的领域事件通常基于某些用户操作或命令的结果而触发。需要注意的是，领域事件不是基于以下操作触发的：
- en: Button clicks, mouse moves, page scroll events, or simple application exceptions.
    Events should be based on the established ubiquitous language of the bounded context.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮点击、鼠标移动、页面滚动事件或简单的应用程序异常。事件应基于限定的上下文中建立的通用语言。
- en: Events from other systems or outside of the current context. It is important
    to properly establish the boundaries between each domain context.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自其他系统或当前上下文之外的事件。正确建立每个领域上下文之间的边界是很重要的。
- en: Simple user requests to the system. A user request at this point is a command.
    The event is raised based on the outcome of the command.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的用户系统请求。在这个阶段，用户请求是一个命令。事件是基于命令的结果触发的。
- en: Now let us get a better understanding of why domain events are integral to implementing
    event sourcing patterns.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来更好地理解为什么领域事件对于实现事件溯源模式至关重要。
- en: Domain events and event sourcing
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域事件与事件溯源
- en: Event sourcing is implemented to provide a single point of reference for the
    history of what has happened within a bounded context. Simply put, event sourcing
    uses domain events to store the states that an aggregate has gone through. We
    have already seen that event sourcing will have us store the record ID, a timestamp,
    and details that help us to understand what the data looked like at that moment.
    Properly implementing **domain events** within a bounded context will lay a foundation
    for a good implementation of event sourcing and so proper scoping and implementation
    are important.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源被实现，以提供一个单一参考点，用于在有限上下文中发生的历史。简单来说，事件溯源使用领域事件来存储聚合体经历过的状态。我们已经看到，事件溯源将使我们存储记录
    ID、时间戳以及帮助我们理解数据当时外观的详细信息。在有限上下文中正确实现 **领域事件** 将为事件溯源的良好实现奠定基础，因此适当的范围和实现非常重要。
- en: Implementing domain events in code can be done relatively simply using the **MediatR**
    library, which was so integral in our CQRS pattern implementation. In the next
    section, we will look at adjusting our application to implement domain events.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **MediatR** 库在代码中实现领域事件可以相对简单，这个库在我们的 CQRS 模式实现中起着至关重要的作用。在下一节中，我们将探讨调整我们的应用程序以实现领域事件。
- en: Exploring domain events in our application
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中探索领域事件
- en: Now, let us consider introducing domain events to our appointment booking system.
    As far as we can see, we have several activities that need to be completed when
    an appointment is booked in our system. We might also need to extend the capabilities
    of our system to support the idea that changes might be needed to the original
    appointment and should be tracked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑将领域事件引入我们的预约预订系统。就我们所见，当在我们的系统中预订预约时，我们需要完成几个活动。我们可能还需要扩展我们系统的功能，以支持可能需要对原始预约进行更改的想法，并且应该跟踪这些更改。
- en: Let us use the email dispatching activity. This needs to happen when an appointment
    is accepted into the system and saved. As it stands, our `CreateAppointmentHandler`
    will handle everything that is needed in the situation. We then run into the challenge
    of separating concerns since we probably don’t want our handler to be responsible
    for too many actions. We would do well to separate our email dispatch operation
    into its own handler.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用电子邮件派发活动。这需要在预约被系统接受并保存时发生。目前，我们的 `CreateAppointmentHandler` 将处理该情况下所需的所有内容。然后我们遇到了分离关注点的挑战，因为我们可能不希望我们的处理器负责太多动作。我们将电子邮件派发操作分离到其自己的处理器中会做得很好。
- en: Using MediatR, we can introduce a new type of handler called `INotificationHandler<T>`.
    This new base type allows us to define handlers relative to data types modeled
    from events that inherit from another MediatR base type, called `INotification`.
    These event types should be named according to the action that it is created to
    facilitate and will be used as the generic parameter in our `INotificationHandler<T>`.
    Our `INotificationHandler<T>` base type will be inherited by a handler or handlers
    that will carry out any specific actions relative to the additional actions required.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MediatR，我们可以引入一种新的处理器类型，称为 `INotificationHandler<T>`。这个新的基类型允许我们定义与从继承自另一个
    MediatR 基类型 `INotification` 的数据类型建模的事件相关的处理器。这些事件类型应该根据其创建的动作来命名，以方便使用，并将作为我们的
    `INotificationHandler<T>` 中的泛型参数。我们的 `INotificationHandler<T>` 基类型将被继承，以执行与所需额外动作相关的任何特定动作。
- en: 'In code, we would want to start with some fundamental base types that will
    help us to define our concrete event types. The first would be `IDomainEvent`,
    which will serve as a base type for all our domain events that will follow. Its
    definition looks something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们希望从一些基本的基类型开始，这将帮助我们定义我们的具体事件类型。第一个将是 `IDomainEvent`，它将作为所有后续领域事件的基类型。其定义看起来像这样：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our interface inherits from MediatR’s built-in `INotification` interface so
    that any derived data type will automatically also be a notification type. This
    `IDomainEvent` interface also helps us to enforce any mandatory data that must
    be present with any event object, such as the date and time of the action.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户界面继承自 MediatR 内置的 `INotification` 接口，因此任何派生的数据类型也将自动成为通知类型。这个 `IDomainEvent`
    接口还帮助我们强制执行任何必须存在于任何事件对象中的数据，例如动作的日期和时间。
- en: 'Now that we have our base types, let us define our derived event class for
    when an appointment gets created. We want to ensure that we name our event type
    in a manner that accurately depicts the action that raised the event. So, we will
    call this event type `AppointmentCreated`. We simply inherit from our `IDomainEvent`
    interface and then define additional fields that correspond with the data that
    is needed for the event to adequately carry out additional work:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本类型，让我们定义我们的派生事件类，用于预约创建时。我们想要确保我们的事件类型名称准确地描述了引发事件的动作。因此，我们将此事件类型命名为
    `AppointmentCreated`。我们简单地从我们的 `IDomainEvent` 接口继承，然后定义与事件所需数据相对应的额外字段：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our `AppointmentCreated` derived event type, we have defined a property for
    our appointment and a constructor that makes sure that an object of `Appointment`
    is present at the time of creation. In this case, it is up to you to decide how
    much or little information you would require for the event to effectively be handled.
    For instance, some types of events might only need the appointment’s ID value.
    Be very sure to scope this properly however, and send as much information as is
    needed. You do not want to send only the ID and then need to query for additional
    details and risk potentially many event handlers trying to fetch details from
    just an ID value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `AppointmentCreated` 派生事件类型中，我们为我们的预约定义了一个属性和一个构造函数，确保在创建 `Appointment`
    对象时存在。在这种情况下，您需要决定您需要多少或多少信息来有效地处理事件。例如，某些类型的事件可能只需要预约的 ID 值。但是，请务必正确地界定范围，发送所需的所有信息。您不希望只发送
    ID，然后需要查询额外的详细信息，并冒着许多事件处理器尝试仅从 ID 值获取详细信息的风险。
- en: Now let us look at defining handlers for our event type. Note that I said *handlers*
    as it is possible and viable to define multiple event handlers based on the event
    that has occurred. For instance, when an appointment gets created, we might have
    a handler that will update the event store with the new record, or have one that
    dispatches an email alert, separate from one that updates a **SignalR** hub, for
    example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何定义我们的事件类型处理器。请注意，我说的是 *处理器*，因为根据发生的事件，定义多个事件处理器是可能且可行的。例如，当预约被创建时，我们可能有一个处理器会更新事件存储的新记录，或者有一个处理器会发送电子邮件警报，与更新
    **SignalR** 集线器等分开。
- en: 'To facilitate updating an event store, we would need to first have a handler
    defined that would look something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于更新事件存储，我们首先需要定义一个看起来像这样的处理器：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our `AppointmentCreated` event type is used as the target type for our `INotificationHandler`.
    This is all it takes to add specific logic sequences to a raised event. This also
    helps us to separate concerns and better isolate bits of code associated with
    raised events. Our notification object contains the appointment record, and we
    can easily use the data we need.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `AppointmentCreated` 事件类型用作我们的 `INotificationHandler` 的目标类型。这就是添加特定逻辑序列到引发事件的全部内容。这也帮助我们分离关注点，更好地隔离与引发事件相关的代码片段。我们的通知对象包含预约记录，我们可以轻松地使用所需的数据。
- en: This code will automatically get fired when the event occurs and handle the
    event-store-update operation accordingly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，此代码将自动触发并相应地处理事件存储更新操作。
- en: 'Let us look at our event handler that will dispatch our email alert:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的将发送电子邮件警报的事件处理器：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice as well that even though we did not have direct access to the patient’s
    record, we had their ID. With that value, we could make a synchronous API call
    to retrieve additional details that can assist us in crafting and dispatching
    the notification email.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们没有直接访问患者的记录，但我们有他们的 ID。有了这个值，我们可以进行同步 API 调用来检索可以帮助我们制作和发送通知电子邮件的额外详细信息。
- en: 'In the same way, if we wanted to define an event handler for SignalR operations,
    we could simply define a second handler for the same event type:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果我们想为 SignalR 操作定义事件处理器，我们可以简单地为相同的事件类型定义第二个处理器：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we can raise an event, we can refactor our application a bit to reflect
    this. We can refactor our `CreateAppointmentHandler` and `CreateAppointmentCommand`
    classes to return an object of `Appointment` instead of the previously defined
    string value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够引发事件，我们可以对我们的应用程序进行一些重构以反映这一点。我们可以重构我们的 `CreateAppointmentHandler` 和 `CreateAppointmentCommand`
    类，使它们返回 `Appointment` 对象而不是之前定义的字符串值：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this adjustment, we can now retrieve an object of the created appointment
    and publish an event from the original calling code, which was in the controller.
    Our `POST` method for our appointments API now looks like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次调整，我们现在可以检索创建的预约对象，并从原始的调用代码（控制器）中发布事件。我们预约 API 的 `POST` 方法现在看起来是这样的：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we use the `Publish` method from the MediatR library to raise an event,
    and all handlers that have been defined to watch for the specified event type
    will be called into action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 MediatR 库中的 `Publish` 方法来引发一个事件，并且所有被定义用于监视指定事件类型的处理器都将被激活。
- en: These refactors to our code will introduce even more code and files, but they
    do assist in helping us maintain a distributed and loosely coupled code base.
    With this activity, we have reviewed how we can cleanly introduce domain events
    to our application, and now we need to appreciate how we can store our events.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码重构将引入更多的代码和文件，但它们确实有助于帮助我们维护一个分布式和松散耦合的代码库。通过这项活动，我们已经回顾了如何干净地引入领域事件到我们的应用程序中，现在我们需要欣赏如何存储我们的事件。
- en: Creating an event store
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建事件存储
- en: Before we get to the scoping phase of creating an event store, it is important
    for us to fully understand what one is. A simple search on the topic might yield
    many results from various sources, with each citing varied definitions. For this
    book, we will conclude that an event store *is an ordered, easily queryable, and
    persistent source of long-term records that represents events that have happened
    against entities in a data store.*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入创建事件存储的范围阶段之前，对我们来说，完全理解什么是事件存储非常重要。对这一主题的简单搜索可能会从各种来源产生许多结果，每个来源都引用了不同的定义。对于这本书，我们将得出结论，事件存储
    *是一个有序的、易于查询的、持久化的长期记录源，它表示数据存储中实体发生的事件*。
- en: In exploring the implementation of a data store, let us break out the key parts
    and how they connect to give the resulting event store. An event record will have
    an aggregate ID, a timestamp, an `EventType` flag, and data representing the state
    at that point in time. An application will persist event records in a data store.
    This data store has an API or some form of interface that allows for adding and
    retrieving events for an entity or aggregate. The event store might also behave
    like a message broker allowing for other services to subscribe to events as they
    are published by the source. It provides an API that enables services to subscribe
    to events. When a service saves an event in the event store, it is delivered to
    all interested subscribers. *Figure 6.1* shows a typical event store architecture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索数据存储实现的过程中，让我们分解关键部分以及它们是如何连接起来以形成最终的事件存储。一个事件记录将包含一个聚合 ID、一个时间戳、一个 `EventType`
    标志，以及表示该时间点状态的 数据。应用程序将在数据存储中持久化事件记录。此数据存储有一个 API 或某种形式的接口，允许为实体或聚合添加和检索事件。事件存储也可能像消息代理一样工作，允许其他服务订阅由源发布的事件。它提供了一个
    API，使服务能够订阅事件。当服务在事件存储中保存事件时，它将被发送给所有感兴趣的订阅者。*图 6.1* 展示了一个典型的事件存储架构。
- en: '![Figure 6.1 – An event store sits between the command handlers of an API and
    the query handler, which may require a different projection of the originally
    stored data](img/Figure_6.1_B19100.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 事件存储位于 API 的命令处理器和查询处理器之间，可能需要以不同的方式投影原始存储的数据](img/Figure_6.1_B19100.jpg)'
- en: Figure 6.1 – An event store sits between the command handlers of an API and
    the query handler, which may require a different projection of the originally
    stored data
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 事件存储位于 API 的命令处理器和查询处理器之间，可能需要以不同的方式投影原始存储的数据
- en: Let us review event storage strategies that we can employ.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们可以采用的存储策略。
- en: How to store events
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何存储事件
- en: We have already established that events should be immutable, and the data store
    should be append-only. Armed with these two requirements, we can deduce that our
    dos and don’ts need to be at a minimum as we scope the data store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定事件应该是不可变的，数据存储应该是追加的。有了这两个要求，我们可以推断出，在确定数据存储的范围时，我们的 dos 和 don'ts 至少需要是最小的。
- en: Each change that takes place in the domain needs to be recorded in the event
    store. Since events need to contain certain details relevant to the event being
    recorded, we need to maintain some amount of flexibility with the structure of
    the data. An event might contain data from multiple sources in the domain. That
    means that we need to leverage possible relationships between tables in order
    to grab all the details required to log the event.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 领域中发生的每个变化都需要记录在事件存储中。由于事件需要包含与所记录事件相关的某些细节，我们需要在数据结构上保持一定的灵活性。一个事件可能包含来自领域多个来源的数据。这意味着我们需要利用表之间的可能关系来获取记录事件所需的所有细节。
- en: This makes the standard relational database model less feasible as a data store
    for events since we want to be as efficient as possible in retrieving our event
    records for auditing, replay, or analytics later. If we are using a relational
    data store, then we would do well to have denormalized tables modeled from the
    event data that we intend to store. An alternative and more efficient manner to
    handle event storage is the use of a non-relational or NoSQL database. This will
    allow us to store the relevant event data as documents in a far more dynamic manner.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得标准的关系数据库模型作为事件数据存储库变得不太可行，因为我们希望在检索事件记录进行审计、回放或分析时尽可能高效。如果我们使用关系型数据存储，那么最好有从我们打算存储的事件数据中建模的规范化表。处理事件存储的另一种更有效的方法是使用非关系型或NoSQL数据库。这将使我们能够以更动态的方式将相关事件数据作为文档存储。
- en: Let us explore some options regarding storing events in a relational database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一些关于在关系数据库中存储事件的选择。
- en: Implementing event sourcing using a relational database
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关系数据库实现事件溯源
- en: We have already reviewed some of the drawbacks of using a relational database
    as the event store. In truth, the way you design this storage, alongside the technology
    that is used, can have a major bearing on how future-proofed your implementation
    will be.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经审查了使用关系数据库作为事件存储的一些缺点。实际上，你设计这种存储的方式以及所使用的技术的选择，将对你的实现将如何适应未来产生重大影响。
- en: If we go the route of using denormalized table representations of the events,
    then we will end up going down a rabbit hole of modeling several tables based
    on several different events. This might not be sustainable in the long run, since
    we would need to introduce new tables with each newly scoped event and constantly
    change designs as the events evolve.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择使用事件的非规范化表表示，那么我们最终会陷入根据多个不同事件建模多个表的兔子洞。从长远来看，这可能不可持续，因为我们需要为每个新范围的事件引入新表，并且随着事件的发展不断更改设计。
- en: 'An alternative would be that we create a singular log table that has columns
    that match the data points we just outlined. For example, this table and the matching
    data types would be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是创建一个单独的日志表，其列与我们所概述的数据点相匹配。例如，此表及其匹配的数据类型如下所示：
- en: '| **Column Name** | **Data Type** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **Column Name** | **Data Type** |'
- en: '| **Id** | `Int` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | `Int` |'
- en: '| **AggregateId** | `Guid` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **AggregateId** | `Guid` |'
- en: '| **Timestamp** | `DateTime` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **Timestamp** | `DateTime` |'
- en: '| **EventType** | `Varchar` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **EventType** | `Varchar` |'
- en: '| **Data** | `Varchar` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **Data** | `Varchar` |'
- en: '| **VersionNumber** | `Int` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **VersionNumber** | `Int` |'
- en: '**Id**: Unique identifier for the event record.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Id**: 事件记录的唯一标识符。'
- en: '**AggregateId**: Unique identifier for the aggregate record to which the event
    is related.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AggregateId**: 与事件相关联的聚合记录的唯一标识符。'
- en: '**Timestamp**: The date and time that this event was logged.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Timestamp**: 记录此事件时的日期和时间。'
- en: '**EventType:** This is a string representation of the name of the event that
    is being logged.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventType:** 这是正在记录的事件名称的字符串表示。'
- en: '**Data:** This is a serialized representation of the data associated with the
    event record. This serialization is best done in an easy-to-manipulate format
    such as **JSON**.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Data:** 这是与事件记录相关联的数据的序列化表示。这种序列化最好在易于操作的格式中完成，例如**JSON**。'
- en: '**VersionNumber**: The version number helps us to know how to sort events.
    It represents the sequence in which each new event was logged in the stream and
    should be unique to each aggregate.We can add constraints to our records by introducing
    a **UNIQUE** index on both the **AggregateId** and **VersionNumber** columns.
    This will help us with speedier queries and ensure that we do not repeat any combination
    of these values.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VersionNumber**：版本号帮助我们了解如何排序事件。它表示每个新事件在流中记录的顺序，并且应该对每个聚合是唯一的。我们可以通过在**AggregateId**和**VersionNumber**列上引入一个**UNIQUE**索引来对我们的记录添加约束。这将帮助我们加快查询速度，并确保我们不会重复这些值的任何组合。'
- en: The type of database technology that is employed does play a part in how flexibly
    and efficiently we can store and retrieve data. The use of **PostgreSQL** and
    later versions of **Microsoft SQL Server** will see us reap the advantages of
    being able to manipulate the serialized representation of the data more efficiently.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的数据库技术类型确实在我们如何灵活和高效地存储和检索数据方面起着作用。使用**PostgreSQL**和**Microsoft SQL Server**的后续版本将使我们能够更有效地操作数据的序列化表示。
- en: Now let us look at how we can model our NoSQL data stores.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何对NoSQL数据存储进行建模。
- en: Implementing event sourcing using a non-relational database
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非关系型数据库实现事件溯源
- en: '**NoSQL databases** are also called **document databases** and are characterized
    by their ability to effectively store unstructured data. This means the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**NoSQL数据库**也被称为**文档数据库**，其特点在于能够有效地存储非结构化数据。这意味着以下内容：'
- en: Records do not need to meet any minimum structure. Columns are not mandated
    in the design phase, so it is easy enough to extend and contract the data based
    on the immediate need.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录不需要满足任何最小结构。在设计阶段不需要指定列，因此根据即时需求扩展和缩减数据很容易。
- en: Data types are not strictly implemented, so the data structure can evolve at
    any point in time without having detrimental effects on previously stored records.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型不是严格实现的，因此数据结构可以在任何时间点演变，而不会对先前存储的记录产生不利影响。
- en: Data can be nested and can contain sequences. This is significant since we do
    not need to spread related data across multiple documents. One document can represent
    a denormalized representation of data from several sources.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以嵌套并且可以包含序列。这一点很重要，因为我们不需要将相关数据分散在多个文档中。一个文档可以代表来自多个来源的数据的非规范化表示。
- en: Popular examples of document stores are **MongoDB**, **Microsoft Azure Cosmos
    DB**, and **Amazon DynamoDB**, to name a few. Outside of the specific querying
    and integration requirements for each of these database options, the concepts
    of how documents are formed and stored are the same.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的文档存储示例包括**MongoDB**、**Microsoft Azure Cosmos DB**和**Amazon DynamoDB**等。除了每个数据库选项的特定查询和集成要求之外，文档的构建和存储的概念是相同的。
- en: 'We can outline the properties of the document in a very similar manner to how
    a table would look. In a document data store, however, the data is stored in JSON
    format (unless specifically requested or implemented otherwise). An event entry
    would look something like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用与表格类似的方式概述文档的属性。然而，在文档数据存储中，数据以JSON格式存储（除非特别要求或实施其他方式）。一个事件条目可能看起来像这样：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another advantage to using a document data store is that we can more easily
    represent a record with its event history in a materialized view. That could look
    something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文档数据存储的另一个优点是，我们可以在物化视图中更容易地表示带有其事件历史的记录。这可能看起来像这样：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This type of data representation can be advantageous for retrieving a record
    with all its events, especially if we intend to display this data on a user interface.
    We have generated a view that acts as both a snapshot of the current state of
    the aggregate data and the stream of events that have affected it. This form of
    data aggregation helps us to reduce some complexity and keep the concept of event
    retrieval simple.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的数据表示对于检索包含所有事件的记录可能是有利的，特别是如果我们打算在用户界面上显示这些数据。我们已经生成了一个视图，它既充当了聚合数据的当前状态的快照，也充当了影响它的事件流。这种形式的数据聚合有助于我们减少一些复杂性，并保持事件检索的概念简单。
- en: Now that we see how we can implement a read-only and denormalized data store,
    let us review how we can use the CQRS pattern to retrieve the latest state of
    the data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到我们如何实现只读和非规范化的数据存储，让我们回顾一下我们如何使用CQRS模式来检索数据的最新状态。
- en: Reading state with CQRS
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CQRS读取状态
- en: We have reviewed the CQRS pattern, and we see where we can create handlers that
    will perform write operations. Earlier in this chapter, we enhanced our command
    handler functionality with the ability to trigger events, which are capable of
    performing triggering additional actions after a command has been completed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经回顾了 CQRS 模式，并看到我们可以在哪里创建执行写操作的处理器。在本章早期，我们通过触发事件增强了命令处理器的功能，这些事件在命令完成后能够触发额外的操作。
- en: In the context of the event sourcing pattern, this additional action involves
    updating our read-only data stores with the appropriate data per view. When creating
    our query handlers, we can rely on these tables for the latest version of the
    data that is available. This ties in perfectly with the ideal implementation of
    the CQRS pattern where separate data stores are to be used for read and write
    operations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件溯源模式的背景下，这个额外操作包括使用适当的数据更新我们的只读数据存储。在创建我们的查询处理器时，我们可以依赖这些表来获取最新版本的数据。这与 CQRS
    模式的理想实现完美结合，其中应使用不同的数据存储来执行读取和写入操作。
- en: It also presents an excellent opportunity for us to provide more specific representations
    of the data we wish to present from our read operations. This approach, however,
    introduces the risk that our data stores might become out of sync in between operations,
    which is a risk that we must accept and mitigate as best as possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这也为我们提供了一个极好的机会，让我们能够提供更多具体的数据表示，这些数据是我们希望从读取操作中展示的。然而，这种方法引入了风险，即我们的数据存储在操作之间可能会变得不同步，这是我们必须接受并尽可能减轻的风险。
- en: Now that we have explored events, event sourcing patterns, and event storage
    options, let us review these concepts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了事件、事件溯源模式和事件存储选项，让我们回顾这些概念。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Event sourcing and event-driven design patterns bring a whole new dimension
    to what is required in our software implementation. These patterns involve additional
    code but do assist in helping us to implement additional business logic for completed
    commands while maintaining a reliable log of all the changes happening in our
    data store.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源和事件驱动设计模式为我们的软件实现所需的内容带来了全新的维度。这些模式涉及额外的代码，但确实有助于我们在保持数据存储中所有变化可靠日志的同时，实现完成命令的附加业务逻辑。
- en: In this chapter, we explored what events are, various factors of event sourcing
    patterns, how we can implement certain aspects in a real application, and the
    pros and cons of using relational or non-relational storage options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了事件是什么，事件溯源模式的各种因素，如何在真实应用程序中实现某些方面，以及使用关系型或非关系型存储选项的优缺点。
- en: In our next chapter, we will explore the Database Per Service pattern and look
    at best practices when implementing the data access layer in each microservice.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据库按服务模式，并查看在实现每个微服务的数据访问层时的最佳实践。
- en: 'Part 2: Database and Storage Design Patterns'
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：数据库和存储设计模式
- en: Understanding and implementing data management patterns and techniques is vital
    when designing a microservices application. Each microservice might need its database,
    and we need to understand the intricacies surrounding managing each database and
    how we coordinate efforts across services. By the end of this part, you will come
    to appreciate the tough decisions that need to be made surrounding databases in
    a microservices application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务应用程序时，理解和实现数据管理模式和技巧至关重要。每个微服务可能需要其自己的数据库，我们需要了解管理每个数据库的复杂性以及我们如何在服务之间协调努力。在本部分结束时，你将开始欣赏在微服务应用程序中围绕数据库需要做出的艰难决定。
- en: 'This part has the following chapters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B19100_07.xhtml#_idTextAnchor108), *Handling Data for Each Microservice
    with the Database per Service Pattern*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19100_07.xhtml#_idTextAnchor108)，*使用数据库按服务模式处理每个微服务的数据*'
- en: '[*Chapter 8*](B19100_08.xhtml#_idTextAnchor127), *Implement Transactions across
    Microservices Using the Saga Pattern*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19100_08.xhtml#_idTextAnchor127)，*使用 Saga 模式在微服务间实现事务*'
