- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we’ve looked at how powerful metaprogramming can be in .NET
    at runtime. Doing everything at runtime has the benefit of the flexibility to
    adapt to things that occur at runtime. The downside of doing this at runtime is
    that it has a performance impact. This is where the C# Roslyn compiler really
    shines. We had the capability to generate code in the past with commercial products
    such as PostSharp ([https://www.postsharp.net/](https://www.postsharp.net/)) or
    **Intermediate Language** (**IL**) weaving, using projects such as Fody ([https://github.com/Fody/Fody](https://github.com/Fody/Fody))
    But with Roslyn, code generation has truly been democratized and made easy for
    anyone to do.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I’ve worked with all the techniques throughout the years, and finally,
    with Roslyn, I can realize a lot of the metaprogramming I like to do without sacrificing
    performance. And I can do so in a more consistent way than before.
  prefs: []
  type: TYPE_NORMAL
- en: The C# Roslyn compiler enables this by allowing developers to be part of its
    compilation pipeline through a set of APIs. With the APIs, we can investigate
    the code that’s there and reason about it and then generate new code, which will
    then be compiled and incorporated into the final binary.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore how to leverage Roslyn compiler extensions for
    generating code, taking a deep dive into the specifics of generating code at compile
    time. We’ll learn how to examine syntax trees and generate additional code, and
    even look at how to use Roslyn to generate text reports from your code via metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating additional code for the Roslyn compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Ab)using the compiler to generate not just C# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the developer experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a strong grasp of how to use Roslyn
    to generate code at compile time, and you’ll have a toolkit of techniques and
    best practices for implementing metaprogramming techniques in C# that leverage
    the power of the Roslyn compiler platform. So, let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to this chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16))
    and builds on top of the **Fundamentals** code, which can also be found on GitHub
    ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  prefs: []
  type: TYPE_NORMAL
- en: Generating additional code for the Roslyn compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful capabilities of the Roslyn compiler platform is the
    ability to generate additional code at compile time. This means that we can create
    new C# code during the compilation process and have it compiled alongside the
    rest of our code.
  prefs: []
  type: TYPE_NORMAL
- en: We will look into how you can leverage Roslyn to generate additional code for
    the compiler. This is super helpful and can help increase your and your team’s
    productivity by removing the need for repetitive tasks. Since you’re working inside
    the compiler, you’ll have to work with the language the compiler understands and
    how it represents code – **Abstract Syntax** **Trees** (**ASTs**).
  prefs: []
  type: TYPE_NORMAL
- en: ASTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **AST** is a data structure used to represent the structure of source code.
    You can compare it to what you already find in the .NET Expression APIs, as we
    saw in *Chapter 7*, *Reasoning about Expressions*. It is a hierarchy consisting
    of nodes that represent the code elements found in the language, such as classes,
    methods, fields, and properties. The outcome from the compiler from the AST is
    in its final stage of the binary IL code. While Expressions do this at runtime
    and are mutatable at runtime, ASTs are static when entering the final stage of
    the compiler pipeline. However, until the final stage, the AST can be reasoned
    about and changed.
  prefs: []
  type: TYPE_NORMAL
- en: The AST is constructed by parsing the source code, interpreting all the keywords
    and variables, and breaking it down into nodes, which then sit together in a tree-like
    structure. ASTs are used as an intermediate representation of code within compilers
    or code analysis tools. Once the source code has been converted into an AST, it
    becomes much easier to analyze and manipulate the code. For example, a tool might
    use an AST to identify potential bugs or transform the code in some way.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of Roslyn is its extensibility. Because Roslyn is open
    source and provides a rich set of APIs for working with the AST, developers can
    easily create their own code analysis tools that leverage the compiler’s AST.
    For example, a developer might create a tool that analyzes code for security vulnerabilities,
    or a tool that automatically generates documentation for a code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easy for developers to extend Roslyn, the platform provides a number
    of extensibility points, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax trees**: Developers can create their own syntax trees to represent
    code, and use them with the Roslyn APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Syntax rewriters**: Developers can create syntax rewriters that transform
    the AST in various ways, such as renaming variables or extracting methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diagnostics**: Developers can create their own diagnostics that identify
    issues with code, such as potential bugs or style violations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code fix providers**: Developers can create code fix providers that automatically
    fix any issues identified by diagnostics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these extensibility points, Roslyn makes it easy for developers to create
    extensions that can improve the quality of the code written or improve productivity
    by automatically generating plumbing code.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler theory and how ASTs work is a big topic on its own, something that
    is outside the scope of this book. Instead, let's get our hands dirty and get
    a glimpse of what can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Application metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect of running systems in production is observability. By observability,
    I mean the ability to observe important aspects of an application. Logging is
    one of these aspects, where you instrument your code with log messages that get
    written and captured by a log search indexer. Logging can be very verbose, so
    it is not ideal for simple measurement values, such as counters, gauges, or histograms.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of .NET 6, Microsoft introduced a namespace called **System.Diagnostics.Metrics**.
    The classes in this new namespace are perfect for when you want to observe values
    that change over time. In addition to this, there are packages out there that
    support **OpenTelemetry** ([https://opentelemetry.io](https://opentelemetry.io)),
    enabling you to capture the different values in popular collectors such as Prometheus,
    Azure AppInsight, and more. For our sample, we will just be using the console
    viewer.
  prefs: []
  type: TYPE_NORMAL
- en: With how Microsoft has built support for metrics, it’s very easy to use while
    it lacks the nice and structured approach Microsoft built for logging. To see
    the issue, we’ll start by using the metrics as intended from the out-of-the-box
    experience and then improve on it. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a new project for the chapter. You should create this
    new project next to the **Fundamentals** project you have been using throughout
    the book and also the **Roslyn.Extensions** project that was established in [*Chapter
    15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn* *Compiler Extensions*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a folder called **Chapter16**, change into this folder on your command
    line, and create a new web project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should know the basics of a web project. Let’s change it so that we can
    use controllers. Change the **Program.cs** file to look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds the controllers to **builder.Services** and then maps all the
    controllers in your application before running the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the goal is to capture metrics, you’re going to need what is called a
    **Meter**, which is used for the values you want to track. You can have multiple
    **Meter** classes for different areas of your system if you want, but it is common
    to have one per application. Add a file called **Metrics.cs** and make it look
    like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code pulls in the **System.Diagnostics.Metrics** namespace and then exposes
    a global **Meter** called **Chapter16**. This can then be used by any code in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now want to add something that creates values within the meter. Add a file
    called **EmployeesController.cs** and make it look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code introduces a web API controller with a single action that lives in
    the **/api/employees** route. The action only returns **Ok()** – an HTTP 200 status.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we’re not focused on the functionality of what we’re building
    but rather focused on the technical problem we’re trying to solve. For this reason,
    we also make it accept an HTTP **GET**. Normally, it would be an HTTP **POST**
    and also include a payload with details about the employee to register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s instrument the code with a counter for counting the number of registered
    employees. To do this, you’ll need to add a couple of **using** statements at
    the top of the **EmployeeController.cs** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can add a counter in the **EmployeesController** class. Add the following
    at the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code introduces a counter that is created using the global meter. It is
    created statically so that we don’t create multiple instances of the same counter
    in the same application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the counter, change the **Register()** method to look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code uses the **_registeredEmployees** counter by calling the **Add()**
    method on it. It also passes along tags, which it sets up before calling **Add()**.
    Tags are a way to group values being added. The counter, from a top level, will
    then aggregate all values tagged, while you can monitor each individual tagged
    value on its own. This is super helpful for breaking down the metrics you want
    to monitor. The **Register()** method breaks down the values by year, month, and
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Tag values are **object**. You could pass it a **DateOnly** instance instead,
    but this illustrates the use of multiple tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the first counter in place, it is time to see what this actually looks
    like. To do so, you need to install a tool called **dotnet-counters**. This is
    done by running the following in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then. you can start your application by running this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal, you can start the metrics monitor by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should then see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there haven’t been any requests yet to the API endpoint, the value won’t
    show up yet. Keep the monitor running and open a browser and navigate to the endpoint
    (for example, **http://localhost:5000/api/employees**); you should then see something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The value will be sampled once per second. If you hit your browser multiple
    times, you should see **0** at the end of the line increase and then fall back
    to **0**. This is expected as it just shows the current measurements and not an
    aggregate over time.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the metrics API in .NET is simple and easy to use, it can quite
    easily become very verbose, especially when you have tags you want to associate.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the developer experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your business code, it looks strange to have the setup code for metrics on
    every method. It is also very verbose and cumbersome. Imagine an evolved application
    with a lot of metrics you want to collect; it kinda becomes messy. You can obviously
    clean this up by encapsulating the metrics, either with methods in the classes
    that need metrics or pulled out into their own classes.
  prefs: []
  type: TYPE_NORMAL
- en: However, I quite like the approach Microsoft has to logs, as we saw in [*Chapter
    14*](B19418_14.xhtml#_idTextAnchor219), *Aspect-Oriented Programming*. For its
    approach to logging, it relies on a code generator that runs at compile time and
    puts in code that gets included in the finished binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s mimic this and create an improved developer experience:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **Fundamentals** project, create a folder called **Metrics**. In
    this folder, add a file called **CounterAttribute.cs** and make it look like the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code introduces an attribute that represents a counter. Counters can have
    a name and description associated with them. It is a generic attribute, allowing
    you to specify the type used for the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Metrics** folder in the **Fundamentals** project, add a file called
    **GlobalMetrics.cs** and make it look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This introduces a globally accessible **Meter** instance, which will make it
    predictable for the code generator you’ll be building, as it will need access
    to this. However, it defaults to a meter called **Global**, which we want to override.
    Open the **Program.cs** file within **Chapter16** and add the following at the
    top of the file after the **using** statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The goal of this chapter is to provide a simpler way of doing metrics. This
    will be done through the technique of creating a partial class providing method
    signatures without implementations. The source code generator will create an implementation
    of the partial class and provide implementations for each of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the metrics file for **EmployeesController**. Add a file called **Employees**
    **ControllerMetrics.cs** and add the following to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code sets up a static partial class, which is important as this will be
    a criterion for finding which classes to generate source code for. All counters
    are then represented as methods with a given name and a **[Counter]** attribute
    with details. Every parameter on the method will be used as a tag.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now prepared the basics needed for the source code generator to be able
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the code template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code generator will generate the code that will implement partial classes.
    To do this, you’ll use a template file that represents the source code to generate.
    As a template language, you’re going to be using something called **Handlebars**
    ([https://handlebarsjs.com](https://handlebarsjs.com)). There is a .NET implementation
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Roslyn.Extensions.csproj** file in the **Roslyn.Extensions** folder
    and add the following package reference in an **ItemGroup** with the other package
    references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The **PrivateAssets="all"** attribute instructs it to be a reference only for
    this project and only be used with the extension itself, meaning that any assemblies
    from **Handlebars** will not be included in any projects referencing this project.
    In addition, you have to set **GeneratePathProperty="true"**. This will create
    a variable specific to the package and allow us to instruct which specific assembly
    of **Handlebars** to use; otherwise, the compiler will say **FileNotFoundError**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the correct assembly, add the following to **Roslyn.Extensions.csproj**
    in the **Roslyn.Extensions** folder at the end of the file, within the **Project**
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With **Handlebars** properly installed, you’re ready to create the template
    you need for generating the code. Before you create the template, you’ll need
    to set up all the types of data you’ll pass to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Roslyn.Extensions** folder, create a folder called **Metrics**. Add
    a file called **MetricsTemplateData.cs** and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**MetricsTemplateData** will be the root object being passed to the template.
    It contains the namespace for the generated code and then the class name for the
    class that will be generated. It then goes on to hold a collection of all the
    counters it will generate for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the counter definitions, add a file called **CounterTemplateData.cs** and
    add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The **CounterTemplateData** type holds information about the type of counter,
    the method name representing it, the name of the counter, and a description to
    be used with the counter. Lastly, it holds all the tags associated with the counter
    when called.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the tag definition, add a file called **CounterTagTemplateData.cs** and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The tag contains a type, which will be reflected in the signature of the method
    being called and then the name.
  prefs: []
  type: TYPE_NORMAL
- en: With the object definitions for the parameters for the template, it’s time to
    add the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Roslyn.Extensions** folder, create a folder called **Templates**,
    and within the **Templates** folder, add a file called **Metrics.hbs** and make
    it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Within the template, there is data context. The top-level item will be the **MetricsTemplateData**
    instance. This is where the **{{Namespace}}** and **{{ClassName}}** values are
    inserted. The use of **{{}}** with text represents values that can be replaced,
    and the text itself is then a property that exists in the current context it’s
    in. When the value in the quotes starts with a **#** symbol, it uses a function
    to resolve it. Handlebars have some automatic magic and recognize enumerables,
    such as **Counters**. Handlebars will loop through these and anything within its
    scope will be output for each instance. The template uses these techniques throughout
    to replace all the values found in the objects passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result for **EmployeesControllerMetrics** will end up rendered like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the template in place, we need a way to programmatically access it in the
    code generator. To enable that, you want to embed any template files into the
    assembly at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **Roslyn.Extensions.csproj** and add an **ItemGroup** within the **Project**
    tag that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The **EmbeddedResource** tag instructs the compiler to include all **hbs** files
    within the **Templates** folder and make them embedded resources of the assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded resources are part of the assembly and are referred to as resources.
    They can be accessed directly on the assembly they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a helper class to get access to the template and future templates
    you’ll be adding. In the **Templates** folder of the **Roslyn.Extensions** project,
    add a file called **TemplateTypes.cs**. Make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces a private method called **GetTemplate()** on the **TemplateTypes**
    class. It leverages **GetManifestResourceStream()** on the assembly instance.
    The compiler will by convention make namespaces of the folder and any subfolder
    of the embedded resource. Accessing the resources will then be like accessing
    types in it. Since the template sits in the **Templates** folder, it will be in
    the same folder and then the same namespace as the **TemplateTypes** class. This
    is therefore used as the prefix for the name of the template before the name of
    the template. The code then uses a **StreamReader** to read the resource stream
    to the end, giving you a string holding the template.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the **TemplateTypes** class sits a property representing the **Metrics**
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the template and code for accessing it, you can move on to creating
    the code generator.
  prefs: []
  type: TYPE_NORMAL
- en: Building the source code generator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order for the code generator to generate code only for classes that match
    the criteria, you need a syntax receiver that gets called on every node from the
    source code being compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **MetricsSyntaxReceiver.cs** in the **Metrics** folder within
    the **Roslyn.Extensions** project. Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The code implements the **ISyntaxReceiver** interface with the **OnVisitSyntaxNode()**
    method, which will be called on every AST node from the compiler. The purpose
    of **MetricsSyntaxReceiver** is to narrow down what classes are of interest for
    code generation. First, it filters down by requiring it to be a **class**, then
    it looks as if the class is partial and static. The last filter is to look for
    any members of the class, looking for static partial methods. If all of the criteria
    are met, it will add the class to a candidate list.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the receiver filtering down, it’s time for the generator itself to be
    set up. Next to the **MetricsSyntaxReceiver.cs** file, add a file called **MetricsSourceGenerator.cs**.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code creates a class called **MetricsSourceGenerator**, which implements
    the **ISourceGenerator** interface with its **Execute()** and **Initialize()**
    methods. For the generator to work, you also have to add the **[Generator]** attribute.
    In the **Initialize()** method, the code registers the syntax receiver you put
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Execute()** method is where all the magic will happen. Let’s start
    by adding the following to the body of the **Execute()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The code is expecting **SyntaxReceiver** to be **MetricsSyntaxReceiver**; if
    it’s not, it’s just returned. Then, it goes on to get an instance of the type
    definition for the **CounterAttribute** type. Notice the name is a little strange;
    **CounterAttribute'1**. This is because the type is a generic type and internally
    in .NET, the type will get the postfix with a number of saying the number of generic
    arguments it has.
  prefs: []
  type: TYPE_NORMAL
- en: For all the candidates **MetricsSyntaxReceiver** has found, the code loops through
    and sets up a **MetricsTemplateData** instance for the class. It then gets what
    is known as the semantic model based on the syntax tree of the class. The semantic
    model in Roslyn provides a deeper understanding of the meaning of code beyond
    its syntax. It can be used for tasks such as name binding, type checking, error
    checking, and automated refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Classes have members and the code walks through all the members and filters
    and skips those that are not methods. From the semantic model, it gets the declared
    symbol of the method, which lets us nicely access the attributes on it. It then
    looks for **CounterAttribute**.
  prefs: []
  type: TYPE_NORMAL
- en: At the very end, it generates the source code from the template, but only if
    there are any counters to generate for. It provides the source code by using the
    **AddSource()** method provided by **GeneratorExecutionContext**. The convention
    for generated files is to include the type name and then postfix it with **.g.cs**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the generator to kick in, it needs the counters. Add the following code
    to the **Execute()** method, replacing the **//** **Generate** comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code gathers the information from the attribute and method information to
    provide the data the template needs.
  prefs: []
  type: TYPE_NORMAL
- en: That is pretty much it for the generator to work. Since we’re leaning on the
    setup done in [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn Compiler
    Extensions*, all we now need to do is start using it.
  prefs: []
  type: TYPE_NORMAL
- en: Test driving the source generator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get the **Chapter16** code compiled and working, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to add a reference to the **Fundamentals** project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you need a reference to the **Roslyn.Extensions** project. This needs
    to be a little bit different since you want it to automatically use the generator.
    Add a **ProjectReference** in the **Chapter16.csproj** file next to the reference
    to the **Fundamentals** project, looking like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This instructs the reference to use the analyzer and not include any of its
    assemblies in the output of **Chapter16**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the new way of doing metrics, you’ll need to change the **EmployeeController**
    class. Open the **EmployeeController.cs** file in the **Chapter16** folder and
    change the **Register()** method to look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code now uses the new partial class instead of dealing with the counter
    and tags itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform a build on the **Chapter16** project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **obj** folder, you can now see the result of the source generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Generated file in the filesystem
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **EmployeesControllerMetrics.g.cs** and confirm you have the expected
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run your project and then start the monitor by running this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then trigger the API by using a browser and navigating to the endpoint
    (for example, **http://localhost:5000/api/employees**). You should see an output
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This technique can be very powerful. More types of metrics can be supported
    and extended, giving you a more intuitive and simple way of working with metric
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding source code that gets compiled is very powerful and you are not limited
    to adding just partial classes; you can in fact add anything you want, which can
    be super useful. That being said, you’re not just limited to outputting source
    files for the compiler. You can produce other artifacts as well.
  prefs: []
  type: TYPE_NORMAL
- en: (Ab)using the compiler to generate not just C# code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since you can basically do anything within the code generator, you could go
    and generate anything else. One of the things we use it for in my day-to-day work
    is to generate TypeScript files from our C# code. This is super useful and we
    save a lot of time and gain consistency in the TypeScript, in line with the REST
    APIs in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go and do something that doesn’t end up in a C# file. Based on the **Fundamentals**
    project in the GitHub repository and what you have built so far in the book, you
    should have a namespace called **Fundamentals.Compliance.GDPR** and an attribute
    called **PersonalIdentifiableInformation**, which was introduced in [*Chapter
    5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is great for marking types that collect **Personally Identifiable
    Information** (**PII**) as well as the reason for collecting PII. In [*Chapter
    5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*, we used it at
    runtime to create a runtime report. What we could instead do is create this report
    at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file in the **Chapter16** folder called **Employee** and make it look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The **Employee** type has its properties annotated with the **[PersonalIdentifiableInformation]**
    attribute, declaring the specific reason for collecting the information. This
    is what we want to output in a GDPR report saying which types have members that
    hold PII.
  prefs: []
  type: TYPE_NORMAL
- en: Building the generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for our generator to know where to output the resulting file, it will
    need a configurable property. The current directory when running in the context
    of the compiler will be the path where the compiler sits and typically a place
    you don’t have write access to write to. Besides, it is not very useful to write
    files at a random location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generators can have properties that get configured in the **.csproj** files.
    For them to be visible to the generator, you need to tell the compiler that the
    property should be visible. To do this, open the **Roslyn.Extensions.props** file,
    which you should have in the **Roslyn.Extensions** folder, and add an **ItemGroup**
    within the **Project** tag that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the **Chapter16.csproj** file in the **Chapter16** folder, you will
    need to add a reference to the **props** file. Add the following at the top of
    the file within the **Project** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, within **PropertyGroup**, you need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This configures the **GDPRReport** variable to point to the folder of the **Chapter16.csproj**
    file and then adds **GDPRReport.txt** to the path.
  prefs: []
  type: TYPE_NORMAL
- en: As you did with the metrics source generator, you’ll need a syntax receiver
    for filtering the candidates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called **GDPR** in the **Roslyn.Extensions** project and add
    a file called **GDPRSyntaxReceiver.cs**. Make the file look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The filter for this syntax receiver is a simple one. It’s interested in syntax
    nodes that are types. This would include classes and records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need the source generator. Add a file called **GDPRSourceGenerator.cs**
    alongside the **GDPRSyntaxReceiver.cs** file and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up the basics for the source generator and also sets up the initials
    for the **Execute()** method. It will only perform the job if **SyntaxReceiver**
    is **GDPRSyntaxReceiver**. Next, it goes and gets the **GDPRReport** variable
    from config. All values are prefixed with **build_property** for the ones coming
    from the build. It then goes on to create the report file before it gets the **PersonalIdentifiableInformationAttribute**
    type for filtering later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue the **Execute()** method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The code looks at the candidates from the syntax receiver. If the candidate
    is a record, it enumerates the parameters of it and adds them as a symbol of interest.
    It then goes on to walk through the members of the candidate, adding them as a
    symbol of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve collected all symbols of interest, it’s time to filter down
    only the symbols that are annotated with the **PersonalIdentifiableInformation**
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the candidates **foreach** loop, add the following at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code iterates the symbols by looking at any attributes. If the symbol has
    the **[Personal** **IdentifiableInformation]** attribute, it’s added to the **memberNamesAndReason**
    list.
  prefs: []
  type: TYPE_NORMAL
- en: If there are members in the **memberNamesAndReason** list, it outputs the type
    and the members with the reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can build your application (in the **Chapter16** folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see a file called **GDPRReport.txt** in your project folder.
    Open it and confirm that you’re seeing something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Having this level of transparency in your code and the ability to show it to
    official auditors is great. It shows you have control over compliance and this
    will ultimately help you in the long run. You could also version this file by
    simply adding it to your source code repository and then during release builds,
    you could commit any changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: It is different to work with extending the compiler itself, it is a somewhat
    different runtime environment from what you’d expect in normal application development.
    You’ve probably already started asking how to debug and might have experienced
    your code not working even though it should have.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the developer experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with the Roslyn compiler can be hard. After all, it’s running inside
    the context of the compiler. One way to ease the pain is to do unit testing and
    actually test all your code from tests, something we will look into more in [*Chapter
    17*](B19418_17.xhtml#_idTextAnchor299), *Static* *Code Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, sometimes, you just simply need to see things with your bare eyes
    through the debugger. The technique I use for this is to add the following code
    into my Roslyn extension code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I can put breakpoints for the places at which I want to break and then
    attach the debugger. You want to attach it to the compiler and it typically shows
    up like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Compiler process to attach to caching
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing that can be painful is if you’re doing changes in the extension
    and these are not reflected. There are a couple of reasons why this might be the
    case. One is that it doesn’t see any changes during an incremental build in the
    project using the extension. You can clean the build output by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can run the build telling it to not perform an incremental build
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Another condition that could occur is that compiler holds a build server in
    memory that caches things and optimizes the developer experience. Sometimes, you
    need to shut it down. You do that by issuing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A form of optimization that can be applied to source generators is to use the
    incremental source generator approach. It combines the syntax receiver and generator
    and runs consistently while the build server is running, providing code generation
    as you type in the editor (for editors that support it).
  prefs: []
  type: TYPE_NORMAL
- en: Working with the compiler can be a bit tedious, but is totally worth it when
    you get everything working.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to leverage Roslyn compiler extensions for
    generating code at compile time. We looked at the basics of generating additional
    code for the compiler. We also looked at how you can leverage the Roslyn source
    generators to generate files other than C#, which is a powerful technique that
    can increase productivity and also provide true business value.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have an understanding of what C# code generators are and how
    you can implement one. And hopefully, you also have a few ideas brewing of what
    you can use it for.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned in the chapter, we use the compiler’s extensibility and ability
    to generate code to actually generate TypeScript code. This has proven to be a
    major productivity boost for our developers. There are some code generators already
    out there that take OpenAPI definitions and convert them into JavaScript or TypeScript,
    but they’re then limited to what this standard supports. And if you want it to
    be in a certain shape, or support a specific frontend framework, that might not
    be enough. We had these requirements and then decided on building an extension
    that supports our needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take things a step further and explore how to use
    Roslyn compiler extensions for static code analysis. As you might have picked
    up thus far, I tend to focus on code quality. Coming up, we’ll explore how to
    build custom code analyzers and code fixes, and we’ll see how these tools can
    be used to automatically detect and correct coding issues.
  prefs: []
  type: TYPE_NORMAL
