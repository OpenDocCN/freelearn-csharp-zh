- en: Chapter 2. Baking Cupcake Towers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：制作纸杯蛋糕塔
- en: In this second chapter, we will begin to build our game. We will see how it's
    possible to place objects in 2D space and create templates for the most used objects.
    Furthermore, we will see how Unity deals with scripts, and we will write a couple
    of our own for our game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们将开始构建我们的游戏。我们将看到如何在二维空间中放置对象并创建最常用对象的模板。此外，我们将看到Unity如何处理脚本，并将为我们的游戏编写几个脚本。
- en: 'In particular, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将涵盖以下主题：
- en: Placing objects in 2D space
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在二维空间中放置对象
- en: Setting up the map for our game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏设置地图
- en: Using tags and layers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签和层
- en: Creating Prefabs (templates for game objects)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预制体（游戏对象的模板）
- en: Creating new scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的脚本
- en: Basic concepts of scripting in Unity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity中脚本的基本概念
- en: Writing our first two scripts for our game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏编写第一个两个脚本
- en: Like all the other chapters of this book, you will find the *Homework* section
    at the end. It has a range of different exercises for you to do to improve your
    skills and implement a range of different functionalities into your game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的所有其他章节一样，你将在末尾找到**作业**部分。它包含一系列不同的练习，以提高你的技能并将各种不同的功能实现到你的游戏中。
- en: So, let's get started by learning how to place 2D objects into the scene.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始学习如何将二维对象放置到场景中。
- en: 2D objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二维对象
- en: In the previous chapter, we saw that 2D objects in Unity are Sprites. However,
    we didn't mention how to import them into the scene.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了在Unity中2D对象是精灵。然而，我们没有提到如何将它们导入场景。
- en: The easiest way to bring your Sprites into the scene is to drag and drop them
    from the **Project** panel into the **Scene view**. Unity will automatically create
    a new game object with the same name of the Sprite along with a Sprite Renderer
    attached. We have already covered this component in the previous chapter. Since
    we will not use Sorting Layers (as we decided in the previous chapter), we don't
    need to change any settings when dragging a new Sprite into the scene.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的精灵拖放到场景中最简单的方法是从**项目**面板中将它们拖放到**场景视图**中。Unity将自动创建一个新的游戏对象，其名称与精灵相同，并附加一个精灵渲染器。我们已经在上一章中介绍了这个组件。由于我们不会使用排序层（正如我们在上一章中决定的），在将新的精灵拖入场景时，我们不需要更改任何设置。
- en: Another way to add Sprites to the scene is by right-clicking on the **Hierarchy**
    panel and then **2D Object | Sprite**. However, in the Sprite Renderer, you need
    to specify which Sprite to use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将精灵添加到场景的另一种方法是右键单击**层次结构**面板，然后选择**2D对象 | 精灵**。然而，在精灵渲染器中，你需要指定要使用哪个精灵。
- en: 'Let''s bring the `Pink_Sprinkle` Sprite into our scene (you can find it in
    the `Graphics/projectiles` folder within the `projectiles_sheet_01` file). It
    appears like this in the **Scene** view:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`Pink_Sprinkle`精灵拖入我们的场景（你可以在`Graphics/projectiles`文件夹中的`projectiles_sheet_01`文件中找到它）。它在**场景**视图中的样子如下：
- en: '![2D objects](img/image00354.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![2D对象](img/image00354.jpeg)'
- en: 'Since Sprites are also GameObjects, you can have access to their **Transform**
    properties, as shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精灵也是游戏对象，你可以访问它们的**变换**属性，如下所示：
- en: '![2D objects](img/image00355.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![2D对象](img/image00355.jpeg)'
- en: This means that you can change their position along the *x* axis and the *y*
    axis, as well as the scale and the rotation. Remember that the *z*-axis is used
    to determine the depth, as we discussed in the previous chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以沿着*x*轴和*y*轴改变它们的位置，以及缩放和旋转。记住，*z*轴用于确定深度，正如我们在上一章中讨论的。
- en: By using the **Scale** parameter, it is possible to flip the Sprite. However,
    keep in mind that this will also flip its children. As we saw in the previous
    chapter, from Unity 5.3 to flip a Sprite it is preferable to use the **Flip**
    variable on the **Sprite Renderer**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**缩放**参数，可以翻转精灵。然而，请注意，这也会翻转其子对象。正如我们在上一章中看到的，从Unity 5.3开始，翻转精灵时，最好使用**精灵渲染器**上的**翻转**变量。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can create an empty game object by navigating to the top bar menu and select
    **GameObject | Create Empty**. Alternatively, on the **Hierarchy** panel, click
    on **Create**, then select **Create Empty**. Creating an empty game object is
    a very useful when we need to create containers of other game objects, or if we
    want to build our game object from scratch.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导航到顶部菜单栏并选择**游戏对象 | 创建空对象**来创建一个空的游戏对象。或者，在**层次结构**面板上，点击**创建**，然后选择**创建空对象**。创建一个空的游戏对象在需要创建其他游戏对象的容器时非常有用，或者如果我们想从头开始构建游戏对象。
- en: Parenting game objects
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 父对象
- en: Each game object can have a parent. This means that the game objects will move,
    rotate, and scale along with its parent.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏对象都可以有一个父对象。这意味着游戏对象将随着其父对象一起移动、旋转和缩放。
- en: 'I could use many words to explain this concept, but there are things which
    videos can explain better than words. As such, there is a very short video explaining,
    *The Hierarchy and Parent-Child relationships *at: [https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships](https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用很多话来解释这个概念，但有些事情视频比文字解释得更好。因此，有一个非常简短的视频解释了*层次结构和父子关系*：[https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships](https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships)。
- en: I recommend that you to watch it before you continue reading this book. I'll
    wait for you here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在继续阅读这本书之前先看看它。我会在这里等你。
- en: Difference between world coordinates and local coordinates
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界坐标和局部坐标之间的区别
- en: 'Every game object in Unity has a position, but a position needs a reference
    frame (more about reference frames later in [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*). In particular, Unity offers two ways to see (and set)
    coordinates:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，每个游戏对象都有一个位置，但位置需要一个参考框架（关于参考框架的更多内容将在[第5章](part0062.xhtml#aid-1R42S1
    "第5章。物理的秘诀是加一点调味料")，*物理的秘诀是加一点调味料*）。特别是，Unity提供了两种查看（和设置）坐标的方式：
- en: '**World coordinates**: These are absolute coordinates of where the game object
    is located (by absolute, I mean with respect to the world frame, which is considered
    to be absolute in the game)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界坐标**：这是游戏对象所在位置的绝对坐标（通过绝对，我是指相对于世界框架，在游戏中被认为是绝对的）'
- en: '**Local coordinates**: These are the coordinates of where the game object is
    with respect to its parent'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部坐标**：这是游戏对象相对于其父对象的坐标'
- en: 'You can easily switch between the two coordinates with a toggle in the upper-right
    part of the Unity interface, as shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过Unity界面右上角的一个切换按钮轻松地在两种坐标之间切换，如下面的截图所示：
- en: '![Difference between world coordinates and local coordinates](img/image00356.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![世界坐标和局部坐标之间的区别](img/image00356.jpeg)'
- en: As shown in the preceding screenshot, they are both toggles, but the one to
    switch between world and local coordinates is the one on the left. At the moment,
    it is selected to be on **Global**, which means on world coordinates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，它们都是切换按钮，但用于在世界坐标和局部坐标之间切换的是左侧的按钮。目前，它被选中为**全局**，这意味着在世界坐标上。
- en: Ordering the different layers with Z-Buffering
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Z-Buffering对不同的层进行排序
- en: In the previous chapter, we decided to use Z-Buffering instead of Sorting Layers.
    However, we need to decide which elements of our game will be in the foreground
    compared to the others.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们决定使用Z-Buffering而不是排序层。然而，我们需要决定我们游戏中的哪些元素将位于前景，相对于其他元素。
- en: 'In addition, it is important to keep in mind how the camera is set. Select
    **Main Camera**, which should be the only camera in the scene. This is what the
    **Inspector** should look like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记住相机的设置也很重要。选择**主相机**，它应该是场景中唯一的相机。**检查器**应该看起来像这样：
- en: '![Ordering the different layers with Z-Buffering](img/image00357.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![使用Z-Buffering对不同的层进行排序](img/image00357.jpeg)'
- en: As you can see, by default, its **Z** value on the the position is set to `-10`.
    This means you cannot have any greater negative values (that means smaller than
    `-10`) in the **Z** value of a Sprite, otherwise it will not be rendered. For
    our purpose, `-10` is perfect, and we will stick with it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，默认情况下，其位置上的**Z**值设置为`-10`。这意味着您不能在精灵的**Z**值中有任何更大的负值（这意味着小于`-10`），否则它将不会被渲染。对我们来说，`-10`是完美的，我们将坚持使用它。
- en: Next, we need to assign a **Z** value to all the elements that we have. We can
    start to place the map in the background, by assigning the lowest depth (maximum
    **Z** value) that we have in mind; in this case it's zero.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为所有元素分配一个**Z**值。我们可以开始将地图放置在背景中，通过分配我们心中最低的深度（即最大的**Z**值）；在这种情况下是零。
- en: 'Then, we would like to have the enemies. Therefore, we can set their **Z**
    value to `-1`. After them, the projectiles and the towers, respectively `-2` and
    `-3`. Finally, we need to add another value for the foreground. Here is a summary
    table:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们希望有敌人。因此，我们可以将它们的**Z**值设置为`-1`。之后是弹丸和塔楼，分别`-2`和`-3`。最后，我们需要为前景添加另一个值。以下是总结表：
- en: '| **Elements** | **Z value (depth)** | **Reasons** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **元素** | **Z值（深度）** | **原因** |'
- en: '| Map | `0` | The map has the lowest value, since it will be behind everything.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 地图 | `0` | 该地图具有最低的值，因为它将在所有事物之后。 |'
- en: '| Enemies | `-1` | Enemies are rendered after the map, since they may pass
    behind the towers, which we would like to keep visible. Furthermore, also the
    projectiles should be visible on the enemies, just before they hit them. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 敌人 | `-1` | 敌人在地图之后渲染，因为它们可能会穿过塔，而我们希望保持塔的可见性。此外，在它们击中敌人之前，也应该在敌人上显示弹丸。 |'
- en: '| Projectiles | `-2` | Projectiles are shot from the towers, so it may look
    odd having the projectiles on top of the tower, whereas appearing from the back
    appears more natural. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 弹丸 | `-2` | 弹丸是从塔楼发射的，所以将弹丸放在塔楼上方看起来可能有些奇怪，而从中部发射出来看起来更自然。 |'
- en: '| Towers | `-3` | The towers don''t have any other layer on top of them, excluding
    the map overlay. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 塔楼 | `-3` | 塔楼没有其他层在其上方，除了地图叠加。 |'
- en: '| Map Overlay | `-9` | This is in the foreground, so it has to be rendered
    last. We chose `-9` instead of `-4` because we may add some other layers, but
    the foreground is always the closest one to the camera. We will see what this
    layer contains in the next section. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 地图叠加 | `-9` | 这位于前景，因此它必须最后渲染。我们选择`-9`而不是`-4`，因为我们可能还会添加其他层，但前景总是离相机最近的那一层。我们将在下一节中看到这一层包含的内容。
    |'
- en: '| Main Camera | `-10` | As default. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 主相机 | `-10` | 默认值。 |'
- en: We need to keep these values in mind when we create the Prefabs for our game
    elements. This is important both for this chapter and the rest of the book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为游戏元素创建Prefab时，我们需要记住这些值。这对本章以及本书的其余部分都很重要。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will discuss what a Prefab is later in the chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面讨论Prefab是什么。
- en: Unfolding the map
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开地图
- en: We are finally ready to place the 2D map in our scene.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好将2D地图放置到我们的场景中。
- en: In the previous chapter, we have set the resolution to 16:9\. Therefore, the
    maps that we will find in our packages are ready to use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经将分辨率设置为16:9。因此，我们将在我们的包中找到的地图已经准备好使用。
- en: Let's start by dragging the `sugar_mountain_map` Sprite from the `Graphics/maps`
    folder into our scene. We need to place it in (0,0,0). Please note that the *z*
    axis is set to zero.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将`sugar_mountain_map`精灵从`Graphics/maps`文件夹拖入我们的场景开始。我们需要将其放置在(0,0,0)。请注意，*z*轴被设置为零。
- en: It is a perfect map for what we need. For example, on the left side, there is
    the beginning of the path that the sweet-tooth pandas will follow. At the end
    of the path, there is the Sugar castle that the player needs to protect. Furthermore,
    there is enough space at the top to implement our user interface in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player - the User Interface*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的完美地图。例如，在左侧，有甜食爱好者将跟随的路径起点。在路径的尽头，有玩家需要保护的糖城堡。此外，顶部有足够的空间在[第3章](part0043.xhtml#aid-190861
    "第3章。与玩家沟通 – 用户界面")，*与玩家沟通 - 用户界面*中实现我们的用户界面。
- en: 'The next step is to modify the camera settings. What we want to do is to fit
    the entire map in the **Camera** view. To achieve this, just modify the **Size**
    properties to `22.5` as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改相机设置。我们想要做的是将整个地图适应到**相机**视图中。为了实现这一点，只需修改**大小**属性为`22.5`，如下所示：
- en: '![Unfolding the map](img/image00358.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![展开地图](img/image00358.jpeg)'
- en: 'As a result, our map will be perfectly centered in the **Camera** view. This
    is what we should see in the **Scene** view with the camera selected:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的地图将在**相机**视图中完美居中。这就是我们在选择了相机后的**场景**视图中应该看到的样子：
- en: '![Unfolding the map](img/image00359.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![展开地图](img/image00359.jpeg)'
- en: 'Now, let''s bring in one of the cupcake tower we sliced in the previous chapter;
    for instance, the `ChocolateChip_Cupcake_Tower_2`. If we drag it to the beginning
    of the path, we have the following problem:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将上一章中切割的其中一个纸杯蛋糕塔引入进来；例如，`ChocolateChip_Cupcake_Tower_2`。如果我们将其拖动到路径的起始位置，我们会遇到以下问题：
- en: '![Unfolding the map](img/image00360.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![展开地图](img/image00360.jpeg)'
- en: 'Or also at the bottom of the map:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者也在地图的底部：
- en: '![Unfolding the map](img/image00361.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![展开地图](img/image00361.jpeg)'
- en: 'In fact, the cupcake tower is not supposed to be on the rock, but behind it,
    due to the perspective. Since we are working in a 2D world, we need to create
    a perspective. Luckily, our package contains an overlay of our map. It also contains
    all the assets that should be in the foreground, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，纸杯蛋糕塔不应该在石头上，而应该在它的后面，这是由于透视造成的。由于我们在2D世界中工作，我们需要创建一个透视。幸运的是，我们的包包含我们地图的叠加层。它还包含所有应该在前景中的资产，如图所示：
- en: '![Unfolding the map](img/image00362.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![展开地图](img/image00362.jpeg)'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that usually, all the assets are on different levels so we can customize
    their positions. However, in the package they are pre-placed as for your convenience,
    so we don't lose time to learn amazing things!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常，所有资产都在不同的层级上，这样我们就可以自定义它们的位置。然而，在包中，它们已经预先放置，以便您方便使用，这样我们就不需要花费时间学习令人惊叹的事情！
- en: So, let's add also this overlay to the scene. It is called `sugar_mountain_map_overlay`
    and can be found inside the `Graphics/maps` folder. Again, remember to set its
    *x* and *y* positions to zero. After we have done this, we don't see any difference,
    and the cupcake tower still hovers over the rock. In fact, we have decided from
    the previous section, that all of the *z*-axis values should be assigned to the
    different game elements. If you remember, the value for the map overlay is `-9`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们也将这个叠加层添加到场景中。它被称为`sugar_mountain_map_overlay`，可以在`Graphics/maps`文件夹内找到。再次提醒，记得将其*x*和*y*位置设置为零。完成这些后，我们没有看到任何区别，纸杯蛋糕塔仍然悬浮在石头上。实际上，我们在上一节中已经决定，所有的*z*轴值都应该分配给不同的游戏元素。如果你记得，地图叠加的值是`-9`。
- en: 'Once you have set the map overlay *z*-axis value, our cupcakes should behave
    as we wished:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了地图叠加的*z*轴值，我们的纸杯蛋糕应该会像我们希望的那样表现：
- en: '![Unfolding the map](img/image00363.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![展开地图](img/image00363.jpeg)'
- en: 'It behaves in the right way here, as well:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它在这里的行为也是正确的：
- en: '![Unfolding the map](img/image00364.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![展开地图](img/image00364.jpeg)'
- en: The map is finally ready. One last touch; we should parent the map overlay to
    the map itself. Therefore, if we need to change the map, they will move and scale
    together.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 地图终于准备好了。最后的润色；我们应该将地图叠加层设置为地图本身的父级。因此，如果我们需要更改地图，它们将一起移动和缩放。
- en: Before we continue our journey, remember to delete the cupcake tower, since
    we only needed it for testing purposes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续旅程之前，记得删除纸杯蛋糕塔，因为我们只需要它进行测试。
- en: Layers and tags
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图层和标签
- en: If you already have in mind what are you going to do, it's good to set everything
    up at the beginning. In particular, Unity has some labels that can be given to
    game objects. These are layers and tags. Unity uses these two properties to discriminate
    amongst certain kinds of game objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道你打算做什么，最好在开始时设置好一切。特别是，Unity有一些标签可以分配给游戏对象。这些是图层和标签。Unity使用这两个属性来区分某些类型的游戏对象。
- en: 'By default, some of them are already defined, but we need a few more for our
    project. From the toolbar menu, we can access the layers and tags settings by
    navigating to **Edit** | **Project Settings** | **Tags and Layers**. As a result,
    the **Inspector** should now look like the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，其中一些已经被定义，但我们需要为我们的项目添加更多。从工具栏菜单中，我们可以通过导航到**编辑** | **项目设置** | **标签和图层**来访问图层和标签设置。因此，**检查器**现在应该看起来像以下截图：
- en: '![Layers and tags](img/image00365.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图层和标签](img/image00365.jpeg)'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this menu, we also have the possibility to change the sorting layers for
    rendering 2D objects. However, as mentioned earlier, we will use Z-Buffering to
    achieve the same effect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜单中，我们还可以更改用于渲染2D对象的排序图层。然而，如前所述，我们将使用Z缓冲区来实现相同的效果。
- en: 'Let''s expand the **Tags** menu, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展开**标签**菜单，如下所示：
- en: '![Layers and tags](img/image00366.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图层和标签](img/image00366.jpeg)'
- en: 'To add a new tag, just press on the + button in the bottom-right corner. We
    need to add two tags, respectively `Enemy` and `**Projectile**`, as shown in the
    following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新标签，只需在右下角点击+按钮。我们需要添加两个标签，分别是`敌人`和`**弹射物**`，如图所示：
- en: '![Layers and tags](img/image00367.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图层和标签](img/image00367.jpeg)'
- en: In fact, we will need these two tags later on in the development of this game.
    In fact, when a cupcake tower searches for surrounding objects, it needs to discriminate
    between enemies and projectiles.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在游戏的开发过程中还需要这两个标签。实际上，当一个纸杯蛋糕塔搜索周围的对象时，它需要区分敌人和弹射物。
- en: Prefabs
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制件
- en: When the scene begins to fill up with objects, some of these objects might become
    complex. By complex, I mean with a lot of components and children. If we need
    to use many of them in the game and maybe change all of them at once, Unity offers
    the possibility to create a Prefab.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景开始充满对象时，其中一些对象可能会变得复杂。这里的复杂是指具有许多组件和子对象。如果我们需要在游戏中使用许多这样的对象，并且可能一次性更改所有这些对象，Unity
    提供了创建预制件的可能性。
- en: As the name suggests, it is an object already assembled with all the necessary
    components and ready to be placed in the scene. The advantage is the possibility
    to reuse it often and to change all its instances quickly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名字所暗示的，这是一个已经组装好所有必要组件并准备好放置在场景中的对象。其优点是经常可以重用它，并且可以快速更改所有实例。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If an object in the scene is a Prefab, its name in the **Hierarchy** panel is
    blue. If the name is red, instead, this means that there are some references missing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景中的对象是一个预制件，那么在**层次结构**面板中它的名字是蓝色的。如果名字是红色的，那么这意味着缺少一些引用。
- en: To keep our project organized, let's create a folder named `Prefabs`, if we
    haven't done so yet. Inside the folder, right-click and then select `Create/Prefab`.
    You can name it as you want, but for this book, let's stick with `Pink_Sprinkle_Projectile_Prefab`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的项目更有条理，让我们创建一个名为 `Prefabs` 的文件夹，如果我们还没有这样做的话。在文件夹内，右键单击并选择 `创建/预制件`。你可以按自己的意愿命名，但为了这本书，让我们保持
    `Pink_Sprinkle_Projectile_Prefab` 这个名字。
- en: We already have the sprinkle in the scene, so from the **Hierarchy** panel,
    drag it into the `Pink_Sprinkle_Projectile_Prefab`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在场景中有了喷雾效果，所以从**层次结构**面板中，将其拖动到 `Pink_Sprinkle_Projectile_Prefab`。
- en: Now, we can also erase the previous sprinkle from the scene, as we don't need
    it anymore. For testing purposes, you can try to add as many sprinkles as you
    want in the scene by dragging the Prefab into the **Scene** view. Of course, remember
    to erase them before continuing with the rest of this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从场景中删除之前的喷雾效果，因为我们不再需要它了。为了测试目的，你可以通过将预制件拖动到**场景**视图中来在场景中添加尽可能多的喷雾效果。当然，记得在继续本章的其余部分之前将它们删除。
- en: 'When we select an object that is an instance of a Prefab, three additional
    buttons appear in the **Inspector**, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择一个预制件的实例对象时，**检查器**中会显示三个额外的按钮，如下面的截图所示：
- en: '![Prefabs](img/image00368.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![预制件](img/image00368.jpeg)'
- en: 'These are their functions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是它们的功能：
- en: '**Select**: This is a shortcut to quickly select in the **Project** panel the
    Prefab of the object.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择**：这是一个快速在**项目**面板中选择对象预制件的快捷方式。'
- en: '**Revert**: If we did some changes in the instance of the Prefab (the current
    selected object), these do not affect the Prefab. By clicking on this button,
    we revert all the changes to the original Prefab.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**还原**：如果我们对预制件实例（当前选定的对象）进行了更改，这些更改不会影响预制件。通过点击此按钮，我们将所有更改还原到原始预制件。'
- en: '**Apply**: If, on the other hand, you are satisfied with the changes you made
    to this instance of the Prefab, by clicking on this button, you can apply these
    changes to the Prefab. As a result, you may modify all of the other instances
    in the scene. So be careful when you use this function.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用**：另一方面，如果你对对预制件实例所做的更改感到满意，通过点击此按钮，你可以将这些更改应用到预制件上。结果，你可能会修改场景中的所有其他实例。所以当你使用这个功能时要小心。'
- en: The game view
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏视图
- en: You should already know about the game view, but there might be some new types
    of functionality that you didn't know about before. So, a short recap might be
    useful, before we move on in our journey.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经了解游戏视图，但可能有一些你之前不知道的新功能类型。因此，在我们继续旅程之前，一个简短的回顾可能是有用的。
- en: 'First of all, we have our three main buttons, which you should be very familiar
    with, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有三个主要按钮，你应该非常熟悉，如下所示：
- en: '![The game view](img/image00369.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![游戏视图](img/image00369.jpeg)'
- en: The first is the play button, which makes your game run. The second button pauses
    the game, and allows you to tweak some settings. The last one makes your game
    run for one frame only.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是播放按钮，它使你的游戏运行。第二个按钮暂停游戏，并允许你调整一些设置。最后一个按钮只让游戏运行一帧。
- en: 'In the top-left corner, we have the displays and the resolution tabs that we
    covered in the previous chapter. In the opposite corner (top-right), there are
    many different yet useful toggles, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在左上角，我们有之前章节中提到的显示和分辨率选项卡。在对角线（右上角），有许多不同但很有用的切换按钮，如下面的截图所示：
- en: '![The game view](img/image00370.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![游戏视图](img/image00370.jpeg)'
- en: 'These are their functions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是它们的功能：
- en: '**Maximize on Play**: If this is on, every time you push the play button, the
    game view will be maximized to the largest window it can be. It''s useful for
    testing the game in almost full screen; otherwise, it can be a little bit hard
    to tweak values without having a second monitor.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大化游戏播放**：如果开启此选项，每次你按下播放按钮，游戏视图将最大化到最大的窗口。这对于在几乎全屏中测试游戏非常有用；否则，如果没有第二个显示器，调整值可能会有些困难。'
- en: '**Mute Audio**: If this is enabled, as the name suggests, it silences all the
    audio sources in the game.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静音音频**：如果启用，正如其名所示，它将静音游戏中的所有音频源。'
- en: '**Stats**: If this is on, it provides some basic feedback about the performance
    of your game, as shown here:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计数据**：如果开启此选项，它将提供一些关于游戏性能的基本反馈，如下所示：'
- en: '![The game view](img/image00371.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![游戏视图](img/image00371.jpeg)'
- en: '**Gizmos**: These are used to identify objects in the scenes. However, we will
    see these later in [Chapter 6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a
    Sea of Sprinkles – Navigation in Artificial Intelligence"), *Through a Sea of
    Sprinkles - Navigation in Artificial Intelligence*.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gizmos**：这些用于识别场景中的对象。然而，我们将在第6章[通过糖果海导航——人工智能导航](part0077.xhtml#aid-29DRA1
    "第6章。通过糖果海导航——人工智能导航")中看到这些，*通过糖果海导航——人工智能导航*。'
- en: Math background
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学背景
- en: Either you like math or not; however, it is a fact that it is required for game
    development. We don't have time to go through all the math behind this game, since
    it is required to have a complete toolset for game development. However, this
    section introduces you to some basic concepts that we will need for the rest of
    the book. In addition, it also makes some references to the official documentation
    so that you can learn a bit more about it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否喜欢数学；然而，这是一个事实，它是游戏开发所必需的。我们没有时间来探讨这个游戏背后的所有数学，因为它需要有一个完整的游戏开发工具集。然而，本节将向你介绍一些我们将需要在本书中其他部分使用的基本概念。此外，它还引用了一些官方文档，以便你可以了解更多关于它们的信息。
- en: 'If you feel confident with some of the following topics, you are free to skip
    them:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己以下的一些主题感到自信，你可以自由地跳过它们：
- en: '**Vectors**: They are really important in game development, because they are
    able to describe spaces (both 3D and 2D). They can represent a position or a direction.
    You can read more about them at [https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html)
    and watch this video: [https://unity3d.com/learn/tutorials/topics/scripting/vector-maths](https://unity3d.com/learn/tutorials/topics/scripting/vector-maths).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量**：在游戏开发中，向量非常重要，因为它们能够描述空间（包括3D和2D）。它们可以表示一个位置或一个方向。你可以在[https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html)了解更多关于它们的信息，并观看这个视频：[https://unity3d.com/learn/tutorials/topics/scripting/vector-maths](https://unity3d.com/learn/tutorials/topics/scripting/vector-maths)。'
- en: '**Probability****:** This is very important when we want a sample to emerge
    from our game, by including uncertainty and chances for the player. A common example
    is in RTS or MMORPG games, where the amount of damage is often between a range
    (determined by the character''s stat), but the actual and real amount of damage
    uses random numbers. Another case is when an attack should be critical so to inflict
    double the damage. At the end of the chapter it is explained how to extract random
    numbers in Unity. However, consider buying a proper math book about probability;
    it might be worthwhile.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概率**：当我们希望从游戏中抽取样本，并包含不确定性和玩家的机会时，这一点非常重要。一个常见的例子是在即时战略（RTS）或大型多人在线角色扮演游戏（MMORPG）中，伤害量通常在一定的范围内（由角色的属性决定），但实际伤害量使用随机数。另一个例子是当攻击应该是致命的，以便造成双倍伤害。在章节末尾将解释如何在Unity中提取随机数。然而，考虑购买一本关于概率的适当数学书籍；这可能是值得的。'
- en: '**Radians and Degrees**: Angles can have two unit of measurements. Radians
    are usually used to perform calculations, but Unity has some constants that by
    a multiplication can convert one to the other representation. You can read more
    about these at [https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html](https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html)
    and [https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html](https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弧度和角度**：角度可以有两种度量单位。弧度通常用于计算，但Unity有一些常数，通过乘法可以将一个单位转换为另一个表示。你可以在[https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html](https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html)和[https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html](https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html)了解更多关于这些的信息。'
- en: '**Trigonometry**: This is really important, because the sine and the cosine
    functions are often used to achieve believable behavior, since Mother Nature uses
    them for our world. Unluckily, there are no shortcuts. Therefore, if you really
    want to understand them and get into them, you should read any book about trigonometry.
    However, the most important notion used is that they range the value of their
    arguments between `-1` and `+1`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角学**：这非常重要，因为正弦和余弦函数经常被用来实现可信的行为，因为大自然在我们的世界中使用了它们。不幸的是，没有捷径。因此，如果你真的想理解它们并深入其中，你应该阅读任何关于三角学的书籍。然而，最重要的概念是它们将它们的参数值范围在`-1`和`+1`之间。'
- en: '**Quaternions**: This is a math entity that''s not very intuitive, since it
    involves the analysis of complex numbers. However, it''s not important to know
    them in detail (except in really specific cases) when programming in Unity. In
    fact, it''s enough to know that Unity uses them to store rotations. Also, there
    are functions to convert from the Euler representations (the most intuitive of
    three angles). The reason of this choice is behind the scope of this book, but
    it''s due a numerical instability of the Euler representation. You can learn more
    about them by watching the following video: [https://unity3d.com/learn/tutorials/topics/scripting/quaternions](https://unity3d.com/learn/tutorials/topics/scripting/quaternions).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四元数**：这是一个不太直观的数学实体，因为它涉及到复数的分析。然而，在Unity编程中，了解它们的细节并不重要（除非在非常具体的情况下）。实际上，知道Unity使用它们来存储旋转就足够了。此外，还有将欧拉表示（三个角度中最直观的）转换为其他表示的函数。这个选择背后的原因超出了本书的范围，但这是由于欧拉表示的数值不稳定性。你可以通过观看以下视频了解更多信息：[https://unity3d.com/learn/tutorials/topics/scripting/quaternions](https://unity3d.com/learn/tutorials/topics/scripting/quaternions)。'
- en: '**Atan2()**: This is a function that is really important in game development,
    because it is able to calculate the angle of a vector. You can read more about
    this function at [https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html](https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Atan2()**：这是一个在游戏开发中非常重要的函数，因为它能够计算向量的角度。你可以阅读更多关于这个函数的信息：[https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html](https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html)。'
- en: Scripting in Unity
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的脚本编写
- en: In this section, we will learn one of the toughest topics in game development!
    However, I strongly encourage you not to be scared, but try to practice a lot.
    As a result, you will be able to master every single detail of your game. And
    that is awesome!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习游戏开发中最难的话题之一！然而，我强烈鼓励你不要害怕，而是要多加练习。结果，你将能够掌握你游戏中的每一个细节。这真是太棒了！
- en: Creating new scripts
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新脚本
- en: First of all, we need to understand how to create new scripts in Unity. The
    easiest way is to select a game object and in the **Inspector**, navigate to **Add
    Component** | **New Script**. In this way, you still have the possibility to rename
    it, but the script will be located in the `Asset` folder. Furthermore, it's not
    possible to create a class that cannot be attached to a game object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解如何在Unity中创建新的脚本。最简单的方法是选择一个游戏对象，在**检查器**中导航到**添加组件** | **新脚本**。这样，你仍然有机会重命名它，但脚本将位于`Asset`文件夹中。此外，不可能创建一个无法附加到游戏对象的类。
- en: A much better way is to create a folder called `Scripts` in the **Project**
    panel, if you haven't done so yet. Then, right-click and navigate to **Create**
    | **C# Script**. As a result, it will be in the right folder, and we don't have
    problems if we create a script that cannot be attached to game objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还没有这样做，一个更好的方法是创建一个名为`Scripts`的文件夹在**项目**面板中。然后，右键单击并导航到**创建** | **C# 脚本**。结果，它将位于正确的文件夹中，如果我们创建一个无法附加到游戏对象的脚本，我们不会有问题。
- en: For the rest of this book, it will be assumed that every new script will be
    created in this way, and always in the `Scripts` folder.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将假设每个新的脚本都是以这种方式创建的，并且始终位于`Scripts`文件夹中。
- en: Keeping the name of the script in mind is important, because the file should
    have the same name as the main class in the script. This means that if we change
    the name of the class later on, we need to rename the file accordingly as well.
    However, this may break some references in other scripts that will require correcting.
    So, be careful when changing names.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记住脚本的名称很重要，因为文件应该与脚本中的主类名相同。这意味着如果我们稍后更改类的名称，我们也需要相应地重命名文件。然而，这可能会破坏其他脚本中的某些引用，需要修正。因此，在更改名称时要小心。
- en: To open a script, you need to double-click on it. Unity will open a script editor.
    By default, it will be Monodevelop. However, it is possible to change this setting
    by navigating through **Edit | Preferences...**. In the **External Tool** tab,
    you can change the **External Script Editor**. Another commonly used script editor
    is Visual Studio, it can can be downloaded from [https://www.visualstudio.com/](https://www.visualstudio.com/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开脚本，你需要双击它。Unity将打开脚本编辑器。默认情况下，它将是Monodevelop。然而，你可以通过导航到**编辑 | 首选项...**来更改此设置。在**外部工具**选项卡中，你可以更改**外部脚本编辑器**。另一个常用的脚本编辑器是Visual
    Studio，可以从[https://www.visualstudio.com/](https://www.visualstudio.com/)下载。
- en: However, if this is your first experience with Unity, I suggest that you stick
    with Monodevelop. In any case, for this book, we don't have any requirements (as
    far as you are able to edit the scripts), so feel free to choose the one you like
    best.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你是第一次使用Unity，我建议你坚持使用Monodevelop。无论如何，对于这本书，我们没有任何要求（只要你能编辑脚本），所以请随意选择你最喜欢的。
- en: Basics about scripts
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本基础知识
- en: If this is your first time scripting in Unity, there is some information to
    know before we begin.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次在Unity中编写脚本，在我们开始之前，有一些信息需要了解。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Unity mainly supports two languages: C# and JavaScript. Since we created a
    C# script in the previous section, we are going to use this language for the rest
    of this book.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Unity主要支持两种语言：C#和JavaScript。由于我们在上一节中创建了一个C#脚本，因此我们将在这本书的其余部分使用这种语言。
- en: Variables
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: Variables can be public, private, or protected. We will not cover the last one,
    since we don't have enough time for that, and it's not really important when getting
    started with Unity development. Private variables can be used only within the
    script itself. Usually they are used to store internal data of the script that
    doesn't need to be shared among other components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以是公共的、私有的或受保护的。我们不会介绍最后一个，因为我们没有足够的时间，而且在Unity开发入门时它并不是很重要。私有变量只能在脚本本身中使用。通常，它们用于存储脚本内部不需要与其他组件共享的数据。
- en: Public variables, instead, can be accessed from any script, so we need to pay
    attention where to use them. It's good practice to implement the `get` and `set`
    functions, when applicable. Even if we will not use them much in this book, it's
    worth learning what they are, which you can do at [https://msdn.microsoft.com/en-us/library/w86s7x04.aspx](https://msdn.microsoft.com/en-us/library/w86s7x04.aspx).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，公共变量可以从任何脚本中访问，因此我们需要注意它们的使用位置。当适用时，实现`get`和`set`函数是一个好的实践。即使在这本书中我们不会经常使用它们，了解它们是什么也值得学习，你可以在[https://msdn.microsoft.com/en-us/library/w86s7x04.aspx](https://msdn.microsoft.com/en-us/library/w86s7x04.aspx)找到相关信息。
- en: 'Furthermore, public variables are visible in the **Inspector**. In fact, just
    for testing purposes, you can create a new script and add the following integer
    variable:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，公共变量在**检查器**中是可见的。实际上，仅为了测试目的，你可以创建一个新的脚本并添加以下整数变量：
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As a result, after you have saved the script, you are able to set its value
    in the **Inspector**, as shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在保存脚本之后，你可以在**检查器**中设置其值，如下面的截图所示：
- en: '![Variables](img/image00372.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![变量](img/image00372.jpeg)'
- en: As a consequence, public variables don't need to be set within the script in
    order to be able to use them. Often, we would like to have a public variable,
    since it will be set from another script, but not visible on the **Inspector**.
    You can achieve that in Unity by using an attribute.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了能够使用公共变量，不需要在脚本中设置它们。通常，我们希望有一个公共变量，因为它将由另一个脚本设置，但在**检查器**中不可见。在Unity中，你可以通过使用属性来实现这一点。
- en: Attributes
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'Before variables and functions, Unity allows us to insert an attribute. An
    attribute is enclosed between `[` and `]`, and can contain different parameters.
    Around 30 attributes exist and they really differ in functionality and usage.
    Since we don''t have the time to go through them all, we will just cover the most
    commonly used ones:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量和函数之前，Unity允许我们插入一个属性。属性被`[`和`]`包围，可以包含不同的参数。大约有30个属性，它们在功能和用法上确实有所不同。由于我们没有时间逐一介绍它们，我们只会介绍最常用的几个：
- en: 'The `Header` attribute is formatted as `[Header("string")]`. It creates a header
    before the variables that follow it. Here is an example of adding the attribute
    to the variable of the test script we used earlier:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`属性格式为`[Header("string")]`。它在其后的变量之前创建一个标题。以下是将属性添加到我们之前使用的测试脚本变量的示例：'
- en: '[PRE1]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is the following:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Attributes](img/image00373.jpeg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![属性](img/image00373.jpeg)'
- en: 'The `HideInInspector` attribute is formatted as `[HideInInspector]`. It hides
    the variable that follows it from the **Inspector**. Here it is in use, in the
    previous example:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HideInInspector` 属性的格式为 `[HideInInspector]`。它隐藏了其后的变量，使其在 **Inspector** 中不可见。这里是在上一个例子中的使用情况：'
- en: '[PRE2]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this is the result:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Attributes](img/image00374.jpeg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![属性](img/image00374.jpeg)'
- en: 'The `Range` attribute is formatted as `[Range(minValue, maxValue)]`. It captures
    the possible values of the variable in the range of numbers from `minValue` to
    `maxValue`. Again, we use the previous example:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range` 属性的格式为 `[Range(minValue, maxValue)]`。它捕捉变量在 `minValue` 到 `maxValue`
    的数值范围内的可能值。再次，我们使用之前的例子：'
- en: '[PRE3]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the result we obtain:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们所得到的结果：
- en: '![Attributes](img/image00375.jpeg)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![属性](img/image00375.jpeg)'
- en: 'Finally, The `Tooltip` attribute is formatted as `[Tooltip("string")]`. It
    creates a tooltip in the **Inspector** when the cursor is hovering over that variable:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`Tooltip` 属性的格式为 `[Tooltip("string")]`。当光标悬停在变量上时，它会在 **Inspector** 中创建一个工具提示：
- en: '[PRE4]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the result (when the cursor hovers):'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是结果（当光标悬停时）：
- en: '![Attributes](img/image00376.jpeg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![属性](img/image00376.jpeg)'
- en: Functions
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'Any script that derives from the `MonoBehaviour` class has two main functions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 任何从 `MonoBehaviour` 类派生的脚本都有两个主要功能：
- en: '`Start()`: This function is called only once, when the game starts. It''s useful
    to set all the variables and get the references we need within this function.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`: 这个函数只会在游戏开始时被调用一次。在函数内设置所有变量和获取我们需要的引用很有用。'
- en: '`Update()`: This function is called every frame, and needs to compute things
    in real time, such as velocity or behaviors. However, since this is called so
    often, we need to pay attention to what we code inside, to avoid slowing down
    our game too often.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`: 这个函数在每一帧都会被调用，需要实时计算一些东西，比如速度或行为。然而，由于这个函数被调用得非常频繁，我们需要注意我们代码内部的内容，以避免游戏运行速度过慢。'
- en: There are other functions that can be implemented and that will be automatically
    called. In actual fact, there are more than 60!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以实现其他函数，并且它们将被自动调用。实际上，有超过 60 个！
- en: 'We will use some of them later on, so we will introduce them here and see them
    in detail in later chapters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会用到其中的一些，所以在这里介绍它们，并在后面的章节中详细探讨：
- en: '`OnTriggerEnter2D()`: This is called when another object with a collider enters
    the trigger collider attached to the game object. We will see this better later
    on, when we deal with physics.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter2D()`: 当另一个具有碰撞器的对象进入附加到游戏对象的触发碰撞器时，会调用此函数。我们将在处理物理时更好地了解这一点。'
- en: '`OnMouseDown()`: This is called when the player has pressed the mouse button
    while over the game object if it has a collider attached. Furthermore, it can
    be a `Coroutine` and works with `GUIElements` too.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnMouseDown()`: 如果游戏对象附加了碰撞器，并且玩家在游戏对象上按下鼠标按钮时，会调用此函数。此外，它还可以是一个 `Coroutine`，并且与
    `GUIElements` 一起工作。'
- en: '`OnEnable()`: This is called when the object becomes enabled and active.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEnable()`: 当对象变为启用和活动状态时，会调用此函数。'
- en: You can find out more about them at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)
    上了解更多关于它们的信息。
- en: Comments
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: As we mentioned in the previous chapter, game development is not an easy process,
    since it involves many stages. For this reason, it's really important to document
    everything that we do. This doesn't mean writing something that will be published,
    but just a couple of lines to remind yourself and your team what you have accomplished.
    In fact, human memory is great at remembering concepts, but not good for details!
    This is essential during the scripting stage. It is important to be able to read
    what the rest of your team or yourself have written a few days ago. When coding,
    it's easy to get lost among the many lines of code when you don't use comments!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中提到的，游戏开发不是一个容易的过程，因为它涉及许多阶段。因此，记录我们所做的一切非常重要。这并不意味着写一些将要发布的内容，而只是几行代码来提醒自己和团队我们已经完成了什么。实际上，人类的大脑在记住概念方面很出色，但在记住细节方面却不是很好！这在脚本编写阶段是至关重要的。能够阅读几天前自己和团队所写的内容非常重要。在编码时，如果不使用注释，很容易在众多代码行中迷失方向！
- en: Since Unity uses a C# compiler, it is possible to insert comments inside the
    code. Comments are lines that will be ignored (not compiled), and as the name
    suggests, they help to leave messages to those who will read the code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unity使用C#编译器，因此可以在代码中插入注释。注释是会被忽略（不会编译）的行，正如其名所示，它们有助于给阅读代码的人留下信息。
- en: 'There are two main ways to comment in C#. The first is to insert `//` at the
    beginning of a line. As a result, everything that comes after until the next line
    will be ignored. The second one is used when we have more than one line. It consists
    to surround the comment with an opening tag `/*` and the closing tag `*/`. As
    a result, everything within these two tags will be ignored. Here is an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中注释主要有两种方式。第一种是在行首插入`//`，结果是从该行开始直到下一行之后的所有内容都将被忽略。第二种方式用于多行注释，它由一个开标签`/*`和一个闭标签`*/`包围。结果，这两个标签之间的所有内容都将被忽略。以下是一个示例：
- en: '[PRE5]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Comments are also used to build automatic documentations and as markups for
    other things. However, this is out the scope of this book.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注释也用于构建自动文档和作为其他内容的标记。然而，这超出了本书的范围。
- en: I strongly suggest that you always try to insert comments in your code, so it
    is easier to read later on. For your convenience, all the code that comes with
    this book is provided with comments, helping you to understand what is happening
    and where.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你始终尝试在你的代码中插入注释，这样以后阅读起来会更方便。为了你的方便，本书附带的所有代码都提供了注释，帮助你理解正在发生的事情以及在哪里。
- en: Execution order
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行顺序
- en: Another important concept about scripting in Unity is the **Execution Order**.
    It may be fundamental that some scripts or parts of code are executed before others.
    As a result, this will affect how the shared resources are modified and the efficiency
    as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Unity中脚本编写的一个重要概念是**执行顺序**。某些脚本或代码部分在执行其他脚本或代码部分之前执行可能是基本的。结果，这将影响共享资源的修改方式和效率。
- en: 'The standard ordering is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的顺序如下：
- en: '**Editor**: In particular, the `Reset()` function.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑器**：特别是，`Reset()`函数。'
- en: '**Scene Load**: Functions such as `Awake()`, `OnEnable()`, and `OnLevelWasLoaded()`
    are called.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**场景加载**：调用`Awake()`、`OnEnable()`和`OnLevelWasLoaded()`等函数。'
- en: '**Before the first frame update**: All the `Start()` functions in the scripts
    are called (if the object is active!).'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在第一帧更新之前**：如果对象是活动的，将调用脚本中的所有`Start()`函数。'
- en: '**In between frames**: the `OnApplicationPause()` function is performed.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**帧之间**：执行`OnApplicationPause()`函数。'
- en: '**Update**: All the different `Update()` functions are called.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新**：调用所有不同的`Update()`函数。'
- en: '**Rendering**: Specific rendering functions are performed.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**渲染**：执行特定的渲染功能。'
- en: '**Coroutines**: They are executed until a yield statement is found'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协程**：它们会一直执行，直到找到yield语句。'
- en: '**When the object is destroyed**: The `Destroy()` function is called.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当对象被销毁时**：调用`Destroy()`函数。'
- en: '**When quitting**: Functions to be executed when disabling game objects or
    when quitting the game are called.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**退出时**：当禁用游戏对象或退出游戏时，将调用要执行的功能。'
- en: Of course, this is just scratching the surface to give you an idea about the
    execution order. If you are interested in finding out more on this topic, you
    can find a detailed explanation of the execution order in the official documentation,
    at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是为了给你一个关于执行顺序的初步印象。如果你对这个主题感兴趣，你可以在官方文档中找到关于执行顺序的详细解释，网址为[https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)。
- en: 'Unity offers also the possibility to change the execution order within your
    scripts when you have specific needs. This can be done by navigating on the toolbar
    to, **Edit** | **Project Settings** | **Script Execution Order**. As a result,
    this window will appear on the **Inspector**, where it is possible to change the
    order:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Unity还提供了在脚本中更改执行顺序的可能性，当你有特定需求时。这可以通过在工具栏中导航到**编辑** | **项目设置** | **脚本执行顺序**来实现。结果，这个窗口将出现在**检查器**中，你可以在这里更改顺序：
- en: '![Execution order](img/image00377.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![执行顺序](img/image00377.jpeg)'
- en: 'For more information about this, you can visit the following link: [https://docs.unity3d.com/Manual/class-ScriptExecution.html](https://docs.unity3d.com/Manual/class-ScriptExecution.html).
    However, the execution order for scripts is for specific needs that we don''t
    have, so we won''t touch any of these settings. However, I hope that this section
    helped you to get a better understanding of the logic behind Unity. Saying that,
    I encourage you to re-read this section when you gain a better understanding of
    scripting in Unity.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多信息，您可以访问以下链接：[https://docs.unity3d.com/Manual/class-ScriptExecution.html](https://docs.unity3d.com/Manual/class-ScriptExecution.html)。然而，脚本的执行顺序是为了特定的需求，而我们没有这样的需求，所以我们将不会修改这些设置。不过，我希望这一部分能帮助您更好地理解Unity背后的逻辑。话虽如此，我鼓励您在更好地理解Unity中的脚本编写时重新阅读这一部分。
- en: Making sprinkles
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作喷雾
- en: In the *Prefabs* section, we created the Prefab for our sprinkle projectile.
    In this section, we will see how to make sprinkles move into the 2D space. In
    particular, we will learn how to create and use scripts in Unity for 2D game elements.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在*预制件*部分，我们为我们的喷雾投射物创建了预制件。在本节中，我们将了解如何使喷雾在2D空间中移动。特别是，我们将学习如何在Unity中为2D游戏元素创建和使用脚本。
- en: The projectile class
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投射物类
- en: 'Since there might be different projectiles in our game that can be thrown against
    the sweet-tooth pandas, and not only sprinkles, we need to define a general class.
    All the different kinds of projectile will follow some general rules:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏中可能有不同的投射物可以投向甜食爱好者熊猫，而不仅仅是喷雾，我们需要定义一个通用类。所有不同类型的投射物都将遵循一些通用规则：
- en: They move in a straight line
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们沿直线移动
- en: They carry information about how much damage they will inflict on the enemies
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们携带有关将对敌人造成多少伤害的信息
- en: Whereas the first is identical for all the projectiles, the second depends on
    the specific kind of projectile that will be fired. So, we need to create a template.
    Once we attach this script to a game object, we can set some of its variables
    and tweak its behavior. In this specific case, we want to tweak how much damage
    is given and how fast.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个对所有投射物都是相同的，第二个取决于将要发射的具体投射物类型。因此，我们需要创建一个模板。一旦我们将此脚本附加到游戏对象上，我们就可以设置一些变量并调整其行为。在这种情况下，我们想要调整造成的伤害量和速度。
- en: Scripting the projectile mother class
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写投射物基类脚本
- en: 'So, to begin, let''s create a new script and name it `ProjectileScript`. Next,
    we need to define four variables. The first is for the amount of damage, the second
    for its speed, and the third one, for its direction, since we need to know where
    the projectile is heading. The last variable stores its life duration expressed
    in seconds. As a consequence, it also sets, together with the speed variable,
    how far the projectile can reach. In fact, if the projectile misses the target,
    we don''t want it going straight on forever, because this would consume computational
    resources and slow down our game. So after this duration, we need to destroy it.
    To do this, we can add the following four variables:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们创建一个新的脚本，并将其命名为`ProjectileScript`。接下来，我们需要定义四个变量。第一个是用于伤害量，第二个是速度，第三个是方向，因为我们需要知道投射物将飞向何方。最后一个变量存储其以秒为单位的生存时间。因此，它还与速度变量一起设置了投射物可以到达的距离。实际上，如果投射物没有击中目标，我们不希望它永远直线前进，因为这会消耗计算资源并减慢我们的游戏。因此，在这个持续时间之后，我们需要销毁它。为此，我们可以添加以下四个变量：
- en: '[PRE6]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next thing to do is to set some of these parameters in the `Start()` function.
    Since the direction will be given by the entity that will throw the projectile,
    we don''t have a guarantee that it has a unit norm. As consequence, we need to
    normalize the direction. Then, we need to rotate the graphic of our projectile,
    which in this case is the sprinkle, towards the right direction. In order to achieve
    this, we need to compute the angle using the `Atan2()` function. After we have
    transformed this in degrees, we use the `AngleAxis()` function in the `Quaternion`
    class to rotate our game object. Finally, we need to set a timer before the game
    object is destroyed. As a result, this will be our `Start()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事情是在`Start()`函数中设置一些参数。由于方向将由投掷实体的方向决定，我们无法保证它具有单位范数。因此，我们需要归一化方向。然后，我们需要将我们的投射物图形（在这种情况下是喷雾）旋转到正确的方向。为了实现这一点，我们需要使用`Atan2()`函数计算角度。在将这个角度转换为度数后，我们使用`Quaternion`类中的`AngleAxis()`函数来旋转我们的游戏对象。最后，我们需要在游戏对象被销毁之前设置一个计时器。因此，这将是我们`Start()`函数的内容：
- en: '[PRE7]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `Update()` function, we just need to move the sprinkle in that direction. If
    the sprinkle collides with something, such as a Panda, it''s a case that we will
    discuss in [Chapter 5](part0056.xhtml#aid-1LCVG1 "Chapter 4. No Longer Alone –
    Sweet-Toothed Pandas Strike"), *No Longer Alone - Sweet-Toothed Pandas Strike*.
    So, we need to update its position according to its direction and speed, keeping
    it dependent on the time. So, we can write the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`函数中，我们只需要将洒水器移动到那个方向。如果洒水器与某个物体发生碰撞，例如熊猫，这将是我们将在[第5章](part0056.xhtml#aid-1LCVG1
    "第4章. 不再孤单 – 喜欢甜食的大熊猫出击")讨论的情况，*不再孤单 - 喜欢甜食的大熊猫出击*。因此，我们需要根据其方向和速度更新其位置，使其依赖于时间。因此，我们可以编写以下代码：
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the end, save the script. There is still a lot of work to do on this script.
    For instance, the direction should be only on the *x* and *y*, and not on the
    *z*, since it is used in the Z-Buffering method. However, for now it is fine,
    and we will look at all these issues later on in the book.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，保存脚本。在这个脚本上还有很多工作要做。例如，方向应该只在*x*和*y*上，而不是*z*，因为它是用于Z缓冲区方法。然而，现在它是可以的，我们将在本书稍后讨论所有这些问题。
- en: Tons of sprinkles through Prefabs
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Prefab生成的无数洒水器
- en: Now that we have a general script that achieves the behavior of a projectile,
    we need to actually make the Prefab of our sprinkles with such behavior.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个实现抛物线行为的通用脚本，我们需要实际制作具有这种行为的洒水器的Prefab。
- en: 'We have already created a Prefab for our sprinkle projectile, but we need to
    change it. So, go into the `Prefabs` folder in the **Project** panel, and select
    our `Pink_Sprinkle_Projectile_Prefab`. In the **Inspector**, we need to add the
    script that we have just created. So, navigate to **Add Component** | **Script**
    | **ProjectileScript**. As a result, you should see the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的洒水器抛射物创建了一个Prefab，但我们需要对其进行更改。因此，进入**项目**面板中的`Prefab`文件夹，并选择我们的`Pink_Sprinkle_Projectile_Prefab`。在**检查器**中，我们需要添加我们刚刚创建的脚本。因此，导航到**添加组件**
    | **脚本** | **抛射物脚本**。结果，你应该看到以下内容：
- en: '![Tons of sprinkles through Prefabs](img/image00378.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![通过Prefab生成的无数洒水器](img/image00378.jpeg)'
- en: 'We need to tweak the values, at least for testing purposes, so that we can
    see our sprinkle moving. We can assign a direction such as (1, 1, 0) and any value
    to the **Damage** variable. At the end, we should have something like the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整一些值，至少是为了测试目的，这样我们才能看到洒水器在移动。我们可以分配一个方向，例如(1, 1, 0)，以及任何值给**伤害**变量。最后，我们应该得到以下类似的结果：
- en: '![Tons of sprinkles through Prefabs](img/image00379.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![通过Prefab生成的无数洒水器](img/image00379.jpeg)'
- en: If we press the play button, we can see our sprinkle leading in the direction
    we specified, and be destroyed after `10` seconds.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下播放按钮，我们可以看到我们的洒水器按照我们指定的方向前进，并在`10`秒后被摧毁。
- en: Then, we need to assign the **Z** value on the Prefab. Since it is a projectile,
    we can look at the table with all the **Z **values for our objects we made earlier.
    Therefore, we need to assign `-2` as the value. We also need to assign the tag
    to our projectile. We will use this tag later on, but it's better to assign it
    now to the Prefab.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在Prefab上分配**Z**值。由于它是一个抛射物，我们可以查看我们之前制作的物体所有的**Z**值表格。因此，我们需要将`-2`作为值分配。我们还需要将标签分配给我们的抛射物。我们稍后会使用这个标签，但现在最好将其分配给Prefab。
- en: 'To assign a tag, on top of the **Inspector**, just below the game object name,
    there is the **Tag** field, as highlighted in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配一个标签，在**检查器**上，游戏对象名称下方，有一个**标签**字段，如下面的截图所示：
- en: '![Tons of sprinkles through Prefabs](img/image00380.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![通过Prefab生成的无数洒水器](img/image00380.jpeg)'
- en: 'Once clicked, a drop-down menu appears, where it is possible to choose from
    the different tags, including the two we defined previously:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击，就会出现一个下拉菜单，其中可以选择不同的标签，包括我们之前定义的两个标签：
- en: '![Tons of sprinkles through Prefabs](img/image00381.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![通过Prefab生成的无数洒水器](img/image00381.jpeg)'
- en: 'We can assign the **Projectile** tag to our Prefab, and in the end, it should
    look like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将**抛物线**标签分配给我们的Prefab，最终它应该看起来像这样：
- en: '![Tons of sprinkles through Prefabs](img/image00382.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![通过Prefab生成的无数洒水器](img/image00382.jpeg)'
- en: And this is all we need to do to fabricate our projectiles. In fact, we can
    now use this Prefab to spawn the sprinkles when we need to.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们制造抛射物所需做的所有事情。实际上，我们现在可以在需要时使用这个Prefab来生成洒水器。
- en: Baking cupcakes towers
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作纸杯蛋糕塔
- en: In this section, we will see how to create our towers. This is not an easy task,
    but by doing this we will acquire a lot of scripting skills.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何创建我们的塔。这不是一项容易的任务，但通过这样做，我们将获得大量的脚本编写技能。
- en: What a cupcake tower does
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蛋糕塔的作用
- en: First of all, it's useful to write down what we want to achieve and define what
    exactly a cupcake tower is supposed to do.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，写下我们想要实现的目标，并定义蛋糕塔确切应该做什么是有用的。
- en: 'The best way is to write down a list, to have clear idea of what we are trying
    to achieve:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是写下列表，以便清楚地了解我们想要实现的目标：
- en: A cupcake tower is able to detect pandas within a certain range.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋糕塔能够检测一定范围内的熊猫。
- en: A cupcake tower shoots a different kind of projectile according to its typology
    against the pandas within a certain range. Furthermore, within this range, it
    uses a policy to decide which panda to shoot.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋糕塔根据其类型对一定范围内的熊猫发射不同类型的弹道。此外，在这个范围内，它使用一种策略来决定射击哪只熊猫。
- en: There is a reload time before the cupcake tower is able to shoot again.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蛋糕塔能够再次射击之前，有一个装填时间。
- en: The cupcake tower can be upgraded (to a bigger cupcake!), increasing its stats
    and therefore changing its appearance.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋糕塔可以升级（到一个更大的蛋糕！），提高其统计数据，从而改变其外观。
- en: Scripting the cupcake tower
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写蛋糕塔的脚本
- en: As we have seen in the previous section, there are many things to implement.
    Let's start by creating a new script and naming it `CupcakeTowerScript`. As we
    already mentioned for the projectile script, in this chapter, we implement the
    main logic, but of course there is always space to improve, as we will see later
    in the book.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，有许多事情需要实现。让我们先创建一个新的脚本，并将其命名为`CupcakeTowerScript`。正如我们之前提到的，对于弹道脚本，在本章中，我们实现主要逻辑，但当然，总有改进的空间，正如我们将在本书后面看到的。
- en: Shooting to the pandas
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 射击熊猫
- en: Even if we don't have enemies yet, we can already start to program the behavior
    of the cupcake towers to shoot to the enemies. In this section, we will learn
    a bit about using physics to detect objects within a range. However, we will see
    colliders in more detail in [Chapter 5](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone - Sweet-Toothed
    Pandas Strike*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们现在还没有敌人，我们也可以开始编写蛋糕塔射击敌人的行为。在本节中，我们将了解一些关于使用物理检测范围内对象的知识。然而，我们将在[第5章](part0056.xhtml#aid-1LCVG1
    "第4章。不再孤单——甜食熊猫出击")中更详细地了解碰撞体，*不再孤单——甜食熊猫出击*。
- en: 'Let''s start by defining four variables. The first three are public, so we
    can set them in the Inspector. The last one is private, since we only need it
    to check how much time has elapsed. In particular, the first three variables store
    the parameters of our tower. There are the projectile Prefab, its range, and its
    reload time. We can write the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义四个变量。前三个是公共的，因此我们可以在检查器中设置它们。最后一个变量是私有的，因为我们只需要它来检查已经过去了多少时间。特别是，前三个变量存储我们塔的参数。它们是弹道Prefab、其范围和其装填时间。我们可以写下以下内容：
- en: '[PRE9]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in the `Update()` function we need to check if enough time has elapsed
    in order to shoot. This can be easily done by using an if statement. In any case,
    at the end, the time elapsed should be increased:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Update()`函数中，我们需要检查是否已经过去了足够的时间以便射击。这可以通过使用一个if语句轻松完成。无论如何，在最后，应增加已过时间：
- en: '[PRE10]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within the `if` statement, we need to reset the elapsed time, so as to be able
    to shoot the next time. Then, we need to check whether there are some game objects
    within its range or not:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句中，我们需要重置已过时间，以便在下一次射击时使用。然后，我们需要检查是否在其范围内有某些游戏对象：
- en: '[PRE11]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If there are enemies within range, we need to decide a policy about which enemy
    the tower should be targeted. There are different ways to do this and different
    strategies that the tower itself could choose. Here, we are going to implement
    one where the nearest enemy to the tower will be the one targeted. Different policies
    and strategies will be discussed in the last chapter of this book.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果范围内有敌人，我们需要决定一个策略，关于塔应该针对哪个敌人。有不同方法来做这件事，塔本身可以选择不同的策略。在这里，我们将实现一个最近的敌人将被针对的策略。不同的策略和策略将在本书的最后一章讨论。
- en: 'To implement this policy, we need to loop all all the game objects that we
    have found in range, check if they actually are enemies, and using distances,
    pick the nearest one. To achieve this, write the following code inside the previous
    if statement:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这项政策，我们需要遍历所有在范围内的游戏对象，检查它们是否实际上是敌人，并使用距离选择最近的一个。为了实现这一点，在之前的if语句中写入以下代码：
- en: '[PRE12]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we find the target, we need to get the direction that the tower will throw
    the projectile. So, let''s write this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到目标，我们需要获取塔将投掷投射物的方向。所以，让我们写下这个：
- en: '[PRE13]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we need to instantiate a new projectile, and assign to it the direction
    of the enemy, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实例化一个新的投射物，并将其方向分配给敌人，如下所示：
- en: '[PRE14]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Instantiating GameObjects is usually slow, and it should be avoided. However,
    for learning purposes, we can live with that. In the last chapter, we will see
    some optimization technique to get rid of this instantiation. And that is it for
    shooting the enemies.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化GameObject通常很慢，应该避免。然而，出于学习目的，我们可以容忍这一点。在最后一章，我们将看到一些优化技术来消除这种实例化。至于射击敌人，这就完成了。
- en: Upgrading the cupcake tower, making it even tastier
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级纸杯蛋糕塔，使其更加美味
- en: 'In order to create a function to upgrade the tower, we first need to define
    a variable to store the actual level of the tower:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个升级塔的函数，我们首先需要定义一个变量来存储塔的实际等级：
- en: '[PRE15]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we need an array with all the Sprites for the different upgrades, like
    this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个包含所有不同升级的Sprite的数组，如下所示：
- en: '[PRE16]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A third variable is required to check when the cupcake tower is upgradable,
    so we can add:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 需要第三个变量来检查纸杯蛋糕塔何时可以升级，因此我们可以添加：
- en: '[PRE17]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we can create our upgrade function. The first thing to do is to check
    if the tower is actually upgradable and then increase its level. Then, we can
    check (based on how many different graphics we have), if the tower has reached
    its maximum level, and in that case is preventing the player from upgrading it
    anymore, by assigning the false value to the `isUpgradable` variable. After that,
    we need to upgrade the graphics, and increase the stats. Feel free to tweak these
    values as you prefer. However, don''t forget to assign the new Sprite. In the
    end, you should have something like the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建我们的升级函数。首先，我们需要检查塔是否可以升级，然后提高它的等级。然后，我们可以根据我们拥有的不同图形的数量来检查，塔是否已经达到最大等级，如果是这样，通过将`isUpgradable`变量设置为false值，阻止玩家再对其进行升级。之后，我们需要升级图形，并提高统计数据。请随意调整这些值，按您喜欢的调整。然而，不要忘记分配新的Sprite。最后，您应该得到以下类似的内容：
- en: '[PRE18]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save the script, and for now, we are done with it. We will need to modify this
    function later in the book, but for now, let's create a Prefab for our cupcake.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，现在我们对此已经完成了。我们将在本书的后面修改这个函数，但现在让我们为我们的纸杯创建一个预制件。
- en: A pre-baked cupcake tower through Prefabs
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过预制件制作的预烘焙纸杯蛋糕塔
- en: As we have done with the sprinkles, we need to do something similar for the
    cupcake tower. In the `Prefabs` folder in the **Project** panel, create a new
    Prefab by right-clicking and then navigating to **Create** | **Prefab**. Name
    it `SprinklesCupcakeTower`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对糖霜所做的那样，我们需要对纸杯蛋糕塔做类似的事情。在**项目**面板的`Prefabs`文件夹中，通过右键单击并导航到**创建** | **预制件**创建一个新的预制件。将其命名为`SprinklesCupcakeTower`。
- en: 'Now, drag and drop `Sprinkles_Cupcake_Tower_0` from the `Graphics/towers` folder
    (within the `cupcake_tower_sheet-01` file) in the **Scene** View. Attach `CupcakeTowerScript`
    to the object by navigating to **Add Component** | **Script** | `CupcakeTowerScript`.
    The **Inspector** should look like the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`Sprinkles_Cupcake_Tower_0`从`Graphics/towers`文件夹（在`cupcake_tower_sheet-01`文件内）拖放到**场景视图**中。通过导航到**添加组件**
    | **脚本** | `CupcakeTowerScript`将`CupcakeTowerScript`附加到对象上。**检查器**应该看起来像以下这样：
- en: '![A pre-baked cupcake tower through Prefabs](img/image00383.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![通过预制件制作的预烘焙纸杯蛋糕塔](img/image00383.jpeg)'
- en: 'We need to assign `Pink_Sprinkle_Projectile_Prefab` to the **Projectile Prefab**
    variable. Then, we need to assign the different Sprites for the upgrades. In particular,
    we can use `Sprinkles_Cupcake_Tower_*` (replacing the `*` with the level of the
    cupcake tower) from the same sheet as earlier. Don''t worry too much about the
    other parameters of the tower, such as the range radius or the reload time, since
    we will see how to balance the game later on. At the end, this is what we should
    see:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `Pink_Sprinkle_Projectile_Prefab` 分配给 **Projectile Prefab** 变量。然后，我们需要为升级分配不同的
    Sprites。特别是，我们可以使用与之前相同的表格中的 `Sprinkles_Cupcake_Tower_*`（将 `*` 替换为纸杯蛋糕塔的等级）。不必过于担心塔的其他参数，例如射程半径或装填时间，因为我们将在稍后看到如何平衡游戏。最后，我们应该看到以下内容：
- en: '![A pre-baked cupcake tower through Prefabs](img/image00384.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![通过 Prefabs 预先烘焙的纸杯蛋糕塔](img/image00384.jpeg)'
- en: The last step is to drag this game object inside the Prefab. As a result, our
    cupcake tower is ready.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将这个游戏对象拖放到 Prefab 中。结果，我们的纸杯蛋糕塔就准备好了。
- en: More about coding in Unity
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于在 Unity 中编码的内容
- en: Before we continue, there are few more things to learn.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一些其他的事情需要学习。
- en: Later in the book, we will use both static variables and inheritance. These
    are topics related with C# more than with Unity, but they are important if you
    want to become a good game developer. Next, you can find a very brief explanation,
    but I recommend that you learn them properly from a C# book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将使用静态变量和继承。这些主题与 C# 比起 Unity 来说更为相关，但如果你想要成为一名优秀的游戏开发者，它们是非常重要的。接下来，你可以找到一个非常简短的说明，但我建议你从
    C# 书籍中正确地学习它们。
- en: Finally, there is probability, which is a topic of math, as we discussed previously,
    and it is essential in game development. However, once you know the basics of
    probability, you should be able to generate random numbers in Unity.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有概率，正如我们之前讨论的，它是游戏开发中必不可少的。然而，一旦你掌握了概率的基础，你应该能够在 Unity 中生成随机数。
- en: Static variables
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态变量
- en: Some classes (or components, in the case of Unity), contain variables, which
    eventually can be set in the Inspector or changed at runtime. However, the whole
    class can share a variable among all its instances. Such variables are referred
    to as static variables and are declared with the `static` keyword. A common use
    is to share a reference to another component, which all the instances of the class
    should refer to. We will see this better later in the book, when we will use static
    variables
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类（或组件，在 Unity 的情况下），包含变量，这些变量最终可以在检查器中设置或在运行时更改。然而，整个类可以将其变量共享给所有其实例。这些变量被称为静态变量，并使用
    `static` 关键字声明。一个常见的用途是共享对另一个组件的引用，所有类的实例都应该引用它。我们将在本书稍后更好地了解这一点，当我们使用静态变量时。
- en: Inheritance
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: If different classes share many features in common, we could give them an inheritance
    structure. This means, to have a parent class that holds the general and common
    features between these classes, and then they are implemented as children of the
    parent. A common example to clarify this is imagining the classes Fruit, Apple,
    and Banana. Fruit is the parent class, which holds all the properties of being
    a fruit (such as that it is edible), and the children share the same feature of
    the parent (since both an Apple and a Banana are fruits, and therefore edible).
    Then, they can implement the specific features of that fruit. For instance, the
    Apple is red, whereas the Banana is yellow.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不同的类在许多方面有共同之处，我们可以给它们一个继承结构。这意味着有一个父类，它包含这些类之间的一般和共同特征，然后它们作为父类的子类来实现。一个常见的例子是为了阐明这一点，想象一下
    Fruit、Apple 和 Banana 类。Fruit 是父类，它包含成为水果的所有属性（例如，它是可食用的），子类共享父类的相同特征（因为苹果和香蕉都是水果，因此是可食用的）。然后，它们可以实现该水果的具体特征。例如，苹果是红色的，而香蕉是黄色的。
- en: Sometimes, the parent class can also have functions (such as `Eat()`) which
    all the children can give their own implementation. This leads to the difference
    between the abstract and virtual methods.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，父类也可以有自己的函数（例如 `Eat()`），所有子类都可以提供自己的实现。这导致了抽象方法和虚拟方法之间的区别。
- en: Abstract methods are so abstract that the parent class cannot give an implementation
    of it, but its children have to. Virtual methods, instead, can be implemented
    in the parent class, since it offers general functionality, but children can override
    it to give a better implementation of it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法非常抽象，以至于父类不能为其提供实现，但它的子类必须提供。虚拟方法，相反，可以在父类中实现，因为它提供了通用功能，但子类可以覆盖它以提供更好的实现。
- en: We will look at inheritance in more detail, in [Chapter 7](part0088.xhtml#aid-2JTHG1
    "Chapter 7. Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming"), *Trading
    Cupcakes and the Ultimate Battle for the Cake - Gameplay Programming*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](part0088.xhtml#aid-2JTHG1 "第7章。交易蛋糕和终极蛋糕之战 – 游戏玩法编程")中更详细地探讨继承，*交易蛋糕和终极蛋糕之战
    - 游戏玩法编程*。
- en: Random numbers in Unity
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中的随机数
- en: 'Generating random numbers in Unity is easy since Unity provides the class `Random`,
    which allows us to generate random numbers. The most used function of this class
    is `Range()`, which generates a random number between a min and a max value. Here
    is an example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中生成随机数很容易，因为Unity提供了`Random`类，它允许我们生成随机数。这个类最常用的函数是`Range()`，它生成一个介于最小值和最大值之间的随机数。以下是一个示例：
- en: '[PRE19]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For more information about the `Random` class, visit the official documentation
    here: [https://docs.unity3d.com/ScriptReference/Random.html](https://docs.unity3d.com/ScriptReference/Random.html).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于`Random`类的信息，请访问官方文档：[https://docs.unity3d.com/ScriptReference/Random.html](https://docs.unity3d.com/ScriptReference/Random.html)。
- en: Homework
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: In this chapter, we have seen how to use Prefabs to quickly replicate and clone
    GameObjects. So, before you continue with the next chapter, let's get good at
    using Prefabs.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用预制体快速复制和克隆GameObject。所以，在你继续下一章之前，让我们熟练地使用预制体。
- en: 'The following two exercises are needed to have the game completed at the end:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个练习是游戏完成时所需的：
- en: '**Arming the Cupcakes Towers (Part I)**:Inside `projectiles_sheet_01` in the
    `Graphics/projectiles` folder, there are nine different projectiles; however,
    we used only one, `Pink_Sprinkle`. Create the other eight Prefabs, with meaningful
    names. Don''t forget to attach the projectile script to all of them. Do not worry
    too much about the values assigned inside the script, such as the damage, since
    we will see the balance of the game later on in the book. However, do not forget
    to assign the right **Z** value and the proper tag.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**武装蛋糕塔（第一部分）**：在`Graphics/projectiles`文件夹中的`projectiles_sheet_01`内部，有九种不同的投射物；然而，我们只使用了其中一种，`Pink_Sprinkle`。为其他八种预制体创建名称有意义的预制体。别忘了将投射物脚本附加到所有这些预制体上。不必过于担心脚本内部分配的值，例如伤害，因为我们在本书后面的部分将看到游戏的平衡。然而，别忘了分配正确的**Z**值和适当的标签。'
- en: '**Arming the Cupcakes Towers (Part II)**: Inside `cupcake_tower_sheet-01` in
    the `Graphics/towers` folder, there are three different towers with their respective
    upgrading levels; however, we only used the sprinkle cupcake tower. Create the
    other two Prefabs for the chocolate and lemon cupcake towers. Don''t forget to
    attach the cupcake tower script to both of them and assign the respective projectiles
    and upgrade levels graphic. Again, don''t worry much about the values, such as
    the range radius, because we will see the balance of the game later in the book.
    However, don''t forget to assign the right **Z** value.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**武装蛋糕塔（第二部分）**：在`Graphics/towers`文件夹中的`cupcake_tower_sheet-01`内部，有三个不同的塔及其相应的升级级别；然而，我们只使用了洒糖蛋糕塔。为巧克力和柠檬蛋糕塔创建另外两个预制体。别忘了将蛋糕塔脚本附加到这两个预制体上，并分配相应的投射物和升级级别图形。同样，不必过于担心值，例如范围半径，因为我们在本书后面的部分将看到游戏的平衡。然而，别忘了分配正确的**Z**值。'
- en: 'The following exercises will help you to improve your skills by familiarizing
    yourself with best practices:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下练习将帮助你通过熟悉最佳实践来提高你的技能：
- en: '**Formatting scripts for designers (Part I)**: In our scripts, we used many
    variables. Comments next to them help us to understand their function; however,
    these comments are hidden to designers. Therefore, it''s good practice to add
    tooltips to show up in the **Inspector**. If you want, you can use the text of
    the comments as parameter for the tooltips.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为设计师格式化脚本（第一部分）**：在我们的脚本中，我们使用了许多变量。它们旁边的注释帮助我们理解它们的功能；然而，这些注释对设计师来说是隐藏的。因此，添加工具提示以在**检查器**中显示是一个好习惯。如果你愿意，可以使用注释的文本作为工具提示的参数。'
- en: '**Formatting scripts for designers (Part II)**: Even if our scripts in the
    **Inspector** look good, they can be improved if we add some headings before groups
    of variables. So, assign meaningful headings and reorder the variables to fit
    in these headings.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为设计师格式化脚本（第二部分）**：即使我们在**检查器**中的脚本看起来不错，如果我们给变量组添加一些标题，它们还可以得到改进。因此，分配有意义的标题并重新排列变量以适应这些标题。'
- en: '**Formatting scripts for designers (Part III)**: The `direction` variable inside
    the projectile script must be set to public since it is changed from the cupcake
    tower script. However, it should be visible in the **Inspector**. Use attributes
    to hide it from the **Inspector**.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为设计师格式化脚本（第三部分）**：在弹道脚本内部的`direction`变量必须设置为公共的，因为它是从纸杯蛋糕塔脚本中改变的。然而，它应该在**检查器**中可见。使用属性来隐藏它从**检查器**中。'
- en: '**Formatting scripts for designers (Part IV)**: Some variables in our scripts
    are better to show with a slider rather than a numeric input field, especially
    those that cannot assume negative numbers. For these, transform their appearance
    to a slider and don''t allow negative values for them.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为设计师格式化脚本（第四部分）**：在我们的脚本中，一些变量最好用滑块来显示，而不是数字输入字段，尤其是那些不能假设为负数的变量。对于这些变量，将它们的显示形式转换为滑块，并禁止它们有负值。'
- en: '**Best Practices (Part I)**: Inside the cupcake tower script there is the `Upgrade
    Level` variable, which is private. However, it might be useful to create a get
    function to retrieve its value. By following the guidelines in the link shown
    in the *Variables* section of this chapter, implement the respective get function.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最佳实践（第一部分）**：在纸杯蛋糕塔脚本内部有一个`Upgrade Level`变量，它是私有的。然而，创建一个获取函数来检索其值可能是有用的。通过遵循本章*变量*部分中显示的链接中的指南，实现相应的获取函数。'
- en: '**Best Practices (Part II)**: Again inside the cupcake tower script, inside
    the `Upgrade()` function, the `GetComponent()` function is called to get the `SpriteRenderer`.
    Best practice suggests to call this function only once and store the reference
    inside a variable. Create a new variable to store the `SpriteRenderer` component
    attached to the cupcake tower game object. Assign its value inside the `Start()`
    function by using the `GetComponent()` function. Then, use this variable in the
    `Upgrade()` function to update the graphic of the cupcake tower.'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最佳实践（第二部分）**：再次在纸杯蛋糕塔脚本内部，在`Upgrade()`函数中，调用`GetComponent()`函数来获取`SpriteRenderer`。最佳实践建议只调用一次这个函数，并将引用存储在一个变量中。创建一个新的变量来存储附加到纸杯蛋糕塔游戏对象的`SpriteRenderer`组件。通过在`Start()`函数中使用`GetComponent()`函数来分配其值。然后，在`Upgrade()`函数中使用这个变量来更新纸杯蛋糕塔的图形。'
- en: '**Best Practices (Part III)**: We didn''t define a tag for the cupcake towers
    because we don''t need to distinguish between them. However, it''s good practice
    to assign a tag to them. This is because it might be needed later on when we would
    like to extend our game (for example, enemies that try to avoid cupcake towers
    within their limits). Therefore, create a new cupcake tower tag and assign it
    to all the cupcake tower Prefabs (there should be three, also counting the one
    created in the first exercise of this section).'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最佳实践（第三部分）**：我们没有为纸杯蛋糕塔定义标签，因为我们不需要区分它们。然而，为它们分配一个标签是良好的实践。这是因为将来我们可能需要它，当我们想要扩展我们的游戏时（例如，敌人试图在其限制内避免纸杯蛋糕塔）。因此，创建一个新的纸杯蛋糕塔标签，并将其分配给所有纸杯蛋糕塔Prefab（应该有三个，包括本节第一个练习中创建的一个）。'
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use Prefabs to quickly replicate and clone
    game objects. We also learned how to place 2D objects, order them with the Z-Buffering
    method, as well as how to set up tags and layers in Unity. Then, we created a
    couple of scripts, and learned along the way how to code complex behaviors with
    just a few lines. In fact, we explored how Unity handles scripts, their main functions
    and attributes, and the general execution order.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Prefab快速复制和克隆游戏对象。我们还学习了如何放置2D对象，使用Z-Buffering方法对它们进行排序，以及如何在Unity中设置标签和层。然后，我们创建了一些脚本，并在学习过程中了解到如何用几行代码编写复杂的行为。实际上，我们探索了Unity如何处理脚本，它们的主要功能和属性，以及一般的执行顺序。
- en: However, we will improve the scripts written in this chapter later on in the
    book, to improve the gameplay. In fact, the goal of this chapter was to get used
    to scripts, and to write down the main logic. Therefore, improving and tweaking
    is left for later.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将在本书的后面部分改进本章中编写的脚本，以改善游戏玩法。实际上，本章的目标是熟悉脚本，并记录主要逻辑。因此，改进和调整留待以后。
- en: In the next chapter, we will dive into the UI world, and integrate it into our
    game.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入UI世界，并将其集成到我们的游戏中。
