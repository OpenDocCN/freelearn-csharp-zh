<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer106">
			<h1 id="_idParaDest-107"><em class="italic"><a id="_idTextAnchor106"/>Chapter 7</em>: Unity API – Making Choices and Story Progression</h1>
			<p>This chapter begins with reviewing how to add a <strong class="source-inline">script</strong> component to a game object in Unity. By creating a <strong class="source-inline">script</strong> component associated with a C# file, code can be written to load the compiled JSON files created by the ink-Unity Integration plugin from ink source files as part of the Unity scene. Next, we will examine how to load an ink story and start to progress through it. We will see how to programmatically make selections of options presented by ink and then how to continue story progression as a result. We will end with an example of a common approach of presenting multiple user interface elements to a player in Unity. A user will be able to click buttons in Unity and guide story progression in a running ink story.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Loading a compiled ink story</li>
				<li>Selecting options programmatically</li>
				<li>Creating a dynamic user interface</li>
			</ul>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Technical requirements</h1>
			<p>The examples used in this chapter, in <strong class="source-inline">*.ink</strong> files, can be found online on GitHub: <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7</a>.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Loading a compiled ink story</h1>
			<p>In <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink-Unity Integration Plugin</em>, we saw how to<a id="_idIndexMarker246"/> add new ink files to a Unity project. After importing the plugin, new files can be created using the <strong class="bold">Create</strong> menu from the <strong class="bold">Project</strong> window. When an ink source was added, the plugin automatically created a compiled JSON file. As we now move into working with the ink API provided by the plugin, we will use the created JSON files for working with a story.</p>
			<p>The first step for working with code in Unity is to create a <strong class="source-inline">GameObject</strong>. This is a basic container in Unity. Each <strong class="source-inline">GameObject</strong> holds at least one component. The different systems in Unity, such as the rendering system (for drawing things on a screen), physics (for detecting whether two things overlap on a screen), and input (for detecting whether a user presses a button) all communicate with these components. When Unity runs a project, it sends data to components matching the system associated with it. For example, to work with data from the input system, an input component is needed.</p>
			<p>To work with code in Unity, a <strong class="source-inline">script</strong> component is needed. All code added to a Unity project works through being a part of different systems. A <strong class="source-inline">script</strong> component allows a developer to write code for working with a game object and the different components it contains. Unlike most other components that primarily receive data from different systems, a <strong class="source-inline">script</strong> component can <em class="italic">script</em> other objects and values. Through code, it can instruct other components to change their values when different events, such as a user clicking on a button, happen.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Creating a script component</h2>
			<p>Any game<a id="_idIndexMarker247"/> object <a id="_idIndexMarker248"/>can have a <strong class="source-inline">script</strong> component. However, for better organization, it is often useful to create a new <strong class="source-inline">GameObject</strong> for each type of data, behavior, or task related to a project. This separates each new action or possible event with a <strong class="source-inline">GameObject</strong> and makes working on the different parts of a larger project much easier:</p>
			<ol>
				<li>Open a new or existing Unity project.</li>
				<li>If not already added, be sure to install the ink-Unity Integration plugin.<p>There are always multiple ways to do things in Unity, and this is also true of creating a new game object. One of the easiest ways to create a new game object is by using the <strong class="bold">GameObject</strong> menu.</p></li>
				<li>Click<a id="_idIndexMarker249"/> on <strong class="bold">GameObject</strong> and then <a id="_idIndexMarker250"/>click on <strong class="bold">Create Empty</strong>.<div id="_idContainer064" class="IMG---Figure"><img src="Images/Figure_7.1_B17597.jpg" alt="Figure 7.1 – GameObject menu&#13;&#10;" width="260" height="135"/></div><p class="figure-caption">Figure 7.1 – GameObject menu</p></li>
				<li>A new <strong class="source-inline">GameObject</strong> will be created and added to the <strong class="bold">Hierarchy</strong> view. Clicking on the created <strong class="source-inline">GameObject</strong> will show its current components in the <strong class="bold">Inspector</strong> view.<div id="_idContainer065" class="IMG---Figure"><img src="Images/Figure_7.2_B17597.jpg" alt="Figure 7.2 – Inspector view in Unity&#13;&#10;" width="599" height="278"/></div><p class="figure-caption">Figure 7.2 – Inspector view in Unity</p><p>Each <strong class="source-inline">GameObject</strong> is merely a container. Its components do all the work involved with running the project. Even the name of the <strong class="source-inline">GameObject</strong> is a value contained as part of its components.</p></li>
				<li>To <a id="_idIndexMarker251"/>change the name of the <a id="_idIndexMarker252"/>created <strong class="source-inline">GameObject</strong>, click on it in the <strong class="bold">Hierarchy</strong> view to show its components in the <strong class="bold">Inspector</strong> view. Click on <strong class="bold">text entry</strong> and change the name from <strong class="source-inline">GameObject</strong> (the default value) to <strong class="source-inline">Ink</strong> <strong class="source-inline">Story</strong>.<div id="_idContainer066" class="IMG---Figure"><img src="Images/Figure_7.3_B17597.jpg" alt="Figure 7.3 – Ink Story name change in Unity&#13;&#10;" width="645" height="297"/></div><p class="figure-caption">Figure 7.3 – Ink Story name change in Unity</p><p>The newly named <strong class="source-inline">Ink</strong> <strong class="source-inline">Story</strong> will be a container for other components related to running an ink story. Changing the name of the game object to <strong class="source-inline">Ink</strong> <strong class="source-inline">Story</strong> makes it easier to find it among potentially many other objects in the project and explains its role in the project as well.</p></li>
				<li>With the components of <strong class="source-inline">Ink</strong> <strong class="source-inline">Story</strong> shown in the <strong class="bold">Inspector</strong> view, click on <strong class="bold">Add Component</strong>.<div id="_idContainer067" class="IMG---Figure"><img src="Images/Figure_7.4_B17597.jpg" alt="Figure 7.4 – Component listing in the Add Component menu&#13;&#10;" width="254" height="371"/></div><p class="figure-caption">Figure 7.4 – Component listing in the Add Component menu</p></li>
				<li>In<a id="_idIndexMarker253"/> the<a id="_idIndexMarker254"/> listing, click on <strong class="bold">New script</strong>.<div id="_idContainer068" class="IMG---Figure"><img src="Images/Figure_7.5_B17597.jpg" alt="Figure 7.5 – New script component creation" width="282" height="269"/></div><p class="figure-caption">Figure 7.5 – New script component creation</p></li>
				<li>Name this new script file <strong class="source-inline">inkLoader.cs</strong>.<p class="callout-heading">Note </p><p class="callout">Clicking on the <strong class="source-inline">script</strong> component name does not always allow access to rename the file in Unity. Pressing the down arrow twice on the keyboard will move the selection from the<a id="_idIndexMarker255"/> search<a id="_idIndexMarker256"/> to the title of the file.</p><div id="_idContainer069" class="IMG---Figure"><img src="Images/Figure_7.6_B17597.jpg" alt="Figure 7.6 – Script renamed InkLoader" width="355" height="344"/></div><p class="figure-caption">Figure 7.6 – Script renamed InkLoader</p></li>
				<li>After renaming the file, click the <strong class="bold">Create and Add</strong> button. A new C# file will be added to the <strong class="bold">Project</strong> window.<div id="_idContainer070" class="IMG---Figure"><img src="Images/Figure_7.7_B17597.jpg" alt="Figure 7.7 – Assets in Unity with the new InkLoader.cs file&#13;&#10;" width="249" height="196"/></div><p class="figure-caption">Figure 7.7 – Assets in Unity with the new InkLoader.cs file</p></li>
				<li>Double-click on this file to open it in Visual Studio for editing. </li>
			</ol>
			<p>This first section has included a step-by-step process of preparing a Unity project for working with the ink Story API. We have seen how to create a <strong class="source-inline">GameObject</strong> and add a <strong class="source-inline">script</strong> component. In <a id="_idIndexMarker257"/>the next section, we will build on this project to begin to work with the Story API added to Unity as part of the <a id="_idIndexMarker258"/>ink-Unity Integration plugin.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Adding the ink Story API</h2>
			<p>Installing <a id="_idIndexMarker259"/>the ink-Unity Integration plugin adds an <a id="_idIndexMarker260"/>additional <strong class="bold">namespace</strong> for use with C# code in Unity. A namespace is a collection of classes and methods collected under a common name and set of actions. The namespace added by the ink-Unity Integration plugin is called <strong class="source-inline">Ink</strong>. It contains, in turn, three other namespaces named <strong class="source-inline">Parsed</strong>, <strong class="source-inline">Runtime</strong>, and <strong class="source-inline">UnityIntegration</strong>, each of which contains classes related to their names. To work with compiled ink JSON files, the <strong class="source-inline">Ink</strong><strong class="source-inline">.Runtime</strong> namespace is needed. This tells Unity that it should start with the <strong class="source-inline">ink</strong> namespace and then find the namespace within it named <strong class="source-inline">Runtime</strong>:</p>
			<ol>
				<li value="1">In the file opened in the <em class="italic">Creating a script component</em> section, add a new <strong class="source-inline">using</strong> line after those already there in the created file:<p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using UnityEngine;</p><p class="source-code"><strong class="bold">using Ink.Runtime;</strong></p><p>The <strong class="source-inline">using</strong> keyword tells Unity to include the <strong class="source-inline">Ink.Runtime</strong> namespace and allow its classes to be used as part of this file.</p></li>
				<li>Next, create a public field called <strong class="source-inline">inkJSONAsset</strong> and change the <strong class="source-inline">Start()</strong> method to the following:<p class="source-code">public class InkLoader: MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">public TextAsset InkJSONAsset;</strong></p><p class="source-code">    // Start is called before the first frame update</p><p class="source-code">    void Start()</p><p class="source-code">    {</p><p class="source-code">        <strong class="bold">Story exampleStory = new Story</strong></p><p class="source-code"><strong class="bold">          (InkJSONAsset.text);</strong></p><p class="source-code">    }</p><p class="source-code">}</p><p>The use of the <strong class="source-inline">InkJSONAsset</strong> field with the <strong class="source-inline">public</strong> keyword will allow this value to be changed inside the Unity editor. The addition of the <strong class="source-inline">Story</strong> class creates a new<a id="_idIndexMarker261"/> ink<a id="_idIndexMarker262"/> story as part of the <strong class="source-inline">Runtime</strong> namespace. This is known as the <em class="italic">Story API</em> because multiple methods will be used as part of the <strong class="source-inline">Story</strong> class.</p></li>
				<li>Save the <strong class="source-inline">InkLoader.cs</strong> file in Visual Studio and return to Unity.</li>
				<li>After a moment, Unity will refresh and reload the changed C# file.</li>
				<li>The final step is to associate an ink JSON file with the created C# file. In the <strong class="bold">Hierarchy</strong> view, click on the <strong class="source-inline">InkStory</strong> game object. In the <strong class="bold">Inspector</strong> view, there will be a new property under the <strong class="source-inline">script</strong> component, as shown in the following screenshot:<div id="_idContainer071" class="IMG---Figure"><img src="Images/Figure_7.8_B17597.jpg" alt="Figure 7.8 – New Ink JSON Asset property in the Inspector view&#13;&#10;" width="610" height="147"/></div><p class="figure-caption">Figure 7.8 – New Ink JSON Asset property in the Inspector view</p><p>The property shows the value <strong class="source-inline">None (Text Asset)</strong>. This means no files are associated with this property. To change this, a compiled JSON file needs to be added.</p><p class="callout-heading">Note </p><p class="callout">An ink JSON file will be needed for the next steps. If one is not created, add a new one by creating an ink file and letting the <strong class="bold">Automatic compile</strong> option create one, or click on an existing ink source file and then click on <strong class="bold">Compile</strong> in the <strong class="bold">Inspector</strong> view to create a new JSON file.</p></li>
				<li>Click on the <strong class="bold">TextAsset</strong> selection<a id="_idIndexMarker263"/> circle next to the<a id="_idIndexMarker264"/> value to open a <strong class="bold">Select TextAsset</strong> window.<div id="_idContainer072" class="IMG---Figure"><img src="Images/Figure_7.9_B17597.jpg" alt="Figure 7.9 – Select TextAsset window&#13;&#10;" width="301" height="198"/></div><p class="figure-caption">Figure 7.9 – Select TextAsset window</p></li>
				<li>Select an ink-compiled JSON file.<div id="_idContainer073" class="IMG---Figure"><img src="Images/Figure_7.10_B17597.jpg" alt="Figure 7.10 – Updated Ink JSON Asset property&#13;&#10;" width="701" height="432"/></div><p class="figure-caption">Figure 7.10 – Updated Ink JSON Asset property</p><p>After the value of the <strong class="bold">Ink JSON Asset</strong> property updates, close the <strong class="bold">Select TextAsset</strong> window.</p></li>
				<li>Click on the <strong class="bold">Play</strong> button in the middle of the Unity editor.</li>
			</ol>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="Images/Figure_7.11_B17597.jpg" alt="Figure 7.11 – Play button in Unity&#13;&#10;" width="216" height="91"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Play button in Unity</p>
			<p>Unity will run the current scene, and nothing will appear to happen. If no errors appear in the <strong class="bold">Console</strong> window, everything<a id="_idIndexMarker265"/> has run correctly. Internally, Unity has loaded the compiled<a id="_idIndexMarker266"/> ink JSON file and is ready to run the ink story.</p>
			<p>Stop the running scene by clicking on the <strong class="bold">Play</strong> button a second time.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Running an ink JSON file</h2>
			<p>ink stories<a id="_idIndexMarker267"/> are run using the <strong class="source-inline">Story</strong> class and <a id="_idIndexMarker268"/>methods. Loading an ink JSON file is only the first step. The <strong class="source-inline">Story</strong> class must be told to load one or more <em class="italic">lines</em> of the story at a time.</p>
			<p>When Inky was used to run the ink source file previously, it displayed one line at a time with an empty line between them:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1:</p>
			<p class="source-code">This is the start.</p>
			<p class="source-code">And then this happens.</p>
			<p>When run in Inky, <em class="italic">Example 1</em> creates the following output:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="Images/Figure_7.12_B17597.jpg" alt="Figure 7.12 – Example 1 output&#13;&#10;" width="451" height="152"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – Example 1 output</p>
			<p>In Inky, the extra lines it created are a result of its own use of the Story API. To replicate this output, we will need to add a new method: <strong class="source-inline">Continue()</strong>:</p>
			<ol>
				<li value="1">In the same file used as part of the <em class="italic">Adding the ink Story API</em> section, open the file in Inky for editing.</li>
				<li>Change the content of the new ink source file to <em class="italic">Example 1</em> and then save the file in Inky. Do not close Inky after saving the file. Now return to Unity.</li>
				<li>Upon detecting the change in the ink source file, the ink-Unity Integration plugin will automatically re-compile the ink JSON file. Because it was associated with the Ink JSON Asset property as part of the <em class="italic">Adding the ink Story API</em> section, the ink JSON <a id="_idIndexMarker269"/>file will also always be loaded correctly.</li>
				<li>If the <strong class="source-inline">InkLoader.cs</strong> file is not already open in Visual Studio, double-click on it in the <strong class="bold">Project</strong> window.</li>
				<li>Add the following line to the <strong class="source-inline">Start()</strong> method:<p class="source-code">void Start()</p><p class="source-code">{</p><p class="source-code">Story exampleStory = new Story(InkJSONAsset.text);</p><p class="source-code"><strong class="bold">  Debug.Log(exampleStory.Continue());</strong></p><p class="source-code">}</p></li>
				<li>Save the changed <strong class="source-inline">inkLoader.cs</strong> file and return to Unity.</li>
				<li>Click on the <strong class="bold">Play</strong> button to run the current scene.<p>This time, the <strong class="bold">Console</strong> window will show a message.</p></li>
			</ol>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="Images/Figure_7.13_B17597.jpg" alt="Figure 7.13 – Console window in Unity&#13;&#10;" width="380" height="124"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – Console window in Unity</p>
			<p>The <strong class="source-inline">Debug.Log()</strong> method used what was returned by the <strong class="source-inline">Continue()</strong> method as part of the <strong class="source-inline">Story</strong> class to display a message in the <strong class="bold">Console</strong> window.</p>
			<p>Each time the <strong class="source-inline">Continue()</strong> method is called, it loads the next line in an ink story and returns a string representing it. However, the method has an issue: it cannot detect the end of a story. For that, a different property is required.</p>
			<p>Stop<a id="_idIndexMarker270"/> the <a id="_idIndexMarker271"/>running scene by clicking on the <strong class="bold">Play</strong> button again.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Checking whether a story can continue</h2>
			<p>The <strong class="source-inline">Continue()</strong> method<a id="_idIndexMarker272"/> loads the next line<a id="_idIndexMarker273"/> of a story if it is available. In the code from <em class="italic">Example 1</em>, there are two lines.</p>
			<ol>
				<li value="1">Return to Visual Studio and edit the <strong class="source-inline">Ink</strong><strong class="source-inline">Loader.cs</strong> file. Change the <strong class="source-inline">Story()</strong> method to the following:<p class="source-code">void Start()</p><p class="source-code">{</p><p class="source-code">Story exampleStory = new Story(InkJSONAsset.text);</p><p class="source-code">Debug.Log(exampleStory.Continue());</p><p class="source-code"><strong class="bold">Debug.Log(exampleStory.Continue());</strong></p><p class="source-code">}</p></li>
				<li>Save the <strong class="source-inline">InkLoader.cs</strong> file after adding the new line of code. Return to Unity and click on the <strong class="bold">Play</strong> button to play the current scene and updated file.</li>
				<li>The <strong class="bold">Console</strong> window will show two messages.<div id="_idContainer077" class="IMG---Figure"><img src="Images/Figure_7.14_B17597.jpg" alt="Figure 7.14 – Example 1 content loaded via the Continue() method&#13;&#10;" width="376" height="183"/></div><p class="figure-caption">Figure 7.14 – Example 1 content loaded via the Continue() method</p><p>Both lines from <em class="italic">Example 1</em> are now shown in the <strong class="bold">Console</strong> window. Each one was loaded<a id="_idIndexMarker274"/> by the <strong class="source-inline">Continue()</strong> method and then passed to the <strong class="source-inline">Debug.Log()</strong> method.</p></li>
				<li>Click on the <strong class="bold">Play</strong> button again in Unity to stop the current scene.</li>
				<li>Return to Visual Studio and edit the <strong class="source-inline">InkLoader.cs</strong> file. Add the following code to the <strong class="source-inline">Start()</strong> method:<p class="source-code">void Start()</p><p class="source-code">{</p><p class="source-code">Story exampleStory = new Story(InkJSONAsset.text);</p><p class="source-code">Debug.Log(exampleStory.Continue());</p><p class="source-code">Debug.Log(exampleStory.Continue());</p><p class="source-code"><strong class="bold">Debug.Log(exampleStory.Continue());</strong></p><p class="source-code">}</p></li>
				<li>Save the updated <strong class="source-inline">InkLoader.cs</strong> file.</li>
				<li>Return to Unity and play the scene.<p>With the third use of the <strong class="source-inline">Continue()</strong> method, an error will happen and be displayed in the <strong class="bold">Console</strong> window.</p><div id="_idContainer078" class="IMG---Figure"><img src="Images/Figure_7.15_B17597.jpg" alt="Figure 7.15 – Continue() error in the Unity console&#13;&#10;" width="1115" height="319"/></div><p class="figure-caption">Figure 7.15 – Continue() error in the Unity console</p></li>
				<li>Click on the <strong class="bold">Play</strong> button in Unity to stop the scene from running.<p>The error happened because the <strong class="source-inline">Continue()</strong> method does not check whether there is another line to load. When there is no more content, it throws an error.</p><p>To fix this<a id="_idIndexMarker275"/> issue, a <a id="_idIndexMarker276"/>property mentioned in the error is needed. The <strong class="source-inline">Story</strong> class provides the <strong class="source-inline">canContinue</strong> property for checking whether there is more story content to load. It contains a Boolean value. If there is more content, <strong class="source-inline">canContinue</strong> will be <strong class="source-inline">true</strong>. Otherwise, it will be <strong class="source-inline">false</strong>.</p></li>
				<li>Return to Visual Studio and edit the <strong class="source-inline">InkLoader.cs</strong> file. Update the <strong class="source-inline">Start()</strong> method<a id="_idIndexMarker277"/> in the <strong class="source-inline">InkLoader.cs</strong> file to the following:<p class="source-code">void Start()</p><p class="source-code">{</p><p class="source-code">Story exampleStory = new Story(InkJSONAsset.text);</p><p class="source-code"><strong class="bold">while(exampleStory.canContinue)</strong></p><p class="source-code"><strong class="bold">      {</strong></p><p class="source-code"><strong class="bold">          Debug.Log(exampleStory.Continue());</strong></p><p class="source-code">      <strong class="bold">}</strong></p><p class="source-code">}</p></li>
				<li>Save the edited <strong class="source-inline">InkLoader.cs</strong> file in Visual Studio.</li>
				<li>Return to Unity and play the scene again.</li>
			</ol>
			<p>With the use of a <strong class="source-inline">while</strong> loop, the story will be loaded line by line until there is no content left. Once this happens, the <strong class="source-inline">canContinue</strong> property is changed to <strong class="source-inline">false</strong> and the loop ends.</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="Images/Figure_7.16_B17597.jpg" alt="Figure 7.16 – Console window using an updated while loop&#13;&#10;" width="382" height="183"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – Console window using an updated while loop</p>
			<p>The combination of the <strong class="source-inline">canContinue</strong> property with the <strong class="source-inline">Continue()</strong> method is a common pattern when using the Story API. More advanced usage patterns may not use a <strong class="source-inline">while</strong> loop, but<a id="_idIndexMarker278"/> the property and method will <a id="_idIndexMarker279"/>often appear together.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Selecting options programmatically</h1>
			<p>Displaying <a id="_idIndexMarker280"/>only the text of an ink story has limited usefulness. Most advanced ink stories use weaves to present different options. Along with the <strong class="source-inline">Continue()</strong> method and the <strong class="source-inline">canContinue</strong> property, the Story API also has another property called <strong class="source-inline">currentChoices</strong> that contains a list of the options generated by the most recent weave.</p>
			<p>As was demonstrated in the <em class="italic">Checking whether a story can continue</em> section, the <strong class="source-inline">canContinue</strong> property is affected by the <strong class="source-inline">Continue()</strong> method. After each line is loaded and returned as a string, the <strong class="source-inline">Story</strong> class will update the <strong class="source-inline">canContinue</strong> property if there is more story to load. This is also true of the <strong class="source-inline">currentChoice</strong> property. When the <strong class="source-inline">Continue()</strong> method is used, it will load the next line <em class="italic">and</em> any weaves.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Any previously used game objects or C# files created as part of this chapter can safely be deleted. This section will create a new game object and script component, and use different code for working with weaves and options.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Detecting ink choices</h2>
			<p>The first<a id="_idIndexMarker281"/> step to act on a weave is to detect that its choices have been loaded by the <strong class="source-inline">currentChoices</strong> property. This means both the <strong class="source-inline">canContinue</strong> property and <strong class="source-inline">Continue()</strong> method are also needed. The first prevents any issues of trying to load content that may not exist and the second loads the current line and any weaves along the way:</p>
			<ol>
				<li value="1">In a new or existing Unity project with no other game objects using the Story API, create a new, empty <strong class="source-inline">GameObject</strong>. Name it <strong class="source-inline">Ink</strong> <strong class="source-inline">Choices</strong>.<div id="_idContainer080" class="IMG---Figure"><img src="Images/Figure_7.17_B17597.jpg" alt="Figure 7.17 – ink Choices GameObject&#13;&#10;" width="347" height="151"/></div><p class="figure-caption">Figure 7.17 – ink Choices GameObject</p></li>
				<li>As was shown in the <em class="italic">Creating a script component</em> section, create a new <strong class="source-inline">script</strong> component <a id="_idIndexMarker282"/>on the <strong class="source-inline">Ink</strong> <strong class="source-inline">Choices</strong> game object. Name this new file <strong class="source-inline">LoadingChoices.cs</strong>.<div id="_idContainer081" class="IMG---Figure"><img src="Images/Figure_7.18_B17597.jpg" alt="Figure 7.18 – LoadingChoices.cs file in the Assets window" width="285" height="352"/></div><p class="figure-caption">Figure 7.18 – LoadingChoices.cs file in the Assets window</p></li>
				<li>Double-click on the <strong class="source-inline">LoadingChoices.cs</strong> file in the <strong class="bold">Assets</strong> window to open it for editing in Visual Studio:<p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using UnityEngine;</p><p class="source-code"><strong class="bold">using Ink.Runtime;</strong></p><p class="source-code">public class LoadingChoices : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">public TextAsset InkJSONAsset;</strong></p><p class="source-code">    void Start()</p><p class="source-code">    {</p><p class="source-code">        <strong class="bold">Story InkStory = new Story(InkJSONAsset.text);</strong></p><p class="source-code">        <strong class="bold">InkStory.Continue();</strong></p><p class="source-code">        <strong class="bold">foreach (Choice c in InkStory.currentChoices)</strong></p><p class="source-code">        <strong class="bold">{</strong></p><p class="source-code">            <strong class="bold">Debug.Log(c.text);</strong></p><p class="source-code">        <strong class="bold">}</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Save the file<a id="_idIndexMarker283"/> in Visual Studio and return to Unity.</li>
				<li>Create a new ink file and name (or rename) the file to <strong class="source-inline">Example3.ink</strong>.<div id="_idContainer082" class="IMG---Figure"><img src="Images/Figure_7.19_B17597.jpg" alt="Figure 7.19 – Example3.ink file in the Assets window&#13;&#10;" width="484" height="197"/></div><p class="figure-caption">Figure 7.19 – Example3.ink file in the Assets window</p></li>
				<li>Following the instructions in the <em class="italic">Running an ink JSON file</em> section, associate the automatically generated ink JSON file with the <strong class="source-inline">Ink</strong> <strong class="source-inline">Choices</strong> game object property.<div id="_idContainer083" class="IMG---Figure"><img src="Images/Figure_7.20_B17597.jpg" alt="Figure 7.20 – Example3.json file associated with the ink JSON Asset property" width="574" height="355"/></div><p class="figure-caption">Figure 7.20 – Example3.json file associated with the ink JSON Asset property</p></li>
				<li>Open <a id="_idIndexMarker284"/>the <strong class="source-inline">Example3.ink</strong> file for editing in Inky. Change it to the following:<p class="source-code">Sam reached out, not quite touching Juan.</p><p class="source-code">* "Are you just going to leave me?"</p><p class="source-code">* "He didn't mean anything to me!"</p><p class="source-code">* "Can't we just start again?"</p></li>
				<li>Save the changed <strong class="source-inline">Example3.ink</strong> file. Return to Unity and run the scene. The <strong class="bold">Console</strong> window in Unity will now show the text content of each option.</li>
			</ol>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="Images/Figure_7.21_B17597.jpg" alt="Figure 7.21 – Example 3 options in the Console window&#13;&#10;" width="459" height="248"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21 – Example 3 options in the Console window</p>
			<p>The use of the <strong class="source-inline">Continue()</strong> method loaded not only the first line of <em class="italic">Example 3</em> but also the first weave appearing within the code. The <strong class="source-inline">currentChoices</strong> property contains a <strong class="source-inline">List&lt;Choice&gt;</strong> of objects per choice that exists within the weave. Each element of <strong class="source-inline">List&lt;Choice&gt;</strong> is a <strong class="source-inline">Choice</strong> object, a special class containing two important properties: <strong class="source-inline">index</strong> and <strong class="source-inline">text</strong>.</p>
			<p>Within the <strong class="source-inline">foreach</strong> loop, the <strong class="source-inline">text</strong> property of each <strong class="source-inline">Choice</strong> object is retrieved. This is then passed to the <strong class="source-inline">Debug.Log()</strong> method. When run, the ink story is loaded. Next, the first line and weave are loaded. Inside the loop, the <strong class="source-inline">currentChoices</strong> property<a id="_idIndexMarker285"/> is used to retrieve the value of each <strong class="source-inline">text</strong> property. Each is then shown in the <strong class="bold">Console</strong> window using the <strong class="source-inline">Debug.Log()</strong> method.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Making choices using the Unity API</h2>
			<p>Options are<a id="_idIndexMarker286"/> selected by players to continue<a id="_idIndexMarker287"/> a story. Within the ink source code, a choice is created using either the asterisk (<strong class="source-inline">*</strong>) or the plus symbol (<strong class="source-inline">+</strong>). When run, the ink runtime code as part of the <strong class="source-inline">Story</strong> class creates <em class="italic">options</em> from these source code choices. However, to progress in an ink story, a choice must be <em class="italic">made</em>. It must exist in the code and then be presented as an option.</p>
			<p>The <strong class="source-inline">Story</strong> class provides a method named <strong class="source-inline">ChooseChoiceIndex()</strong>. This accepts an <em class="italic">index</em> (<strong class="source-inline">int</strong>) within the range of the current total number of elements in the <strong class="source-inline">currentChoices</strong> property. Each <strong class="source-inline">Choice</strong> object within the list of <strong class="source-inline">currentChoices</strong> has <strong class="source-inline">index</strong> and <strong class="source-inline">text</strong> properties. In the <em class="italic">Detecting ink choices</em> section, the <strong class="source-inline">text</strong> property was used to display the generated option from the ink source file. To <em class="italic">make</em> a choice, its <strong class="source-inline">index</strong> property is used:</p>
			<ol>
				<li value="1">Double-click on the <strong class="source-inline">LoadingChoices.cs</strong> file from the <em class="italic">Detecting ink choices</em> section to open it for editing if it is not already open in Visual Studio.</li>
				<li>Update the file to the following:<p class="source-code">void Start()</p><p class="source-code">{</p><p class="source-code">Story InkStory = new Story(InkJSONAsset.text);</p><p class="source-code">InkStory.Continue();</p><p class="source-code"><strong class="bold">Choice exampleChoice = InkStory.currentChoices[0];</strong></p><p class="source-code"><strong class="bold">InkStory.ChooseChoiceIndex(exampleChoice.index);</strong></p><p class="source-code"><strong class="bold">Debug.Log(InkStory.Continue());</strong></p><p class="source-code">}</p></li>
				<li>Save the file in Visual Studio, return to Unity, and run the scene.</li>
			</ol>
			<p>The <strong class="bold">Console</strong> window will show the text of the choice matching the first (<strong class="source-inline">0</strong>) position element<a id="_idIndexMarker288"/> within <a id="_idIndexMarker289"/>the <strong class="source-inline">currentChoices</strong> property.</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="Images/Figure_7.22_B17597.jpg" alt="Figure 7.22 – Option chosen from Example 3 in the Console window&#13;&#10;" width="452" height="137"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Option chosen from Example 3 in the Console window</p>
			<p>The <strong class="source-inline">ChooseChoiceIndex()</strong> method selects the first choice within the weave based on the <strong class="source-inline">index</strong> property of <strong class="source-inline">exampleChoice</strong>. This is then displayed in the Unity <strong class="bold">Console</strong> window using the <strong class="source-inline">Continue()</strong> method.</p>
			<p>To <em class="italic">make</em> choices when using ink and Unity, a combination of things needs to happen in sequence. First, a story must be loaded. Second, at least one line needs to be loaded that also contains a weave. Next, the <strong class="source-inline">currentChoices</strong> property of the <strong class="source-inline">Story</strong> class must be used to retrieve the created options for the player. The <strong class="source-inline">ChooseChoiceIndex()</strong> method then needs to be used with the <strong class="source-inline">index</strong> property of one of the <strong class="source-inline">Choice</strong> objects retrieved from the <strong class="source-inline">currentChoices</strong> property. Finally, the next part of the story needs to be loaded. This additional loading will include the text of the option (if selective output is not used) chosen using the <strong class="source-inline">ChooseChoiceIndex()</strong> method. The rest of the story can then proceed.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Loading all text until the next weave</h2>
			<p>While useful<a id="_idIndexMarker290"/> for loading story content, the <strong class="source-inline">Continue()</strong> method must be used multiple times to load each line at a time. As with the code in the <em class="italic">Making choices using the Unity API</em> section, this means it would need to appear across multiple lines of code. Anticipating this problem, the Story API also includes a method named <strong class="source-inline">ContinueMaximally()</strong>. </p>
			<p>Instead of loading a line at a time, the <strong class="source-inline">ContinueMaximally()</strong> method loads all content until it encounters a weave. For many projects, this is a preferred method to use when there might be multiple lines of text between weaves or generated by ink internally as a part of the weave itself:</p>
			<ol>
				<li value="1">Create a new ink source file in Unity. Name (or rename) the file to <strong class="source-inline">Example4.ink</strong>.</li>
				<li>Open <strong class="source-inline">Example4.ink</strong> for editing in Inky and update it to the following:<p class="source-code">You read all the books and convinced your parents into going to the zoo. You just had to know. </p><p class="source-code">You enter the area containing the snakes and walk up to the glass.</p><p class="source-code">-&gt; snake_house</p><p class="source-code">== snake_house</p><p class="source-code">+ (tap){tap &lt; 2}[Tap the glass and say something {tap &gt; 0: again}]</p><p class="source-code">    {tap &lt;= 1: You tap on the glass in front of you.</p><p class="source-code">      The snake turns slightly toward the noise and</p><p class="source-code">      sticks out its tongue.}</p><p class="source-code">    {tap &gt; 1: No, you finally decide. You cannot talk</p><p class="source-code">      to snakes.}</p><p class="source-code">    -&gt; snake_house</p><p class="source-code">+ [Ignore the snake]</p><p class="source-code">    You regard the coiled snake and then walk out.</p><p class="source-code">    {tap &gt; 1: What were you thinking? Talking to</p><p class="source-code">      snakes is fictional.}</p><p class="source-code">    -&gt; DONE</p></li>
				<li>Update the <strong class="source-inline">Example4.ink</strong> file with the content from <em class="italic">Example 4</em>.</li>
				<li>Click on the <strong class="bold">Ink Choices</strong> game object and then, in the <strong class="bold">Inspector</strong> view, change the<a id="_idIndexMarker291"/> associated file from <strong class="source-inline">Example3.json</strong> to <strong class="source-inline">Example4.json</strong>.<div id="_idContainer086" class="IMG---Figure"><img src="Images/Figure_7.23_B17597.jpg" alt="Figure 7.23 – Updated Example4.json value in the Inspector view&#13;&#10;" width="494" height="308"/></div><p class="figure-caption">Figure 7.23 – Updated Example4.json value in the Inspector view</p></li>
				<li>Double-click on <strong class="source-inline">LoadingChoices.cs</strong> to open it for editing in Visual Studio.</li>
				<li>Update the file to the following:<p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using UnityEngine;</p><p class="source-code">using Ink.Runtime;</p><p class="source-code">public class LoadingChoices : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    public TextAsset InkJSONAsset;</p><p class="source-code">    void Start()</p><p class="source-code">    {</p><p class="source-code">        Story InkStory = new Story(InkJSONAsset.text);</p><p class="source-code">        Debug.Log(InkStory.ContinueMaximally());</p><p class="source-code">        Choice exampleChoice =</p><p class="source-code">        InkStory.currentChoices[0];</p><p class="source-code">        <strong class="bold">Debug.Log(exampleChoice.text);</strong></p><p class="source-code">        InkStory.ChooseChoiceIndex</p><p class="source-code">          (exampleChoice.index);</p><p class="source-code">        Debug.Log(InkStory.ContinueMaximally());</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Save the<a id="_idIndexMarker292"/> changes in Visual Studio, return to Unity, and run the scene.<div id="_idContainer087" class="IMG---Figure"><img src="Images/Figure_7.24_B17597.jpg" alt="Figure 7.24 – Loaded lines and choice text from Example 4&#13;&#10;" width="1378" height="320"/></div><p class="figure-caption">Figure 7.24 – Loaded lines and choice text from Example 4</p></li>
				<li>Stop the running scene.</li>
			</ol>
			<p>The first usage of the <strong class="source-inline">ContinueMaximally()</strong> method loaded the first two lines and the weave. Next, the <strong class="source-inline">ChooseChoiceIndex()</strong> method chose the first option. The second <strong class="source-inline">ContinueMaximally()</strong> method usage, when paired with the internal divert, then loaded the next line and the weave again. </p>
			<p>When working with looping structures, the <strong class="source-inline">ContinueMaximally()</strong> method is often better than using the <strong class="source-inline">Continue()</strong> method. Use of the <strong class="source-inline">ContinueMaximally()</strong> method will always load all the new text until it encounters the next weave. For loops where text might appear between weaves, a single use of the <strong class="source-inline">ContinueMaximally()</strong> method would achieve the same effect as multiple calls to the <strong class="source-inline">Continue()</strong> method to load the same content.</p>
			<p>This topic started with detecting choices in a running ink story with the <strong class="source-inline">currentChoices</strong> property. We then moved into making choices, both creating them in the ink code and then using the <strong class="source-inline">ChooseChoiceIndex()</strong> method to pick them. Finally, we saw how the <strong class="source-inline">ContinueMaximally()</strong> method can be combined with both the <strong class="source-inline">currentChoices</strong> property and the <strong class="source-inline">ChooseChoiceIndex()</strong> method. In the next topic, we will expand on these concepts. To create a dynamic interface, we can use our knowledge <a id="_idIndexMarker293"/>of the Story API to associate the <strong class="source-inline">GameObjects</strong> user interface and create a connection between clicking a button on the screen and progressing an ink story.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Creating a dynamic user interface</h1>
			<p>The <strong class="source-inline">Story</strong> class <a id="_idIndexMarker294"/>provides multiple methods for loading and progressing a story. However, without a user interface, a player is not able to select between options and see the result. To fix this problem, additional game objects are needed to show text and provide an interface for a user to click on different things.</p>
			<p>To start, a new project is needed. Instead of example code, this will use different user interface objects for working with a user. The project will also need to create a <strong class="bold">Prefab</strong>. In Unity, a <strong class="source-inline">GameObject</strong> can become <em class="italic">prefabricated</em> by moving it from the <strong class="bold">Hierarchy</strong> view into the <strong class="bold">Project</strong> window. This allows its settings and values to be kept as an asset in the project. Prefabs in Unity can also be <strong class="bold">instantiated</strong>, a process by which C# code can create a copy of an existing <strong class="source-inline">GameObject</strong> during runtime.</p>
			<p>The current lines as returned by the <strong class="source-inline">ContinueMaximally()</strong> method and choices in the <strong class="source-inline">currentChoices</strong> property can potentially be dynamic while an ink story runs. Combined with a Prefab, C# code can recreate an interface dynamically because of a player clicking on buttons to make choices in a story.</p>
			<p>In this topic, we will move through the steps of creating a dynamic interface by starting with a new Unity project and creating the necessary game objects. Next, we will associate a Prefab with our code. Finally, we will end with a section on putting everything<a id="_idIndexMarker295"/> together and running the combined project.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Creating a new project and game objects</h2>
			<p>Let us now start with creating a new project and game objects:</p>
			<ol>
				<li value="1">Create <a id="_idIndexMarker296"/>a new project in Unity. Name this project <strong class="source-inline">The Body</strong> and use a 2D template.<div id="_idContainer088" class="IMG---Figure"><img src="Images/Figure_7.25_B17597.jpg" alt="Figure 7.25 – Unity Hub project creation with the name of The Body" width="1303" height="708"/></div><p class="figure-caption">Figure 7.25 – Unity Hub project creation with the name of The Body</p><p class="callout-heading">Important Note</p><p class="callout">Before doing anything else, install the ink-Unity Integration plugin in the new project using the instructions as part of <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink-Unity Integration Plugin</em>.</p></li>
				<li>Once the project has been created by Unity, add a <strong class="source-inline">Canvas</strong> game object to the <strong class="bold">Hierarchy</strong> view. <p>A new <strong class="source-inline">Canvas</strong> game object can be accessed by selecting <strong class="bold">UI</strong> and then <strong class="bold">Canvas</strong> from the <strong class="bold">GameObject</strong> menu.</p><div id="_idContainer089" class="IMG---Figure"><img src="Images/Figure_7.26_B17597.jpg" alt="Figure 7.26 – GameObject menu with UI and Canvas selected&#13;&#10;" width="646" height="1056"/></div><p class="figure-caption">Figure 7.26 – GameObject menu with UI and Canvas selected</p><p>By<a id="_idIndexMarker297"/> adding a <strong class="source-inline">Canvas</strong> game object, Unity will automatically add an <strong class="source-inline">EventSystem</strong> game object.</p></li>
				<li>Click on the <strong class="source-inline">Canvas</strong> game object. In the <strong class="bold">Inspector</strong> view, click on the <strong class="bold">Add Component</strong> button. Select <strong class="bold">Layout</strong> and then <strong class="bold">Vertical Layout Group</strong>.<div id="_idContainer090" class="IMG---Figure"><img src="Images/Figure_7.27_B17597.jpg" alt="Figure 7.27 – Vertical Layout Group component selection&#13;&#10;" width="466" height="594"/></div><p class="figure-caption">Figure 7.27 – Vertical Layout Group component selection</p><p>A vertical<a id="_idIndexMarker298"/> layout group will automatically align all other UI game objects within itself in a <em class="italic">vertical</em> pattern.</p></li>
				<li>In the vertical layout group, click on the <strong class="bold">Child Alignment</strong> dropdown and select <strong class="bold">Middle Center</strong>.<div id="_idContainer091" class="IMG---Figure"><img src="Images/Figure_7.28_B17597.jpg" alt="Figure 7.28 – Vertical Layout Group with Middle Center selected&#13;&#10;" width="855" height="521"/></div><p class="figure-caption">Figure 7.28 – Vertical Layout Group with Middle Center selected</p></li>
				<li>With the <strong class="source-inline">Canvas</strong> game object selected in the <strong class="bold">Hierarchy</strong> view, create a new <strong class="source-inline">Text</strong> game object. <strong class="source-inline">Text</strong> game objects can be found under <strong class="bold">UI</strong> and then <strong class="bold">Text</strong>. The created <strong class="source-inline">Text</strong> will be added as a child of the <strong class="source-inline">Canvas</strong> game object.<div id="_idContainer092" class="IMG---Figure"><img src="Images/Figure_7.29_B17597.jpg" alt="Figure 7.29 – Added Text game object in the Hierarchy view&#13;&#10;" width="258" height="190"/></div><p class="figure-caption">Figure 7.29 – Added Text game object in the Hierarchy view</p></li>
				<li>With <a id="_idIndexMarker299"/>the <strong class="source-inline">Canvas</strong> game object selected in the <strong class="bold">Hierarchy</strong> view, create a <strong class="source-inline">Button</strong> game object. <strong class="source-inline">Button</strong> can be found under <strong class="bold">UI</strong> and then <strong class="bold">Button</strong>. The created <strong class="source-inline">Button</strong> game object will be added as a child of the <strong class="source-inline">Canvas</strong> game object.<div id="_idContainer093" class="IMG---Figure"><img src="Images/Figure_7.30_B17597.jpg" alt="Figure 7.30 – Added Button game object in the Hierarchy view&#13;&#10;" width="336" height="223"/></div><p class="figure-caption">Figure 7.30 – Added Button game object in the Hierarchy view</p></li>
				<li>Select the newly added <strong class="source-inline">Button</strong> game object, and then click and drag it from the <strong class="bold">Hierarchy</strong> view to the <strong class="bold">Project</strong> window. This will create a Prefab based on the <strong class="source-inline">Button</strong> in the <strong class="bold">Project</strong> window.<div id="_idContainer094" class="IMG---Figure"><img src="Images/Figure_7.31_B17597.jpg" alt="Figure 7.31 – Prefab created in the Project window&#13;&#10;" width="285" height="188"/></div><p class="figure-caption">Figure 7.31 – Prefab created in the Project window</p></li>
				<li>After the <strong class="source-inline">Button</strong> game object icon changes in the <strong class="bold">Hierarchy</strong> view, delete the <strong class="source-inline">Button</strong> game object in the <strong class="bold">Hierarchy</strong> view only. Because the <strong class="source-inline">Button</strong> game object is now a Prefab, it exists as an asset and does not need to exist in the current <strong class="bold">Hierarchy</strong> view. (It will later be instantiated by code.)</li>
			</ol>
			<p>With the project and game objects created, the next item is a <strong class="source-inline">script</strong> component. This will create the<a id="_idIndexMarker300"/> necessary properties for other files to be associated with running the story.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Associating Prefab and ink JSON files</h2>
			<p>After <a id="_idIndexMarker301"/>creating <a id="_idIndexMarker302"/>the game<a id="_idIndexMarker303"/> objects in the last <a id="_idIndexMarker304"/>section, we will now create a <strong class="source-inline">script</strong> component, create the necessary properties, and then associate assets with the properties:</p>
			<ol>
				<li value="1">Select the <strong class="source-inline">Canvas</strong> game object in the <strong class="bold">Hierarchy</strong> view.</li>
				<li>In the <strong class="bold">Inspector</strong> view, create a new <strong class="source-inline">script</strong> component using the instructions in the <em class="italic">Creating a script component</em> section.</li>
				<li>Name (or rename following creation) this new file <strong class="source-inline">InkStory.cs</strong>.<div id="_idContainer095" class="IMG---Figure"><img src="Images/Figure_7.32_B17597.jpg" alt="Figure 7.32 – Created InkStory.cs file&#13;&#10;" width="327" height="188"/></div><p class="figure-caption">Figure 7.32 – Created InkStory.cs file</p></li>
				<li>Double-click on the <strong class="source-inline">InkStory.cs</strong> file for editing in Visual Studio.</li>
				<li>Update the code to the following:<p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using UnityEngine;</p><p class="source-code"><strong class="bold">using Ink.Runtime;</strong></p><p class="source-code">public class InkStory : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">public TextAsset InkJSONAsset;</strong></p><p class="source-code">    <strong class="bold">public GameObject prefabButton;</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>There <a id="_idIndexMarker305"/>are<a id="_idIndexMarker306"/> three <a id="_idIndexMarker307"/>new additions to the default<a id="_idIndexMarker308"/> code provided by Unity. The first is the inclusion of the <strong class="source-inline">Ink.Runtime</strong> namespace. This will allow us to work with ink while a story runs. The second two additions are the properties we will be using in the <strong class="bold">Inspector</strong> view in the Unity editor. To associate assets with code, we can use the <strong class="source-inline">public</strong> keyword in C# to create a property we can adjust in the editor:</p>
			<ol>
				<li value="1">Save the file and return to Unity.</li>
				<li>Create a new ink file named (or renamed following creation) <strong class="source-inline">TheBody.ink</strong>.</li>
				<li>Open the <strong class="source-inline">TheBody.ink</strong> file in Inky for editing and copy the contents from the file from GitHub.<p class="callout-heading">Note</p><p class="callout">The code for this example, <strong class="source-inline">TheBody.ink</strong>, can be found on GitHub.</p></li>
				<li>Save the ink source file and return to Unity.<p>The use of the <strong class="source-inline">public</strong> keyword in <strong class="source-inline">InkStory.cs</strong> added two new properties to the <strong class="source-inline">Canvas</strong> game object.</p><div id="_idContainer096" class="IMG---Figure"><img src="Images/Figure_7.33_B17597.jpg" alt="Figure 7.33 – Properties added in the Inspector view&#13;&#10;" width="525" height="156"/></div><p class="figure-caption">Figure 7.33 – Properties added in the Inspector view</p></li>
				<li>Click<a id="_idIndexMarker309"/> on<a id="_idIndexMarker310"/> the<a id="_idIndexMarker311"/> file selection next to<a id="_idIndexMarker312"/> the <strong class="source-inline">Ink</strong> <strong class="source-inline">JSON Asset</strong> property to open the <strong class="bold">Select TextAsset</strong> window.</li>
				<li>Associate the ink JSON file created by the ink-Unity Integration plugin with the <strong class="bold">Ink JSON Asset</strong> property and then close the <strong class="bold">Select TextAsset</strong> window.</li>
				<li>Click on the file selection next to the <strong class="source-inline">Button</strong> Prefab to open the <strong class="bold">Select GameObject</strong> window. </li>
				<li>Select the <strong class="bold">Assets</strong> tab in the <strong class="bold">Select GameObject</strong> window if it is not open. </li>
				<li>Select the <strong class="bold">Button</strong> Prefab and then close the <strong class="bold">Select GameObject</strong> window.</li>
			</ol>
			<p>The result of associating the ink JSON file with the <strong class="source-inline">Button</strong> Prefab will be that the code has access to those assets during runtime.</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="Images/Figure_7.34_B17597.jpg" alt="Figure 7.34 – Updated Ink Story component with the ink JSON file and button Prefab values&#13;&#10;" width="678" height="196"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.34 – Updated Ink Story component with the ink JSON file and button Prefab values</p>
			<p>With the file associated with properties of the <strong class="source-inline">script</strong> component, additional code can now be written. Changing the ink source file, <strong class="source-inline">TheBody.ink</strong>, and saving the change will automatically update the <strong class="source-inline">TheBody.json</strong> file. The same is also true of the <strong class="source-inline">Button</strong> Prefab. It can also be adjusted, and its settings changed. As long as neither asset is renamed, Unity will maintain the association and allow developers to customize their settings independent of the code using them when the scene runs.</p>
			<p>By the end of this section, we will have created a Unity project, its game objects, and associated assets with properties. Before we can run the project, we will need to write more code to dynamically create a user interface based on the content of a running ink story. In the next section, we will write the code to use the Prefab and create a dynamic interface<a id="_idIndexMarker313"/> based <a id="_idIndexMarker314"/>on the <a id="_idIndexMarker315"/>text output <a id="_idIndexMarker316"/>of the <strong class="source-inline">ContinueMaximally()</strong> method and the <strong class="source-inline">currentChoices</strong> property.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Making a dynamic user interface</h2>
			<p>The final<a id="_idIndexMarker317"/> series of steps needed before the Unity project can be run is to add more code. We need to incorporate the concepts explained in this chapter covering the use of the <strong class="source-inline">ContinueMaximally()</strong> method and the <strong class="source-inline">currentChoices</strong> property. We also need to add an overall loop within the code using the <strong class="source-inline">canContinue</strong> property to check whether there is more content before progressing the story.</p>
			<p>We begin by adding the properties we will need within the class that will not be used by the Unity editor. We mark these using the <strong class="source-inline">private</strong> keyword.</p>
			<p>Open <strong class="source-inline">InkStory.cs</strong> for editing in Visual Studio:</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code"><strong class="bold">using UnityEngine.UI;</strong></p>
			<p class="source-code">using Ink.Runtime;</p>
			<p class="source-code">public class InkStory : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    public TextAsset InkJSONAsset;</p>
			<p class="source-code">    public GameObject prefabButton;</p>
			<p class="source-code">    <strong class="bold">private Story inkStory;</strong></p>
			<p class="source-code">    <strong class="bold">private Text currentLinesText;</strong></p>
			<p class="source-code">}</p>
			<p>To work with user interface game objects, another instance of the <strong class="source-inline">using</strong> keyword is needed. This adds access to classes such as <strong class="source-inline">Text</strong> and <strong class="source-inline">Button</strong> used in this file.</p>
			<p>The <strong class="source-inline">Story</strong> class and the <strong class="source-inline">Text</strong> game object <strong class="source-inline">currentLinesText</strong> will be used across methods in this code. To make sure they can be used in this way, they must be properties of the <strong class="source-inline">InkStory</strong> class and not variables within any method.</p>
			<p>The first thing that must happen is the loading of the ink JSON file. Next, a reference to the <strong class="source-inline">Text</strong> component is needed. The text will be shown to the user each time they make a choice. This <a id="_idIndexMarker318"/>means the <strong class="source-inline">text</strong> property of the <strong class="source-inline">Text</strong> game object will need to be updated. However, as it is a child of <strong class="source-inline">Canvas</strong>, the <strong class="source-inline">GetComponentInChildren()</strong> method is needed:</p>
			<p class="source-code"><strong class="bold">void Start()</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">inkStory = new Story(InkJSONAsset.text);</strong></p>
			<p class="source-code"><strong class="bold">currentLinesText = GetComponentInChildren&lt;Text&gt;();</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p>The process of loading the text content and current choices will be used multiple times. This means all the code used as part of the process should be its own method:</p>
			<p class="source-code"><strong class="bold">void LoadTextAndWeave()</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">if (inkStory.canContinue)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">currentLinesText.text = inkStory.ContinueMaximally();</strong></p>
			<p class="source-code"><strong class="bold">foreach (Choice c in inkStory.currentChoices)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">GameObject cloneButtonGameObject = </strong></p>
			<p class="source-code"><strong class="bold">  Instantiate(prefabButton, this.transform);</strong></p>
			<p class="source-code"><strong class="bold">Button cloneButtonButton =</strong></p>
			<p class="source-code"><strong class="bold">  cloneButtonGameObject.GetComponent&lt;Button&gt;();</strong></p>
			<p class="source-code"><strong class="bold">cloneButtonButton.onClick.AddListener(delegate</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">inkStory.ChooseChoiceIndex(c.index);</strong></p>
			<p class="source-code"><strong class="bold">LoadTextAndWeave();</strong></p>
			<p class="source-code"><strong class="bold">                });</strong></p>
			<p class="source-code"><strong class="bold">Text cloneButtonText = cloneButtonButton.</strong></p>
			<p class="source-code"><strong class="bold">  GetComponentInChildren&lt;Text&gt;();</strong></p>
			<p class="source-code"><strong class="bold">cloneButtonText.text = c.text;</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p>In the <a id="_idIndexMarker319"/>new <strong class="source-inline">LoadTextAndWeave()</strong> method, new text content will be loaded if the <strong class="source-inline">canContinue</strong> property is true. Using the <strong class="source-inline">foreach</strong> keyword, new buttons will be added by using the <strong class="source-inline">Instantiate()</strong> method in Unity. This <em class="italic">instantiates</em> a Prefab as a GameObject during runtime, creating it through code and adding it to the running scene.</p>
			<p>Finally, the <strong class="source-inline">AddListener()</strong> method is used with the <strong class="source-inline">OnClick</strong> property of a button in Unity. This adds to a collection of which functions should be notified that a click has happened. The <strong class="source-inline">delegate</strong> keyword allows a developer to pass a method as an argument to another method. In this case, a short method is created within the same scope as the <strong class="source-inline">foreach</strong> loop. The <strong class="source-inline">index</strong> property can thus be used inside this created method.</p>
			<p>Every time the button is clicked, the <strong class="source-inline">Story</strong> class method <strong class="source-inline">ChooseChoiceIndex()</strong> will be called with the correct index, and the <strong class="source-inline">LoadTextAndWeave()</strong> method will be called again, refreshing the value of the <strong class="source-inline">currentLinesText</strong> method and updating the current buttons shown on the screen:</p>
			<ol>
				<li value="1">To run<a id="_idIndexMarker320"/> the current code, one more change is needed. The <strong class="source-inline">LoadTextAndWeave()</strong> method needs to be called inside the <strong class="source-inline">Start()</strong> method:<p class="source-code">void Start()</p><p class="source-code">{</p><p class="source-code">inkStory = new Story(InkJSONAsset.text);</p><p class="source-code">currentLinesText = GetComponentInChildren&lt;Text&gt;();</p><p class="source-code"><strong class="bold">LoadTextAndWeave();</strong></p><p class="source-code">}</p></li>
				<li>Save the current code in Visual Studio. Return to Unity and run the scene.<p>Immediately, two problems will become evident. First, the default black text on a dark background makes the text impossible to read. Second, only the first few words will be shown.</p><div id="_idContainer098" class="IMG---Figure"><img src="Images/Figure_7.35_B17597.jpg" alt="Figure 7.35 – The Body project running in Unity" width="350" height="329"/></div><p class="figure-caption">Figure 7.35 – The Body project running in Unity</p></li>
				<li>Click on the <strong class="bold">(Continue.)</strong> button to see two more problems.</li>
			</ol>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="Images/Figure_7.36_B17597.jpg" alt="Figure 7.36 – Dynamically created buttons in The Body" width="368" height="447"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.36 – Dynamically created buttons in The Body</p>
			<p>The first <a id="_idIndexMarker321"/>problem is that instead of replacing the first button, Unity added two more. This is caused by the second call to the <strong class="source-inline">LoadTextAndWeave()</strong>method internally. First, the text content and button were loaded. Next, when the <strong class="bold">(Continue.)</strong> button was clicked, it was called again, adding more buttons.</p>
			<p>We can also observe that the buttons are small and hard to read. By default, Unity will assume some values for a <strong class="source-inline">Button</strong> game object. While adjusting our code, we will also need to change the properties:</p>
			<ol>
				<li value="1">Stop the running scene.</li>
				<li>To start to fix the issue with the text, first, select the <strong class="source-inline">Text</strong> game object in the <strong class="bold">Hierarchy</strong> view. The default values of its width and height are <strong class="source-inline">160</strong> and <strong class="source-inline">30</strong>. </li>
				<li>Through either clicking and dragging using the <strong class="bold">Rect Transform</strong> tool, or by changing the number directly, update their values to a width of <strong class="source-inline">800</strong> and height of <strong class="source-inline">300</strong>.<div id="_idContainer100" class="IMG---Figure"><img src="Images/Figure_7.37_B17597.jpg" alt="Figure 7.37 – The Inspector view in Unity with updated width and height values&#13;&#10;" width="894" height="430"/></div><p class="figure-caption">Figure 7.37 – The Inspector view in Unity with updated width and height values</p></li>
				<li>Click on the <strong class="bold">Font Size</strong> property and change its value from <strong class="source-inline">14</strong> to <strong class="source-inline">24</strong>. This will make the starting size larger.</li>
				<li>Click on the <strong class="bold">Color</strong> property. Change the color from its <strong class="source-inline">default</strong> to <strong class="source-inline">white</strong> and then close the <strong class="bold">Color</strong> window.<p>The updated values will now display more text and, with the white on a darker background, increase<a id="_idIndexMarker322"/> its readability.</p><div id="_idContainer101" class="IMG---Figure"><img src="Images/Figure_7.38_B17597.jpg" alt="Figure 7.38 – Updated Text GameObject component values&#13;&#10;" width="820" height="559"/></div><p class="figure-caption">Figure 7.38 – Updated Text GameObject component values</p></li>
				<li>Click on the <strong class="source-inline">Button</strong> Prefab in the <strong class="bold">Project</strong> window.</li>
				<li>Like the <strong class="source-inline">Text</strong> game object, its default width is <strong class="source-inline">160</strong> and its height is <strong class="source-inline">30</strong>. Change the width to <strong class="source-inline">250</strong> and the height to <strong class="source-inline">100</strong>.<div id="_idContainer102" class="IMG---Figure"><img src="Images/Figure_7.39_B17597.jpg" alt="Figure 7.39 – Updated button Prefab values&#13;&#10;" width="623" height="259"/></div><p class="figure-caption">Figure 7.39 – Updated button Prefab values</p></li>
				<li>Return to editing <strong class="source-inline">InkStory.cs</strong> in Visual Studio.</li>
			</ol>
			<p>The fix to the code is a small but important one. Each time the button is clicked, the code will need to destroy the current buttons and then create new ones:</p>
			<ol>
				<li value="1">A new <a id="_idIndexMarker323"/>method is needed for the specific task of destroying <strong class="source-inline">Button</strong> children:<p class="source-code"><strong class="bold">void DestroyButtonChildren()</strong></p><p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  foreach (Transform child in transform)</strong></p><p class="source-code"><strong class="bold">  {</strong></p><p class="source-code"><strong class="bold">    if(child.tag == "ButtonChoice")</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">      GameObject.Destroy(child.gameObject);</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code"><strong class="bold">}</strong></p><p>The new <strong class="source-inline">DestroyButtonChildren()</strong> method needs to be called as part of the delegate method. Before the content is refreshed, the current buttons need to be destroyed:</p><p class="source-code">cloneButtonButton.onClick.AddListener(delegate</p><p class="source-code">{</p><p class="source-code">inkStory.ChooseChoiceIndex(c.index);</p><p class="source-code"><strong class="bold">DestoryButtonChildren();</strong></p><p class="source-code">LoadTextAndWeave();</p><p class="source-code">});</p></li>
				<li>Save the updated file in Visual Studio and return to Unity.<p>The <strong class="source-inline">DestroyButtonChildren()</strong> method looks for a specific <strong class="source-inline">tag</strong> value. This needs to be added to the <strong class="source-inline">Button</strong> Prefab.</p></li>
				<li>Select the <strong class="source-inline">Button</strong> Prefab in the <strong class="bold">Project</strong> window.</li>
				<li>In the <strong class="bold">Inspector</strong> view, click <a id="_idIndexMarker324"/>on the <strong class="bold">Tag</strong> drop-down menu and then the <strong class="bold">Add Tag…</strong> option.<div id="_idContainer103" class="IMG---Figure"><img src="Images/Figure_7.40_B17597.jpg" alt="Figure 7.40 – Tag drop-down menu in the Unity Inspector view" width="301" height="308"/></div><p class="figure-caption">Figure 7.40 – Tag drop-down menu in the Unity Inspector view</p></li>
				<li>Click on the <strong class="bold">+</strong> icon to add a new tag to the list. In the prompt, use the name <em class="italic">ButtonChoice</em>.<div id="_idContainer104" class="IMG---Figure"><img src="Images/Figure_7.41_B17597.jpg" alt="Figure 7.41 – New tag name&#13;&#10;" width="499" height="135"/></div><p class="figure-caption">Figure 7.41 – New tag name</p></li>
				<li>Click on <strong class="bold">Save</strong> to create a new tag.</li>
				<li>Click on the <strong class="source-inline">Button</strong> Prefab in the <strong class="bold">Project</strong> window to open its values in the <strong class="bold">Inspector</strong> view.<p>Now that the <strong class="source-inline">ButtonChoice</strong> tag has been added, it must be selected. </p></li>
				<li>In the <strong class="bold">Tag</strong> dropdown, select <strong class="bold">ButtonChoice</strong>.<div id="_idContainer105" class="IMG---Figure"><img src="Images/Figure_7.42_B17597.jpg" alt="Figure 7.42 – Added ButtonChoice option to the Tag drop-down menu&#13;&#10;" width="287" height="298"/></div><p class="figure-caption">Figure 7.42 – Added ButtonChoice option to the Tag drop-down menu</p></li>
				<li>Run the <a id="_idIndexMarker325"/>scene. Play through the story by clicking on buttons to make choices and see the result. </li>
				<li>Stop the running scene when done playing the story.</li>
			</ol>
			<p>The changes to the <strong class="source-inline">Text</strong> game object and code will load the new text and correctly update the choices as the player clicks on the buttons. While consisting of multiple steps, this same approach can be used with most ink JSON files to present text and dynamic buttons <a id="_idIndexMarker326"/>for a player to make different choices and then see the result on the screen.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Summary</h1>
			<p>In this chapter, we worked through the process of adding a <strong class="source-inline">script</strong> component, associating an ink JSON file with a property, and using methods and properties as part of the <strong class="source-inline">Story</strong> class to progress a running ink story. We saw how the <strong class="source-inline">Continue()</strong> method loads one line at a time and the <strong class="source-inline">ContinueMaximally()</strong> method loads all text until it encounters a weave. When combined with the <strong class="source-inline">canContinue</strong> property, these methods allow for text content to be loaded from an ink JSON file and prevent any errors when the content runs out. With the <strong class="source-inline">currentChoices</strong> property, we examined how to use loops, such as those using the <strong class="source-inline">foreach</strong> keyword. When we used the <strong class="source-inline">ChooseChoiceIndex()</strong> method, we picked which option among the weave we wanted and progressed through a story using the <strong class="source-inline">Continue()</strong> or <strong class="source-inline">ContinueMaximally()</strong> methods again.</p>
			<p>By setting up user interface game objects in Unity, we built a dynamic process to load ink story content, destroy buttons, and then create new ones. Needing to create a <strong class="source-inline">Button</strong> Prefab, we saw how these could be instantiated by the code while it was running. Adjusting the values of <strong class="source-inline">Text</strong> and <strong class="source-inline">Button</strong> game objects, we completed an interface for running an ink JSON file and built a system usable by many other projects working with the same game objects and organization.</p>
			<p>In the next chapter, we continue to use the <strong class="source-inline">Story</strong> class and its methods. We will examine how to retrieve and update the values of variables in an ink story using C# code. We will also see ways of accessing functions in ink and how to pass data in and out of them. Combined with user interface game objects, we will build an example of how to communicate between the ink runtime and Unity code by using content from ink to create multiple dynamic interfaces in Unity.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between the <strong class="source-inline">Continue()</strong> and <strong class="source-inline">ContinueMaximally()</strong> methods in the <strong class="source-inline">Story</strong> class?</li>
				<li>What type of data does the <strong class="source-inline">ChooseChoiceIndex()</strong> method in the <strong class="source-inline">Story</strong> class expect?</li>
				<li>How is the <strong class="source-inline">canContinue</strong> property used with the <strong class="source-inline">Continue()</strong> and <strong class="source-inline">ContinueMaximally()</strong> methods in the <strong class="source-inline">Story</strong> class?</li>
				<li>What is a Prefab in Unity?</li>
				<li>What type of object is found in the <strong class="source-inline">currentChoices</strong> list property of the <strong class="source-inline">Story</strong> class?</li>
			</ol>
		</div>
	</div></body></html>