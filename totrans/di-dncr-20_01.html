<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The SOLID Principles of Software Design</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This book focuses on techniques related to Dependency Injection and the way those techniques are implemented by default and can be extended by the programmer in .NET Core--the first version of .NET that executes on every platform.</span></p>
<p><span class="koboSpan" id="kobo.3.1">It works on Windows, macOS, and Linux distro on the desktop, and the idea can even be extended to the mobile world covering the Apple, Android, and Tizen (Samsung) operating systems.</span></p>
<p><span class="koboSpan" id="kobo.4.1">This is, with no doubt, the most ambitious project from Microsoft in its search for a universal coverage of programming technologies and tools, and it can be considered a natural step after the initial </span><strong><span class="koboSpan" id="kobo.5.1">UWP</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong><span class="koboSpan" id="kobo.7.1">Universal Windows Platform</span></strong><span class="koboSpan" id="kobo.8.1">) project that allows building applications for any device supporting Windows, from IoT devices to the desktop, XBOX, or HoloLens.</span></p>
<p><span class="koboSpan" id="kobo.9.1">So, in this chapter we'll start with a quick review of the main architectural components of .NET Core and its derivative frameworks (such as ASP.NET Core), to be followed with the foundations on which Dependency Injection techniques are based, as part of the SOLID principles, stated by Robert C. </span><span class="koboSpan" id="kobo.9.2">Martin (</span><em><span class="koboSpan" id="kobo.10.1">Uncle Bob</span></em><span class="koboSpan" id="kobo.11.1">) in 2000. </span><span class="koboSpan" id="kobo.11.2">(See Wikipedia: </span><a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)"><span class="koboSpan" id="kobo.12.1">https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)</span></a><span class="koboSpan" id="kobo.13.1">.)</span></p>
<p><span class="koboSpan" id="kobo.14.1">Therefore, we'll revise those five SOLID principles, explaining their purpose and advantages, together with some basic implementations of each one of them in the C# language using Console applications coded in .NET Core. </span><span class="koboSpan" id="kobo.14.2">In all we'll see an explanation of each principle and its coverage:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Separation of concerns (clearly implemented in the core infrastructure of .NET Core and also from the initial configuration of pipelines and middleware in ASP.NET Core)</span></li>
<li><span class="koboSpan" id="kobo.16.1">Open/Closed (already implemented in classic .NET Framework since version 3.0 and also present here)</span></li>
<li><span class="koboSpan" id="kobo.17.1">Liskov Substitution Principle (available in two ways--in a classic manner through the support of typecasting, and through the use of generics)</span></li>
<li><span class="koboSpan" id="kobo.18.1">Interface segregation: Explanation of Interface segregation and its advantages</span></li>
<li><span class="koboSpan" id="kobo.19.1">Dependency Inversion: Explanation of the principle, its derivatives, and the concept of IoC containers</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">In the beginning</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The evolution of programming techniques is, somehow, related to language evolution. </span><span class="koboSpan" id="kobo.2.2">Once the initial (and, in some ways, chaotic) times had passed, the universality of computing became clear, and the need for good patterns and languages capable of affording large projects turned out to be evident.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The 70s marked the start of the adoption of other paradigms, such as procedural programming, and later on, </span><strong><span class="koboSpan" id="kobo.4.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong><span class="koboSpan" id="kobo.6.1">OOP</span></strong><span class="koboSpan" id="kobo.7.1">), proposed by Ole-Johan Dahl and Kristen Nygaard with the Simula language, when they both worked at the Norwegian Computing Center. </span><span class="koboSpan" id="kobo.7.2">They were given the Turing Award for these achievements, among other recognitions.</span></p>
<p><span class="koboSpan" id="kobo.8.1">A few years later (around 1979), Bjarne Stroustrup created C with Classes, the prototype of what C++ is today because he found valuable aspects in the Simula language, but he thought that it was too slow for practical purposes, being the first OOP language that was universally adopted.</span></p>
<p><span class="koboSpan" id="kobo.9.1">C++ originally had imperative features and object-oriented and generic ones, while also providing the ability to program for low-level memory manipulation. </span><span class="koboSpan" id="kobo.9.2">While it's true that it has become a de facto standard for building critical systems and applications, for many people it was not adequate for </span><strong><span class="koboSpan" id="kobo.10.1">LOB</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong><span class="koboSpan" id="kobo.12.1">Line of Business</span></strong><span class="koboSpan" id="kobo.13.1">) applications.</span></p>
<p><span class="koboSpan" id="kobo.14.1">Years later, Java and the .NET platforms proposed a much easier and affordable solution for many programmers while still moving within the ordered space that object-oriented programming languages promote.</span></p>
<p><span class="koboSpan" id="kobo.15.1">So, OOP was adopted, and so far no other important programming paradigm has replaced these ideas. </span><span class="koboSpan" id="kobo.15.2">Certainly, there are other approaches, such as functional programming, but even the most significant representative of this tendency, JavaScript, is becoming more object-oriented in the latest versions (ECMAScript 2015).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">.NET and .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">.NET has been revamped lately in order to achieve the goal that Microsoft has pursued since Satya Nadella arrived in the company--"</span><q><em><span class="koboSpan" id="kobo.3.1">Any Developer, Any App, Any </span><span><span class="koboSpan" id="kobo.4.1">Platforms.</span></span></em></q><span class="koboSpan" id="kobo.5.1">".</span></p>
<p><span class="koboSpan" id="kobo.6.1">According to Principal Manager Scott Hunter, the company now presents a set of unified application models that can be summarized in the following screenshot:</span></p>
<div class="CDPAlignCenter"><span class="koboSpan" id="kobo.7.1"><img height="231" width="480" class=" image-border" src="assets/93628383-00e3-490b-9444-694f2dc6f79d.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1">Source: </span><a href="http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx"><span class="koboSpan" id="kobo.9.1">http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.</span><span><span class="koboSpan" id="kobo.10.1">aspx</span></span></a></div>
<p><span class="koboSpan" id="kobo.11.1">As you see, the situation now is quite promising for a .NET Developer. </span><span class="koboSpan" id="kobo.11.2">The screenshot shows a </span><strong><span class="koboSpan" id="kobo.12.1">Common Infrastructure</span></strong><span class="koboSpan" id="kobo.13.1"> (compilers, languages, and runtime components), powered by Roselyn services and other features. </span><span class="koboSpan" id="kobo.13.2">All those integrate with the IDEs that support these projects, now including Visual Studio for Mac.</span></p>
<p><span class="koboSpan" id="kobo.14.1">On top of that lies a </span><strong><span class="koboSpan" id="kobo.15.1">.NET Standard Library</span></strong><span class="koboSpan" id="kobo.16.1">, which has points in common that allow us to share code along the three different frameworks--the classic </span><strong><span class="koboSpan" id="kobo.17.1">.NET Framework</span></strong><span class="koboSpan" id="kobo.18.1"> (in version 4.6.2, at the time of writing this), </span><strong><span class="koboSpan" id="kobo.19.1">.NET Core</span></strong><span class="koboSpan" id="kobo.20.1"> (now in version 2.0), and </span><strong><span class="koboSpan" id="kobo.21.1">Xamarin</span></strong><span class="koboSpan" id="kobo.22.1">, which allows building applications for any type of mobile target--Android, iOS, Windows Phone, and Tizen (Samsung).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">About .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">.NET Core is the new version of .NET presented officially in the summer of 2016, and updated to version 1.1 in the November Connect() event the same year. </span><span class="koboSpan" id="kobo.2.2">It's defined as a </span><em><span class="koboSpan" id="kobo.3.1">cross-platform, open source, cloud-ready and modular .NET platform for creating modern web apps, microservices, libraries, and console applications that run everywhere (Windows, Linux, and MacOS).</span></em></p>
<p><span class="koboSpan" id="kobo.4.1">It can be deployed along with the application itself, minimizing installation issues.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Prior to its publication, Microsoft decided to restart the numbering, reinforcing the idea that this is a totally new concept with respect to classical versions, as a better way to avoid ambiguities.</span></p>
<p><span class="koboSpan" id="kobo.6.1">MSDN architect Cesar de la Torre defines in his blog very precisely the goals and structure of .NET Core--unlike the traditional .NET Framework, which is a single package installation, system-wide, and Windows-only runtime environment, .NET Core is about decoupling .NET from Windows, allowing it to run in non-Windows environments without having to install a giant 400 Mb set of binaries (versus just the footprint of the components you need from .NET Core) plus the ability to deploy applications accompanying the framework itself, supporting side-by-side execution of different versions of the framework.</span></p>
<p><span class="koboSpan" id="kobo.7.1">A very interesting part of its architecture and deployment infrastructure, as mentioned in the same source, is that instead of being part of the operating system, .NET Core is composed of NuGet packages and is either compiled directly into an application or put into a folder inside the application. </span><span class="koboSpan" id="kobo.7.2">This means applications can carry .NET Core within and thus are completely side by side on the machine.</span></p>
<p><span class="koboSpan" id="kobo.8.1">I, personally, think this is absolutely crucial for the project to be successful. </span><span class="koboSpan" id="kobo.8.2">No side-effects, no component installation in the target machine, and no dependencies. </span><span class="koboSpan" id="kobo.8.3">(As you'll see throughout this book this avoiding of dependencies is totally foundational when building software that follows good practices.)</span></p>
<p><span class="koboSpan" id="kobo.9.1">NET Core 2.0 - Supported OS Versions Proposal:</span></p>
<table>
<tbody>
<tr>
<td><strong><span class="koboSpan" id="kobo.10.1">OS</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.11.1">Version</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.12.1">Architectures</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.13.1">Notes</span></strong></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.14.1">Windows Client</span></td>
<td><span class="koboSpan" id="kobo.15.1">7 SP1+</span></td>
<td><span class="koboSpan" id="kobo.16.1">x64, x86</span></td>
<td/>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.17.1">Windows Server</span></td>
<td><span class="koboSpan" id="kobo.18.1">2008 R2 SP1+</span></td>
<td><span class="koboSpan" id="kobo.19.1">x64, x86</span></td>
<td><span class="koboSpan" id="kobo.20.1">Configurations: Full, Server Core, Nano</span></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.21.1">Windows IoT</span></td>
<td><span class="koboSpan" id="kobo.22.1">10+</span></td>
<td><span class="koboSpan" id="kobo.23.1">[C] arm32</span></td>
<td><span class="koboSpan" id="kobo.24.1">IoT Core - see </span><a href="https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md"><span class="koboSpan" id="kobo.25.1">Raspberry Pi instructions</span></a></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.26.1">Red Hat Enterprise Linux</span></td>
<td><span class="koboSpan" id="kobo.27.1">7.3+</span></td>
<td><span class="koboSpan" id="kobo.28.1">x64</span></td>
<td><span class="koboSpan" id="kobo.29.1">This includes Centos and Oracle Linux</span></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.30.1">Fedora</span></td>
<td><span class="koboSpan" id="kobo.31.1">25+</span></td>
<td><span class="koboSpan" id="kobo.32.1">x64</span></td>
<td/>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.33.1">Debian</span></td>
<td><span class="koboSpan" id="kobo.34.1">8.7+</span></td>
<td><span class="koboSpan" id="kobo.35.1">x64</span></td>
<td><a href="https://github.com/dotnet/corefx/issues/8951#issuecomment-299927277"><span class="koboSpan" id="kobo.36.1">Debian 9 (Stretch) workaround</span></a></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.37.1">Ubuntu</span></td>
<td><span class="koboSpan" id="kobo.38.1">14.04+</span></td>
<td><span class="koboSpan" id="kobo.39.1">x64, [C] arm32</span></td>
<td><span class="koboSpan" id="kobo.40.1">This includes Linux Mint 17 for x64</span><br/><span class="koboSpan" id="kobo.41.1">
For arm32, see </span><a href="https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md"><span class="koboSpan" id="kobo.42.1">Raspberry Pi instructions</span></a></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.43.1">openSUSE</span></td>
<td><span class="koboSpan" id="kobo.44.1">42.2+</span></td>
<td><span class="koboSpan" id="kobo.45.1">x64</span></td>
<td/>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.46.1">Tizen</span></td>
<td><span class="koboSpan" id="kobo.47.1">4+</span></td>
<td><span class="koboSpan" id="kobo.48.1">[S] arm32</span></td>
<td><a href="https://developer.tizen.org/development/tizen-.net-preview/introduction"><span class="koboSpan" id="kobo.49.1">Tizen .NET Developer Preview</span></a></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.50.1">Mac OS X</span></td>
<td><span class="koboSpan" id="kobo.51.1">10.12+</span></td>
<td><span class="koboSpan" id="kobo.52.1">x64</span></td>
<td/>
</tr>
<tr>
<td><strong><span class="koboSpan" id="kobo.53.1">In Progress OS's</span></strong></td>
<td/>
<td/>
<td/>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.54.1">Arch Linux</span></td>
<td><span class="koboSpan" id="kobo.55.1">[C] TBD</span></td>
<td><span class="koboSpan" id="kobo.56.1">TBD</span></td>
<td><span class="koboSpan" id="kobo.57.1">Blocked on </span><a href="https://github.com/dotnet/corefx/issues/9855#issuecomment-298982251"><span class="koboSpan" id="kobo.58.1">missing OpenSSL 1.0 package</span></a><span class="koboSpan" id="kobo.59.1"> in distro.</span><br/><span class="koboSpan" id="kobo.60.1">
Arch Linux community efforts tracked </span><a href="https://bbs.archlinux.org/viewtopic.php?pid=1708479"><span class="koboSpan" id="kobo.61.1">here</span></a><span class="koboSpan" id="kobo.62.1">.</span></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.63.1">FreeBSD &amp; NetBSD</span></td>
<td><span class="koboSpan" id="kobo.64.1">[C] TBD</span></td>
<td><span class="koboSpan" id="kobo.65.1">TBD</span></td>
<td><span class="koboSpan" id="kobo.66.1">Tracking </span><a href="https://github.com/dotnet/coreclr/issues/6115"><span class="koboSpan" id="kobo.67.1">main issue</span></a><span class="koboSpan" id="kobo.68.1"> and </span><a href="https://github.com/dotnet/coreclr/labels/os-freebsd"><span class="koboSpan" id="kobo.69.1">label</span></a><span class="koboSpan" id="kobo.70.1">.</span><br/><span class="koboSpan" id="kobo.71.1">
NetBSD packages for </span><a href="https://github.com/dotnet/coreclr/issues/6115#issuecomment-233151220"><span class="koboSpan" id="kobo.72.1">.NET Core 1.0.0</span></a></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.73.1">As for the types of programmable project available from any of the above-mentioned IDE's, .NET Core can support its own application model, and also the Universal Windows Platform Model, optionally compiled to .NET Native (see the following screenshot):</span></p>
<div class="CDPAlignCenter"><span class="koboSpan" id="kobo.74.1"><img height="191" width="209" class=" image-border" src="assets/ee337a92-791f-4607-8b0c-290aee531b55.png"/></span></div>
<div class="CDPAlignCenter packt_figref CDPAlign"><span class="koboSpan" id="kobo.75.1">Source: </span><a href="http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx"><span class="koboSpan" id="kobo.76.1">http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.</span><span><span class="koboSpan" id="kobo.77.1">aspx</span></span></a></div>
<p><span class="koboSpan" id="kobo.78.1">We end this introduction to .NET Core with the summary from the same page mentioned previously in relation to this framework:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.79.1">Cross-platform</span></strong><span class="koboSpan" id="kobo.80.1">: .NET Core currently supports three main operating systems--Linux, Windows and OS X. </span><span class="koboSpan" id="kobo.80.2">There are other OS ports in progress such as FreeBSD, NetBSD, and Arch Linux. </span><span class="koboSpan" id="kobo.80.3">.NET Core libraries can run unmodified across supported OSes. </span><span class="koboSpan" id="kobo.80.4">The apps must be re-compiled per environment, given that apps use a native host. </span><span class="koboSpan" id="kobo.80.5">Users select the .NET Core supported environment that works best for their situation.</span></li>
<li><strong><span class="koboSpan" id="kobo.81.1">Open Source</span></strong><span class="koboSpan" id="kobo.82.1">: .NET Core is available on GitHub at </span><a href="https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md"><span class="koboSpan" id="kobo.83.1">https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md</span></a><span class="koboSpan" id="kobo.84.1">, licensed with the MIT and Apache 2 licenses (licensing is per component). </span><span class="koboSpan" id="kobo.84.2">It also makes use of a significant set of open source industry dependencies (see release notes). </span><span class="koboSpan" id="kobo.84.3">Being OSS is critical for having a thriving community plus a must for many organizations where OSS is part of their development strategy.</span></li>
<li><strong><span class="koboSpan" id="kobo.85.1">Natural acquisition</span></strong><span class="koboSpan" id="kobo.86.1">: .NET Core is distributed as a set of NuGet packages that developers can pick and choose from. </span><span class="koboSpan" id="kobo.86.2">The runtime and base framework can be acquired from NuGet and OS-specific package managers, such as APT, Homebrew, and Yum. </span><span class="koboSpan" id="kobo.86.3">Docker images are available on docker hub. </span><span class="koboSpan" id="kobo.86.4">The higher-level framework libraries and the larger .NET library ecosystem are available on NuGet.</span></li>
<li><strong><span class="koboSpan" id="kobo.87.1">Modular framework</span></strong><span class="koboSpan" id="kobo.88.1">: .NET Core is built with a modular design, enabling applications to include only the .NET Core libraries and dependencies that are needed. </span><span class="koboSpan" id="kobo.88.2">Each application makes its own .NET Core versioning choices, avoiding conflicts with shared components. </span><span class="koboSpan" id="kobo.88.3">This approach aligns with the trend of developing software using container technologies such as Docker.</span></li>
<li><strong><span class="koboSpan" id="kobo.89.1">Smaller deployment footprint</span></strong><span class="koboSpan" id="kobo.90.1">: Even when in v1.0/1.1 the size of .NET Core is a lot smaller than .NET Framework; note that the overall size of .NET Core doesn't set out to be smaller than the .NET Framework over time, but since it is pay-for-play, most applications that utilize only parts of CoreFX will have a smaller deployment footprint.</span></li>
<li><strong><span class="koboSpan" id="kobo.91.1">Fast release cycles of .NET Core</span></strong><span class="koboSpan" id="kobo.92.1">: .NET Core's modular architecture plus its OSS nature provide more modern and much faster release cycles (even per NuGet package) compared to slow release cycles from larger monolithic frameworks. </span><span class="koboSpan" id="kobo.92.2">This approach allows a much faster innovation pace from Microsoft and the OSS .NET community than what was traditionally possible with the .NET Framework.</span></li>
</ul>
<p class="QuotePACKT"><span class="koboSpan" id="kobo.93.1">Thus, there are multiple application model stacks built on top of the .NET Core that allow developers to build applications ranging from console applications, across UWP Windows 10 apps (PC, tablet, and phones) to scalable web applications and microservices with ASP.NET Core.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ASP.NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">ASP.NET applications that use .NET Core promote a model based on the previous MVC model, although built from scratch, targeted at cross-platform execution, the elimination of some unnecessary features, and the unification of the previous MVC with the web API variant; so, they work with the same controller type.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Besides this, the code doesn't need to be compiled prior to execution while you're developing. </span><span class="koboSpan" id="kobo.3.2">The BrowserSync technology allows you change the code on-the-fly and the Roselyn services take care of updating; so, you just have to refresh your page to see the changes.</span></p>
<p><span class="koboSpan" id="kobo.4.1">ASP.NET Core also uses a new hosting model, completely decoupled from the web server environment that hosts the application. </span><span class="koboSpan" id="kobo.4.2">It supports IIS versions and also self-hosting contexts via Kestrel (cross-platform, extremely optimized, built on top of LibUv, the same component that Node.js uses) and WebListener HTTP (Windows-only) servers.</span></p>
<p><span class="koboSpan" id="kobo.5.1">As part of its architecture, it proposes a new generation of middleware that is asynchronous, very modular, lightweight, and totally configurable, where we define things such as routing, authentication, static files, diagnostics, error handling, session, CORS, localization; and they can even be user-defined.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Notice also that ASP.NET Core can run as well in the classic .NET Framework with access to the functionality exposed by those libraries. </span><span class="koboSpan" id="kobo.6.2">The following screenshot shows the schema:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img height="178" width="398" class=" image-border" src="assets/991fdcd2-0907-42ae-a698-432ddeae6b14.png"/></span></div>
<p><span class="koboSpan" id="kobo.8.1">ASP.NET Core joins many things that were separate in previous versions. </span><span class="koboSpan" id="kobo.8.2">Thus, there are no distinctions between MVC and Web API and, if you target .NET Core or if you prefer to target any of the other version of .NET, the architectural model can be MVC using this rebuilt architecture.</span></p>
<p><span class="koboSpan" id="kobo.9.1">In addition, a new built-in IoC container for dependency injection is responsible for bootstrapping the system, together with a new configuration protocol, which we'll see in practice in the following chapters.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">About the IDE used in this book</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Since this book deals with .NET Core and ASP.NET Core and their built-in capabilities covering SOLID principles in general and DI in particular, we're using the latest available version of Visual Studio (Visual Studio 2017 Enterprise), which includes full support for these platforms, together with a bunch of convenient extensions and templates.</span></p>
<p><span class="koboSpan" id="kobo.3.1">You can also use Visual Studio 2017 Community Edition, which is free, or any higher version with practically no changes, as far as the codes samples are concerned.</span></p>
<p><span class="koboSpan" id="kobo.4.1">If you're a Mac user, you can also use Visual Studio for Mac (</span><a href="https://www.visualstudio.com/vs/visual-studio-mac/" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.5.1">https://www.visualstudio.com/vs/visual-studio-mac/</span></span></a><span class="koboSpan" id="kobo.6.1">), available since November 2016, and, if you prefer a light, full-fledged, and free IDE for any platform (Linux, Mac or Windows), you can opt for Visual Studio Code (</span><a href="https://code.visualstudio.com/download" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://code.visualstudio.com/download</span></span></a><span class="koboSpan" id="kobo.8.1">), which also has excellent editing and debugging capabilities. </span><span class="koboSpan" id="kobo.8.2">All of them have full support for .NET Core/ASP.NET Core as well (see the following screenshot):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1"><img class=" image-border" src="assets/4b6e0c2e-656d-4746-97c5-65f130e39d09.png"/></span></div>
<p><span class="koboSpan" id="kobo.10.1">Throughout this and other chapters, I'll use indiscriminately .NET Core or ASP.NET Core for the demos, depending on whether we need a more complex user interface or not. </span><span class="koboSpan" id="kobo.10.2">Notice also that .NET Core (for the time being) does not offer any visual UI beyond Console applications.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Actually, the currently available templates shown by default when we select </span><em><span class="packt_screen"><span class="koboSpan" id="kobo.12.1">New Project</span></span></em><span class="koboSpan" id="kobo.13.1"> and click on </span><span class="packt_screen"><span class="koboSpan" id="kobo.14.1">.NET Core</span></span><span class="koboSpan" id="kobo.15.1"> are the ones you can see in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img height="311" width="535" src="assets/a6c16fe2-d1f2-4828-946f-372be1fca13d.png"/></span></div>
<p><span class="koboSpan" id="kobo.17.1">As you see, the choices are basically threefold (besides testing): Console apps, Class libraries, and ASP.NET Core Web apps, based on NET Core. </span><span class="koboSpan" id="kobo.17.2">In the three cases, the resulting apps run on any platform.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Other foundational changes in .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's important to keep in mind that, with NET Core, you no longer depend on .NET Framework libraries (the BCL libraries), either installed by the OS or manually and located in the GAC (Global Assembly Cache).</span></p>
<p><span class="koboSpan" id="kobo.3.1">All libraries are available via NuGet and downloaded accordingly. </span><span class="koboSpan" id="kobo.3.2">But, if you have tried .NET Core prior to Visual Studio 2017, you might miss the file </span><kbd><span class="koboSpan" id="kobo.4.1">project.json</span></kbd><span class="koboSpan" id="kobo.5.1"> in which all dependencies were referenced.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The official documentation states that when using Visual Studio 2017:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">MSBuild supports .NET Core projects, using a simplified </span><kbd><span class="koboSpan" id="kobo.8.1">csproj</span></kbd><span class="koboSpan" id="kobo.9.1"> project format that makes it easier to be edited by hand, without the need for unloading the project</span></li>
<li><span class="koboSpan" id="kobo.10.1">There is support for file wildcards in the project file, enabling folder-based projects that don't require individual files to be included</span></li>
<li><span class="koboSpan" id="kobo.11.1">NuGet package references are now part of the </span><kbd><span class="koboSpan" id="kobo.12.1">csproj</span></kbd><span class="koboSpan" id="kobo.13.1"> format, consolidating all project references in one file</span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">So, if you try a new .NET Core project with this tool, the project's dependencies are now referenced in the </span><kbd><span class="koboSpan" id="kobo.15.1">csproj</span></kbd><span class="koboSpan" id="kobo.16.1"> file (in XML format), as you can see when opening it in any text editor:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img height="130" width="358" src="assets/2ef002b8-cf59-47ae-8be3-ea6dcce235c9.png"/></span></div>
<p><span class="koboSpan" id="kobo.18.1">In parallel, Visual Studio reads that file, creates a </span><kbd><span class="koboSpan" id="kobo.19.1">Dependencies</span></kbd><span class="koboSpan" id="kobo.20.1"> entry in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.21.1">Solution Explorer</span></span><span class="koboSpan" id="kobo.22.1">, and starts looking for that information (either in the PC's cache or in NuGet).</span></p>
<p><span class="koboSpan" id="kobo.23.1">Note also that they're not real, classic DLLs, but fragments of code that are assembled all together at compile time to minimize size and launch time. </span><span class="koboSpan" id="kobo.23.2">If you take a look at that entry you can see the </span><span class="packt_screen"><span class="koboSpan" id="kobo.24.1">Dependencies</span></span><span class="koboSpan" id="kobo.25.1">' dependencies, and so on:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img height="242" width="386" src="assets/551b8bc4-174e-43f4-900c-1288d9d309f5.png"/></span></div>
<p><span class="koboSpan" id="kobo.27.1">Another critical point to highlight relates to the deliverables produced after the compiling process. </span><span class="koboSpan" id="kobo.27.2">If you open the demo included as </span><span class="packt_screen"><span class="koboSpan" id="kobo.28.1">ConsoleApp1</span></span><span class="koboSpan" id="kobo.29.1"> (or create a basic one of your own), and just compile it, you'll see that the </span><span class="packt_screen"><span class="koboSpan" id="kobo.30.1">bin</span></span><span class="koboSpan" id="kobo.31.1"> directory does not contain any executable file. </span><span class="koboSpan" id="kobo.31.2">You'll see a DLL with that name instead (</span><span class="packt_screen"><span class="koboSpan" id="kobo.32.1">ConsoleApp1.dll</span></span><span class="koboSpan" id="kobo.33.1">).</span></p>
<p><span class="koboSpan" id="kobo.34.1">When you launch the application (after adding a </span><kbd><span class="koboSpan" id="kobo.35.1">Console.Read()</span></kbd><span class="koboSpan" id="kobo.36.1"> sentence to stop execution), you'll see that the executable is, indeed, </span><kbd><span class="koboSpan" id="kobo.37.1">dotnet.exe</span></kbd><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">And the same is true when you open the </span><span class="packt_screen"><span class="koboSpan" id="kobo.39.1">Diagnostics Too</span></span><span class="packt_screen"><span class="koboSpan" id="kobo.40.1">l</span></span><span class="koboSpan" id="kobo.41.1"> and take a snapshot of the executable to see what is in place in that moment. </span><span class="koboSpan" id="kobo.41.2">The following screenshot shows the situation:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.42.1"><img height="234" width="488" class=" image-border" src="assets/419d5222-7299-47be-9774-fd60507cf1d4.png"/></span></div>
<p><span class="koboSpan" id="kobo.43.1">The reason for this is directly related to the complexity of this model. </span><span class="koboSpan" id="kobo.43.2">The application is thought to execute on distinct platforms. </span><span class="koboSpan" id="kobo.43.3">The default option allows the deployment architecture to determine the best way to configure the JIT compilers depending on the target. </span><span class="koboSpan" id="kobo.43.4">This is why the execution is undertaken by the dotnet runtime (named </span><span class="packt_screen"><span class="koboSpan" id="kobo.44.1">dotnet.exe</span></span><span class="koboSpan" id="kobo.45.1">).</span></p>
<p><span class="koboSpan" id="kobo.46.1">From the point of view of deployment, in .NET Core, two types of application are defined: portable and self-contained.</span></p>
<p><span><span class="koboSpan" id="kobo.47.1">In .NET Core, portable applications are the default. </span><span class="koboSpan" id="kobo.47.2">Of course, that means that (as developers) we can be sure about their portability in distinct .NET core installations. </span><span class="koboSpan" id="kobo.47.3">However, a standalone app does not depend on any previous installation to run. </span><span class="koboSpan" id="kobo.47.4">That is to say, it holds within itself all the necessary components and dependencies, including the runtime packaged with the application. </span><span class="koboSpan" id="kobo.47.5">Certainly, that builds a larger app, but it also makes the application capable of executing on any .NET Core platform whether you have .NET Core installed in the target or not.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">For the main purposes of this book, it doesn't matter which runtime mode we choose. </span><span class="koboSpan" id="kobo.48.2">Anyhow, this brief introduction can give you an idea of how the new framework behaves and is managed inside Visual Studio 2017.</span></p>
<p><span class="koboSpan" id="kobo.49.1">And, remember, anything I do using Visual Studio 2017, you can also do with Visual Studio Code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The SOLID principles</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Some programming guidelines have a comprehensive, general-purpose intention, while others are mainly designed to fix certain specific problems. </span><span class="koboSpan" id="kobo.2.2">Therefore, before we focus on specific problems, it's important to review those features that can be applied in different scenarios and solutions. </span><span class="koboSpan" id="kobo.2.3">I mean those principles that you should consider beyond the type of solution or specific platform to program for.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This is where the SOLID principles (and other related problems) come into play. </span><span class="koboSpan" id="kobo.3.2">In 2001, Robert Martin published a foundational article on the subject (</span><a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.4.1">http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</span></span></a><span class="koboSpan" id="kobo.5.1">), in which he enumerated a set of principles and guidelines that, in his own words, focus very tightly on dependency management, its potential problems, and how to avoid them.</span></p>
<p><span class="koboSpan" id="kobo.6.1">To explain this further, in his words, </span><em><span class="koboSpan" id="kobo.7.1">poor dependency management leads to code that is hard to change, fragile, and non-reusable</span></em><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">So, this principle is directly related with two of the OOP mantras--reusability, and maintainability (the capacity to change as the project grows, one of the main goals of inheritance).</span></p>
<p><span class="koboSpan" id="kobo.9.1">Overall, Martin stated his 11 commandments to consider, but they can be divided into three areas:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">The five SOLID principles, which deal with class design</span></li>
<li><span class="koboSpan" id="kobo.11.1">The other six principles, mainly focused on packages--three of them are about package cohesion, and the other three explain the dangers of package coupling and how to evaluate a package structure</span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">We're going to start with the SOLID principles, which by extension not only affect the class design, but also other aspects of software architecture.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.13.1">The application of these ideas has, for example, been decisive in important modifications made to the HTML5 standard. </span><span class="koboSpan" id="kobo.13.2">Concretely, the application of the </span><strong><span class="koboSpan" id="kobo.14.1">SRP</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong><span class="koboSpan" id="kobo.16.1">Single Responsibility principle</span></strong><span class="koboSpan" id="kobo.17.1">) only highlighted the need to totally separate presentation (CSS) from content (HTML) and the subsequent deprecation of some tags (</span><kbd><span class="koboSpan" id="kobo.18.1">&lt;cite&gt;</span></kbd><span class="koboSpan" id="kobo.19.1">, </span><kbd><span class="koboSpan" id="kobo.20.1">&lt;small&gt;</span></kbd><span class="koboSpan" id="kobo.21.1">, </span><kbd><span class="koboSpan" id="kobo.22.1">&lt;font&gt;</span></kbd><span class="koboSpan" id="kobo.23.1">).</span></div>
<p><span class="koboSpan" id="kobo.24.1">This applies to other popular frameworks as well, such as AngularJS (and even more in Angular 2), both designed not only with the Single Responsibility principle in mind but also based on the </span><strong><span class="koboSpan" id="kobo.25.1">Dependency Inversion</span></strong><span class="koboSpan" id="kobo.26.1"> principle (the </span><strong><span class="koboSpan" id="kobo.27.1">D</span></strong><span class="koboSpan" id="kobo.28.1"> in SOLID).</span></p>
<p><span class="koboSpan" id="kobo.29.1">The following diagram schematizes the five principles' initials and correspondences:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.30.1"><img height="193" width="333" src="assets/433e9b9f-6c4e-4c2c-9bd5-f5c088ae6f4d.png"/></span></div>
<p><span class="koboSpan" id="kobo.31.1">The explanation of every letter in the acronym as expressed in Wikipedia is as follows:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.32.1">S - Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.33.1">: A class should have only a single responsibility (that is, only one potential change in the software's specification should be able to affect the specification of the class). </span><span class="koboSpan" id="kobo.33.2">Martin states that this principle is based on the principle of cohesion, previously defined by Tom de Marco in a book named </span><em><span class="koboSpan" id="kobo.34.1">Structured Analysis and Systems Specification</span></em><span class="koboSpan" id="kobo.35.1"> and by Meilir Page-Jones in his work </span><em><span class="koboSpan" id="kobo.36.1">The Practical Guide to Structured Systems Design</span></em><span class="koboSpan" id="kobo.37.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.38.1">O - Open/Closed Principle</span></strong><span class="koboSpan" id="kobo.39.1">: Software entities should be open for extension, but closed for modification. </span><span class="koboSpan" id="kobo.39.2">Bertrand Meyer was the first to propose this principle. </span><span class="koboSpan" id="kobo.39.3">Martin puts this in another way at </span><a href="http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod"><span class="URLPACKT"><span class="koboSpan" id="kobo.40.1">http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</span></span></a><span class="koboSpan" id="kobo.41.1">, saying that </span><em><em><span class="koboSpan" id="kobo.42.1">You should be able to extend a class's behavior, without modifying it.</span></em></em></li>
<li><strong><span class="koboSpan" id="kobo.43.1">L - Liskov Substitution principle</span></strong><span class="koboSpan" id="kobo.44.1">: Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. </span><span class="koboSpan" id="kobo.44.2">Barbara Liskov first stated this, and Martin rephrases the principle in this manner--</span><em><span class="koboSpan" id="kobo.45.1">Derived classes must be substitutable for their base classes</span></em><span class="koboSpan" id="kobo.46.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.47.1">I - Interface Segregation principle</span></strong><span class="koboSpan" id="kobo.48.1">: </span><em><span class="koboSpan" id="kobo.49.1">Many client-specific interfaces are better than one general-purpose interface</span></em><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">Robert C. </span><span class="koboSpan" id="kobo.50.3">Martin was the first to use and formulate this principle, which he rewords in the aforementioned article as--</span><em><span class="koboSpan" id="kobo.51.1">Make fine grained interfaces that are client specific.</span></em></li>
<li><strong><span class="koboSpan" id="kobo.52.1">D - Dependency inversion principle</span></strong><span class="koboSpan" id="kobo.53.1">: </span><em><span class="koboSpan" id="kobo.54.1">We should 'Depend on Abstractions'. </span><span class="koboSpan" id="kobo.54.2">Do not depend upon concretions</span></em><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">This too is an idea developed by Robert C. </span><span class="koboSpan" id="kobo.55.3">Martin.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Single Responsibility Principle (SRP)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><strong><span class="koboSpan" id="kobo.3.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">SRP</span></strong><span class="koboSpan" id="kobo.6.1">), focuses on the fact that there should never be more than one reason for a class to change. </span><span class="koboSpan" id="kobo.6.2">In this context, responsibility is defined as a reason for a change. </span><span class="koboSpan" id="kobo.6.3">If, under any circumstances, more than one reason comes up to change the class, then the class' responsibilities are multiple and should be redefined.</span></p>
<p><span class="koboSpan" id="kobo.7.1">This is, indeed, one of the most difficult principles to apply properly because as Martin says, </span><em><span class="koboSpan" id="kobo.8.1">conjoining responsibilities is something that we do naturally</span></em><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">In his book, </span><em><span class="koboSpan" id="kobo.10.1">Agile Principles, Patterns, and Practices in C#</span></em><span class="koboSpan" id="kobo.11.1">, Martin proposes a canonical example to show the differences, as follows:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">    interface Modem 
    { 
      public void dial(String phoneNumber); 
      public void hangup(); 
      public void send(char c); 
      public char recv(); 
   } </span></pre>
<p><span class="koboSpan" id="kobo.13.1">Given the previous interface, any class implementing it has two responsibilities: connection management and the communication itself. </span><span class="koboSpan" id="kobo.13.2">Such responsibilities can be used from the different parts of an application, which, in turn, might change as well.</span></p>
<p><span class="koboSpan" id="kobo.14.1">We're going to use the Visual Studio 2017 Class Designer to express the way Martin proposes we express this class design instead:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1"><img height="280" width="326" class=" image-border" src="assets/77024a2f-1d84-4232-ae00-e7317be4c6f5.png"/></span></div>
<p><span class="koboSpan" id="kobo.16.1">As we see, in Martin's solution, the class depends on two interfaces, each one in charge of a responsibility--connection and channel transmission (two abstractions, really: remember that an interface is not compiled and it only serves as a contract for the compiler to check).</span></p>
<p><span class="koboSpan" id="kobo.17.1">However, one wonders, should these two responsibilities be separated? </span><span class="koboSpan" id="kobo.17.2">It only depends on application changes. </span><span class="koboSpan" id="kobo.17.3">To be precise, the key here is to know whether changes in the application affect the signature of connection functions. </span><span class="koboSpan" id="kobo.17.4">If they do, we should separate both; otherwise, there's no need for separation because we would then create needless complexity.</span></p>
<p><span class="koboSpan" id="kobo.18.1">So, overall, a reason to change is the key, but keep in mind that a reason to change is applicable only if changes occur.</span></p>
<p><span class="koboSpan" id="kobo.19.1">In other situations, there might be reasons to keep distinct responsibilities together as long as they are closely related to the business definitions or have to do with the hardware requirements of the operating system.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The background of the Separation of Concerns (SoC)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As always happens, there were previous approaches to the problem of software separation. </span><span class="koboSpan" id="kobo.2.2">Dijkstra in "</span><em><span class="koboSpan" id="kobo.3.1">On the role of scientific thought</span></em><span class="koboSpan" id="kobo.4.1">" (</span><a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html"><span class="URLPACKT"><span class="koboSpan" id="kobo.5.1">http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html</span></span></a><span class="koboSpan" id="kobo.6.1">) mentioned that </span><em><span class="koboSpan" id="kobo.7.1">It is what I sometimes have called "the separation of concerns", which, even if not perfectly possible, is yet the only available technique for effective ordering of one's thoughts, that I know of.</span></em></p>
<p><span class="koboSpan" id="kobo.8.1">Another advance was Information Hiding, defined by Wikipedia (</span><a href="https://en.wikipedia.org/wiki/Information_hiding"><span class="koboSpan" id="kobo.9.1">https://en.wikipedia.org/wiki/Information_hiding</span></a><span class="koboSpan" id="kobo.10.1">) as </span><em><span class="koboSpan" id="kobo.11.1">the principle of segregation of the design decisions in a computer program that</span></em> <em><span class="koboSpan" id="kobo.12.1">are</span></em> <em><span class="koboSpan" id="kobo.13.1">most likely to change, thus protecting other parts of the program from extensive modification if the design decision is changed.</span></em><span class="koboSpan" id="kobo.14.1"> This was the seed that later became a basic pillar of OOP--Data Encapsulation.</span></p>
<p><span class="koboSpan" id="kobo.15.1">Even Barbara Liskov, whom we mentioned in connection with the substitution principle, published at the same time </span><em><span class="koboSpan" id="kobo.16.1">Programming With Abstract Data Types</span></em><span class="koboSpan" id="kobo.17.1"> (</span><a href="http://dl.acm.org/citation.cfm?id=807045"><span class="koboSpan" id="kobo.18.1">http://dl.acm.org/citation.cfm?id=807045</span></a><span class="koboSpan" id="kobo.19.1">), which she describes as an approach to the computer representation of abstraction. </span><span class="koboSpan" id="kobo.19.2">The definition of ADTs as a class of objects whose logical behavior is defined by a set of values and a set of operations links data and functionality.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Later approaches have improved these ideas. </span><span class="koboSpan" id="kobo.20.2">Proposals for Code Contracts, originally introduced by Bertrand Meyer in his Eiffel language, and implemented in C# via Code Contracts (</span><a href="https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx)"><span class="URLPACKT"><span class="koboSpan" id="kobo.21.1">https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx</span></span><span class="koboSpan" id="kobo.22.1">)</span></a><span class="koboSpan" id="kobo.23.1"> foster the use of pre and post conditions that our software has to accomplish.</span></p>
<p><span class="koboSpan" id="kobo.24.1">Finally, we can think of the separation of what Hayim Makabee (</span><a href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/"><span class="koboSpan" id="kobo.25.1">https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/</span></a><span class="koboSpan" id="kobo.26.1">) reports as cross-cutting concerns--aspects that might affect distinct pieces of software in even distinct layers of the application and that should be managed in a similar fashion (authorization or instrumentation issues, and so on.). </span><span class="koboSpan" id="kobo.26.2">In .Net, we count on Attributes, applicable equally to classes and class members, to modify and tune such behavior.</span></p>
<p><span class="koboSpan" id="kobo.27.1">A bit later in the same article, Makabee clearly establishes the main purposes for these techniques. </span><span class="koboSpan" id="kobo.27.2">If we understand coupling as the degree of dependency between two modules, the goal is to obtain low coupling. </span><span class="koboSpan" id="kobo.27.3">Another term is cohesion or the measure of how strongly-related the set of functions performed by a module is. </span><span class="koboSpan" id="kobo.27.4">Obviously, high cohesion is better.</span></p>
<p><span class="koboSpan" id="kobo.28.1">He ends by summarizing the benefits obtained with these techniques:</span></p>
<p><span class="koboSpan" id="kobo.29.1">Patterns and methodologies are always intended to reduce coupling and at the same time increase congruity. </span><span class="koboSpan" id="kobo.29.2">By hiding information, we reduce coupling since we isolate implementation details. </span><span class="koboSpan" id="kobo.29.3">Thus, ADT's reduce coupling by using clear and abstract interfaces. </span><span class="koboSpan" id="kobo.29.4">We have an ADT specifying the set of function that can be executed on a type, that's more cohesive than a global data structure modified by external functions. </span><span class="koboSpan" id="kobo.29.5">The way that OOP reaches that cohesion is the implementation of two of its basic principles--encapsulation and polymorphism, together with dynamic binding. </span><span class="koboSpan" id="kobo.29.6">Furthermore, inheritance reinforces cohesion by means of hierarchies that are based on generalization and specialization, which permits a suitable separation from the functionality belonging to a superclass from its subclasses. </span><span class="koboSpan" id="kobo.29.7">AOP, in turn, supplies solutions for cross-cutting concerns in a way that both aspects and functionality may become more cohesive.</span></p>
<p><span class="koboSpan" id="kobo.30.1">Maintainability, reusability, and extensibility are only three of the main advantages gained with its implementation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Well-known examples of Separation of Concerns</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">All of us have gone through cases and scenarios where the separation of concerns lies at the heart of the system or technology that implements it. </span><span class="koboSpan" id="kobo.2.2">One such case is HTML (and, especially HTML5).</span></p>
<p><span class="koboSpan" id="kobo.3.1">Since its inception, the standard HTML5 was thought to clearly separate content from presentation. </span><span class="koboSpan" id="kobo.3.2">And the popularity of mobile devices only made that requirement more evident. </span><span class="koboSpan" id="kobo.3.3">The huge variety of form factors available today demanded a technology capable of adapting to these sizes, in such a way that content could be held by HTML tags and the final presentation in a given device decided at runtime depending on the device.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Therefore, some tags were declared deprecated, such as </span><kbd><span class="koboSpan" id="kobo.5.1">&lt;font&gt;</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">&lt;big&gt;</span></kbd><span class="koboSpan" id="kobo.8.1">, </span><kbd><span class="koboSpan" id="kobo.9.1">&lt;center&gt;</span></kbd><span class="koboSpan" id="kobo.10.1">, and a list of others, and the same happened to some attributes, such as </span><kbd><span class="koboSpan" id="kobo.11.1">background</span></kbd><span class="koboSpan" id="kobo.12.1">, </span><kbd><span class="koboSpan" id="kobo.13.1">align</span></kbd><span class="koboSpan" id="kobo.14.1">, </span><kbd><span class="koboSpan" id="kobo.15.1">bgcolor</span></kbd><span class="koboSpan" id="kobo.16.1">, or </span><kbd><span class="koboSpan" id="kobo.17.1">border</span></kbd><span class="koboSpan" id="kobo.18.1"> since they didn't make sense in this new system. </span><span class="koboSpan" id="kobo.18.2">Even some of them that still remain unchanged and that have a visual effect on the output (such as </span><kbd><span class="koboSpan" id="kobo.19.1">&lt;b&gt;</span></kbd><span class="koboSpan" id="kobo.20.1">, </span><kbd><span class="koboSpan" id="kobo.21.1">&lt;i&gt;</span></kbd><span class="koboSpan" id="kobo.22.1">, or </span><kbd><span class="koboSpan" id="kobo.23.1">&lt;small&gt;</span></kbd><span class="koboSpan" id="kobo.24.1">) are kept for their semantic meaning and not for their presentational effects, which is a role totally dependent on CSS3.</span></p>
<p><span class="koboSpan" id="kobo.25.1">So, one of the main goals is to avoid functionality overlapping, although this is not the only benefit. </span><span class="koboSpan" id="kobo.25.2">If we understand concerns as the different aspects of software functionality, the business logic of software is a concern, and the interface through which a person uses this logic is another.</span></p>
<p><span class="koboSpan" id="kobo.26.1">In practice, this translates into keeping the code for each of these concerns separate. </span><span class="koboSpan" id="kobo.26.2">That means, changing the interface should not require changing the business logic code, and vice versa. </span><span class="koboSpan" id="kobo.26.3">The underlying principle of encapsulation reinforces these ideas in the OOP paradigm, and the </span><strong><span class="koboSpan" id="kobo.27.1">Model-view-controller</span></strong><span class="koboSpan" id="kobo.28.1"> (</span><strong><span class="koboSpan" id="kobo.29.1">MVC</span></strong><span class="koboSpan" id="kobo.30.1">) design pattern is a great example of separating these concerns for better software maintainability.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">A basic sample of Separation of Concerns</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's put this into code with a very basic sample and check for the differences between coupled and decoupled implementations. </span><span class="koboSpan" id="kobo.2.2">Imagine that a Console application in .NET Core has to show the user the initial configuration of Console colors, change a value, and present those changes.</span></p>
<p><span class="koboSpan" id="kobo.3.1">If you make a basic project </span><kbd><span class="koboSpan" id="kobo.4.1">ConsoleApp1</span></kbd><span class="koboSpan" id="kobo.5.1">, the following code could be the first approach:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">    using System; 
 
    class Program 
    { 
      static void Main(string[] args) 
      { 
        Console.ResetColor(); 
        Console.WriteLine("This is the default configuration for Console"); 
        Console.ForegroundColor = ConsoleColor.Cyan; 
        Console.WriteLine("Color changed..."); 
        Console.Read(); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.7.1">This produces the expected results (see the following screenshot showing the output):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="98" width="333" class=" image-border" src="assets/2b26742b-2bde-43dc-946c-74cbb2e91fd1.png"/></span></div>
<p><span class="koboSpan" id="kobo.9.1">Which problems can we find in this code? </span><span class="koboSpan" id="kobo.9.2">First, the main point is in charge of everything: resets the previous initial configuration of the console, changes the foreground, and prints the results.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The first attempt at separation would be to realize that further needs might require other fragments of code to use the same functionality. </span><span class="koboSpan" id="kobo.10.2">Even more, that functionality would be better located in another difference-- a piece of software such as a library, for example. </span><span class="koboSpan" id="kobo.10.3">So, we should enhance our solution with a new project containing a library project that would be referenced by any other projects along with the solution.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Besides, the manual change to Cyan color implicitly reminds us of the need for a function that allows changing to any valid color.</span></p>
<p><span class="koboSpan" id="kobo.12.1">So, we might end up with another piece of code like this:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">    namespace Utilities 
    { 
      public class ConsoleService 
      { 
        public void ChangeForegroundColor(ConsoleColor newColor) 
        { 
            Console.ForegroundColor = newColor; 
        } 
        public void ResetConsoleValues() 
        { 
            Console.ResetColor(); 
        } 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.14.1">Now, in the main entry point, we could write:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    /* This is version 2 (with utilities) */ 
    ConsoleService cs = new ConsoleService(); 
    cs.ResetConsoleValues(); 
    Console.WriteLine("This is the default configuration for Console"); 
    cs.ChangeForegroundColor(ConsoleColor.Cyan); 
    Console.WriteLine("Color changed..."); 
    Console.Read(); </span></pre>
<p><span class="koboSpan" id="kobo.16.1">With exactly the same results (I omit the output since there are no changes). </span><span class="koboSpan" id="kobo.16.2">So, we made a physical separation together with a logical one, given that now any change to the </span><kbd><span class="koboSpan" id="kobo.17.1">Console</span></kbd><span class="koboSpan" id="kobo.18.1">, should be managed by the </span><kbd><span class="koboSpan" id="kobo.19.1">Utilities</span></kbd><span class="koboSpan" id="kobo.20.1"> library, which increases their reusability and therefore maintainability and testing.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Notice also that we could have opted for creating the library as static, to avoid instantiation.</span></p>
<p><span class="koboSpan" id="kobo.22.1">The only change over previous versions of .NET is that, as we showed in a previous screenshot, the reference to the library is now made slightly differently, as it appears in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.23.1">Dependencies</span></span><span class="koboSpan" id="kobo.24.1"> section on the </span><span class="packt_screen"><span class="koboSpan" id="kobo.25.1">Solution Explorer</span></span><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">Once the project is compiled, we can also see that reference in the </span><kbd><span class="koboSpan" id="kobo.27.1">bin</span></kbd><span class="koboSpan" id="kobo.28.1"> directory resulting from compilation:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.29.1"><img height="119" width="293" src="assets/c8c31586-699a-49c0-ae4f-e844ade412e2.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Another sample</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's take a more everyday approach with another sample: something simple, such as reading from a JSON file on a disk and presenting the results in the output. </span><span class="koboSpan" id="kobo.2.2">So, I've created a .NET Core Console app that includes a JSON file with five books from PACKT.</span></p>
<p><span class="koboSpan" id="kobo.3.1">A first approach could be the following code:</span></p>
<pre><span class="koboSpan" id="kobo.4.1">    using System; 
    using System.IO; 
    using Newtonsoft.Json; 
 
    class Program 
    { 
      static void Main(string[] args) 
      { 
        Console.WriteLine(" List of Books by PACKT"); 
        Console.WriteLine(" ----------------------"); 
        var cadJSON = ReadFile("Data/BookStore.json"); 
        var bookList = JsonConvert.DeserializeObject&lt;Book[]&gt;(cadJSON); 
        foreach (var item in bookList) 
        { 
            Console.WriteLine($" {item.Title.PadRight(39,' ')} " +  
                $"{item.Author.PadRight(15,' ')} {item.Price}");  
        } 
        Console.Read(); 
      } 
 
      static string ReadFile(string filename) 
      { 
        return File.ReadAllText(filename); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.5.1">As we can see, the code uses a </span><kbd><span class="koboSpan" id="kobo.6.1">Book</span></kbd><span class="koboSpan" id="kobo.7.1"> class that implements the </span><kbd><span class="koboSpan" id="kobo.8.1">IBook</span></kbd><span class="koboSpan" id="kobo.9.1"> interface, defined in a very simple manner:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    interface IBook 
    { 
      string Title { get; set; } 
      string Author { get; set; } 
      double Price { get; set; } 
    } 
    class Book : IBook 
    { 
      public string Author { get; set; } 
      public double Price { get; set; } 
      public string Title { get; set; } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.11.1">This works fine, and generates the following output:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="139" width="466" src="assets/055ba326-0689-4f4c-bbc1-2228223eb651.png"/></span></div>
<p><span class="koboSpan" id="kobo.13.1">Notice that we're using the popular Newtonsoft JSON library, to easily convert the string into an array of </span><kbd><span class="koboSpan" id="kobo.14.1">Book</span></kbd><span class="koboSpan" id="kobo.15.1"> objects.</span></p>
<p><span class="koboSpan" id="kobo.16.1">If we analyze the code, we can identify several places where that SoC principle is present:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">First, since the entity to manage is a </span><kbd><span class="koboSpan" id="kobo.18.1">Book</span></kbd><span class="koboSpan" id="kobo.19.1"> (which has three properties), I created a </span><kbd><span class="koboSpan" id="kobo.20.1">Model</span></kbd><span class="koboSpan" id="kobo.21.1"> folder to hold the definition of a </span><kbd><span class="koboSpan" id="kobo.22.1">Book</span></kbd><span class="koboSpan" id="kobo.23.1"> interface (</span><kbd><span class="koboSpan" id="kobo.24.1">IBook</span></kbd><span class="koboSpan" id="kobo.25.1">), and also a </span><kbd><span class="koboSpan" id="kobo.26.1">Book</span></kbd><span class="koboSpan" id="kobo.27.1"> class that implements that interface</span></li>
<li><span class="koboSpan" id="kobo.28.1">Secondly, the use of the </span><kbd><span class="koboSpan" id="kobo.29.1">Newtonsoft</span></kbd><span class="koboSpan" id="kobo.30.1"> library is another separation since it's the library that takes care of the conversion of the string into an array of </span><kbd><span class="koboSpan" id="kobo.31.1">Books</span></kbd></li>
<li><span class="koboSpan" id="kobo.32.1">Finally, file reading takes place in the method </span><kbd><span class="koboSpan" id="kobo.33.1">ReadFile()</span></kbd><span class="koboSpan" id="kobo.34.1">, which receives the name of the file</span></li>
</ul>
<p><span class="koboSpan" id="kobo.35.1">Is there any other separation required? </span><span class="koboSpan" id="kobo.35.2">As we mentioned, the reason to change would be key at the time to decide. </span><span class="koboSpan" id="kobo.35.3">For example, does the app read another type of information (apart from </span><kbd><span class="koboSpan" id="kobo.36.1">Books</span></kbd><span class="koboSpan" id="kobo.37.1">)? </span><span class="koboSpan" id="kobo.37.2">Or, does our UI really need to include the </span><kbd><span class="koboSpan" id="kobo.38.1">ReadFile()</span></kbd><span class="koboSpan" id="kobo.39.1">method? </span><span class="koboSpan" id="kobo.39.2">And what about having to reference directly the </span><kbd><span class="koboSpan" id="kobo.40.1">Newtonsof</span></kbd><span class="koboSpan" id="kobo.41.1">t library directly in the user interface?</span></p>
<p><span class="koboSpan" id="kobo.42.1">If this isn't the case, perhaps a better approach would be to separate that method in a </span><kbd><span class="koboSpan" id="kobo.43.1">Utilities</span></kbd><span class="koboSpan" id="kobo.44.1"> class, just like in the first sample, thus ensuring architecture has three separate folders to hold different aspects of the application: the data model, the utilities area, and the main user interface.</span></p>
<p><span class="koboSpan" id="kobo.45.1">In this manner, we would end up with a </span><kbd><span class="koboSpan" id="kobo.46.1">Utilities</span></kbd><span class="koboSpan" id="kobo.47.1"> class like this:</span></p>
<pre><span class="koboSpan" id="kobo.48.1">    using Newtonsoft.Json; 
    using System.IO; 
 
    internal class Utilities 
    { 
      internal static Book[] ReadData() 
      { 
        var cadJSON = ReadFile("Data/BookStore.json"); 
        return JsonConvert.DeserializeObject&lt;Book[]&gt;(cadJSON); 
      } 
 
      static string ReadFile(string filename) 
      { 
        return File.ReadAllText(filename); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.49.1">And the resulting </span><kbd><span class="koboSpan" id="kobo.50.1">Program</span></kbd><span class="koboSpan" id="kobo.51.1"> class gets reduced to the following:</span></p>
<pre><span class="koboSpan" id="kobo.52.1">    using System; 
 
    class Program 
    { 
      static void Main(string[] args) 
      { 
        var bookList = Utilities.ReadData(); 
        PrintBooks(bookList); 
      } 
 
      static void PrintBooks(Book[] books) 
      { 
        Console.WriteLine(" List of Books by PACKT"); 
        Console.WriteLine(" ----------------------"); 
        foreach (var item in books) 
        { 
          Console.WriteLine($" {item.Title.PadRight(39, ' ')} "  + </span><br/><span class="koboSpan" id="kobo.53.1">             $"{item.Author.PadRight(15, ' ')} {item.Price}"); 
        } 
        Console.Read(); 
      } 
    }  </span></pre>
<p><span class="koboSpan" id="kobo.54.1">Of course, we get the same output, but now we have an initial separation of concerns. </span><span class="koboSpan" id="kobo.54.2">There's no need to reference external libraries in the UI, which facilitates maintainability and extensibility.</span></p>
<p><span class="koboSpan" id="kobo.55.1">Let's now explore the second principle: Open/Closed.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Open/Closed principle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can detect the need to use this principle when a change in the module results in a cascade of changes that affect dependent modules. </span><span class="koboSpan" id="kobo.2.2">The design is said to be too inflexible.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The </span><strong><span class="koboSpan" id="kobo.4.1">Open/Closed principle</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong><span class="koboSpan" id="kobo.6.1">OCP</span></strong><span class="koboSpan" id="kobo.7.1">) principle advises us that we should refactor the application in such a manner that future changes don't provoke further modifications.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The form to apply this principle correctly would be by extending the functionality with new code (for instance, using polymorphism) and never changing the old code, which is working already. </span><span class="koboSpan" id="kobo.8.2">We can find several strategies to achieve this goal.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Observe that closed for modification is especially meaningful when you have distinct, separate modules (DLLs, EXEs, and so on) that depend on the module that has to be changed.</span></p>
<p><span class="koboSpan" id="kobo.10.1">On the other hand, using extension methods or polymorphic techniques allows us to perform changes in code without affecting the rest. </span><span class="koboSpan" id="kobo.10.2">Think, for example, about the extension methods available in the C# language since version 3.0.</span></p>
<p><span class="koboSpan" id="kobo.11.1">You can consider extension methods as a special type of static methods with the difference being that they are called as if they were instance methods of the extended type. </span><span class="koboSpan" id="kobo.11.2">You find a typical example in the LINQ standard query operators because they add a query functionality to the existing types, such as </span><kbd><span class="koboSpan" id="kobo.12.1">System.Collections.IEnumerable</span></kbd><span class="koboSpan" id="kobo.13.1"> or </span><kbd><span class="koboSpan" id="kobo.14.1">System.Collections.Generic.IEnumerable&lt;T&gt;</span></kbd><span class="koboSpan" id="kobo.15.1">.</span></p>
<p><span class="koboSpan" id="kobo.16.1">The classical and simplest example of this pattern is the client/server cohesion that has been largely seen in development for many years. </span><span class="koboSpan" id="kobo.16.2">It is preferable that clients depend on server abstractions, not on their concretions.</span></p>
<p><span class="koboSpan" id="kobo.17.1">This can be achieved with interfaces. </span><span class="koboSpan" id="kobo.17.2">Servers can implement a client interface that clients will use to connect to them. </span><span class="koboSpan" id="kobo.17.3">In this manner, servers can change without affecting the way clients use them (refer to the following diagram):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"><img height="159" width="254" class=" image-border" src="assets/8ce953ba-b990-4382-9cca-78e872b36543.png"/></span></div>
<p><span class="koboSpan" id="kobo.19.1">Any subtype of the client interface will be free to implement the interface in the way it deems more appropriate, and as long as it doesn't break other clients' access.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Back to our sample</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's imagine a simple case in which the app has to cover a new aspect. </span><span class="koboSpan" id="kobo.2.2">For example, the app now has to allow the user to list an extra file of books to be added to the previous list.</span></p>
<p><span class="koboSpan" id="kobo.3.1">For this new requirement, we can create a new and overloaded </span><kbd><span class="koboSpan" id="kobo.4.1">ReadData()</span></kbd><span class="koboSpan" id="kobo.5.1"> method that receives an extra argument. </span><span class="koboSpan" id="kobo.5.2">Notice here that the argument doesn't even have to be used. </span><span class="koboSpan" id="kobo.5.3">It's enough if it declares another signature to be invoked for this extra situation.</span></p>
<p><span class="koboSpan" id="kobo.6.1">If we have the extra data in another file (</span><kbd><span class="koboSpan" id="kobo.7.1">BookStore2</span></kbd><span class="koboSpan" id="kobo.8.1">.</span><kbd><span class="koboSpan" id="kobo.9.1">json</span></kbd><span class="koboSpan" id="kobo.10.1">, in our demo), we could create this extra version of the method:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">     internal static List&lt;Book&gt; ReadData(string extra) 
     { 
       List&lt;Book&gt; books = ReadData(); 
       var cadJSON = ReadFile("Data/BookStore2.json"); 
       books.AddRange(JsonConvert.DeserializeObject&lt;List&lt;Book&gt;&gt;(cadJSON)); 
       return books; 
     } </span></pre>
<p><span class="koboSpan" id="kobo.12.1">Notice that we don't even use the method's argument in this implementation (of course, there are other ways to do this, but let's put it this way for the purpose of the demo).</span></p>
<p><span class="koboSpan" id="kobo.13.1">We have now two versions of </span><kbd><span class="koboSpan" id="kobo.14.1">ReadData()</span></kbd><span class="koboSpan" id="kobo.15.1"> that should be called in the user interface depending on the user's choice (I also changed the </span><kbd><span class="koboSpan" id="kobo.16.1">Book[]</span></kbd><span class="koboSpan" id="kobo.17.1"> definition into a </span><kbd><span class="koboSpan" id="kobo.18.1">List&lt;Book&gt;</span></kbd><span class="koboSpan" id="kobo.19.1"> for simplicity, but you can see the older version as well in the source code):</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    static List&lt;Book&gt; bookList; 
    static void Main(string[] args) 
    { 
      Console.WriteLine("Please, press 'yes' to read an extra file, "); 
      Console.WriteLine("or any other key for a single file"); 
      var ans = Console.ReadLine(); 
      bookList = (ans != "yes") ? </span><span class="koboSpan" id="kobo.20.2">Utilities.ReadData() : Utilities.ReadData(ans); 
      PrintBooks(bookList); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.21.1">Now if the user's answer is </span><em><span class="koboSpan" id="kobo.22.1">yes</span></em><span class="koboSpan" id="kobo.23.1"> you have an extra set of books added to the list, as you can see in the output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.24.1"><img class=" image-border" src="assets/e265aab9-543e-48d8-aa15-7a4f66f11b2f.png"/></span></div>
<p><span class="koboSpan" id="kobo.25.1">Besides all these reasons, you can think of situations such as having the </span><kbd><span class="koboSpan" id="kobo.26.1">Utilities</span></kbd><span class="koboSpan" id="kobo.27.1"> code separated in a distinct library that could also be used by other parts of the application. </span><span class="koboSpan" id="kobo.27.2">The implementation of the Open/Closed principle here allows a more stable and extensible approach.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Liskov Substitution principle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's remember this definition--subtypes must be substitutable for their base types. </span><span class="koboSpan" id="kobo.2.2">This means that this should happen without breaking the execution or losing any other kind of functionality.</span></p>
<p><span class="koboSpan" id="kobo.3.1">You'll notice that this idea lies behind the basic principles of inheritance in the OOP programming paradigm.</span></p>
<p><span class="koboSpan" id="kobo.4.1">If you have a method that requires an argument of the </span><kbd><span class="koboSpan" id="kobo.5.1">Person</span></kbd><span class="koboSpan" id="kobo.6.1"> type (let's put it that way), you can pass an instance of another class (</span><kbd><span class="koboSpan" id="kobo.7.1">Employee</span></kbd><span class="koboSpan" id="kobo.8.1">, </span><kbd><span class="koboSpan" id="kobo.9.1">Provider</span></kbd><span class="koboSpan" id="kobo.10.1">, and so on) as long as these instances inherit from </span><kbd><span class="koboSpan" id="kobo.11.1">Person</span></kbd><span class="koboSpan" id="kobo.12.1">.</span></p>
<p><span class="koboSpan" id="kobo.13.1">This is one of the main advantages of well-designed OOP languages, and most popular and accepted languages support this characteristic.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Back to the code again</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's take a look at the support inside our sample, where a new requirement arises. </span><span class="koboSpan" id="kobo.2.2">Actually, our demo simply calls the </span><kbd><span class="koboSpan" id="kobo.3.1">PrintBooks</span></kbd><span class="koboSpan" id="kobo.4.1"> method and expects to receive a </span><kbd><span class="koboSpan" id="kobo.5.1">List&lt;Book&gt;</span></kbd><span class="koboSpan" id="kobo.6.1"> object as the argument.</span></p>
<p><span class="koboSpan" id="kobo.7.1">However, another reason for change might come up when new lists of books appear, and those lists include some new field, like the topic each book belongs to (.NET, Node, Angular, and so on).</span></p>
<p><span class="koboSpan" id="kobo.8.1">For example, a new list appears containing a fourth field, </span><kbd><span class="koboSpan" id="kobo.9.1">Topic</span></kbd><span class="koboSpan" id="kobo.10.1">, in this way:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">    { 
      "Title": "AngularJS Services", 
      "Author": "Jim Lavin", 
      "Price": 30.99, 
      "Topic": "Angular" 
    } </span></pre>
<p><span class="koboSpan" id="kobo.12.1">The class </span><kbd><span class="koboSpan" id="kobo.13.1">Book</span></kbd><span class="koboSpan" id="kobo.14.1"> should not be changed since it's being used already. </span><span class="koboSpan" id="kobo.14.2">Thus, we can inherit from </span><kbd><span class="koboSpan" id="kobo.15.1">Book</span></kbd><span class="koboSpan" id="kobo.16.1"> and create a </span><kbd><span class="koboSpan" id="kobo.17.1">TopicBook</span></kbd><span class="koboSpan" id="kobo.18.1"> class just adding the new field (I'm trying to keep things as simple as possible to focus on the architecture we're dealing with):</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    public class TopicBook : Book 
    { 
      public string Topic { get; set; } 
    }</span></pre>
<p><span class="koboSpan" id="kobo.20.1">To cover this new aspect, we can change the user interface to allow the user to select a new option (</span><kbd><span class="koboSpan" id="kobo.21.1">topic</span></kbd><span class="koboSpan" id="kobo.22.1">) that includes the new type of book:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">    static void Main(string[] args) 
    { 
      Console.WriteLine("Please, press 'yes' to read an extra file, "); 
      Console.WriteLine("'topic' to include topic books or any</span><br/><span class="koboSpan" id="kobo.24.1">          other key for a single file"); 
      var ans = Console.ReadLine(); 
      bookList = ((ans != "yes") &amp;&amp; (ans != "topic")) ?  
        </span><span class="koboSpan" id="kobo.24.2">Utilities.ReadData() : Utilities.ReadData(ans); 
      PrintBooks(bookList); 
    }   </span></pre>
<p><span class="koboSpan" id="kobo.25.1">Notice that we're just including a new condition and calling the overloaded method in case the new condition is selected.</span></p>
<p><span class="koboSpan" id="kobo.26.1">As for the </span><kbd><span class="koboSpan" id="kobo.27.1">ReadData()</span></kbd><span class="koboSpan" id="kobo.28.1"> overloaded method, we can make some minimal changes (basically, adding an </span><kbd><span class="koboSpan" id="kobo.29.1">if</span></kbd><span class="koboSpan" id="kobo.30.1"> condition to include the extra data), like you can see in the following code:</span></p>
<pre><span class="koboSpan" id="kobo.31.1">    internal static List&lt;Book&gt; ReadData(string extra) 
    { 
      List&lt;Book&gt; books = ReadData(); 
      var filename = "Data/BookStore2.json"; 
      var cadJSON = ReadFile(filename); 
         books.AddRange(JsonConvert.DeserializeObject&lt;List&lt;Book&gt;&gt;(cadJSON)); 
      if (extra == "topic") 
      { 
         filename = "Data/BookStore3.json"; 
         cadJSON = ReadFile(filename); 
         books.AddRange(JsonConvert.DeserializeObject&lt;List&lt;TopicBook&gt;&gt;(cadJSON)); 
      } 
      return books; 
    } 
 </span></pre>
<p><span class="koboSpan" id="kobo.32.1">Observe that the method's changes are minimal, and especially that we're adding to the list of books the result of deserializing a different class (</span><kbd><span class="koboSpan" id="kobo.33.1">TopicBook</span></kbd><span class="koboSpan" id="kobo.34.1">), without any compilation or execution problems.</span></p>
<p><span class="koboSpan" id="kobo.35.1">Therefore, the implementation of Generics in .NET (and .NET Core, in this case) correctly implements the Liskov Substitution Principle, and we don't have to make modifications in our logic.</span></p>
<p><span class="koboSpan" id="kobo.36.1">We can check the results in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.37.1">Automatic Window</span></span><span class="koboSpan" id="kobo.38.1"> using a breakpoint before the </span><kbd><span class="koboSpan" id="kobo.39.1">return</span></kbd><span class="koboSpan" id="kobo.40.1"> sentence of </span><kbd><span class="koboSpan" id="kobo.41.1">ReadData</span></kbd><span class="koboSpan" id="kobo.42.1"> and seeing how the </span><kbd><span class="koboSpan" id="kobo.43.1">List&lt;Book&gt;</span></kbd><span class="koboSpan" id="kobo.44.1"> now includes five elements of type </span><kbd><span class="koboSpan" id="kobo.45.1">TopicBook</span></kbd><span class="koboSpan" id="kobo.46.1">, with no complaints:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.47.1"><img height="321" width="523" class=" image-border" src="assets/93b4c95e-e217-47b0-917a-6c54857c62ca.png"/></span></div>
<p><span class="koboSpan" id="kobo.48.1">What about the other side (the user interface logic) and, especially, our </span><kbd><span class="koboSpan" id="kobo.49.1">PrintBooks</span></kbd><span class="koboSpan" id="kobo.50.1"> method, which expects a </span><kbd><span class="koboSpan" id="kobo.51.1">List&lt;Book&gt;</span></kbd><span class="koboSpan" id="kobo.52.1">? </span><span class="koboSpan" id="kobo.52.2">Well, there's no difference insofar as we don't try to print out a field that doesn't exist.</span></p>
<p><span class="koboSpan" id="kobo.53.1">You can check the output in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.54.1"><img height="272" width="485" class=" image-border" src="assets/d7689355-b322-49c0-a426-ec60a6c98b46.png"/></span></div>
<p><span class="koboSpan" id="kobo.55.1">Thanks to the Liskov Substitution principle support, we were able to add behavior and information with minimum effort, and consequently, enforce the OOP principle of code reutilization.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Other implementations of LSP in .NET</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">What we've seen up to this point is not the only implementation of the LSP principle that we find inside .NET, since different areas of the framework, have grown using this conception.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Events are flexible enough to be defined in a way that allows us to pass our own information via classic definitions, alternatively with the participation of generics, we can simply define a generic event handler that holds information of any kind. </span><span class="koboSpan" id="kobo.3.2">All these techniques foster the implementation of good practices, not just the SOLID principles.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Interface Segregation principle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As Martin states, this principle deals with the inconveniences of </span><em><span class="koboSpan" id="kobo.3.1">fat</span></em><span class="koboSpan" id="kobo.4.1"> interfaces. </span><span class="koboSpan" id="kobo.4.2">And the problem arises when the interfaces of the class can be logically fragmented into distinct groups or methods.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In this case, if there is more than one client of our application, chances are that some clients are connected to a functionality they never use. </span><span class="koboSpan" id="kobo.5.2">As Martin states in his </span><em><span class="koboSpan" id="kobo.6.1">Agile Principles Patterns and Practices in C#</span></em><span class="koboSpan" id="kobo.7.1"> book,</span></p>
<div class="packt_quote"><span class="koboSpan" id="kobo.8.1">When the clients are separate, the interfaces should remain separate, too. </span><span class="koboSpan" id="kobo.8.2">Why? </span><span class="koboSpan" id="kobo.8.3">Because clients exert forces on their server interfaces. </span><span class="koboSpan" id="kobo.8.4">When we think of forces that cause changes in software, we normally think about how changes to interfaces will affect their users.</span></div>
<p><span class="koboSpan" id="kobo.9.1">And, as a conclusion, he remarks that</span></p>
<div class="packt_quote"><span class="koboSpan" id="kobo.10.1">When clients are forced to depend on methods they don't use, those clients are subject to changes to those methods. </span><span class="koboSpan" id="kobo.10.2">This results in an inadvertent coupling between all the clients. </span><span class="koboSpan" id="kobo.10.3">Said another way, when a client depends on a class that contains methods that the client does not use but that other clients do use, that client will be affected by the changes that those other clients force on the class. </span><span class="koboSpan" id="kobo.10.4">We would like to avoid such couplings where possible, and so we want to separate the interfaces.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Another sample</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's see this situation with another example that starts from a new scenario. </span><span class="koboSpan" id="kobo.2.2">Let's imagine another app in which we have to cover not only the two types of books available at the moment but also a new publication in video format, that holds another field named </span><kbd><span class="koboSpan" id="kobo.3.1">Duration</span></kbd><span class="koboSpan" id="kobo.4.1">.</span></p>
<p><span class="koboSpan" id="kobo.5.1">A single record of this file would look like this:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">     { 
       "Title": "HTML 5 Game Development", 
       "Author": "Daniel Albu", 
       "Price": 5.68, 
       "Topic": "HTML5 Games", 
       "Duration": "2h20m" 
     }  </span></pre>
<p><span class="koboSpan" id="kobo.7.1">But the application maintains the other two previous formats, so we have the possibility to list files with three, four, or five fields, depending on the initial selection the user chooses.</span></p>
<p><span class="koboSpan" id="kobo.8.1">A first approach could lead us to an interface like this:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    interface IProduct 
    { 
      string Title {get; set;} 
      string Author {get; set;} 
      double Price {get; set;} 
      string Topic { get; set; } 
      string Duration { get; set; } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.10.1">Based on this interface we could create the </span><kbd><span class="koboSpan" id="kobo.11.1">Product</span></kbd><span class="koboSpan" id="kobo.12.1"> class (the new name is supposed to locate a step above the books or videos since both have four fields in common):</span></p>
<pre><span class="koboSpan" id="kobo.13.1">    public class Product : IProduct 
    { 
      public string Title { get; set; } 
      public string Author { get; set; } 
      public double Price { get; set; } 
      public string Topic { get; set; } 
      public string Duration { get; set; } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.14.1">Now, the equivalent </span><kbd><span class="koboSpan" id="kobo.15.1">Utilities</span></kbd><span class="koboSpan" id="kobo.16.1"> class could select a file depending on the user's entry, read it, deserialize it, and send the information back to a </span><kbd><span class="koboSpan" id="kobo.17.1">PrintProducts</span></kbd><span class="koboSpan" id="kobo.18.1"> method in charge of the console output.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Our new user interface would look like this:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    using System;
    using System.Collections.Generic;

    class Program
    {
      static List&lt;Product&gt; productList;
      static void Main(string[] args)
      {
        string id = string.Empty;
        do
        {
            Console.WriteLine("File no. </span><span class="koboSpan" id="kobo.20.2">to read: 1/2/3-Enter(exit): ");
            id = Console.ReadLine();
            if ("123".Contains(id) &amp;&amp; !String.IsNullOrEmpty(id))
            {
                productList = Utilities.ReadData(id);
                PrintBooks(productList);
            }
        } while (!String.IsNullOrWhiteSpace(id));
      }

      static void PrintBooks(List&lt;Product&gt; products)
      {
        Console.WriteLine(" List of Products by PACKT");
        Console.WriteLine(" ----------------------");
        foreach (var item in products)
        {
            Console.WriteLine($" {item.Title.PadRight(36, ' ')} " +
            $"{item.Author.PadRight(20, ' ')} {item.Price}" + " " +
            $"{item.Topic?.PadRight(12, ' ') } " +]
            $"{item.Duration ?? </span><span class="koboSpan" id="kobo.20.3">""}");
        }
        Console.WriteLine();
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.21.1">Observe that we had to deal with the two cases in which some field could be null, so we use string interpolation, together with the null coalescence operator (</span><kbd><span class="koboSpan" id="kobo.22.1">??</span></kbd><span class="koboSpan" id="kobo.23.1">) and the Null-conditional operator (</span><kbd><span class="koboSpan" id="kobo.24.1">?</span></kbd><span class="koboSpan" id="kobo.25.1">), to prevent failure in these cases.</span></p>
<p><span class="koboSpan" id="kobo.26.1">The </span><kbd><span class="koboSpan" id="kobo.27.1">Utilities</span></kbd><span class="koboSpan" id="kobo.28.1"> class gets reduced to a much simpler code:</span></p>
<pre><span class="koboSpan" id="kobo.29.1">    using System.Collections.Generic;
    using System.IO;

    internal class Utilities
    {
      internal static List&lt;Product&gt; ReadData(string fileId)
      {
        var filename = "Data/ProductStore" + fileId + ".json";
        var cadJSON = ReadFile(filename);
        return JsonConvert.DeserializeObject&lt;List&lt;Product&gt;&gt;(cadJSON);
      }
      static string ReadFile(string filename)
      {
        return File.ReadAllText(filename);
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.30.1">The output lets the user select a number and print the file's content in a similar way to what we did in previous demos, only this time selecting each file individually:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.31.1"><img height="386" width="501" class=" image-border" src="assets/4d0040db-0d58-4b08-b5e9-891917d4b7a0.png"/></span></div>
<p><span class="koboSpan" id="kobo.32.1">If our application now requires more changes, like the addition of statistics, for example, the use of a single class to hold them all (the </span><kbd><span class="koboSpan" id="kobo.33.1">Product</span></kbd><span class="koboSpan" id="kobo.34.1"> class, here) denotes a violation of the Interface Segregation principle.</span></p>
<p><span class="koboSpan" id="kobo.35.1">This is because we should separate the interfaces and use a compound approach to prevent a class from dealing with unwanted or unneeded functionality.</span></p>
<p><span class="koboSpan" id="kobo.36.1">The alternative and proper separation could be to create the following (distinct) interfaces:</span></p>
<pre><span class="koboSpan" id="kobo.37.1">    interface IProduct
    {
      string Title { get; set; }
      string Author { get; set; }
      double Price { get; set; }
    }

    interface ITopic
    {
      string Topic { get; set; }
    }

    interface IDuration
    {
      string Duration { get; set; }
    }</span></pre>
<p><span class="koboSpan" id="kobo.38.1">Now we should have three classes, since three entities can be distinguished, but could maintain three fields in common. </span><span class="koboSpan" id="kobo.38.2">The definitions of the three classes could be expressed in this way:</span></p>
<pre><span class="koboSpan" id="kobo.39.1">    class Book : IProduct
    {
      public string Author { get; set; }
      public double Price { get; set; }
      public string Title { get; set; }
    }
    class TopicBook: IProduct, ITopic
    {
      public string Author { get; set; }
      public double Price { get; set; }
      public string Title { get; set; }
      public string Topic { get; set; }
    }
    class Video: IProduct, ITopic, IDuration
    {
      public string Author { get; set; }
      public double Price { get; set; }
      public string Title { get; set; }
      public string Topic { get; set; }
      public string Duration { get; set; }
    }</span></pre>
<p><span class="koboSpan" id="kobo.40.1">Thanks to this division every entity keeps its own personality, and we can later create methods that use generics, or apply the Liskov Substitution principle to deal with the distinct requirements that might arise during the lifecycle.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Dependency Inversion principle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The last of the SOLID principles is based on two statements, which Wikipedia (</span><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle"><span class="koboSpan" id="kobo.3.1">https://en.wikipedia.org/wiki/Dependency_inversion_principle</span></a><span class="koboSpan" id="kobo.4.1">) defines in this form:</span></p>
<ul>
<li><em><span class="koboSpan" id="kobo.5.1">High-level modules should not depend on low-level modules. </span><span class="koboSpan" id="kobo.5.2">Both should depend on abstractions</span></em></li>
<li><em><span class="koboSpan" id="kobo.6.1">Abstractions should not depend upon details. </span><span class="koboSpan" id="kobo.6.2">Details should depend upon abstractions</span></em></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">As for the first statement, we should clarify what we understand by high-level and low-level modules. </span><span class="koboSpan" id="kobo.7.2">The terminology is related to the importance of the actions performed by the module with respect to the application as a whole.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Let's put it simply: if a module holds the business logic of a </span><kbd><span class="koboSpan" id="kobo.9.1">Customers</span></kbd><span class="koboSpan" id="kobo.10.1"> class, and another module </span><kbd><span class="koboSpan" id="kobo.11.1">PrinterService</span></kbd><span class="koboSpan" id="kobo.12.1"> includes the format that a list of the </span><kbd><span class="koboSpan" id="kobo.13.1">Customers</span></kbd><span class="koboSpan" id="kobo.14.1"> class uses in a report, the first one would be high-class and the second would be low-class (the reason for the existence of the second is to provide some functionality to the first).</span></p>
<p><span class="koboSpan" id="kobo.15.1">The second statement speaks for itself. </span><span class="koboSpan" id="kobo.15.2">If an abstraction depends on details, the usage as a definition contract is compromised (a change in the details could force a redefinition).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The (more or less) canonical example</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Dependency Injection techniques are just a way of implementing this principle, and we will see them exemplified in many forms and scenarios along this book.</span></p>
<p><span class="koboSpan" id="kobo.3.1">So, I'll use here the (almost) canonical code that you could find on the internet about this subject. </span><span class="koboSpan" id="kobo.3.2">I'm showing you here an adaptation made by Munir Hassan (</span><a href="https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency"><span class="koboSpan" id="kobo.4.1">https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency</span></a><span class="koboSpan" id="kobo.5.1">) in CodeProject which uses a notification scenario to illustrate this situation, and I think it's particularly interesting. </span><span class="koboSpan" id="kobo.5.2">He starts with an initial code such as this:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">    public class Email
    {
      public void SendEmail()
      {
        // code
      }
    }
    public class Notification
    {
      private Email _email;
      public Notification()
      {
        _email = new Email();
      }
      public void PromotionalNotification()
      {
        _email.SendEmail();
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.7.1">Notification depends on </span><kbd><span class="koboSpan" id="kobo.8.1">Email</span></kbd><span class="koboSpan" id="kobo.9.1">, creating an instance in its constructor. </span><span class="koboSpan" id="kobo.9.2">This kind of interaction is said to be tightly coupled. </span><span class="koboSpan" id="kobo.9.3">If we want to send other types of notification as well, we have to modify the way the </span><kbd><span class="koboSpan" id="kobo.10.1">Notification</span></kbd><span class="koboSpan" id="kobo.11.1"> class is implemented.</span></p>
<p><span class="koboSpan" id="kobo.12.1">A way to achieve this could be the introduction of an interface (a new level of abstraction) to define the concept of sending messages and force the </span><kbd><span class="koboSpan" id="kobo.13.1">Email</span></kbd><span class="koboSpan" id="kobo.14.1"> class to implement that interface:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    public interface IMessageService
    {
      void SendMessage();
    }
    public class Email : IMessageService
    {
      public void SendMessage()
      {
        // code
      }
    }
    public class Notification
    {
      private IMessageService _iMessageService;
      public Notification()
      {
        _iMessageService = new Email();
      }
      public void PromotionalNotification()
      {
        _iMessageService.SendMessage();
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.16.1">Now, the class calls something named </span><kbd><span class="koboSpan" id="kobo.17.1">_iMessageService</span></kbd><span class="koboSpan" id="kobo.18.1">, whose implementation could vary. </span><span class="koboSpan" id="kobo.18.2">As Hamir mentions, there are three ways to implement this pattern:</span></p>
<div class="packt_quote"><span class="koboSpan" id="kobo.19.1">DI is the act of supplying all classes that a service needs rather than leaving the responsibility to the service to obtain dependent classes. </span><span class="koboSpan" id="kobo.19.2">DI typically comes in three flavors: Constructor Injection, Property Injection, Method Injection</span></div>
<p><span class="koboSpan" id="kobo.20.1">In the first form, (constructor injection) Hamir proposes the following:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">    public class Notification
    {
      private IMessageService _iMessageService;
      public Notification(IMessageService _messageService)
      {
        this._iMessageService = _messageService;
      }
      public void PromotionalNotification()
      {
        _iMessageService.SendMessage();
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.22.1">This reminds us of what we will see in the implementation of Dependency Injection in ASP.NET Core in the following chapters. </span><span class="koboSpan" id="kobo.22.2">No mention of </span><kbd><span class="koboSpan" id="kobo.23.1">Emails</span></kbd><span class="koboSpan" id="kobo.24.1"> here: only an </span><kbd><span class="koboSpan" id="kobo.25.1">IMessageService</span></kbd><span class="koboSpan" id="kobo.26.1"> is implied.</span></p>
<p><span class="koboSpan" id="kobo.27.1">You can visit the aforementioned page for more details about the other ways to implement injection, but, as I mentioned, we'll cover all those in detail in the coming chapters.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Other ways to implement Dependency Inversion</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Generally speaking, there are many ways in which the DIP principle can lead to a solution. </span><span class="koboSpan" id="kobo.2.2">Another way to implement this principle is by using the Dependency Injection techniques, derived from another way to see Dependency Inversion: the so-called </span><strong><span class="koboSpan" id="kobo.3.1">Inversion of Control</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">IoC</span></strong><span class="koboSpan" id="kobo.6.1">).</span></p>
<p><span class="koboSpan" id="kobo.7.1">According to the paper written by Martin Fowler (</span><a href="https://martinfowler.com/articles/injection.html"><span class="koboSpan" id="kobo.8.1">https://martinfowler.com/articles/injection.html</span></a><span class="koboSpan" id="kobo.9.1">), Inversion of Control is the principle whereby the control flow of a program is inverted; instead of the programmer controlling the flow of a program, the external sources (framework, services, and other components) take control of it.</span></p>
<p><span class="koboSpan" id="kobo.10.1">One of them is a dependency container, which is a component and serves or provides you with some code, injecting it when required.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Some popular Dependency Containers for C# are Unity and Ninject, to name just a couple. </span><span class="koboSpan" id="kobo.11.2">In NET Core, there's an embedded container so there's no need to use an external one, except in cases where we might require some special functionality provided by them.</span></p>
<p><span class="koboSpan" id="kobo.12.1">In the code, you instruct this component to register certain classes of your application; so, later on, when you need an instance of one of them, you just have to declare it (typically in the constructor), and it is served to your code automatically.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Other frameworks implement this principle as well, even if they're not purely object-oriented. </span><span class="koboSpan" id="kobo.13.2">This is the case with AngularJS or Angular 2, in which, when you create a controller that requires access to a service, you ask for the service in the controller's function declaration, and the internal Angular's DI system serves a singleton instance of the service without the intervention of the client's code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we've reviewed the five SOLID Principles in the way they were formulated by Robert C. </span><span class="koboSpan" id="kobo.2.2">Martin in 2000.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We've explored each of these principles, discussing their advantages and checking their implementation with some simple code using .NET Core Console applications, to see how they can be coded.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In the next chapter, we will talk about Dependency Injection and the most popular IoC containers, reviewing how they can be used and analyzing their pros and cons in everyday applications.</span></p>


            </article>

            
        </section>
    </body></html>