<html><head></head><body>
        

                            
                    <h1 class="header-title">Documenting Your API Using Swagger</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will learn how to document our API using the OpenAPI Specification and how to use Swagger tools to parse and generate the documentation. Documenting APIs is particularly significant when our web service is consumed by an external company or a foreign organization team. Moreover, some services can be considerably complex and expose a lot of endpoints. For this reason, some tools related to the .NET ecosystem guarantee up-to-date API documentation. Two main toolchains can be used in this process: NSwag and Swashbuckle. In this book, we will cover and use NSwag to document our APIs.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding OpenAPI</li>
<li>Implementing OpenAPI in ASP.NET Core services</li>
</ul>
<p>By the end of this chapter, you will be able to automatically generate up-to-date documentation that's compliant with the OpenAPI Specification using Swagger and the NSwag package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding OpenAPI</h1>
                
            
            
                
<p>The OpenAPI initiative is part of the Linux Foundation and defines the <strong>OpenAPI</strong> <strong>Specification</strong> (<strong>OAS</strong>) standard. The OpenAPI Specification aims to provide a language-agnostic interface for REST APIs. This kind of approach guarantees that both humans and client applications understand and discover the capabilities of a web service by referring to a unique entry point. In addition, it provides a high-level abstraction that can also be used for business or design purposes.</p>
<p>Furthermore, its standard way of querying services facilitates every kind of automation â€“ from the autogeneration of a client to the autogeneration of the documentation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Swagger project</h1>
                
            
            
                
<p>Just like the OpenAPI Specification, Swagger was born as a language-agnostic specification for describing REST APIs. It has recently been adopted by the OpenAPI project, which means there are no differences between these two projects.</p>
<p>The main aim of Swagger is to autogenerate and expose a document called <kbd>swagger.json</kbd>, also known as the <strong>Swagger Specification</strong>. The Swagger Specification is the autogenerated documentation of the API and provides information about every single route that's exposed by the web services. The following code shows the structure of an example <kbd>swagger.json</kbd> file:</p>
<pre>{<br/>  "x-generator": "NSwag v12.0.12.0 (NJsonSchema v9.13.15.0 (Newtonsoft.Json v12.0.0.0))",<br/>  "swagger": "2.0",<br/>  "host": "localhost:5000",<br/>  "schemes": [<br/>    "http"<br/>  ],<br/>  "consumes": [<br/>    "application/json"<br/>  ],<br/>  "paths": {<br/>    "/api/artist": {<br/>      "get": {<br/>        "tags": [<br/>          "Artist"<br/>        ],<br/>        "operationId": "Artist_Get",<br/>        "parameters": [<br/>          {<br/>            "type": "string",<br/>            "name": "artistId",<br/>            "in": "query"<br/>          }<br/>        ],<br/>        "responses": {<br/>          "200": {<br/>            "schema": {<br/>              "type": "file"<br/>            }<br/>          }<br/>        }<br/>...</pre>
<p>The preceding snippet describes some of the routes that are defined in the<strong> catalog service</strong> API. As you can see, at the first level of the JSON, there is some general information about the service, such as the <kbd>apiVersion</kbd>, <kbd>title</kbd>, and <kbd>basePath</kbd> of the service. Furthermore, we can also see a node called <kbd>paths</kbd>, which contains all the paths of our service. For each route, it describes the different response types, the different HTTP verbs, and all the payload information that's accepted by the service. Since we have a unique standard for describing our APIs, it is also possible to define a unique user interface so that we can query and send information to the service; this is what <strong>Swagger UI</strong> does. Swagger UI is a tool that uses the <kbd>swagger.json</kbd> file to provide a user-friendly UI:</p>
<div><img src="img/68000202-f3d8-455b-928f-d5a3f0a2952f.png" style=""/></div>
<p>The preceding screenshot shows an example of a useful UI that we can use to browse the different routes that are exposed by the APIs. Furthermore, it allows the consumer to have an immediate overall view of the data that's provided by the API. Now, let's learn how to implement OpenAPI in ASP.NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing OpenAPI in ASP.NET Core services</h1>
                
            
            
                
<p>There are two different packages that we can use to implement OpenAPI in ASP.NET Core:</p>
<ul>
<li><strong>Swashbuckle</strong>: <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2">https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2</a></li>
<li><strong>NSwag</strong>: <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2">https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2</a></li>
</ul>
<p>Both of these use middleware to generate and serve the <kbd>swagger.json</kbd> file and allow the user interface to browse the service definition. In this section, we will discuss how to integrate NSwag into our vinyl catalog service. The following schema shows how NSwag is plugged into our ASP.NET Core service:</p>
<div><img src="img/9316aeb8-6ddc-4e23-b63f-140dc116b563.png" style=""/></div>
<p>Let's start by adding <kbd>NSwag.AspNetCore</kbd> to the <kbd>Catalog<em>.</em>API</kbd> project by using the following command:</p>
<pre><strong>dotnet add package NSwag.AspNetCore</strong></pre>
<p>After that, we can proceed by combining the middleware to generate and provide the OpenAPI specification and the middleware to initialize the UI. As we saw in <a href="77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml">Chapter 3</a>, <em>Working with the Middleware Pipeline</em>, we need to use the <kbd>Configure</kbd> and <kbd>ConfigureServices</kbd> methods, which are implemented in the <kbd>Startup</kbd> class:</p>
<pre>...<br/>    public class Startup<br/>    {<br/>       <br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            services<br/>                .AddCatalogContext(Configuration.<br/>                GetSection("DataSource:ConnectionString").Value);<br/><br/>            services<br/>               ..<br/>                <strong>.AddOpenApiDocument(settings =&gt;{<br/>                                       settings.Title = "Catalog API";<br/>                                       settings.DocumentName = "v3";<br/>                                       settings.Version = "v3";                                   <br/>                                    });</strong><br/>        }<br/><br/>        public void Configure(IApplicationBuilder app, <br/>        IHostingEnvironment env)<br/>        {<br/>            ...<br/>             app<br/>                <strong>.UseOpenApi()</strong><br/><strong>                .UseSwaggerUi3();</strong><br/>        }<br/>    }<br/>}</pre>
<p><kbd>AddOpenApiDocument</kbd> adds the services that are required for OpenAPI 3.0 generation. <kbd>UseOpenApi</kbd> adds the OpenAPI/Swagger generator, which uses API description to perform Swagger generation, and <kbd>UseSwaggerUi3</kbd> creates and instantiates the middleware that provides the UI of Swagger. Since we integrated the OpenAPI middleware into our service, we can proceed by running our service and browse the <kbd>https://localhost/swagger</kbd> URL using our preferred browser.</p>
<p>NSwag and Swashbuckle use reflection to browse the action methods inside our controllers. Fortunately, this process is only executed the first time the service runs. Sometimes, complex response types can prevent the <kbd>swagger.json</kbd> file from being generated. For that reason, it is strongly suggested that you check all the response types that are provided by the action methods of our controllers.</p>
<p>NSwag also provides some useful utilities so that we can perform code generation on our web services, such as the following ones:</p>
<ul>
<li><kbd>NSwag.CodeGeneration.CSharp</kbd> (<a href="https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/">https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/</a>) </li>
<li><kbd>NSwag.CodeGeneration.TypeScript</kbd> (<a href="https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/">https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/</a>)</li>
</ul>
<p>These allow us to autogenerate client classes for C# and Typescript, respectively.</p>
<p>In this section, we learned how to install and configure NSwag so that we can expose Swagger documentation that's compatible with the OpenAPI Specification. In the next section, we will learn how to explicitly define the conventions for our APIs, as well as how to include additional information in the <kbd>swagger.json</kbd> contract. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding ASP.NET Core's conventions</h1>
                
            
            
                
<p>The default response type of the Swagger UI produces some incorrect information. If we take a look at the responses section, we will see that the response code is incorrect and that it doesn't correspond with the actual HTTP code that's returned by the web service. When using ASP.NET Core 2.2 or later, it is possible to use conventions to specify the response types:</p>
<pre>..<br/>   <strong> [ApiController]</strong><br/>    public class ItemController : ControllerBase<br/>    {<br/>        [HttpGet]<br/>       <strong> [ApiConventionMethod(typeof(DefaultApiConventions), <br/>        nameof(DefaultApiConventions.Get))]</strong><br/>        public async Task&lt;IActionResult&gt; Get([FromQuery] int pageSize = <br/>        10, [FromQuery] int pageIndex = 0)<br/><br/>        [HttpGet("{id:guid}")]<br/>       <strong> [ApiConventionMethod(typeof(DefaultApiConventions), <br/>        nameof(DefaultApiConventions.Get))]</strong><br/>        public async Task&lt;IActionResult&gt; GetById(Guid id)<br/>      ...</pre>
<p>For example, the preceding code uses the <kbd>ApiConventionMethod</kbd> attribute to pass a custom type and a method name. The <kbd>ApiConventionMethod</kbd> attribute is part of the <kbd>Microsoft.AspNetCore.Mvc</kbd> namespace and uses the <kbd>DefaultApiConventions</kbd> static class, which provides a default set of conventions for each action in a generic API. In the same way, we can add that attribute to the writing methods of <kbd>ItemController</kbd>, such as the <kbd>Create</kbd>, <kbd>Update</kbd>, and <kbd>Delete</kbd> methods:</p>
<pre>        ...<br/><br/>        [HttpPost]<br/>     <strong>   [ApiConventionMethod(typeof(DefaultApiConventions), <br/>        nameof(DefaultApiConventions.Create))]</strong><br/>        public async Task&lt;IActionResult&gt; Create(AddItemRequest request)<br/><br/>        [HttpPut("{id:guid}")]<br/>    <strong>    [ApiConventionMethod(typeof(DefaultApiConventions), <br/>        nameof(DefaultApiConventions.Update))]</strong><br/>        public async Task&lt;IActionResult&gt; Update(Guid id, <br/>        EditItemRequest request)<br/><br/>        [HttpDelete("{id:guid}")]<br/>       <strong> [ApiConventionMethod(typeof(DefaultApiConventions), <br/>        nameof(DefaultApiConventions.Delete))]</strong><br/>        public async Task&lt;IActionResult&gt; Delete(Guid id)<br/>    }<br/>}</pre>
<p>This kind of approach is a shortcut that we can use to declare action method responses without explicitly using the <kbd>ProducesResponseType</kbd> attribute. Let's take a look at the <kbd>DefaultApiConventions</kbd> static class, which provides a set of default response types if we declare some static void methods:</p>
<pre>using Microsoft.AspNetCore.Mvc.ApiExplorer;<br/><br/>namespace Microsoft.AspNetCore.Mvc<br/>{<br/>  public static class DefaultApiConventions<br/>  {<br/>    <strong>[ProducesResponseType(200)]</strong><br/><strong>    [ProducesResponseType(404)]</strong><br/><strong>    [ProducesDefaultResponseType]</strong><br/><strong>    [ApiConventionNameMatch(ApiConventionNameMatchBehavior.Prefix)]</strong><br/><strong>    public static void Get([ApiConventionNameMatch<br/>    (ApiConventionNameMatchBehavior.Suffix), ApiConventionTypeMatch(<br/>    ApiConventionTypeMatchBehavior.Any)] object id)</strong><br/><strong>    {</strong><br/><strong>    }</strong><br/>    <br/>    ...<br/>  }<br/>}</pre>
<p>For example, for the <kbd>Get</kbd> method, it states the <kbd>HTTP 200 OK</kbd> response and <kbd>HTTP 404 Not found</kbd>. By doing this, we can easily declare the proper response types for each action. The <kbd>DefaultApiConventions</kbd> class is part of the <kbd>Microsoft.AspNetCore.Mvc</kbd> namespace.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom conventions</h1>
                
            
            
                
<p>The <kbd>DefaultApiConvention</kbd> class isn't always suitable for our controllers. Furthermore, it is too generic, and action methods are usually too specific to suit the <kbd>DefaultApiConvention</kbd> class. Due to this, ASP.NET Core allows us to create our custom API conventions based on our needs. To declare a new convention, we need to create a new static class with the corresponding static methods, like so:</p>
<pre>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.ApiExplorer;<br/><br/>namespace Catalog.API.Conventions<br/>{<br/>    public static class ItemApiConvention<br/>    {<br/><br/>        [ProducesResponseType(200)]<br/>        [ProducesResponseType(404)]<br/>        [ProducesResponseType(400)]<br/>        [ProducesDefaultResponseType]<br/>        [ApiConventionNameMatch(ApiConventionNameMatchBehavior.Prefix)]<br/>        public static void <strong>Get</strong>([ApiConventionNameMatch<br/>        (ApiConventionNameMatchBehavior.Suffix),<br/>                                ApiConventionTypeMatch<br/>                                (ApiConventionTypeMatchBehavior.Any)]<br/>                                 object id)<br/>        {<br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>The conventions we've implemented here describe the <kbd>Get</kbd> action method of <kbd>ItemController</kbd>. As you can see, this method produces the following HTTP responses: <kbd>200</kbd>, <kbd>404</kbd>, and <kbd>400</kbd>. This approach also allows us to generate and extend the response types that are returned by a route. Furthermore, it is possible to assign and use these conventions by applying the attribute in the following way:</p>
<pre>[HttpGet]<br/><strong>[ApiConventionMethod(typeof(ItemApiConvention), nameof(ItemApiConvention.Get))]</strong><br/>public async Task&lt;IActionResult&gt; Get([FromQuery] int pageSize = 10, [FromQuery] int pageIndex = 0)<br/>{<br/><br/>    ...<br/>}</pre>
<p>This approach allows us to customize and group API conventions into a unique class and fully-customize the contract of the API. The same approach can be used for the other action methods that are present in the controller classes of your services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned how to improve the discoverability of web services by documenting them using the OpenAPI Specification. The OpenAPI technique also provides us with a standard way to generate clients in every language and generate auto-maintainable documentation. Documenting APIs is useful when the service is utilized by third-party teams and consumers, and also provides us with a high-level overview of the information and actions that are exposed by the service. </p>
<p>In the next chapter, we will learn about Postman and how to use it to query, test, and check the responses of a web service.</p>


            

            
        
    </body></html>