- en: Creating Your First Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic Standard Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding properties to a shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using properties in a Surface Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover some of the more common diffuse techniques found in
    today's game development shading pipelines. Let's imagine a cube that has been
    painted white uniformly in a 3D environment with a directional light. Even if
    the color used is the same on each face, they will all have different shades of
    white on them depending on the direction that the light is coming from and the
    angle that we are looking at it from. This extra level of realism is achieved
    in 3D graphics through the use of shaders, special programs that are mostly used
    to simulate how light works. A wooden cube and a metal one may share the same
    3D model, but what makes them look different is the shader that they use.
  prefs: []
  type: TYPE_NORMAL
- en: This first chapter will introduce you to shader coding in Unity. If you have
    little to no previous experience with shaders, this chapter is what you need in
    order to understand what shaders are, how they work, and how to customize them.
    By the end of this chapter, you will have learned how to build basic shaders that
    perform basic operations. Armed with this knowledge, you will be able to create
    just about any Surface Shader.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic Standard Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, when we create a game object, we then attach additional functionality
    through the use of **components**. In fact, every game object is required to have
    a Transform component; there are a number of components included in Unity already,
    and we create components of our own when we write scripts that extend from `MonoBehaviour`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the objects that are part of a game contain a number of components that
    affect their look and behavior. While scripts determine how objects should behave,
    renderers decide how they should appear on the screen. Unity comes with several
    renderers, depending on the type of object that we are trying to visualize; every
    3D model typically has a `MeshRenderer` component attached to it. An object should
    have only one renderer, but the renderer itself can contain several materials.
    Each material is a wrapper for a single shader, the final ring in the food chain
    of 3D graphics. The relationships between these components can be seen in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the difference between these components is essential for understanding
    how shaders work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this recipe, you will need to have Unity running and must
    have a project opened. As mentioned before, there will also be a Unity project
    included with this cookbook, so you can use that one as well and simply add your
    own custom shaders to it as you step through each recipe. With this completed,
    you are now ready to step into the wonderful world of real-time shading!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting into our first shader, let''s create a small scene for us to
    work with:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a scene by navigating to File | New Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you create the scene, create a plane to act as the ground by going to GameObject | 3D
    Objects | Plane in the Unity editor. Next, select the object in the Hierarchy tab
    and then go into the Inspector tab. From there, right-click on the Transform component
    and select the Reset Position option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will reset the position property of the object to be at `0`, `0`, `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier to see what our shaders will look like when applied, let''s
    add some shapes to visualize what each of our shaders will do. Create a sphere
    by going to GameObject | 3D Objects | Sphere. Once created, select it and go to
    the Inspector tab. Next, change the Position to `0`, `1`, `0` so it is above the
    origin of the world (which is at `0`, `0`, `0`) and our previously created plane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this sphere is created, create two more spheres, placing them to the left
    and right of the spheres at positions `-2`, `1`, `0` and `2`, `1`, `0` respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, confirm that you have a directional light (it should be seen in the
    Hierarchy tab). If not, you can add one by selecting GameObject | Light | Directional
    Light to make it easier to see the effect of your changes and how your shaders
    react to light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using the Unity project that came with the cookbook, you can open
    up the `Chapter 2` | `Starting Point` scene instead as it has been set up already.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our scene generated, we can move on to the shader writing steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project tab in your Unity editor, right-click on the `Chapter 2` folder
    and select Create | Folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the folder that you created as `Shaders` by right-clicking on it and
    selecting Rename from the drop-down list, or by selecting the folder and hitting
    *F2* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another folder and rename it as `Materials`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Shaders` folder and select Create | Shader | Standard Surface
    Shader. Then, right-click on the `Materials` folder and select Create | Material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename both the shader and material as `StandardDiffuse`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the `StandardDiffuse` shader by double-clicking on the file. This will
    automatically launch a scripting editor for you and display the shader's code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that Unity has already populated our shader with some basic code.
    This, by default, will get you a basic shader that accepts one texture in the
    Albedo (RGB) property. We will be modifying this base code so that you can learn
    how to quickly start developing your own custom shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s give our shader a custom folder from which it''s selected. The very
    first line of code in the shader is the custom description that we have to give
    the shader so that Unity can make it available in the shader drop-down list when
    assigning to materials. We have renamed our path as `Shader "CookbookShaders/StandardDiffuse"`,
    but you can name it whatever you want and rename it at any time so don''t worry
    about any dependencies at this point. Save the shader in your script editor and
    return to the Unity editor. Unity will automatically compile the shader when it
    recognizes that the file has been updated. This is what your shader should look
    like at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Technically speaking, this is a Surface Shader based on **physically-based rendering** (**PBR**).
    As the name suggests, this type of shader achieves realism by simulating how light
    physically behaves when hitting objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After your shader is created, we need to connect it to a material. Select the
    material called `StandardDiffuse` that we created in *step 4* and look at the
    Inspector tab. From the Shader drop-down list, select CookbookShaders | StandardDiffuse.
    (Your shader path might be different if you chose to use a different path name.)
    This will assign your shader to your material and make it ready for you to assign
    to an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To assign material to an object, you can simply click and drag your material
    from the Project tab to the object in your scene. You can also drag material to
    the Inspector tab of an object in the Unity editor in order to assign it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot of an example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Not much to look at at this point, but our shader development environment is
    set up and we can now start to modify the shader to suit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity has made the task of getting your shader environment up and running very
    easy for you. It is simply a matter of a few clicks and you are good to go. There
    are a lot of elements working in the background with regard to the Surface Shader
    itself. Unity has taken the Cg shader language and made it more efficient to write
    by doing a lot of the heavy Cg code lifting for you. The Surface Shader language
    is a more component-based way of writing shaders. Tasks such as processing your
    own texture coordinates and transformation matrices have already been done for
    you, so you don't have to start from scratch any more. In the past, we would have
    to start a new shader and rewrite a lot of code over and over again. As you gain
    more experience with Surface Shaders, you will naturally want to explore more
    of the underlying functions of the Cg language and how Unity is processing all
    of the low-level **graphics** **processing unit** (**GPU**) tasks for you.
  prefs: []
  type: TYPE_NORMAL
- en: All the files in a Unity project are referenced independently from the folder
    that they are in. We can move shaders and materials from within the editor without
    the risk of breaking any connection. Files, however, should never be moved from
    outside the editor as Unity will not be able to update their references.
  prefs: []
  type: TYPE_NORMAL
- en: So, by simply changing the shader's path name to a name of our choice, we have
    got our basic diffuse shader working in the Unity environment, with lights and
    shadows and all that, just by changing one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code of the built-in shaders is typically hidden in Unity. You cannot
    open this from the editor as you do with your own shaders. For more information
    on where to find a large portion of the built-in Cg functions for Unity, go to
    your Unity install directory and navigate to the `Editor` | `Data` | `CGIncludes` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this folder, you can find the source code of the shaders shipped with Unity.
    Over time, they have changed a lot; you can visit the** Unity download archive**
    ([https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive))
    if you need to access the source codes of a shader used in a different version
    of Unity. After choosing the right version, select Built in shaders from the drop-down
    list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are three files that are of note at this point: `UnityCG.cginc`,  `Lighting.cginc`,
    and `UnityShaderVariables.cginc`. Our current shader is making use of all these
    files at the moment. In [Chapter 11](part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08),
    *Advanced Shading Techniques*, we will explore in depth how to use CGInclude for
    a modular approach to shader coding.
  prefs: []
  type: TYPE_NORMAL
- en: Adding properties to a shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Properties of a shader are very important for the shader pipeline as they are
    the method that you use to let the artist or user of the shader assign textures
    and tweak your shader values. Properties allow you to expose GUI elements in a
    material's Inspector tab without you having to use a separate editor, which provides
    visual ways to tweak a shader. With your shader opened in your IDE of choice,
    look at the block of lines two through seven. This is called the `Properties`
    block of the script. Currently, it will have one texture property in it called
    `_MainTex`.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at your material that has this shader applied to it, you will notice
    that there is one **texture** GUI element in the Inspector tab. These lines of
    code in our shader are creating this GUI element for us. Again, Unity has made
    this process very efficient in terms of coding and the amount of time it takes
    to iterate through changing your properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how this works in our current shader called `StandardDiffuse` by creating
    our own properties and learning more about the syntax involved. For this example,
    we will refit the shader previously created. Instead of using a texture, it will
    only use its color and some other properties that we will be able to change directly
    from the Inspector tab. Start by duplicating the `StandardDiffuse` shader. You
    can do this by selecting it in the Inspector tab and pressing *Ctrl *+ *D*. This
    will create a copy called `StandardDiffuse 1`. Go ahead and rename it as `StandardColor`.
  prefs: []
  type: TYPE_NORMAL
- en: You can give a friendlier name to your shader in its first line. For instance,
    `Shader "CookbookShaders/StandardDiffuse"` tells Unity to call this shader `StandardDiffuse` and
    move it to a group called `CookbookShaders`. If you duplicate a shader using *Ctrl *+ *D*,
    your new file will share the same name. To avoid confusion, make sure to change
    the first line of each new shader so that it uses a unique alias in this and future
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the `StandardColor` shader is ready, we can start changing its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line of the script, update the name to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Downloading the example code
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com/). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support) and
    register to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Properties` block of our shader, remove the current property by deleting
    the following code from our current shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have removed an essential property, this shader will not compile until
    the other references to `_MainTex` are removed. Let''s remove this other line
    inside of the `SubShader` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The original shader used `_MainTex` to color the model. Let''s change this
    by replacing the first line of code of the `surf()` function with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just as you may be used to the `float` type being used for floating point values
    when writing code in C# and other programming languages, `fixed` is used for fixed-point
    values and is the type used when writing shaders. You may also see the `half`
    type used as well, which is like the `float` type but takes up half the space.
    This is useful for saving memory but is less precise in how it is presented. We
    will be discussing this in much greater detail in the *Techniques to make shaders
    more efficient* recipe in [Chapter 8](part0212.html#6A5N80-e8c76c858d514bc3b1668fda96f8fa08),
    *Mobile Shader Adjustment*.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on fixed-point values, check out [https://en.wikipedia.org/wiki/Fixed-point_arithmetic](https://en.wikipedia.org/wiki/Fixed-point_arithmetic).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `4`  in `fixed4` stands for the fact that the color is a single variable
    that contains four `fixed` values: red, green, blue, and alpha. You will learn
    more about how this works and how to modify these values in more detail in the
    next chapter, [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08), *Surface
    Shaders and Texture Mapping*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you save and return to Unity, the shader will compile, and you will see
    that now our material''s Inspector tab doesn''t have a texture swatch any more.
    To complete the refit of this shader, let''s add one more property to the `Properties`
    block and see what happens. Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added another color swatch to the material''s Inspector tab. Now let''s
    add one more in order to get a feel for other kinds of properties that we can
    create. Add the following code to the `Properties` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created another GUI element that allows us to visually interact
    with our shader. This time, we created a slider with the name This is a Slider,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Properties allow you to create a visual way to tweak shaders without having
    to change values in the shader code itself. The next recipe will show you how
    these properties can actually be used to create a more interesting shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While properties belong to shaders, the values associated with them are stored
    in materials. The same shader can be safely shared between many different materials.
    On the other hand, changing the property of a material will affect the look of
    all the objects that are currently using it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Unity shader has a built-in structure that it is looking for in its code.
    The Properties block is one of those functions that are expected by Unity. The
    reason behind this is to give you, the shader programmer, a means of quickly creating
    GUI elements that tie directly into your shader code. These properties (variables)
    that you declare in the Properties block can then be used in your shader code
    to change values, colors, and textures. The syntax to define a property is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at what is going on under the hood here. When you first
    start writing a new property, you will need to give it a **Variable Name**. The
    **Variable Name** is going to be the name that your shader code is going to use
    in order to get the value from the GUI element. This saves us a lot of time because
    we don''t have to set up this system ourselves. The next elements of a property
    are the **Inspector GUI Name** and **Type** of the property, which is contained
    within parentheses. The **Inspector GUI Name** is the name that is going to appear
    in the material''s Inspector tab when the user is interacting with and tweaking
    the shader. The **Type** is the type of data that this property is going to control.
    There are many types that we can define for properties inside of Unity shaders.
    The following table describes the types of variables that we can have in our shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Surface Shader property types** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Range` (min, max) | This creates a `float` property as a slider from the
    minimum value to the maximum value |'
  prefs: []
  type: TYPE_TB
- en: '| `Color` | This creates a color swatch in the Inspector tab that opens up
    a `color picker = (float,float,float,float)` |'
  prefs: []
  type: TYPE_TB
- en: '| `2D` | This creates a texture swatch that allows a user to drag a texture into
    the shader |'
  prefs: []
  type: TYPE_TB
- en: '| `Rect` | This creates a non-power of two texture swatch and functions the
    same as the `2D` GUI element |'
  prefs: []
  type: TYPE_TB
- en: '| Cube | This creates a cube map swatch in the Inspector tab and allows a user
    to drag and drop a cube map into the shader |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | This creates a float value in the Inspector tab but without a slider
    |'
  prefs: []
  type: TYPE_TB
- en: '| Vector | This creates a four-float property that allows you to create directions
    or colors |'
  prefs: []
  type: TYPE_TB
- en: Finally, there is the **Default Value**. This simply sets the value of this
    property to the value that you place in the code. So, in the previous example
    diagram, the default value for the property named `_AmbientColor`, which is of
    the `Color` type, is set to a value of `1, 1, 1, 1`. As this is a `Color` property
    expecting a color that is `RGBA` or `float4` or `r, g, b, a = x, y, z, w`, this
    `Color` property, when first created, is set to white.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The properties are documented in the Unity manual at [http://docs.unity3d.com/Documentation/Components/SL-Properties.html](http://docs.unity3d.com/Documentation/Components/SL-Properties.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using properties in a Surface Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created some properties, let's actually hook them up to the
    shader so that we can use them as tweaks to our shader and make the material process
    much more interactive. We can use the Properties values from the material's Inspector
    tab because we have attached a variable name to the property itself, but in the
    shader code, you have to set up a couple of things before you can start calling
    the value by its variable name.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps show you how to use the properties in a Surface Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from the previous example, let''s create another shader with the
    name `ParameterExample`. Just like before, remove the `_MainTex` property in the
    same manner as was done in the *Adding properties to a shader* recipe of this
    chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, update the `Properties` section to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following lines of code to the shader, below the `CGPROGRAM`
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With *step 3* complete, we can now use the values from the properties in our
    shader. Let''s do this by adding the value from the `_Color` property to the `_AmbientColor`
    property and giving the result of this to the `o.Albedo` line of code. So, let''s
    add the following code to the shader in the `surf()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, your shader should look like the following shader code. If you save
    your shader and re-enter Unity, your shader will compile. If there were no errors,
    you will now have the ability to change the ambient and emissive colors of the
    material as well as increase the saturation of the final color using the slider
    value. Pretty neat:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `pow(arg1, arg2)` function is a built-in function that will perform the
    equivalent `math` function of power. So, argument `1` is the value that we want
    to raise to a power and argument `2` is the power that we want to raise it to.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about the `pow()` function, look at the Cg tutorial. It is
    a great free resource that you can use to learn more about shading and there is
    a glossary of all the functions available to you in the Cg shading language at [http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the result obtained using our properties
    to control our material''s colors and saturation from within the material''s Inspector
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you declare a new property in the `Properties` block, you are providing
    a way for the shader to retrieve the tweaked value from the material's Inspector
    tab. This value is stored in the variable name portion of the property. In this
    case, `_AmbientColor`, `_Color`, and `_MySliderValue` are the variables in which
    we are storing the tweaked values.
  prefs: []
  type: TYPE_NORMAL
- en: In order for you to be able to use the value in the `SubShader` block, you need
    to create three new variables with the same names as the property's variable name.
    This automatically sets up a link between these two so that they know they have
    to work with the same data. Additionally, it declares the type of data that we
    want to store in our `SubShader` variables, which will come in handy when we look
    at optimizing shaders in a later chapter. Once you have created the `SubShader`
    variables, you can then use the values in the `surf()` function. In this case,
    we want to add the `_Color` and `_AmbientColor` variables together and take it
    to a power of whatever the `_MySliderValue` variable is equal to in the material's
    Inspector tab. The vast majority of shaders start out as Standard Shaders and
    get modified until they match the desired look. We have now created the foundation
    for any Surface Shader you will create that requires a diffuse component.
  prefs: []
  type: TYPE_NORMAL
- en: Materials are assets. This means that any change made to them while your game
    is running in the editor are permanent. If you have changed the value of a property
    by mistake, you can undo it using *Ctrl *+ *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any other programming language, Cg does not allow mistakes. As such, your
    shader will not work if you have a typo in your code. When this happens, your
    materials are rendered in unshaded magenta:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'When a script does not compile, Unity prevents your game from being exported
    or even executed. Conversely, errors in shaders do not stop your game from being
    executed. If one of your shaders appears as magenta, it is time to investigate
    where the problem is. If you select the incriminated shader, you will see a list
    of errors displayed in its Inspector tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Despite showing the line that raised the error, it rarely means that this is
    the line that has to be fixed. The error message shown in the previous screenshot
    is generated by deleting the `sampler2D _MainTex` variable from the `SubShader{}`
    block. However, the error is raised by the first line that tries to access such
    a variable. Finding and fixing what''s wrong with code is a process called **debugging**.
    The most common mistakes that you should check for are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A missing bracket. If you forgot to add a curly bracket to close a section,
    the compiler is likely to raise errors at the end of the document, at the beginning,
    or in a new section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A missing semicolon. One of the most common mistakes, but luckily one of the
    easiest to spot and fix. When looking at the Error definition, first check if
    the line above it has a semicolon or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property that has been defined in the `Properties` section but has not been
    coupled with a variable in the `SubShader{}` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compared to what you might be used to in C# scripts, the floating point values
    in Cg do not need to be followed by an `f`. It's `1.0`, not `1.0f`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error messages raised by shaders can be very misleading, especially due
    to their strict syntactic constraints. If you are in doubt about their meaning,
    it's best to search the internet. The Unity forums are filled with other developers
    who are likely to have encountered (and fixed) your problem before.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on how to master Surface Shaders and their properties can be
    found in [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08), *Surface
    Shaders and Texture Mapping*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are curious to see what shaders can actually do when used at their full
    potential, have a look at [Chapter 11](part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08),
    *Advanced Shading Techniques*, for some of the most advanced techniques covered
    in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
