- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronous and Asynchronous Data Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore various facets of data binding in Blazor. **Binding**
    is a cornerstone in modern web development. We’ll start with the fundamentals
    of binding values with DOM elements. Then, we will progress to binding specific
    DOM events, ensuring that your Blazor application is highly interactive and responsive.
    Most commercial applications will require integration with an external data provider.
    With that, you will have to perform asynchronous actions. We will explore how
    to pair them with bindings as well.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we’ll cover customizing getters and setters, allowing for greater data
    handling flexibility. We will also cover the **bind-Value** binding pattern, which
    should simplify most of your binding scenarios. Lastly, we will implement a commercial
    scenario of seamless binding with an external data provider. That comes in handy
    when implementing search modules or data persistence mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will fully skip building forms or using Blazor-native components
    that can simplify binding – we cover that in [*Chapter 6*](B22020_06.xhtml#_idTextAnchor203)
    , which covers *building* *interactive forms* .
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will gain a deep understanding of data binding
    in Blazor. It will enable you to build more dynamic and user-friendly web applications.
    All interactivity you’ll come to implement will come down to binding. You’ll have
    recipes at hand to handle those synchronous and asynchronous scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the list of recipes we’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Binding values with markup elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding to a specific DOM event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing asynchronous actions after binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing get and set binding logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying binding with the **bind-Value** pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding with an external data provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we will be exploring fundamental concepts of Blazor and web development,
    you won’t need any paid add-ons or additional tools. You will, however, need the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern IDE (of your choice)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser ( supporting **WebAssembly** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the code examples (and data samples) that you’ll see next can be found
    in a dedicated GitHub repository at :'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter0
    2](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: Binding values with markup elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we introduce the foundational concept of data binding in Blazor
    applications. This feature bridges the gap between the user interface and the
    application’s data or state. A deep understanding of this concept will allow you
    to level up the interactivity of your projects. We start with mastering the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s bind a simple text field to a backing variable to see the data flowing
    from the user interface to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you dive into binding, create a **Recipe01** directory – this will be
    your working directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to bind a C# value with a markup element:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a routable **IntroduceYourself** component that renders in an **InteractiveWebAssembly**
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **@code** block of **IntroduceYourself** , initialize a **User**
    variable to store the user input value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **IntroduceYourself** markup, add a call to action and an input field
    with a **@bind** attribute assigned to the **User** variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As part of the **IntroduceYourself** markup, construct a little logic to dynamically
    display a greeting once the user fills the input field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We kick off the recipe with a routine step in Blazor development – the creation
    of a new component. In *step 1* , we execute a routine step in Blazor development
    – we create a new **IntroduceYourself** component and declare its render mode.
    In our case, we opt for **InteractiveWebAssembly** . In *step 2* , we jump to
    the **@code** block of **IntroduceYourself** and initialize a **User** backing
    field – crucial for our data-binding operation.
  prefs: []
  type: TYPE_NORMAL
- en: The actual binding magic starts in *step 3* . We move to the **IntroduceYourself**
    markup and, next to a call to action, we embed an **input** element and leverage
    Blazor’s native **@bind** attribute for the first time. The **@bind** attribute
    enables a two-way data binding – not only assigning the input value to the **User**
    backing field but also ensuring that the UI is updated to reflect this change.
    In *step 4* , we add another section of the **IntroduceYourself** markup – we
    display the current **User** value when a user fills the input. That will help
    us to visualize the behavior of our binding.
  prefs: []
  type: TYPE_NORMAL
- en: The two-way binding, facilitated by the **@bind** attribute, simplifies the
    implementation of user interactivity. It is a go-to method for most simple binding
    cases, where you don’t need to execute additional logic. Notably, by default,
    this binding occurs when the user exits the input box, but that’s fully customizable.
    We will explore and clarify this behavior and its underlying mechanics in the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to a specific DOM event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will dive into targeted and efficient handling of user interactions
    in Blazor applications. While general data binding is crucial, binding specific
    actions to specific **DOM events** takes your application’s interactivity to the
    next level. This approach allows for a more controlled and responsive user experience.
    You can directly link an event, such as a click or a key press, to a corresponding
    C# method or action. You’ll learn how to identify and bind to these events and
    which events are bindable.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a simple text field but trigger binding as the user types, not
    when they exit the field, which is the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before exploring binding on a specific event, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Recipe02** directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy your **IntroduceYourself** component from the *Binding values with markup
    elements* recipe or copy its implementation from the **Chapter02** / **Recipe01**
    directory of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bind to a specific DOM event, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **@code** block in your **IntroduceYourself** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alongside the existing **User** variable, initialize a new **Greeting** variable.
    We will use it to hold a greeting for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the **IsGreetingReady** and **IsUserFilled** methods, which allow
    you to evaluate the state of the **User** and **Greeting** variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a **SayHello()** method that prepares a greeting message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **IntroduceYourself** markup, extend the input field binding by adding
    **@** **bind:event="oninput"** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend the input field binding further by attaching a **SayHello()** behavior
    to the **@** **onfocusout** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove any existing checks of the **User** value from the previous implementation
    and implement a conditional greeting rendering based on the state-checking methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’re enhancing the **IntroduceYourself** component to make
    it more interactive and engaging. Our goal is to enable the component to greet
    the user and display the progress of the user name input.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **IntroduceYourself** component, and in *step
    2* , we go straight to the **@code** block and initialize an additional **Greeting**
    variable to store the generated greeting message. That sets the stage for our
    dynamic user interaction. In *step 3* , we introduce **IsUserFilled** and **IsGreetingReady**
    parameterless methods that check the state of the **User** and **Greeting** variables
    and allow us to simplify the markup code and make our logic more readable. Moving
    on to *step 4* , we add another method – **SayHello()** . We will invoke **SayHello()**
    when the user finishes typing their name to generate a greeting and assign it
    to the **Greeting** variable. It adds a personalized touch to the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* is where we take control of the binding logic. You can trigger binding
    on any event applicable in script-based frameworks, such as **oncopy** , **onpaste**
    , or **onblur** . We chose the **oninput** event for this example. We override
    the default binding event with **@bind:event="oninput"** and enable **User** value
    live updates as the user types. Notice the lowercase syntax of the **@bind:event**
    attribute, as Razor is a case-sensitive language framework. In *step 6* , we take
    interactivity a step further. We use a native Blazor reference to the **@onfocusout**
    event and when the user navigates away from the input field, we invoke the **SayHello()**
    method, effectively generating the greeting message.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 7* , we implement a little rendering logic to ensure that
    the greeting is displayed only when the user has finished typing. Until then,
    the message **Introducing...** is generated. That way, we provide a clear indicator
    of UI interactivity and progress.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to know that Blazor allows you to intercept all event arguments.
    You can accomplish this by adding a parameter that matches the event argument
    type corresponding to the triggered event.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let’s consider **DragEventArgs** . When a user is dragging elements
    into or within your application, you can intercept cursor positions and any active
    keyboard combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how simple it is to intercept a dragging event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, with **InputFileChangeEventArgs** , you can access the details of
    the file that the user has uploaded. It also exposes the **IBrowserFile** object,
    which you can use to stream the content to your servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can intercept details of a file uploaded by a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The capability to intercept specific events and details of those actions opens
    possibilities for more advanced and nuanced event handling in your Blazor applications.
  prefs: []
  type: TYPE_NORMAL
- en: Performing asynchronous actions after binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous actions are pivotal in modern web applications, especially when
    dealing with data-intensive operations such as fetching data from an **API** or
    database. It’s also crucial that your application remains responsive as it’s executing
    a long-running task. In this recipe, I’ll guide you through data binding when
    working with asynchronous tasks. You will learn how to integrate asynchronous
    actions, allowing non-blocking UI updates and smoother user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enable an **auto-complete** feature on a simple input field and generate
    a list of suggestions as the user types their name.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the auto-complete implementation, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Recipe03** directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy your **IntroduceYourself** component from the *Binding to a specific DOM
    event* recipe or copy its implementation from the **Chapter02** / **Recipe02**
    directory of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to **Recipe03** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing the **SuggestionsApi** class required in this recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to trigger asynchronous actions after data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Program** file of your application and register the **SuggestionsApi**
    service to enable communication with the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **@code** block of the **IntroduceYourself** component and
    clean up the section, so only the **User** variable is still there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **@code** block, inject the **SuggestionsApi** service and initialize
    a **Suggestions** collection that will hold the autocomplete results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement a new asynchronous **AutocompleteAsync()**
    method responsible for calling the API and updating the **Suggestions** collection
    based on user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **IntroduceYourself** markup, find the **input** field and replace the
    **@onfocusout** assignment with the **@bind:after** attribute that triggers the
    **AutocompleteAsync()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below **input** , under the **<hr />** separator, clear out the existing greeting
    and introduction sections and construct a fast-return when suggestions are currently
    unavailable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, at the end of the **IntroduceYourself** markup, render the **Suggestions**
    collection received from the API response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1* , we add a **SuggestionsApi** service to the **dependency injection**
    container of our application. That makes **SuggestionsApi** readily available
    for injection across the application, ensuring we can utilize it wherever needed.
    Similar to other .NET web frameworks, Blazor can manage services with three lifetimes
    – singleton, scoped, and transient:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton** services are created once per application and shared across all
    components and requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transient** services are created anew each time they are requested, which
    makes them perfect for lightweight, stateless services (i.e. API integrations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped** services are a little trickier. In client-side applications, scoped
    services generally behave like singleton services because there is no connection
    context to differentiate sessions. However, that changes when an **OwningComponentBase**
    component comes into play. **OwningComponentBase** is a base class for components
    ensuring that the component and its dependencies are disposed of gracefully when
    Blazor destroys the component instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *step 2* , we move on to the **IntroduceYourself** component and clear out
    the greeting implementation, so only the **User** variable remains. In *step 3*
    , we inject **SuggestionsApi** into our **IntroduceYourself** component and initialize
    a **Suggestions** collection to store the results from calls we make to the API.
    Moving on to *step 4* , we implement the **AutocompleteAsync()** asynchronous
    method, playing a crucial role in simplifying the logic within the markup. **AutocompleteAsync()**
    checks whether the user has entered any input and calls the API’s **FindAsync()**
    method to fetch suggestions; otherwise, it short-circuits the operation, returning
    an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we enhance the markup of **IntroduceYourself** . We refine the
    binding logic on the input field, by removing the **@onfocusout** event and replacing
    it with the **@bind:after** directive, which invokes the **AutocompleteAsync()**
    method immediately after the binding completes. With this setup, we ensure that
    a new set of auto-suggestions is requested from the API each time the user modifies
    the input. Finally, in *step 6* and *step 7* , we introduce additional markup
    to display the results of the auto-complete operation. We render a list of found
    names, starting with the same set of characters that the user entered, if the
    API returns any.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, we utilized the **[Inject]** attribute to inject **SuggestionsApi**
    into a component. However, Blazor provides additional methods for service injection.
    Let’s review all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will commonly use the **[Inject]** attribute when injecting services within
    the **@code** block of a **.** **razor** file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You would also use the **[Inject]** attribute if you were adopting a code-behind
    approach, where you separate your Blazor component’s logic in a **.** **cs** file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When working in a code-behind fashion, you can also leverage a **constructor
    injection** pattern and avoid using any attributes at all:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, Blazor allows injecting services directly within the component’s markup
    – in that case, you would use the **@** **inject** directive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All those methods serve the same purpose but accommodate various coding styles
    and preferences. None is better than the other, so choose what best fits the structure
    and organization of your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing get and set binding logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data binding is not just about connecting a UI element to a data source. It’s
    also about how data is retrieved and updated. Customizing these **get** and **set**
    operations makes state management and data flow more flexible. In this recipe,
    I’ll guide you through the caveats of using **get** and **set** explicitly and
    executing asynchronous logic when setting values. These mechanisms will allow
    you to simplify your code and take even greater control of the interactivity of
    your Blazor application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a simple text field with explicit **get** and **set** operations
    so we can execute additional, asynchronous logic as binding is commencing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, we will take a shortcut with preparations for this upcoming recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Recipe04** directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy your **IntroduceYourself** component from the *Performing asynchronous
    actions after binding* recipe or copy its implementation from the **Chapter02**
    / **Recipe03** directory of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to **Recipe04** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing the objects required in this recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To customize **get** and **set** binding logic, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the **input** field within the **IntroduceYourself** component’s markup.
    Keep the **@bind:event** directive but replace others with custom **@bind:get**
    and **@** **bind:set** logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **@code** block of **IntroduceYourself** and adapt the **AutocompleteAsync()**
    method to align with a setter pattern, enforced by the **@** **bind:set** directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we update the binding logic on the **input** field. We keep the
    **oninput** event because we want our methods to execute as the user types but
    we replace the other directives with **@bind:get** and **@bind:set** . We use
    **@bind:get** to specify where Blazor should retrieve the input value from – which
    in our case is just a reference to the **User** variable. With the **@bind:set**
    directive, we define the logic to execute when Blazor binds the input value to
    the component’s state. That’s when we trigger the **AutocompleteAsync()** method.
    At this point, your IDE should highlight a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a **set** method in C# receives a **value** object by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In Blazor, the method used for **@bind:set** must follow a similar pattern.
    The difference is that we can define the name of the incoming **value** object,
    offering greater control and clarity. So, in *step 2* , we extend **AutocompleteAsync()**
    by adding a **value** parameter and keeping it in line with the conventional **get**
    - **set** pattern. Pay extra attention to the parameter type consistency. Since
    we bound **input** to the **User** object of type **string** , the **AutocompleteAsync()**
    method also expects a string. If, for instance, you were binding to an **Age**
    variable of type **int** , your binding method would need to accept an **int**
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So why do **@bind:after** and **@bind:set** both exist if they do virtually
    the same thing? The execution time of each event is critical. When you need to
    execute additional logic, often asynchronous, using the default binding operation,
    **@bind:after** , should be your choice as it spares you the complexity of persisting
    the incoming value manually. On the other hand, **@bind:set** provides more flexibility
    as it’s executed upon setting the binding value. It enables the integration of
    validation logic, including asynchronous operations, into the binding process.
    Crucially, **@bind:set** allows you to assess the incoming value and, based on
    the outcome of any validation, decide whether to discard or accept it before it
    becomes part of the component state. Both features are invaluable for ensuring
    data integrity and implementing sophisticated validation mechanisms in your Blazor
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying binding with the bind-Value pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **bind-Value** pattern is a game-changer in simplifying the linking process
    of your UI elements to data properties. It enhances the clarity and conciseness
    of your code by reducing the boilerplate often associated with handling two-way
    data binding. In this recipe, I will guide you through a practical example, showcasing
    the pattern’s utility in creating more maintainable and simple code, ultimately
    enhancing your development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a component that allows binding directly to its parameters in
    a structure similar to the standard binding to HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start implementing a component that enables the **bind-Value** pattern,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Recipe05** directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to **Recipe05** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing **SkillLevel** and **DataSeed** , required in this
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to apply the **bind-Value** binding pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **IntroductionForm** component and add the required assembly reference
    at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block of **IntroductionForm** , declare a **string** parameter
    for **Name** . Alongside it, add **EventCallback<string>** to communicate changes
    to the **Name** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, right below **Name** and **NameChanged** , add a **Skill** and an
    **EventCallback<SkillLevel>** parameters to manage the skill level state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement a method invoking the **NameChanged**
    callback and propagating changes to the **Name** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, complete the **@code** block with another method, handling changes
    of the **Skill** value, that retrieves the **ChangeEventArgs** parameter and sets
    the skill level based on the resolved value and underlying **DataSeed.SkillLevels**
    data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **IntroductionForm** markup, below **@using** , add a section where
    the user can input their name. Declare the binding to occur on the **oninput**
    event and set it to trigger the **OnNameChanged** method after the binding is
    complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another markup section below allowing you to select the user’s skill level.
    Utilize the **DataSeed.SkillLevels** data source to populate the selection options
    and ensure that the binding of selection changes occurs with the **onchange**
    event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **IntroduceYourself** routable component, rendering in an **InteractiveWebAssembly**
    mode, and reference the data objects assembly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block, initialize **Name** and **Skill** variables to capture
    the user input and generate the greeting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement an **IsGreetingReady** method,
    allowing you to check whether the greeting is ready to render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **IntroduceYourself** markup, embed **IntroductionForm** and leverage
    the **bind-Value** pattern to dynamically bind the **Name** and **Skill** parameters
    to the corresponding target variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **IntroduceYourself** markup by adding a section separator and
    conditional rendering of the user greeting, when it’s ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create an **IntroductionForm** component and reference the
    assembly with sample data at the top. In *step 2* , we define a pair of parameters
    of type **string** and **EventCallback<string>** , that we will bind to the form,
    and we intentionally call them **Name** and **NameChanged** respectively. In *step
    3* , we add a similar pair to handle the skill level and name them **Skill** and
    **SkillChanged** respectively. The pairing of a value of type **T** and a matching
    **EventCallback<T>** handler forms the basis of the **bind-Value** pattern. Similar
    to recognizing **ChildContent** implicitly, when working with **RenderFragment**
    , Blazor’s code generators recognize **T** and **EventCallback<T>** and compile
    the **@bind-Value** directive. In *step 4* , we declare an **OnNameChanged()**
    method to invoke the intended **EventCallback** and propagate the changes in **Name**
    . To handle value changes of the **Skill** parameter, we implement a bit more
    complex logic in *step 5* . We intercept a **ChangeEventArgs** object that carries
    the selected option’s value, which we use to retrieve the corresponding **SkillLevel**
    object from the **DataSeed.SkillLevels** collection. We then pass this value to
    the intended **EventCallback** handler.
  prefs: []
  type: TYPE_NORMAL
- en: With the logic in place, in *step 6* , we proceed to the **IntroductionForm**
    markup. We add a simple **input** field and bind it to the **Name** parameter.
    We also hook up the **OnNameChanged()** method, so it’s triggered after the binding
    completes. In *step 7* , we construct a **select** field to allow the user to
    choose their skill level. We render a neutral option, displaying **-** , and skill
    options from the **DataSeed.SkillLevels** collection. We wire the **@onchanged**
    event of the **select** field to the **OnSkillChanged()** method.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* , we create a routable **IntroduceYourself** component that renders
    in an **InteractiveWebAssembly** mode. We also reference the sample data assembly,
    leveraging the **@using** directive. In *step 9* , we initialize a **@code** block
    within the **IntroduceYourself** component and declare **Name** and **Skill**
    backing properties for binding and generating the user’s greeting. In *step 10*
    , we implement a simple **IsGreetingReady** method that checks whether both **Name**
    and **Skill** have meaningful values and a greeting can be safely generated.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11* , we jump to the **IntroduceYourself** markup and witness the **bind-Value**
    pattern in action. Since **IntroductionForm** exposes **Name** and **Skill** parameters
    with pattern-matching event callbacks, we can dynamically bind them using **@bind-Name**
    and **@bind-Skill** . Your IDE will recognize this pattern automatically and should
    even suggest these directives. We finalize the markup in *step 12* by adding a
    conditional rendering of a greeting message built from the current **Name** and
    **Skill** values.
  prefs: []
  type: TYPE_NORMAL
- en: The **bind-Value** pattern encapsulates binding logic and validation within
    a component, greatly simplifying unit testing and enhancing the parent component’s
    cleanliness and robustness. It only requires the parent component to provide backing
    variables, streamlining the development process. It’s even more powerful as all
    the binding directives that we’ve covered ( **@bind:after** , **@bind:get** ,
    **@bind:set** ), you can also pair with the **bind-Value** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Binding with an external data provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building web applications that interact with external data sources, it’s
    common to trigger API calls in response to user input. However, this can lead
    to a flood of requests, straining the API and degrading the user’s experience.
    To address that challenge, we’ll implement input **throttling** – a technique
    that moderates the rate at which requests are sent based on user input. In this
    recipe, I will guide you through setting up input throttling in a Blazor component,
    ensuring efficient and responsible usage of external APIs. You’ll create more
    robust and user-friendly applications capable of handling a heavy load of user
    interactions without overwhelming your data providers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a simple text field that uses throttling to limit calls to the
    external API and seamlessly waits for a user to finish typing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you dive into throttling implementation, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Recipe06** directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to **Recipe06** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing a **SuggestionsApi** class required in this recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **IntroduceYourself** component from the **Chapter02** / **Recipe03**
    directory of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement throttling when calling an external API, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Program** file of your application and register the **SuggestionsApi**
    service to enable communication with the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enhance the **IntroduceYourself** component with the implementation of the
    **IDisposable** interface using the **@implements** directive, below the **@**
    **rendermode** directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **@code** block of the **IntroduceYourself** component, declare
    the **Timer** variable and two **TimeSpan** variables – for throttling and overall
    timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement an **OnUserInput()** method with
    a proxy logic that uses the **Timer** and **TimeSpan** variables to throttle the
    API requests encapsulated inside the **AutocompleteAsync()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the **@code** block, implement the **Dispose()** lifecycle method,
    required by the **IDisposable** interface, and explicitly dispose of the **_debounceTimer**
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **IntroduceYourself** markup, update the **@bind:after** directive to
    invoke the **OnUserInput()** method, where we’ve added the throttling logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we register the **SuggestionsApi** service in the application’s
    dependency injection container. If you’re following along with the entire chapter,
    you might already have **SuggestionsApi** there.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , with the help of the **@implements** directive, we enhance the
    **IntroduceYourself** component with an **IDisposable** pattern. In Blazor, the
    **IDisposable** interface is used to release unmanaged resources or detach event
    handlers when disposing of a component. **IDisposable** requires the implementation
    of a **Dispose()** method, which Blazor will then automatically invoke when a
    component is removed from the UI, ensuring proper cleanup and preventing memory
    leaks. Without the **Dispose()** method in place, your IDE will highlight compilation
    errors. We will address that in subsequent steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 3* , we lay the groundwork for throttling logic. In the **@code**
    block of the **IntroduceYourself** component, we initialize two key variables:
    **_throttle** , which defines the idle time (500 milliseconds in our example)
    between user interactions and API calls, and **_timeout** , which sets an overall
    timeout for the external communication. We also declare a **_debounceTimer** variable
    of type **Timer** , which is the backbone of managing the frequency of API calls.
    The **Timer** class wraps a scheduler that delays the execution of a method for
    a specified time, making it ideal for throttling. In *step 4* , still within the
    **@code** block, we implement an **OnUserInput()** method with throttling proxy
    logic. First, we stop the currently scheduled operation, by disposing of the **_debounceTimer**
    instance, to avoid any overlapping executions. Next, we instantiate a new **Timer**
    object, wrapping the existing **AutocompleteAsync()** method within the **InvokeAsync()**
    method for thread safety. As we don’t need to maintain any state between timer
    invocations, we pass **null** for the state object and complete the **_debounceTimer**
    initialization with the **_throttle** and **_timeout** variables. In *step 5*
    , we complete the **@code** block by implementing the missing **Dispose()** method
    to gracefully dispose of the **_debounceTimer** instance. The compilation errors
    should now be gone.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in *step 6* , we slightly update the **input** field in the **IntroduceYourself**
    markup. Rather than invoking **AutocompleteAsync()** after the binding completes,
    we update the **@bind:after** attribute to invoke the **OnUserInput()** method,
    containing our throttling logic. Now, every keystroke goes through the throttling
    mechanism, optimizing application responsiveness and reducing the load on the
    external API.
  prefs: []
  type: TYPE_NORMAL
