["```cs\nusing UnityEngine.EventSystems; \n\n```", "```cs\npublic abstract class TradeCupcakeTowers : MonoBehaviour,\n  IPointerClickHandler { \n\n```", "```cs\n*// Variable to store the Sugar Meter* \nprotected static SugarMeterScript sugarMeter; \n\n```", "```cs\nvoid Start () { \n  *//If the reference to the Sugar Meter is missing, the script gets it* \n  if (sugarMeter == null) { \n    sugarMeter = FindObjectOfType<SugarMeterScript>(); \n  }      \n} \n\n```", "```cs\n*//Variable to store the current selected tower by the player* \nprotected static CupcakeTowerScript currentActiveTower; \n\n```", "```cs\n*// Static function that allows other scripts to assign the new/current\n  selected tower* \npublic static void setActiveTower(CupcakeTowerScript cupcakeTower) { \n  currentActiveTower = cupcakeTower; \n} \n\n```", "```cs\n*// Abstract function triggered when one of the trading buttons is\n  pressed, however the \n// implementation is specific for each trade operation.* \npublic abstract void OnPointerClick(PointerEventData eventData); \n\n```", "```cs\n*// How much this tower costs when it is bought    * \npublic int initialCost; \n\n*// How much this tower costs when it is upgraded* \npublic int upgradingCost; \n\n*// How much this tower is valuable if sold* \npublic int sellingValue; \n\n```", "```cs\n*//Increase the value of the tower;* \nsellingValue += 5; \n\n//Increase the upgrading cost \nupgradingCost += 10; \n\n```", "```cs\nusing UnityEngine.EventSystems; \n\n```", "```cs\npublic class TradeCupcakeTowers_Buying : TradeCupcakeTowers { \n\n```", "```cs\n*/* Public variable to identify which tower this script is selling. \n * Ideally, you could have many instances of this script selling\n   different \n * Cupcake towers, and the tower is specified in the Inspector */* \npublic GameObject cupcakeTowerPrefab; \n\n```", "```cs\npublic override void OnPointerClick(PointerEventData eventData) { \n * //Rest of the code* \n} \n\n```", "```cs\n*//Retrieve from the prefab which is its initial cost* \nint price = cupcakeTowerPrefab.GetComponent<CupcakeTowerScript\n  ().initialCost; \n\n```", "```cs\n*// Check if the player can afford to buy the tower* \nif (price <= sugarMeter.getSugarAmount()) { \n * //Payment succeeds, and the cost is removed from the player's sugar* \n  sugarMeter.ChangeSugar(-price); \n * //A new cupcake tower is created* \n  GameObject newTower = Instantiate(cupcakeTowerPrefab); \n * //The new cupcake tower is also assigned as the current selection* \n  currentActiveTower = newTower.GetComponent<CupcakeTowerScript>(); \n} \n\n```", "```cs\nusing UnityEngine.EventSystems; \n\n```", "```cs\npublic class TradeCupcakeTowers_Selling : TradeCupcakeTowers { \n\n```", "```cs\npublic override void OnPointerClick(PointerEventData eventData) { \n  *//Rest of code* \n} \n\n```", "```cs\n*//Check if there is a tower selected before to proceed* \nif (currentActiveTower == null) \n  return; \n\n*//Add to the player's sugar the value of the tower* \nsugarMeter.ChangeSugar(currentActiveTower.sellingValue); \n*//Remove the cupcake tower from the scene* \nDestroy(currentActiveTower); \n\n```", "```cs\nusing UnityEngine.EventSystems; \n\n```", "```cs\npublic class TradeCupcakeTowers_Upgrading : TradeCupcakeTowers { \n\n```", "```cs\npublic override void OnPointerClick(PointerEventData eventData) { \n * //Rest of the code* \n} \n\n```", "```cs\n*//Check if the player can afford to upgrade the tower* \nif(currentActiveTower.isUpgradable && currentActiveTower.upgradingCost\n  <=sugarMeter.getSugarAmount()) { \n * //The payment is executed and the sugar removed from the player* \n  sugarMeter.ChangeSugar(-currentActiveTower.upgradingCost); \n *//The tower is upgraded* \n  currentActiveTower.Upgrade(); \n} \n\n```", "```cs\n*//Private variable to check if the mouse is hovering an area where* \n*//Cupcake tower can be placed* \nprivate bool _isPointerOnAllowedArea = true; \n\n```", "```cs\n*//Function that returns true if the mouse is hovering an area where a \n//Cupcake tower can be placed* \npublic bool isPointerOnAllowedArea() { \n  return _isPointerOnAllowedArea; \n} \n\n```", "```cs\n*//Function which is called when the mouse enters in one of the \n//colliders of the Game Manager* \nvoid OnMouseEnter() { \n  *//Set that the mouse is now hovering an area where placing Cupcake \n  //towers is allowed* \n  _isPointerOnAllowedArea = true; \n} \n\n*//Function which is called when the mouse exits from one of the \n//colliders of the Game Manager* \nvoid OnMouseExit() { \n * //Set that the mouse is not hovering anymore an area where placing \n  //Cupcake towers is allowed* \n  _isPointerOnAllowedArea = false; \n} \n\n```", "```cs\n*// Private variable to store the reference to the Game Manager* \nprivate GameManagerScript gameManager; \n\nvoid Start () { \n * //Get the reference to the Game Manager* \n  gameManager = FindObjectOfType<GameManagerScript>(); \n} \n\n```", "```cs\nvoid Update () { \n  *//Get the mouse position* \n  float x = Input.mousePosition.x; \n  float y = Input.mousePosition.y; \n\n  */* Place the cupcake Tower where the mouse is, transformed in game\n    coordinates \n   * from the Main Camera. Since the Camera is placed at -10 and we\n     want the \n   * tower to be at -3, we need to use 7 as z-axis coordinate */* \n  transform.position = Camera.main.ScreenToWorldPoint(new Vector3(x,\n     y, 7)); \n\n  *//If the player clicks, the second condition checks if the current\n    position is \n  //within an area where cupcake towers can be placed* \n  if (Input.GetMouseButtonDown(0) &&\n    gameManager.isPointerOnAllowedArea()) { \n * //Enabling again the main cupcake tower script, so to make it\n    operative* \n  GetComponent<CupcakeTowerScript>().enabled = true; \n * //Place a collider on the Cupcake tower* \n  gameObject.AddComponent<BoxCollider2D>(); \n  *//Remove this script, so to not keeping the Cupcake Tower on the\n    mouse* \n  Destroy(this); \n} \n\n```", "```cs\n*//Function called when the player clicks on the cupcake Tower* \nvoid OnMouseDown() { \n * //Assign this tower as the active tower for trading operations* \n  TradeCupcakeTowers.setActiveTower(this); \n} \n\n```", "```cs\n*//Variable to store the the screen displayed when the player loses* \npublic GameObject losingScreen; \n\n*//Variable to store the screen displayed when the player wins* \npublic GameObject winningScreen; \n\n```", "```cs\n*//Private function called when some gameover conditions are met, and\n  displays\n//the winning or losing screen depending from the value of the\n  parameter passed.* \nprivate void GameOver(bool playerHasWon) { \n  *//Check if the player has won from the parameter* \n  if (playerHasWon) { \n    *//Display the winning screen* \n    winningScreen.SetActive(true); \n  }else { \n    *//Display the losing screen* \n    losingScreen.SetActive(true); \n  } \n\n  *//Freeze the game time, so to stop in some way the level to be\n    executed* \n  Time.timeScale = 0; \n} \n\n```", "```cs\n*//Private variable to store the reference to the Player's health* \nprivate HealthBarScript playerHealth; \n\n```", "```cs\nvoid Start () { \n *//Get the reference to the Player's health* \n  playerHealth = FindObjectOfType<HealthBarScript>(); \n} \n\n```", "```cs\n*//Private variable which acts as a counter of how many Pandas are\n  remained to defeat* \nprivate int numberOfPandasToDefeat; \n\n```", "```cs\n*//Function that decreases the number of Pandas still to defeat every\n  time a Panda dies * \npublic void OneMorePandaInHeaven() { \n  numberOfPandasToDefeat--; \n} \n\n```", "```cs\n*//Function that damages the player when a Panda reaches the player's\n  cake. \n//Moreover, it monitors the player's health to trigger the GameOver\n  function when needed* \npublic void BiteTheCake(int damage) { \n * //Apply damage to the player and retrieve a Boolean to see if the\n    cake has been eaten all* \n  bool IsCakeAllEaten = playerHealth.ApplyDamage(damage); \n * //If the cake has been eaten all, the GameOver function is called in\n    \"losing mode\"* \n  if (IsCakeAllEaten) { \n    GameOver(false); \n  } \n  *//The Panda that bit the cake will also explode, and therefore we\n    have a Panda less to defeat* \n  OneMorePandaInHeaven(); \n} \n\n```", "```cs\n*//The amount of cake that the Panda eats* \npublic int cakeEatenPerBite; \n\n```", "```cs\nvoid FixedUpdate() { \n  *//if the Panda has reached the cake, then it will eat it, by\n    triggering the right animation, \n  //and remove this script, since the State Machine Behaviour will take\n    care of removing the Panda* \n  if (currentWaypointNumber == gameManager.waypoints.Length) { \n    animator.SetTrigger(AnimEatTriggerHash); \n    gameManager.BiteTheCake(cakeEatenPerBite); \n    Destroy(this); \n    return; \n  } \n * // [...] The remaining code of the function*\n\n```", "```cs\nprivate void Hit(float damage) { \n * //Subtract the damage to the health of the Panda* \n  health -= damage; \n * //Then it triggers the Die or the Hit animations based if the Panda\n    is still alive* \n  if(health <= 0) { \n    animator.SetTrigger(AnimDieTriggerHash); \n    gameManager.OneMorePandaInHeaven(); \n  } \n  else { \n    animator.SetTrigger(AnimHitTriggerHash); \n  } \n} \n\n```", "```cs\n*//The Spawning Point transform so to get where the Pandas should be\n  spawned* \nprivate Transform spawner; \n\n```", "```cs\nvoid Start () {\n  *//Get the reference to the Player's health*\n  playerHealth = FindObjectOfType<HealthBarScript>();\n\n *//Get the reference to the Spawner*\n  spawner = GameObject.Find(\"Spawning Spot\").transform;\n}\n```", "```cs\n*//The Panda Prefab that should be spawned as enemy*\npublic GameObject pandaPrefab;\n\n*//The number of waves that the player has to face in this level*\npublic int numberOfWaves;\n\n*//The number of Pandas that the player as to face per wave.\n//It increase when a wave is won.*\npublic int numberOfPandasPerWave;\n```", "```cs\n*//Coroutine that spawns the different waves of Pandas* \nprivate IEnumerator WavesSpawner() { \n * //For each wave* \n  for(int i = 0; i < numberOfWaves; i++) { \n    *//Let the PandaSpawner coroutine to handle the single wave. When it\n      finishes \n    //also the wave is finished, and so this coroutine can continue.* \n    yield return PandaSpawner(); \n    *//Increase the number of Pandas that are generated per wave* \n    numberOfPandasPerWave += 3; \n  } \n * //If the Player won all the waves, call the GameOver function in\n    \"winning\" mode* \n  GameOver(true); \n} \n\n```", "```cs\n*//Coroutine that spawns the Pandas for a single wave, and waits until\n  \"all the Pandas are in Heaven\"* \nprivate IEnumerator PandaSpawner() { \n  *//Rest of the code* \n} \n\n```", "```cs\n*//Initialize the number that needs to be defeated for this wave* \nnumberOfPandasToDefeat = numberOfPandasPerWave; \n\n```", "```cs\n*//Progressively spawn Pandas* \nfor(int i=0; i < numberOfPandasPerWave; i++) {\n  *//Rest of the code inside the cycle* \n} \n*//Rest of the code outside the cycle*\n\n```", "```cs\n*//Spawn/Instantiate a Panda at the Spawner position* \nInstantiate(pandaPrefab, spawner.position, Quaternion.identity);\n\n*//Wait a time that depends both on how many Pandas are left to be \n//spawned and by a random number* \nfloat ratio = (i * 1f) / (numberOfPandasPerWave - 1); \nfloat timeToWait = Mathf.Lerp(3f, 5f, ratio) + Random.Range(0f, 2f); \nyield return new WaitForSeconds(timeToWait); \n\n```", "```cs\n*//Once all the Pandas are spawned, wait until all of them are defeated \n//by the player (or a gameover condition occurred before)* \nyield return new WaitUntil(() => numberOfPandasToDefeat <= 0); \n\n```", "```cs\nusing UnityEngine.SceneManagement; \n\n```", "```cs\n*//Function that loads the first level* \npublic void NewGame() { \n  SceneManager.LoadScene(1); \n} \n\n```", "```cs\n*//Function that displays the settings* \npublic void Settings() { \n * //Your own code here* \n} \n\n```", "```cs\n*//Function that closes the game* \npublic void Quit() { \n  Application.Quit(); \n} \n\n```"]