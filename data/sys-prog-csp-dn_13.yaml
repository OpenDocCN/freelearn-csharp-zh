- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: The One with the Deployment Dramas
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署戏剧篇
- en: '*Deployment* *and Distribution*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署* *和分发*'
- en: 'Allow me to make a confession: I love writing code. The whole process that
    starts with a vague idea, followed by writing the first lines of code, then finding
    issues and debugging the code, gives me a thrill. There is something magical about
    creating something out of thin air and seeing it come to life before my eyes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我坦白一下：我喜欢编写代码。从模糊的想法开始，然后编写第一行代码，接着发现问题和调试代码，这个过程让我感到兴奋。从无到有创造东西，并亲眼看到它在我眼前变得生动，这有一种神奇的感觉。
- en: 'But there comes a moment when the software is “good enough” and it needs to
    move into production. After all, we write software with a purpose: it needs to
    be used. And that usually means moving it away from your development machine to
    a production environment.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但总有那么一刻，软件变得“足够好”，需要进入生产环境。毕竟，我们编写软件是有目的的：它需要被使用。这通常意味着将软件从你的开发机器转移到生产环境中。
- en: 'There are many challenges in this process. But don’t worry: we will tackle
    all of them! We will discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中有许多挑战。但不用担心：我们将一一解决它们！我们将讨论以下主题：
- en: What does deployment mean?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署是什么意思？
- en: How do you use the Publish wizard from Visual Studio?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Visual Studio 中的发布向导？
- en: What is CI/CD, and how do I use it in Azure DevOps or GitHub?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD 是什么，我如何在 Azure DevOps 或 GitHub 中使用它？
- en: How do I build an installer?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何构建安装程序？
- en: How do I deploy with Docker?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何使用 Docker 进行部署？
- en: So, if you are ready to let the world see the fruits of your labor but are unsure
    how to get that out there, this is the chapter for you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你准备好让世界看到你劳动的成果，但又不确定如何将其推广出去，那么这一章就是为你准备的。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code in this chapter in our repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的仓库中找到本章的所有代码：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13)。
- en: If you want to follow along with the CI/CD samples in Azure, you’ll need an
    Azure subscription. You can sign up for a free trial for Azure at [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟随 Azure 中的 CI/CD 示例，你需要一个 Azure 订阅。你可以在以下链接注册 Azure 的免费试用：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: 'To have a go with GitHub Actions, you’ll need to sign up for a GitHub account.
    You can get a free one here: [https://github.com/signup](https://github.com/signup).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 GitHub Actions，你需要注册一个 GitHub 账户。你可以在以下链接免费注册：[https://github.com/signup](https://github.com/signup)。
- en: If you want to follow along when we talk about the setup projects, you must
    install **Visual Studio Extension Microsoft Visual Studio Installer Projects 2022**.
    You can find this by going to the **Extensions** menu item and choosing **Manage
    extensions**. From there, in the **Online** tab, search for that extension.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在我们讨论设置项目时跟随，你必须安装**Visual Studio 扩展 Microsoft Visual Studio Installer Projects
    2022**。你可以在**扩展**菜单项中选择**管理扩展**来找到它。从那里，在**在线**选项卡中搜索该扩展。
- en: With this tool, you can follow along and build your own installers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工具，你可以跟随步骤并构建自己的安装程序。
- en: 'If you want to work with the Docker sample, install Docker Desktop. You can
    find it here: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用 Docker 示例，请安装 Docker Desktop。你可以在以下链接找到它：[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)。
- en: All the software mentioned here is free or has a free trial.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的所有软件都是免费的或提供免费试用。
- en: From development to production
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从开发到生产
- en: There will come a moment when you’re developing your application when you decide
    it is time for other people to try out the fruits of your labor. This means moving
    your application from your development machine to another environment. This could
    be another developer’s machine or a production system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序的过程中，总会有那么一刻，你决定是时候让其他人尝试你劳动的成果了。这意味着将你的应用程序从你的开发机器转移到另一个环境。这可能是一个开发者的机器或是一个生产系统。
- en: Depending on the complexity of your system, moving the bits away could involve
    anything from a simple file copy to building a complex installer application.
    You also have to think about ways to remove your application from their system
    and about ways to update or upgrade your application. All these tasks are gathered
    under the term *deployment*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您系统的复杂性，将位移动开可能涉及从简单的文件复制到构建复杂的安装程序应用程序的任何事情。您还必须考虑从他们的系统中删除您的应用程序的方法以及更新或升级您应用程序的方法。所有这些任务都汇集在术语
    *部署* 之下。
- en: Deployment should be as seamless as possible. The users should be able to take
    your application and prepare it for use effortlessly. This means all the hard
    work lies with us.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应尽可能无缝。用户应该能够轻松地将您的应用程序准备好使用。这意味着所有艰苦的工作都由我们来承担。
- en: 'Creating a deployment scenario involves thinking about the following aspects:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建部署场景需要考虑以下方面：
- en: Copying your binaries
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制您的二进制文件
- en: Copying the binaries your system depends on
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制您的系统依赖的二进制文件
- en: Copying additional files
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制附加文件
- en: Setting user rights
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用户权限
- en: Copying settings and altering them
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制设置并修改它们
- en: Creating and copying secrets
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和复制密钥
- en: Altering system settings such as paths
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改系统设置，如路径
- en: Registering your application in the host environment
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在宿主环境中注册您的应用程序
- en: 'Uninstalling your applications means reversing this process: in an ideal world,
    an uninstall leaves no trace of your application and the associated files on the
    host machine.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载您的应用程序意味着逆转此过程：在理想世界中，卸载不会在宿主机器上留下您的应用程序和相关文件的痕迹。
- en: 'Upgrading and updating is a mix of these scenarios: deploying new code, changing
    settings, and removing things you no longer need in the latest version.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 升级和更新是这些场景的混合：部署新代码、更改设置以及从最新版本中删除不再需要的项目。
- en: 'If all you have is a simple, standalone console application, deployment is
    a breeze: just copy the files needed. Suppose you’re deploying a complex system,
    such as a background worker; this needs configuration settings to connect to external
    systems. In that case, you have a lot more work to do. But there is good news:
    for each of those and other scenarios, there are strategies to follow. And that
    is what the rest of this chapter is all about. So, do a final build of your app,
    do a quick local test, and let’s deploy our work!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只有一个简单的独立控制台应用程序，部署将变得非常简单：只需复制所需的文件。假设您正在部署一个复杂的系统，例如后台工作者；这需要配置设置以连接到外部系统。在这种情况下，您有更多的工作要做。但有好消息：对于这些和其他场景，都有可遵循的策略。这正是本章剩余部分的内容。因此，进行最终构建您的应用程序，进行快速本地测试，然后让我们部署我们的工作！
- en: Publishing and file copy
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布和文件复制
- en: The easiest way to deploy an application is to use Visual Studio’s Publish mechanism.
    Let’s assume I have a simple console application. I don’t have any configuration
    settings that I need to change when running on a production environment. So, I
    can just copy what I have.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序最简单的方法是使用 Visual Studio 的发布机制。假设我有一个简单的控制台应用程序。我没有在运行生产环境时需要更改的任何配置设置。因此，我只需复制我所拥有的。
- en: 'Let’s assume we have a simple console application. You’ve tested it, and you’re
    ready to deliver. There are two options: use **Visual Studio** or use the **CLI**.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的控制台应用程序。您已经测试了它，并准备交付。有两种选择：使用 **Visual Studio** 或使用 **CLI**。
- en: Publish using Visual Studio
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 发布
- en: 'In Visual Studio, in the **Solution Explorer** area, right-click on your project
    and select **Publish**. You’ll see the following dialog:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，在 **解决方案资源管理器** 区域中，右键单击您的项目并选择 **发布**。您将看到以下对话框：
- en: '![Figure 13.1: Publishing via Visual Studio](img/B20924_14_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：通过 Visual Studio 发布](img/B20924_14_01.jpg)'
- en: 'Figure 13.1: Publishing via Visual Studio'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：通过 Visual Studio 发布
- en: 'There are a couple of options to choose from:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个选项可供选择：
- en: '**Azure**: This means deploying your system to Azure so that it runs there.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure**：这意味着将您的系统部署到 Azure，以便在那里运行。'
- en: '**ClickOnce**: ClickOnce is a technique for building a simple installer. Updates
    and uninstallation are part of the mechanism. However, ClickOnce is meant for
    Windows applications that the users start. Therefore, this is not a solution for
    us system programmers. For that reason, I will not cover ClickOnce here.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClickOnce**：ClickOnce 是构建简单安装程序的技术。更新和卸载是机制的一部分。然而，ClickOnce 是为用户启动的 Windows
    应用程序设计的。因此，这不是我们系统程序员的解决方案。因此，我将在此处不涉及 ClickOnce。'
- en: '**Docker Container Registry**: This is a great way to package and deploy systems.
    We will discuss this later.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker容器注册库**：这是一种打包和部署系统的绝佳方式。我们将在稍后讨论这一点。'
- en: '**Folder**: This is the simplest way to publish as it just copies all files
    needed to a folder.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件夹**：这是发布的最简单方式，因为它只是将所有必要的文件复制到一个文件夹中。'
- en: '**Import Profile**: If you’ve already defined deployment methods, you can use
    those settings here by importing them.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入配置文件**：如果您已经定义了部署方法，您可以通过导入它们来使用这些设置。'
- en: In this case, we’ll choose **Folder**. Upon doing so, you’ll get a new dialog
    asking if you want to use **ClickOnce** for the folder deployment or whether you
    wish to deploy to the filesystem. Choose **Folder** to pick the latter. At this
    point, you can enter the path to which you want to publish. For now, leave it
    as the default setting. Click **Finish**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们将选择**文件夹**。这样做之后，您将得到一个新的对话框，询问您是否希望使用**ClickOnce**进行文件夹部署，或者是否希望部署到文件系统。选择**文件夹**以选择后者。此时，您可以输入您想要发布的路径。目前，请将其保留为默认设置。点击**完成**。
- en: Although you clicked `FolderProfile.pubxml`, and you can find it in the **Solution
    Explorer** area in your project under **Properties** > **PublishProfiles**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您点击了`FolderProfile.pubxml`，并且您可以在项目的**解决方案资源管理器**区域下的**属性** > **发布配置文件**中找到它。
- en: 'Visual Studio will open the profile and show you what it looks like. From here,
    we can click the big **Publish** button; however, we might want to tweak the profile
    before doing that. Click **More Actions** and choose **Edit**. This results in
    the following dialog:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio将打开配置文件并显示其外观。从这里，我们可以点击大的**发布**按钮；然而，我们可能想在这样做之前调整配置文件。点击**更多操作**并选择**编辑**。这将导致以下对话框：
- en: '![Figure 13.2: The Profile settings dialog](img/B20924_14_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2：配置设置对话框](img/B20924_14_02.jpg)'
- en: 'Figure 13.2: The Profile settings dialog'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：配置设置对话框
- en: 'You can tweak the profile a lot here. Let’s walk through the options:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里大量调整配置文件。让我们看看选项：
- en: '**Configuration**: You can choose any configuration you might have defined
    in your project. By default, these are the **Debug** and **Release** configurations.
    I suggest that you use **Release** for deployments.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：您可以选择在项目中定义的任何配置。默认情况下，这些是**调试**和**发布**配置。我建议您使用**发布**进行部署。'
- en: '**Target framework**: Here, you can choose any compatible and installed framework
    you want for your application. Just leave this set to what you used when you were
    building your system.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标框架**：在这里，您可以为您的应用程序选择任何兼容和已安装的框架。只需将其设置为构建系统时使用的设置即可。'
- en: '**Deployment mode**: Here, you can choose between **Framework-dependent** and
    **Self-contained**. If you pick **Framework-dependent**, the application will
    assume the .NET runtime is installed on the target machine. However, if you select
    **Self-contained**, all needed assemblies will be part of the publication. Your
    package will be much bigger since it contains everything you need from the .NET
    runtime. However, it does not rely on others to install the .NET runtime.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署模式**：在这里，您可以选择**框架依赖**和**自包含**之间的选项。如果您选择**框架依赖**，应用程序将假定目标机器上已安装.NET运行时。然而，如果您选择**自包含**，所有需要的程序集都将包含在发布中。由于它包含从.NET运行时所需的所有内容，因此您的包将变得更大。但是，它不依赖于其他人安装.NET运行时。'
- en: '**Target runtime**: This is where you decide on the architecture of the target.
    If you know what architecture that machine is, you can choose it from the drop-down
    menu. This results in more optimized code but restricts where you can use it.
    For instance, if you decide to use Win-X64, you cannot deploy your code to a Linux
    machine. If you do not want to make that decision, leave it set to **Portable**.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标运行时**：这是您决定目标架构的地方。如果您知道那台机器的架构是什么，您可以从下拉菜单中选择它。这将导致代码更加优化，但限制了您可以使用它的地方。例如，如果您决定使用Win-X64，您就不能将代码部署到Linux机器上。如果您不想做出这个决定，请将其设置为**便携式**。'
- en: '**Target location**: This is the location where the files will be copied.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标位置**：这是文件将被复制到的位置。'
- en: 'Suppose you decided to go with the **Self-contained** option. In that case,
    you get three additional choices: **Produce Single file**, **Enable ReadyToRun
    compilation**, and **Trim** **unused code**.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您决定选择**自包含**选项。在这种情况下，您将获得三个额外的选择：**生成单个文件**、**启用ReadyToRun编译**和**删除未使用代码**。
- en: 'The first option is self-explanatory: you get one big file instead of dozens
    of small files. **ReadyToRun** is a form of **ahead-of-time** (**AOT**) compilation.
    This means the code is pre-compiled and thus starts faster. It is not a real AOT
    compilation: the resulting files contain both the compiled code and the IL. Still,
    it saves startup time. The **Trim unused code** option removes all code from the
    runtime you don’t need. Selecting this option makes the final package a lot smaller.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是显而易见的：你得到一个大的文件，而不是几十个小文件。**ReadyToRun** 是一种 **提前编译**（**AOT**）的形式。这意味着代码是预编译的，因此启动更快。它不是真正的
    AOT 编译：生成的文件包含编译后的代码和 IL。尽管如此，它节省了启动时间。**删除未使用代码**选项从运行时中删除你不需要的所有代码。选择此选项会使最终包的大小大大减小。
- en: 'Make your changes and then click **Save**. After that, click **Publish**. When
    Visual Studio is finished, go to the folder you picked as the destination and
    inspect what has happened (*hint*: you can click on the **Target location** value
    in the **Publish Profile** dialog to open an **Explorer** window and go to the
    location directly).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的更改，然后点击 **保存**。之后，点击 **发布**。当 Visual Studio 完成后，转到你选择的文件夹，检查发生了什么（提示：你可以在
    **发布配置文件** 对话框中点击 **目标位置** 值来打开 **资源管理器** 窗口并直接转到该位置）。
- en: All that’s left is to copy the resulting files to the target machine. Then,
    you can run it on that machine to see if everything is working fine and you are
    ready.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将生成的文件复制到目标机器上。然后，你可以在该机器上运行它，看看一切是否正常工作，你准备好了。
- en: 'Congratulations: you just deployed your application!'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜：你刚刚部署了你的应用程序！
- en: Publishing using the CLI
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CLI 发布
- en: The Visual Studio wizard is very good at helping you build the profile. Still,
    if you already know what you’re doing or want to make publishing part of a pipeline,
    you can use the CLI to do the same.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 向导在帮助你构建配置方面非常出色。尽管如此，如果你已经知道自己在做什么或者想要将发布作为管道的一部分，你可以使用 CLI 来完成同样的操作。
- en: 'The base command is simple – in the directory where you have your `.csproj`
    file, just run the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基本命令很简单——在你有 `.csproj` 文件所在的目录中，只需运行以下命令：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command takes all the default settings in the dialog box and uses them
    to publish your application. Of course, you can change what `publish` does: all
    you have to do is supply the correct parameters. The following table shows the
    most common ones and their possible values. Most parameters have two variants
    – a full parameter name (often preceded by two dashes) and a shorthand (often
    preceded by one dash):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用对话框中的所有默认设置并将它们用于发布你的应用程序。当然，你可以更改 `publish` 的行为：你只需要提供正确的参数。以下表格显示了最常见的参数及其可能值。大多数参数有两个变体——一个完整的参数名称（通常以两个连字符开头）和一个缩写（通常以一个连字符开头）：
- en: '| **Parameter** | **Description** | **Possible Values** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** | **可能值** |'
- en: '| --- | --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `-``o`/`--output` | The output directory to place the published artifacts
    in | The directory where you want to place the published application |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `-o`/`--output` | 放置已发布工件的目标目录 | 你想要放置已发布应用程序的目录 |'
- en: '| `--``sc`/`--self-contained` | Includes the runtime with your application
    | - |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `--sc`/`--self-contained` | 将运行时包含在你的应用程序中 | - |'
- en: '| `-``f`/`--framework` | The target framework you want to deploy to | `net6.0``net7.0``net8.0`
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `-f`/`--framework` | 你想要部署到的目标框架 | `net6.0` `net7.0` `net8.0` |'
- en: '| `-``r`/`--runtime` | The target runtime to publish for | `win-x64``linux-x64``linux-arm`
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `-r`/`--runtime` | 要发布的目标运行时 | `win-x64` `linux-x64` `linux-arm` |'
- en: '| `-``c`/`--configuration` | The build configuration | `Release``Debug` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `-c`/`--configuration` | 构建配置 | `Release` `Debug` |'
- en: 'Table 13.1: dotnet publish options'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1：dotnet publish 选项
- en: 'If you decide to build a self-contained deployment, you can add three more
    parameters:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定构建一个自包含的部署，你可以添加三个额外的参数：
- en: '| **Parameter** | **Description** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `-``p:PublishSingleFile=true` | Creates a single file |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `-p:PublishSingleFile=true` | 创建单个文件 |'
- en: '| `-``p:PublishReadyToRun=true` | Compiles to Ready To Run AOT binaries |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `-p:PublishReadyToRun=true` | 编译为 Ready To Run AOT 二进制文件 |'
- en: '| `-``p:PublishTrimmed=true` | Removes all unnecessary code from the binaries
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `-p:PublishTrimmed=true` | 从二进制文件中删除所有不必要的代码 |'
- en: 'Table 13.2: Self-Contained extra options'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.2：自包含额外选项
- en: You could specify that you do not want these options by setting them to `False`,
    but I suggest that you omit that parameter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将它们设置为 `False` 来指定你不想使用这些选项，但我建议你省略该参数。
- en: 'So, to publish your console application to a specific folder, create a self-contained
    deployment in a single file that’s ready to run, and trim all unnecessary code
    for a `win-x64` architecture running on `net.80`. To do so, issue the following
    code (all on a single line):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要将您的控制台应用程序发布到特定文件夹，创建一个包含单个可执行文件的独立部署，并删除所有不必要的代码以适应在 `net.80` 上运行的 `win-x64`
    架构。为此，请执行以下代码（所有内容都在一行上）：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, if you go to the `d:\temp\publish` folder, you can take the file there,
    copy that to your production machines, and run it. At this point, you can sit
    back, knowing your hard work is finally being used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您转到 `d:\temp\publish` 文件夹，您可以取那里的文件，将其复制到您的生产机器上，并运行它。在这个时候，您可以坐下来，知道您辛勤的工作终于被使用了。
- en: Using Azure DevOps and GitHub
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 和 GitHub
- en: If your code is meant to be used in the cloud, such as on Azure or AWS, you
    can use Azure DevOps and GitHub. Which one you pick depends on where you currently
    have your source code. Both DevOps and GitHub allow for **continuous integration
    and continuous deployment** (**CI/CD**) scenarios.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码打算在云中使用，例如在 Azure 或 AWS 上，您可以使用 Azure DevOps 和 GitHub。您选择哪一个取决于您当前源代码的位置。DevOps
    和 GitHub 都允许进行 **持续集成和持续部署**（**CI/CD**）场景。
- en: CI/CD
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD
- en: The idea with CI/CD is that when you change your source code, the system notices
    this and builds your software. Then, it can run tests optionally (in my view,
    it is not optional, but mandatory). After, it automatically deploys the new binaries
    to the production environment. This way of working means that you can do a lot
    of minor, incremental updates to your system and get early feedback on what you
    did. If this fits your use case, it is a great tool!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 的想法是，当您更改源代码时，系统会注意到这一点并构建您的软件。然后，它可以选择性地运行测试（在我看来，这不是可选的，而是强制性的）。之后，它会自动将新的二进制文件部署到生产环境。这种工作方式意味着您可以对系统进行许多小的、增量更新，并尽早获得关于您所做工作的反馈。如果这符合您的用例，这是一个伟大的工具！
- en: Let’s look at Azure DevOps first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 Azure DevOps。
- en: Deploying to Azure
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到 Azure
- en: I assume you have an Azure DevOps project set up, have defined the working process,
    and have a repo available to host your code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经设置了一个 Azure DevOps 项目，定义了工作流程，并且有一个用于托管代码的仓库。
- en: You can connect Visual Studio to that project if you have done so. In my case,
    I have created a simple Function App. A Function App is a service that runs in
    Azure. In this case, I have decided to use a simple HTTP-based trigger. In other
    words, the function responds to a REST API call and returns a string with a pleasant
    greeting. This chapter is not about writing Azure Functions but about deploying
    code, so I won’t dive into the details of how the code works. For now, it’s a
    REST API that you call with a parameter called `name`; it returns a friendly greeting
    containing that name. That’s it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经将 Visual Studio 连接到该项目，您可以将它连接到该项目。在我的情况下，我创建了一个简单的 Function App。Function
    App 是在 Azure 中运行的服务。在这种情况下，我决定使用一个简单的基于 HTTP 的触发器。换句话说，该函数响应 REST API 调用并返回一个包含友好问候语的字符串。本章不是关于编写
    Azure Functions，而是关于部署，所以我不会深入探讨代码的工作原理。目前，它是一个您可以通过名为 `name` 的参数调用的 REST API；它返回包含该名称的友好问候。就是这样。
- en: 'But to make things more interesting, I have called my program `MyFileConverterFunctionApp`.
    Trust me: it doesn’t do anything interesting.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了使事情更有趣，我给我的程序命名为 `MyFileConverterFunctionApp`。相信我：它并不做任何有趣的事情。
- en: If you have the code up and running locally, it is time to prepare your system
    for deployment. There are two steps we need to take.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在本地运行了代码，那么现在是时候为部署准备您的系统了。我们需要执行两个步骤。
- en: Create a publish profile
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建发布配置文件
- en: Publish the system to Azure
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将系统发布到 Azure
- en: Let’s get started.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Building the publish profile for Azure DevOps
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Azure DevOps 构建发布配置文件
- en: 'Before I show you how to deploy your application to Azure, let’s review the
    prerequisites if you want to follow along. First, you need a project to deploy.
    But besides this obvious prerequisite, these are the things you’ll need:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在向您展示如何将应用程序部署到 Azure 之前，让我们回顾一下如果您想跟随操作所需的先决条件。首先，您需要一个要部署的项目。但除了这个明显的先决条件之外，您还需要以下这些：
- en: An Azure account.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure 账户。
- en: A resource group (mine is called `SystemsProgrammingRg`).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个资源组（我的叫做 `SystemsProgrammingRg`）。
- en: A Key Vault to store secrets.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个密钥保管库来存储机密。
- en: A storage account. We’ll need this for deployment later.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个存储账户。我们稍后需要这个账户进行部署。
- en: Once you have these, you’re ready to start the deployment process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了这些，您就可以开始部署过程了。
- en: 'In Visual Studio, right-click on your project’s name and select **Publish**.
    You’ll be taken to the following screen:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，右键单击您的项目名称，然后选择**发布**。您将被带到以下屏幕：
- en: '![Figure 13.3: Default publishing dialog](img/B20924_14_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3：默认发布对话框](img/B20924_14_03.jpg)'
- en: 'Figure 13.3: Default publishing dialog'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：默认发布对话框
- en: Yes, this is the same dialog we saw previously. However, this time, select **Azure**
    as your target.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是我们之前看到的同一个对话框。然而，这次，选择**Azure**作为您的目标。
- en: The following dialog will ask you what kind of service you want to deploy. I
    chose **Azure Function App (Windows)**. You could go for a Linux deployment. Don’t
    worry about the container options for now; we will discuss Docker and containers
    later in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对话框将询问您想要部署哪种类型的服务。我选择了**Azure Function App (Windows)**。您可以选择Linux部署。现在不用担心容器选项；我们将在本章后面讨论Docker和容器。
- en: 'Then, we need to tell Visual Studio about the final location of our application.
    Likely, you won’t have a Function App you can use (that wasn’t part of the prerequisites,
    after all), so you can create one now. You’ll be presented with a dialog asking
    you about your environment and preferences. Mine looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要告诉Visual Studio我们的应用程序的最终位置。很可能您没有可以使用的函数应用（毕竟，这并不是先决条件的一部分），因此您现在可以创建一个。您将看到一个对话框，询问您关于您的环境和首选项。我的看起来像这样：
- en: '![Figure 13.4: Creating a new Function App in Visual Studio](img/B20924_14_04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4：在Visual Studio中创建新的函数应用](img/B20924_14_04.jpg)'
- en: 'Figure 13.4: Creating a new Function App in Visual Studio'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：在Visual Studio中创建新的函数应用
- en: I’ve blacked out my Azure account details since I want you to use yours. You
    need to choose the options that are best for you. This dialog is also where you
    must specify the storage account I told you to create (in my case, it is `dvstorageaccountsp`).
    I also decided to add **Application Insights**. Using **Application Insights**
    helps me monitor and troubleshoot my application if needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将我的Azure账户详情隐藏起来，因为我希望您使用自己的账户。您需要选择最适合您的选项。此对话框也是您必须指定我告诉您创建的存储账户的地方（在我的情况下，它是`dvstorageaccountsp`）。我还决定添加**应用程序洞察**。使用**应用程序洞察**可以帮助我在需要时监控和调试我的应用程序。
- en: 'When you click **Create**, the system will build your environment. This takes
    a while, but we can move to the next screen when it is done. This next screen
    gives you an overview of all app services in the given resource group and all
    the deployment slots. Since we haven’t deployed yet, this list is empty. Click
    **Next**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击**创建**时，系统将构建您的环境。这需要一些时间，但完成之后，我们可以转到下一个屏幕。下一个屏幕提供了给定资源组中所有应用程序服务和所有部署槽位的概览。由于我们还没有部署，这个列表是空的。点击**下一步**：
- en: '![Figure 13.5: Choosing what to generate as a publishing mechanism](img/B20924_14_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5：选择作为发布机制要生成的内容](img/B20924_14_05.jpg)'
- en: 'Figure 13.5: Choosing what to generate as a publishing mechanism'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：选择作为发布机制要生成的内容
- en: We can choose whether to use a publish profile or GitHub Actions here. We will
    look at GitHub Actions shortly, so let’s go with **Publish** for now. Visual Studio
    will generate the Publish profile for us.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里选择是否使用发布配置文件或GitHub Actions。我们很快就会看到GitHub Actions，所以现在让我们选择**发布**。Visual
    Studio将为我们生成发布配置文件。
- en: 'When that is done, we’ll get an overview, including a nice, big, inviting **Publish**
    button:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们会看到一个概览，包括一个漂亮的大、吸引人的**发布**按钮：
- en: '![Figure 13.6: Overview of the Publish profile](img/B20924_14_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6：发布配置概览](img/B20924_14_06.jpg)'
- en: 'Figure 13.6: Overview of the Publish profile'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：发布配置概览
- en: Let’s click that **Publish** button!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击那个**发布**按钮！
- en: Again, this takes a little while, but when your code has been published, you’ll
    get a hyperlink that allows you to go to the resource. You can click that, but
    it won’t be exciting. It’s just a web page saying your Function App is up and
    running.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这需要一点时间，但您的代码发布后，您将获得一个超链接，允许您访问资源。您可以点击它，但不会有什么激动人心的东西。它只是一个网页，说明您的函数应用正在运行。
- en: 'To see what happened, go to the Azure portal, find your resource group, and
    locate the Function App we created. There, you can test the function right inside
    the Azure web portal. Or better yet, open Visual Studio Code (if you have that
    installed), create a new file called `test.http`, and add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看发生了什么，请转到Azure门户，找到您的资源组，并定位到我们创建的函数应用。在那里，您可以直接在Azure网页门户中测试函数。或者更好的是，如果您已安装Visual
    Studio Code，创建一个名为`test.http`的新文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Replace my URL with yours, and click the **Send Request** link at the top of
    the first line. This will call the server. You’ll get some results that should
    look similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 用您的URL替换我的URL，并点击第一行顶部的**发送请求**链接。这将调用服务器。您会得到一些结果，应该看起来类似于以下内容：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Your data will be different, but the important part is that we get the `HTTP/1.1
    200 OK` result. This shows that our app works!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据可能不同，但重要的是我们得到了`HTTP/1.1 200 OK`的结果。这表明我们的应用程序工作正常！
- en: Enabling continuous integration in Azure DevOps
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Azure DevOps中启用持续集成
- en: Pushing to Azure directly from your development environment is convenient. Once
    you’ve set up the publishing profile, right-click on your program and click **Publish**
    to move your changes to Azure.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从您的开发环境将代码推送到Azure很方便。一旦您设置了发布配置文件，右键单击您的程序并点击**发布**，将您的更改移动到Azure。
- en: 'There is a better way of doing this, though: you can enable CI/CD so that any
    change you make is automatically deployed.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有更好的方法来做这件事：您可以通过启用CI/CD，使得任何您做出的更改都会自动部署。
- en: Branching and CI/CD
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 分支和CI/CD
- en: 'In all my samples, I use a single branch: `main`. I push changes from `main`
    on my machine directly to the online source repositories and let the systems build
    from that. In a real-world scenario, that is a terrible idea. You should pick
    up a branching strategy that allows for a good separation between the daily work
    and the deployments. You need things such as pull requests and merging strategies
    to preserve the quality of the work. Please don’t do what I’ve done here and have
    only a single branch.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我所有的示例中，我使用单个分支：`main`。我将机器上的`main`分支更改直接推送到在线源仓库，并让系统从那里构建。在现实世界的场景中，这是一个糟糕的想法。您应该选择一种分支策略，以便在日常工作与部署之间有良好的分离。您需要像拉取请求和合并策略这样的东西来保持工作的质量。请不要像我这里做的那样，只有一个分支。
- en: So, how do we achieve this magic? How do we get our changes “auto-magically”
    in our production environment? The answer is to use pipelines.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现这个魔法？我们如何让我们的更改“自动魔法般”地出现在我们的生产环境中？答案是使用管道。
- en: 'In your Azure DevOps environment, go to the project. You’ll see a **Pipelines**
    tab in the left sidebar. Click that. You’ll greeted with a page saying you haven’t
    got any pipelines yet. Let’s change that. Click the **Create Pipeline** button.
    You’ll be taken to the following screen:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Azure DevOps环境中，转到项目。您会在左侧侧边栏中看到一个**管道**标签。点击它。您会看到一个页面，说明您还没有任何管道。让我们改变这一点。点击**创建管道**按钮。您将被带到以下屏幕：
- en: '![Figure 13.7: Creating an Azure DevOps pipeline](img/B20924_14_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7：创建Azure DevOps管道](img/B20924_14_07.jpg)'
- en: 'Figure 13.7: Creating an Azure DevOps pipeline'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：创建Azure DevOps管道
- en: In this case, select **Azure Repos Git**. When you click that, you’ll get a
    dialog asking for your project. Select the repository containing the code you
    want to deploy automatically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，选择**Azure Repos Git**。点击它后，会弹出一个对话框要求选择项目。选择包含您想要自动部署的代码的仓库。
- en: Once you have done that, you’re done. Yes – it was that easy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您这样做，您就完成了。是的——它就是这么简单。
- en: 'You can now run the pipeline manually to see if everything works. Building
    your solution will take a couple of minutes, but when it’s done, you’ll see something
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以手动运行管道以查看一切是否正常工作。构建您的解决方案需要几分钟，但完成后，您会看到如下内容：
- en: '![Figure 13.8: Successful pipeline run](img/B20924_14_08.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8：成功的管道运行](img/B20924_14_08.jpg)'
- en: 'Figure 13.8: Successful pipeline run'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：成功的管道运行
- en: To test if your code has been published, rerun the test from Visual Studio Code
    (or whatever tool you use to test REST calls).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的代码是否已发布，请从Visual Studio Code（或您用于测试REST调用的任何工具）重新运行测试。
- en: Now, it is time for the cool stuff.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候做一些酷的事情了。
- en: In Visual Studio, make a change to the code. You could do something simple,
    such as change the text the function returns.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，对代码进行更改。您可以做一些简单的事情，比如更改函数返回的文本。
- en: Save your changes and push them to your repository. Once you’ve done that, go
    to Azure DevOps and find the pipeline – you’ll see that it’s already running!
    Just wait a few minutes until it is done and rerun your tests. You should see
    that your results have been propagated to the production environment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的更改并将它们推送到您的仓库。一旦您这样做，转到Azure DevOps并找到管道——您会看到它已经开始运行了！只需等待几分钟，直到它完成并重新运行您的测试。您应该会看到您的结果已经传播到生产环境中。
- en: That’s what I call easy deployment!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我所说的简单部署！
- en: In case you were wondering, the pipeline gets all the necessary information
    from your Publish profile. Remember when I said it was easier to do this if you
    publish manually first? Now you know why! You should look at the generated YAML
    files to see how things work. If you’re ready to take your deployment skills to
    the next level, I suggest that you search for this online. Dozens of books have
    been written on this topic, so I’m sure you can find what you’re looking for.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有所怀疑，管道会从你的发布配置文件中获取所有必要的信息。记得我之前说过，如果你先手动发布，这样做会更简单吗？现在你知道为什么了！你应该查看生成的YAML文件，看看事情是如何工作的。如果你准备好将你的部署技能提升到下一个水平，我建议你在网上搜索。关于这个主题已经写了几十本书，所以我相信你可以找到你想要的东西。
- en: Enabling CI from GitHub
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用GitHub的CI
- en: 'Azure DevOps is a great way to collaborate with people in the same organization.
    However, if you want to work with people across organizations, GitHub might be
    a better choice. GitHub is more geared toward open collaboration, such as open
    source projects. But that doesn’t mean you can’t have the same continuous integration
    as you have with Azure DevOps: you can achieve the same thing with GitHub Actions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps是与同一组织内的人协作的好方法。然而，如果你想与不同组织的人合作，GitHub可能是一个更好的选择。GitHub更倾向于开放协作，如开源项目。但这并不意味着你不能像在Azure
    DevOps中那样拥有相同的持续集成：你可以通过GitHub Actions实现相同的事情。
- en: Instead of having our source code in Azure DevOps, we host it in GitHub. Originally,
    GitHub was nothing more than a bunch of repositories, but they have expanded a
    lot since then. One of the more astonishing things they have added is GitHub actions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在Azure DevOps中保留源代码，而是在GitHub上托管它。最初，GitHub不过是一堆仓库，但自那时起它们已经扩展了很多。他们添加的更令人惊讶的事情之一是GitHub动作。
- en: Actions are the equivalent of the pipelines we just looked at. The syntax is
    different, and they support many more environments than the default pipelines
    in Azure, but the idea remains the same.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 行动相当于我们刚才查看的管道。语法不同，并且它们支持比Azure默认管道更多的环境，但理念保持一致。
- en: GitHub offers wizards to help you write your Actions, but there is a straightforward
    way to get our first Action up and running.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub提供向导来帮助你编写动作，但有一个简单的方法可以快速启动我们的第一个动作。
- en: Create a new Azure Function project in Visual Studio, but this time store it
    in your GitHub account. Once you’ve done that, test it locally and publish it
    to Azure. I always do this to make sure it works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中创建一个新的Azure Function项目，但这次将其存储在你的GitHub账户中。一旦完成，就在本地测试并发布到Azure。我总是这样做以确保它工作。
- en: Once the publishing is done, create a test for your code using Visual Studio
    Code or your preferred test tool.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布完成，使用Visual Studio Code或你喜欢的测试工具为你的代码创建一个测试。
- en: Now, let’s set up CI/CD from GitHub!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从GitHub设置CI/CD！
- en: In the Azure portal, navigate to your function. Then, in the left sidebar, select
    **Deployment Center**. Then, under **Source**, select **GitHub**. After doing
    that, you can enter your details. You must log in to GitHub and select the correct
    organization, repository, and source branch you want to publish.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure门户中，导航到你的函数。然后，在左侧边栏中，选择**部署中心**。然后，在**源**下，选择**GitHub**。完成这些后，你可以输入你的详细信息。你必须登录到GitHub并选择正确的组织、仓库和你要发布的源分支。
- en: You’ll also need to specify how you wish to authenticate. The GitHub action
    needs to log in to Azure to deploy your code, so the wizard will create an account
    for you. Use a user-assigned identity to make this happen. The identity will be
    created automatically. Once this has happened, click **Save**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要指定你希望如何进行身份验证。GitHub动作需要登录到Azure以部署你的代码，因此向导会为你创建一个账户。使用用户分配的标识来实现这一点。标识将自动创建。一旦发生这种情况，点击**保存**。
- en: And that is it – you’ve just set up your first GitHub Action! If you don’t believe
    me, go to your GitHub account, select your project, and go to **Actions**. You
    should see the action there, and it should show that it has already run as well!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——你刚刚设置了你的第一个GitHub动作！如果你不相信我，去你的GitHub账户，选择你的项目，然后转到**动作**。你应该在那里看到动作，并且它应该显示它已经运行过！
- en: '![Figure 13.9: First Action](img/B20924_14_09.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9：第一个动作](img/B20924_14_09.jpg)'
- en: 'Figure 13.9: First Action'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：第一个动作
- en: To check that it works as intended, you can change your code, commit the changes
    to the repository, and see the Action come to life. You can click on the run to
    see the details. When you’re done, it will have updated the code in your Azure
    environment. Test it and see the changes!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查它是否按预期工作，您可以更改代码，将更改提交到存储库，并查看操作是否生效。您可以通过点击运行来查看详细信息。完成后，它将更新您Azure环境中的代码。测试它并查看更改！
- en: 'Of course, a lot of our code doesn’t run on Azure. As system programmers, we
    often have to deploy to local hardware. In that case, these techniques won’t work.
    We have to figure out a better way. And there is: using installers!'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的大部分代码在Azure上无法运行。作为系统程序员，我们经常必须部署到本地硬件。在这种情况下，这些技术将不起作用。我们必须找到更好的方法。而且有：使用安装程序！
- en: Building installers with Visual Studio
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio构建安装程序
- en: Installers are nothing new – they were the only way to get an application on
    your system for a long time. Installers were primarily used to install Windows-based
    applications on the users’ machines. They aren’t used that often anymore since
    this has become obsolete for most use cases. But installers are a great and simple
    way to get the job done if you wish to install a background worker process and
    need to do some custom work.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序并不是什么新鲜事物——在很长的一段时间里，它是将应用程序安装到您系统上的唯一方式。安装程序主要用于在用户的机器上安装基于Windows的应用程序。由于这已经过时，因此不再经常使用。但如果您希望安装后台工作进程并需要进行一些自定义工作，安装程序是一个非常好且简单的方法来完成这项工作。
- en: Installers and Wix
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序和Wix
- en: The standard Microsoft Installer project works just fine. Still, many developers
    have moved away in favor of using Wix. Wix is a third-party solution for building
    installers. It is incredibly versatile, and thus, it is pretty hard to start using.
    Many books, articles, and how-tos are available to help you get up and running.
    But in our case, we don’t need that complexity. The standard installer is enough
    for most system programmers. But if you want more control, I urge you to dive
    into Wix and see what it can do for you.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的Microsoft Installer项目工作得很好。尽管如此，许多开发者已经转向使用Wix。Wix是用于构建安装程序的第三方解决方案。它非常灵活，因此，开始使用它相当困难。有许多书籍、文章和教程可以帮助您入门。但就我们而言，我们不需要这种复杂性。标准的安装程序对大多数系统程序员来说就足够了。但如果您想要更多控制权，我强烈建议您深入研究Wix，看看它能为您做什么。
- en: Suppose you installed the **Microsoft Visual Studio Installer Projects 2022**
    extension in Visual Studio. In that case, you can add an installer project to
    your solution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在Visual Studio中安装了**Microsoft Visual Studio Installer Projects 2022**扩展。在这种情况下，您可以将安装程序项目添加到您的解决方案中。
- en: Let’s do that!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做！
- en: Building a simple installer
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建简单的安装程序
- en: In the **New Project** dialog, select the **Setup Wizard** template. This will
    start a typical “next, next, finish” type wizard. There are five steps to follow.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新项目**对话框中，选择**设置向导**模板。这将启动一个典型的“下一步，下一步，完成”类型的向导。需要遵循五个步骤。
- en: 'The first one looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个看起来像这样：
- en: '![Figure 13.10: Setup Wizard (1 of 5)](img/B20924_14_10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10：设置向导（第1页，共5页）](img/B20924_14_10.jpg)'
- en: 'Figure 13.10: Setup Wizard (1 of 5)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：设置向导（第1页，共5页）
- en: 'The rest of the screens are self-explanatory. The first real question asks
    you whether you want to build a setup program for a Windows application, a setup
    program for a web application, or whether you want to create a redistributable
    package. We want the first option: a setup for a Windows application since that
    is what a background worker system still is.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的屏幕都是自我解释的。第一个真正的问题是询问您是否想为Windows应用程序构建设置程序、为Web应用程序构建设置程序，或者您是否想创建一个可分发的包。我们想要第一个选项：为Windows应用程序的设置，因为后台工作系统仍然是这个。
- en: Then, the wizard will want to know what you want to install. From the dropdown,
    select the **Publish Items from…** option. Those are all the executables and dependencies,
    so we want those.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向导将询问您想安装什么。从下拉菜单中选择**从…发布项目**选项。这些都是所有可执行文件和依赖项，因此我们想要这些。
- en: After, you’ll be asked if there are any other files you want to include. There
    aren’t, so just click **Next**. The last step is a summary of the previous steps.
    Review this page and click **Finish**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将被询问是否还有其他文件要包含。没有，所以只需点击**下一步**。最后一步是之前步骤的总结。查看此页面并点击**完成**。
- en: And that’s it!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'Before we can test it, we need to set some properties. Select your project
    in the **Solution Explorer** area and look at the **Properties** window. Here,
    you can fill in all the details you think matter to you. Mine looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够测试它之前，我们需要设置一些属性。在**解决方案资源管理器**区域中选择你的项目，并查看**属性**窗口。在这里，你可以填写你认为重要的所有详细信息。我的看起来像这样：
- en: '![Figure 13.11: Setting up project properties](img/B20924_14_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11：设置项目属性](img/B20924_14_11.jpg)'
- en: 'Figure 13.11: Setting up project properties'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：设置项目属性
- en: You should at least change the `C:\Program Files (x86)` folder. If that’s not
    what you want, change the `TargetPlatform` property from `C:\Program Files` the
    default folder. Of course, you should only do that when your application is indeed
    64-bit (the **x64** option) instead of the older 32-bit (**x86**) format.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你至少应该更改`C:\Program Files (x86)`文件夹。如果你不想要这个，将`TargetPlatform`属性从默认文件夹`C:\Program
    Files`更改。当然，你应该只在你的应用程序确实是64位（**x64**选项）而不是较旧的32位（**x86**）格式时这样做。
- en: Why is 64-bit X64, but 32-bit X86?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么64位是X64，而32位是X86？
- en: 'Sometimes, people get confused by these names. People seem to get that X64
    means 64-bit, but why on earth is 32-bit called X86? The answer is rather simple:
    X64 indeed is just 64-bit, but the X86 refers to the original Intel 8086 processor
    from long ago, when machines ran 16-bit or at most 32-bit software. It’s just
    a weird thing that you now know and can brag about to your friends!'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，人们会被这些名称搞混。人们似乎明白X64代表64位，但为什么32位被称为X86呢？答案相当简单：X64确实只是64位，但X86指的是很久以前的原始英特尔8086处理器，当时机器运行的是16位或最多32位的软件。这只是一个你现在知道并且可以向朋友吹嘘的奇怪事情！
- en: It’s time to test it all out!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试一切了！
- en: Right-click on your **Setup** project, select **Build**, and see if everything
    builds. If it does, you can right-click on the project again, but select **Install**
    this time. If all goes well, your system will be installed! You can navigate to
    the folder you chose during installation and see your files there.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击你的**安装**项目，选择**构建**，看看是否一切构建成功。如果成功了，你可以再次右键单击项目，但这次选择**安装**。如果一切顺利，你的系统将被安装！你可以导航到安装过程中选择的文件夹，并看到那里的文件。
- en: To clean up, you only have to click **uninstall** in Visual Studio.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理，你只需要在Visual Studio中点击**卸载**。
- en: Writing a Custom Action
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义操作
- en: This is nice, but it’s not enough. Especially for us system programmers, several
    other things need to be done during or after installation. For instance, a worker
    process must be registered as a Windows service to start automatically. Or let’s
    say we have a secret that must be encrypted before we can store it in a settings
    file. How would we do that? The answer is we write a Custom Action.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但还不够。特别是对于我们系统程序员来说，在安装期间或之后还需要做几件事情。例如，工作进程必须注册为Windows服务以自动启动。或者让我们假设我们有一个必须在存储到设置文件之前加密的秘密。我们该如何做呢？答案是，我们编写一个自定义操作。
- en: '*A Custom Action is some code in an external assembly that gets deployed with
    the Installer and called at the* *right time.*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*自定义操作是外部程序集中的一个代码片段，它在安装程序部署时在正确的时间被调用。*'
- en: 'It’s not hard to write them: it’s all done in C#. And we know that language!'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 编写它们并不难：它们都是用C#编写的。而且我们知道这门语言！
- en: First, let’s discuss what we want to do.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下我们想要做什么。
- en: In the previous chapter, we discussed secrets. We discovered we can use the
    .NET system to generate keys to encrypt and decrypt data. That key would only
    work on that machine since it is tied to the installed version of Windows for
    that particular user. That means we must encrypt any secret in the `appsettings`
    file on the target machine.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了秘密。我们发现我们可以使用.NET系统生成密钥来加密和解密数据。这个密钥只会在这个机器上工作，因为它与特定用户的安装的Windows版本相关联。这意味着我们必须加密目标机器上的`appsettings`文件中的任何秘密。
- en: So, suppose we deploy an unencrypted secret in a settings file. In that case,
    we must make sure that we encrypt the target machine during installation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在设置文件中部署了一个未加密的秘密。在这种情况下，我们必须确保在安装过程中加密目标机器。
- en: In my sample, I am just replacing a placeholder with a new `GUID` to show how
    it’s done. But the principle stands.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，我只是用一个新的`GUID`替换了一个占位符来展示如何操作。但原则是相同的。
- en: 'Add a new Class Library to the solution. However, there is one caveat: select
    the **.NET Framework** version of the Class Library. The MSI installer uses the
    “old” .NET framework, so any add-ons must be built with that technology.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新的类库添加到解决方案中。然而，有一个注意事项：选择类库的**.NET Framework**版本。MSI安装程序使用的是“旧”的.NET框架，因此任何附加组件都必须使用该技术构建。
- en: 'Add a reference to **System.Configuration.Install** to the class library project,
    as I did here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将对**System.Configuration.Install**的引用添加到类库项目中，就像我这里做的那样：
- en: '![Figure 13.12: Adding the System.Configuration.Install reference](img/B20924_14_12.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12：添加System.Configuration.Install引用](img/B20924_14_12.jpg)'
- en: 'Figure 13.12: Adding the System.Configuration.Install reference'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：添加System.Configuration.Install引用
- en: 'Add a new item to the class library that’s of the `Installer` type. You can
    do that by right-clicking on the project and selecting `Installer`. Call it `SecretsInstaller`.
    This can be seen in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 向类库添加一个新的`Installer`类型的项目。你可以通过右键单击项目并选择`Installer`来实现。命名为`SecretsInstaller`。这可以在下面的屏幕截图中看到：
- en: '![Figure 13.13: Adding an installer class](img/B20924_14_13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13：添加安装类](img/B20924_14_13.jpg)'
- en: 'Figure 13.13: Adding an installer class'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13：添加安装类
- en: 'Change the code so that it looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 修改代码，使其看起来像这样：
- en: '[PRE4]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code gets called by `Installer`. Here, I found the `appsettings.json` file,
    loaded it in memory, found the `SECRET_PLACEHOLDER` string, and replaced it with
    a `Guid` value. Finally, I wrote it back to the file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会被`Installer`调用。在这里，我找到了`appsettings.json`文件，将其加载到内存中，找到了`SECRET_PLACEHOLDER`字符串，并将其替换为`Guid`值。最后，我将它写回文件。
- en: The interesting part is the line where I get the path to the file. I return
    to that one later, so keep that in mind.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是我获取文件路径的行。我稍后会回到那里，所以请记住这一点。
- en: 'We need to register this class with `Installer`. Add a new `Installer` class
    to our class library, `ProjectInstaller`, and change the constructor. This code
    is even simpler than the last one:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`Installer`注册这个类。将一个新的`Installer`类添加到我们的类库中，`ProjectInstaller`，并更改构造函数。这段代码甚至比上一个还要简单：
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the constructor, we create an instance of the `SecretsInstaller` class and
    add it to our `Installer`. This is a list of classes the install system looks
    at and then calls `Install` on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们创建了一个`SecretsInstaller`类的实例并将其添加到我们的`Installer`中。这是一个安装系统会查看并调用`Install`方法的类列表。
- en: That is all the code we need to write. Let’s use it!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要编写的所有代码。让我们来使用它！
- en: Incorporating the custom action in the setup
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在设置中集成自定义操作
- en: Go back to **Setup program**. Right-click on the project, select **Add…**, then
    **Project output**. Select the primary output of the **Custom Action** project.
    This ensures our DLL is part of the files that are being installed on the target
    machine.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**设置程序**。右键单击项目，选择**添加…**，然后**项目输出**。选择**自定义操作**项目的输出。这确保我们的DLL是目标机器上正在安装的文件之一。
- en: Right-click on **Setup program** again but select **View**, then **Custom Actions…**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 再次右键单击**设置程序**，但选择**查看**，然后**自定义操作…**。
- en: 'You should see a screen with four categories. This determines when the custom
    action should be called. These options are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个包含四个类别的屏幕。这决定了自定义操作应该在何时被调用。这些选项如下：
- en: '**Install**: This is when all files are installed'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装**：这是所有文件都被安装的时候'
- en: '**Commit**: This is when the setup has finalized everything'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交**：这是设置完成所有事情的时候'
- en: '**Rollback**: When the setup fails, this is called'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：当设置失败时，这被称为'
- en: '**Uninstall**: When the user decides to install, these actions are performed'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卸载**：当用户决定安装时，这些操作会被执行'
- en: 'In our case, we need to use **Install**. Right-click on that and select **Add
    Custom Action**. Once again, you’ll be presented with a dialog showing the target
    machine’s file structure. These are all the locations where our files can end
    up. Since we added our project output of the custom action to the regular installation,
    we can find it in the **Application Folder** area. Select the primary output from
    your Custom Action and click **OK**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要使用**Install**。右键单击它并选择**添加自定义操作**。再次，你将看到一个显示目标机器文件结构的对话框。这些都是我们的文件可能最终到达的位置。由于我们将自定义操作的项目输出添加到了常规安装中，我们可以在**应用程序文件夹**区域找到它。选择自定义操作的主要输出并点击**确定**：
- en: '![Figure 13.14: Adding the Custom Action assembly](img/B20924_14_14.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14：添加自定义操作组件](img/B20924_14_14.jpg)'
- en: 'Figure 13.14: Adding the Custom Action assembly'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：添加自定义操作组件
- en: Don’t leave the Custom Action view yet. Click on the new item in the **Install**
    section, and look at the **Properties** area. Here, you can add all sorts of items,
    but the most important is **CustomActionData**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不要离开自定义操作视图。点击**安装**部分中的新项目，查看**属性**区域。在这里，你可以添加各种项目，但最重要的是**CustomActionData**。
- en: 'This is data from outside that gets passed as parameters to our custom action.
    Remember when I said I would get back to how I would get the path to the target
    directory? This is where I do that. Add the following line to that property:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自外部传递给我们的自定义操作参数的数据。记得我之前说过我会回到如何获取目标目录路径的方法吗？这就是我做到这一点的地方。将以下行添加到该属性中：
- en: '[PRE6]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Yes. A “backslash, space, closing quote” is at the end of that line. Don’t
    leave those out. Trust me: I spent hours determining why my actions didn’t work.
    The reason: I forgot that extra slash and space. It just doesn’t work without
    it.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。那一行的末尾有一个“反斜杠，空格，关闭引号”。不要遗漏这些。相信我：我花了好几个小时确定为什么我的操作不起作用。原因是：我忘记了那个额外的斜杠和空格。没有它根本不起作用。
- en: And that’s all there is to it!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！
- en: You can now build and then run **Install**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以构建并运行**安装**。
- en: Look up the folder where the installation took place and marvel at the changes
    in the JSON file!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 查找安装发生的文件夹，并惊叹于JSON文件中的变化！
- en: Using Docker
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker
- en: The most used excuse developers use when someone complains the system doesn’t
    work as expected is “But it works on my machine!” Of course, the only suitable
    response is, “We do not ship your machine; we ship software.”
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者当有人抱怨系统不符合预期时最常用的借口是“但是在我的机器上它工作得很好！”当然，唯一的合适回应是，“我们不发货机；我们发货软件。”
- en: Docker aims to be a solution to that problem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Docker旨在解决那个问题。
- en: Docker is a highly complex topic. If you’re unaware of what it can do, please
    skip this part of this chapter until you’re more familiar with it. In short, Docker
    can act like a complete virtual machine. This principle means you can develop
    on that virtual machine, test on that virtual machine, and then deploy that virtual
    machine. In other words, if it works on that machine, it will work everywhere.
    The reason it will work everywhere is that with Docker, we ship your machine.
    Well, the virtual one, at least.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个高度复杂的话题。如果你不了解它能做什么，请在熟悉它之前跳过本章的这一部分。简而言之，Docker可以像完整的虚拟机一样运行。这个原则意味着你可以在那个虚拟机上开发，在那个虚拟机上测试，然后部署那个虚拟机。换句话说，如果它在那个机器上工作，它将在任何地方工作。它之所以能在任何地方工作，是因为有了Docker，我们发货你的机器。好吧，至少是虚拟的。
- en: Visual Studio has completely embraced Docker. The IDE comes packed with handy
    add-ons and wizards to help you use Docker.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio完全拥抱了Docker。IDE内置了实用的附加组件和向导，以帮助您使用Docker。
- en: Adding Docker support to your background worker
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Docker支持添加到你的后台工作进程
- en: 'If you create a new project, such as a background worker, you can choose to
    add Docker support. But if you already have a project, you must add support later.
    It’s not hard to do: just right-click on the project, select **Add**, and then
    click **Docker support**. You can choose between **Windows** and **Linux**:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个新的项目，例如后台工作进程，你可以选择添加Docker支持。但如果你已经有一个项目，你必须稍后添加支持。这并不难做：只需右键单击项目，选择**添加**，然后点击**Docker支持**。你可以在**Windows**和**Linux**之间选择：
- en: '![Figure 13.15: Adding Docker to an existing project](img/B20924_14_15.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图13.15：将Docker添加到现有项目](img/B20924_14_15.jpg)'
- en: 'Figure 13.15: Adding Docker to an existing project'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15：将Docker添加到现有项目
- en: Docker – using Windows or Linux?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Docker – 使用Windows还是Linux？
- en: 'If you’ve been working with Visual Studio for some time, you will likely choose
    Windows over Linux. After all, you probably know that platform very well. Why
    should you move to Linux? However, containerization comes from the Linux world:
    it is baked into the core of the operating system. Linux is a far better platform
    for containers than Windows. If you don’t need Windows features, I suggest that
    you take Linux as the base container. Your apps will benefit from that if you
    decide to use Docker.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用Visual Studio了一段时间，你可能会选择Windows而不是Linux。毕竟，你可能非常了解那个平台。为什么你要迁移到Linux呢？然而，容器化来自Linux世界：它被嵌入到操作系统的核心中。Linux是比Windows更好的容器平台。如果你不需要Windows功能，我建议你以Linux为基础容器。如果你决定使用Docker，你的应用程序将从中受益。
- en: 'When you do this, a lot of things happen:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，会发生很多事情：
- en: A new file called `Dockerfile` is added to the project
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目中添加了一个名为`Dockerfile`的新文件
- en: The `launchSettings.json` file is changed to add Docker
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchSettings.json`文件被更改以添加Docker'
- en: In the background, all the necessary support images are installed
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台，安装所有必要的支持镜像
- en: The default start action is set to **Container** (Dockerfile)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认启动操作设置为**容器**（Dockerfile）
- en: 'If you start debugging, Visual Studio will build the Docker image with your
    binaries and start a container. You can add breakpoints to your code, and Visual
    Studio will also ensure the debugger is deployed in the container. Hence, it knows
    how to tunnel the debug information back and forth. The whole process is streamlined:
    you hardly notice you’re running on a Docker image instead of your host machine.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始调试，Visual Studio将会使用你的二进制文件构建Docker镜像并启动一个容器。你可以在代码中添加断点，Visual Studio也会确保调试器被部署在容器中。因此，它知道如何来回隧道调试信息。整个过程都是简化的：你几乎不会注意到你是在Docker镜像上运行而不是在主机机器上。
- en: Deploying your Docker images
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署你的Docker镜像
- en: 'Once you’ve finished working on your code base and are ready to deploy it,
    you must figure out where to deploy it. There are three options:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成对代码库的工作并准备部署它，你必须弄清楚在哪里部署它。有三个选项：
- en: Use Docker Hub. This is the standard repository where you can store your images.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Hub。这是你可以存储你的镜像的标准存储库。
- en: Use Azure/AWS/Google Cloud to store your images. These are much more secure
    since you control these environments. For instance, you can create a container
    registry in Azure and then upload your images. Everybody in your organization
    can then pull that image and run it locally.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure/AWS/Google Cloud来存储你的镜像。这些存储库要安全得多，因为你控制这些环境。例如，你可以在Azure中创建一个容器注册库，然后上传你的镜像。你组织中的每个人都可以拉取那个镜像并在本地运行它。
- en: Use your own repository. Suppose you don’t want to depend on a cloud provider
    but want complete control over where your images are. In that case, you can build
    your own repository.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你自己的存储库。假设你不想依赖云提供商，但想完全控制你的镜像存储位置。在这种情况下，你可以构建自己的存储库。
- en: The third option is the most used one for our scenarios. Of course, you can
    use Docker Hub or Azure. Nothing is getting in your way. It’s just that for the
    things we build, the third option is probably the best.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是我们场景中最常用的一个。当然，你也可以使用Docker Hub或Azure。没有任何东西会阻碍你的道路。只是对于我们构建的东西来说，第三个选项可能是最合适的。
- en: Building an actual repository is hard. But the good news is that someone else
    has already done it. And they have put it in a Docker image. So, all we have to
    do is download that image and start it up.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 构建实际的存储库是困难的。但好消息是，其他人已经完成了这项工作。他们已经将其放入了一个Docker镜像中。所以，我们只需要下载那个镜像并启动它。
- en: 'But before we do that, we need to think about security. There are many ways
    to secure the repository, but the easiest (and least secure) way is to assign
    a username/password. You need some code to generate those, but don’t worry: there’s
    a Docker image for that.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，我们需要考虑安全性。有许多方法可以保护存储库，但最简单（也是最不安全）的方法是分配一个用户名/密码。你需要一些代码来生成这些，但不用担心：有一个Docker镜像可以做到这一点。
- en: 'First, create a folder named `C:\Auth`. Then, run the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`C:\Auth`的文件夹。然后，运行以下命令：
- en: '[PRE7]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command downloads the `http:2` image and runs it, gives it a username of
    `yourusername` and a password of `yourpassword` (I suggest that you use other
    values for those parameters), and stores the result in the `htpasswd` file in
    the `c:\auth` folder.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令下载了`http:2`镜像并运行它，给它一个用户名为`yourusername`和密码为`yourpassword`（我建议你使用其他值作为这些参数），并将结果存储在`c:\auth`文件夹中的`htpasswd`文件中。
- en: 'Now, we can start the repository. Run the following command, all on one line:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动存储库。运行以下命令，全部在一行中：
- en: '[PRE8]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command pulls the `registry:2` image from Docker Hub and starts it. It
    connects the internal folder, `/auth`, to our `c:\auth` directory and gives it
    some parameters.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从Docker Hub拉取`registry:2`镜像并启动它。它将内部文件夹`/auth`连接到我们的`c:\auth`目录，并给它一些参数。
- en: And that’s all there is to it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。
- en: 'To use the repo, you must log in:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用存储库，你必须登录：
- en: '[PRE9]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, you can tag and push your images there. In my case, my C# worker process
    image from Visual Studio is called `image13workerfordocker`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在那里标记和推送你的镜像。在我的例子中，我的从Visual Studio来的C#工作进程镜像被称为`image13workerfordocker`。
- en: 'You can tag it by running the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来标记它：
- en: '[PRE10]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, this is all one line. Now, I can push it to my local repository, like
    this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一整行。现在，我可以将其推送到我的本地存储库，如下所示：
- en: '[PRE11]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If I want to reuse my image, I can pull it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想重用我的镜像，我可以拉取它：
- en: '[PRE12]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I can use this repository just like I can with the ones at Docker Hub, Azure,
    AWS, or Google.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用这个存储库，就像我可以在Docker Hub、Azure、AWS或Google上的那些存储库中一样。
- en: Production-ready Docker repository
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产就绪的Docker存储库
- en: What I’ve shown you here is just to show you the uttermost beginnings. The repository
    isn’t secure or stable and doesn’t even survive a reboot.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里展示的只是让你看到最基础的开始。这个仓库并不安全或不稳定，甚至无法在重启后存活。
- en: 'There are several things you need to do if you want to use this in a real production
    environment:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在真实的生产环境中使用它，你需要做几件事情：
- en: Harden the security by using TLS
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 TLS 来加强安全性
- en: 'Install a volume so that you can store the images instead of using a container
    (hint: map a volume to `/var/lib/registry`)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个卷，以便你可以存储镜像而不是使用容器（提示：将卷映射到 `/var/lib/registry`）
- en: Use actual authentication instead of the single username/password I have just
    shown you
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实际的认证方式，而不是我刚刚展示给你的单个用户名/密码
- en: Deploy the repository in a fail-safe environment such as Kubernetes
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在像 Kubernetes 这样的故障安全环境中部署仓库
- en: But even with this setup, you can have your own repository. This will ensure
    that if the code works on your machine, it works everywhere!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使有这个设置，你仍然可以拥有自己的仓库。这将确保如果代码在你的机器上工作，它将在任何地方工作！
- en: Next steps
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: 'In this chapter, we discussed many ways you can get your software from your
    machine to other machines. Some were easy, others were hard. To be honest, this
    chapter was more about helping you start thinking about deployment. Each topic
    could fill hundreds of pages. For instance, I mentioned Wix. Well, dozens of books
    have been written on Wix alone. We discussed CI/CD in Azure in a couple of pages.
    It turns out people make a complete career out of that topic. We also looked at
    Docker: people spend weeks, if not months, getting up to speed on that topic.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多将你的软件从你的机器传输到其他机器的方法。有些很简单，有些则很复杂。说实话，本章更多的是帮助你开始思考部署。每个主题都可以填满数百页。例如，我提到了
    Wix。好吧，仅关于 Wix 就有数十本书籍。我们在 Azure 中讨论了 CI/CD，只用了几页。结果发现，人们可以从这个主题中完全建立起自己的职业生涯。我们还研究了
    Docker：人们可能需要花费数周甚至数月的时间来掌握这个主题。
- en: There are many ways you can get your code out there, and this chapter only scratched
    the surface.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多种方式可以将你的代码发布出去，而这章只是触及了表面。
- en: I wanted to show you the most common ones that fit scenarios we will most likely
    run into. It is up to you to determine which is the best for your use case and
    then dive deeper into it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向你展示最常见的一些适合我们最可能遇到场景的方法。确定哪种最适合你的用例，然后深入探索，这取决于你。
- en: But before I let you go, I need to say something about the dialog regarding
    Docker. The dialog asked if you wanted to use Linux or Windows. I suggest that
    you choose Linux as often as you can. If you think, “But I know very little about
    Linux,” don’t worry. The next chapter will tell you all you need to know about
    that operating system. So, let’s have a look, shall we?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我让你们离开之前，我需要说一些关于 Docker 对话的内容。对话询问你是否想使用 Linux 或 Windows。我建议你尽可能选择 Linux。如果你认为，“但我对
    Linux 了解很少”，请不要担心。下一章将告诉你所有你需要知道的关于那个操作系统的内容。那么，让我们看看，好吗？
