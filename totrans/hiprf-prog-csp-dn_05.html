<html><head></head><body>
		<div><h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor072"/>Chapter 4</em>: Memory Management</h1>
			<p>In this chapter, we will be looking at object generations and how to avoid memory issues, followed by a discussion on strong and weak references. Then, we will look at finalization and how we can suppress finalization by implementing the <code>IDisposable</code> pattern to clean up managed and unmanaged resources. Finally, we will take a high-level look at ways to avoid memory leaks. </p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li><code>System.OutOfMemoryException</code>. We learn how to predict out-of-memory errors before they happen by using the <code>System.Runtime.MemoryFailPoint</code> class.</li>
				<li><strong class="bold">Understanding long and short weak references</strong>: In this section, we learn about long and short weak references and how they are affected by the garbage collector.</li>
				<li><strong class="bold">Finalization</strong>: In this section, we look at how to use finalizers to clean up resources, and understand why we have no control over if and when they will run.</li>
				<li><code>IDisposable</code> pattern.</li>
				<li><strong class="bold">Preventing memory leaks</strong>: In this section, we look at how the use of the <strong class="bold">Component Object Model</strong> (<strong class="bold">COM</strong>) and managed events can be sources that generate memory leaks and what we can do to avoid memory leaks from being generated. We will be using Microsoft Excel and JetBrains dotMemory in this section to see how leaks can be generated and to see how using a memory profiler can be very useful in identifying memory leaks and their sources.</li>
			</ul>
			<p>By the end of this chapter, you will have gained skills in the following areas:</p>
			<ul>
				<li>Understanding object generations</li>
				<li>Understanding how objects are disposed</li>
				<li>Understanding why it is best to avoid finalizers and implement <code>IDisposable</code></li>
				<li>Understanding how to prevent memory leaks arising from the use of unmanaged COM libraries and components and from using events</li>
				<li>Using anonymous methods, long weak references, and short weak references to improve garbage collection</li>
			</ul>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>To complete the steps in this chapter, there are some technical requirements, as outlined here:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>JetBrains dotMemory</li>
				<li>Source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04</a></li>
			</ul>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Object generations and avoiding memory issues</h1>
			<p>There are three<a id="_idIndexMarker285"/> object generations<a id="_idIndexMarker286"/> in the .NET runtime, as follows: </p>
			<ul>
				<li>Generation 0</li>
				<li>Generation 1</li>
				<li>Generation 2</li>
			</ul>
			<p>Generation 0 is the youngest generation and holds short-lived objects. Objects that are less than 80,000 bytes are generation 0 objects<a id="_idIndexMarker287"/> that get placed on the <strong class="bold">small object heap</strong> (<strong class="bold">SOH</strong>) when they are instantiated. Objects that are 80,000 bytes or larger are usually generation 2 objects and live on the <strong class="bold">large object heap</strong> (<strong class="bold">LOH</strong>). Generation 1 objects are those objects<a id="_idIndexMarker288"/> that survived generation 0 garbage collection and received a promotion to generation 1.</p>
			<p>Generation 0 is where most of the garbage <a id="_idIndexMarker289"/>collection takes place. Objects that do not get collected<a id="_idIndexMarker290"/> when they are generation 0 will get promoted to generation 1 to make room for more generation 0 objects to be added to the heap. If generation 0 and 1 become full, then generation 1 objects are promoted to generation 2, and generation 0 objects are promoted to generation 1. If generations 0, 1, and 2 become full so that no more objects can be added to the heap, you then end up with a <code>System.OutOfMemoryException</code>-type exception.</p>
			<p>We are now going to write a very simple program that will throw a <code>System.OutOfMemoryException</code>-type exception. Follow these next steps:</p>
			<ol>
				<li>Start a new .NET 6 console application project called <code>CH04_OutOfMemoryExceptions</code>. Add the following <code>using</code> statements to the <code>Program.cs</code> file:<pre>using System.Text.RegularExpressions;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime;
using System.Text;</pre></li>
				<li>Add the following method calls to the <code>Main</code> method:<pre>DataExportToCsv();
ReadCsvBroken();
ReadCsvPredictive();
Console.ReadKey();</pre></li>
				<li>The <code>DataExportToCsv()</code> method builds up a very large data file. <code>ReadCsvBroken()</code> reads in the <code>System.OutOfMemoryException</code>-type exception. The exception<a id="_idIndexMarker291"/> is avoided in the <code>ReadCsvPredictive()</code> method, as the method<a id="_idIndexMarker292"/> instantiates the <code>MemoryFailPoint</code> class to ensure that the data read of the file will not generate an exception. If the operation does generate a <code>System.OutOfMemory exception</code>-type exception, then the <code>MemoryFailPoint</code> object will raise an <code>OutOfMemoryException</code>-type exception. This saves memory, time, <code>Program</code> class:<pre>private static string _filename 
= @"G:\Temp\SampleData.csv";</pre></li>
				<li>This will be the file we will write to and read from. Add the following <code>DataExportToCsv()</code> method:<pre>private static void DataExportToCsv()
{
    int row = 0;
    try
    {
    File.Delete(_filename);
    using (FileStream fs = new FileStream(_filename, 
    FileMode.OpenOrCreate))
    {
        fs.Write(Encoding.Unicode.GetBytes("Id, 
            Name, Description\n"));
            for (int i = 0; i &lt;= 491616373; i++)
            {
                row = i;
                Console.WriteLine($"Writing row {row} to 
                    CSV data. There are {491616373-row} 
                        rows remaining.");
                fs.Write(Encoding.Unicode.GetBytes
                  ($"{i}, Name {i}, Description {i}\n"));
    }
  }
}
catch (Exception ex)
    {
        Console.WriteLine($"DataExportToCsv: 
            {ex.GetBaseException().Message}")
    }
}</pre></li>
				<li>This code writes 491,616,373 lines<a id="_idIndexMarker293"/> of data to a CSV file. Add<a id="_idIndexMarker294"/> the following <code>ReadCsvBroken()</code> method:<pre>private static void ReadCsvBroken()
{
    int row = 0;
    try
    {
        string csv = File.ReadAllText(_filename);
    }
    catch (OutOfMemoryException oomex)
    {
    Console.WriteLine($"ReadCsvBroken:
        {oomex.GetBaseException().Message}");
    }
}</pre></li>
				<li>The <code>ReadCsvBroken()</code> method tries to read the massive 44.2 <code>string</code> variable. This operation throws a <code>System.OutOfMemoryException</code>-type exception. Add the following <code>ReadCsvPredictive()</code> method:<pre>private static void ReadCsvPredictive()
{
    int row = 0;
    try
    {
        string alphabet = "abcdefghijklmnopqrstuvwxyz";
        using (new MemoryFailPoint(alphabet.length))
        {
            string alpha = alphabet;
        }
        FileInfo fi = new FileInfo(_filename);
        Int length = unchecked((int)fi.length);
        using (new MemoryFailPoint(length))
        {
            string csv = File.ReadAllText(_filename);
        }
    }
    catch (OutOfMemoryException oomex)
    {
        Console.WriteLine($"ReadCsvPredictive: 
            {oomex.GetBaseException().Message}");
    }
}</pre></li>
				<li>This code uses predictive memory checking using the <code>MemoryFailPoint</code> class. We show it working<a id="_idIndexMarker297"/> for the <code>alphabet</code> string, and we show<a id="_idIndexMarker298"/> that it highlights an error and fails with an <code>OutOfMemoryException</code>-type exception when the length of the file contents is assigned to the <code>length</code> variable that is passed into the <code>MemoryFailPoint</code> constructor. We use the unchecked struct since the length of the file is a long value, and this value to too big to be assigned to an <code>int</code> data type. If we used the checked struct instead, we would have an <code>ArithmeticOverflowException</code>-type exception.</li>
				<li>Building and running the code takes hours. I recommend you build the code in <code>Release</code> mode, and then run the executable from a command window. The code will successfully build up the CSV file and save it. When the file contents are read all at once, they will generate an <code>OutOfMemoryException</code>-type exception. Then, the program will do a precheck prior to loading the file and will fail before the file read is attempted with a more detailed <code>OutOfMemoryException</code>-type exception.</li>
			</ol>
			<p>Predicting memory exceptions saves time and improves application performance, as you are not wasting CPU cycles and memory performing an operation that is ultimately going to fail.</p>
			<p>We have seen how easy<a id="_idIndexMarker299"/> it is for an application to run out of memory and how<a id="_idIndexMarker300"/> we can predict and prevent memory exceptions. So, let’s now move on to discuss strong and weak references.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Understanding long and short weak references</h1>
			<p>In the .NET runtime, there are two types of references: <strong class="bold">long weak references</strong> and <strong class="bold">short weak references</strong>. These are described in more detail here:</p>
			<ul>
				<li><code>Finalize()</code> method has been called on an object, a long weak reference<a id="_idIndexMarker301"/> is retained in memory. You specify <code>true</code> in the <code>WeakReference</code> constructor to define a long reference. A long weak reference can be recreated, although its state can be unpredictable. A short weak reference will be applied when an object’s type does not have a <code>Finalize()</code> method. The weak reference will only remain until its target is collected sometime after the finalizer is run. You will need to cast the target property of a <code>WeakReference</code> constructor to the type of an object if you want to create a strong weak reference that will be reused. When the object is collected, the <code>Target</code> property will be <code>null</code>. If it is not <code>null</code>, then you can continue to use the object because the application has regained a strong reference to it.</li>
				<li><code>WeakReference</code> is a short weak reference. When the garbage collector reclaims a short weak reference, its target becomes <code>null</code>.</li>
			</ul>
			<p>A long weak reference<a id="_idIndexMarker303"/> protects referenced objects from garbage collection, and a short weak reference<a id="_idIndexMarker304"/> does not protect referenced objects from garbage collection. This means that when garbage collection executes, the long weak referenced objects will not be garbage-collected, but the short weak referenced objects will be garbage-collected. We will demonstrate this with a code example.</p>
			<p>Our code example will show both long and short weak references at work. Follow these next steps:</p>
			<ol>
				<li value="1">Start by adding a new .NET 6 console application called <code>CH04_WeakReferences</code>. Add the following class called <code>ReferenceObject</code>:<pre>internal class ReferenceObject
{
public int Id { get; set; }
public string Name { get; set; }
}</pre></li>
			</ol>
			<p>This class will be our reference object that we will be adding to two different object managers.</p>
			<ol>
				<li value="2">Add a new class called <code>LongWeakReferenceObjectManager</code>. Then, add the following list field:<pre>private readonly List&lt;ReferenceObject&gt; Objects 
= new List&lt;ReferenceObject&gt;();</pre></li>
				<li>Our read-only <code>Objects</code> list will contain several <code>ReferenceObject</code> types. Now, add the following method to add items to the list:<pre>public void Add(ReferenceObject o)
{
Objects.Add(o);
}</pre></li>
				<li>This method adds a <code>ReferenceObject</code> object to the list<a id="_idIndexMarker305"/> of reference objects. Then, the next task is to add a method<a id="_idIndexMarker306"/> that will print a list of stored objects to the console, as follows:<pre>public void ListObjects()
{
    Console.WriteLine("Long Weak Reference Objects: ");
    foreach (var reference in Objects)
        Console.WriteLine($"- {reference.Name}");
}</pre></li>
			</ol>
			<p>The <code>ListObjects()</code> method prints out the contents of the list to the console window. That concludes our <code>LongWeakReferenceObjectManager</code> class. </p>
			<ol>
				<li value="5">Now, add a class called <code>ShortWeakReferenceObjectManager</code>. At the top of the class, add the following list field:<pre>private readonly List&lt;WeakReference&lt;ReferenceObject&gt;&gt; 
  Objects 
= new List&lt;WeakReference&lt;ReferenceObject&gt;&gt;();</pre></li>
			</ol>
			<p>Notice with the list that the <code>ReferenceObject</code> object is wrapped in a <code>WeakReference</code> object.</p>
			<ol>
				<li value="6">Now, add a method to add items to the list, as follows:<pre>public void Add(ReferenceObject o)
{
Objects.Add(new WeakReference&lt;ReferenceObject&gt;(o));
}</pre></li>
			</ol>
			<p>This method wraps the passed-in <code>ReferenceObject</code> object in a <code>WeakReference</code> object and assigns it to the list. </p>
			<ol>
				<li value="7">We now add <a id="_idIndexMarker307"/>the <code>ListObjects()</code> method, as<a id="_idIndexMarker308"/> follows:<pre>public void ListObjects()
{
Console.WriteLine("Short Weak Reference Objects: ");
foreach (var reference in Objects)
{
    reference.TryGetTarget(
        out ReferenceObject referenceObject
    );
    if (referenceObject != null)
        Console.WriteLine($"- {referenceObject.Name}");
}
}</pre></li>
			</ol>
			<p>The <code>ListObjects()</code> method prints out to the console window all the weak objects that are stored in the list. Our focus now moves to the <code>Program</code> class.</p>
			<ol>
				<li value="8">Add the following two fields to the top of the <code>Program</code> class:<pre>private static readonly StrongReferenceObjectManager 
  StrongReferences = new StrongReferenceObjectManager();
private static readonly WeakReferenceObjectManager 
  WeakReferences = new WeakReferenceObjectManager();</pre></li>
			</ol>
			<p>These are our read-only strong and weak object managers that we will use to demonstrate strong and weak references in action, with regard to the garbage collector.</p>
			<ol>
				<li value="9">Update the <code>Main(string[] _)</code> method by adding the following three method calls:<pre>TestLongWeakReferences();
TestStrongReferences();
TestShortWeakReferences();
ProcessReferences();</pre></li>
			</ol>
			<p>The <code>TestLongWeakreferences()</code>, <code>TestStrongReferences()</code>, and <code>TestWeakReferences()</code> methods<a id="_idIndexMarker309"/> build up our lists of strong referenced objects<a id="_idIndexMarker310"/> and weak referenced objects respectively. </p>
			<ol>
				<li value="10">Add the <code>TestStrongReferences()</code> method, as follows:<pre>private static void TestStrongReferences()
{
var o1 = new ReferenceObject() { 
    Id = 1, Name = "Object 1" 
};
var o2 = new ReferenceObject() { 
    Id = 2, Name = "Object 2" 
};
var o3 = new ReferenceObject() { 
    Id = 3, Name = "Object 3" 
};
StrongReferences.Add(o1);
StrongReferences.Add(o2);
StrongReferences.Add(o3);
}</pre></li>
			</ol>
			<p>This method adds three <code>ReferenceObject</code> objects to the <code>StrongReferences</code> list. </p>
			<ol>
				<li value="11">Next, add<a id="_idIndexMarker311"/> the <code>TestWeakReferences()</code> method, as<a id="_idIndexMarker312"/> follows:<pre>private static void TestWeakReferences()
{
var o1 = new ReferenceObject() { 
    Id = 1, Name = "Object 4" 
};
var o2 = new ReferenceObject() { 
    Id = 2, Name = "Object 5" 
};
var o3 = new ReferenceObject() { 
    Id = 3, Name = "Object 6" 
};
WeakReferences.Add(o1);
WeakReferences.Add(o2);
WeakReferences.Add(o3);
o1 = null;
o2 = null;
o3 = null;
}</pre></li>
			</ol>
			<p>This method adds three weak referenced objects to the <code>WeakReferences</code> list and then sets the objects it instantiated to <code>null</code> so that they will be garbage-collected.</p>
			<ol>
				<li value="12">Finally, add the <code>ProcessReferences()</code> method, as follows:<pre>private static void ProcessReferences()
{
int x = 0;
while(x &lt; 10)
{
    StrongReferences.ListObjects();
    WeakReferences.ListObjects();
    Thread.Sleep(2000);
    GC.Collect();
    x++;
}
}</pre></li>
			</ol>
			<p>The <code>ProcesseReferences()</code> method<a id="_idIndexMarker313"/> loops 10 times. During each<a id="_idIndexMarker314"/> iteration, the <code>ListObjects()</code> method is called on the <code>StrongReferences</code> and <code>WeakReferences</code> fields. The program sleeps for 2 seconds, and then the garbage collector is executed manually. </p>
			<ol>
				<li value="13">It is now time to run the program. When you run the program, you should see the following output:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16617_Figure_4.1.jpg" alt="Figure 4.1 – Weak references’ project output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Weak references’ project output</p>
			<p>As you can see from <em class="italic">Figure 4.1</em>, on the first iteration<a id="_idIndexMarker315"/> of the loop, both strong and weak reference objects exist, and the names<a id="_idIndexMarker316"/> of those objects are printed in the console window. However, after garbage collection is called, the weak references are garbage-collected, and so, from the second iteration onward, only the strongly referenced objects remain in memory.</p>
			<p>A weakly referenced object’s lifespan is not extended as it is for strong references. This means that they can be garbage-collected once all strong references have gone out of scope.</p>
			<p>Objects that are large but cheap to rehydrate on-demand benefit from weak references.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To improve the performance of your applications, avoid using weak references on many small objects as they can take up more memory space than the objects they wrap, thus adding performance overhead. But if you are working with many large expensive objects, using cached weak references may help improve your application’s performance.</p>
			<p>That concludes<a id="_idIndexMarker317"/> our look at strong<a id="_idIndexMarker318"/> and weak references. Let’s move our focus and attention to finalization in C#.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Finalization</h1>
			<p>In C#, there is no direct way of destroying<a id="_idIndexMarker319"/> an object. The nearest thing we have is <strong class="bold">finalization</strong>. A finalizer in C# is the C# equivalent of a destructor in C++. Except in C#, you have no control over if and when it will run this down to the garbage collector to make that decision.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The terms <em class="italic">finalizer</em> and <em class="italic">destructor</em> are used interchangeably in C#. A finalizer is where the user-defined finalizer code is run. After the finalizer<a id="_idIndexMarker320"/> in an object is run, it is once again considered alive and the garbage collector will then finally collect the object. This means an object is actually marked “<code>collectable</code>” twice if it has a finalizer defined.</p>
			<p>Finalization is used by an object to release resources and perform other housekeeping operations prior to the object being garbage-collected. Cleanup operations to release unmanaged resources held by an object can be performed by overriding the protected <code>Finalize()</code> method.</p>
			<p>You have to override the <code>Finalize()</code> method for the garbage collector to mark types derived from <code>Object</code> for finalization. When you override the <code>Finalize()</code> method, an entry for the instance is placed in a finalization queue. Before reclaiming memory, the <code>Finalize()</code> method is called for each object instance in the finalization queue. Once an object’s <code>Finalize()</code> method has been run, then its memory can be reclaimed by the garbage collector.</p>
			<p>The <code>Finalize()</code> method is not called if <code>GC.SupressFinalize()</code> has been called during the disposing<a id="_idIndexMarker321"/> of the object’s resources, but the <code>Finalize()</code> method will be called automatically when<a id="_idIndexMarker322"/> an object is discovered to be inaccessible, and during <strong class="bold">application domain</strong> (<strong class="bold">AppDomain</strong>) shutdown (even if the object is accessible).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">AppDomains isolate applications from<a id="_idIndexMarker323"/> one another, but their usage is very expensive. In .NET 5+, some AppDomain <code>AssemblyLoadContext</code> class for dynamic assembly loading.</p>
			<p><code>Finalize()</code> methods only run once unless <code>GC.SuppressFinalize()</code> has not been called and <code>GC.ReRegisterForFinalize()</code> is called; then, the <code>Finalize()</code> method can be called again.</p>
			<p>When overriding <code>Finalize()</code>, there are a few things to keep in mind, as follows:</p>
			<ul>
				<li>You have no control over when the <code>Finalize()</code> method will be called.</li>
				<li>To guarantee the release of managed and unmanaged resources within your instance, implement the <code>IDisposable.Dispose()</code> method using the <code>IDisposable</code> pattern. There is no guarantee of the order in which finalizers will run. </li>
				<li>Finalizers run on an unspecified thread, and they implicitly call the <code>Finalize()</code> method on the base class.</li>
			</ul>
			<p>To avoid the need to override the <code>Finalize()</code> method and for us to ensure the cleanup of our managed and unmanaged resources, we will look at implementing the <code>IDisposable</code> pattern.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Using finalization</h2>
			<p>We are going to write a sample<a id="_idIndexMarker324"/> application that demonstrates the use of <code>Finalize()</code>. Then, we will modify the program to implement the <code>IDisposable</code> pattern and suppress the call to <code>Finalize()</code>, while ensuring the deterministic release of our managed and unmanaged resources. Follow these next steps:</p>
			<ol>
				<li value="1">Start a new .NET 6 console application called <code>CH04_Finalization</code>. Add a new internal class called <code>Product</code>. Then, add the following properties:<pre>public int Id { get; set; }
public string Name { get; set; }
public string Description { get; set; }
public decimal UnitPrice { get; set; }</pre></li>
				<li>We have created four properties—<code>Id</code>, <code>Name</code>, <code>Description</code>, and <code>UnitPrice</code>. Now, add the constructor, as follows:<pre>public Product()
{
Console.WriteLine("Product constructor.");
}</pre></li>
				<li>Our constructor writes a message to the console window so that we know we have entered the constructor. Next, add the finalizer, as follows:<pre>~Product()
{
Console.WriteLine("Product finalizer.");
}</pre></li>
				<li>In our finalizer, we write a message to the console window so that we know our finalizer has been called. For the last bit of code in our <code>Product</code> class, we will override the <code>ToString()</code> method, as follows:<pre>public override string ToString()
{
  return $"Id: {Id}, Name: {Name},
  Description: {Description}, Unit Price: {UnitPrice}";
}</pre></li>
				<li>Our <code>ToString()</code> method returns a string<a id="_idIndexMarker325"/> that outputs the values of each of the properties of the <code>Product</code> class. For now, unless stated otherwise, the following code is to be added to the <code>Program</code> class. Add the following variable:<pre>private static Product _product;</pre></li>
				<li>The <code>_product</code> variable will be used to store an instance of our <code>Product</code> class. Update the <code>Main</code> method, as follows:<pre>static void Main(string[] _)
{
InstantiateObject();
PrintObjectData();
RemoveObjectReference();
RunGarbageCollector();
InstantiateLocalObject();
RunGarbageCollector();
DisplayGeneration(_product);
RemoveObjectReference();
RunGarbageCollector();
}</pre></li>
				<li>As you can see, we have several methods that instantiate the object, print object data, remove object<a id="_idIndexMarker326"/> references, display object generations, and run the garbage collector. We will now add each of the methods in turn. Add the <code>InitiateObject()</code> method, as follows:<pre>private static void InstantiateObject()
{
  Console.WriteLine("Instantiating Product.");
  _product = new Product()
{
    Id = 1,
    Name = "Polly Parrot",
    Description = "Cudly child's toy.",
    UnitPrice = 7.99M
};
}</pre></li>
				<li>In this method, we write a console window message, create a new product, and assign it to the <code>_product</code> member variable. Now, we will add the <code>PrintObjectData()</code> method, as follows:<pre>private static void PrintObjectData()
{
Console.WriteLine(_product.ToString());
}</pre></li>
				<li>Here, we are printing the contents of the <code>Product</code> class to the console window. Next, we will write the <code>RemoveObjectReference()</code> method, as follows:<pre>private static void RemoveObjectReference()
{
    _product = null;
}</pre></li>
				<li>We are setting the <code>Product</code> object to <code>null</code>. This removes references to the object and makes it eligible<a id="_idIndexMarker327"/> for garbage collection. We now add a method to call the garbage collection, as follows:<pre>private static void RunGarbageCollector()
{
    GC.Collect();
}</pre></li>
				<li>In this method, we call the garbage collector, as follows:<pre>private static void InstantiateLocalObject()
{
      var product = new Product()
      {
          Id = 2,
          Name = "Cute Kittie",
          Description = "Cudly child's toy.",
          UnitPrice = 5.75M
      };
      DisplayGeneration(product);
      _product = product;
      GC.Collect();
}</pre></li>
				<li>In this method, we create a local object. Then, we call the method to display the current generation. We then assign<a id="_idIndexMarker328"/> the local product to the member product, followed by a call to the garbage collector. Our final method, for now, is the <code>DisplayGeneration(Product product)</code> method, as illustrated in the following code snippet:<pre>private static void DisplayGeneration(Product product)
{
      Console.WriteLine($"local product: 
          generation {GC.GetGeneration(product)}");
}</pre></li>
				<li>This method prints out the generation of the product passed into it. Run the code. You should see the following output:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.2.jpg" alt="Figure 4.2 – The finalization project output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – The finalization project output</p>
			<p>As you can see, our code demonstrates<a id="_idIndexMarker329"/> construction and finalization. We have both generation 0 and generation 2 code, and both our constructor and finalizer methods do get called. Now, we will look at implementing <code>IDisposable</code> to make the cleanup of our code more deterministic so that <code>Finalize()</code> does not need to be called.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Implementing the IDisposable pattern</h1>
			<p>In this section, we will implement<a id="_idIndexMarker330"/> a reusable <code>IDisposable</code> pattern. We will have a base class that implements <code>IDisposable</code>. This base class will provide two methods that subclasses can override. One method will be for cleaning up managed<a id="_idIndexMarker331"/> resources, and the other method will be for disposing of unmanaged resources. For us to implement the <code>IDisposable</code> pattern, proceed as follows:</p>
			<ol>
				<li value="1">Add a new class called <code>DisposableBase</code> that implements <code>IDisposable</code>, as follows:<pre>public class DisposableBase : IDisposable
{
      public void Dispose()
      {
         Dispose(true);
      }
      private void Dispose(bool disposing)
      {
          if (disposing)
          GC.SuppressFinalize(this);
          ReleaseManagedResources();
          ReleaseUnmanagedResources();
      }
protected virtual void ReleaseManagedResources(){} 
protected virtual void ReleaseUnmanagedResources(){}
}</pre></li>
			</ol>
			<p>This class acts as a base class that can be inherited. It implements the <code>IDisposable</code> interface and calls two virtual methods called <code>ReleaseManagedResources()</code> and <code>ReleaseUnmanagedResources()</code> that will be overridden in the subclass.</p>
			<ol>
				<li value="2">Move the code from <code>Main</code> into a new <a id="_idIndexMarker332"/>method called <code>Finalization()</code>. Then, modify <code>Main</code>, as follows:<pre>static void Main(string[] _)
{
      Finalization();
      Disposing();
}</pre></li>
			</ol>
			<p>We are calling two methods. The <code>Finalization()</code> method demonstrates using finalization to clean up resources that you have no control over when finalization will be called by the garbage collector. <code>Disposing()</code> demonstrates the determined disposing of managed and unmanaged resources, with finalization being suppressed so that it is not called by the garbage collector. Your <code>Finalization()</code> method should look like this:</p>
			<pre>private static void Finalization()
{
      Console.WriteLine("--- Finalization ---");
      InstantiateObject("Finalization");
      PrintObjectData();
      RemoveObjectReference();
      RunGarbageCollector();
      InstantiateLocalObject("Finalization");
      RunGarbageCollector();
      DisplayGeneration(_product);
      RemoveObjectReference();
      RunGarbageCollector();
}</pre>
			<p>We are passing <code>“Finalization”</code> into the <code>InstantiateObject(string cleanUpMethod)</code> and <code>InstantiateLocalObject(string cleanUpMethod)</code> methods so that we know the objects being finalized<a id="_idIndexMarker333"/> were instantiated in our <code>Finalization()</code> method.</p>
			<ol>
				<li value="3">Add a new method called <code>Disposing()</code>, as follows:<pre>private static void Disposing()
{
Console.WriteLine("--- Disposing ---");
InstantiateObject("Disposing");
PrintObjectData();
DisposeOfObject();
InstantiateLocalObject("Disposing");
DisplayGeneration(_product);
DisposeOfObject();
RunGarbageCollector();
}</pre></li>
				<li>In the <code>Disposing()</code> method, we write a message to the console identifying that the <code>Disposing()</code> method is running. We then call <code>InstantiateObject(“Disposing”)</code>. Next, we print the object data and dispose of the object. Then, we instantiate a local object that will get assigned to the member variable. The generations of the local and member variables are printed to the console window, and then we dispose of the object and call garbage collection.</li>
				<li>Add the <code>DisposeofObject()</code> method, as follows:<pre>private static void DisposeOfObject()
{
      _product.Dispose();
}</pre></li>
				<li>The <code>DisposeOfObject()</code> method<a id="_idIndexMarker334"/> calls the <code>Dispose()</code> method on the <code>_product</code> object to free up resources. Update the <code>Product</code> class, as follows:<pre>private string _cleanUpMethod;
public Product(string cleanUpMethod)
{
  Console.WriteLine("Product constructor.");
  _cleanUpMethod = cleanUpMethod;
}
~Product()
{
  Console.WriteLine($"Product destructor: {_
    cleanUpMethod}.");
}</pre></li>
				<li>We are storing the name of the cleanup method we are using so that when the finalizer is called, we will know the method of cleanup the object uses. Modify the <code>InstantiateObject()</code> method, as follows:<pre>private static void InstantiateObject(string 
    cleanUpMethod)
{
Console.WriteLine("Instantiating Product.");
_product = new Product(cleanUpMethod)
{
           Id = 1,
           Name = "Polly Parrot",
           Description = "Cudly child's toy.",
           UnitPrice = 7.99M
};
}</pre></li>
				<li>We are assigning the method<a id="_idIndexMarker335"/> of cleanup to the <code>Product</code> object. Do the same with the <code>InstantiateLocalObject()</code> method so that the code looks like this:<pre>private static void InstantiateLocalObject(string 
    cleanUpMethod)
{
var product = new Product(cleanUpMethod)
{
    Id = 2,
    Name = "Cute Kittie",
    Description = "Cudly child's toy.",
    UnitPrice = 5.75M
};
DisplayGeneration(product);
_product = product;
}</pre></li>
				<li>Again, we are assigning the method of cleanup to the <code>Product</code> object. Update <code>Product</code> to inherit from <code>DisposableBase</code>. Then, add the <code>ReleaseManagedResources()</code> method to the <code>Product</code> class, as follows:<pre>protected override void ReleaseManagedResources()
{
base.ReleaseManagedResources();
Console.WriteLine("Releasing managed resources.");
}</pre></li>
				<li>This method will be used to release managed<a id="_idIndexMarker336"/> resources. Now, add the <code>ReleaseUnmanagedResources()</code> method to the <code>Product</code> class, as follows:<pre>protected override void ReleaseUnmanagedResources()
{
base.ReleaseUnmanagedResources();
Console.WriteLine("Releasing unmanaged resources.");
}</pre></li>
			</ol>
			<p>This method will be used for cleaning up unmanaged resources.</p>
			<ol>
				<li value="11">Run the code and you should see the output, as shown here: </li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.3.jpg" alt="Figure 4.3 – The output of finalization and disposing code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – The output of finalization and disposing code</p>
			<p>As you can see, the finalization code calls the finalizer, but the methods used for releasing managed and unmanaged<a id="_idIndexMarker337"/> resources explicitly do not get called. Objects also survive the generation 0 garbage collection. Conversely, the disposing code explicitly releases the managed and unmanaged code, and finalization being suppressed is not called by the garbage collector. No objects in our example survive generation 0 garbage collection.</p>
			<p>Another way to implicitly call <code>Dispose()</code> on disposable classes is to use a <code>using</code> statement. Here is an example, as can be seen in the <code>Program</code> class:</p>
			<pre class="source-code">private static void UsingDispose()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      Console.WriteLine("--- UsingDispose() ---");</pre>
			<pre class="source-code">      using (var product = new Product("using")</pre>
			<pre class="source-code">          {</pre>
			<pre class="source-code">              Id = 2,</pre>
			<pre class="source-code">              Name = "Cute Kittie",</pre>
			<pre class="source-code">              Description = "Cudly child's toy.",</pre>
			<pre class="source-code">              UnitPrice = 5.75M</pre>
			<pre class="source-code">          }</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          DisplayGeneration(product);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">}</pre>
			<p>The <code>using</code> statement is used with disposable objects. When the code block completes, the object is automatically disposed of. The object’s generation is 0. Add a call to <code>UsingDispose()</code> in the <code>Main</code> method.</p>
			<p>Well, you have seen how to use finalization<a id="_idIndexMarker338"/> and implement the <code>IDisposable</code> pattern in relation to the garbage collector. Now, let’s look at how we can avoid memory leaks in C#.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Preventing memory leaks</h1>
			<p>In this section, we will understand<a id="_idIndexMarker339"/> the issues around COM objects and what can lead to memory leaks using COM objects. We will look at interoping with the Excel COM library for our example code. We will see how instances of Excel are kept alive after our code exits. By using Windows Task Manager, we will be able to see instances of Excel being generated. Our Excel code will be developed in such a way as to avoid memory leaks and ensure that every Excel instance is closed when our code has completed running so that no instances of Excel remain in memory.</p>
			<p>We will then move on to look at how using events can be a common source of memory leaks at runtime and how we can avoid them. Using JetBrains dotMemory, we will profile a runtime build executable of our program code. As the code is running, we will generate snapshots. As the profiler runs, you will see the memory usage gradually climbing. Clicking on the snapshots will display detailed memory information for our running profile. We will also be able to see if we have any memory leaks, and will see that we have event-based memory leaks. In this section, we will also be looking at anonymous methods and weak references.</p>
			<p>The outcome of this section will be that you understand how COM and the use of events, if not handled correctly, can introduce memory exceptions, and you will see how you can write your code so that no memory exceptions are generated.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Understanding the dangers of using Marshal.ReleaseComObject</h2>
			<p>The Visual Studio team ran into problems<a id="_idIndexMarker340"/> with Visual Studio 2010. Their problems arose due to rewriting native C++ components in managed C# code. The components that were rewritten as managed C# code were the window manager, command bars, and text editor.</p>
			<p>With the release of Visual Studio 2010, there were two extension enablers—the existing extension mechanism that uses COM interfaces for older extensions, and a new managed programming model.</p>
			<p>In order for the <code>RuntimeCallableWrapper</code> or <strong class="bold">RCW</strong>. An RCW acts as a bridge between the worlds<a id="_idIndexMarker342"/> of COM and managed code.</p>
			<p>All COM components<a id="_idIndexMarker343"/> must, at the very minimum, implement the <code>IUnknown</code> interface. When an object that implements the <code>IUnknown</code> interface enters the managed runtime, it is wrapped in an RCW. An RCW is, therefore, a regular managed object that references native code that implements the <code>IUnknown</code> interface.</p>
			<p>There are two types of objects that can reference an RCW in a managed .NET computer program: COM objects and managed objects. This is the point at which issues can start to present themselves.</p>
			<p>At this point, we will now consider a typical scenario that will result in memory issues between COM objects and managed objects.</p>
			<p>The <code>DatabaseSearch</code> component<a id="_idIndexMarker344"/> begins the <code>Find</code> operation by asking the <code>DatabaseManager</code> service. A valid instance of <code>IDatabaseManager</code> is returned to the <code>DatabaseSearch</code> component. The <code>DatabaseManager</code> component returned to the <code>DatabaseSearch</code> component is a native COM component. Because the <code>DatabaseManager</code> component is a native COM component, it is wrapped in an RCW by the runtime. The <code>DatabaseSearch</code> component does not know or care whether the <code>DatabaseManager</code> component is a native COM component or managed code component because all it sees is the <code>IDatabaseManager</code> interface. The <code>Find</code> operation continues with the <code>DatabaseSearch</code> component making various calls through <code>IDatabaseManager</code> to complete its task. Once the <code>Find</code> operation is completed, it is exited. Since <code>IDatabaseManager</code> is an RCW, it has the same lifetime semantics as managed objects. As a result, the <code>IDatabaseManager</code> component will be cleaned up when the garbage collector runs. The garbage collector may not run for a long time if there is not a lot of memory pressure, and there is the possibility that it may not even run. At this point, we end up with a native and managed memory clash because of the different ways in which they both manage system memory. The managed <code>DatabaseSearch</code> component is finished with the <code>DatabaseManager</code> component until it needs it again. If there are no references to the <code>DatabaseManager</code> component, then this would be a good time for the garbage collector to run and remove <code>DatabaseManager</code>. Any component written in native code would, as soon as the <code>Find</code> method is exited, call <code>Release</code> on <code>IDatabaseManager</code>. This would indicate that the reference to <code>IDatabaseManager</code> is no longer needed. Since the final <code>Release</code> is not being called until the next garbage collection, it appears that there is a memory leak with <code>IDatabaseManager</code>. This is an example<a id="_idIndexMarker345"/> of non-deterministic finalization. The inability to determine when an object should be garbage-collected is known as non-deterministic finalization. The <code>Finalize()</code> method is executed on a special<a id="_idIndexMarker346"/> thread allocated by the garbage collector whenever the object it belongs to is being garbage-collected and finalization has not been suppressed when there are non-managed resources to be disposed of.</p>
			<p>This scenario that we have looked at would result in expensive objects being reported as leaked objects, and this would be during application shutdown.</p>
			<p>The natural solution would be to call <code>Marshal.ReleaseComObject(object)</code>. This call would be made as soon as the expensive object is no longer needed. In our scenario, it would be when <code>DatabaseManager</code> is no longer needed. This call causes the RCW to be released, and the internal reference count is decremented by one. At this point, the underlying COM object is usually released.</p>
			<p>However, calling <code>Marshal.ReleaseComObject(object)</code> can be dangerous.</p>
			<p>Consider that as part of a migration away from COM, <code>DatabaseManager</code> has been written in managed code. The <code>DatabaseSearch</code> managed component requests the <code>DatabaseManager</code> component via the GSP. An <code>IDatabaseManager</code> instance is returned to the <code>DatabaseSearch</code> component. The instance returned is an RCW that wraps a COM object. As a result, we have double<a id="_idIndexMarker347"/> wrapping that consists of an RCW wrapped around a <code>Find</code> operation exits that problems arise. The <code>DatabaseSearch</code> component still calls <code>Marshall.ReleaseComObject(object)</code> for the RCW of <code>DatabaseManager</code> when terminating. </p>
			<p>This results in an <code>ArgumentException</code>-type exception being raised. The exception message generated is <code>“The object’s type must be _ComObject or derived from _ComObject.”</code> When this happens, remove the call to <code>Marshal.ReleaseComObject(object)</code>. An alternative is to call <code>Marshal.IsComObject</code> before <code>ReleaseComObject</code> is called.</p>
			<p>Calling <code>Marshal.IsComObject</code> causes further problems. The <code>DatabaseManager</code> RCW has been declared as being no longer needed, but the problem is that the <code>DatabaseManager</code> RCW is still a valid object, meaning that it may still be reachable by managed objects. The next time the object is accessed, if reachable from managed code, an <code>InvalidComObjectException</code>-type exception will be raised by the CLR, stating: <code>“COM object that has been separated from its underlying RCW cannot be used.”</code></p>
			<p>If the COM components used by our <code>DatabaseManager</code> RCW are cached by managed code instead of being returned<a id="_idIndexMarker348"/> to the GSP each time our <code>DatabaseManager</code> component is requested, our cached COM components will be checked first. This is done to avoid costly calls across the boundary between managed and unmanaged code. If several components then request the same COM component, they will each receive the same RCW. </p>
			<p>The problem here is that the component calling the RCW that has had <code>ReleaseComObject</code> called will often be blamed as the component that generated the exception. But this is not the case—it is the component that called <code>ReleaseComObject</code> that is the component at fault, which in our scenario would be the <code>DatabaseSearch</code> component.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is recommended by Microsoft developers, especially those on the Visual Studio team, that unless you are 100% certain that there are no managed code items that have access to the RCW, you do not call <code>Marshal.ReleaseComObject</code>.</p>
			<p>We will delve deeper into what we have just been discussing by looking at an Excel example.</p>
			<h3>Using the Microsoft Excel 16.0 Object Library in .NET 6</h3>
			<p>We are going to be looking at COM<a id="_idIndexMarker349"/> interoperability in .NET 6 in this section, by referencing<a id="_idIndexMarker350"/> the Microsoft Excel 16.0 Object Library. This library is a COM library. You will see how to use Excel to create a new application, modify it, and save it. When the first example is run a few times, you will see that your code does not fail. But in Task Manager, each time the method is run, another instance of Excel will remain open, as seen in Windows Task Manager. Then, we will move on to see how we can correctly dispose of COM objects<a id="_idIndexMarker351"/> so that instances of Excel <a id="_idIndexMarker352"/>are not kept open when our applications complete. Let’s start by viewing what happens when we don’t release Excel COM objects.</p>
			<h4>Investigating what happens when Excel COM objects are not released</h4>
			<p>In this section, we will create<a id="_idIndexMarker353"/> a spreadsheet, add data to it, and then save the file. This will reveal memory issues that arise from using Excel and not cleaning up properly after ourselves when we have finished using Excel. We will also see how to use Excel and clean up after ourselves so that we prevent memory issues through using Excel.</p>
			<p>Add a COM reference to the <code>CH04_PreventingMemoryLeaks</code> project for the <em class="italic">Microsoft Excel 16.0 Object Library</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you add a COM reference to your project, you will have IntelliSense available to you. But when you come to run your successfully compiled program, when it attempts to create an Excel application, it will raise a <code>FileNotFoundException</code>-type exception. Therefore, you need to set the values for <code>EmbedInteropTypes</code> and <code>Private</code> to <code>true</code>.</p>
			<p>Since a <code>FileNotFoundException</code>-type exception is the last thing we need, edit your project file and then update the <code>COMReference</code> section, as follows:</p>
			<pre class="source-code">&lt;ItemGroup&gt;</pre>
			<pre class="source-code">      &lt;COMReference Include="Microsoft.Office.Excel.dll"&gt;</pre>
			<pre class="source-code">          &lt;WrapperTool&gt;tlbimp&lt;/WrapperTool&gt;</pre>
			<pre class="source-code">          &lt;VersionMinor&gt;9&lt;/VersionMinor&gt;</pre>
			<pre class="source-code">          &lt;VersionMajor&gt;1&lt;/VersionMajor&gt;</pre>
			<pre class="source-code">          &lt;Guid&gt;00020813-0000-0000-c000-000000000046&lt;/Guid&gt;</pre>
			<pre class="source-code">          &lt;Lcid&gt;0&lt;/Lcid&gt;</pre>
			<pre class="source-code">          &lt;Isolated&gt;false&lt;/Isolated&gt;</pre>
			<pre class="source-code">          <strong class="bold">&lt;EmbedInteropTypes&gt;True&lt;/EmbedInteropTypes&gt;</strong></pre>
			<pre class="source-code">      <strong class="bold">    &lt;Private&gt;true&lt;/Private&gt;</strong></pre>
			<pre class="source-code">    &lt;/COMReference&gt;</pre>
			<pre class="source-code">  &lt;/ItemGroup&gt;</pre>
			<p>This will ensure that we don’t experience<a id="_idIndexMarker354"/> the <code>FileNotFoundException</code>-type exception. Add a new <code>UsingExcel</code> class to the project, and then add the following <code>using</code> statements:</p>
			<pre class="source-code">using Microsoft.Office.Interop.Excel;</pre>
			<pre class="source-code">using System;</pre>
			<pre class="source-code">using System.Diagnostics;</pre>
			<pre class="source-code">using System.IO;</pre>
			<pre class="source-code">using System.Runtime.InteropServices;</pre>
			<pre class="source-code">using Excel = Microsoft.Office.Interop.Excel;</pre>
			<p>Now, add the <code>RunExcelExamples()</code> method, as follows:</p>
			<pre class="source-code">public void RunExcelExamples()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      for (int i = 0; i &lt; 10; i++)</pre>
			<pre class="source-code">          NotReleasingExcelComObjects();</pre>
			<pre class="source-code">      for (int i = 0; i &lt; 10; i++)</pre>
			<pre class="source-code">          ReleasingExcelComObjects();</pre>
			<pre class="source-code">}</pre>
			<p>This method calls two methods. It calls each of these methods 10 times and then exits. Let’s add the <code>NotReleasingExcelComObjects()</code> method, as follows:</p>
			<pre class="source-code">private static void NotReleasingExcelComObjects()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      string filename = @"C:\Temp\BucketList.xlsx";</pre>
			<pre class="source-code">      Excel.Application application = new Excel.Application();</pre>
			<pre class="source-code">      application.Visible = false;</pre>
			<pre class="source-code">      Excel.Workbook workbook = application.Workbooks.Add();</pre>
			<pre class="source-code">      Excel.Sheets sheets = workbook.Sheets;</pre>
			<pre class="source-code">      Excel.Worksheet worksheet =(Worksheet)sheets</pre>
			<pre class="source-code">      .Add(sheets[1], Type.Missing, Type.Missing, </pre>
			<pre class="source-code">            Type.Missing);</pre>
			<pre class="source-code">      worksheet.Range["A1"].Value = "Bucket List";</pre>
			<pre class="source-code">      worksheet.Range["A2"].Value = "Visit New Zealand";</pre>
			<pre class="source-code">      worksheet.Range["A1"].Value = "Visit Australia";</pre>
			<pre class="source-code">      if (File.Exists(filename))</pre>
			<pre class="source-code">          File.Delete(filename);</pre>
			<pre class="source-code">      workbook.SaveAs(filename);</pre>
			<pre class="source-code">      workbook.Close();</pre>
			<pre class="source-code">      application.Quit();</pre>
			<pre class="source-code">}</pre>
			<p>This method declares a <code>filename</code> string. It then instantiates a new Excel application that is not visible. It then<a id="_idIndexMarker355"/> adds a column header called “<code>Bucket List”</code>, and adds two items to that bucket list column in the rows below. It then checks if the file exists. If the file does exist, then it is deleted. The workbook is then saved and closed, and the Excel application is exited. Comment out the following lines from the <code>RunExcelExamples()</code> method:</p>
			<pre class="source-code">      for (int i = 0; i &lt; 10; i++)</pre>
			<pre class="source-code">          ReleasingExcelComObjects();</pre>
			<p>If you then save your project and run it, you will find that once the program exits, you are left with multiple Excel processes. Each of these processes takes up memory. The following screenshot shows Excel processes that remain in memory after our program exits:</p>
			<div><div><img src="img/B16617_Figure_4.4.jpg" alt="Figure 4.4 – Windows Task Manager displaying Excel processes no longer in use using up memory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Windows Task Manager displaying Excel processes no longer in use using up memory</p>
			<p>As you can see, these Excel processes<a id="_idIndexMarker356"/> that remain in memory after our program finishes are using up 367.6 <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>) of RAM, which is the combined sum of all Excel processes’ RAM. If this program in its current form were to be run multiple times, you would eventually run out of memory, as the Excel processes left running in memory constitute a memory leak. Each time the program runs, you are using up another 367 MB of RAM, or thereabouts. Eventually, the amount of memory available will not be enough, and you will end up with an out-of-memory exception.</p>
			<p>The following screenshot shows the display in Task Manager after the program has been run once:</p>
			<div><div><img src="img/B16617_Figure_4.5.jpg" alt="Figure 4.5 – Windows Task Manager after the program has been run once&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Windows Task Manager after the program has been run once</p>
			<p>From <em class="italic">Figure 4.5</em>, we can see that<a id="_idIndexMarker357"/> we are using 7.4 GB (793 MB), with 8.5 GB RAM still available to us. Run the program through a number of times continually. Each time the program is run, you will see the compressed memory rise and the available memory fall. At no point does the memory appear to be reclaimed, as shown in the following screenshot: </p>
			<div><div><img src="img/B16617_Figure_4.6.jpg" alt="Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished available memory after multiple program runs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished available memory after multiple program runs</p>
			<p>After multiple continuous runs<a id="_idIndexMarker358"/> of our program, we can see that our <strong class="bold">In use (Compressed)</strong> memory has gone from 7.4 GB (793 MB) to 10.9 GB (799 MB) and our available memory has gone from 8.5 GB to 4.9 GB. This is clearly a problem that needs to be addressed, but how? </p>
			<p>This is where the <code>ReleasingExcelComObjects()</code> method shown here comes in:</p>
			<pre class="source-code">[System.Diagnostics.CodeAnalysis SuppressMessage</pre>
			<pre class="source-code">  ("Interoperability","CA1416:Validate platform compatibility",</pre>
			<pre class="source-code">    Justification = "Windows only code.")]</pre>
			<pre class="source-code">private static void ReleasingExcelComObjects()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      Excel.Application application = null;</pre>
			<pre class="source-code">      Excel.Workbooks workbooks = null;</pre>
			<pre class="source-code">      Excel.Workbook workbook = null;</pre>
			<pre class="source-code">      Excel.Sheets worksheets = null;</pre>
			<pre class="source-code">      Excel.Worksheet worksheet = null;</pre>
			<pre class="source-code">      Excel.Range range = null;</pre>
			<pre class="source-code">      Try</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          string filename = @"C:\Temp\BucketList.xlsx";</pre>
			<pre class="source-code">          application = new Excel.Application();</pre>
			<pre class="source-code">          application.Visible = false;</pre>
			<pre class="source-code">          workbooks = application.Workbooks;</pre>
			<pre class="source-code">          workbook = workbooks.Add();</pre>
			<pre class="source-code">          worksheets = workbook.Sheets;</pre>
			<pre class="source-code">          worksheet = (Worksheet)worksheets.Add(worksheets[1], </pre>
			<pre class="source-code">              Type.Missing, Type.Missing, Type.Missing);</pre>
			<pre class="source-code">          range = worksheet.Range["A1"];</pre>
			<pre class="source-code">          range.Value = "Bucket List";</pre>
			<pre class="source-code">          range = worksheet.Range["A2"];</pre>
			<pre class="source-code">          range.Value = "Visit New Zealand";</pre>
			<pre class="source-code">          range = worksheet.Range["A3"];</pre>
			<pre class="source-code">          range.Value = "Visit Australia";</pre>
			<pre class="source-code">          if (File.Exists(filename))</pre>
			<pre class="source-code">              File.Delete(filename);</pre>
			<pre class="source-code">          workbook.SaveAs(filename);</pre>
			<pre class="source-code">          workbook.Close();</pre>
			<pre class="source-code">          application.Quit();</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      Finally</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          if (range != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(range);</pre>
			<pre class="source-code">          if (worksheet != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(worksheet);</pre>
			<pre class="source-code">          if (worksheets != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(worksheets);</pre>
			<pre class="source-code">          if (workbook != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(workbook);</pre>
			<pre class="source-code">          if (workbooks != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(workbooks);</pre>
			<pre class="source-code">          if (application != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(application);</pre>
			<pre class="source-code">          range = null;</pre>
			<pre class="source-code">          worksheet = null;</pre>
			<pre class="source-code">          worksheets = null;</pre>
			<pre class="source-code">          workbook = null;</pre>
			<pre class="source-code">          worksheets = null;</pre>
			<pre class="source-code">          application = null;</pre>
			<pre class="source-code">          GC.Collect();</pre>
			<pre class="source-code">          GC.WaitForPendingFinalizers();</pre>
			<pre class="source-code">          Process[] processes = </pre>
			<pre class="source-code">              Process.GetProcessesByName("EXCEL");</pre>
			<pre class="source-code">          foreach (Process process in processes)</pre>
			<pre class="source-code">              process.Kill();</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">}</pre>
			<p>This rather lengthy method<a id="_idIndexMarker359"/> does what we need Excel to do—it releases the Excel COM objects, sets the managed objects to <code>null</code>, runs the garbage collector, and then terminates all running Excel processes. If you uncomment the code in the <code>RunExcelExamples()</code> method and then run the code once, you will see that we no longer have any Excel processes running in memory once our code has finished running. You will also see if you look at the <strong class="bold">Performance</strong> tab of Windows Task Manager that we have reclaimed our memory. </p>
			<p>We have managed to fix our memory leak by terminating COM components and setting managed objects to <code>null</code> to remove managed references. Then, we killed all processes called <code>EXCEL</code>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Be careful when using the <code>process.Kill()</code> method to kill off all processes for<a id="_idIndexMarker360"/> a given name such as <code>EXCEL</code>. There may be other programs that also use that process that could be badly impacted by such termination. You should run such code in an isolated environment if doing batch processing on a server, or schedule such operations for a time when you can guarantee that other processes will not be affected by running such code.</p>
			<p>It is now time to look at how using events can be a source of memory leaks.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>How using events can be a source of memory leaks</h2>
			<p>In this section, we will look<a id="_idIndexMarker361"/> at how the use of events in your computer programs<a id="_idIndexMarker362"/> can be a source of memory leaks. We will demonstrate this using a very simple Windows Forms application that we will write. Then, we will analyze our memory usage using JetBrains dotMemory. There will be two methods employed to show events in use. One method will generate a memory leak, while the other won’t generate a memory leak.</p>
			<p>So, how can using events generate memory leaks?</p>
			<p>Unless you are using anonymous methods, subscribing to an event holds a reference to the class that holds that event until such time as the event is unsubscribed from. Consider the following class:</p>
			<pre class="source-code">internal class EventSubscriber</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      public EventSubscriber(Control control)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          Control.TextChanged += OnTextChanged</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      private void OnTextChanged(</pre>
			<pre class="source-code">          object sender, </pre>
			<pre class="source-code">          EventArgs eventArgs</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          Text ((Control)sender).Text;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">}</pre>
			<p>If the control outlives the <code>EventSubscriber</code> class, then all instances of <code>EventSubscriber</code> will not be deallocated by the garbage collector. The end result is a memory leak. Here are some different ways to avoid event-based memory leaks:</p>
			<ol>
				<li value="1">Subscribe to anonymous methods.</li>
				<li>Unsubscribe from events when you are finished with them.</li>
				<li>Implement the weak-handler pattern.</li>
			</ol>
			<p>Before we look at each<a id="_idIndexMarker363"/> of these ways of avoiding memory leaks, we will write<a id="_idIndexMarker364"/> our Windows Forms application that demonstrates a way to avoid memory leaks and a way to generate memory leaks. Follow these steps:</p>
			<ol>
				<li value="1">Start a new .NET Core Windows Forms project, and then change the target framework from .NET Core 3.1 to .NET 5 in the project settings.</li>
				<li>Rename <code>Form1</code> to <code>MainForm</code>.</li>
				<li>Add a label called <code>InformationLabel</code> with the text <code>“Information”</code>, a button called <code>RaiseEventsButton</code> with the text <code>“Raise Events”</code>, and another label called <code>ProgressLabel</code> with the text <code>“Progress:”</code>. You can lay the components out and style them according to your preference.</li>
				<li>Double-click on the <code>RaiseEventsButton</code> button. This will generate a click event handler method.</li>
				<li>Add a class to the project called <code>EventOne</code>. You will need the following <code>using</code> statements:<pre>using System;
using System.Threading;</pre></li>
				<li>Add the following code to the top of the <code>EventOne</code> class:<pre>public event EventHandler OnEventRaised;
private static int _count;
public static int Count { get { return _count; } }</pre></li>
				<li>These elements are needed to handle the event and keep a count of how many instances are still being kept alive. Add the constructor, as follows:<pre>public EventOne()
{
      Interlocked.Increment(ref _count);
}</pre></li>
				<li>The constructor<a id="_idIndexMarker365"/> code increments the _<code>count</code> member variable<a id="_idIndexMarker366"/> in an atomic and thread-safe manner for each instance of the class. Add the <code>RaiseEvent(EventArgs e)</code> method, as follows:<pre>public void RaiseEvent(EventArgs e)
{
      EventHandler eventHandler = OnEventRaised;
            if (eventHandler != null)
                  eventHandler(this, e);
}</pre></li>
				<li>This method is called by the clients and is responsible for firing the event upon request. Now, add the finalizer, as follows:<pre>~EventOne()
{
      Interlocked.Decrement(ref _count);
}</pre></li>
				<li>The finalizer decrements the _<code>count</code> member variable in a thread-safe manner each time an instance of the class is terminated and collected by the garbage collector. Add a new <code>EventTwo</code> class to the project. You will need the following <code>using</code> statements:<pre>using System;
using System.Threading;
using System.Windows.Forms;</pre></li>
				<li>Add the following code to the top of the <code>EventTwo</code> class:<pre>private static int _count;
public static int Count { get { return _count; } }
public string Text { get; private set; }</pre></li>
				<li>The code stores the count<a id="_idIndexMarker367"/> of the number of alive instances and the current<a id="_idIndexMarker368"/> text of the subscribed control. Add the following constructor:<pre>public EventTwo(Control control)
{
      Interlocked.Increment(ref _count);
      control.TextChanged += OnTextChanged;
}</pre></li>
				<li>The constructor takes a Windows Forms control as a parameter. It increments the <code>_count</code> member variable by one in a thread-safe manner. It then subscribes to the <code>TextChanged</code> event that is handled by the <code>OnTextChanged</code> method. Add the <code>OnTextChanged</code> method, as follows:<pre>private void OnTextChanged(object sender, EventArgs 
    eventArgs)
{
      Text = ((Control)sender).Text;
}</pre></li>
				<li>This method is fired when the <code>Text</code> property of the subscribed control is changed. It takes the <code>Text</code> content of the control and assigns it to the <code>Text</code> property of the <code>EventTwo</code> class. Add the <code>Finalizer()</code> method, as follows:<pre>~EventTwo()
{
      Interlocked.Decrement(ref _count);
}</pre></li>
				<li>The finalizer decrements the <code>_count</code> member variable<a id="_idIndexMarker369"/> by one in a thread-safe manner each time an instance is garbage-collected. We now have in place the two classes that our form will<a id="_idIndexMarker370"/> use for raising events. Switch back to the <code>MainForm</code> class.</li>
				<li>At the top of the <code>MainForm</code> class, add the following member variables:<pre>private int _eventsGeneratedCount;
private int _eventSubscriberCount;</pre></li>
				<li>These two values will store the number of events that have been generated. Add the <code>SetTitleText()</code> method, as follows:<pre>private void SetTitleText()
{
      Text = $"{_eventsGeneratedCount}/{EventOne.Count} – 
          {_eventSubscriberCount}/{EventTwo.Count}";
}</pre></li>
				<li>This method sets the control’s <code>Text</code> property for each method that raises events. The text displays the number of events raised and the number of events still alive for the non-memory leak method, and the same again for the memory leak method. Add the <code>SetInformationLabelText()</code> method, as follows:<pre>private void SetInformationLabelText()
{
      StringBuilder sb = new StringBuilder();
      sb.AppendLine($"Raised Events (No Memory Leak):
          {_eventsGeneratedCount},  Alive Events: 
            {EventOne.Count}");
      sb.AppendLine($"Raised Events (Memory Leak): 
          {_eventSubscriberCount},  Alive Events: 
            {EventTwo.Count}");
      InformationLabel.Text = sb.ToString();
}</pre></li>
				<li>The <code>SetInformationLabelText()</code> method updates the <code>InformationLabel</code> text to display<a id="_idIndexMarker371"/> the number of events raised in<a id="_idIndexMarker372"/> each method and the number of events remaining in memory once both methods have finished executing. Add the <code>RaiseEvent</code> method, as follows:<pre>private void RaiseEvent(object sender, EventArgs e)
{
      ProgressLabel.Text = $"Event Raised: 
          {DateTime.Now}";
      ProgressLabel.Invalidate();
      ProgressLabel.Update();
}</pre></li>
				<li>The <code>RaiseEvent</code> method updates the <code>ProgressLabel.Text</code> property, but so that it is updated in real time, it is necessary to call the <code>Invalidate()</code> and <code>Update()</code> methods. Now, add the <code>MemoryLeakMethod</code> method, as follows:<pre>private void MemoryLeakMethod(EventArgs e)
{
      int count = 10000;
      for (int x = 0; x &lt; count; x++)
      {
            var eventTwo = new EventTwo(this);
      }
      _eventTwoCount += count;
}</pre></li>
				<li>This method declares a count<a id="_idIndexMarker373"/> of 10,000 items. It then loops<a id="_idIndexMarker374"/> through 10,000 iterations. A new <code>EventTwo</code> object is subscribed to with the reference to <code>MainForm</code> passed in. Once the loop completes, the <code>_eventTwoCount</code> variable is incremented by 10,000. Next, we will add the <code>NoMemoryLeakedMethod</code> method, as follows:<pre>private void NoMemoryLeakMethod(EventArgs e)
{
      int count = 10000;
      for (int x = 0; x &lt; count; x++)
      {
      EventOne eventOne = new EventOne();
      eventOne.OnEventRaised += RaiseEvent;
      eventOne.RaiseEvent(e);
      }
      _eventOneCount += count;
}</pre></li>
				<li>This method declares a count of 10,000. It iterates 10,000 times. During that 10,000 times, it instantiates a new <code>EventOne</code> object, adds an event handler called <code>RaisedEvent</code>, and then raises the event. Once, the loop has completed, the <code>_eventOneCount</code> variable is incremented by 10,000. Update the click event handler with the following code:<pre>NoMemoryLeakMethod(e);
MemoryLeakMethod(e);
SetInformationLabelText();
SetTitleText();</pre></li>
				<li>Change the build mode to <code>Release</code> and build the project.</li>
				<li>Open <strong class="bold">JetBrains dotMemory</strong>. Select <strong class="bold">Local</strong> | <strong class="bold">.NET Core Application</strong>, select an executable<a id="_idIndexMarker375"/> generated by the build<a id="_idIndexMarker376"/> process, then check the <strong class="bold">Collect memory allocation and traffic from start</strong> box. Your screen should look like this: </li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.7.jpg" alt="Figure 4.7 – The JetBrains dotMemory configuration screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – The JetBrains dotMemory configuration screen</p>
			<ol>
				<li value="25">Click on the <strong class="bold">Run</strong> button. This<a id="_idIndexMarker377"/> will start your application and profiling<a id="_idIndexMarker378"/> session, as shown in the next two screenshots: </li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.8.jpg" alt="Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application</p>
			<div><div><img src="img/B16617_Figure_4.9.jpg" alt="Figure 4.9 – Our Windows Forms application before any events have been run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Our Windows Forms application before any events have been run</p>
			<ol>
				<li value="26">Click on the <strong class="bold">Raise Events</strong> button a few times. Each time you click on the button, the memory profile <a id="_idIndexMarker379"/>should change and the memory usage<a id="_idIndexMarker380"/> should increase, as shown in the following screenshot: </li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.10.jpg" alt="Figure 4.10 – Our Windows Forms application showing 50,000 alive events, &#13;&#10;indicating we have a memory leak&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Our Windows Forms application showing 50,000 alive events, indicating we have a memory leak</p>
			<ol>
				<li value="27">As you can see, we have a memory leak. Our <code>NoMemoryLeakMethod</code> method does not generate a memory leak. As you can see, after 50,000 raised events, the objects kept alive in memory is 0. But our <code>MemoryLeakMethod</code> method does produce a memory leak. Out of 50,000 raised events, 50,000 objects remain alive.</li>
				<li>Run the program a few more times, and pay attention to what is going on in dotMemory. When you see a point of interest, click on the area and then click on <strong class="bold">Get Snapshot</strong>. This will take a snapshot of that moment in time that users can analyze to see if there are any<a id="_idIndexMarker381"/> issues. You should end up with<a id="_idIndexMarker382"/> something similar to this: </li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.11.jpg" alt="Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application &#13;&#10;when events are raised and snapshots are taken&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application when events are raised and snapshots are taken</p>
			<ol>
				<li value="29">Click on any one<a id="_idIndexMarker383"/> of your snapshots. You should<a id="_idIndexMarker384"/> see an output like this: </li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.12.jpg" alt="Figure 4.12 – A memory leak has been identified with the EventTwo class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – A memory leak has been identified with the EventTwo class</p>
			<ol>
				<li value="30">JetBrains dotMemory has detected a memory leak in the <code>EventTwo</code> class. This is because the class subscribes to an event of another object, but never unsubscribes from it. However, you will see that all the objects for the <code>EventOne</code> class have been finalized.</li>
			</ol>
			<p>You have seen how to use events<a id="_idIndexMarker385"/> in such a way that generates memory<a id="_idIndexMarker386"/> leaks and in such a way that all objects are finalized and a memory leak is prevented. Let’s revisit the three ways to prevent memory leaks when using events, as follows:</p>
			<ol>
				<li value="1">Subscribe to anonymous methods.</li>
				<li>Unsubscribe from events when you are finished with them.</li>
				<li>Implement the weak-handler pattern.</li>
			</ol>
			<p>Let’s take a look at subscribing to anonymous methods and then unsubscribing</p>
			<h3>Using local methods</h3>
			<p>Prior to C# 7.0, you would <a id="_idIndexMarker387"/>use anonymous methods as a way of handling events such that you avoid introducing memory leaks. As of C# 7.0, you can use local methods. In this example, we will handle events using local methods. Follow these next steps:</p>
			<ol>
				<li value="1">Load the <code>CH04_PreventingMemoryLeaks</code> project.</li>
				<li>Add a class called <code>Website</code>, as follows:<pre>internal class Website
{
      public event EventHandler&lt;EventArgs&gt; Login;
      public event EventHandler&lt;EventArgs&gt; Logout;
}</pre></li>
				<li>This class has<a id="_idIndexMarker388"/> two events for logging in and logging out of a website. Add a new class called <code>AnonymousEventSubscription</code>. Add the <code>Login()</code> method, as follows:<pre>public void Login()
{
      Website website = new Website();
      void LoginHandler(object sender, EventArgs args)
      {
          Debug.WriteLine("Anonymous login event handler 
            using a local method.");
          website.Login -= LoginHandler;
      };
      website.Login += LoginHandler;
      LoginHandler(this, new EventArgs());
}</pre></li>
				<li>The <code>Login()</code> method instantiates a new <code>Website</code> object. It then has a local method called <code>LoginHandler</code> that writes a message to the debug window and then unsubscribes from the <code>Website.Login</code> event. Then, outside of the local method, it subscribes to the <code>Website.Login</code> event and raises the event. Let’s add the <code>Logout()</code> method, as follows:<pre>public void Logout()
{
      Website website = new Website();
      void LogoutHandler(object sender, EventArgs args)
      {
          Debug.WriteLine("Anonymous logout event handler 
            using a local method.");
          website.Logout -= LogoutHandler;
      };
      website.Logout += LogoutHandler;
      LogoutHandler(this, new EventArgs());
}</pre></li>
				<li>The <code>Logout()</code> method<a id="_idIndexMarker389"/> instantiates a new <code>Website</code> object. It then has a local method called <code>LogoutHandler</code> that writes a message to the debug window and then unsubscribes from the <code>Website.Logout</code> event. Then, outside of the local method, it adds the event handler for the <code>Website.Logout</code> event, and then raises the event. </li>
				<li>In the <code>Main</code> method, comment out the <code>RunExcelExamples()</code> line. Then, add the <code>UseAnonymousEventSubscription()</code> method call, as follows:<pre>private static void UseAnonymousEventSubscriptions()
{
      for (int x = 0; x &lt; 1000000; x++)
      {
          AnonymousEventSubscription aes = new 
            AnonymousEventSubscription();
          aes.Login();
          aes.Logout();
      }
}</pre></li>
				<li>This code runs<a id="_idIndexMarker390"/> through 1,000,000 iterations. For each iteration, a new <code>AnonymousEventSubscription</code> is instantiated, with calls to <code>Login()</code> and <code>Logout()</code> made. These two calls will each have a subscription to an event, an event executed via a local method, and, as the local method is executed, the event it will be unsubscribed from.</li>
				<li>If you build and run the code, you should see the following lines printed 1,000,000 times in your debug window: </li>
			</ol>
			<div><div><img src="img/B16617_Figure_4.13.jpg" alt="Figure 4.13 – The debug window showing events firing for Login and Logout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – The debug window showing events firing for Login and Logout</p>
			<ol>
				<li value="9">If you perform a release build and run dotMemory, you will see that we have no memory leak, considering we have just generated 2,000,000 event subscriptions and unsubscriptions—that is, 1,000,000 for <code>Login()</code> and 1,000,000 for <code>Logout()</code>.</li>
			</ol>
			<p>We have seen how to effectively use anonymous events using local methods without causing memory leaks. Now, let’s look at our final topic of the chapter—weak references.</p>
			<h3>Using weak reference events</h3>
			<p>We use the weak reference<a id="_idIndexMarker391"/> event pattern to allow an object to be garbage-collected if its only remaining link is an event handler. We will implement the weak reference event pattern in this section in the <code>CH04_PreventingMemoryLeaks</code> project. Follow these next steps:</p>
			<ol>
				<li value="1">In the Package Manager Console, type the following: <code>install-package WeakEventListener</code>. The <code>System.Windows.WeakEventManager</code> package only works with .NET 4.8 and older, which is why we install this package.</li>
				<li>Add the following <code>SampleClass</code> class:<pre>internal class SampleClass
{
      public event EventHandler&lt;EventArgs&gt; RaiseEvent;
      public void DoSomething()
      {
          OnRaiseEvent();
      }
      protected virtual void OnRaiseEvent()
      {
          RaiseEvent?.Invoke(this, EventArgs.Empty);
      }
}</pre></li>
				<li>In this class, we declare an event called <code>RaiseEvent</code>. The <code>DoSomething()</code> method calls the <code>OnRaiseEvent()</code> method. The <code>OnRaiseEvent()</code> method checks if the event is <code>null</code>; if it is not <code>null</code>, then the event is invoked. Add a new class called <code>UsingWeakreferences</code>. You will need the following references:<pre>using System;
using System.Diagnostics;
using WeakEventListener;</pre></li>
				<li>Add the <code>RaiseWeakReferenceEvents()</code> method, as follows:<pre>public void RaiseWeakReferenceEvents()
{
      bool isOnEventTriggered = false;
      bool isOnDetachTriggered = false;
      SampleClass sample = new SampleClass();
      WeakEventListener&lt;SampleClass, object, EventArgs&gt; 
        weak = new WeakEventListener&lt;SampleClass, object, 
                EventArgs&gt;(sample);
      weak.OnEventAction = (instance, source, eventArgs) 
        =&gt; { isOnEventTriggered = true; };
      weak.OnDetachAction = (listener) =&gt;
        {isOnDetachTriggered = true; };
      sample.Raisevent += weak.OnEvent;
      sample.DoSomething();
      Debug.Assert(isOnEventTriggered);
      weak.Detach();
      Debug.Assert(isOnDetachTriggered);
}</pre></li>
				<li>We have two variables that are <code>true</code> when an event has been triggered and when it has been detached. We instantiate a new <code>SampleClass</code> class instance. Then we declare a <code>WeakEventListener</code> package that references the <code>SampleClass</code> class. Anonymous methods are used to handle the <code>OnEventAction</code> and <code>OnDetachAction</code> methods. The <code>WeakReferenceListener.OnEvent</code> method is then assigned as the handler for the <code>SampleClass.RaiseEvent</code> event. We then call the <code>DoSomething()</code> method that raises the event. Then, we assert that the event has been triggered, detach the event, and then assert that the event has been detached.</li>
				<li>Make sure the<a id="_idIndexMarker392"/> project is set to <strong class="bold">Debug</strong> mode, and then step through the code. It should work as expected, with the event being correctly triggered and detached.</li>
			</ol>
			<p>Let’s now summarize what we have learned in this chapter. </p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Summary</h1>
			<p>We looked at object generations and saw how easy it was to generate a <code>System.OutOfMemoryException</code>-type exception. We saw how we can use predictive out-of-memory exception checking to save time by preventing the running of code that will cause this exception.</p>
			<p>Then, we moved on to discuss long weak references and short weak references. We learned that strong references are not garbage-collected, and weak references are garbage-collected.</p>
			<p>We then looked at finalization and saw how the <code>Finalize()</code> method will be called on objects that are not disposed of, and that we have no control over when the <code>Finalize()</code> method will run. Then, we looked at how to implement the <code>IDisposable</code> pattern and suppress the need for garbage collection to call <code>Finalize()</code>.</p>
			<p>Finally, we looked at the various ways to prevent memory leaks, such as properly disposing of managed resources and unmanaged resources. We also saw how to correctly handle events so that we do not cause memory leaks.</p>
			<p>With what you have learned in this chapter, you will be able to overcome out-of-memory exceptions, improve memory performance, and improve garbage collection in your applications, and you will be to correctly use events and event handlers without generating memory leaks and will be able to effectively release COM objects and allocated memory. This will lead to better quality and more stable programs that make good use of memory.</p>
			<p>In the next chapter, we will be looking at application profiling.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Questions</h1>
			<ol>
				<li value="1">How many object generations are there?</li>
				<li>Which sized objects get placed on the SOH?</li>
				<li>Which sized objects get placed on the LOH?</li>
				<li>What is a strong reference?</li>
				<li>What is a weak reference?</li>
				<li>How can we clean up objects without having to rely on finalization?</li>
				<li>How do we avoid memory leaks when using events?</li>
				<li>Which method do we use to release COM objects?</li>
				<li>How do we prevent memory leaks when allocating memory?</li>
			</ol>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Further reading</h1>
			<ul>
				<li>Weak references: <a href="https://www.youtube.com/watch?v=2WcDhh8lvJs">https://www.youtube.com/watch?v=2WcDhh8lvJs</a></li>
				<li><code>ComWrappers</code> class: https://docs.microsoft.com/ dotnet/api/system.runtime.interopservices.comwrappers?view=net-5.0</li>
				<li><em class="italic">Marshal.ReleaseComObject Considered Dangerous</em>: <a href="https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/">https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/</a></li>
				<li><em class="italic">WeakEventManager Class:</em> https://docs.microsoft.com /dotnet/api/system.windows.weakeventmanager?view=net-5.0</li>
				<li><em class="italic">Weak Event Patterns</em>: <a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8">https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8</a></li>
				<li><em class="italic">How to properly release Excel COM objects</em>: <a href="https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/">https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/</a></li>
				<li><em class="italic">Understanding and Avoiding Memory Leaks with Event Handlers and Event Aggregators</em>: <a href="https://www.markheath.net/post/understanding-and-avoiding-memory-leaks">https://www.markheath.net/post/understanding-and-avoiding-memory-leaks</a></li>
				<li>Why and how to avoid event handler memory leaks: <a href="https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks">https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks</a></li>
				<li><em class="italic">.NET Framework technologies unavailable on .NET Core and .NET 5+:</em> <a href="https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable">https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable</a></li>
			</ul>
		</div>
	</body></html>