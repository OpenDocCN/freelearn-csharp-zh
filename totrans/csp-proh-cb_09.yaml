- en: Chapter 9. Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。正则表达式
- en: '**Regular Expressions** (**regex**) are somewhat of a mystery for many developers.
    We admit that they are something that we use often enough to warrant a deeper
    understanding of how they work. On the flip side, there are so many tried and
    tested regex patterns on the Internet that just reusing one that already exists
    is most times easier than trying to create one yourself. The subject of regex
    is much larger than what can be explained in a single chapter in this book.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**（**regex**）对许多开发者来说仍然是一个谜。我们承认，我们经常使用它们，这足以证明深入了解它们的工作原理是必要的。另一方面，互联网上有许多经过测试的正则表达式模式，直接重用现有的模式通常比尝试自己创建一个更容易。正则表达式的主题远比本书单章所能解释的要多。'
- en: 'Therefore, in this chapter, we will merely introduce some of the concepts of
    regex. For a deeper understanding of regex, further study is needed. For the purpose
    of this book, however, we will take a closer look at how regex are created and
    how they can be applied to some common programming problems. In this chapter,
    we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们仅介绍一些正则表达式的概念。为了更深入地理解正则表达式，还需要进一步学习。然而，为了本书的目的，我们将更详细地研究正则表达式的创建方式和它们如何应用于一些常见的编程问题。在本章中，我们将涵盖以下食谱：
- en: Getting started with regex
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用正则表达式
- en: Matching a valid date
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配有效日期
- en: Sanitizing input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理输入
- en: Dynamic regex matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态正则表达式匹配
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A regex is a pattern that describes a string through the use of special characters
    that denote a specific bit of text to match. The use of regex is not a new concept
    in programming. For regex to work, they need to use a regex engine that does all
    the heavy lifting.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是通过使用表示特定文本匹配的特殊字符来描述字符串的模式。正则表达式的使用在编程中不是一个新概念。为了使正则表达式工作，它们需要使用正则表达式引擎来完成所有繁重的工作。
- en: In the .NET Framework, Microsoft has provided for the use of regex. To use regex,
    you will need to import the `System.Text.RegularExpressions` assembly to your
    project. This will allow the compiler to use your regex pattern and apply it to
    the specific text you need to match.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架中，Microsoft 为正则表达式的使用提供了支持。要使用正则表达式，您需要将 `System.Text.RegularExpressions`
    程序集导入到您的项目中。这将允许编译器使用您的正则表达式模式并将其应用于您需要匹配的特定文本。
- en: Secondly, regex have a specific set of metacharacters that hold special meaning
    to the Regex engine. These characters are `[ ]`, `{ }`, `( )`, `*`, `+`, `\`,
    `?`, `|`, `$`, `.` and, `^`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，正则表达式有一组特定的元字符，这些字符对正则表达式引擎具有特殊意义。这些字符是 `[ ]`、`{ }`、`( )`、`*`、`+`、`\`、`?`、`|`、`$`、`.`
    和 `^`。
- en: The use of the curly brackets `{ }`, for example, enables developers to specify
    the number of times a specific set of characters need to occur. Using square brackets,
    on the other hand, defines exactly what needs to be matched.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用花括号 `{ }`，例如，允许开发者指定特定字符集需要出现的次数。另一方面，使用方括号定义需要精确匹配的内容。
- en: If we, for example, specified `[abc]`, the pattern would look for lowercase
    As, Bs, and Cs. Regex, therefore, also allows you to define a range, for example,
    `[a-c]`, which is interpreted in exactly the same way as the `[abc]` pattern.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们指定了 `[abc]`，则模式将寻找小写的A、B和C。因此，正则表达式还允许您定义一个范围，例如 `[a-c]`，它被解释得与 `[abc]`
    模式完全相同。
- en: Regex then also allow you to define characters to exclude by using the `^` character.
    Therefore, typing `[^a-c]` would find lowercase D through Z because the pattern
    is telling the regex engine to exclude lowercase As, Bs, and Cs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式还允许您使用 `^` 字符定义要排除的字符。因此，键入 `[^a-c]` 将找到小写字母D到Z，因为模式告诉正则表达式引擎排除小写字母A、B和C。
- en: Regex also define `\d` and `\D` as types of shortcut for `[0-9]` and `[^0-9]`,
    respectively. Therefore, `\d` matches all numeric values, and `\D` matches all
    non-numeric values. Another shortcut is `\w` and `\W`, which match any character
    from lowercase A to Z, irrespective of the case, all numeric values from 0 to
    9, and the underscore character. Therefore, `\w` is `[a-zA-Z0-9_]`, while `\W`
    is `[^a-zA-Z0-9_]`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式还定义了 `\d` 和 `\D` 作为 `[0-9]` 和 `[^0-9]` 的快捷类型。因此，`\d` 匹配所有数值，`\D` 匹配所有非数值。另一个快捷类型是
    `\w` 和 `\W`，它们匹配从小写字母A到Z的所有字符，不考虑大小写，以及从0到9的所有数值和下划线字符。因此，`\w` 是 `[a-zA-Z0-9_]`，而
    `\W` 是 `[^a-zA-Z0-9_]`。
- en: The basics of regex are rather easy to understand, but there is a lot more that
    you can do with regex.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的基础知识相对容易理解，但你可以用正则表达式做更多的事情。
- en: Getting started with regex
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用正则表达式
- en: We will be create a new class in C# called `Chapter9`. Here, we will create
    various methods to illustrate the use of regex.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `Chapter9` 的新类，在这里我们将创建各种方法来展示正则表达式的使用。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the purpose of this book, we will create a simple console application to
    illustrate the use of regex. In reality, you would probably not have this logic
    mixed in with your production code, because this would result in code being rewritten.
    The best place to add something like regex is in a helper class within an extension
    method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们将创建一个简单的控制台应用程序来展示正则表达式的使用。实际上，你很可能不会将这种逻辑与你的生产代码混合在一起，因为这会导致代码被重写。正则表达式最佳添加位置是在扩展方法中的辅助类。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Start by right-clicking the solution, going to **Add**, and then to **New Project**
    from the context menu:![How to do it…](img/B05391_09_01.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先右键单击解决方案，转到 **添加**，然后从上下文菜单中选择 **新建项目**：![如何操作…](img/B05391_09_01.jpg)
- en: The **Add New Project** window opens up. Select the **Class Library** project
    type and call the project `Chapter9`:![How to do it…](img/B05391_09_02.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加新项目** 窗口打开。选择 **类库** 项目类型，并将项目命名为 `Chapter9`：![如何操作…](img/B05391_09_02.jpg)'
- en: After the new class file has been added, your **Solution Explorer** should look
    like this:![How to do it…](img/B05391_09_03.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类文件被添加后，你的 **解决方案资源管理器** 应该看起来像这样：![如何操作…](img/B05391_09_03.jpg)
- en: Right-click the `Class1.cs` file and select **Rename** from the context menu:![How
    to do it…](img/B05391_09_04.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Class1.cs` 文件，并从上下文菜单中选择 **重命名**：![如何操作…](img/B05391_09_04.jpg)
- en: Rename the `Class1.cs` file to `Recipes.cs` and select **Yes** from the confirmation
    dialog:![How to do it…](img/B05391_09_05.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Class1.cs` 文件重命名为 `Recipes.cs` 并在确认对话框中选择 **是**：![如何操作…](img/B05391_09_05.jpg)
- en: In the console application, click on the **References** section and select **Add
    Reference** from the context menu:![How to do it…](img/B05391_09_06.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，点击 **引用** 部分，并从上下文菜单中选择 **添加引用**：![如何操作…](img/B05391_09_06.jpg)
- en: In **Reference** **Manager** for the console application, select `Chapter9`
    and click on **OK** to add it as a reference to the console application:![How
    to do it…](img/B05391_09_07.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序的 **引用管理器** 中，选择 `Chapter9` 并点击 **确定** 以将其添加为控制台应用程序的引用：![如何操作…](img/B05391_09_07.jpg)
- en: 'In the `Recipes` class, add the following `using` statement so that we can
    use the regex assembly in .NET:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recipes` 类中添加以下 `using` 语句，以便我们可以在 .NET 中使用正则表达式程序集：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you have done all this, your `Chapter9` class should look like this:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成所有这些后，你的 `Chapter9` 类应该看起来像这样：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We have added a basic class file that will be used to validate regex patterns,
    which is called from our console application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个基本的类文件，它将被用来验证正则表达式模式，这个文件是从我们的控制台应用程序中调用的。
- en: Matching a valid date
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配有效日期
- en: We will create a regex to validate a date pattern of yyyy-mm-dd, yyyy/mm/dd,
    or yyyy.mm.dd. At first, the regex will look daunting, but bear with me. When
    you have completed the code and run the application, we will dissect the regex.
    Hopefully, the expression logic will become clear.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个正则表达式来验证 yyyy-mm-dd、yyyy/mm/dd 或 yyyy.mm.dd 的日期模式。一开始，这个正则表达式可能看起来令人畏惧，但请耐心等待。当你完成代码并运行应用程序后，我们将分析正则表达式。希望表达式逻辑会变得清晰。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t already done so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经将正确的程序集添加到你的类中。如果你的代码文件顶部还没有，请添加以下代码行：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new method called `ValidDate()` that takes a string as the parameter.
    This string will be the date pattern we want to validate:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ValidDate()` 的新方法，它接受一个字符串作为参数。这个字符串将是我们要验证的日期模式：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following regex pattern to your method, to a variable in the method:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下正则表达式模式添加到你的方法中，到一个方法变量中：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, add the regex to match the supplied string parameter:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加正则表达式来匹配提供的字符串参数：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you have done this, your method should look like this:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，你的方法应该看起来像这样：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Going back to your console application, add the following code and debug your
    application by clicking on Start:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的控制台应用程序，添加以下代码并通过点击 **开始** 来调试你的应用程序：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice that `Read()` is used in the preceding code example instead
    of `Console.Read()`. This is because `using static System.Console`; is added to
    the console application's `using` statements. Doing this will allow you to omit
    the `Console` keyword.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会注意到在先前的代码示例中使用了 `Read()` 而不是 `Console.Read()`。这是因为我们在控制台应用程序的 `using` 语句中添加了
    `using static System.Console`;。这样做将允许您省略 `Console` 关键字。
- en: The date strings are passed to the regex, and the pattern is matched against
    the date string in the parameter. The output is displayed in the console application:![How
    to do it…](img/B05391_09_08.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日期字符串被传递到正则表达式，模式与参数中的日期字符串进行匹配。输出在控制台应用程序中显示：![如何做到这一点…](img/B05391_09_08.jpg)
- en: If you look at the output carefully, you will notice that there is a mistake.
    We are validating the date string in the format yyyy-mm-dd, yyyy/mm/dd, and yyyy.mm.dd.
    If we use this logic, our regex has incorrectly flagged a valid date as invalid.
    This is the date `2016.4.10`, which is 10 April, 2016, and is in fact quite valid.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果仔细查看输出，您会注意到有一个错误。我们正在验证的日期字符串格式为 yyyy-mm-dd, yyyy/mm/dd, 和 yyyy.mm.dd。如果我们使用这种逻辑，我们的正则表达式错误地将一个有效日期标记为无效。这是日期
    `2016.4.10`，即2016年4月10日，实际上是非常有效的。
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will explain shortly why the date `1800-01-21` is invalid.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将简要解释为什么日期 `1800-01-21` 是无效的。
- en: 'Go back to your `ValidDate()` method and change the regular expression to read
    as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的 `ValidDate()` 方法，将正则表达式更改为以下内容：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the console application again and look at the output:![How to do it…](img/B05391_09_09.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序并查看输出：![如何做到这一点…](img/B05391_09_09.jpg)
- en: This time the regex worked for all the given date strings. But what exactly
    did we do? This is how it works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这次正则表达式对所有给定的日期字符串都有效。但我们到底做了什么？这是它的工作原理。
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s take a closer look at the two expressions used in the previous code
    example. Comparing them with each other, you can see the change we made in yellow:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看先前的代码示例中使用的两个表达式。将它们相互比较，您可以看到我们用黄色标记出的更改：
- en: '![How it works…](img/B05391_09_10.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_09_10.jpg)'
- en: 'Before we get to what that change means, let''s break up the expression and
    view the individual components. Our regex is basically saying that we must match
    all string dates that start with 19 or 20 and have the following separators:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释这个更改意味着什么之前，让我们分解表达式并查看各个组成部分。我们的正则表达式基本上表示我们必须匹配所有以19或20开头并具有以下分隔符的字符串日期：
- en: Dash (`-`)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号 (`-`)
- en: Decimal (`.`)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小数点 (`.`)
- en: Forward slash (`/`)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斜杠 (`/`)
- en: To understand the expression better, we need to understand the following format
    of the expression *<Valid Years><Valid Separators><Valid Months><Valid Separators><Valid
    Days>*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解表达式，我们需要了解以下表达式的格式 *<有效年份><有效分隔符><有效月份><有效分隔符><有效日期>*。
- en: We also need to be able to tell the regex engine to consider one OR another
    pattern. The word OR is symbolised by the `|` metacharacter. To make the regex
    engine consider the word OR without splitting up the whole expression, we wrap
    it in parenthesis `()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够告诉正则表达式引擎考虑一个或另一个模式。单词“或”由元字符 `|` 表示。为了使正则表达式引擎考虑单词“或”而不拆分整个表达式，我们将其括在括号
    `()` 中。
- en: 'Here are the symbols used in the regex:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是正则表达式中使用的符号：
- en: '| The conditional OR |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 条件或 |'
- en: '| --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `&#124;` | This denotes the OR metacharacter. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 这表示“或”元字符。 |'
- en: '| **The year portion** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **年份部分** |'
- en: '| `(19&#124;20)` | Only allow 19 or 20. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `(19&#124;20)` | 只允许19或20。 |'
- en: '| `\d\d` | Match two single digits between 0 and 9\. To match only one digit
    between 0 and 9, you would use `\d`. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `\d\d` | 匹配0到9之间的两个单个数字。要匹配0到9之间的单个数字，您将使用 `\d`。 |'
- en: '| **The valid separator character set** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **有效的分隔符字符集** |'
- en: '| `[-./]` | Match any of the following characters in the character set. These
    are our valid separators. To match a space date separator, you would change this
    to `[- ./]`, where you add a space anywhere in the character set. We added the
    space between the dash and the decimal. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `[-./]` | 匹配字符集中以下任意字符。这些是我们有效的分隔符。要匹配空格日期分隔符，您需要将其更改为 `[- ./]`，其中您可以在字符集中添加空格。我们在破折号和十进制之间添加了空格。
    |'
- en: '| **Valid digits for months and days** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **月份和日期的有效数字** |'
- en: '| `0[1-9]` | Match any part starting with zero followed by any digit between
    1 and 9\. This will match 01, 02, 03, 04, 05, 06, 07, 08, and 09. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `0[1-9]` | 匹配以零开头，后跟1到9之间任意数字的部分。这将匹配01, 02, 03, 04, 05, 06, 07, 08和09。 |'
- en: '| `1[0-2]` | Match any part starting with 1 followed by any digit between 0
    and 2\. This will match 10, 11, or 12. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `1[0-2]` | 匹配以1开头，后跟0到2之间的任何数字的任何部分。这将匹配10, 11或12。 |'
- en: '| `[1-9]` | Match any digit between 1 and 9. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `[1-9]` | 匹配1到9之间的任何数字。 |'
- en: '| `[12][0-9]` | Match any part starting with 1 or 2, followed by any digit
    between 0 and 9\. This will match all number strings between 10 and 29. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `[12][0-9]` | 匹配以1或2开头，后跟0到9之间的任何数字的任何部分。这将匹配所有介于10到29之间的数字字符串。 |'
- en: '| `3[01]` | Match any part starting with 3 and followed by 0 or 1\. This will
    match 30 or 31. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `3[01]` | 匹配以3开头，后跟0或1的任何部分。这将匹配30或31。 |'
- en: '| **Start and end of string** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **字符串的开始和结束** |'
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 告诉正则表达式引擎从给定字符串的开始处开始匹配。 |'
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match.
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 告诉正则表达式引擎在给定字符串的末尾停止匹配。 |'
- en: 'The first regex we created, interprets as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个正则表达式解释如下：
- en: '`^`: Start at the beginning of the string to match'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`: 从字符串的开始处开始匹配。'
- en: '`(19|20)`: Check whether the string starts with 19 or 20'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(19|20)`: 检查字符串是否以19或20开头。'
- en: '`\d\d`: After the check, follows two single digits between 0 and 9'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d\d`: 在检查之后，跟随两个0到9之间的单个数字。'
- en: '`[-./]`: The year portion ends followed by a date separator'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 年份部分结束，随后是日期分隔符。'
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, or digits starting with 1, followed
    by any digit between 0 and 2'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|1[0-2])`: 通过查找以0开头，后跟1到9之间的任何数字，或者以1开头，后跟0到2之间的任何数字的逻辑来找到月份。'
- en: '`[-./]`: The month logic ends, followed by a date separator'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 月份逻辑结束，随后是日期分隔符。'
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, or digits starting with
    1 or 2, followed by any digit between 0 and 9, or a digit matching 3, followed
    by any digit between 0 and 1'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|[12][0-9]|3[01])`: 然后，通过查找以0开头，后跟1到9之间的任何数字，或者以1或2开头，后跟0到9之间的任何数字，或者以3开头，后跟0到1之间的任何数字的逻辑来找到日期。'
- en: '`$`: Do this until the end of the string'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`: 继续这样做，直到字符串的末尾。'
- en: Our first regex was incorrect because our month logic was incorrect. Our month
    logic dictates to find the month logic by looking for digits starting with a 0
    followed by any digit between 1 and 9, or digits starting with a 1 followed by
    any digit between 0 and 2 `(0[1-9]|1[0-2])`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个正则表达式是错误的，因为我们的月份逻辑是错误的。我们的月份逻辑指示通过查找以0开头，后跟1到9之间的任何数字，或者以1开头，后跟0到2之间的任何数字`(0[1-9]|1[0-2])`来找到月份逻辑。
- en: This will then find 01, 02, 03, 04, 05, 06, 07, 08, 09 or 10, 11, 12\. The date
    that it didn't match was `2016.4.10` (the date separators don't make a difference
    here). This is because our month came through as a single digit, and we were looking
    for months where the single digits started with a zero. To fix this, we had to
    modify the expression of the month logic to include single digits between 1 and
    9\. We did this by adding `[1-9]` to the expression at the end.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到01, 02, 03, 04, 05, 06, 07, 08, 09或10, 11, 12。没有匹配的日期是`2016.4.10`（这里的日期分隔符没有影响）。这是因为我们的月份是一个单独的数字，而我们寻找的是以0开头的月份。为了解决这个问题，我们必须修改月份逻辑的表达式，以包括1到9之间的单个数字。我们通过在表达式的末尾添加`[1-9]`来实现这一点。
- en: 'The modified regex then reads as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的正则表达式如下所示：
- en: '`^`: Start at the beginning of the string to match.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`: 从字符串的开始处开始匹配。'
- en: '`(19|20)`: Check whether the string starts with 19 or 20.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(19|20)`: 检查字符串是否以19或20开头。'
- en: '`\d\d`: After the check, follows two single digits between 0 and 9.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d\d`: 在检查之后，跟随两个0到9之间的单个数字。'
- en: '`[-./]`: The year portion ends, followed by a date separator'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 年份部分结束，随后是日期分隔符。'
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, or digits starting with 1, followed
    by any digit between 0 and 2, or any single digits between 1 and 9'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|1[0-2])`: 通过查找以0开头，后跟1到9之间的任何数字，或者以1开头，后跟0到2之间的任何数字，或者任何单个数字（1到9）的逻辑来找到月份。'
- en: '`[-./]`: The month logic ends, followed by a date separator'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 月份逻辑结束，随后是日期分隔符。'
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, or digits starting with
    1 or 2, followed by any digit between 0 and 9, or a digit matching 3, followed
    by any digit between 0 and 1'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|[12][0-9]|3[01])`: 然后，通过寻找以0开头的数字，后面跟着一个1到9之间的数字，或者以1或2开头的数字，后面跟着任何0到9之间的数字，或者一个匹配3的数字，后面跟着任何0到1之间的数字来找到天逻辑'
- en: '`$`: Do this until the end of the string'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`: 一直做到字符串的末尾'
- en: This is a basic regex, and we say basic because there is a lot more we can do
    to make the expression better. We can include logic to consider alternative date
    formats such as mm-dd-yyyy or dd-mm-yyyy. We can add logic to check February and
    validate that it contains only 28 days, unless it is a leap year, in which case
    we need to allow the twenty-ninth day of February. Furthermore, we can also extend
    the regex to check that January, March, May, July, August, October, and December
    have 31 days while April, June, September, and November contain only 30 days.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的正则表达式，我们称之为基本，因为我们还可以做更多的事情来使表达式更好。我们可以包括逻辑来考虑其他日期格式，例如 mm-dd-yyyy 或
    dd-mm-yyyy。我们可以添加逻辑来检查二月，并验证它是否只包含28天，除非它是闰年，在这种情况下，我们需要允许二月的第二十九天。此外，我们还可以扩展正则表达式来检查一月、三月、五月、七月、八月、十月和十二月有31天，而四月、六月、九月和十一月只有30天。
- en: Sanitizing input
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理输入
- en: Sometimes, you will need to sanitize input. This could be to prevent SQL injections
    or ensure that an entered URL is valid. In this recipe, we will look at replacing
    the bad words in a string with asterisks. We are sure that there are more elegant
    and code-efficient methods of writing sanitation logic using regex (especially
    when we have a large collection of blacklist words), but we want to illustrate
    a concept here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要清理输入。这可能是为了防止SQL注入或确保输入的URL有效。在这个菜谱中，我们将查看用星号替换字符串中的脏话。我们确信有更多优雅且代码效率更高的方法来编写清理逻辑使用正则表达式（特别是当我们有一个大量的黑名单单词集合时），但在这里我们想要说明一个概念。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t done so already:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经将正确的程序集添加到你的类中。如果你还没有这样做，请在你的代码文件顶部添加以下代码行：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new method in your `Recipes.cs` class called `SanitizeInput()` and
    let it accept a string parameter:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Recipes.cs` 类中创建一个新的方法，命名为 `SanitizeInput()`，并让它接受一个字符串参数：
- en: '[PRE10]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a list of type `List<string>` to the method that contains the bad words
    we want to remove from the input:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含我们想要从输入中移除的脏话的方法中添加一个类型为 `List<string>` 的列表：
- en: '[PRE11]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, you might make use of a database call to read the blacklisted words
    from a table in the database. You would usually not hardcode them in a list like
    this.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，你可能需要使用数据库调用从数据库中的表中读取黑名单中的单词。你通常不会像这样将它们硬编码到列表中。
- en: 'Start constructing the regex that we will use to look for the blacklisted words.
    Concatenate the words with the `|` (OR) metacharacter so that the regex will match
    any of the words. When the list is complete, you can append the `\b` expression
    to either side of the regex. This denotes a word boundary and, therefore, will
    only match whole words:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始构建我们将用来查找黑名单单词的正则表达式。使用 `|`（或）元字符连接单词，以便正则表达式可以匹配任何单词。当列表完成时，你可以在正则表达式的两边添加
    `\b` 表达式。这表示单词边界，因此只会匹配整个单词：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we will add the `Regex.Replace()` method that takes the input and
    looks for the occurrence of the words defined in the pattern, while ignoring case
    and replacing the bad words with `*****`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加 `Regex.Replace()` 方法，该方法接受输入并查找模式中定义的单词的出现，同时忽略大小写并将脏话替换为 `*****`：
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you have completed this, your `SanitizeInput()` method will look like
    this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，你的 `SanitizeInput()` 方法将看起来像这样：
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the console application, add the following code to call the `SanitizeInput()`
    method and run your application:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，添加以下代码来调用 `SanitizeInput()` 方法并运行你的应用程序：
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you run your application, you will see the following in the console window:![How
    to do it…](img/B05391_09_11.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行你的应用程序时，你将在控制台窗口中看到以下内容：![如何操作…](img/B05391_09_11.jpg)
- en: Let's take a closer look at the regular expression generated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看生成的正则表达式。
- en: How it works…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s step through the code to understand what is happening. We need to get
    a regex that looks like this: `\b(wordToMatch1|wordToMatch2|wordToMatch3)\b`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析代码，了解正在发生的事情。我们需要得到一个看起来像这样的正则表达式：`\b(wordToMatch1|wordToMatch2|wordToMatch3)\b`。
- en: 'What this basically says is find me any of the words and only whole words that
    are denoted by `\b`. When we look at the list we created, we will see the words
    we want to remove from the input string:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是说，找到任何由`\b`表示的单词，并且只匹配整个单词。当我们查看我们创建的列表时，我们会看到我们想要从输入字符串中删除的单词：
- en: '![How it works…](img/B05391_09_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_09_12.jpg)'
- en: 'We then created a simple loop that will create the list of words to match using
    the OR metacharacter. We ended up with a `BadWord1|BadWord2|BadWord3` pattern
    after the `foreach` loop has completed. However, this is still not a valid regex:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个简单的循环，使用OR元字符创建要匹配的单词列表。在`foreach`循环完成后，我们得到了`BadWord1|BadWord2|BadWord3`的模式。然而，这仍然不是一个有效的正则表达式：
- en: '![How it works…](img/B05391_09_13.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_09_13.jpg)'
- en: To complete the pattern resulting in the valid regex, we need to add the `\b`
    expression on either side of the pattern to tell the regex engine to only match
    whole words. As you can see, we are using string interpolation. String interpolation
    is covered in detail in [Chapter 1](ch01.html "Chapter 1. New Features in C# 6.0"),
    *New Features in C#6*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成有效的正则表达式模式，我们需要在模式两侧添加`\b`表达式，告诉正则表达式引擎只匹配整个单词。正如你所看到的，我们正在使用字符串插值。字符串插值将在[第1章](ch01.html
    "第1章。C# 6.0的新特性")中详细介绍，*C#6的新特性*。
- en: 'It is here, however, that we need to be very careful. Start off by writing
    the code to complete the pattern without the `@` sign, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里我们需要非常小心。首先编写代码来完成没有`@`符号的模式，如下所示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you run your console application, you will see that the bad words are not
    matched and filtered out. This is because we have not escaped the `\` character
    before `b`. The compiler, therefore, interprets this line of code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行你的控制台应用程序，你会看到坏词没有被匹配和过滤掉。这是因为我们没有在`b`之前转义`\`字符。因此，编译器解释这一行代码：
- en: '![How it works…](img/B05391_09_17.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_09_17.jpg)'
- en: The generated expression `[](BadWord1| BadWord2| BadWord3)[]` is not a valid
    expression and will therefore not sanitize the input string.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的表达式`[](BadWord1| BadWord2| BadWord3)[]`不是一个有效的表达式，因此不会清理输入字符串。
- en: 'To correct this, we need to add the `@` symbol before the string to tell the
    compiler to treat the string as a literal. This means any escape sequences are
    ignored. The correctly formatted line of code looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个问题，我们需要在字符串前添加`@`符号，告诉编译器将字符串视为字面量。这意味着任何转义序列都会被忽略。正确格式的代码行看起来像这样：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once you do this, the string for the pattern is interpreted literally by the
    compiler, and the correct regex pattern generated:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，编译器就会逐字解释模式字符串，并生成正确的正则表达式模式：
- en: '![How it works…](img/B05391_09_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_09_14.jpg)'
- en: 'With our correct regex pattern, we called the `Regex.Replace()` method. It
    takes the input to check, the regex to match, the text to replace the matched
    words with, and optionally allows for the ignoring of case:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们正确的正则表达式模式，我们调用了`Regex.Replace()`方法。它接受要检查的输入、要匹配的正则表达式、用于替换匹配单词的文本，并且可选地允许忽略大小写：
- en: '![How it works…](img/B05391_09_15.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_09_15.jpg)'
- en: 'When the string returns to the calling code in the console application, the
    string will be sanitized properly:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串返回到控制台应用程序的调用代码时，字符串将被正确清理：
- en: '![How it works…](img/B05391_09_16.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_09_16.jpg)'
- en: Regex can become quite complex and can be used to perform a multitude of tasks
    to format and validate input and other text.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以变得相当复杂，并且可以用来执行多种任务，以格式化和验证输入和其他文本。
- en: Dynamic regex matching
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态正则表达式匹配
- en: What does dynamic regex matching even mean? Well, it isn't an official term,
    but it is a term we use to explain a Regex that uses variables at runtime to generate
    a specific expression. Assume for a minute that you are working on a document-management
    system that needs to implement versioning of documents for a company called Acme
    Corporation. To do this, the system validates that the document has a valid file
    name.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 动态正则表达式匹配是什么意思呢？嗯，这不是一个官方术语，但我们用它来解释在运行时使用变量生成特定表达式的正则表达式。假设你正在为一个名为Acme Corporation的公司工作的文档管理系统，该系统需要实现文档的版本控制。为此，系统会验证文档是否具有有效的文件名。
- en: A business rule states that the file name of any file uploaded on a specific
    day must be prefixed with `acm` (for Acme) and today's date in the yyyy-mm-dd
    format. There can be only text files, Word documents (only `.docx`), and Excel
    documents (only `.xlsx`). Any documents not conforming to this file format are
    processed by another method that takes care of archive and invalid documents.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一项业务规则规定，在特定一天上传的任何文件的文件名必须以前缀 `acm`（代表 Acme）和今天的日期（格式为 yyyy-mm-dd）开头。只能有文本文件、Word
    文档（仅 `.docx`）和 Excel 文档（仅 `.xlsx`）。任何不符合此文件格式的文档将由另一个方法处理，该方法负责归档和无效文档。
- en: The only task that your method needs to perform is to process fresh documents
    as version one documents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您的方法需要执行的唯一任务是处理作为版本一文档的新鲜文档。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a production system, further logic will probably be needed to determine whether
    the same document has been uploaded previously on the same day. This, however,
    is beyond the scope of this chapter. We are just trying to set the scene.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，可能需要进一步逻辑来确定是否在同一天已上传相同的文档。然而，这超出了本章的范围。我们只是在尝试设定场景。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t already done so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已将正确的程序集添加到您的类中。如果您还没有这样做，请在代码文件顶部添加以下行：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'A really nice way to do this is to use an extension method. This way, you can
    call the extension method directly on the file name variable and have it validated.
    In your `Recipes.cs` file, start off by adding a new class called `CustomRegexHelper`
    with the `public static` modifier:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种非常好的方法是使用扩展方法。这样，您可以直接在文件名变量上调用扩展方法，并对其进行验证。在您的 `Recipes.cs` 文件中，首先添加一个名为
    `CustomRegexHelper` 的新类，并使用 `public static` 修饰符：
- en: '[PRE19]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the usual extension method code to the `CustomRegexHelper` class and call
    the `ValidAcmeCompanyFilename` method:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将常规扩展方法代码添加到 `CustomRegexHelper` 类，并调用 `ValidAcmeCompanyFilename` 方法：
- en: '[PRE20]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside your `ValidAcmeCompanyFilename` method, add the following regex. We
    will explain the makeup of this regex in the *How it works…* section of this recipe:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `ValidAcmeCompanyFilename` 方法内部，添加以下正则表达式。我们将在本食谱的 *工作原理…* 部分解释此正则表达式的构成：
- en: '[PRE21]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you have completed this, your extension method should look like this:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，您的扩展方法应如下所示：
- en: '[PRE22]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Back in the `Recipes` class, create a method with the `void` return type called
    `DemoExtendionMethod()`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `Recipes` 类，创建一个名为 `DemoExtendionMethod()` 的 `void` 返回类型的方法：
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add some output text to show the current date and the valid file name types:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些输出文本以显示当前日期和有效的文件名类型：
- en: '[PRE24]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, add the file name checking code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加文件名检查代码：
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will notice that the `if` statement contains the call to the extension
    method on the variable that contains the file name:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到 `if` 语句包含对包含文件名的变量的扩展方法的调用：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you have completed this, your method should look like this:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已完成此操作，您的方法应如下所示：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Going back to the console application, add the following code that simply just
    calls the `void` method. This is just to simulate the versioning method talked
    about earlier:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到控制台应用程序，添加以下代码，该代码仅调用 `void` 方法。这只是为了模拟之前提到的版本化方法：
- en: '[PRE28]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you are done, run your console application:![How to do it…](img/B05391_09_18.jpg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行您的控制台应用程序：![如何操作…](img/B05391_09_18.jpg)
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s have a closer look at the regex generated. The line of code we are looking
    at is the `return` statement in the extension method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看生成的正则表达式。我们正在查看的是扩展方法中的 `return` 语句：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To appreciate what is happening, we need to break this expression up into the
    different components:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解正在发生的事情，我们需要将这个表达式分解成不同的组件：
- en: '| The conditional OR |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 条件或 |'
- en: '| --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `&#124;` | This denotes the OR metacharacter. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 这表示 OR 元字符。 |'
- en: '| **The file prefix and separator** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **文件前缀和分隔符** |'
- en: '| `acm` | The file must begin with the text `acm`. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `acm` | 文件名必须以文本 `acm` 开头。 |'
- en: '| `[_]` | The only valid separator between the date components and the prefix
    in the file name is an underscore. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `[_]` | 文件名中日期组件和前缀之间唯一的有效分隔符是一个下划线。 |'
- en: '| **The date parts** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **日期部分** |'
- en: '| `{DateTime.Now.Year}` | The interpolated year part of the date for the file
    name. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `{DateTime.Now.Year}` | 文件名中日期的插值年份部分。 |'
- en: '| `{DateTime.Now.Month}` | The interpolated month part of the date for the
    file name. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `{DateTime.Now.Month}` | 文件名中日期的插值月份部分。 |'
- en: '| `0[{DateTime.Now.Month}]` | The interpolated month part of the date with
    a leading zero for the file name. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `0[{DateTime.Now.Month}]` | 日期的插值月部分，文件名前有前导零。 |'
- en: '| `{DateTime.Now.Day}` | The interpolated day part of the date for the file
    name. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `{DateTime.Now.Day}` | 日期的插值日部分，用于文件名。 |'
- en: '| `0[{DateTime.Now.Day}]` | The interpolated day part of the date with a leading
    zero for the file name. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `0[{DateTime.Now.Day}]` | 日期的插值日部分，文件名前有前导零。 |'
- en: '| **Valid file formats** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **有效的文件格式** |'
- en: '| `(.txt&#124;.docx&#124;.xlsx)` | Match any of these file extensions for text
    documents, Word documents, or Excel documents. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `(.txt&#124;.docx&#124;.xlsx)` | 匹配这些文件扩展名之一，用于文本文件、Word 文档或 Excel 文档。 |'
- en: '| **Start and end of string** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **字符串的开始和结束** |'
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 告诉正则表达式引擎从给定字符串的开始位置开始匹配。 |'
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match.
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 告诉正则表达式引擎在给定字符串的结束位置停止匹配。 |'
- en: Creating the regex in this manner allows us to always have it stay up to date.
    As we have to always match the current date to the file being validated, this
    creates a unique challenge that is easily overcome using string interpolation,
    `DateTime`, and regex OR statements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建正则表达式使我们总能保持其更新。因为我们必须始终匹配正在验证的文件中的当前日期，这创造了一个独特的挑战，但使用字符串插值、`DateTime`
    和正则表达式 OR 语句可以轻松克服。
- en: Having a look at some of the more useful bits of regex, you will see that this
    chapter has not even begun to scratch the surface of what can be accomplished.
    There is a whole lot more to explore and learn. There are many resources on the
    Internet, as well as some free (some online) and commercial tools that will assist
    you in creating regex.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看一些更有用的正则表达式片段，你会发现这一章甚至还没有触及到可以完成的事情的表面。还有许多东西可以探索和学习。互联网上有许多资源，以及一些免费（有些在线）和商业工具可以帮助你创建正则表达式。
