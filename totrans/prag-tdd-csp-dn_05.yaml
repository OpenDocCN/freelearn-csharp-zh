- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-Driven Development Explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test-Driven Development** (**TDD**) is a set of practices on top of unit
    tests. They alter the way you design your code and you write unit tests. Basically,
    it is a different approach to writing code than the classical technique of writing
    code and then testing it after.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a cliché to say that TDD is not just doing testing first, but rather than
    me telling you otherwise, you will decide yourself after going through *Chapters
    5* and *6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Go through TDD pillars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a software feature following the TDD style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converse the FAQs and criticism around the subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss having TDD with Sintegration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to use TDD to write basic coding
    tasks and understand the topics around the subject and where TDD fits in the software
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch05
  prefs: []
  type: TYPE_NORMAL
- en: TDD pillars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is a set of practices that specify how and when a unit test should be written.
    You can write unit tests without TDD, but TDD has to have a type of test associated
    with it. Sometimes, you can hear TDD and unit tests used as if they mean the same
    thing, but they are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the ecosystem around TDD is sophisticated as it touches a lot of software
    engineering aspects, TDD as a standalone concept is easy to explain and understand.
    We can summarize TDD as these two pillars:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test first**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red, Green, Refactor** (**RGR**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss these pillars.
  prefs: []
  type: TYPE_NORMAL
- en: Test first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea here is to start with the tests before starting with the production
    code. It really means testing code that doesn’t exist yet!
  prefs: []
  type: TYPE_NORMAL
- en: Testing first changes the way we write code, as now you are redirected to think
    about your classes' structure and public methods before the implementation. This
    encourages the developer to reflect on the design from the client’s perspective
    (the client is the external code calling your code, also known as the caller).
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate how to start with tests by going through a few examples
    to get you accustomed to the concept and familiarize you with how it is done.
    Then, we will go into detail about the benefits of this approach in the first
    section of [*Chapter 6*](B18370_06.xhtml#_idTextAnchor140), *The FIRSTHAND Guidelines
    of TDD*.
  prefs: []
  type: TYPE_NORMAL
- en: Red, green, refactor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RGR process is the one used when writing code in TDD-style. This process
    works in tandem with the test first guideline. This is how it goes:'
  prefs: []
  type: TYPE_NORMAL
- en: You are planning to write a coding task, which is part of a feature that you
    want to add to the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You write the unit test for this production code while the production code doesn’t
    exist (as you haven’t written it yet). Also, maybe you are planning to update
    existing production code, so you write a unit test first, assuming the final production
    code is in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You run the unit test and it will fail (red), for one of two reasons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code doesn’t compile, as the production code is not written yet.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The test will fail, as while it is compiling, the logic that implements the
    new coding task is not the right one, as the existing production code has not
    been updated to reflect the new feature yet.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the fastest and minimal code to make the test pass (green). Don’t perfect
    the code at this stage; you can also copy the intended code from the internet.
    The idea is just to get on with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we know that our coding task is in place and it is working; however, you
    might consider refactoring the production code if it suffers from one of these
    issues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Readability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A design that doesn’t comply with the rest of the code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run your unit test to make sure you have not broken anything while you were
    refactoring. If it is broken (red), then you would naturally go back to *step
    3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see why the color names were picked:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red**: Represents failed tests, which look red in the test runners (such
    as VS Test Explorer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: Represents passed tests, which look green in the test runners'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The red, green, refactor process ](img/Figure_5.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The red, green, refactor process
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram highlights the steps that we’ve just discussed in the RGR
    process.
  prefs: []
  type: TYPE_NORMAL
- en: We can draw diagrams and talk more about TDD, or we can demonstrate with examples,
    which is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: TDD by example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TDD is best understood by looking at examples, so let’s take a story and write
    it TDD-style. We will be working on the feature described by this story:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Story Title:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Changing a username*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Story Description:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a customer*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Given I already have an account*'
  prefs: []
  type: TYPE_NORMAL
- en: '*When I navigate to my profile page*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Then I can update my username*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceptance Criteria:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The username can only contain between 8 and 12 characters, inclusive:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Valid: AnameOf8, NameOfChar12*'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Invalid: AnameOfChar13, NameOf7*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Only alphanumerics and underscores are allowed:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Valid: Letter_123*'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Invalid: !The_Start, InThe@Middle, WithDollar$, Space 123*'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the username already exists, generate an error*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s not waste any time and implement this story.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the solution shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a class library called `Uqs.Customer`, add a unit testing project
    to test it called `Uqs.Customer.Tests.Unit`, and add them to a solution called
    `TddByExample.sln`. So, let’s start:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a directory called `TddByExample`, create the `lib` class and the following
    xUnit projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a solution file and add the projects to it. The solution name will be
    the directory name. So, in this case, it will automatically be called `TddByExample.sln`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reference the production code project from the unit tests project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you open the solution, you will get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Solution Explorer showing the newly created project ](img/Figure_5.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Solution Explorer showing the newly created project
  prefs: []
  type: TYPE_NORMAL
- en: Now, to the coding stage.
  prefs: []
  type: TYPE_NORMAL
- en: Adding coding tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The requested feature comprises smaller coding tasks (challenges), so you will
    be adding multiple unit tests with at least one unit test for each coding challenge.
  prefs: []
  type: TYPE_NORMAL
- en: I start with the challenge that gives the shortest feedback and work my way
    up. This will help me build the initial structure without having to worry about
    everything at the same time. It will also help me avoid tasks such as connectivity
    to the database and availability of the username in the database (username is
    already taken) from the start. Then, start adding more sophisticated challenges
    in order of complexity. Let’s see how we can achieve this next.
  prefs: []
  type: TYPE_NORMAL
- en: Coding task one – validate null username
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I normally spend little time analyzing the shortest code challenge and use
    my gut feeling. I feel the shortest route is to check the username for nullability.
    Now, rename the template test class from `UnitTest1.cs` to `ProfileServiceTests.cs`
    and replace the content with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous code does the preparation to pass `null` to our intended method.
    It executes the method and records `Exception` generated by the method.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we check whether we got an exception of the `ArgumentNullException`
    type having `username` as the argument and having the message starting with `Null`.
  prefs: []
  type: TYPE_NORMAL
- en: Before executing this, let’s reflect on what has happened so far.
  prefs: []
  type: TYPE_NORMAL
- en: Naming your test class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Right off the bat, the decision that I had to take was to think of my production
    code class name, because I needed it so I could append the `Tests` suffix to it
    and create my test class name (remember the convention: `ProductionCodeClass`**Tests**).
    I am following **Domain-Driven Design** (**DDD**) in my architecture, so I directly
    thought of this as a service class. Don’t worry about DDD terminology and how
    it fits with TDD for now, as DDD will have a dedicated chapter, [*Chapter 7*](B18370_07.xhtml#_idTextAnchor183),
    *A Pragmatic View of Domain-Driven Design*.'
  prefs: []
  type: TYPE_NORMAL
- en: I didn’t give naming my class deep thought as I can always rename my classes
    with minimal effort. I landed on `ProfileService`, so I can call my unit test
    class `ProfileServiceTests`. Please note that I have not created `ProfileService`
    at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some developers write meaningless test class names and then rename them after
    finishing the first unit test. Do what makes you more productive. This is not
    a rigid process.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test method naming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The moment I wanted to write my test, I needed to think about what I am testing
    and what I should expect, following the `MethodName_Condition_Expectation` approach.
    So, I chose my method name to be `ChangeUsername` and the condition to check if
    `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding your expectations upfront
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The expectation requires a bit of a pause and think. I am expecting whoever
    calls this method to have not sent `null`, as they have checked it on the UI or
    by any other means. So, I will be merciless and throw an exception if it doesn’t
    match my expectation and let the client deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: The point here is that I directly thought from the client’s perspective and
    focused on the external behavior of my intended method.
  prefs: []
  type: TYPE_NORMAL
- en: Making sure the test fails
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this stage, you can see VS highlighting your code with squiggly lines, so
    it doesn’t take a genius to conclude that the code will not compile, as there
    is no production code written yet.
  prefs: []
  type: TYPE_NORMAL
- en: You have taken your first step in RGR, as you’ve got the red.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the production code class shell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s at least be able to compile to get some IntelliSense help from VS. So,
    in your `Uqs.Customer` project, modify `Class1.cs` to be `ProfileService.cs`,
    and the content will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, given that you will be doing this a lot, there are shortcuts for this.
    For example, if you have ReSharper, then it will give you the option to generate
    the production code based on your unit test. With VS, rather than renaming `Class1.cs`
    as in the previous step, just delete it, and follow these steps to do the same
    thing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover over `ProfileService()` where you have the squiggly line, and VS will
    show you a bulb. Expand the bulb and select **Generate new type…** as in the following
    figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Selecting the refactoring bulb ](img/Figure_5.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Selecting the refactoring bulb
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the bulb takes time to appear; you can always use the *Ctrl* + *.*
    shortcut to force it to appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the dialog box appears, you can change its settings as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Generate Type dialog box ](img/Figure_5.4_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Generate Type dialog box
  prefs: []
  type: TYPE_NORMAL
- en: This way, you will get the same `ProfileService.cs` class generated as before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the first option from the bulb menu, **Generate class ‘ProfileService’
    in a new file**, doesn’t do the job, as VS will generate the file in the unit
    testing project, while you intend to generate it in the production code project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our class shell created, let’s continue our production code
    writing process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the production code method shell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create the `ChangeUsername` method, hover over it, and select the bulb as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Generate method ](img/Figure_5.5_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Generate method
  prefs: []
  type: TYPE_NORMAL
- en: 'It will show you what is going to be generated in the display window. It is
    exactly what we want, so select `ProfileService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the generated code. Alternatively, you can write the code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This is using C# 10, so not having `string?` (with a question mark after *string*)
    as the parameter warns the caller that this method doesn’t expect `null`. But,
    the caller can still force a `null`. Notice that the unit test did force a `null`
    in the `Act` section by having a bang sign after the `null`: `sut.ChangeUsername(null``)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the generated code has already added for you a `NotImplementedException`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Having `NotImplementedException` is a good practice to highlight to the reader
    that the code is not yet written, and to throw an exception when called by mistake
    in case you forgot about it and pushed the code to source control.
  prefs: []
  type: TYPE_NORMAL
- en: Now to the fun part, the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the null check logic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All this is to write the following piece of logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first argument in the exception represents the parameter name, and the second
    represents the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Run the unit tests from Test Explorer (*Ctrl* + *R*, *A*) and you should get
    the code compiling and all the tests passing (green).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I looked at the code after I’d written it and I thought it could be improved
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a magic string inside the code to match my parameter name is not a good
    practice, as whenever I change the parameter name, the string doesn’t necessarily
    change with it. I will use the `nameof` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'My refactored code would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that I did these changes, I ran the tests again, and they passed.
  prefs: []
  type: TYPE_NORMAL
- en: While the size of the refactoring is small, and usually refactoring will be
    more sophisticated in a more streamlined example, this example serves as a good
    way to show you how you can implement an optional refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: We have finished our first coding task! The first task is usually longer than
    the others as, in the first one, you will be building the shell and deciding about
    a few names. Our second task is going to be shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Coding task two – validate min and max lengths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again, without spending too much time thinking about the second thing to test,
    I thought of the length validation, according to the story where the length of
    the username should be between 8 and 12 characters included, so this is my second
    unit test to target this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The previous code prepares many testing scenarios for valid and invalid-length
    usernames. It uses the `Theory` attribute to pass multiple scenarios to the unit
    test. In the end, we check if we got an exception of the `ArgumentOutOfRangeException`
    type. We branch with an `if` statement, as a valid username does not produce an
    exception, so we will get `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some practitioners are against having any logic, such as an `if` statement,
    within a unit test. I am with the other school that having light logic that is
    clear and readable would reduce the amount of repetition in unit tests. Do what
    feels readable for you and your team.
  prefs: []
  type: TYPE_NORMAL
- en: This sample test data may come from who wrote the story (for example, the product
    owner, business analyst, or product manager), from you, or a combination of both.
  prefs: []
  type: TYPE_NORMAL
- en: The red stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Run the unit tests, and this newly added unit test should fail as we have no
    implementation written yet.
  prefs: []
  type: TYPE_NORMAL
- en: The green stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add this logic to your method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run the unit tests from Test Explorer (*Ctrl* + *R*, *A*) and you should get
    the code compiling and all the tests passing. We’ve reached green.
  prefs: []
  type: TYPE_NORMAL
- en: The refactoring stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I looked at the code after I’d written it and I thought it could be improved
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: I am getting the length twice to compare it. Lucky for me, C# 8 introduced pattern
    matching that will lead to a more readable syntax (arguably). Also, C# might do
    some optimization magic to prevent the `Length` property from being executed twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'My refactored code would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that I did these changes, I ran the tests again, and they passed.
  prefs: []
  type: TYPE_NORMAL
- en: Coding task three – ensure alphanumerics and underscores only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As per the requirements, we are only allowing alphanumerics and underscores,
    so let’s write the test for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test and it should fail except for the first test of `Letter_123`,
    which is a valid test. We want everything to fail to make sure we did not make
    a mistake. This is the output of Test Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Test Explorer output for the valid letters test ](img/Figure_5.6_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Test Explorer output for the valid letters test
  prefs: []
  type: TYPE_NORMAL
- en: 'You can follow one of these two solutions to make the test fail::'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the production code and write code that will make this test fail. I don’t
    personally like this approach, as I feel it is a purist approach, but there is
    nothing wrong with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debug the code and see why it is passing without implementation. This is the
    approach that I took and it looks like this is a valid scenario anyway, so it
    should have passed. I can ignore the passed test and assume everything has failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let’s write the proper implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can see in all our tests that we are not asserting if there is an exception
    only. We are asserting the type of exception and two fields on the exception.
    This approach will help us catch the specific exception we are looking for and
    avoid catching other exceptions caused by something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quickest way is to use a *regex* that will only allow alphanumerics and
    underscores. The fastest way is to search online for `alphanumeric and underscore
    only C# regex`. I found the regex on StackOverflow and it looks like this: `^[a-zA-Z0-9_]+$`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that my intention is to make this pass as soon as possible without
    thinking too much about the code or polishing it. This is the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the test again and it will pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the code suffers from a performance problem, as having an inline regex
    is slow. Let me optimize the performance and improve the readability. This is
    my whole class after refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run again after refactoring. In all honesty, the test failed for me as I missed
    copying a letter from the regex while refactoring. Running the test again showed
    me that my refactoring wasn’t right, so I fixed the code and tried again.
  prefs: []
  type: TYPE_NORMAL
- en: Coding task four – checking if the username is already in use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, checking if a username is already in use will require a trip to the
    database, and testing for that will require test doubles. Also, as you are doing
    IO operation (by accessing the DB), all your methods will be following the `async`
    `await` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This coding task and other coding tasks that are left for this feature to be
    completed will require database access, and I deliberately avoided this. I wanted
    this chapter to familiarize you with TDD without going through test doubles and
    more advanced topics. In *Part 2*, *Building an Application with TDD*, of this
    book, you will have dedicated chapters that will involve a mix of TDD, DDD, test
    doubles, and DBs. So, for now, we are going to stop here. Otherwise, how can I
    encourage you to continue reading if I explain everything here?
  prefs: []
  type: TYPE_NORMAL
- en: This ends our coding tasks for this chapter, and I hope so far you’ve got the
    TDD rhythm.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When starting a new feature, you need to think of this feature as a series
    of coding challenges. Every coding challenge will start with a unit test, similar
    to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Feature made of tasks, with a unit test targeting each task
    ](img/Figure_5.7_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Feature made of tasks, with a unit test targeting each task
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you don’t have a unit test project created yet, so you’ve seen how
    to create one. Sometimes, you add your unit tests to an existing unit testing
    project and you can immediately go ahead and start adding your tests.
  prefs: []
  type: TYPE_NORMAL
- en: You had to think upfront about how your client will interact with your production
    code and you designed everything according to the expectation of the client.
  prefs: []
  type: TYPE_NORMAL
- en: You followed the RGR pattern in adding each coding task and you’ve seen multiple
    examples of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: More advanced scenarios are kept for *Part 2*, *Building an Application with
    TDD*.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs and criticism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is one of the most controversial topics in modern software development.
    You will find some developers swearing by it and others claiming it is useless.
  prefs: []
  type: TYPE_NORMAL
- en: I will try to objectively answer the questions and show you both views where
    relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Why do I need to do TDD? Can’t I just do unit testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve gathered from the start of the chapter, TDD is a style of writing
    unit tests. So, yes, you can write unit tests without following the TDD style.
    In the next chapter, you will find the *first guideline* from the FIRSTHAND guidelines
    that will focus on the benefits of following the TDD style.
  prefs: []
  type: TYPE_NORMAL
- en: I found that some teams are reluctant to do TDD for various reasons. My recommendation
    is not to abandon unit tests in case your team is not inclined to follow TDD.
    Maybe if you start with unit testing, then the next evolution would be TDD. This
    would slow down the rate of change for some teams.
  prefs: []
  type: TYPE_NORMAL
- en: Did I say this before? Don’t abandon unit testing even if you are not following
    TDD.
  prefs: []
  type: TYPE_NORMAL
- en: TDD feels unnatural to the software process!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I trust that when you first learned programming, the concern was to understand
    basic programming constructs, such as `for` loops, functions, and OOP. Your concerns,
    or your tutor’s concerns, were not producing scalable high-quality software, because
    you just wanted a program that worked, with bugs here and there.
  prefs: []
  type: TYPE_NORMAL
- en: That worked while you were learning, and this is probably what you refer to
    as *natural* because you have done this from day one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real world, the modern expectations from software are to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalable**: Cloud-based solutions became the norm and microservices took
    control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated**: The manual testing process turned out to be old-fashioned. A
    *developer in test* turned into a popular job title, and automated testing became
    the modern trend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DDD**: Having objects interact with each other in a sophisticated manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release pipeline ready (CI/CD)**: CI has a dedicated chapter in this book.
    In brief, your software should allow incremental feature addition and push to
    production every so often.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding scenarios are the concerns of today’s software developers and
    for that, you have to change your work strategy to the new real-life norm. This
    requires a paradigm shift in the way you write code, hence, the TDD norm of development.
  prefs: []
  type: TYPE_NORMAL
- en: Doing TDD is going to slow us down!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When starting a project, not doing any sort of testing would lead to faster
    results in the short term. Consider the following diagram that depicts this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – TDD versus no testing concerning time and features ](img/Figure_5.8_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – TDD versus no testing concerning time and features
  prefs: []
  type: TYPE_NORMAL
- en: If you are starting from scratch building software with no dependencies and
    no features, it is easy to run doing no tests, maybe even having someone manually
    doing them. The project is small, manageable, and easy to change and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test-free software will be fast to develop at the early stages until you start
    having a bunch of dependent features, where you change one and the other is broken!
    This is where test-backed software begins to shine, where adding a new feature
    has less probability of introducing a bug to an existing feature, as this should
    be caught by well-implemented tests. I have heard this phrase many times from
    product owners: *when we add a new feature, another unrelated area breaks!* They
    usually blame the developers or the tester who let this error pass. It is easy
    to think, for non-developers, that features are not related, but you and I know
    that this is not the case.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, after the *critical point*, the slowness in speed for non-tested
    software is due to the fact that the features are no longer manageable. The features
    are changing rapidly and the developers are moving to different areas or even
    leaving the project, and new developers are replacing them.
  prefs: []
  type: TYPE_NORMAL
- en: So, yes, TDD might slow you down, but this depends on where you are in the development
    process. If you passed the critical point in the preceding diagram, then you will
    start reaping the benefits of your investment.
  prefs: []
  type: TYPE_NORMAL
- en: Is TDD relevant for a start-up?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers involved in start-ups are usually stressed out and bombarded with
    feature requests. The company’s survival and funding might depend on the next
    set of features. Rarely the product owners are concerned about the long-term strategy,
    because why bother if the destiny of the start-up is risky? We will worry about
    tomorrow later.
  prefs: []
  type: TYPE_NORMAL
- en: If the start-up may fail before the critical point (in the preceding chart),
    then would it be worth investing in TDD? But what if they passed this critical
    point and have no unit tests? Maybe the company will rewrite their codebase when
    they have financial backers and customers. They will add unit tests, or maybe
    they won’t and they will struggle to add new features.
  prefs: []
  type: TYPE_NORMAL
- en: The start-up situation is complex; you can see this from the previous argument.
    The answer to this question depends on individual cases.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t like to do TDD, I like to do my code design first!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you create your classes' structure before writing your tests, *you are still
    doing TDD*. Remember that TDD is a set of best practices and having your own flavor
    doesn’t exclude you.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing doesn’t test the real thing!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a criticism that the TDD community seeks to actively improve. This is
    mainly related to the usage of test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test doubles try to mimic the behavior of real objects, and the problem here
    is in the word *try*. The problem of mimicking a real object is that it relies
    on the developer’s best attempt to predict what the behavior of the real object
    is. This can be done in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the documentation of the real object and trying to code something similar
    in a test double
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading the source code, if available, and extracting its essence to build the
    test double
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doing a proof-of-concept sample to call the real object to check its behavior
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These ways take research and experience. Sometimes, the test double object
    doesn’t reflect the real object and that may lead to a wrong test and potentially
    to a bug. Let’s take this example of a third-party method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The method above loads a text file and returns it as a string. If we were to
    create a test double that involves this method, the question is what happens if
    the file doesn’t exist at the specified `path`?
  prefs: []
  type: TYPE_NORMAL
- en: Is it going to return null?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it going to return an empty string?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it going to throw an exception? If so, what is the exception?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The developer writing the test double will do the necessary due diligence to
    establish the answer to these questions, but they might get it wrong. The previous
    example was trivial, but you start getting more discrepancies between test doubles
    and real objects with more complex methods. The way to minimize this problem is
    to do the proper due diligence when creating the test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve heard about London-school TDD and classic-school TDD. What are they?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a debate on the internet about which should we use and which is better.
    London-school TDD focuses on test doubles and it is more suited for business applications.
    Business applications are apps dealing with DB and UI. The classic-school TDD
    is more suitable for an algorithmic type of coding.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we only address the London-school TDD, as we are working on developing
    business applications.
  prefs: []
  type: TYPE_NORMAL
- en: Why do some developers dislike unit testing and TDD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing adds time and complexity to product development, obviously for
    a good reason, nevertheless, it is still overhead. Unit testing has four major
    drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development time**: Adding unit testing will multiply development time by
    multiple factors. Developers under pressure to deliver features as soon as possible
    will find unit testing overwhelming.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Modifying existing features**: It will require updating the unit tests as
    well. This can be minimized, but it is hard to eliminate without a major shift
    from unit testing to Sintegration testing, which is going to be discussed in the
    next section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Usage of test doubles**: Some developers have strong feelings against using
    test doubles, as they tend to produce less realistic tests if the test doubles
    were not coded correctly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unit testing is challenging**: It demands advanced coding skills and coordination
    between team members, which requires synergy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit testing is not for the fainthearted. I sympathize with these views, but
    at the same time, I know that companies who are looking for a high-quality product
    should allocate more time for unit tests. *Drawbacks 2* and *3* can be addressed
    by better coding practices, which also require more effort.
  prefs: []
  type: TYPE_NORMAL
- en: What is the relationship between TDD and Agile XP?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many agile workflow flavors, the most popular ones are **Agile Scrum**
    and **Agile Kanban**. However, there is one that is less popular and it is software
    engineering-focused. It is called **Agile XP**, where **XP** stands for **Extreme
    Programming**.
  prefs: []
  type: TYPE_NORMAL
- en: XP puts unit testing in general, and TDD in particular, at the forefront of
    its practices, while the other popular agile practices do not go to this level
    of technical details. XP also tries to solve common software engineering problems,
    such as project management, documentation, and knowledge sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Code documentation via unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XP believes that the best way to document the code is by having unit tests attached
    to it versus having some document written elsewhere that would become quickly
    out of sync with the code. On the other hand, unit tests reflect the current state
    of the system, as they are regularly checked and updated.
  prefs: []
  type: TYPE_NORMAL
- en: The developer can understand the details of any business rule by looking into
    the unit tests rather than reading the documentation that may not go to that level
    of detail.
  prefs: []
  type: TYPE_NORMAL
- en: Can a system survive without TDD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I would bounce the question back to the developer and ask, do you require the
    added quality of TDD? Do you agree with the fact that, as the software grows and
    as the team changes, you need a quality guard?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you can survive without TDD and unit tests, but the quality may suffer.
  prefs: []
  type: TYPE_NORMAL
- en: There are successful software systems rolled in corporates without unit tests.
    This is a fact. However, the teams behind them have a higher maintenance overhead
    and possibly slower release pace, and maybe they have dedicated staff for bug
    fixing, and possibly follow a waterfall SDLC. This is fine as long as the organization
    is happy with the quality and cost and they consider the system as *successful*.
  prefs: []
  type: TYPE_NORMAL
- en: TDD with Sintegration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One criticism of unit testing is that the unit test code will be tightly coupled
    with the implementation. Changing production code will have a rippling effect
    that will force updating, adding, and removing multiple unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: These are ways to reduce coupling with unit tests, which are discussed in [*Chapter
    6*](B18370_06.xhtml#_idTextAnchor140), *The FIRSTHAND Guidelines of TDD*, in *The
    single-behavior guideline* section. However, the provided solutions do reduce
    coupling but don’t get rid of them completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, integration tests have a dependency on the input and output
    of the tested functionality. If we are doing integration testing for an API, then
    we are concerned about what parameters we pass to the API and what we get back,
    that is, the input and output. This creates loose coupling with the code. Here
    is a reminder of how integration testing and unit testing operate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Integration tests versus unit tests ](img/Figure_5.9_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Integration tests versus unit tests
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, unit tests have to understand some details of the layers, while
    integration tests are interested in the input and output. This is why unit tests
    have more coupling to the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests come with their own disadvantages, but Sintegration tests
    solve some of the drawbacks, as we discussed in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097),
    *Real Unit Testing with Test Doubles*.
  prefs: []
  type: TYPE_NORMAL
- en: Sintegration testing as an alternative to unit testing with TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In recent years, Sintegration tests started competing with unit tests as a
    way to address these two issues of unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing from the end-user perspective (the user might be a software client,
    not necessarily a human). This is also known as **outside-in testing**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a loose coupling with the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applying TDD principles to Sintegration can work fine in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Test first can be applied in the same way it is applied with unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The red, green, refactor approach can work similarly to unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design from the test perspective works in the same way as in unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sintegration can use the same mocking framework to build fakes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sintegration can use the same AAA and method naming conventions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main disadvantage is that, while unit testing gives fast feedback as it
    is focused on small SUTs, the Sintegration tests would not give as fast feedback
    to the developer. The reason is that they involve building multiple components
    for the whole feature before a Sintegration test can pass.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Faster and slower feedback ](img/Figure_5.10_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Faster and slower feedback
  prefs: []
  type: TYPE_NORMAL
- en: In the previous figure, you can see the unit tests are only operating on small
    pieces of code units, and while building these units, you can get the results
    of your unit test immediately. On the other hand, the feedback of the Sintegration
    test will be when the whole feature is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example. Let’s say that you are writing a feature to update a
    username. The feature would include, but not be limited to, the following units
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks username length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks username illegal characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks whether the user has the right to change the username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks whether the username is already in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gives the user an alternative view if they supply a used username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves username to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirms to the user that their username has changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While, in theory, each of these units of code can have multiple unit tests,
    and by the time each is coded you get the feedback, the Sintegration test needs
    to wait until the end of the feature so you can get feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges of Sintegration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sintegration tests still rely on fakes, which are test doubles. Fakes are harder
    to build and maintain than doing mocks or stubs. The way to master building fakes
    requires experience in building mocks and stubs, as fakes are usually more complex
    and require advanced coding.
  prefs: []
  type: TYPE_NORMAL
- en: Also, creating fakes has a time overhead and will delay the start of the project
    as, before you can write your first Sintegration test, all your related fakes
    should be ready. For example, if your Sintegration test involves accessing a document
    database and cloud storage, you might need to create fakes for these components
    first, before you do any useful Sintegration test.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing TDD with Sintegration requires more experience than practicing it
    with unit tests. However, the good news is that following the content of this
    book will help you progress, so when the time comes, and you, with your team,
    decide to focus on Sintegration, you will have gained the necessary experience
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve been through the basics and the principles around TDD, thus, I trust that
    at this point, you can confidently describe the process to a colleague. However,
    this chapter is the start of learning TDD, as the book will continue adding to
    your knowledge as you go.
  prefs: []
  type: TYPE_NORMAL
- en: I held my pen (okay, my keyboard) back from writing more advanced examples and
    stopped here for a smoother introduction. I hope that I explained the concept
    in a clear way and encouraged you to continue the book, as the upcoming chapters
    will have more pragmatic examples that will give you the experience to apply TDD
    in your own project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the TDD guidelines and what I refer to
    as the FIRSTHAND guidelines. You will understand why testing first is important
    and what value it offers you.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Martin Fowler on Test-Driven Development*: [https://martinfowler.com/bliki/TestDrivenDevelopment.xhtml](https://martinfowler.com/bliki/TestDrivenDevelopment.xhtml%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extreme Programming*: [https://www.agilealliance.org/glossary/xp](https://www.agilealliance.org/glossary/xp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Classic TDD or “London School”?*: [http://codemanship.co.uk/parlezuml/blog/?postid=987](http://codemanship.co.uk/parlezuml/blog/?postid=987)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
