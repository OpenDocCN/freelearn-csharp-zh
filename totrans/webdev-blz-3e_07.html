<html><head></head><body>
<div><h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-150">Creating an API</h1>
<p class="normal">When running Blazor using WebAssembly (InteractiveWebAssembly or InteractiveAuto) we need to be able to retrieve data and also change our data. For that to work, we need an API to access the data. In this chapter, we will create a web API using <strong class="keyWord">Minimal API</strong>.</p>
<p class="normal">When using Blazor Server, the API will be secured by the page (if we add an <strong class="keyWord">Authorize</strong> attribute), so we get that for free. But with WebAssembly, everything will be executed in the browser, so we need something that WebAssembly can communicate with to update the data on the server.</p>
<p class="normal">To do this, we will need to cover the following topics:</p>
<ul>
<li class="bulletList">Creating the service</li>
<li class="bulletList">Creating the client</li>
</ul>
<h1 class="heading-1" id="_idParaDest-151">Technical requirements</h1>
<p class="normal">Make sure you have read the previous chapters or use the <code class="inlineCode">Chapter06</code> folder as a starting point.</p>
<p class="normal">You can find the source code for this chapter’s end result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter07</a>.</p>
<h1 class="heading-1" id="_idParaDest-152">Creating the service</h1>
<p class="normal">There are <a id="_idIndexMarker340"/>many ways to create a service, such as via REST.</p>
<p class="normal">For those who haven’t worked with<a id="_idIndexMarker341"/> REST before, <strong class="keyWord">REST</strong> stands for <strong class="keyWord">representational state transfer</strong>. Simply put, it is a way for machines to talk to other devices using HTTP.</p>
<p class="normal">With REST, we use different HTTP verbs for different operations. They could look something like this:</p>
<table class="table-container" id="table001-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">URI</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Verb</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Action</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/BlogPosts</code></p>
</td>
<td class="table-cell">
<p class="normal">Get</p>
</td>
<td class="table-cell">
<p class="normal">Gets a list of blog posts</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/BlogPosts</code></p>
</td>
<td class="table-cell">
<p class="normal">Post</p>
</td>
<td class="table-cell">
<p class="normal">Creates a new blog post</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/BlogPosts/{id}</code></p>
</td>
<td class="table-cell">
<p class="normal">Get</p>
</td>
<td class="table-cell">
<p class="normal">Gets a blog post with a specific ID</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/BlogPosts/{id}</code></p>
</td>
<td class="table-cell">
<p class="normal">Put</p>
</td>
<td class="table-cell">
<p class="normal">Replaces a blog post</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/BlogPosts/{id}</code></p>
</td>
<td class="table-cell">
<p class="normal">Patch</p>
</td>
<td class="table-cell">
<p class="normal">Updates a blog post</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/BlogPosts/{id}</code></p>
</td>
<td class="table-cell">
<p class="normal">Delete</p>
</td>
<td class="table-cell">
<p class="normal">Deletes a blog post</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 7.1: Rest calls</p>
<p class="normal">We will implement <a id="_idIndexMarker342"/>an API for <strong class="keyWord">Tags</strong>, <strong class="keyWord">Categories</strong>, and <strong class="keyWord">blog posts</strong>.</p>
<p class="normal">Since the API takes care of whether the <code class="inlineCode">Post</code> should be created, we’ll cheat and only implement <code class="inlineCode">Put</code> (replace) because we don’t know whether we are creating or updating the data.</p>
<p class="normal">We will implement the API in the <strong class="keyWord">BlazorWebApp</strong> project. </p>
<h2 class="heading-2" id="_idParaDest-153">Learning about Minimal APIs</h2>
<p class="normal">Before <a id="_idIndexMarker343"/>we jump into implementing the Minimal API, let’s take a moment to learn about it. Back in November 2019, one of the members of the <strong class="keyWord">Distributed Application Runtime </strong>(<strong class="keyWord">Dapr</strong>) team wrote a couple of tutorials on how to build a distributed calculator using different languages.</p>
<p class="normal">They had<a id="_idIndexMarker344"/> examples using Go, Python, Node.js, and .NET Core. The code showed how much harder it was to write a distributed calculator in C# than in other languages.</p>
<p class="normal">Microsoft asked various non-.NET developers what their perception was of C#. Their response wasn’t great. Then, Microsoft asked them to complete a tutorial using an early version of Minimal APIs.</p>
<p class="normal">After the tutorial, they were asked about their perception, and their response had shifted and was now more positive; it felt like home.</p>
<p class="normal">The goal of<a id="_idIndexMarker345"/> Minimal APIs was to reduce complexity and ceremony and embrace minimalism. I thought that “minimal” meant that I wouldn’t be able to do everything, but digging deeper into the code, I soon realized that was not the case.</p>
<p class="normal">From my point of view, Minimal APIs are a much nicer way to code APIs. The idea is that if we need to, we can grow our API, and as soon as we feel like it, we can move our code into a controller to get more structure. At my workplace, we switched to Minimal APIs because we think the syntax is much nicer.</p>
<p class="normal">A very simple sample of adding a Minimal API would be just adding this line in <code class="inlineCode">Program.cs</code>:</p>
<pre class="programlisting code"><code class="hljs-code">app.MapGet("/api/helloworld", () =&gt; "Hello world!");
</code></pre>
<p class="normal">We say that if we navigate to a URL without specifying any route, just <code class="inlineCode">"/"</code>, we return a string with <code class="inlineCode">"Hello World"</code>.</p>
<p class="normal">This is, of course, the simplest example possible, but it is possible to implement more complex things as well, as we will see in the next section.</p>
<h2 class="heading-2" id="_idParaDest-154">Adding the API controllers</h2>
<p class="normal">We have<a id="_idIndexMarker346"/> three data models: blog posts, Tags, and Categories.</p>
<p class="normal">Let’s create three different files, one for each data model, to demonstrate that there are friendly ways to add more complex APIs using Minimal APIs. For a small project, it would probably make more sense to add everything in <code class="inlineCode">Program.cs</code>.</p>
<h3 class="heading-3" id="_idParaDest-155">Adding APIs for handling blog posts</h3>
<p class="normal">Let’s start <a id="_idIndexMarker347"/>by adding the API methods for handling <a id="_idIndexMarker348"/>blog posts.</p>
<p class="normal">Execute the following steps to create the API:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp</code> project, add a new folder called <code class="inlineCode">Endpoints</code>.</li>
<li class="numberedList">In the <code class="inlineCode">Endpoints</code> folder, create a class called <code class="inlineCode">BlogPostEndpoints.cs</code>. The idea is to create an extension method we can use later in <code class="inlineCode">Program.cs</code>.
    <p class="normal">Add these <code class="inlineCode">using</code> statements at the top of the file:</p>
<pre class="programlisting code"><code class="hljs-code">using Data.Models;
using Data.Models.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Replace<a id="_idIndexMarker349"/> the class with the following code:
        <pre class="programlisting code"><code class="hljs-code">public static class BlogPostEndpoints
{
    public static void MapBlogPostApi(this WebApplication app)
    {
        app.MapGet("/api/BlogPosts",
        async (IBlogApi api, [FromQuery] int numberofposts, [FromQuery] int startindex) =&gt;
        {
            return Results.Ok(await api.GetBlogPostsAsync(numberofposts, startindex));
        });
       }
}
</code></pre>
<p class="normal">As we <a id="_idIndexMarker350"/>are creating an extension method, we must ensure the class is static. The <code class="inlineCode">MapBlogPostApi</code> method uses the <code class="inlineCode">this</code> keyword, which makes the method available on any <code class="inlineCode">WebApplication</code> class.</p>
<p class="normal">We set up the Minimal API by using <code class="inlineCode">MapGet</code> and a path, which means that the method will run if we access that path with the correct parameters using a <code class="inlineCode">Get</code> verb.</p>
<p class="normal">The method takes a couple of parameters. The first is of the <code class="inlineCode">IBlogApi</code> type, which will use dependency injection to get an instance of the class we need, in this case, <code class="inlineCode">BlogApiJsonDirectAccess</code>, which will access the JSON files we have stored.</p>
<p class="normal">The other parameters will use the query string (since we are using the <code class="inlineCode">query</code> attribute); in most cases, a Minimal API will figure these things out, but it’s never wrong to nudge it in the right direction.</p>
<p class="normal">We have created a method that returns the data directly from the database (the same API the Blazor Server project is using).</p>
<p class="normal">We also need to make sure to call it from <code class="inlineCode">Program.cs</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">In <code class="inlineCode">Program.cs</code>, add the following namespace:
        <pre class="programlisting code"><code class="hljs-code">using BlazorWebApp.Endpoints;
</code></pre>
</li>
<li class="numberedList">Also, add<a id="_idIndexMarker351"/> the following code just above <code class="inlineCode">app.Run();</code>:
        <pre class="programlisting code"><code class="hljs-code">app.MapBlogPostApi();
</code></pre>
</li>
<li class="numberedList">It’s time to<a id="_idIndexMarker352"/> test the API; make sure to start the <code class="inlineCode">BlazorWebApp</code> project. In .NET 6, the port numbers are random, so replace <code class="inlineCode">{REPLACEWITHYOURPORTNUMBER}</code> with the port number for your project.
    <p class="normal">Go to the following URL: <code class="inlineCode">https://localhost:{REPLACEWITHYOURPORTNUMBER}/Api/BlogPosts?numberofposts=10&amp;startindex=0</code> (the port number might be something else). We will get some JSON back with a list of our blog posts.</p>
<p class="normal">We are off to a good start! Now, we need to implement the rest of the API as well.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">In the <code class="inlineCode">Endpoints</code>/<code class="inlineCode">BlogPostEndpoint.cs</code> file, in the <code class="inlineCode">MapBlogPostApi</code> method, let’s add the code to get the blog post count:
        <pre class="programlisting code"><code class="hljs-code">app.MapGet("/api/BlogPostCount",
async (IBlogApi api) =&gt;
{
    return Results.Ok(await api.GetBlogPostCountAsync());
});
</code></pre>
<p class="normal">We use the <code class="inlineCode">Get</code> verb but with another route.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">We also need to be able to get one blog post. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">app.MapGet("/api/BlogPosts/{*id}",
async (IBlogApi api, string id) =&gt;
{
    return Results.Ok(await api.GetBlogPostAsync(id));
});
</code></pre>
<p class="normal">In this case, we are using the <em class="italic">Get</em> verb but with another URL, containing the ID for <code class="inlineCode">Post</code> that we want to get.</p>
<p class="normal">We are<a id="_idIndexMarker353"/> using a string as an ID and some databases, like RavenDB, for example, use an ID that looks like this: <code class="inlineCode">CollectionName/IdOfThePost</code>; we also make sure to add <code class="inlineCode">*</code> to the parameter. This way, it will use anything that comes after as an ID, otherwise it would interpret the slash as part of the routing and not find the endpoint.</p>
<p class="normal">Next, we need an API that is protected, typically the one that updates or deletes things.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">Let’s add <a id="_idIndexMarker354"/>an API that saves a blog post. Add the following code under the code we just added:
        <pre class="programlisting code"><code class="hljs-code">app.MapPut("/api/BlogPosts",
async (IBlogApi api, [FromBody] BlogPost item) =&gt;
{
    return Results.Ok(await api.SaveBlogPostAsync(item));
}).RequireAuthorization();
</code></pre>
<p class="normal">As I mentioned earlier in this chapter, we will only add one API for creating and updating blog posts, and we will use the <code class="inlineCode">Put</code> verb (replace) to do that. We have added the <code class="inlineCode">RequireAuthorization</code> method at the end, which will ensure that the user needs to be authenticated to call the method.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="10">Next up, we add a code for deleting blog posts. To do this, add the following code:
        <pre class="programlisting code"><code class="hljs-code">app.MapDelete("/api/BlogPosts/{*id}",
async (IBlogApi api, string id) =&gt;
{
    await api.DeleteBlogPostAsync(id);
    return Results.Ok();
}).RequireAuthorization();
</code></pre>
</li>
</ol>
<p class="normal">In this case, we use the <code class="inlineCode">Delete</code> verb, and just as with saving, we add the <code class="inlineCode">RequireAuthorization</code> method at the end.</p>
<p class="normal">Next, we need to do this for <code class="inlineCode">Categories</code> and <code class="inlineCode">Tags</code> as well.</p>
<h3 class="heading-3" id="_idParaDest-156">Adding APIs for handling Categories</h3>
<p class="normal">Let’s <a id="_idIndexMarker355"/>start<a id="_idIndexMarker356"/> with <code class="inlineCode">Categories</code>. Follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">Endpoints</code> folder, add a new class called <code class="inlineCode">CategoryEndpoints.cs</code>. Replace the code with the following:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models;
using Data.Models.Interfaces;
using Microsoft.AspNetCore.Mvc;
namespace BlazorWebApp.Endpoints;
public static class CategoryEndpoints
{
    public static void MapCategoryApi(this WebApplication app)
    {
        app.MapGet("/api/Categories",
        async (IBlogApi api) =&gt;
        {
            return Results.Ok(await api.GetCategoriesAsync());
        });
        app.MapGet("/api/Categories/{*id}",
        async (IBlogApi api, string id) =&gt;
        {
            return Results.Ok(await api.GetCategoryAsync(id));
        });
        app.MapPut("/api/Categories",
        async (IBlogApi api, [FromBody] Category item) =&gt;
        {
            return Results.Ok(await api.SaveCategoryAsync(item));
        }).RequireAuthorization();
        app.MapDelete("/api/Categories/{*id}",
        async (IBlogApi api, string id) =&gt;
        {
            await api.DeleteCategoryAsync(id);
            return Results.Ok();
        }).RequireAuthorization();
    }
} 
</code></pre>
</li>
<li class="numberedList">In <code class="inlineCode">Program.cs</code>, add the following code just above <code class="inlineCode">app.Run()</code>:
        <pre class="programlisting code"><code class="hljs-code">app.MapCategoryApi();
</code></pre>
</li>
</ol>
<p class="normal">These are <a id="_idIndexMarker357"/>all the<a id="_idIndexMarker358"/> methods needed to handle <code class="inlineCode">Categories</code>.</p>
<p class="normal">Next, let’s do the same thing with <code class="inlineCode">Tags</code>.</p>
<h3 class="heading-3" id="_idParaDest-157">Adding APIs for handling Tags</h3>
<p class="normal">Let’s do<a id="_idIndexMarker359"/> the<a id="_idIndexMarker360"/> same things for Tags by following these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">Endpoints</code> folder, add a new class called <code class="inlineCode">TagEndpoints.cs</code>. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models;
using Data.Models.Interfaces;
using Microsoft.AspNetCore.Mvc;
namespace BlazorWebApp.Endpoints;
public static class TagEndpoints
{
    public static void MapTagApi(this WebApplication app)
    {
        app.MapGet("/api/Tags",
        async (IBlogApi api) =&gt;
        {
            return Results.Ok(await api.GetTagsAsync());
        });
        app.MapGet("/api/Tags/{*id}",
        async (IBlogApi api, string id) =&gt;
        {
            return Results.Ok(await api.GetTagAsync(id));
        });
        app.MapPut("/api/Tags",
        async (IBlogApi api, [FromBody] Tag item) =&gt;
        {
            return Results.Ok(await api.SaveTagAsync(item));
        }).RequireAuthorization();          app.MapDelete("/api/Tags/{*id}",
        async (IBlogApi api, string id) =&gt;
        {
            await api.DeleteTagAsync(id);
            return Results.Ok();
        }).RequireAuthorization();
    }
}
</code></pre>
</li>
<li class="numberedList">In <code class="inlineCode">Program.cs</code>, add the following code just above <code class="inlineCode">app.Run()</code>:
        <pre class="programlisting code"><code class="hljs-code">app.MapTagApi();
</code></pre>
</li>
</ol>
<p class="normal">But wait! What about comments? The way we have implemented comments means that the <a id="_idIndexMarker361"/>component <a id="_idIndexMarker362"/>will never run as WebAssembly, so we don’t really need to implement it in the API. But we are not going to leave the comments hanging – let’s implement those as well!</p>
<h3 class="heading-3" id="_idParaDest-158">Adding APIs for handling comments</h3>
<p class="normal">Let’s do the <a id="_idIndexMarker363"/>same things for comments by following these <a id="_idIndexMarker364"/>steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">Endpoints</code> folder, add a new class called <code class="inlineCode">CommentEndpoints.cs</code>. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models;
using Data.Models.Interfaces;
using Microsoft.AspNetCore.Mvc;
namespace BlazorWebApp.Endpoints;
public static class CommentEndpoints
{
    public static void MapCommentApi(this WebApplication app)
    {
        app.MapGet("/api/Comments/{*blogPostid}",
        async (IBlogApi api, string blogPostid) =&gt;
        {
            return Results.Ok(await api.GetCommentsAsync(blogPostid));
        });
        }).RequireAuthorization();
        app.MapPut("/api/Comments",
        async (IBlogApi api, [FromBody] Comment item) =&gt;
        {
            return Results.Ok(await api.SaveCommentAsync(item));
        }).RequireAuthorization();
        app.MapDelete("/api/Comments/{*id}",
        async (IBlogApi api, string id) =&gt;
        {
            await api.DeleteCommentAsync(id);
            return Results.Ok();
    }
}
</code></pre>
</li>
<li class="numberedList">In <code class="inlineCode">Program.cs</code>, add the following code just above <code class="inlineCode">app.Run()</code>:
        <pre class="programlisting code"><code class="hljs-code">app.MapCommentApi();
</code></pre>
</li>
</ol>
<p class="normal">Great! We <a id="_idIndexMarker365"/>have an API! Now, it’s time to create the<a id="_idIndexMarker366"/> client that will access that API.</p>
<h1 class="heading-1" id="_idParaDest-159">Creating the client</h1>
<p class="normal">To access<a id="_idIndexMarker367"/> the API, we need to create a client. There are many ways of doing this, but we will do it in the simplest way possible by writing the code ourselves.</p>
<p class="normal">The client will implement the same <code class="inlineCode">IBlogApi</code> interface. This way, we have the same code regardless of which implementation we are using, and direct JSON access with <code class="inlineCode">BlogApiJsonDirectAccess </code>or <code class="inlineCode">BlogApiWebClient</code>, which we are going to create next:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Right-click on the <strong class="screenText">Dependencies</strong> node under <code class="inlineCode">BlazorWebApp.Client</code> and select <strong class="screenText">Manage NuGet Packages</strong>.</li>
<li class="numberedList">Search for <code class="inlineCode">Microsoft.AspNetCore.Components.WebAssembly.Authentication</code> and click <strong class="screenText">Install</strong>.</li>
<li class="numberedList">Also, search for <code class="inlineCode">Microsoft.Extensions.Http</code> and click <strong class="screenText">Install</strong>.</li>
<li class="numberedList">In the <code class="inlineCode">BlazorWebApp.Client</code> project, in the root of the project, add a new class and name it <code class="inlineCode">BlogApiWebClient.cs</code>.</li>
<li class="numberedList">Open the newly created file and add the following namespaces:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models;
using Data.Models.Interfaces;
using Microsoft.AspNetCore.Components.WebAssembly.Authentication;
using System.Net.Http.Json;
using System.Text.Json;
</code></pre>
</li>
<li class="numberedList">Add <code class="inlineCode">IBlogApi</code> to the class and make it public like this:
        <pre class="programlisting code"><code class="hljs-code">namespace BlazorWebApp.Client;
public class BlogApiWebClient : IBlogApi
{
}
</code></pre>
</li>
<li class="numberedList">Some API<a id="_idIndexMarker368"/> calls will be public (do not require authentication), but <code class="inlineCode">HttpClient</code> will be configured to require a token.
    <p class="normal">The handling of tokens is handled automatically by Blazor, so we only need one client, and, in this case, we call it <code class="inlineCode">Api</code>.</p>
<p class="normal">To be able to call the API, we need to inject <code class="inlineCode">HttpClient</code>. Add the following code to the class:</p>
<pre class="programlisting code"><code class="hljs-code">    private readonly IHttpClientFactory _factory;
    public BlogApiWebClient(IHttpClientFactory factory)
    {
        _factory = factory;
    }
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">Now, it’s time to implement calls to the API. Let’s begin with the <em class="italic">Get</em> calls for blog posts. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">public async Task&lt;BlogPost?&gt; GetBlogPostAsync(string id)
    {
        var httpclient = _factory.CreateClient("Api");
        return await httpclient.GetFromJsonAsync&lt;BlogPost&gt;($"api/BlogPosts/{id}");
    }
    public async Task&lt;int&gt; GetBlogPostCountAsync()
    {
        var httpclient = _factory.CreateClient("Api");
        return await httpclient.GetFromJsonAsync&lt;int&gt;("/api/BlogPostCount");
    }
    public async Task&lt;List&lt;BlogPost&gt;?&gt; GetBlogPostsAsync(int numberofposts, int startindex)
    {
        var httpclient = _factory.CreateClient("Api");
        return await httpclient.GetFromJsonAsync&lt;List&lt;BlogPost&gt;&gt;($"/api/BlogPosts?numberofposts={numberofposts}&amp;startindex={startindex}");
    }
</code></pre>
<p class="normal">We use the <code class="inlineCode">HttpClient</code> we injected and then call <code class="inlineCode">GetFromJsonAsync</code>, which will automatically download the JSON and convert it into the class we supply to the generic method.</p>
<p class="normal">Now, it <a id="_idIndexMarker369"/>gets a little trickier: we need to handle authentication. Luckily, this is built into <code class="inlineCode">HttpClient</code> so we only need to handle <code class="inlineCode">AccessTokenNotAvailableException</code>. If a token is missing, it will automatically try and renew it, but if there is a problem (for example, the user is not logged in), we can redirect to the login page.</p>
<p class="normal">We will come back to tokens and how authentication works in <em class="chapterRef">Chapter 8</em>, <em class="italic">Authentication and Authorization</em>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">Next, we add the API calls that need authentication, such as saving or deleting a blog post.
    <p class="normal">Add the following code under the code we just added:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task&lt;BlogPost?&gt; SaveBlogPostAsync(BlogPost item)
{
    try
    {
        var httpclient = _factory.CreateClient("Api");
        var response = await httpclient.PutAsJsonAsync&lt;BlogPost&gt;
           ("api/BlogPosts", item);
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize&lt;BlogPost&gt;(json);
    }
    catch (AccessTokenNotAvailableException exception)
    {
        exception.Redirect();
    }
    return null;
}
public async Task DeleteBlogPostAsync(string id)
{
    try
    {
        var httpclient = _factory.CreateClient("Api");
        await httpclient.DeleteAsync($"api/BlogPosts/{id}");
    }
    catch (AccessTokenNotAvailableException exception)
    {
        exception.Redirect();
    }
}
</code></pre>
<p class="normal">If the call throws <code class="inlineCode">AccessTokenNotAvailableException</code>, that means <code class="inlineCode">HttpClient</code> couldn’t get or renew a token automatically, and the user needs to log in.</p>
<p class="normal">This state<a id="_idIndexMarker370"/> should probably never happen because we will ensure that when the user navigates to that page, they will need to be logged in, but it’s better to be safe than sorry.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="10">Now, we need to do the same for <code class="inlineCode">Categories</code>. Add the following code to the <code class="inlineCode">BlogApiWebClient</code> class:
        <pre class="programlisting code"><code class="hljs-code">public async Task&lt;List&lt;Category&gt;?&gt; GetCategoriesAsync()
{
    var httpclient = _factory.CreateClient("Api");
    return await httpclient.GetFromJsonAsync&lt;List&lt;Category&gt;&gt;($"api/Categories");
}
public async Task&lt;Category?&gt; GetCategoryAsync(string id)
{
    var httpclient = _factory.CreateClient("Api");
    return await httpclient.GetFromJsonAsync&lt;Category&gt;($"api/Categories/{id}");
}
public async Task DeleteCategoryAsync(string id)
{
    try
    {
        var httpclient = _factory.CreateClient("Api");
        await httpclient.DeleteAsync($"api/Categories/{id}");
    }
    catch (AccessTokenNotAvailableException exception)
    {
        exception.Redirect();
    }
}
public async Task&lt;Category?&gt; SaveCategoryAsync(Category item)
{
    try
    {
        var httpclient = _factory.CreateClient("Api");
        var response = await httpclient.PutAsJsonAsync&lt;Category&gt;("api/Categories", item);
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize&lt;Category&gt;(json);
    }
    catch (AccessTokenNotAvailableException exception)
    {
        exception.Redirect();
    }
    return null;
}
</code></pre>
</li>
<li class="numberedList">Next up, we<a id="_idIndexMarker371"/> will do the same for <code class="inlineCode">Tags</code>. Add the following code just under the code we just added:
        <pre class="programlisting code"><code class="hljs-code">public async Task&lt;Tag?&gt; GetTagAsync(string id)
{
    var httpclient = _factory.CreateClient("Api");
    return await httpclient.GetFromJsonAsync&lt;Tag&gt;($"api/Tags/{id}");
}
public async Task&lt;List&lt;Tag&gt;?&gt; GetTagsAsync()
{
    var httpclient = _factory.CreateClient("Api");
    return await httpclient.GetFromJsonAsync&lt;List&lt;Tag&gt;&gt;($"api/Tags");
}
public async Task DeleteTagAsync(string id)
{
    try
    {
        var httpclient = _factory.CreateClient("Api");
        await httpclient.DeleteAsync($"api/Tags/{id}");
    }
    catch (AccessTokenNotAvailableException exception)
    {
        exception.Redirect();
    }
}
public async Task&lt;Tag?&gt; SaveTagAsync(Tag item)
{
    try
    {
        var httpclient = _factory.CreateClient("Api");
        var response = await httpclient.PutAsJsonAsync&lt;Tag&gt;("api/Tags", item);
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize&lt;Tag&gt;(json);
    }
    catch (AccessTokenNotAvailableException exception)
    {
        exception.Redirect();
    }
    return null;
}
</code></pre>
</li>
<li class="numberedList">Let’s not forget <a id="_idIndexMarker372"/>about our comments! Add the following code just under the code we just added:
        <pre class="programlisting code"><code class="hljs-code">public async Task&lt;List&lt;Comment&gt;&gt; GetCommentsAsync(string blogpostid)
    {
        var httpclient = _factory.CreateClient("Api");
        return await httpclient.GetFromJsonAsync&lt;List&lt;Comment&gt;&gt;($"api/Comments/{blogpostid}");
    }
    
    public async Task DeleteCommentAsync(string id)
    {
        try
        {
            var httpclient = _factory.CreateClient("Api");
            await httpclient.DeleteAsync($"api/Comments/{id}");
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
    }
    public async Task&lt;Comment?&gt; SaveCommentAsync(Comment item)
    {
        try
        {
            var httpclient = _factory.CreateClient("Api");
            var response = await httpclient.PutAsJsonAsync&lt;Comment&gt;("api/Comments", item);
            var json = await response.Content.ReadAsStringAsync();
            return JsonSerializer.Deserialize&lt;Comment&gt;(json);
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        return null;
    }
</code></pre>
</li>
</ol>
<p class="normal">Great job! Our API client<a id="_idIndexMarker373"/> is now done!</p>
<h1 class="heading-1" id="_idParaDest-160">Summary</h1>
<p class="normal">In this chapter, we learned how to create an API using Minimal APIs and an API client, which is an important part of most applications. This way, we can get blog posts from our database and show them when we are running on WebAssembly. It is worth mentioning that we can always run our applications using a web API; this is just to show that we can use different ways to access our data depending on what hosting model we are currently using.</p>
<p class="normal">In the next chapter, we will add the login functionality to our sites and call our API for the first time.</p>
</div>
</body></html>