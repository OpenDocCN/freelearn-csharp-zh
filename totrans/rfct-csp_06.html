<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor133"/>6</h1>
<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Unit Testing</h1>
<p>In the first part of this book, we covered the process of refactoring and some of the more common refactoring techniques. Now, it’s time for us to take a step back and remind ourselves of what refactoring is: <em class="italic">refactoring is the process of changing the form or shape of the code without changing how </em><em class="italic">it behaves</em>.</p>
<p>In other words, we can make our code as clean and easy to maintain as we can, but if those changes introduce bugs, that’s not refactoring since refactoring is about changing the form of code <em class="italic">without changing its behavior</em>. To improve our code without introducing bugs, we need a safety net: <strong class="bold">unit testing</strong>.</p>
<p>In this chapter, we’ll explore unit tests and cover the following main topics:</p>
<ul>
<li>Understanding testing and unit tests</li>
<li>Testing code with xUnit</li>
<li>Refactoring unit tests</li>
<li>Exploring other testing frameworks</li>
<li>Adopting a testing mindset</li>
</ul>
<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Technical requirements</h1>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter06/Ch6BeginningCode</code> folder.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Understanding testing and unit tests</h1>
<p>Whenever I was<a id="_idIndexMarker342"/> managing or mentoring another developer and they wanted to make a change to a system I’d ask them a question: <em class="italic">“How can you be sure your change won’t </em><em class="italic">break things?”</em></p>
<p>This simple question can be deceptively hard to answer, but every answer I’ve ever heard boils down to a single concept: testing.</p>
<p>I <a id="_idIndexMarker343"/>define <strong class="bold">testing</strong> as <em class="italic">the process of verifying software functionality and detecting unwanted changes to </em><em class="italic">program behavior</em>.</p>
<p>This testing could be done by a human, such as a developer or a quality assurance analyst, or it could be done via software, depending on the type of test involved.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Types of tests and the testing pyramid</h2>
<p>Testing is a <a id="_idIndexMarker344"/>broad field that encompasses many different types of activities, including the following:</p>
<ul>
<li><strong class="bold">Manual testing</strong>, which<a id="_idIndexMarker345"/> involves a person performing some activity manually and verifying the outcome.</li>
<li><strong class="bold">Exploratory testing</strong>, a <a id="_idIndexMarker346"/>subset of manual testing that focuses on exploring how the system reacts to things to find new types of bugs.</li>
<li><strong class="bold">Unit tests</strong>, in <a id="_idIndexMarker347"/>which small parts of the software system are tested in isolation.</li>
<li><strong class="bold">Component tests</strong>, where<a id="_idIndexMarker348"/> larger components of the system are tested.</li>
<li><strong class="bold">Integration tests</strong>, which<a id="_idIndexMarker349"/> involve two components, such as an API and a database, that are tested together.</li>
<li><strong class="bold">End-to-end tests</strong>, in <a id="_idIndexMarker350"/>which entire paths through the system are tested. This usually involves multiple sets of components interacting in sequence.</li>
</ul>
<p>Most of these activities are automated tests where computer code interacts with the system to verify its behavior. We’ll talk more about what factors make up good tests at the end of this chapter.</p>
<p>Automated tests do have some drawbacks. First, automated tests take time to create. Typically, a human must write code or use some tool to script out the test. Secondly, these tests often require ongoing maintenance as the software system changes to stay relevant. Finally, these tests can offer a false sense of security. For example, let’s say a developer wrote a test to navigate to the “book a flight” web page and verify that open seats display as available. This test may pass even if the web page has obvious errors and misalignments on it, simply because the test was only coded to check a small part of the web page.</p>
<p>On the other hand, human testers are intelligent. They have free agency and initiative and can make objective judgments about software that machines cannot. They can find issues that nobody ever thought of writing a test for, and they can provide valuable feedback about the functionality of your products. However, people are usually a lot slower than automated tests and it may take some time for a quality assurance analyst to test a feature once it is ready for testing.</p>
<p>There are strengths and weaknesses when it comes to both automated and manual tests. One is not better than the other; instead, they combine to make for an effective solution to quality issues in software projects.</p>
<p>A popular concept in <a id="_idIndexMarker351"/>software quality is the idea of a <strong class="bold">testing pyramid</strong>. A testing pyramid shows the various types of tests an organization might perform. Additionally, as shown in <em class="italic">Figure 6</em><em class="italic">.1</em>, the width of each segment of the pyramid indicates the <a id="_idIndexMarker352"/>quantity of that type of test:</p>
<div><div><img alt="Figure 6.1 – An example of a testing pyramid" src="img/B21324_06_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – An example of a testing pyramid</p>
<p>In a testing pyramid, such as this one, the items at the base should be the most numerous and the items at the top of the pyramid should be the rarest. Almost every diagram of a testing pyramid is different in the exact types of tests listed in the pyramid, but all of them agree that the most common form of testing should be the unit test and the least common should be manual testing.</p>
<p>Many organizations <a id="_idIndexMarker353"/>get this wrong early in their software development maturity. When that happens, they have a lot of manual tests, few unit tests, and typically no end-to-end, integration, or component tests. As a result, the pyramid would look a little like <em class="italic">Figure 6</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and no other tests" src="img/B21324_06_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and no other tests</p>
<p>This pyramid <em class="italic">should</em> look ridiculous because having very little test automation is almost always a recipe for slow processes, delayed releases, and software bugs reaching production environments!</p>
<p>The larger your system becomes, the less feasible manual testing will be and the longer it will take to discover bugs manually.</p>
<p>The solution to this is <strong class="bold">automated testing</strong>, particularly<a id="_idIndexMarker354"/> automated unit testing.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>Unit tests</h2>
<p>Unit tests<a id="_idIndexMarker355"/> are small methods of code that test other methods in your system to verify those methods perform correctly given a specific scenario.</p>
<p><em class="italic">More succinctly, unit tests are code that tests </em><em class="italic">other code</em>.</p>
<p class="callout-heading">Already familiar with tests?</p>
<p class="callout">You may already be familiar with unit tests if you work with unit tests regularly. If that’s true, you may want to skim the rest of this chapter and resume with the next one.</p>
<p>To illustrate the idea of unit testing, let’s look at a simple method that generates a flight status message:</p>
<pre class="source-code">
public class Flight {
<strong class="bold">  public string BuildMessage(string id, string status){</strong>
<strong class="bold">    return $"Flight {id} is {status}";</strong>
<strong class="bold">  }</strong>
}</pre>
<p>While this <a id="_idIndexMarker356"/>method is very simple, let’s think about the steps we’d need to take to verify it works correctly:</p>
<ol>
<li>Instantiate the <code>Flight</code> class and store that object in a variable.</li>
<li>Declare a pair of string variables representing <code>id</code> and <code>status</code>.</li>
<li>Invoke the <code>BuildMessage</code> method on our flight object from <em class="italic">Step 1</em>.</li>
<li>Store the result of <em class="italic">Step 3</em> in a new string variable.</li>
<li>Verify the string we just stored matched what we expected.</li>
</ol>
<p>This is essentially what a unit test would do. It would instantiate your class, <em class="italic">arrange</em> the variables it needs, <em class="italic">act</em> on the method the unit test is trying to verify, and finally <em class="italic">assert</em> that the result of the method matched what we expected. We call this pattern the <strong class="bold">arrange/act/assert</strong> pattern<a id="_idIndexMarker357"/> and we’ll discuss it more later in this chapter.</p>
<p>To help illustrate this concept, here’s a sample test for the <code>BuildMessage</code> method:</p>
<pre class="source-code">
public class FlightTests {
<strong class="bold">  [Fact]</strong>
<strong class="bold">  public void GeneratedMessageShouldBeCorrect() {</strong>
<strong class="bold">    </strong><strong class="bold">// Arrange</strong>
<strong class="bold">    Flight flight = new();</strong>
<strong class="bold">    string id = "CSA1234";</strong>
<strong class="bold">    string status = "On Time";</strong>
<strong class="bold">    // Act</strong>
<strong class="bold">    string message = flight.BuildMessage(id, status);</strong>
<strong class="bold">    // Assert</strong>
<strong class="bold">    Assert.Equal("Flight CSA1234 is On Time", message);</strong>
<strong class="bold">  }</strong>
}</pre>
<p>Don’t worry<a id="_idIndexMarker358"/> about the specific syntax here as we’ll get into this shortly. For now, understand that the <code>GeneratedMessageShouldBeCorrect</code> method is an example of a unit test that tests a small unit of code to verify a specific piece of functionality.</p>
<p>Specifically, this method verifies that the <code>Flight</code> class’s <code>BuildMessage</code> method calculates and returns an accurate status message given the <code>id</code> and <code>status</code> parameters it receives.</p>
<p>This test can be run quickly alongside all the other tests in the solution and will either pass if the <code>BuildMessage</code> method is acting as expected or will fail if the result of <code>BuildMessage</code> ever changes, as shown in <em class="italic">Figure 6</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 6.3 – A failing unit test" src="img/B21324_06_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A failing unit test</p>
<p>Test failures such as this are helpful because they highlight bugs that developers might otherwise release into production without the failing test flagging the potential issue.</p>
<p>In the next section, we’ll explore unit tests more by introducing the most popular unit testing framework: <strong class="bold">xUnit</strong>.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Testing code with xUnit</h1>
<p>xUnit.net, commonly <a id="_idIndexMarker359"/>referred to as xUnit, is currently the most popular unit testing library in .NET, followed <a id="_idIndexMarker360"/>by <code>Attributes</code> that you can use to identify your test code, as we’ll see shortly. Using these attributes lets<a id="_idIndexMarker362"/> a test runner, such as Visual Studio’s <strong class="bold">Test Explorer</strong>, recognize<a id="_idIndexMarker363"/> your methods as unit tests and run them.</p>
<p>This<a id="_idIndexMarker364"/> chapter’s code starts with most of the classes from the chapters up to this point, organized into various namespaces inside of the <code>Chapter6</code> <code>Chapter6BeginningCode</code> <strong class="bold">solution</strong>.</p>
<p class="callout-heading">Solutions and projects</p>
<p class="callout">In .NET, a project represents a distinct assembly of .NET code that accomplishes some purpose. Different projects have different types, from desktop applications to web servers to class libraries and test projects. Solutions, on the other hand, group all of these projects together into a collection of interrelated projects.</p>
<p>In the remainder of this chapter, we’ll write tests for a number of the classes from the previous chapters. Since xUnit is currently the most popular testing library, let’s start by adding a new xUnit test project to the solution.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Creating an xUnit Test Project</h2>
<p>To <a id="_idIndexMarker365"/>add a new project to a solution, right-click on the solution’s name at the top of <strong class="bold">Solution Explorer</strong>, just below the search bar, and then choose <strong class="bold">Add</strong>, followed by <strong class="bold">New Project…</strong></p>
<p>Next, search for <code>xUnit</code> and select the <strong class="bold">xUnit Test Project</strong> result with the C# label attached to it, as shown in <em class="italic">Figure 6</em><em class="italic">.4</em>. Note that there are also versions of this test project that use other languages, such as VB or F#:</p>
<div><div><img alt="Figure 6.4 – Selecting the xUnit Test Project option" src="img/B21324_06_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Selecting the xUnit Test Project option</p>
<p>Click <code>Chapter6XUnitTests</code>, and click <strong class="bold">Next</strong> again.</p>
<p>After this, you'll need to select the version of .NET to use. Since the code in this book uses <strong class="bold">.NET 8</strong>,  you can select that option and click <strong class="bold">Create</strong>.</p>
<p>This should open a new file in your editor that contains some basic test code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">UnitTest1.cs</p>
<pre class="source-code">
namespace Chapter6XUnitTests {
    public class UnitTest1 {
        [Fact]
        public void Test1() {
        }
    }
}</pre>
<p>Additionally, a new project was added to your solution that now appears in <strong class="bold">Solution Explorer</strong>, as shown in <em class="italic">Figure 6</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 6.5 – The test project in Solution Explorer" src="img/B21324_06_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The test project in Solution Explorer</p>
<p>There <a id="_idIndexMarker367"/>are still a few more steps that we’ll need to do to test our code in the other project. But before we do that, it may surprise you that the code xUnit created is already a runnable unit test.</p>
<p>Click on the <code>Test1</code> unit test, which will turn into a green check mark once the test runs, as shown in <em class="italic">Figure 6</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is visible" src="img/B21324_06_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is visible</p>
<p class="callout-heading">Troubleshooting</p>
<p class="callout">If you do not see <strong class="bold">Test Explorer</strong> after running your tests, click on the <strong class="bold">View</strong> menu and then select <strong class="bold">Test Explorer</strong>. You may also need to build your solution before running tests becomes an option.</p>
<p>Note<a id="_idIndexMarker368"/> that our current test isn’t much of a test and we still haven’t covered the code or how it works. We’ll get there shortly, but first, let’s take the final step in setting up our tests and connect our test project to our <code>Chapter6</code> project.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Connecting the xUnit Test Project to your main project</h2>
<p>In .NET, projects <a id="_idIndexMarker369"/>can depend on code in other projects. This allows you to have a class defined in one project and another project uses that class. This is something we’ll need to be able to do to test code from our unit test project. So, we’ll need to set up a project dependency from the test project to the <code>Chapter6</code> project.</p>
<p>Right-click on the <strong class="bold">Dependencies</strong> node inside of the test project in <strong class="bold">Solution Explorer</strong> and choose <strong class="bold">Add Project Reference…</strong>, as shown in <em class="italic">Figure 6</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 6.7 – Adding a project reference to our test project" src="img/B21324_06_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Adding a project reference to our test project</p>
<p>After this, click the checkmark next to <code>Chapter6</code> and click <code>Chapter6</code> project so that the test project can now reference classes defined in the other project.</p>
<p>With all this in place, we’re ready to write our first real test.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Writing your first unit test</h2>
<p>Our first tests <a id="_idIndexMarker370"/>will test the <code>BaggageCalculator</code> class we built in <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>.</p>
<p><code>BaggageCalculator</code> has a <code>CalculatePrice</code> method with the following method signature:</p>
<pre class="source-code">
public decimal CalculatePrice(int bags, int carryOn,
  int passengers, bool isHoliday)</pre>
<p>We also know the following rules for this method:</p>
<ul>
<li>All carry-on baggage costs $30 per bag</li>
<li>The first checked bag a passenger checks in costs $40</li>
<li>Each subsequent checked bag costs $50</li>
<li>If the travel occurs during the holidays, a 10% surcharge is applied</li>
</ul>
<p>We won’t be able to test all this logic in a single test, and we shouldn’t try. Unit tests should be small and related to one specific piece of logic. If a test fails, that failure should tell you a lot about what is wrong in your system. If unit tests try to do too much, they become harder to understand and a failure tells you less about what is wrong.</p>
<p>Let’s start by taking our <code>UnitTest1</code> class and renaming it using the rename refactoring we covered in <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>. Tests are generally named after the class they test. Since our class tests <code>BaggageCalculator</code>, let’s rename it <code>BaggageCalculatorTests</code>.</p>
<p>Next, we’ll rename the <code>Test1</code> method to reflect what we’re trying to verify. The name of this test will show up in a test failure. So, my general rule of thumb is that if I get a notification that a test failed, its name alone should tell me what went wrong.</p>
<p>In our case, we’re trying to verify that carry-on baggage is priced correctly. So, let’s rename <code>Test1</code> to something like <code>CarryOnBaggageIsPricedCorrectly</code>.</p>
<p>Our code now reads as follows:</p>
<pre class="source-code">
namespace Chapter6XUnitTests {
  <strong class="bold">public class BaggageCalculatorTests</strong> {
    <strong class="bold">[Fact]</strong>
    <strong class="bold">public void CarryOnBaggageIsPricedCorrectly()</strong> {
    }
  }
}</pre>
<p>Before we <a id="_idIndexMarker371"/>move on to writing our test code, let’s highlight a few key things:</p>
<ul>
<li>First, our method has a <code>Fact</code> attribute applied to it. This lets xUnit tell the test runner about our test and effectively registers the test for potential execution.</li>
<li>Next, <code>CarryOnBaggageIsPricedCorrectly</code> returns <code>void</code> and accepts no parameters. Test methods using the <code>Fact</code> attribute cannot accept parameters and must either return <code>void</code> or <code>Task</code> for asynchronous tests. We’ll discuss <code>Theory</code> and <code>InlineData</code> later in this chapter as they allow you to pass in parameters to unit tests.</li>
<li>Finally, both the class and the method are <code>public</code>. Both must be <code>public</code> for the unit test to appear in the test runner.</li>
</ul>
<p>Now that we’ve covered some of the basic mechanics of unit tests, let’s follow the <em class="italic">arrange</em>/<em class="italic">act</em>/<em class="italic">assert</em> pattern to build our test.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Organizing tests with Arrange/Act/Assert</h2>
<p>The <strong class="bold">arrange/act/assert pattern</strong> is a <a id="_idIndexMarker372"/>structural pattern that’s used when writing tests. When<a id="_idIndexMarker373"/> following <em class="italic">arrange</em>/<em class="italic">act</em>/<em class="italic">assert</em>, you perform the following steps:</p>
<ol>
<li><strong class="bold">Arrange</strong> the things that you need for your tests by declaring variables.</li>
<li><strong class="bold">Act</strong> on the specific thing you’re trying to test.</li>
<li><strong class="bold">Assert</strong> that the result of your action produced the desired outcome.</li>
</ol>
<p>Let’s start by arranging the code. Since we’re testing the <code>CalculatePrice</code> method on the <code>BaggageCalculator</code> class, we’ll need to instantiate an instance of the baggage calculator.</p>
<p>We also <a id="_idIndexMarker374"/>know we’ll need to pass in the number of checked and carry-on bags, as well as the number of passengers and whether the travel is during a holiday season. These values should be whatever we think will make the most relevant or representative test, so they’re up to our discretion.</p>
<p>Filling out our <em class="italic">arrange</em> section with variable declarations results in the following code:</p>
<pre class="source-code">
[Fact]
public void CarryOnBaggageIsPricedCorrectly() {
    // Arrange
<strong class="bold">    BaggageCalculator calculator = new();</strong>
<strong class="bold">    int carryOnBags = 2;</strong>
<strong class="bold">    int checkedBags = 0;</strong>
<strong class="bold">    int passengers = 1;</strong>
<strong class="bold">    bool isHoliday = false;</strong></pre>
<p>Here, we’re setting up everything we need to carry out the <em class="italic">act</em> phase. Also, note that I included an <code>// Arrange</code> comment to group related code together. This is something I and many other developers I know do in our test code to help organize tests.</p>
<p>Now that we have our variables in place, we can act upon the code we’re testing: the <code>CalculatePrice</code> method. To do this, we must call the method and store the <code>decimal</code> value it returns:</p>
<pre class="source-code">
// Act
decimal result = <strong class="bold">calculator.CalculatePrice(checkedBags,</strong>
<strong class="bold">  carryOnBags, passengers, isHoliday)</strong>;</pre>
<p>Unlike the <em class="italic">arrange</em> section, the <em class="italic">act</em> section is very brief, usually only a single line long. This is because the <em class="italic">act</em> section focuses on the thing you’re trying to test. We call the method we’re testing on the calculator object that was instantiated earlier and pass it the parameters it needs to do its job.</p>
<p class="callout-heading">The system under test</p>
<p class="callout">In our example, the <code>calculator</code> variable stores the instance of the class we’re testing. This is commonly referred <a id="_idIndexMarker375"/>to as the <code>sut</code> variable name for the object they’re about to test.</p>
<p>Here’s <a id="_idIndexMarker376"/>the cool thing: from our test’s perspective, we don’t care how it does its job. All we care about is that we give the method a set of inputs and we expect a specific output.</p>
<p>We verify this behavior in our <em class="italic">assert</em> section by asserting that one or more things are true. If these things turn out <em class="italic">not</em> to be true, our test will fail. If all of them turn out to be true, the test will pass.</p>
<p>Assertions typically use the <code>Assert</code> class to verify that values match their expected value. In our case, the scenario has 2 carry-on bags and no other bags. At $30 per carry-on bag, this should work out to $60, so our test code becomes as follows:</p>
<pre class="source-code">
// Assert
<strong class="bold">Assert.Equal(60m, result);</strong></pre>
<p>The first parameter of the <code>Equal</code> method is the expected value. That’s the value <em class="italic">you</em> expect your result to be. You should <em class="italic">not</em> be calculating this value in code; otherwise, you risk repeating the same potentially bad logic in the code you’re testing to begin with!</p>
<p>The second parameter is the actual value, which is almost always the result of calling your method in the <em class="italic">act</em> section.</p>
<p>Often, developers new to testing expect the first parameter to be the actual value and the second value to be the expected value. However, this is incorrect and will lead to confusing test failures with swapped values.</p>
<p>For example, if the result was 50 and we verified it correctly with <code>Assert.Equal(60m, result);</code> as we did earlier, you’d see a failure like this:</p>
<pre class="source-code">
  Assert.Equal() Failure
  Expected: 60
  Actual:   <strong class="bold">50</strong></pre>
<p>This is helpful and tells the developer what went wrong.</p>
<p>If you <a id="_idIndexMarker377"/>confused the two parameters and wrote <code>Assert.Equal(result, 60m);</code> you’d get this much more confusing message:</p>
<pre class="source-code">
  Assert.Equal() Failure
  Expected: <strong class="bold">50</strong>
  Actual:   60</pre>
<p>This mistake has caused a lot of confusion and hair loss for me in the past. Do yourself a favor and remember that the first parameter is always the value you expect the result to be.</p>
<p>In <a href="B21324_09.xhtml#_idTextAnchor189"><em class="italic">Chapter 9</em></a>, <em class="italic">Advanced Unit Testing</em>, we’ll introduce a cleaner way of writing assertions with<a id="_idIndexMarker378"/> the <strong class="bold">Shouldly</strong> and <strong class="bold">FluentAssertions</strong> libraries. For now, remember<a id="_idIndexMarker379"/> that the expected value goes first and the actual value goes second.</p>
<p class="callout-heading">Other Assert methods</p>
<p class="callout">The <code>Assert</code> class <a id="_idIndexMarker380"/>has more methods than just <code>Assert.Equal</code>. You can also use <code>Assert.True</code> and <code>Assert.False</code> to verify whether a boolean condition is true or false. <code>Assert.Null</code> and <code>Assert.NotNull</code> can help verify if something is or isn’t null. <code>Assert.Contains</code> and <code>Assert.DoesNotContain</code> will verify the presence or absence of an element in a collection. These are just a few of the methods available through the <code>Assert</code> class. For each of these messages, you can also provide a custom failure message to use when an assertion causes your test to fail.</p>
<p>Now that we’ve added our first unit test, let’s talk specifically about what makes a test pass and what makes a test fail.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Understanding tests and exceptions</h2>
<p>Every <a id="_idIndexMarker381"/>unit <a id="_idIndexMarker382"/>test that runs will pass – unless it encounters something that makes it fail.</p>
<p>That failure could be an <code>Assert</code> statement not matching the expected value, or it could be your program or test throwing an exception without catching it.</p>
<p>When you investigate how <code>Assert</code> methods are implemented, you’ll see that they all throw exceptions when their conditions aren’t met. When these exceptions are thrown, the test runner catches them and fails the test, displaying the failure message and stack trace appropriately.</p>
<p>This is why an empty test will pass even without any <code>Assert</code> statements, and this is why you generally never write a <code>try</code>/<code>catch</code> block in your unit tests unless you are explicitly trying to verify some form of exception-handling logic.</p>
<p>Armed with this understanding of what makes a test fail, let’s write a second test.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Adding additional test methods</h2>
<p>Just like <a id="_idIndexMarker383"/>classes can have multiple methods inside of them, test classes can have multiple test methods inside of them. This is because unit tests are just code in every sense of the word. Unit tests live in classes that are ordinary in every regard, except they live in a special project type and individual unit test methods have <code>[Fact]</code> just before the method is declared.</p>
<p>Let’s illustrate this by adding a test for the next scenario: <em class="italic">The first checked bag costs $40</em>. Here’s what that test would look like:</p>
<pre class="source-code">
[Fact]
public void FirstCheckedBagShouldCostExpectedAmount() {
  // Arrange
  BaggageCalculator calculator = new();
  <strong class="bold">int carryOnBags = 0;</strong>
<strong class="bold">  int checkedBags = 1;</strong>
  int passengers = 1;
  bool isHoliday = false;
  // Act
  decimal result = calculator.CalculatePrice(checkedBags,
carryOnBags, passengers, isHoliday);
  // Assert
  Assert.Equal(<strong class="bold">40m</strong>, result);
}</pre>
<p>There are a lot of similarities between this test and the prior one, but the key differences are that the number of carry-on and checked bags has changed to match the new scenario we’re testing, and the expected total is now $40 instead of $60.</p>
<p>Each test you write should be different. However, if you start to notice a lot of commonalities between tests, it’s probably time to refactor your unit tests.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Refactoring unit tests</h1>
<p>Unit tests <a id="_idIndexMarker384"/>are code, and like other types of code, they can degrade in quality over time when not given proper respect and proactive refactoring.</p>
<p>Hence, when you see code smells such as duplicated code that appears in most of your tests, it’s a sign that your tests need to be refactored.</p>
<p>In this section, we’ll explore several ways of refactoring your test code.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Parameterizing tests with Theory and InlineData</h2>
<p>When <a id="_idIndexMarker385"/>we think about the similarities between our two tests, they only vary based on the values being passed into the method we’re testing and the value we expect the result to be.</p>
<p>Thinking about our test method, this is a clear case where it’d be wonderful to have parameters that could go into one test method that could represent multiple unit tests, each testing something slightly different, but with similar code.</p>
<p>As you may recall from earlier, unit tests that use <code>Fact</code> cannot have any parameters to them. However, xUnit gives us another attribute called <code>Theory</code> that allows us to pass data into the unit test as parameters.</p>
<p>There are multiple different ways of providing data to these parameters, but the most common way is to use an <code>InlineData</code> attribute to provide the test parameter data next to the method.</p>
<p>Here’s an<a id="_idIndexMarker386"/> example of using <code>Theory</code> and <code>InlineData</code> to test four different scenarios around baggage pricing using the same test code:</p>
<pre class="source-code">
<strong class="bold">[Theory]</strong>
<strong class="bold">[InlineData(0, 0, 1, false, 0)]</strong>
<strong class="bold">[InlineData(2, 3, 2, false, 190)]</strong>
<strong class="bold">[InlineData(2, 1, 1, false, 100)]</strong>
<strong class="bold">[InlineData(2, 3, 2, true, 209)]</strong>
public void BaggageCalculatorCalculatesCorrectPrice<strong class="bold">(</strong>
<strong class="bold">  int carryOnBags, int checkedBags, int passengers,</strong>
<strong class="bold">  bool isHoliday, decimal expected)</strong> {
    // Arrange
    BaggageCalculator calculator = new();
    // Act
    decimal result = calculator.CalculatePrice        (<strong class="bold">checkedBags, carryOnBags, passengers, isHoliday</strong>);
    // Assert
    Assert.Equal(<strong class="bold">expected</strong>, result);
}</pre>
<p>While this is only a single method, each <code>InlineData</code> line represents a unique unit test and, as shown in <em class="italic">Figure 6</em><em class="italic">.8</em>, it will show up as an individual test in the test runner:</p>
<div><div><img alt="Figure 6.8 – The four theory-based tests in Test Explorer grouped under a single test" src="img/B21324_06_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The four theory-based tests in Test Explorer grouped under a single test</p>
<p>Although <a id="_idIndexMarker387"/>using <code>Theory</code> instead of <code>Fact</code> can initially be harder to read, the maintainability advantage is huge. First, parameterized tests have less code duplication. Secondly, if you need to update your tests later, you only need to update a single method instead of the many separate methods if you wrote the same tests using <code>Fact</code>.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>Initializing test code with constructors and fields</h2>
<p><code>Theory</code> isn’t <a id="_idIndexMarker388"/>the only way to improve your test code. If you find that your tests do a lot of work that is potentially sharable, you can introduce private methods to help organize your test code.</p>
<p>For example, let’s say you wanted to test the <code>FlightScheduler</code> class from <a href="B21324_05.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a> and you wanted to start with testing that adding a flight to the schedule via <code>ScheduleFlight</code> results in that flight showing up when <code>GetAllFlights</code> is called.</p>
<p>To do this, you’ve created a <code>FlightSchedulerTests</code> class and are working on a <code>ScheduleFlightShouldAddFlight</code> unit test.</p>
<p>As you begin to write the test, you notice the <code>ScheduleFlight</code> method requires an <code>IFlightInfo</code> instance, which, in turn, needs several <code>AirportEvent</code> objects. These <code>AirportEvent</code> objects require their own <code>Airport</code> instances.</p>
<p>These dependencies result in you writing a lot of <em class="italic">arrange</em> code to set up for your test:</p>
<pre class="source-code">
[Fact]
public void ScheduleFlightShouldAddFlight() {
  // Arrange
  Airport airport1 = new() {
    Code = "DNA",
    Country = "United States",
    Name = "Dotnet Airport"
  };
  Airport airport2 = new() {
    Code = "CSI",
    Country = "United Kingdom",
    Name = "C# International Airport"
  };
  FlightScheduler scheduler = new();
  PassengerFlightInfo flight = new() {
    Id = "CS2024",
    Status = FlightStatus.OnTime,
    Departure = new AirportEvent() {
        Location = airport1,
        Time = DateTime.Now,
    },
    Arrival = new AirportEvent() {
        Location = airport2,
        Time = DateTime.Now.AddHours(2)
    }
  };</pre>
<p>This large volume of code isn’t necessarily <em class="italic">bad</em>, but it does distract from the rest of the test <a id="_idIndexMarker389"/>method, which performs the scheduling and verifies that the flight was added:</p>
<pre class="source-code">
  // Act
  scheduler.ScheduleFlight(flight);
  // Assert
  IEnumerable&lt;IFlightInfo&gt; result =
    scheduler.GetAllFlights();
  Assert.NotNull(result);
  Assert.Contains(flight, result);
}</pre>
<p>While a lengthy <em class="italic">arrange</em> section isn’t the end of the world, other tests may likely want to create their own <code>PassengerFlightInfo</code>, <code>Airport</code>, or <code>AirportEvent</code>, which would lead to very similar code showing up between tests.</p>
<p>To help improve the readability of our arrange method, we can introduce fields for the two airports and set them up in the constructor:</p>
<pre class="source-code">
public class FlightSchedulerTests {
<strong class="bold">  private readonly Airport _airport1;</strong>
<strong class="bold">  private readonly Airport _airport2;</strong>
  public FlightSchedulerTests() {
    <strong class="bold">_airport1 = new()</strong> {
        Code = "DNA",
        Country = "United States",
        Name = "Dotnet Airport"
    };
    <strong class="bold">_airport2 = new()</strong> {
        Code = "CSI",
        Country = "United Kingdom",
        Name = "C# International Airport"
    };
  }</pre>
<p>When<a id="_idIndexMarker390"/> xUnit runs your test code, it will instantiate the <code>FlightSchedulerTests</code> class once for every unit test in that class. This means that any logic in the constructor or field initializers will run whenever any test in that class is run.</p>
<p>This lets us simplify the <em class="italic">arrange</em> section of our test considerably:</p>
<pre class="source-code">
// Arrange
FlightScheduler scheduler = new();
PassengerFlightInfo flight = new() {
    Id = "CS2024",
    Status = FlightStatus.OnTime,
    Departure = new AirportEvent() {
        <strong class="bold">Location = _airport1,</strong>
        Time = DateTime.Now
    },
    Arrival = new AirportEvent() {
        Lo<strong class="bold">cation = _airport2,</strong>
        Time = DateTime.Now.AddHours(2)
    }
};</pre>
<p>This process can be repeated as needed. For example, if you wanted to reuse the same <code>PassengerFlightInfo</code> between tests, you could add a <code>_flight</code> field and initialize it in the constructor as well.</p>
<p>The refactoring process isn’t about minimizing the size of the <em class="italic">arrange</em> section; it’s about keeping <a id="_idIndexMarker391"/>code duplication low while keeping the important aspects of your test visible to other developers reading your code.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Sharing test code with methods</h2>
<p>Another <a id="_idIndexMarker392"/>technique you can use to keep your code focused is to extract reusable methods from your test code to help accomplish common <em class="italic">arrange</em> tasks.</p>
<p>For example, if you wanted to test that removing a flight correctly removes the flight from the scheduler, you’d need a test that looks a lot like the test we just covered.</p>
<p>When you think about it, both tests don’t care much about the specifics of the flight being added – they care that when a flight is scheduled, it appears in the list of flights and that when a flight is removed, it should no longer be included.</p>
<p>To accomplish this, we can extract a method to create our <code>Flight</code> object. This method could take in a flight identifier and return the created flight, as shown here:</p>
<pre class="source-code">
<strong class="bold">private PassengerFlightInfo CreateFlight(string id)</strong>
<strong class="bold">  =&gt; new()</strong> {
    Status = FlightStatus.OnTime,
<strong class="bold">    Id = id,</strong>
    Departure = new AirportEvent() {
      Location = _airport1,
      Time = DateTime.Now
    },
    Arrival = new AirportEvent() {
      Location = _airport2,
      Time = DateTime.Now.AddHours(2)
    }
  };</pre>
<p>Our prior test can now call this method to create its flight:</p>
<pre class="source-code">
[Fact]
public void ScheduleFlightShouldAddFlight() {
  // Arrange
  FlightScheduler scheduler = new();
  <strong class="bold">PassengerFlightInfo flight = CreateFlight("CS2024");</strong>
  // Act
  scheduler.ScheduleFlight(flight);
  // Assert
  IEnumerable&lt;IFlightInfo&gt; result =
    scheduler.GetAllFlights();
  Assert.NotNull(result);
  Assert.Contains(flight, result);
}</pre>
<p>See how <a id="_idIndexMarker393"/>much more focused this method is? You can quickly read it and get the intent of the test without having to focus on all the mechanics needed to create the flight.</p>
<p class="callout-heading">Testing void methods</p>
<p class="callout">One question I often encounter is “How do you test <code>void</code> methods since they don’t return anything?” Most of the time, when you write tests, you test the return value of a method, but with <code>void</code> methods, you test the side effects of that method. This <code>ScheduleFlight</code> test is an example of how a <code>void</code> method can be tested. In our case, the side effect of scheduling a flight <em class="italic">should</em> be that the flight is present later when we’re getting all the flights from the scheduler.</p>
<p>Now, let’s look at the flight removal test, which uses the same method:</p>
<pre class="source-code">
[Fact]
public void RemoveShouldRemoveFlight() {
  // Arrange
  FlightScheduler scheduler = new();
  <strong class="bold">PassengerFlightInfo flight = CreateFlight("CS2024");</strong>
  scheduler.ScheduleFlight(flight);
  // Act
  scheduler.RemoveFlight(flight);
  // Assert
  IEnumerable&lt;IFlightInfo&gt; result =
    scheduler.GetAllFlights();
  Assert.NotNull(result);
  Assert.DoesNotContain(flight, result);
}</pre>
<p>This <a id="_idIndexMarker394"/>method is focused on the task of scheduling a flight and then removing it, and then verifying that the flight is no longer on the list of flights. If adding and removing a flight doesn’t remove it from the list of flights, that would be a bug and the test would fail.</p>
<p class="callout-heading">Sharing methods between test classes</p>
<p class="callout">If you find that many of your test classes would benefit from the same “helper” methods, such as <code>CreateFlight</code>, you may want to consider moving these helpers to a static class in your test project. This pattern is sometimes referred to as the <strong class="bold">ObjectMother</strong> or Builder pattern<a id="_idIndexMarker395"/> and is described further in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
<p class="callout">Alternatively, you could introduce a base testing class, move your shared methods to that class, and then have your tests inherit from that class. Test classes and test projects are just like normal code and many of the refactoring tricks we used in part 1 of this book will help improve your tests as well.</p>
<p>Before we close out this chapter with a discussion on adopting a testing mindset, let’s briefly look at a pair of other popular C# testing frameworks.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Exploring other testing frameworks</h1>
<p>Beyond xUnit, the <a id="_idIndexMarker396"/>next most popular testing frameworks are <strong class="bold">NUnit</strong> and <strong class="bold">MSTest</strong>.</p>
<p>These two frameworks operate in very similar ways to xUnit but with slight differences in the syntax you use to declare a unit test.</p>
<p>I’ve had the opportunity to program professionally and recreationally in all three major testing frameworks and I can tell you that these differences are largely cosmetic. That said, you will find that certain frameworks have specific features that might not be present in the others.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Testing with NUnit</h2>
<p>Of the three<a id="_idIndexMarker397"/> testing frameworks, NUnit’s syntax is my favorite because<a id="_idIndexMarker398"/> it uses the <code>Test</code> name for both unit tests that require no parameters (equivalent to an xUnit <code>Fact</code>) and those that do (equivalent to an xUnit <code>Theory</code>).</p>
<p>Here’s a parameterized test that verifies the <code>Load</code> method on <code>PassengerFlightInfo</code>:</p>
<pre class="source-code">
public class PassengerFlightTests {
<strong class="bold">    [TestCase(6)]</strong>
    public void AddPassengerShouldAdd(int passengers) {
        // Arrange
        PassengerFlightInfo flight = new();
        // Act
        flight.Load(passengers);
        // Assert
        int actual = flight.Passengers;
<strong class="bold">        Assert.AreEqual(passengers, actual);</strong>
<strong class="bold">        Assert.That(actual, Is.EqualTo(passengers));</strong>
    }
}</pre>
<p>In <code>NUnit</code>, Test and <code>TestCase</code> replace Theory and <code>InlineData</code>. If this test were not parameterized, <code>TestCase</code> would become <code>Test</code>.</p>
<p>The<a id="_idIndexMarker399"/> assert section of this test is a little different. The first thing to note is that NUnit’s assertion method is <code>Assert.AreEqual</code> instead of <code>Assert.Equal</code>. While this is a minor difference, I find that the code reads a bit better.</p>
<p>Below the <code>Assert.AreEqual</code> line is the <code>Assert.That</code> line. This is NUnit’s newer constraint model of unit tests; it reads a bit more fluently and reduces your chances of confusing parameters like the expected and actual values on an assertion. Both ways of writing NUnit tests are valid and work fine.</p>
<p>One final note: in NUnit, all tests in a test class share the same class instance. This means that values stored in fields or properties on your tests will be shared by all tests in that test class. This is different from xUnit which creates a new test class instance for each test that runs. </p>
<p>With NUnit explored, let's look at MSTest.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Testing with MSTest</h2>
<p>MSTest’s official name was <strong class="bold">Visual Studio Unit Testing Framework</strong>, but the framework <a id="_idIndexMarker400"/>has come to <a id="_idIndexMarker401"/>be known as <strong class="bold">MSTest</strong> throughout the community and even throughout Microsoft’s internal documentation.</p>
<p class="callout-heading">MSTest V2</p>
<p class="callout">While MSTest had a poor reputation for nearly a decade due to a lack of feature parity between it and NUnit and xUnit, Microsoft revised MSTest in 2016, calling it <strong class="bold">MSTest V2</strong> and bringing many improvements to the framework to the point where it is now on par with its competitors.</p>
<p>Like NUnit, MSTest <a id="_idIndexMarker402"/>uses a single <code>TestMethod</code> attribute to mark both parameterized and unparameterized unit tests. However, unlike both NUnit and xUnit, MSTest also requires a <code>TestClass</code> attribute on the class itself to make the individual tests discoverable. This is something to watch out for when writing tests in MSTest as it’s another thing you can miss to make your tests not show up in the test runner.</p>
<p>Let’s look at a <a id="_idIndexMarker403"/>sample parameterized test in MSTest that verifies the <code>FullName</code> property of<a id="_idIndexMarker404"/> the <code>Passenger</code> class from our <code>BoardingProcessor</code> class from <a href="B21324_03.xhtml#_idTextAnchor045"><em class="italic">Chapter 3</em></a>:</p>
<pre class="source-code">
<strong class="bold">[TestClass]</strong>
public class PassengerTests {
<strong class="bold">  [TestMethod]</strong>
<strong class="bold">  </strong><strong class="bold">[DataRow("Calvin", "Allen", "Calvin Allen")]</strong>
<strong class="bold">  [DataRow("Matthew", "Groves", "Matthew Groves")]</strong>
<strong class="bold">  [DataRow("Sam", "Gomez", "Sam Gomez")]</strong>
<strong class="bold">  [DataRow("Brad", "Knowles", "Brad Knowles")]</strong>
  public void PassengerNameShouldBeCorrect(string first,
    string last, string expected) {
    // Arrange
    Passenger passenger = new() {
      FirstName = first,
      LastName = last,
    };
    // Act
    string fullName = passenger.FullName;
    // Assert
    <strong class="bold">Assert.AreEqual(expected, fullName);</strong>
  }
}</pre>
<p>Here, this parameterized test evaluates the name of each of this book’s technical reviewers from <code>DataRow</code>, just like <code>InlineData</code> does in xUnit or <code>TestCase</code> does in NUnit.</p>
<p>While the MSTest syntax is different, there are many similarities between it and the other test frameworks.</p>
<p>The major<a id="_idIndexMarker405"/> differences between MSTest and NUnit are the inclusion of the <code>TestClass</code> attribute and the names <code>TestMethod</code> and <code>DataRow</code> instead of <code>Test</code> and <code>TestCase</code>, respectively. Even the naming of the <code>Assert.AreEqual</code> methods are identical between the two frameworks.</p>
<p>Ultimately, these<a id="_idIndexMarker406"/> three testing frameworks are all very similar and serve a powerful role in your goal of high-quality software. I’ve found that I can work effectively in any of the three frameworks. While I tend to prefer NUnit’s syntax, I use xUnit in new projects because xUnit has largely become the community standard.</p>
<p>My recommendation is to pick the library whose syntax you like the most and use that for your projects and focus your efforts on writing good tests and adopting a testing mindset.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Adopting a testing mindset</h1>
<p>Let’s take a <a id="_idIndexMarker407"/>step back and talk about why a book on refactoring features an entire series of chapters around testing. The reason is that code that needs to be refactored is often a bit more volatile and tends to break more easily when changed. Since the art of refactoring is about changing the form of the software without changing its behavior, introducing bugs when refactoring is undesirable and unacceptable.</p>
<p>This is where tests come in. Tests give you the confidence you and your team need to be able to improve your code. Your legacy code may or may not have tests around it already, so the responsibility and necessity of ensuring good tests are present falls to you before you perform any testing work.</p>
<p>This requires you to adopt a testing mindset. This phrase refers to thinking about tests at the <em class="italic">beginning</em> of the development process as a vital component of software development and refactoring, not as an afterthought.</p>
<p>While we’ll explore this concept at length in the next chapter as we discuss <strong class="bold">test-driven development</strong>, let’s touch on a few considerations that will help you be successful with tests in your organization and adopt a testing mindset.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Incorporating testing into your workflow</h2>
<p>Testing <a id="_idIndexMarker408"/>should be a standard part of your everyday life as a software engineer.</p>
<p>This means that you should think about testing whenever you make any change to a system, whether the change is a new feature, fixing a bug, or paying down technical debt through refactoring.</p>
<p>This requires a shift of mentality from seeing tests as tedious or something you ought to do to thinking of tests as things that have intrinsic value to the codebase and even to the larger organization. This is because tests provide value through their role as a sort of “living documentation” of your codebase, their ability to provide a safety net against certain types of bugs in the future, and their ability to give you and the business confidence in the code you’re writing.</p>
<p>You will, of course, bump into pieces of software that are significantly harder to test. These might be pieces of code working with the user interface or they might be pieces of code with very strong dependencies to other systems.</p>
<p>We’ll touch more on dependencies later in this section and again in <em class="italic">Chapters 8</em> and <em class="italic">9</em>, but testing the user interface is typically done with specialized tools and libraries and varies based on whether you are testing a web, desktop, or mobile application. As a result, user interface testing is outside the scope of this book. However, isolating dependencies is usually a strong part of that process.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Isolating dependencies</h2>
<p>When we talk <a id="_idIndexMarker409"/>about isolating dependencies, this means that when we test a piece of code, testing it shouldn’t alter anything else.</p>
<p>For example, when we’re trying to verify that scheduling a flight adds the flight to the list of flights in the system, we don’t want the system to send an email with a flight confirmation every time we run our unit test!</p>
<p>Such an example might look like this:</p>
<pre class="source-code">
public class FlightScheduler {
  <strong class="bold">private readonly EmailClient _email = new();</strong>
  public void ScheduleFlight(Flight flight) {
     // other logic omitted...
     _<strong class="bold">email.SendMessage($"Flight {flight.Id} confirmed");</strong>
  }
}</pre>
<p>Here, <code>FlightScheduler</code> has an <code>EmailClient</code> class and calls <code>SendMessage</code> on the client every time a flight is scheduled. This is a strong dependency from <code>FlightScheduler</code> to the <code>EmailClient</code> class and will result in an undesirable side effect of sending emails when this code is tested.</p>
<p>Side effects<a id="_idIndexMarker410"/> such as sending emails or interacting with the filesystem or a database are often undesirable in unit tests, as we’ll discuss shortly.</p>
<p>While it’s good for systems to be able to do these things, we want to test our units of code in isolation without them having side effects we don’t like. We can work around this via a process called <strong class="bold">dependency injection</strong>, where<a id="_idIndexMarker411"/> a class is no longer responsible for creating the dependencies it needs but gets them from others.</p>
<p>A more testable version of <code>FlightScheduler</code> would look like this:</p>
<pre class="source-code">
public class FlightScheduler {
  <strong class="bold">private readonly IEmailClient _email;</strong>
<strong class="bold">  public FlightScheduler(IEmailClient email) {</strong>
<strong class="bold">    _email = email;</strong>
<strong class="bold">  }</strong>
  public void ScheduleFlight(Flight flight) {
     // other logic omitted...
     _email.SendMessage($"Flight {flight.Id} confirmed");
  }
}</pre>
<p>Here, the dependency on the <code>EmailClient</code> class is injected into this class in its constructor and a new <code>IEmailClient</code> interface is used so that we can use a different implementation of this interface for testing. This test-specific version wouldn’t have the negative side effect of sending emails, making it more acceptable.</p>
<p>Dependency injection<a id="_idIndexMarker412"/> and <a id="_idIndexMarker413"/>its related terms, <strong class="bold">inversion of control</strong> and <strong class="bold">dependency inversion</strong>, are<a id="_idIndexMarker414"/> complex topics that take some <a id="_idIndexMarker415"/>time to grasp. So, we’ll revisit them in <a href="B21324_08.xhtml#_idTextAnchor173"><em class="italic">Chapter 8</em></a>, <em class="italic">Avoiding Code Anti-Patterns with SOLID</em>. Additionally, experienced testers may be crying out that a mocking framework such as Moq or NSubstitute can help with some of these concerns. We’ll cover these libraries in <a href="B21324_07.xhtml#_idTextAnchor161"><em class="italic">Chapter 7</em></a>.</p>
<p>For now, let’s move on to talking about other factors that constitute good and bad tests.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Evaluating good and bad tests</h2>
<p>Good <a id="_idIndexMarker416"/>unit tests should be as follows:</p>
<ul>
<li><strong class="bold">Fast to run</strong>: If tests take minutes to run, developers won’t run them.</li>
<li><strong class="bold">Reliable and repeatable</strong>: Tests shouldn’t randomly fail or pass or fail based on the day of the week, time of day, or which other tests were run earlier.</li>
<li><strong class="bold">Independent from one another</strong>: One test should never impact another test passing or failing and tests shouldn’t need to be run in a certain order.</li>
<li><strong class="bold">Isolated</strong>: They should be kept independent of dependencies such as databases, files on disk, cloud resources, or external APIs. Not only do these things slow down your tests but if we’re testing these interactions, that’s an <em class="italic">integration test</em>, not a unit test.</li>
<li><strong class="bold">Readable</strong>: Tests serve as examples of how to interact with your classes. Additionally, when a test fails, its failure should be easy to understand.</li>
<li><strong class="bold">Portable</strong>: Tests shouldn’t require significant machine setup and should be runnable on any developer’s machine or another machine as part of a <strong class="bold">continuous integration/continuous delivery</strong> (<strong class="bold">CI/CD</strong>) pipeline.</li>
</ul>
<p>In contrast, bad tests take time to run, are “flaky” and randomly fail, cannot be run in parallel or out of order, are difficult to understand regarding what they’re testing or why, and require<a id="_idIndexMarker417"/> a lot of manual configuration to run reliably.</p>
<p>In general, you want to favor many small unit tests that are fast to run, easy to understand, and reliable over more ambitious tests that test too many things at once, leading to slow tests that lead to unclear and unreliable test failures.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Thoughts on code coverage</h2>
<p>I can’t talk <a id="_idIndexMarker418"/>about unit testing without introducing <strong class="bold">code coverage</strong>. Code coverage is<a id="_idIndexMarker419"/> the lines of code that run as part of any unit test. If a test causes the line of code to run, it is considered covered; otherwise, it is considered not covered.</p>
<p>Several tools calculate code coverage, including Visual Studio Enterprise and JetBrains ReSharper, which we talked about briefly in <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>. If you have Visual Studio Enterprise, you can calculate code coverage by selecting the <strong class="bold">Test</strong> menu and then <strong class="bold">Analyze Code Coverage for All Tests</strong>. This will show the lines of code that are covered and not covered by unit tests, as shown in <em class="italic">Figure 6</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise" src="img/B21324_06_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise</p>
<p>These coverage results will highlight any lines that are not covered by unit tests, such as the code of the <code>Unload</code> method in <code>PassengerFlightInfo</code>, as shown in <em class="italic">Figure 6</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 6.10 – Covered lines are highlighted in blue, while lines without tests are highlighted in red (line 14)" src="img/B21324_06_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Covered lines are highlighted in blue, while lines without tests are highlighted in red (line 14)</p>
<p>Code coverage is <a id="_idIndexMarker420"/>one of those topics that can be divisive. On<a id="_idIndexMarker421"/> the one hand, code coverage gives you a metric that shows how much of your code is executed by any test. This gives you a meaningful way of measuring the extent of your unit testing safety net.</p>
<p>However, code coverage can be deceptive. Just running a line of code does not mean that the effects of that line are verified by a unit test. This can lead to a false sense of security around your unit tests.</p>
<p>Additionally, when organizations prioritize work that increases the code coverage percentage or requires a certain minimum percentage of code coverage for new work, this can lead to tests that focus on the less risky aspects of your software system. For example, do you need to write a unit test to verify code that throws an <code>ArgumentNullException</code> error when a null value is passed to a method, or is your time better spent elsewhere?</p>
<p>Often, the most critical areas of your application may already appear to be covered by your code coverage metrics, but no tests verify that these lines work correctly.</p>
<p>My personal feeling is that code coverage is one of many useful metrics to monitor but should not be used to significantly drive the behavior of your development teams.</p>
<p>See the <em class="italic">Further reading</em> section for more information on code coverage and how to get started calculating it.</p>
<p>We’ll explore other metrics in <a href="B21324_12.xhtml#_idTextAnchor259"><em class="italic">Chapter 12</em></a>, <em class="italic">Code Analysis in Visual Studio</em>, but for now, let’s conclude this chapter with some closing thoughts on unit testing.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Summary</h1>
<p>Unit testing is a powerful way to verify that refactoring code does not introduce bugs, document your classes, and prevent bugs from occurring in the future.</p>
<p>Unit tests are code that tests other code. In .NET, project unit tests are usually performed with xUnit, NUnit, or MSTest. Each testing framework provides assertions that verify that code behaves correctly or fails a test if the actual value doesn’t match the expected value.</p>
<p>When we write unit tests, we typically structure our tests in the <em class="italic">arrange</em>/<em class="italic">act</em>/<em class="italic">assert</em> pattern, which sets up the thing being tested in the <em class="italic">arrange</em> step, does a single action in the <em class="italic">act</em> step, and verifies the correctness of the action’s result in the <em class="italic">assert</em> step.</p>
<p>In the next chapter, we’ll explore testing more with test-driven development.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>Which unit testing framework syntax do you like the most?</li>
<li>What are the most complex parts of your application? Are they tested?</li>
<li>How would you test a method that calculates the credit score of an applicant?</li>
<li>How do you test a <code>void</code> method?</li>
<li>What things can you do to help test code stay clean and readable?</li>
</ol>
<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Further reading</h1>
<p>You can find more information about the materials discussed in this chapter by checking out the following resources:</p>
<ul>
<li><em class="italic">Types of </em><em class="italic">Tests</em>: <a href="https://learn.microsoft.com/en-us/dotnet/core/testing/">https://learn.microsoft.com/en-us/dotnet/core/testing/</a></li>
<li><em class="italic">Visual Studio Test </em><em class="italic">Explorer</em>: <a href="https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer">https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer</a></li>
<li><em class="italic">xUnit</em>: <a href="https://xunit.net/">https://xunit.net/</a></li>
<li><em class="italic">NUnit</em>: <a href="https://nunit.org/">https://nunit.org/</a></li>
<li><em class="italic">MSTest</em>: <a href="https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest">https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest</a></li>
<li><em class="italic">The ObjectMother </em><em class="italic">Pattern</em>: <a href="https://www.martinfowler.com/bliki/ObjectMother.html">https://www.martinfowler.com/bliki/ObjectMother.html</a></li>
<li><em class="italic">Code </em><em class="italic">Coverage</em>: <a href="https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested">https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested</a></li>
</ul>
</div>
</body></html>