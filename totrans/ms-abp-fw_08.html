<html><head></head><body>
		<div><h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor177"/>Chapter 6</em>: Working with the Data Access Infrastructure</h1>
			<p>Almost all business applications use a kind of database system. We typically implement data access logic to read data from and write data to a database. We also need to deal with database transactions to ensure consistency in the data source.</p>
			<p>In this chapter, we will learn how to work with the data access infrastructure of ABP Framework, which provides abstractions for data access by implementing <strong class="bold">Repository</strong> and <strong class="bold">Unit of Work</strong> (<strong class="bold">UoW</strong>) patterns. Repositories provide a standard way to perform common database operations for your <strong class="bold">entities</strong>. The UoW system automates database connections and transaction management to ensure a use case (typically, a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request) is atomic; this means all operations done in the request are successful together or rolled back together in any error.</p>
			<p>You will see how to define your entities based on ABP Framework's pre-built base entity classes. Then, you will learn how to insert, update, delete, and query entities in the database using the repositories. You will also understand the UoW system to control transaction scopes in your application.</p>
			<p>ABP Framework can work with any database system, while it provides built-in integration packages with <code>DbContext</code> class, mapping your entities to database tables, implementing your repositories, and deploying different ways of loading related entities when you have an entity. You will also see how to use <strong class="bold">MongoDB</strong> as a second database provider option.</p>
			<p>This chapter covers ABP's fundamental data access infrastructure with the following topics:</p>
			<ul>
				<li>Defining entities</li>
				<li>Working with repositories</li>
				<li>EF Core integration</li>
				<li>MongoDB integration</li>
				<li>Understanding the UoW system</li>
			</ul>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor178"/>Technical requirements</h1>
			<p>If you want to follow and try the examples, you need to have an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>)/editor installed (for example, Visual Studio) to build ASP.NET Core projects.</p>
			<p>You can download the code examples from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor179"/>Defining entities</h1>
			<p>Entities are the main classes to define your domain model. If you are using a relational database, an entity is <a id="_idIndexMarker300"/>generally mapped to a database table. An <strong class="bold">object-relational mapper</strong> <strong class="bold">(ORM)</strong>, such as EF Core, provides abstractions to make you feel as though you are <a id="_idIndexMarker301"/>working with objects in your application code rather than database tables.</p>
			<p>ABP Framework standardizes defining entities by providing some interfaces and base classes. In the next sections, you will learn about ABP Framework's <code>AggregateRoot</code> and <code>Entity</code> base <a id="_idIndexMarker302"/>classes (and their variants), using single <strong class="bold">primary keys</strong> (<strong class="bold">PKs</strong>) and <strong class="bold">composite PKs</strong> (<strong class="bold">CPKs</strong>) with <a id="_idIndexMarker303"/>these classes and <a id="_idIndexMarker304"/>working with <strong class="bold">globally unique identifier</strong> (<strong class="bold">GUID</strong>) PKs. </p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor180"/>AggregateRoot classes</h2>
			<p>An <strong class="bold">aggregate</strong> is a cluster <a id="_idIndexMarker305"/>of objects (entities and value objects) bound <a id="_idIndexMarker306"/>together by an aggregate root object.</p>
			<p>Relational databases do not have a physical aggregate concept. Every entity is related to a separate database table, and <a id="_idIndexMarker307"/>an aggregate is spread into more than one table. You define relations with <strong class="bold">foreign keys</strong> (<strong class="bold">FKs</strong>). However, in document/object databases such as MongoDB, an aggregate is saved into a single collection by serializing it as a single document (a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>)-like object). The aggregate <a id="_idIndexMarker308"/>root is mapped to the collection, and <a id="_idIndexMarker309"/>sub-entities are serialized within the aggregate root object. That means sub-entities don't have their collections and are always accessed over the aggregate root.</p>
			<p class="callout-heading">The Aggregate Concept</p>
			<p class="callout">We will cover the aggregate concept in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>, with all the details of this. For now, you can think of aggregate roots as the main (root) entities in your domain.</p>
			<p>In ABP Framework, you can define main entities and aggregate roots, by deriving from one of the <code>AggregateRoot</code> classes. <code>BasicAggregateRoot</code> is the most simple class for defining your aggregate roots.</p>
			<p>The following example entity class is derived from the <code>BasicAggregateRoot</code> class:</p>
			<pre>using System;
using System.Collections.Generic;
using Volo.Abp.Domain.Entities;
namespace FormsApp
{
    public class Form : BasicAggregateRoot&lt;Guid&gt;
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public bool IsDraft { get; set; }
        public ICollection&lt;Question&gt; Questions { get; set; }
    }
}</pre>
			<p><code>BasicAggregateRoot</code> just defines an <code>Id</code> property as the PK and takes the PK type as the generic parameter. In this example, the PK type of <code>Form</code> is <code>Guid</code>. You can use any type as <a id="_idIndexMarker310"/>the PK (for example, <code>int</code>, <code>string</code>, and so on), as long as the underlying database provider supports it.</p>
			<p>There are some other base classes to derive your aggregate roots from, as detailed here:</p>
			<ul>
				<li>The <code>AggregateRoot</code> class has additional properties to support optimistic concurrency and object extension features.</li>
				<li><code>CreationAuditedAggregateRoot</code> inherits from the <code>AggregateRoot</code> class and adds <code>CreationTime</code> (<code>DateTime</code>) and <code>CreatorId</code> (<code>Guid</code>) properties to store creation audit information.</li>
				<li><code>AuditedAggregateRoot</code> inherits from the <code>CreationAuditedAggregateRoot</code> class and adds <code>LastModificationTime</code> (<code>DateTime</code>) and <code>LastModifierId</code> (<code>Guid</code>)  properties to store modification audit information.</li>
				<li><code>FullAuditedAggregateRoot</code> inherits from the <code>AuditedAggregateRoot</code> class and adds <code>DeletionTime</code> (<code>DateTime</code>) and <code>DeleterId</code> (<code>Guid</code>) properties to store deletion audit information. It also adds <code>IsDeleted</code> (<code>bool</code>) by implementing the <code>ISoftDelete</code> interface, which makes the entity soft-delete.<p class="callout-heading">Optimistic Concurrency and Object Extension Features</p><p class="callout">These topics are not covered in this book. Please check the ABP Framework documentation if you need to use them.</p></li>
			</ul>
			<p>ABP automatically sets auditing properties. We will return to the audit logging and soft-delete topics in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor181"/>Entity classes</h2>
			<p><code>Entity</code> base classes <a id="_idIndexMarker311"/>are similar to <code>AggregateRoot</code> classes, but they are used for sub-collection entities rather than main (root) entities. For example, the <code>Form</code> aggregate root example in the previous section has a collection of questions. The <code>Question</code> class is <a id="_idIndexMarker312"/>derived from the <code>Entity</code> class and is shown in the following code snippet:</p>
			<pre>public class Question : Entity&lt;Guid&gt;
{
    public Guid FormId { get; set; }
    public string Title { get; set; }
    public bool AllowMultiSelect { get; set; }
    public ICollection&lt;Option&gt; Options { get; set; }
}</pre>
			<p>As with the <code>AggregateRoot</code> class, the <code>Entity</code> class also defines an <code>Id</code> property of a given type. In this example, the <code>Question</code> entity also has a collection of options, where <code>Option</code> is another entity type.</p>
			<p>There are some other pre-defined base entity classes, such as <code>CreationAuditedEntity</code>, <code>AuditedEntity</code>, and <code>FullAuditedEntity</code>. They are similar to the audited aggregate root classes explained in the previous section.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor182"/>Entities with CPKs</h2>
			<p>Relational databases <a id="_idIndexMarker313"/>support CPKs, whereby your PK consists of a combination of multiple <a id="_idIndexMarker314"/>values. Composite keys are especially useful for relation <a id="_idIndexMarker315"/>tables with <strong class="bold">many-to-many</strong> relations.</p>
			<p>Assume that you want to set multiple managers for a form object and add a collection property to the <code>Form</code> class, as follows:</p>
			<pre>public class Form : BasicAggregateRoot&lt;Guid&gt;
{
    ...
    public ICollection&lt;FormManager&gt; Managers { get; set; }
}</pre>
			<p>You can then define a <code>FormManager</code> class deriving from the non-generic <code>Entity</code> cl<a id="_idTextAnchor183"/>ass, like this:</p>
			<pre>public class FormManager : Entity
{
    public Guid FormId { get; set; }
    public Guid UserId { get; set; }
    public Guid IsOwner { get; set; }
    public override object[] GetKeys()
    {
        return new object[] {FormId, UserId};
    }
}</pre>
			<p>When you inherit <a id="_idIndexMarker316"/>from the non-generic <code>Entity</code> class, you have to implement <a id="_idIndexMarker317"/>the <code>GetKeys</code> method to return an array of the keys. In this way, ABP can use the CPK's value where it is needed. For this example, <code>FormId</code> and <code>UserId</code> are FKs to other tables, and they build the CPK of the <code>FormManager</code> entity.</p>
			<p class="callout-heading">CPKs for Aggregate Roots</p>
			<p class="callout"><code>AggregateRoot</code> classes also have non-generic versions for CPKs, while it is not so usual to set CPKs for aggregate root entities.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor184"/>The GUID PK</h2>
			<p>ABP mostly uses GUIDs as <a id="_idIndexMarker318"/>the PK type for pre-built entities. GUIDs are generally compared to auto-increment IDs (such as <code>int</code> or <code>long</code>, supported by relational databases). Here are some commonly known benefits of using GUIDs as the PK <a id="_idIndexMarker319"/>compared to auto-increment keys:</p>
			<ul>
				<li>GUIDs are naturally unique. This works well if you are building distributed systems, using a non-relational database, and need to split or merge tables or integrate external systems.</li>
				<li>GUIDs can be generated on the client side without needing a database round trip. In this way, the <a id="_idIndexMarker320"/>client code can know the PK value before saving the entity.</li>
				<li>GUIDs are impossible to guess, so they can be more secure in some cases (for example, if end users see the ID of an entity, they can't find the ID of another entity).</li>
			</ul>
			<p>GUIDs also have <a id="_idIndexMarker321"/>some disadvantages compared to auto-increment integer values, as follows:</p>
			<ul>
				<li>A GUID is 16 bytes in the storage, higher than <code>int</code> (4 bytes) and <code>long</code> (8 bytes).</li>
				<li>GUIDs are not sequential by nature, which causes performance problems on clustered indexes. However, ABP offers a solution to that problem.</li>
			</ul>
			<p>ABP provides the <code>IGuidGenerator</code> service, which generates sequential <code>Guid</code> values by default. While it generates sequential values, the values generated by the algorithm are still safe to be universal and random. Generating a sequential value solves the clustered index performance problem.</p>
			<p>If you manually set the <code>Id</code> value of an entity, always use the <code>IGuidGenerator</code> service; never use <code>Guid.NewGuid()</code>. If you don't set the <code>Id</code> value for a new entity and insert it into the database using a repository, the repository automatically sets it using the <code>IGuidGenerator</code> service.</p>
			<p class="callout-heading">GUID versus Auto-Increment</p>
			<p class="callout">GUID versus auto-increment PKs is <a id="_idIndexMarker322"/>a hot discussion in software development, and <a id="_idIndexMarker323"/>there is no clear winner. ABP works with any PK type, so you can make your own choice based on your requirements.</p>
			<p>We have now learned the basics of entity definitions and will explore best practices for entities in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>. But now, let's continue with the repositories to understand how to work with a database to persist our entities.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor185"/>Working with repositories</h1>
			<p>The <strong class="bold">Repository pattern</strong> is a common <a id="_idIndexMarker324"/>approach to abstract the data access <a id="_idIndexMarker325"/>code from the other services of your application. In the next sections, you will learn how to use ABP Framework's generic repositories for your entities to query or manipulate data in the database using pre-defined repository methods. You will also see how to create custom repositories when you need to extend the generic repositories and add your own repository methods to encapsulate your data access logic.</p>
			<p class="callout-heading">Integrating Database Providers</p>
			<p class="callout">Database provider integration should be done to use repositories. We will do this in the <em class="italic">EF Core integration</em> and <em class="italic">MongoDB integration</em> sections of this chapter.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor186"/>Generic repositories</h2>
			<p>Once you have <a id="_idIndexMarker326"/>an entity, you can directly inject and use the generic repository for <a id="_idIndexMarker327"/>that entity. Here is an example class that uses a repository:</p>
			<pre>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Volo.Abp.DependencyInjection;
using Volo.Abp.Domain.Repositories;
namespace FormsApp
{
    public class FormService : ITransientDependency
    {
        private readonly IRepository&lt;Form, Guid&gt;                         _formRepository;
        public FormService(IRepository&lt;Form, Guid&gt;                       formRepository)
        {
            _formRepository = formRepository;
        }
        public async Task&lt;List&lt;Form&gt;&gt; GetDraftForms()
        {
            return await _formRepository
                .GetListAsync(f =&gt; f.IsDraft);
        }
    }
}</pre>
			<p>In this example, we've injected <code>IRepository&lt;Form, Guid&gt;</code>, the default generic repository for the <code>Form</code> entity. Then, we've used the <code>GetListAsync</code> method to get a filtered list of <a id="_idIndexMarker328"/>forms from the database. The generic <code>IRepository</code> interface <a id="_idIndexMarker329"/>has two generic parameters: entity type (<code>Form</code>, in this example) and PK type (<code>Guid</code>, in this example).</p>
			<p class="callout-heading">Repositories for Non-Aggregate Root Entities</p>
			<p class="callout">Generic repositories are only available for <em class="italic">aggregate root</em> entities by default because it is a best practice to access aggregates via aggregate root objects. However, it is possible to enable generic repositories for other entity types if you're using a relational database. We will see the configuration point in the <em class="italic">EF Core integration</em> section.</p>
			<p>Generic repositories provide many built-in methods to query, insert, update, and delete entities.</p>
			<h3>Inserting, updating, and deleting entities</h3>
			<p>The following methods can be used to manipulate data in the database:</p>
			<ul>
				<li><code>InsertAsync</code> is <a id="_idIndexMarker330"/>used to insert a new entity.</li>
				<li><code>InsertManyAsync</code> is used <a id="_idIndexMarker331"/>to insert multiple entities in a single call.</li>
				<li><code>UpdateAsync</code> is used <a id="_idIndexMarker332"/>to update an existing entity.</li>
				<li><code>UpdateManyAsync</code> is used <a id="_idIndexMarker333"/>to update multiple entities in a single call.</li>
				<li><code>DeleteAsync</code> is used <a id="_idIndexMarker334"/>to delete an existing entity.</li>
				<li><code>DeleteManyAsync</code> is used <a id="_idIndexMarker335"/>to insert multiple entities in a single call.<p class="callout-heading">About Asynchronous Programming</p><p class="callout">All repository methods are asynchronous. As a general principle in .NET, it is strongly suggested to write <a id="_idIndexMarker336"/>your application code with the <code>async</code>/<code>await</code> pattern wherever possible, because in .NET, mixing asynchronous code with synchronous code leads to potential deadlock, timeout, and scalability problems in your application that are not easy to detect and resolve.</p></li>
			</ul>
			<p>If you are using EF Core, these methods may not immediately perform an actual database operation because EF Core uses a change-tracking system. It saves changes only when you call the <code>DbContext.SaveChanges</code> method. ABP Framework's UoW system automatically calls the <code>SaveChanges</code> method when the current HTTP request successfully finishes. If you want to save changes into the database immediately, you can pass the <code>autoSave</code> parameter as <code>true</code> to the repository methods.</p>
			<p>The following example <a id="_idIndexMarker337"/>creates a new <code>Form</code> entity and immediately saves it to the database in the <code>InsertAsync</code> method:</p>
			<pre>var form = new Form(); // TODO: set the form properties
await _formRepository.InsertAsync(form, autoSave: true);</pre>
			<p>Even if you save changes into the database, the changes may not be visible yet, depending on the transaction isolation level, and will be rolled back if the current transaction fails. We will cover the UoW system in the <em class="italic">Understanding the UoW system</em> section of this chapter.</p>
			<p>The <code>DeleteAsync</code> method has an extra overload to delete all the entities satisfying the given condition. The following <a id="_idIndexMarker338"/>example deletes all the draft forms in the database:</p>
			<pre>await _formRepository.DeleteAsync(form =&gt; form.IsDraft);</pre>
			<p>You can also have a complex condition using logical operators such as <code>&amp;&amp;</code> and <code>||</code>.</p>
			<p class="callout-heading">About Cancellation Tokens</p>
			<p class="callout">All repository methods get an optional <code>CancellationToken</code> parameter. Cancellation tokens <a id="_idIndexMarker339"/>are used to cancel a database operation when needed. For example, if the user closes the browser window, there is no need to continue a long-running database query operation. Most of the time, you don't need to manually pass a cancellation token, since ABP Framework automatically captures and uses the cancellation token from the HTTP request when you don't explicitly pass it.</p>
			<h3>Querying a single entity</h3>
			<p>The following methods <a id="_idIndexMarker340"/>can be used to fetch a single entity:</p>
			<ul>
				<li><code>GetAsync</code>: Returns a single entity by its <code>Id</code> value or a predicate expression. Throws <code>EntityNotFoundException</code> if the requested entity was not found.</li>
				<li><code>FindAsync</code>: Returns a single entity by its <code>Id</code> value or a predicate expression. Returns <code>null</code> if the requested entity was not found.</li>
			</ul>
			<p>You should use the <code>FindAsync</code> method only if you have custom logic or fallback code, in case the given entity does not exist in the database. Otherwise, use <code>GetAsync</code>, which throws a well-known exception that causes the <code>404</code> status code to return to the client in an HTTP request.</p>
			<p>The following example uses the <code>GetAsync</code> method to query a <code>Form</code> entity with its <code>Id</code> value:</p>
			<pre>public async Task&lt;Form&gt; GetFormAsync(Guid formId)
{
    return await _formRepository.GetAsync(formId);
}</pre>
			<p>Both methods have <a id="_idIndexMarker341"/>overloads to pass a predicate expression to query an entity with a given condition. The following example uses the <code>GetAsync</code> method to get a <code>Form</code> entity with its unique name:</p>
			<pre>public async Task&lt;Form&gt; GetFormAsync(string name)
{
    return await _formRepository
        .GetAsync(form =&gt; form.Name == name);
}</pre>
			<p>Use these overloads only if you are expecting a single entity. If your query returns multiple entities, then they throw <code>InvalidOperationException</code>. For example, if form names are always <em class="italic">unique</em> in your system, you can find a form by name, as in this example. However, if your query may return multiple entities, use querying methods that return a list of entities.</p>
			<h3>Querying a list of entities</h3>
			<p>Generic repositories provide a lot of options to query entities from the database. The following methods <a id="_idIndexMarker342"/>can be used to get a list of entities directly:</p>
			<ul>
				<li><code>GetListAsync</code>: Returns all the entities or a list of entities satisfying the given condition</li>
				<li><code>GetPagedListAsync</code>: Used to query entities by paging</li>
			</ul>
			<p>The following code block shows how to get a list of forms filtered by the given name:</p>
			<pre>public async Task&lt;List&lt;Form&gt;&gt; GetFormsAsync(string name)
{
    return await _formRepository
        .GetListAsync(form =&gt; form.Name.Contains(name));
}</pre>
			<p>I've passed a lambda expression to the <code>GetListAsync</code> method to get all the <code>Form</code> entities with <a id="_idIndexMarker343"/>the given <code>name</code> parameter's value contained in their names.</p>
			<p>These methods are simple but limited. If you want to write advanced queries, you can use <strong class="bold">Language-Integrated Query</strong> (<strong class="bold">LINQ</strong>) over the repositories.</p>
			<h3>Using LINQ over the repositories</h3>
			<p>Repositories provide <a id="_idIndexMarker344"/>the <code>GetQueryableAsync()</code> method, which returns an <code>IQueryable&lt;TEntity&gt;</code> object. You can then use this object to perform LINQ on the entities in the database.</p>
			<p>The following example uses a LINQ operation on the <code>Form</code> entities to get a list of forms filtered and ordered by their names:</p>
			<pre>public class FormService2 : ITransientDependency
{
    private readonly IRepository&lt;Form, Guid&gt;                         _formRepository;
    private readonly IAsyncQueryableExecuter                         _asyncExecuter;
    public FormService2(
        IRe<a id="_idTextAnchor187"/>pository&lt;Form, Guid&gt; formRepository,
        IAsyncQueryableExecuter asyncExecuter)
    {
        _formRepository = formRepository;
        _asyncExecuter = asyncExecuter;
    }
    
    public async Task&lt;List&lt;Form&gt;&gt;                                   GetOrderedFormsAsync(string name)
    {
        var queryable = await                                           _formRepository.GetQueryableAsync();
        var query = from form in queryable
            where form.Name.Contains(name)
            orderby form.Name
            select form;
        return await _asyncExecuter.ToListAsync(query);
    }
}</pre>
			<p>We've first obtained an <code>IQueryable&lt;Form&gt;</code> object, then written a LINQ query, and finally executed <a id="_idIndexMarker345"/>the query using the <code>IAsyncQueryableExecuter</code> service.</p>
			<p>An alternative way to write the previous query could be using LINQ extension methods, as follows:</p>
			<pre>var query = queryable
    .Where(form =&gt; form.Name.Contains(name))
    .OrderBy(form =&gt; form.Name);</pre>
			<p>Having an <code>IQueryable</code> object provides you with all the power of LINQ. You can even make joins between multiple <code>IQueryable</code> objects obtained from different repositories.</p>
			<p>Using the <code>IAsyncQueryableExecuter</code> service may seem strange to you. You may expect to call the <code>ToListAsync</code> method directly on the query object, like so:</p>
			<pre>return await query.ToListAsync();</pre>
			<p>Unfortunately, <code>ToListAsync</code> is an extension method defined by EF Core (or MongoDB, if you are using it) and located inside the <code>Microsoft.EntityFrameworkCore</code> NuGet package. If referencing that package from your application <a id="_idIndexMarker346"/>layer is not a problem for you, then you can directly use these asynchronous extension methods in your code. However, if you want to keep your application layer ORM-independent, ABP's <code>IAsyncQueryableExecuter</code> service provides the necessary abstraction.</p>
			<h3>IRepository async extension methods</h3>
			<p>ABP Framework <a id="_idIndexMarker347"/>provides all the standard async LINQ extension methods for the <code>IRepository</code> interface: <code>AllAsync</code>, <code>AnyAsync</code>, <code>AverageAsync</code>, <code>ContainsAsync</code>, <code>CountAsync</code>, <code>FirstAsync</code>, <code>FirstOrDefaultAsync</code>, <code>LastAsync</code>, <code>LastOrDefaultAsync</code>, <code>LongCountAsync</code>, <code>MaxAsync</code>, <code>MinAsync</code>, <code>SingleAsync</code>, <code>SingleOrDefaultAsync</code>, <code>SumAsync</code>, <code>ToArrayAsync</code>, and <code>ToListAsync</code>. You can directly use any of these methods on a repository object.</p>
			<p>The following example uses the <code>CountAsync</code> method to get a count of forms where the name starts with <code>"A"</code>:</p>
			<pre>public async Task&lt;int&gt; GetCountAsync()
{
    return await _formRepository
        .CountAsync(x =&gt; x.Name.StartsWith("A"));
}</pre>
			<p>Notice that these extension methods are only available on the <code>IRepository</code> interface. If you want to use queryable extensions, you should still follow the approach explained in the previous section.</p>
			<h3>Generic repositories for entities with CPKs</h3>
			<p>If your entity has a CPK, you can't use the <code>IRepository&lt;TEntity, TKey&gt;</code> interface, since it gets <a id="_idIndexMarker348"/>a single PK (<code>Id</code>) type. In this case, you can use the <code>IRepository&lt;TEntity&gt;</code> interface.</p>
			<p>For example, you can use <code>IRepository&lt;FormManag<a id="_idTextAnchor188"/>er&gt;</code> to get managers of a given form, as follows:</p>
			<pre>public class FormManagementService : ITransientDependency
{
    private readonly IRepository&lt;FormManager&gt;                       _formManagerRepository;
    public FormManagementService(
        IRepository&lt;FormManager&gt; formManagerRepository)
    {
        _formManagerRepository = formManagerRepository;
    }
    public async Task&lt;List&lt;FormManager&gt;&gt;                             GetManagersAsync(Guid formId)
    {
        return await _formManagerRepository
            .GetListAsync(fm =&gt; fm.FormId == formId);
    }
}</pre>
			<p>In this example, I've used the <code>IRepository&lt;FormManager&gt;</code> interface to perform a query for the <code>FormManager</code> entities.</p>
			<p class="callout-heading">Repositories for Non-Aggregate Root Entities</p>
			<p class="callout">As stated in the <em class="italic">Generic repositories</em> section of this chapter, you can't use <code>IRepository&lt;FormManager&gt;</code> by default, since <code>FormManager</code> is not an aggregate root entity. You normally want to get the <code>Form</code> aggregate root and access its <code>Managers</code> collection to get the form managers. However, if you are using EF Core, you can create default generic repositories for entities that are not aggregate roots. See the <em class="italic">EF Core integration</em> section to learn how to do this.</p>
			<p>One limitation of <a id="_idIndexMarker349"/>generic repositories without the <code>TKey</code> generic argument is that they don't have methods that get <code>Id</code> parameters because they can't know the <code>Id</code> type. However, you can still use LINQ to write any type of query you need.</p>
			<h3>Other generic repository types</h3>
			<p>You typically want to use the repository interfaces explained in the previous sections since they are the <a id="_idIndexMarker350"/>most feature-full repository types. However, there are some more limited repository types that can be useful in some scenarios, such as the following:</p>
			<ul>
				<li><code>IBasicRepository&lt;TEntity, TPrimaryKey&gt;</code> and <code>IBasicRepository&lt;TEntity&gt;</code> provide fundamental repository methods, but they don't support LINQ and <code>IQueryable</code> functionalities. You can use these repositories if your underlying database provider doesn't support LINQ or you don't want to leak LINQ queries into your application layer. In this case, you probably need to write custom repositories by inheriting from these interfaces and implement your queries with custom methods.</li>
				<li><code>IReadOnlyRepository&lt;TEntity, TKey&gt;</code>, <code>IReadOnlyRepository&lt;TEntity&gt;</code>, <code>IReadOnlyBasicRepository&lt;Tentity, TKey&gt;</code>, and <code>IReadOnlyBasicRepository&lt;TEntity, TKey&gt;</code> provide methods to fetch data but do not include any methods to manipulate the database.</li>
			</ul>
			<p>Generic repository methods are enough for most cases. However, you may still need to add custom methods to your repositories.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor189"/>Custom repositories</h2>
			<p>You can <a id="_idIndexMarker351"/>create custom repository interfaces and classes to access the <a id="_idIndexMarker352"/>underlying database provider <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), encapsulate your LINQ expressions, call stored procedures, and so on.</p>
			<p>To create a custom repository, first, define a new repository interface. Repository interfaces are defined in the <code>Domain</code> project that comes with the startup template. You can inherit from one of the generic repository interfaces to include the standard methods in your repository interface. The code is illustrated in the following snippet:</p>
			<pre>public interface IFormRepository : IRepository&lt;Form, Guid&gt;
{
    Task&lt;List&lt;Form&gt;&gt; GetListAsync(
        string name,
        bool includeDrafts = false
    );
}</pre>
			<p><code>IFormRepository</code> inherits from <code>IRepository&lt;Form, Guid&gt;</code> and adds a new method to get a list of forms with some filters. You can then inject <code>IFormRepository</code> into your services instead of the generic repository and use your custom methods. If you don't want to include the standard repository methods, just derive your interface from the <code>IRepository</code> (without any generic argument) interface. This is an empty interface that is used to identify your interface as a repository.</p>
			<p>Surely, we must implement the <code>IFormRepository</code> interface somewhere in our application. ABP startup templates provide integration projects for the underlying database provider, so we can implement custom repository interfaces in the database integration project. We will implement that interface for EF Core and MongoDB in the next sections.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor190"/>EF Core integration</h1>
			<p>Microsoft's EF Core is the de facto ORM for .NET, with which you can work with major database providers, such <a id="_idIndexMarker353"/>as SQL Server, Oracle, MySQL, PostgreSQL, and Cosmos DB. It is the default database provider when you create a new ABP solution using the ABP <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>).</p>
			<p>The startup template <a id="_idIndexMarker354"/>uses <em class="italic">SQL Server</em> by default. If you prefer another <code>-dbms</code> parameter while creating a new solution, like so:</p>
			<pre>abp new DemoApp -dbms PostgreSQL</pre>
			<p><code>SqlServer</code>, <code>MySQL</code>, <code>SQLite</code>, <code>Oracle</code>, and <code>PostgreSQL</code> are directly supported.</p>
			<p class="callout-heading">Other Databases</p>
			<p class="callout">You can refer to ABP's documentation to learn about up-to-date supported database options and how to switch to another database provider that the ABP CLI does not support <a id="_idIndexMarker355"/>out of the box: <a href="https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS">https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS</a>.</p>
			<p>In the next sections, you will learn how to configure the DBMS (although it is already done in the <a id="_idIndexMarker356"/>startup template), define a <code>DbContext</code> class, and register to the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) system. Then, you will see how to map your entities to database tables, using Code First Migrations and creating custom repositories for your entities. Finally, we will explore different ways of loading related data for an entity.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor191"/>Configuring the DBMS</h2>
			<p>We <a id="_idIndexMarker357"/>use <code>AbpDbContextOptions</code> to configure the DBMS in the <code>ConfigureServices</code> method of our module. The following example configures using SQL Server as the DBMS:</p>
			<pre>Configure&lt;AbpDbContextOptions&gt;(options =&gt;
{
    options.UseSqlServer();
});</pre>
			<p>Surely, the <code>UseSqlServer()</code> method call will be different if you've preferred a different DBMS. We don't <a id="_idIndexMarker358"/>need to set the connection string since it is automatically obtained from the <code>ConnectionStrings:Default</code> configuration. You can check the <code>appsettings.json</code> file in your project to see and change the connection string.</p>
			<p>We've configured the DBMS but haven't defined a <code>DbContext</code> object, which is necessary to work with the database in EF Core.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor192"/>Defining DbContext</h2>
			<p><code>DbContext</code> is the main object in EF Core that you interact with the database. You normally create a <a id="_idIndexMarker359"/>class inheriting from <code>DbContext</code> to create your own <code>DbContext</code>. With ABP Framework, we are inheriting from <code>AbpDbContext</code> instead.</p>
			<p>Here is an example of a <code>DbContext</code> class definition with ABP Framework:</p>
			<pre>using Microsoft.EntityFrameworkCore;
using Volo.Abp.EntityFrameworkCore;
namespace FormsApp
{
    public class FormsAppDbContext :                                 AbpDbContext&lt;FormsAppDbContext&gt;
    {
        public DbSet&lt;Form&gt; Forms { get; set; }
        public FormsAppDbContext(
            DbContextOptions&lt;FormsAppDbContext&gt; options)
            : base(options)
        {
        }
    }
}</pre>
			<p><code>FormsAppDbContext</code> inherits from <code>AbpDbContext&lt;FormsAppDbContext&gt;</code>. <code>AbpDbContext</code> is a generic class and takes the <code>DbContext</code> type as a generic parameter. It also <a id="_idIndexMarker360"/>forces us to create a constructor, as shown here. We can then add <code>DbSet</code> properties for our entities. It is essential to add <code>DbSet</code> properties since ABP can create default generic repositories only for the entities with <code>DbSet</code> properties defined.</p>
			<p>Once we've defined <code>DbContext</code>, we should register it with the DI system to use it in our application.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor193"/>Registering DbContext with DI</h2>
			<p>The <code>AddAbpDbContext</code> extension method is used to register <code>DbContext</code> classes with the DI system. You <a id="_idIndexMarker361"/>can use this method inside the <code>ConfigureServices</code> method of your module (it is inside the <code>EntityFrameworkCore</code> project in the startup solution), as shown in the following code block:</p>
			<pre>public override void ConfigureServices(
    ServiceConfigurationContext context)
{
    context.Services.AddAbpDbContext&lt;FormsAppDbContext&gt;              (options =&gt;
    {
        options.AddDefaultRepositories();
    });
}</pre>
			<p><code>AddDefaultRepositories()</code> is used to enable default generic repositories for your entities <a id="_idIndexMarker362"/>related to that <code>DbContext</code>. It enables generic repositories only for <a id="_idIndexMarker363"/>aggregate root entities by default because, in <code>includeAllEntities</code> parameter to <code>true</code> if you want to use repositories for other entity types too, as illustrated here:</p>
			<pre>options.AddDefaultRepositories(includeAllEntities: true);</pre>
			<p>With this option, you can inject the <code>IRepository</code> service for any entity in your application code.</p>
			<p class="callout-heading">The includeAllEntities Option in the Startup Template</p>
			<p class="callout">The ABP startup template sets the <code>includeAllEntities</code> option to <code>true</code> because developers working on relational databases are used to querying from all database tables. If you want to apply DDD principles strictly, you should always use the aggregate roots to access sub-entities. In this case, you can remove this option from the <code>AddDefaultRepositories</code> method call.</p>
			<p>We've seen how to register the <code>DbContext</code> class. We can inject and use <code>IRepository</code> interfaces for all your entities in your <code>DbContext</code> class. However, we should first configure the EF Core mappings for the entities.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor194"/>Configuring entity mappings</h2>
			<p>EF Core is an object-to-relational <a id="_idIndexMarker364"/>mapper that maps your entities to database tables. We can configure the details of those mappings in two ways, as outlined here:</p>
			<ul>
				<li>Using data annotation attributes on your entity class</li>
				<li>Using Fluent API inside by overriding the <code>OnModelCreating</code> method</li>
			</ul>
			<p>Using data annotation attributes makes your domain layer EF Core-dependent. If that's not a problem for you, you can simply use these attributes by following EF Core's documentation. In this book, I will use the Fluent API approach.</p>
			<p>To use the Fluent API approach, you can override the <code>OnModelCreating</code> method in your <code>DbContext</code> class, as shown in the following code block:</p>
			<pre>public class FormsAppDbContext : AbpDbContext&lt;FormsAppDbContext&gt;
{
    ...
    protected override void OnModelCreating(ModelBuilder             builder)
    {
        base.OnModelCreating(builder);
        // TODO: configure entities...
    }
}</pre>
			<p>When you <a id="_idIndexMarker365"/>override the <code>OnModelCreating</code> method, always call <code>base.OnModelCreating()</code> since ABP also performs default configurations inside that method, necessary to properly use ABP features such as audit logs and data filters. Then, you can use the <code>builder</code> object to perform your configurations.</p>
			<p>For example, we can configure the mapping for the <code>Form</code> class defined in this chapter, as follows:</p>
			<pre>builder.Entity&lt;Form&gt;(b =&gt;
{
    b.ToTable("Forms");
    b.ConfigureByConvention();
    b.Property(x =&gt; x.Name)
        .HasMaxLength(100)
        .IsRequired();
    b.HasIndex(x =&gt; x.Name);
});</pre>
			<p>Calling the <code>b.ConfigureByConvention()</code> method is important here. It configures the base properties of your <a id="_idIndexMarker366"/>entity if it is derived from ABP's pre-defined <code>Entity</code> or <code>AggregateRoot</code> classes. The remaining configuration code is pretty clean and standard, and you can learn all the details from EF Core's documentation.</p>
			<p>Here is another example that configures a relation between entities:</p>
			<pre>builder.Entity&lt;Question&gt;(b =&gt;
{
    b.ToTable("FormQuestions");
    b.ConfigureByConvention();
    b.Property(x =&gt; x.Title)
        .HasMaxLength(200)
        .IsRequired();
    b.HasOne&lt;Form&gt;()
        .WithMany(x =&gt; x.Questions)
        .HasForeignKey(x =&gt; x.FormId)
        .IsRequired();
});</pre>
			<p>In this example, we are defining the relation between the <code>Form</code> and <code>Question</code> entities: a form can have many questions, while a question always belongs to a single form.</p>
			<p>The configuration we've made ensures that EF Core knows how to read and write entities to the database tables. However, related tables in the database should also be available. You can definitely create a database and the tables inside it manually. Then, in every change to your entities, you manually reflect the related changes in the database schema. However, it is hard to keep your entities and database tables in sync in this way. It is also tedious and error-prone to make them all manual, especially when you have <a id="_idIndexMarker367"/>multiple environments (such as development and production).</p>
			<p>Fortunately, there is a better way: Code First Migrations. EF's Code First Migrations system provides an efficient way to incrementally update the database schema to keep it in sync with your entity model. We've already used the Code First Migration system in <a href="B17287_03_Epub_AM.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Step-By-Step Application Development</em>. You can refer to that chapter to learn how to add a new database migration and apply it in the database.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor195"/>Implementing custom repositories</h2>
			<p>We created an <code>IFormRepository</code> interface in the <em class="italic">Custom repositories</em> part of the <em class="italic">Working with repositories</em> section <a id="_idIndexMarker368"/>in this chapter. Now, it's time to implement this repository interface using EF Core.</p>
			<p>You can implement the repository<a id="_idTextAnchor196"/> inside the EF Core integration project of your solution, like this:</p>
			<pre>public class FormRepository :
    EfCoreRepository&lt;FormsAppDbContext, Form, Guid&gt;,
    IFormRepository
{
    public FormRepository(
        IDbContextProvider&lt;FormsAppDbContext&gt;                           dbContextProvider)
        : base(dbContextProvider)
    { }
    public async Task&lt;List&lt;Form&gt;&gt; GetListAsync(
        string name, bool includeDrafts = false)
    {
        var dbContext = await GetDbContextAsync();
        var query = dbContext.Forms
            .Where(f =&gt; f.Name.Contains(name));
        if (!includeDrafts)
        {
            query = query.Where(f =&gt; !f.IsDraft);
        }
        return await query.ToListAsync();
    }
}</pre>
			<p>This class is derived from ABP's <code>EfCoreRepository</code> class. In this way, we are inheriting all the <a id="_idIndexMarker369"/>standard repository methods. The <code>EfCoreRepository</code> class gets three generic parameters: the <code>DbContext</code> type, the entity type, and the PK type of the entity class.</p>
			<p><code>FormRepository</code> also implements <code>IFormRepository</code>, which defines a custom <code>GetListAsync</code> method. We get the <code>DbContext</code> instance to use all the power of the EF Core API in this method.</p>
			<p class="callout-heading">Tip about WhereIf</p>
			<p class="callout">Conditional filtering is a widely used pattern, and ABP provides a nice <code>WhereIf</code> extension method that can simplify our code. </p>
			<p>We could rewrite the <code>GetListAsync</code> method, as shown in the following code block:</p>
			<pre>var dbContext = await GetDbContextAsync();
return await dbContext.Forms
    .Where(f =&gt; f.Name.Contains(name))
    .WhereIf(!includeDrafts, f =&gt; !f.IsDraft)
    .ToListAsync();</pre>
			<p>Since we have <a id="_idIndexMarker370"/>the <code>DbContext</code> instance, we can use it to execute <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) commands or stored procedures. The following method executes a raw SQL command to delete all draft forms:</p>
			<pre>public async Task DeleteAllDraftsAsync()
{
    var dbContext = await GetDbContextAsync();
    await dbContext.Database
        .ExecuteSqlRawAsync("DELETE FROM Forms WHERE                     IsDraft = 1");
}</pre>
			<p class="callout-heading">Executing Stored Procedures and Functions</p>
			<p class="callout">You can refer to EF Core's documentation (<a href="https://docs.microsoft.com/en-us/ef/core">https://docs.microsoft.com/en-us/ef/core</a>) to learn how to <a id="_idIndexMarker371"/>execute stored procedures and functions.</p>
			<p>Once you <a id="_idIndexMarker372"/>implement <code>IFormRepository</code>, you can inject and use it instead of <code>IRepository&lt;Form, Guid&gt;</code>, as follows:</p>
			<pre>public class FormService : ITransientDependency
{
    private readonly IFormRepository _formRepository;
    public FormService(IFormRepository formRepository)
    {
        _formRepository = formRepository;
    }
    
    public async Task&lt;List&lt;Form&gt;&gt; GetFormsAsync(string               name)
    {
        return await _formRepository
            .GetListAsync(name, includeDrafts: true);
    }
}</pre>
			<p>This class uses the custom <code>GetListAsync</code> method of <code>IFormRepository</code>.</p>
			<p>Even if you implement a custom repository class for the <code>Form</code> entity, it is still possible to inject and use default generic repositories (for example, <code>IRepository&lt;Form, Guid&gt;</code>) for that entity. This is <a id="_idIndexMarker373"/>a good feature, especially if you start with generic repositories, then decide to create a custom repository later. You don't have to change your existing code that uses the generic repository.</p>
			<p>One potential problem may occur if you override a base method from the <code>EfCoreRepository</code> class and customize it in your repository. In this case, the services that use the generic repository reference will continue to use the non-overridden method. To prevent this fragmentation, use the <code>AddRepository</code> method while registering your <code>DbContext</code> with DI, as follows:</p>
			<pre>context.Services.AddAbpDbContext&lt;FormsAppDbContext&gt;(options =&gt;
{
    options.AddDefaultRepositories();
    options.AddRepository&lt;Form, FormRepository&gt;();
});</pre>
			<p>With this configuration, the <code>AddRepository</code> method redirects generic repositories to your custom repository class.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor197"/>Loading related data</h2>
			<p>If your entity has navigation properties to other entities or has collections of other entities, then you'll frequently need to access those related entities while working with the main entity. For example, the <code>Form</code> entity introduced before has a collection of <code>Question</code> entities, and you may need to access the questions while working with a <code>Form</code> object.</p>
			<p>There are <a id="_idIndexMarker374"/>multiple <a id="_idIndexMarker375"/>ways <a id="_idIndexMarker376"/>to access related entities: <strong class="bold">explicit loading</strong>, <strong class="bold">lazy loading</strong>, and <strong class="bold">eager loading</strong>.</p>
			<h3>Explicit loading</h3>
			<p>Repositories <a id="_idIndexMarker377"/>provide <code>EnsurePropertyLoadedAsync</code> and <code>EnsureCollectionLoadedAsync</code> extension methods to load a navigation property or sub-collection explicitly.</p>
			<p>For example, we can explicitly load the questions of a form, as shown in the following code block:</p>
			<pre>public async Task&lt;IEnumerable&lt;Question&gt;&gt; GetQuestionsAsync(Form form)
{
    await _formRepository
        .EnsureCollectionLoadedAsync(form, f =&gt;                         f.Questions);
    return form.Questions;
}</pre>
			<p>If we don't use <code>EnsureCollectionLoadedAsync</code> here, then the <code>form.Questions</code> collection might be empty. If we are not sure it is filled, we can use <code>EnsureCollectionLoadedAsync</code> to ensure it is loaded. The <code>EnsurePropertyLoadedAsync</code> and <code>EnsureCollectionLoadedAsync</code> methods do nothing if the related property or collection is already loaded, so calling them multiple times is not a problem for performance.</p>
			<h3>Lazy loading</h3>
			<p>Lazy loading is a feature of EF Core that loads related properties and collections when you first access them. Lazy loading is not <a id="_idIndexMarker378"/>enabled by default. If you want to enable it for your <code>DbContext</code>, follow these steps:</p>
			<ol>
				<li>Install the <code>Microsoft.EntityFrameworkCore.Proxies</code> NuGet package in your EF Core layer.</li>
				<li>Use the <code>UseLazyLoadingProxies</code> method while configuring <code>AbpDbContextOptions</code>, as follows:<pre>Configure&lt;AbpDbContextOptions&gt;(options =&gt;
{
    options.PreConfigure&lt;FormsAppDbContext&gt;(opts =&gt;
    {
        opts.DbContextOptions.UseLazyLoadingProxies();
    });
    options.UseSqlServer();
});</pre></li>
				<li>Be sure that the navigation properties and collection properties are virtual in your entities, as shown here:<pre>public class Form : BasicAggregateRoot&lt;Guid&gt;
{
    ...
    public virtual ICollection&lt;Question&gt; Questions {           get; set; }
    public virtual ICollection&lt;FormManager&gt; Owners {            get; set; }
}</pre></li>
			</ol>
			<p>When you enable lazy loading, you don't need to use explicit loading anymore.</p>
			<p>Lazy loading is a discussed concept of ORMs. Some developers find it useful and practical, while others <a id="_idIndexMarker379"/>suggest not using it in any way. I am drawn to not using it because it has some potential problems, such as these:</p>
			<ul>
				<li>Lazy loading can't use asynchronous programming because there is no way to access a property with the <code>async</code>/<code>await</code> pattern. So, it blocks the caller thread, which is a bad practice for throughput and scalability.</li>
				<li>You may have a <code>1+N</code> loading problem if you forget to eager-load the related data before using a <code>foreach</code> loop. <code>1+N</code> loading means you query a list of entities from the database with a single database operation (<code>1</code>), then perform a loop that accesses a navigation property (or a collection) of these entities. In this case, it lazy-loads <a id="_idIndexMarker380"/>the related property for each loop (<code>N</code> = count of the queried entities in the first database operation). So, you make a <code>1+N</code> database call, which dramatically drops your application performance. You should eager-load the related entities in such cases so that you make a single database in total.</li>
				<li>It makes it hard to predicate and optimize your code since you may not easily see when the related data is loaded from the database.</li>
			</ul>
			<p>I suggest going for a more controlled approach and using eager loading wherever possible.</p>
			<h3>Eager loading</h3>
			<p>Eager loading is a way of loading <a id="_idIndexMarker381"/>related data while first querying the main entity.</p>
			<p>Assume that you've created a custom repository method to load the related questions while getting a <code>Form</code> object from the database, as shown here:</p>
			<pre>public async Task&lt;Form&gt; GetWithQuestions(Guid formId)
{
    var dbContext = await GetDbContextAsync();
    return await dbContext.Forms
        .Include(f =&gt; f.Questions)
        .SingleAsync(f =&gt; f.Id == formId);
}</pre>
			<p>If you create such custom repository methods, you can use the full EF Core API. However, if you are <a id="_idIndexMarker382"/>working with ABP's repositories and don't want to depend on EF Core in your application layer, you can't use EF Core's <code>Include</code> extension method (which is used to eager-load the related data). In this case, you have two options, which are discussed in the next sections.</p>
			<h4>IRepository.WithDetailsAsync</h4>
			<p>The <code>WithDetailsAsync</code> method <a id="_idIndexMarker383"/>of the <code>IRepository</code> returns <a id="_idIndexMarker384"/><a id="_idTextAnchor198"/>an <code>IQueryable</code> instance by including the given properties or collections, as follows:</p>
			<pre>public async Task EagerLoadDemoAsync(Guid formId)
{
    var queryable = await _formRepository
        .WithDetailsAsync(f =&gt; f.Questions);
    var query = queryable.Where(f =&gt; f.Id == formId);
    var form = await                                                 _asyncExecuter.FirstOrDefaultAsync(query);
    foreach (var question in form.Questions)
    {
        //...
    }
}</pre>
			<p><code>WithDetailsAsync(f =&gt; f.Questions)</code> returns <code>IQueryable&lt;Form&gt;</code> with questions included, so we can safely loop through the <code>form.Questions</code> collection. <code>IAsyncQueryableExecuter</code> was explained before, in the <em class="italic">Generic repositories</em> section of this chapter. The <code>WithDetailsAsync</code> method can get more than one expression to include more than one property if you need it. <code>WithDetailsAsync</code> can't be used if you need nested includes (the <code>ThenInclude</code> extension method in EF Core). In this case, create a custom repository method.</p>
			<h4>The Aggregate pattern</h4>
			<p>The Aggregate pattern will be covered in depth in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>. However, to give a brief bit of information, an aggregate is considered a single unit; it is read and <a id="_idIndexMarker385"/>saved as a single unit with all sub-collections. That means you always load related questions while loading a form.</p>
			<p>ABP supports the aggregate pattern well and allows you to configure eager loading for an entity at a global point. We can write the following configuration inside the <code>ConfigureServi<a id="_idTextAnchor199"/>ces</code> method of our module class (in the <code>EntityFrameworkCore</code> project in your solution):</p>
			<pre>Configure&lt;AbpEntityOptions&gt;(options =&gt;
{
    options.Entity&lt;Form&gt;(orderOptions =&gt;
    {
        orderOptions.DefaultWithDetailsFunc = query =&gt;                   query
            .Include(f =&gt; f.Questions)
            .Include(f =&gt; f.Owners);
    });
});</pre>
			<p>It is suggested to include all sub-collections. Once you configure the <code>DefaultWithDetailsFunc</code> method as shown, then the following will occur:</p>
			<ul>
				<li>Repository methods that return a single entity (such as <code>GetAsync</code>) will eager-load related entities by default unless you explicitly disable that behaviour by specifying the <code>includeDetails</code> parameter to <code>false</code> on the method call.</li>
				<li>Repository methods that return multiple entities (such as <code>GetListAsync</code>) will allow the eager loading of related entities, while they will not eager-load by default.</li>
			</ul>
			<p>Here are some examples.</p>
			<p>Get a single form with sub-collections included like this:</p>
			<pre>var form = await _formRepository.GetAsync(formId);</pre>
			<p>Get a single form without sub-collections like this:</p>
			<pre>var form = await _formRepository.GetAsync(formId, includeDetails: false);</pre>
			<p>Get a list of forms without sub-collections like this:</p>
			<pre>var forms = await _formRepository.GetListAsync(f =&gt; f.Name.StartsWith("A"));</pre>
			<p>Get a list of forms with sub-collections included like this:</p>
			<pre>var forms = await _formRepository.GetListAsync(f =&gt; f.Name.StartsWith("A"), includeDetails: true);</pre>
			<p>The Aggregate pattern simplifies your application code in most cases, while you can still fine-tune cases where you <a id="_idIndexMarker386"/>need performance optimization. Note that navigation properties (to other aggregates) are not used if you truly implement the Aggregate pattern. We will return to this topic again in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>.</p>
			<p>We've covered the essentials of using EF Core with ABP Framework. The next section will explain MongoDB integration, the other built-in database provider of ABP Framework.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor200"/>MongoDB integration</h1>
			<p>MongoDB is a popular non-relational <strong class="bold">document database</strong>, which stores data in JSON-like documents <a id="_idIndexMarker387"/>rather than traditional row-/column-based tables.</p>
			<p>The ABP CLI provides an option to create new applications using MongoDB, as shown here:</p>
			<pre>abp new FormsApp -d mongodb</pre>
			<p>If you want to check and change the database connection string, you can look at the <code>appsettings.json</code> file of your application.</p>
			<p class="callout-heading">The MongoDB Client Package</p>
			<p class="callout">ABP uses the official <code>MongoDB.Driver</code> NuGet package for MongoDB integration.</p>
			<p>In the next chapters, you will learn <a id="_idIndexMarker388"/>how to work with ABP's <code>AbpMongoDbContext</code> class to define <code>DbContext</code> objects, perform object-mapping configurations, register <code>DbContext</code> objects with the DI system, and implement custom repositories when you want to extend the generic repositories for your entities.</p>
			<p>We begin the MongoDB integration by defining a <code>DbContext</code> class.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor201"/>Defining DbContexts</h2>
			<p>The MongoDB driver package doesn't have a <code>DbContext</code> concept like EF Core does. However, ABP introduces <a id="_idIndexMarker389"/>the <code>AbpMongoDbContext</code> class to provide a standard way to define and configure MongoDB integration. We need to define a class deriving from the <code>AbpMongoD<a id="_idTextAnchor202"/>bContext</code> base class, as follows:</p>
			<pre>public class FormsAppDbContext : AbpMongoDbContext
{
    [MongoCollection("Forms")]
    public IMongoCollection&lt;Form&gt; Forms =&gt;                           Collection&lt;Form();
}</pre>
			<p>The <code>MongoCollection</code> attribute sets the collection name on the database side. It is optional and uses the driver's default value if you don't specify it. Defining a collection property on the <code>FormsAppDbContext</code> class is required to use the default generic repositories.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor203"/>Configuring object mappings</h2>
			<p>While the MongoDB C# driver is not an ORM, it still maps your entities to collections in the database, and you may <a id="_idIndexMarker390"/>want to customize the mapping configuration. In this case, override the <code>CreateModel</code> method in your <code>DbContext</code> class like this:</p>
			<pre>protected override void CreateModel(IMongoModelBuilder builder)
{
    builder.Entity&lt;Form&gt;(b =&gt;
    {
        b.BsonMap.UnmapProperty(f =&gt; f.Description);
    });
}</pre>
			<p>In this example, I've configured MongoDB so that it ignores the <code>Description</code> property of the <code>Form</code> entity <a id="_idIndexMarker391"/>while saving and retrieving data. Please refer to the documentation of the <code>MongoDB.Driver</code> NuGet package to learn about all configuration options.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor204"/>Registering DbContext with DI</h2>
			<p>Once you create <a id="_idIndexMarker392"/>and configure your <code>DbContext</code> class, it is registered with the DI system in the <code>ConfigureServices</code> method of your module class (typically in the MongoDB integration project of your solution). The following code snippet illustrates this:</p>
			<pre>public override void ConfigureServices(
    ServiceConfigurationContext context)
{
    context.Services.AddMongoDbContext&lt;FormsAppDbContext&gt;(
        options =&gt;
            {
                options.AddDefaultRepositories();
            });
}</pre>
			<p><code>AddDefaultRepositories()</code> is used to enable default generic repositories for your entities related to that <code>DbContext</code>. You can then inject <code>IRepository&lt;Form&gt;</code> into your classes and start using your MongoDB database.</p>
			<p>The <code>AddDefaultRepositories</code> method enables default repositories only for aggregate root <a id="_idIndexMarker393"/>entities (the entity classes derived from the <code>AggregateRoot</code> class). Set <code>includeAllEntities</code> to <code>true</code> to enable default repositories for all entity types. However, it is strongly suggested to apply the Aggregate pattern while working with MongoDB. The Aggregate pattern will be covered in depth in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>.</p>
			<p>Default generic repositories are enough in most cases, but you may need to access the MongoDB API or abstract your queries into custom repository methods.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor205"/>Implementing custom repositories</h2>
			<p>We created <a id="_idIndexMarker394"/>an <code>IFormRepository</code> interface in the <em class="italic">Custom repositories</em> part of the <em class="italic">Working with repositories</em> section in this chapter. We can implement this repository interface using MongoDB.</p>
			<p>You ca<a id="_idTextAnchor206"/>n implement the repository inside the MongoDB integration project of your solution, like this:</p>
			<pre>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using MongoDB.Driver;
using MongoDB.Driver.Linq;
using Volo.Abp.Domain.Repositories.MongoDB;
using Volo.Abp.MongoDB;
namespace FormsApp
{
    public class FormRepository : 
        MongoDbRepository&lt;FormsAppDbContext, Form, Guid&gt;, 
        IFormRepository
    {
        public FormRepository(
            IMongoDbContextProvider&lt;FormsAppDbContext&gt;                       dbContextProvider)
            : base(dbContextProvider)
        { }
        // TODO: implement the GetListAsync method
    }
}</pre>
			<p>The <code>FormRepository</code> class is derived from ABP's <code>MongoDbRepository</code> class. In this way, we are inheriting <a id="_idIndexMarker395"/>all the standard repository methods. The <code>MongoDbRepository</code> class gets three generic parameters: the <code>DbContext</code> type, the entity type, and the PK type of the entity class.</p>
			<p>The <code>FormRepository</code> class<a id="_idTextAnchor207"/> should implement the <code>GetListAsync</code> method defined by the <code>IFormRepository</code> interface, as follows:</p>
			<pre>public async Task&lt;List&lt;Form&gt;&gt; GetListAsync(
    string name, bool includeDrafts = false)
{
    var queryable = await GetMongoQueryableAsync();
    var query = queryable.Where(f =&gt;                                 f.Name.Contains(name));
    if (!includeDrafts)
    {
        query = queryable.Where(f =&gt; !f.IsDraft);
    }
    return await query.ToListAsync();
}</pre>
			<p>I've used the LINQ API of the MongoDB driver in this example, but you can use alternative APIs by <a id="_idIndexMarker396"/>obtaining the <code>IMongoCollection</code> object, as illustrated in the following code snippet:</p>
			<pre>IMongoCollection&lt;Form&gt; formsCollection = await GetCollectionAsync();</pre>
			<p>Now, you can inject <code>IFormRepository</code> instead of the generic <code>IRepository&lt;Form, Guid&gt;</code> repository into your services and use all the standard and custom repository methods.</p>
			<p>Even if you implement a custom repository class for the <code>Form</code> entity, it is still possible to inject and use default generic repositories (such as <code>IRepository&lt;Form, Guid&gt;</code>) for that entity. If you implement a custom repository, it is suggested to use the <code>AddRepository</code> method on the <code>DbContext</code> registration code, as illustrated in the following code snippet:</p>
			<pre>context.Services.AddMongoDbContext&lt;FormsAppDbContext&gt;(options =&gt;
{
    options.AddDefaultRepositories();
    options.AddRepository&lt;Form, FormRepository&gt;();
});</pre>
			<p>In this way, generic default repositories will be redirected to your custom repository class. If you override a base method in your custom repository, they will also use your overload instead of the base method.</p>
			<p>We've learned how to use EF Core and MongoDB as the database provider. In the next section, we will understand the UoW system, making it possible to connect these databases and apply transactions.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor208"/>Understanding the UoW system</h1>
			<p>UoW is the main system that ABP uses to initiate, manage, and dispose of database connections and <a id="_idIndexMarker397"/>transactions. The UoW system is designed with the <strong class="bold">Ambient Context pattern</strong>. That means when we create a new UoW, it creates a <a id="_idIndexMarker398"/>scoped context that is participated by all the database operations performed in the current scope by sharing the same context and is considered a single transaction boundary. All the operations done in a UoW are committed (on success) or rolled back (on exception) together.</p>
			<p>While you can manually create UoW scopes and control the transaction properties, most of the time, it works seamlessly just as you desire. However, it provides some options if you change the default behavior.</p>
			<p class="callout-heading">UoW and Database Operations</p>
			<p class="callout">All database operations must be performed in a UoW scope since UoW is the way to manage database <a id="_idIndexMarker399"/>connections and transactions in ABP Framework. Otherwise, you get an exception indicating that.</p>
			<p>In the next sections, you will gain an understanding of how the UoW system works and customize it by configuring the options. I will also explain how to manually control the UoW system when the conventional system doesn't work for your use case.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor209"/>Configuring UoW options </h2>
			<p>With the default setup, in an ASP.NET Core application, an HTTP request is considered as the UoW scope. ABP starts <a id="_idIndexMarker400"/>a UoW at the beginning of the request and saves changes to the database if the request successfully finishes. It rolls back the UoW if the request fails because of an exception.</p>
			<p>ABP determines database transaction usage based on the HTTP request type. HTTP <code>GET</code> requests don't create a database transaction. UoW works anyway but doesn't use a database transaction in this case. All other HTTP request types (<code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and others) use a database transaction if you haven't configured them otherwise.</p>
			<p class="callout-heading">HTTP GET Requests and Transactions</p>
			<p class="callout">It is a best practice not to make database changes in <code>GET</code> requests. If you make multiple write operations in a <code>GET</code> request and somehow your request fails, your database state could be left in an inconsistent state because ABP doesn't create a database transaction for <code>GET</code> requests. In this case, either enable transactions for <code>GET</code> requests using  <code>AbpUnitOfWorkDefaultOptions</code> or manually control the UoW, as described in the next section.</p>
			<p>Use <code>AbpUnitOfWorkDefaultOptions</code> in the <code>ConfigureServices</code> method of your <a id="_idIndexMarker401"/>module (in the database integration project) if you want to change the UoW option<a id="_idTextAnchor210"/>s, as follows:</p>
			<pre>public override void ConfigureServices(
    ServiceConfigurationContext context)
{
    Configure&lt;AbpUnitOfWorkDefaultOptions&gt;(options =&gt;
    {
        options.TransactionBehavior =                                   UnitOfWorkTransactionBehavior.Enabled;
        options.Timeout = 300000; // 5 minutes
        options.IsolationLevel =                                      IsolationLevel.Serializable;
    });
}</pre>
			<p><code>TransactionBehavior</code> can take the following three values:</p>
			<ul>
				<li><code>Auto</code> (default): Automatically determines using database transactions (transactions are enabled for non-<code>GET</code> <code>HTTP</code> requests)</li>
				<li><code>Enabled</code>: Always uses a database transaction, even for <code>HTTP</code> <code>GET</code> requests</li>
				<li><code>Disabled</code>: Never uses a database transaction</li>
			</ul>
			<p>The <code>Auto</code> behavior is the default value and is suggested for most applications. <code>IsolationLevel</code> is only valid for relational databases. ABP uses the default value of the underlying provider <a id="_idIndexMarker402"/>if you don't specify it. Finally, the <code>Timeout</code> option allows you to set a default timeout value for transactions as milliseconds. If a UoW operation doesn't complete in the given timeout value, a timeout exception is thrown.</p>
			<p>In this section, we've learned how to configure the default options across all UoWs. It is also possible to configure these values for an individual UoW if you manually control it.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor211"/>Manually controlling the UoW</h2>
			<p>For web applications, you rarely need to control the UoW system manually. However, for background <a id="_idIndexMarker403"/>workers or non-web applications, you may need to create UoW scopes yourself. You may also need to control the UoW system to create inner transaction scopes.</p>
			<p>One way to create a UoW scope is to use the <code>[UnitOfWork]</code> attribute on your method, like this:</p>
			<pre>[UnitOfWork(isTransactional: true)]
public async Task DoItAsync()
{
    await _formRepository.InsertAsync(new Form() { ... });
    await _formRepository.InsertAsync(new Form() { ... });
}</pre>
			<p>The UoW system uses the Ambient Context pattern. If a surrounding UoW is already in place, your <code>UnitOfWork</code> attribute is ignored and your method participates in the surrounding UoW. Otherwise, ABP starts a new transactional UoW just before entering the <code>DoItAsync</code> method and commits the transaction if it doesn't throw an exception. The transaction is rolled back if that method throws an exception.</p>
			<p>If you want to fine-control the UoW system, you can inject and use the <code>IUnitOfWorkManager</code> service, as shown in the following code block:</p>
			<pre>public async Task DoItAsync()
{
    using (var uow = _unitOfWorkManager.Begin(
        requiresNew: true,
        isTransactional: true,
        timeout: 15000))
    {
        await _formRepository.InsertAsync(new Form() { });
        await _formRepository.InsertAsync(new Form() { });
        await uow.CompleteAsync();
    }
}</pre>
			<p>In this example, we are starting a new transactional UoW scope with 15 seconds as the <code>timeout</code> parameter's value. With this usage (<code>requiresNew: true</code>), ABP always starts a new UoW even if <a id="_idIndexMarker404"/>there is a surrounding UoW. Always call the <code>uow.CompleteAsync()</code> method if everything goes right. You can use the <code>uow.RollbackAsync()</code> method if you want to roll back the current transaction.</p>
			<p>As mentioned before, UoW uses an ambient scope. You can access the current UoW anywhere in this scope, using the <code>IUnitOfWorkManager.Current</code> property. It can be <code>null</code> if there is no ongoing UoW.</p>
			<p>The following code snippet uses the <code>SaveChangesAsync</code> method with the <code>IUnitOfWorkManager.Current</code> property:</p>
			<pre>await _unitOfWorkManager.Current.SaveChangesAsync();</pre>
			<p>We've saved all pending changes to the database. However, if that's a transactional UoW, these changes are also rolled back if you roll back the UoW or throw any exception in the UoW scope.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor212"/>Summary</h1>
			<p>In this chapter, we've learned how to work with databases using ABP Framework. ABP standardizes to define entities by providing base classes. It also helps to automatically track change times and the users changing entities, when you derive from audited entity classes.</p>
			<p>The repository system provides the fundamental functionalities to read and write entities. You can use LINQ over the repositories for advanced querying possibilities. Also, you can create custom repository classes to work with the underlying data provider directly, hide complex queries behind simple repository interfaces, call stored procedures, and so on.</p>
			<p>ABP is database-agnostic, but it provides integration packages with EF Core and MongoDB out of the box. ABP application startup templates come with one of these providers, whichever you prefer.</p>
			<p>EF Core is the de facto ORM for the .NET platform, and ABP supports EF Core as a first-class citizen. The application startup template is fine-tuned to configure your mappings and manage your database schema migrations while supporting a modular application structure.</p>
			<p>Finally, the UoW system provides a seamless way to manage database connections and transactions for us. It keeps the application code clean by automating these repeating tasks for us.</p>
			<p>Data access is a core requirement for any business application, and it is essential to understand the details of it. The next chapter will continue with the cross-cutting concerns required for every application, such as authorization, validation, and exception handling.</p>
		</div>
	</body></html>