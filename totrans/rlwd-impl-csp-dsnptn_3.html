<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-64"><a id="_idTextAnchor063"/>3</h1>
<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Getting Creative with Creational Patterns</h1>
<p>Creational patterns deal with creating <a id="_idIndexMarker175"/>objects, a process<a id="_idIndexMarker176"/> we call <em class="italic">instantiation</em>. Remember, an object is a class that has been instantiated. Objects only exist in <a id="_idIndexMarker177"/>running programs. They are built from blueprints called <em class="italic">classes</em>. Since C# is a static language, you can’t generally change the structure of an object once it has been instantiated, which means you should use the best strategy to create your objects. That’s what we’ll be discussing in this chapter.</p>
<p>Even if you’re <code>new</code> to software development with C# (that might be the first pun in the book that relies only on formatting to be funny), you already know the simplest way to instantiate an object from a class. You simply use the <code>new</code> keyword and invoke the class’s constructor:</p>
<pre class="source-code">var myConcreteClass = new ConcreteObjectThingy();</pre>
<p>That’s instantiation. You’re creating an instance of a class that acts as the point where the class turns into an object. In C#, like many languages, we use the <code>new</code> keyword in conjunction with a constructor. A constructor is a method, whose name. matches the class’s name Its only job is to create and return an instance of the class as a new object. That is why you have a parenthesis at the end of <code>CreateObjectThingy()</code>.</p>
<p>Why do we need anything else? Remember the foundational principles we covered earlier in this book. We don’t want a stovepipe system consisting of a bunch of object classes we can’t build from because they’re too specific, too concrete, or tightly coupled to one another. By definition, the <code>new</code> keyword creates a concrete object. Our classes should be open for extension but closed for modification. and However in stovepipe software they aren’t stovepipe software, they aren’t. Following patterns will help us avoid those situations and provide us with a clear way to create complex objects that are easy to understand and extend. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The initial design</li>
<li>No pattern implementation</li>
<li>The Simple Factory pattern</li>
<li>The Factory Method pattern</li>
<li>The Builder pattern</li>
<li>The Object Pool pattern</li>
<li>The Singleton pattern</li>
</ul>
<p>These patterns will be shown in simple C# command-line projects to keep the proverbial signal-to-noise ratio low. There are a great many books out there that teach patterns independently of any coding language. I think this is a mistake. Most people learn by doing, and to “do” patterns, you need an implementation language. Without that, you are just learning academic concepts. We are focused on the real world and we’re using C#, but what you will learn in this book is 100% portable. As you learn about these patterns, remember that they are not language-specific. You can use the knowledge you gain here and apply it to Java, Python, or any other object-oriented language.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Technical requirements</h1>
<p>Throughout this book, I assume you know how to create new C# projects in your favorite <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>), so I won’t spend any time on the mechanics of setting up and running projects. Should you decide to try any of this out, you’ll need the following:</p>
<ul>
<li>A computer running the Windows operating system. I’m using Windows 10. Since the projects are simple command-line projects, I’m pretty sure everything here would also work on a Mac or Linux, but I haven’t tested the projects on those operating systems.</li>
<li>A supported IDE such as Visual Studio, JetBrains Rider, or Visual Studio Code with C# extensions. I’m using Rider 2021.3.3.</li>
<li>Some version of the .NET SDK. Again, the projects are simple enough that our code shouldn’t be reliant on any particular version. I happen to be using the .NET Core 6 SDK.</li>
<li>You can find the completed project files for this chapter on GitHub at <a href="https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3">https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3</a>.</li>
</ul>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>The following story is fictitious</h1>
<p>Any resemblance to <a id="_idIndexMarker178"/>actual persons, alive or dead, is a mere coincidence.</p>
<p>Meet Kitty and Phoebe – Texas-born sisters who share a love for riding bicycles. Phoebe is studying engineering at Southern Methodist University, a private university in the sisters’ hometown of Dallas, Texas. Texas is one of the southernmost states in the United States. Kitty is studying industrial design at Sul Ross University in West Texas. Purely through kismet, they both won a summer internship at MegaBikeCorp, which is a large multi-national bicycle manufacturing company: </p>
<div><div><img alt="Figure 3.1: Kitty (left) and Phoebe (right) posing with their innovative bicycle prototype built entirely in their robotic factory. " height="748" src="img/B18605_Figure_3.1_NEW.jpg" width="1482"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Kitty (left) and Phoebe (right) posing with their innovative bicycle prototype built entirely in their robotic factory.</p>
<p>While working at <a id="_idIndexMarker179"/>MegaBikeCorp, the sisters had the opportunity to try out several different kinds of bicycles. Phoebe, who lives in a big city, is partial to the road bike. Road bikes use a diamond-shaped frame with two large thin wheels, slick tires, and plenty of gears to help a rider deal with the steep hills they often encounter in many cities: </p>
<div><div><img alt="Figure 3.2 – Kitty’s CAD design for a road bike she calls Hillcrest. " height="498" src="img/B18605_Figure_4.2.jpg" width="1282"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Kitty’s CAD design for a road bike she calls Hillcrest.</p>
<p>The rider on a road bike leans far forward on a set of dropped handlebars. This makes these bicycles fast, and every year, hundreds of riders from all over the world compete in a famous race called the <em class="italic">Tour de France</em>. In the tour, racers compete to see who is the fastest in the world. Kitty and Phoebe recalled that their mother, a huge cycling fan, would not allow anyone in the house to speak while the race was on television. Phoebe also enjoyed the tour and as she cycled through the streets of Dallas on her road bike, she would often have a desire to ride faster. This requires a different bike.</p>
<p>Phoebe rides a recumbent bike when she needs to satisfy her need for speed. A recumbent bicycle features the rider sitting in a comfortable seat that looks more like a lawn chair but with wheels. You can see Kitty’s design in the <a id="_idIndexMarker180"/>following diagram:</p>
<div><div><img alt="Figure 3.3 – Kitty’s CAD design for a recumbent bicycle. Note that the frame is shaped differently than the diamond shape used on most other bicycles such as the Hillcrest shown in the inset. These are among the fastest bicycles ever made. " height="605" src="img/B18605_Figure_4.3.jpg" width="1072"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Kitty’s CAD design for a recumbent bicycle. Note that the frame is shaped differently than the diamond shape used on most other bicycles such as the Hillcrest shown in the inset. These are among the fastest bicycles ever made.</p>
<p>The rider leans way back and sits very low on the bicycle. The seat is stretched out beneath Phoebe. The pedals are elevated above the front wheel to capture the power of the rider’s full leg extension. These bikes can go faster than a traditional racing bicycle and they’re very comfortable to ride over long distances. However, because of racing rules recognized throughout the world, they are never used for racing in events such as the <em class="italic">Tour de France</em>.</p>
<p>Kitty, on the other hand, enjoys riding a mountain bike, which is designed to be ridden off-road like a Jeep. Mountain bikes, like road bikes, use a diamond-shaped frame, but they have big, knobby tires and disc brakes that work well in the mud. The rider sits more upright so that they can see and react to any off-road obstacles. The standard mountain bicycles usually have fancy shock absorbers in the front, and the more expensive bikes have a <a id="_idIndexMarker181"/>separate shock absorber on the back wheel, along with the front shocks:</p>
<div><div><img alt="Figure 3.4 – Kitty’s CAD drawing for an innovative design for a mountain bike that she calls the “Palo Duro Canyon Ranger”. " height="731" src="img/B18605_Figure_4.4.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Kitty’s CAD drawing for an innovative design for a mountain bike that she calls the “Palo Duro Canyon Ranger”.</p>
<p>Kitty also likes riding in town, but she doesn’t like the uncomfortable riding position of a road bike. A recumbent bike is too <a id="_idIndexMarker182"/>dangerous to ride because it is so low to the ground that cowboys driving the big trucks that are so popular in Texas won’t be able to see her. Instead, Kitty likes to ride comfort cruisers, sometimes called <em class="italic">granny bikes</em>. They are perfect for in-town riding. They let her sit fully upright in a comfortable position owing to a curved handlebar design: </p>
<div><div><img alt="Figure 3.5 – Kitty’s design for a comfort cruiser bicycle, sometimes called a granny bike. These are perfect for in-town commutes and tourists who need to get around comfortably. " height="729" src="img/B18605_Figure_4.5.jpg" width="953"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Kitty’s design for a comfort cruiser bicycle, sometimes called a granny bike. These are perfect for in-town commutes and tourists who need to get around comfortably.</p>
<p>The cruisers have thick tires for stability and they have a chain guard and enclosed gear system to prevent ruining the left leg of your pants, which tends to rub against the bicycle chain. These bicycles are built for comfort rather than speed or off-road prowess.</p>
<p>Between them, the<a id="_idIndexMarker183"/> sisters rode every model of bicycle produced by MegaBikeCorp. Phoebe found the level of engineering innovation at MegaBikeCorp uninspiring. Kitty felt MegaBike’s designs were stale. “<em class="italic">They’ve been making the same four bicycles for 30 years,</em>” Kitty said. The sisters decided they could do better and decided to make a plan of action. After many long nights, lots of tacos, online collaboration sessions, bicycle rides, and a few skinned knees, they came up with four bicycle designs. But the sisters did not stop with bike designs. They also came up with plans for a robotic manufacturing system that could fully automate the bicycle production process. Together, they formed a start-up company called <em class="italic">Bumble Bikes Incorporated</em>, named <a id="_idIndexMarker184"/>after Phoebe’s favorite childhood toy: a stuffed bumblebee she named <em class="italic">Bumbles</em>. They plan to open two manufacturing locations: one in the sisters’ hometown of Dallas, Texas, and the other in Kitty’s college town of Alpine, Texas. The two areas are very different geographically.</p>
<p>North Texas, Dallas in particular, is urban and heavily developed. Cycling is a popular sport and hobby for many North Texans. The riders in the Dallas area primarily buy traditional road bicycles. Surprisingly, there is also a lot of interest in recumbent bicycles, especially around the large engineering colleges. You can even see recumbents ridden around the 7 million-square-foot (650 million square-meter) campus of Texas Instruments – a large semi-conductor manufacturer in Dallas. The girls decided to build their road bike and recumbent bike designs in the factory in Dallas.</p>
<p>In West Texas, the city of Alpine is the last bastion of civilization north of Big Bend National Park. Extreme mountain biking is popular in the Chisos mountain basin and the old mining and cattle roads that crisscross the desert. Alpine is a small town and doesn’t have or need any mass transit services.  Kitty’s research indicates there is a market for comfortable “cruiser” bicycles that are ideal for getting around town. Kitty decides to manufacture the mountain bike and the cruiser models in Alpine. Phoebe and Kitty, with their initial plans in hand, set to work.</p>
<p>Phoebe tasked herself to work on the robotics to be used in manufacturing the bicycles. Kitty settled down with her favorite C# IDE and got to work on the control software that would ultimately control Phoebe’s robotics. She knows that her designs, along with Phoebe’s engineering, will produce the best bicycles the industry has ever seen. Kitty is planning on their company and the software that runs it  being wildly successful, which, as we learned in <a href="B18605_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">There’s a Big Ball of Mud on Your Plate of Spaghetti</em>, is the worst-case scenario.</p>
<p>Kitty’s starting point in writing the code for her robotics control software is going to be modeling out the basic class structure for very generic bicycle objects. This modeling will form the basis of her entire company’s future. Modeling the classes well the first time will put Kitty and Phoebe riding their bicycles down the road to success!</p>
<p>Let’s follow the exploits of the <a id="_idIndexMarker185"/>sisters, Kitty and Phoebe, as they embark on building the automated plant’s robotic control systems. We’ll focus on creational patterns, which are just what they sound like: patterns for controlling the instantiation of objects.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>The initial design</h1>
<p>Kitty knows she wants to model <a id="_idIndexMarker186"/>a bicycle for her software, and she wants to design her models in a way that maximizes each class’s flexibility. The plan for the start-up is to develop four bicycles with a future expansion to include exotic bicycles and custom builds.</p>
<p>Kitty opens her IDE and creates a class library project to hold her classes since she knows she’s probably going to use these in several different programs. She calls the class library <code>BumbleBikesLibrary</code> which you’ll find in the sample code for this chapter.</p>
<p>She decides to start with an abstract class and to use inheritance to define her bicycle models for each of the four types of bicycles she intends to initially design and manufacture. <em class="italic">Figure 3.6</em> shows the result of her effort. This set of properties can be used to define nearly any type of bicycle:</p>
<div><div><img alt="Figure 3.6 – The abstract bicycle model. " height="358" src="img/B18605_Figure_4.6.jpg" width="586"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – The abstract bicycle model.</p>
<p>Let’s take a look at these properties in more detail:</p>
<ul>
<li><code>ModelName</code>: The name of the model as it will appear on the company website.</li>
<li><code>Year</code>: The model year for the bicycle. All bicycle designs should be updated every 2 years to prevent the designs from becoming stale like MegaBikeCorp’s.</li>
<li><code>SerialNumber</code>: A unique identifier for each bicycle that rolls off the assembly line.</li>
<li><code>Color</code>: The color of the bicycle. To keep initial costs low, Kitty will define an enumeration with a limited set of colors for each model.</li>
<li><code>Geometry</code>: This refers to the frame configuration for the bicycle. All the bikes for the initial manufacturing <a id="_idIndexMarker187"/>run are either upright or recumbent geometries. This can be moved into an enumeration as well.</li>
<li><code>Suspension</code>: This refers to the type of shock absorbers used on the bicycle. Shocks are most important on mountain bikes, but you also find them on road bicycles, recumbents, and some cruisers. It could be argued that this property is only appropriate for a mountain bike subclass, but Kitty knows about “analysis paralysis.” Rather than trying to get the model perfect on the first go-around, she decides to put it in the superclass for now. She can always refactor it later when things become more concrete, or if she gets a whiff of smelly code structure.</li>
<li><code>BuildStatus</code>: Kitty knows her robotics control system needs to understand the current state of the bicycle build process, so she decides to include an enumerated property to hold this information.</li>
</ul>
<p>Several properties can be expressed as an enumeration, which is a fixed collection. Back in the old days, we used “magic numbers” to represent finite lists. The programmers would assign an integer to each value. As an example, to represent a finite list of suspension types, we might be tempted to number them 0 through 3, since there are four possibilities. This made maintenance difficult because everyone had to remember what each number meant. Was it 0 for a full suspension? What was the code for a hardtail? Later, we wised up and defined constants for everything:</p>
<pre class="source-code">const int FULLSUSPENSION = 0; 
const int FRONTSUSPENSION = 1; 
const int SEATPOSTSUSPENSION = 2; 
const int HARDTAIL = 3;</pre>
<p>This is better, but it isn’t very object-oriented. You wind up with dozens of lines of ugly constant definitions in all caps. You might be tempted to use an integer type to model them since you are presented with the opportunity to assign an arbitrary integer as a value. What will stop someone from setting it to 100 when the potential values are supposed to be from 0 to 3? We could write encapsulation logic to enforce our range of 0 to 3. That’s all well and good, but we’d have to constantly alter the accessor logic every time we add a new suspension to the line-up. Thankfully, in C#, we have <code>&lt;&lt;Enumeration&gt;&gt;</code> tag at the top of the box. Our bicycle class uses four enumerations, as shown here:</p>
<div><div><img alt="Figure 3.7 – Four enumerations are defined to limit the options available for our abstract bicycle’s geometry, suspension, color, and current manufacturing status. Enumerations help us keep our object’s state clean, valid, and easy to read. " height="612" src="img/B18605_Figure_4.7.jpg" width="852"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Four enumerations are defined to limit the options available for our abstract bicycle’s geometry, suspension, color, and current manufacturing status. Enumerations help us keep our object’s state clean, valid, and easy to read.</p>
<p>Before getting into patterns, let’s begin by creating what we have diagrammed so far. First, Kitty will make the four enumerations: </p>
<ul>
<li><code>SuspensionTypes</code></li>
<li><code>BicycleGeometries</code></li>
<li><code>BicyclePaintColors</code></li>
<li><code>ManufacturingStatus</code></li>
</ul>
<p>Here is the <code>BicycleGeometries</code> enumeration:</p>
<pre class="source-code">public enum BicycleGeometries 
{ 
  Upright, Recumbent 
}</pre>
<p>Next, she makes <a id="_idIndexMarker190"/>an <code>enum</code> for suspension types:</p>
<pre class="source-code">public enum SuspensionTypes 
{ 
  Full, Front, Hardtail  
}</pre>
<p>Next comes the paint colors:</p>
<pre class="source-code">public enum BicyclePaintColors 
{ 
  Black, Red, White, Blue 
}</pre>
<p>Finally, Kitty makes an <code>enum</code> for manufacturing status codes:</p>
<pre class="source-code">public enum ManufacturingStatus 
{ 
  Specified, FrameManufactured, Painted, SuspensionMounted,
   Complete 
}</pre>
<p>With those out of the way, let’s see what the <code>Bicycle</code> base class looks like:</p>
<pre class="source-code">public abstract class Bicycle 
{ 
  protected string ModelName { get; init; } 
  private int Year { get; set; } 
  private string SerialNumber { get; } 
  protected BicyclePaintColors Color { get; init; } 
  protected BicycleGeometries Geometry { get; init; } 
  protected SuspensionTypes Suspension { get; init; } 
  private ManufacturingStatus BuildStatus { get; set; }</pre>
<p>Kitty creates the <code>Bicycle</code> class as an abstract class, just as she did in the UML model. Note that the name of the class in <em class="italic">Figure 3.6</em> is <em class="italic">italicized</em>, indicating it is abstract. Next, she adds the properties. The UML model purposefully left out the access modifiers and types, leaving those as implementation details for the programmer to <a id="_idIndexMarker191"/>determine. In this case, as it is with many start-up projects, the architect and developer are the same person.</p>
<p>Kitty defines several of the properties as being protected because she intends to manipulate them from the subclasses. A few of the properties are marked <code>private</code> since it is appropriate to manipulate those at a higher level.</p>
<p>Next, she moves on to the constructor, which is the function that is run with instantiation using the <code>new</code> keyword:</p>
<pre class="source-code">  public Bicycle() 
  { 
    ModelName = string.Empty; 
    SerialNumber = Guid.NewGuid().ToString(); 
    Year = DateTime.Now.Year; 
    BuildStatus = ManufacturingStatus.Specified; 
  }</pre>
<p>Kitty sets the default values for each property within the constructor. The model name, for now, is empty. She’ll change that in the subclass. The serial number property is a generated GUID, which is a string that is guaranteed to always be unique. The <code>Year</code> property is set to the current year, and <code>BuildStatus</code> is set to the first status in the enumeration.</p>
<p>The last step is to add the <code>Build</code> method. For now, the <code>Build</code> method will just print to the console to show the logic is working correctly. Eventually, this can be substituted for the more complex control logic for Phoebe’s robotic systems:</p>
<pre class="source-code">  public void Build() 
  { 
    Console.WriteLine($"Manufacturing a {Geometry.ToString()} frame..."); 
    BuildStatus = ManufacturingStatus.FrameManufactured; 
    PrintBuildStatus(); 
     
    Console.WriteLine($"Painting the frame {Color.ToString()}"); 
    BuildStatus = ManufacturingStatus.Painted; 
    PrintBuildStatus(); 
     
    if (Suspension != SuspensionTypes.Hardtail) 
    { 
      Console.WriteLine($"Mounting the {Suspension.ToString()} suspension."); 
      BuildStatus = ManufacturingStatus.SuspensionMounted; 
      PrintBuildStatus(); 
    } 
    Console.WriteLine("{0} {1} Bicycle serial number {2} manufacturing complete!", Year, ModelName, SerialNumber); 
    BuildStatus = ManufacturingStatus.Complete; 
    PrintBuildStatus(); 
  }</pre>
<p>The abstract class<a id="_idIndexMarker192"/> is done! Next, Kitty needs to create the concrete subclasses for the bicycles they intend to build:</p>
<ul>
<li><code>RoadBike</code></li>
<li><code>MountainBike</code></li>
<li><code>Recumbent</code></li>
<li><code>Cruiser</code></li>
</ul>
<p>First, she makes the <code>RoadBike</code> class:</p>
<pre class="source-code">public class RoadBike : Bicycle 
{ 
  public RoadBike() 
  { 
    ModelName = "Hillcrest"; 
    Suspension = SuspensionTypes.Hardtail; 
    Color = BicyclePaintColors.Blue; 
    Geometry = BicycleGeometries.Upright; 
     
  }   
}</pre>
<p>The <code>RoadBike</code> class inherits from <code>Bicycle</code> and the constructor sets the defaults for the class. The model name is <code>Hillcrest</code>, after the name of the street that runs West of Phoebe’s university campus. Road bikes typically lack shock absorbers, so she defines the suspension type as <code>Hardtail</code>. The initial models only come in <a id="_idIndexMarker193"/>one color, and this one comes in blue. Since this isn’t a 	recumbent, the geometry is set to <code>Upright</code>.</p>
<p>With Phoebe’s favorite road bike out of the way, Kitty sets to modeling her favorite – the mountain bike:</p>
<pre class="source-code">public class MountainBike : Bicycle 
{ 
  public MountainBike() 
  { 
    ModelName = "Palo Duro Canyon Ranger"; 
    Suspension = SuspensionTypes.Full; 
    Color = BicyclePaintColors.Black; 
    Geometry = BicycleGeometries.Upright; 
  } 
   
}</pre>
<p>Kitty names the mountain bike after the Palo Duro Canyon located in the Texas panhandle. Few people know that the Palo Duro Canyon is the second-largest canyon in the United States, after the Grand Canyon. Palo Duro Canyon is home to some of the best mountain biking in Texas. She wants an aggressive look for her design, so she goes with <code>Black</code> for the color. Naturally, not being one to skimp, she creates the design with full suspension – shocks on the front and rear of the bicycle to handle any obstacle the trail might present. As mentioned previously, given it isn’t recumbent, the geometry is defined as <code>Upright</code>.</p>
<p>Now, the <code>Recumbent</code> bicycle class needs to be created:</p>
<pre class="source-code">public class Recumbent : Bicycle 
{ 
  public Recumbent() 
  { 
    ModelName = "Big Bend"; 
    Suspension = SuspensionTypes.Front; 
    Color = BicyclePaintColors.White; 
    Geometry = BicycleGeometries.Recumbent; 
  }   
}</pre>
<p>Kitty decides to call this bike <em class="italic">Big Bend</em>. The Big<a id="_idIndexMarker194"/> Bend area is a desert with a mountain range, which has a host of mountain biking opportunities. However, there are great stretches of paved and unpaved roads that are more or less straight. Recumbents do well in those environments as their design allows riders to go faster and farther <a id="_idIndexMarker195"/>without getting tired. The recumbents are also pretty good at pulling trailers. A person who desires to camp can carry adequate water and supplies. Since the bicycle’s namesake has paved and unpaved roads, Kitty opts for a front suspension. Recumbents already have a nice seat, so rear suspension doesn’t add many benefits, and it would make the bicycle more expensive. Naturally, the geometry is set to <code>Recumbent</code>.</p>
<p>The final bicycle is the cruiser:</p>
<pre class="source-code">public class Cruiser : Bicycle
{
    public Cruiser()
    {
        ModelName = "Galveston Cruiser";
        Suspension = SuspensionTypes.Hardtail;
        Color = BicyclePaintColors.Red;
        Geometry = BicycleGeometries.Upright;
    }
}</pre>
<p>Kitty names this bicycle the <em class="italic">Galveston Cruiser</em> after fondly remembering her seaside vacations with her family. Galveston is a medium-sized city on the Gulf of Mexico. Galveston has beaches, a pier for commercial and vacation cruise ships, and a lively historical district called <em class="italic">The Strand</em>. The Strand is loaded with one-of-a-kind <a id="_idIndexMarker196"/>shops, cafes, bars, museums, and fun activities for tourists. Parking at the Strand is expensive, and often difficult to find. Galveston’s Strand is the perfect place to ride a cruiser, aside from the less known streets of Alpine.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>No pattern implementation</h1>
<p>Kitty is on a roll! You know how <a id="_idIndexMarker197"/>it gets. She knocked out the enumerations, base class, and subclasses in nary an hour. She’s seriously <em class="italic">cruising</em> along and she doesn’t want to lose velocity. Kitty gives in to the temptation to write this code for the final implementation of the main entry point for the program:</p>
<pre class="source-code">using BumbleBikesLibrary; 
const string errorText = "You must pass in mountainbike, cruiser, recumbent, or roadbike"; </pre>
<p>We take in an argument from the command-line program and use that to determine what to make. If a string was passed in, the length of <code>args</code> will be greater than zero and we can do our thing. Otherwise, we can admonish our foolish users for thinking our software can read their minds: </p>
<pre class="source-code">if(args.Length &gt; 0) 
{ </pre>
<p>It’s a good idea to trim and normalize your command-line input. This means we ignore extra spaces in front of and after the argument. We ignore the case by forcing everything to either upper or lowercase so that we can compare the input with our expected values. The comparison works regardless of whether the user passed in <em class="italic">mountainbike</em>, <em class="italic">MOUNTAINBIKE</em>, or even <em class="italic">mOuNtAiNbIkE</em>:</p>
<pre class="source-code">  var bicycleType = args[0].Trim().ToLower(); 
  Bicycle bikeToBuild; </pre>
<p>Next comes a <code>switch</code> statement based on the input. The input determines what to build and returns the corresponding class instance:</p>
<pre class="source-code">  switch (bicycleType) 
  { 
    case "mountainbike": 
      bikeToBuild = new MountainBike(); 
      break; 
    case "cruiser": 
      bikeToBuild = new Cruiser(); 
      break; 
    case "recumbent": 
      bikeToBuild = new Recumbent(); 
      break; 
    case "roadbike": 
      bikeToBuild = new RoadBike(); 
      break; </pre>
<p>If the user passes an argument that we haven’t accounted for in the switch, such as <code>MotorCycle</code> or <code>PeanutButter</code>, we write and throw an exception:</p>
<pre class="source-code">    default: 
      Console.WriteLine(errorText); 
      throw new Exception("Unknown bicycle type: " +       bicycleType); 
  } 
   
  bikeToBuild.Build(); 
}  </pre>
<p>If no arguments were passed into the command-line program, we show an error message instructing the user to supply the required argument:        </p>
<pre class="source-code">else 
{ 
  Console.WriteLine(errorText); 
}</pre>
<p>Effectively, Kitty is <a id="_idIndexMarker198"/>taking a command-line argument and using the software’s main entry point, <code>Program.cs</code>, as the class that will instantiate the correct bicycle type. She tries it out and it works! Kitty has cleverly leveraged Liskov substitution by using the abstract base class as her type for the <code>bikeToBuild</code> variable, which allows her to instantiate the appropriate subclass based on what kind of bike she wants to build. Kitty would not be able to do that if she was working at MegaBikeCorp. She would probably have a pointy-haired boss who would tell her to clean up the code and ship it. Thankfully, she’s in business for herself as a nagging voice in the back of her mind decries, “<em class="italic">You can do better.</em>”</p>
<p>Kitty’s first implementation <a id="_idIndexMarker199"/>can be found in the <code>NoPattern</code> project within this chapter’s sample source code.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>The Simple Factory pattern</h1>
<p>Kitty decides to do a little <a id="_idIndexMarker200"/>research on patterns. She wasn’t a computer science major in college and had only heard of patterns in her coding class. Kitty looks around and finds some blog articles on something called <strong class="bold">the Simple Factory pattern</strong>. Perfect, she thinks. This being her first coding project since college, and since she has a lot <em class="italic">riding</em> on her code (see what I did there?), she decides that something with <em class="italic">simple</em> right there in the name is a good place to start.</p>
<p>According to the blogs, all she has to do is move her instantiation logic into its own class, called a <strong class="bold">factory class</strong>. This is<a id="_idIndexMarker201"/> done, say the articles, to decouple the instantiation logic from the main program. This should get her closer to honoring the open-closed principle and should make her code more flexible.</p>
<p>She returns to her IDE and adds a class called <code>SimpleBicycleFactory</code> and moves her instantiation logic there. The logic is the same as that shown previously:</p>
<pre class="source-code">public class SimpleBicycleFactory 
{ 
  public Bicycle CreateBicycle(string bicycleType) 
  { 
    Bicycle bikeToBuild; 
    switch (bicycleType) 
    { 
      case "mountainbike": 
        bikeToBuild = new MountainBike(); 
        break; 
      case "cruiser": 
        bikeToBuild = new Cruiser(); 
        break; 
      case "recumbent": 
        bikeToBuild = new Recumbent(); 
        break; 
      case "roadbike": 
        bikeToBuild = new RoadBike(); 
        break; 
      default: 
        throw new Exception("Unknown bicycle type: " +         bicycleType); 
    } 
    return bikeToBuild; 
  } 
} </pre>
<p>Then, Kitty refactors her <code>Program.cs</code> file to use the simple factory:</p>
<pre class="source-code">using SimpleFactoryExample; 
 
const string errorText = "You must pass in mountainbike, cruiser, recumbent, or roadbike"; 
 
if (args.Length &gt; 0) 
{ 
  var bicycleType = args[0].Trim().ToLower(); </pre>
<p>Here’s the different part – Kitty uses the <code>SimpleBicycleFactory</code> class instead of directly running a <code>switch</code> statement:</p>
<pre class="source-code">  var bicycleFactory = new SimpleBicycleFactory(); 
  var bikeToBuild = bicycleFactory.CreateBicycle(bicycleType); 
  bikeToBuild.Build(); 
} 
else 
{ 
  Console.WriteLine(errorText); 
}</pre>
<p>A refactor, by definition, means you are improving the structure or performance of your code without introducing any new features. Kitty has accomplished this by making her code a little more elegant.</p>
<p>When the logic is free-range in the <code>Program.cs</code> file, it is locked into being used in only that program. Kitty wisely realizes that she and, undoubtedly, Phoebe will want to create other programs that can use the creation logic. Encapsulating the logic into a class is an obvious improvement.</p>
<p>Kitty, before closing her <a id="_idIndexMarker202"/>laptop for the evening, notices a post on social media from her programming professor. She asks how he’s been and while catching up, she mentions her code project. The prof says he’d love to see it, so she sends him a GitHub link.</p>
<p>The code Kitty’s professor is going to review can be found in the <code>SimpleFactoryPattern</code> project within this chapter’s sample source code.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>The Factory Method pattern</h1>
<p>Kitty’s old professor looks at the code and tells her this newer code is an improvement, but she isn’t using a pattern. The simple <a id="_idIndexMarker203"/>factory is classified <a id="_idIndexMarker204"/>as a <strong class="bold">programming idiom</strong>. Idioms are like patterns, in that they occur frequently. You recognize them when you see one, but they haven’t fully realized any solutions to common problems. Perhaps the most famous programming idiom ever devised was created in Kernighan and Ritchie’s book titled <em class="italic">The C Programming Language</em>, also known as <em class="italic">The K&amp;R book</em>. It was in this book we saw our very first <em class="italic">Hello, World</em> program. <em class="italic">Hello, World</em> is an idiom. It usually serves as the first few lines of code you try when you are learning a new language. It doesn’t solve any industrial-grade problems by encouraging flexibility and code reuse.</p>
<p>Kitty realized she’d seen this idiom in her IDE of choice for C#, JetBrains <em class="italic">Rider</em>. When you create a console application, like the one she’s been working on, the first thing you see is this code , which is generated by the IDE as a starting point for the project:</p>
<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
<p>I have included an example of a <code>Hello,</code> <code>World</code> program. You’ll find it in the <code>HelloWorld</code> project, located within the chapter’s source code. Yes, I did include a <code>Hello, World</code> program because I’m all about attention to detail. Now, back to the story.</p>
<p>The next day, Kitty sets herself to fully researching the creational patterns. She wanted to do this the right way. After some reading, Kitty found several patterns called factory patterns: </p>
<ul>
<li>The simple factory, which we’ve established isn’t a pattern, but it is often mistaken for one.</li>
<li>The Factory pattern, which is a mild improvement over the simple factory.</li>
<li>The Factory Method pattern, which truly abstracts the creation process when you have a variety of object types to instantiate.</li>
<li>The Abstract Factory pattern, which, for now, seems more complex than necessary since it deals with creating groups of objects. </li>
</ul>
<p>Kitty settled on what she thought would be the perfect pattern for her problem: <strong class="bold">the Factory Method pattern</strong>. She also thought it ironic that the starting point for her software design was working with a factory pattern, given she was modeling what would one day be a physical factory. The factory patterns are so-called because they take a set of inputs and produce a concrete object as output. The simple factory accomplished this at a superficial level, but there are some problems with relying on the idiom in place of the real pattern. The idiom isn’t as flexible as it could be. Bumble Bikes Inc. is going to have two factory locations making different types of bicycles. The simple factory can create any bicycle, but at the same time, it’s locked into making all four. Relate that to a real factory and you can see it might be wasteful to require the factory to make every kind of bicycle, instead of the two that it will be making.</p>
<p>In our software design, the factory shouldn’t have any knowledge of what it is going to create. It should be flexible enough to make any kind of bicycle. We can structure this so that we can create a factory capable of producing a subset of all the subclasses. The subclasses decide what can and should be made concrete. We can diagram the generic factory method pattern as so:</p>
<div><div><img alt="Figure 3.8 – A generic diagram of the Factory Method pattern. " height="535" src="img/B18605_Figure_4.8.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – A generic diagram of the Factory Method pattern.</p>
<p>Let’s review each part <a id="_idIndexMarker205"/>of the diagram based on the numbers:</p>
<ol>
<li>The Factory Method pattern starts with an interface that defines a common behavior or set of behaviors. In general, using interfaces is more flexible than using a base class because you aren’t limited by the inheritance rules in C. This is to say that any child class in C# may have only one parent class. Multiple class inheritance is not supported. In the case of interfaces, any class may implement as many different interfaces as are needed.  </li>
<li>When we discuss the Factory Method pattern, we call the objects the factory creates <code>products</code>. These are the concrete products the factory will produce. They will all implement the common product interface. In practice, you don’t need to stick with the same names, as shown in the preceding diagram.</li>
<li>A factory method has a <code>Creator</code> class that houses the factory method itself. The Factory Method is coded to return the <code>Product</code> interface so that it can return any product that implements that interface. It isn’t tied to a particular abstract base class, as was the case with Kitty’s original refactor. These creators are abstract and are meant to be overridden in concrete creator subclasses. This is what provides the flexibility we need with our bicycle factory.</li>
<li>Concrete creators provide the actual concrete classes. All your creation logic will be here.</li>
</ol>
<p>Let’s remember the specifics of Kitty and Phoebe’s plan. It calls for two factories – one in Dallas to make road and recumbent bicycles and another in Alpine to make mountain and cruiser bicycles. Kitty heads to her whiteboard and makes her version of the preceding diagram:</p>
<div><div><img alt="Figure 3.9 – Kitty’s whiteboard drawing of her Factory Method pattern design idea. " height="738" src="img/B18605_Figure_4.9.jpg" width="1325"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Kitty’s whiteboard drawing of her Factory Method pattern design idea.</p>
<p>This looks pretty good! Kitty<a id="_idIndexMarker206"/> decides to move a lot of what is in her abstract bicycle class into an interface she calls <code>IBicycle</code>. This doesn’t mean she should throw out the abstract class, but it’s easy to have the abstract class implement the interface. Once she does that, she can pass the interface around, which is more flexible than using the base class.</p>
<p>The abstract bicycle base class won’t change, other than implementing the <code>IBicycle</code> interface. None of the bicycle subclasses change at all.</p>
<p>She does need to add some creator classes. She’ll need to create an abstract <code>BicycleCreator</code> class, which will be subclassed by as many concrete creation classes as she might need.</p>
<p>This fits the design problem because we need to model two actual factories. One is called <code>DallasCreator</code>, which will make road bikes and recumbent bikes, and the other is called <code>AlpineCreator</code>, which will produce mountain bikes and cruisers. </p>
<p>Our design is closed for modification. We never need to mess with the base classes and interface again. However, the design is also open for extension. As the line of products expands in the future, we can continue to add factories and each factory can specialize in any set of products. New bikes can be added by simply creating new subclasses of <code>Bicycle</code>. </p>
<p>There’s nothing left but the typing.</p>
<p>Kitty adds the <code>IBicycle</code> interface to her <code>class</code> library:</p>
<pre class="source-code">public interface IBicycle 
{ 
  public string ModelName { get; set; } 
  public int Year { get; } 
  public string SerialNumber { get; } 
  public BicycleGeometries Geometry { get; set; } 
  public BicyclePaintColors Color { get; set; } 
  public SuspensionTypes Suspension { get; set; } 
  public ManufacturingStatus BuildStatus { get; set; } 
  public void Build(); 
}</pre>
<p>Then, she modifies the <code>Bicycle</code> base class. Defining non-public members is not possible in an interface. C# generally requires properties and methods defined in an interface to be <code>public</code>. Non-public members in an interface don’t make sense. They would be housing implementation details, not something for public consumption, which is the point of an interface. The bottom line is that if we want to require anything on the <code>Bicycle</code> base class, we will need to change the access modifiers to <code>public</code>. We usually <a id="_idIndexMarker207"/>want to avoid changing classes once they are published in production. At this stage, we haven’t done that yet. We can either change the access modifiers or avoid defining those elements in the interface and just have the <code>build</code> function. Kitty decides on the more complete version of the interface she’s already typed:  </p>
<pre class="source-code">public abstract class Bicycle : IBicycle 
{ 
  protected Bicycle() 
  { 
    ModelName = string.Empty; // will be filled in subclass                               // constructor 
    SerialNumber = new Guid().ToString(); 
    Year = DateTime.Now.Year; 
    BuildStatus = ManufacturingStatus.Specified; 
  } 
 
  public string ModelName { get; set; } 
  public int Year { get; } 
  public string SerialNumber { get; } 
  public BicyclePaintColors Color { get; set; } 
  public BicycleGeometries Geometry { get; set; } 
  public SuspensionTypes Suspension { get; set; } 
  public ManufacturingStatus BuildStatus { get; set; }</pre>
<p>Next, we need our creator classes. Kitty starts with the abstract class, which she’ll call <code>BicycleCreator</code>:</p>
<pre class="source-code">using BumbleBikesLibrary;
namespace FactoryMethodExample;
public abstract class BicycleCreator
{
    public abstract IBicycle CreateProduct(string modelName);
}</pre>
<p>Next comes the two concrete <a id="_idIndexMarker208"/>creator classes, beginning with <code>DallasCreator</code>:</p>
<pre class="source-code">using BumbleBikesLibrary;
namespace FactoryMethodExample;
public class DallasCreator : BicycleCreator
{
    public override IBicycle CreateProduct(string modelName)
    {
        return modelName.ToLower() switch
        {
            "hillcrest" =&gt; new RoadBike(),
            "big bend" =&gt; new Recumbent(),
            _ =&gt; throw new Exception("Invalid bicycle model")
        };
    }
}</pre>
<p>This is followed by the <code>AlpineCreator</code> class:</p>
<pre class="source-code">using BumbleBikesLibrary;
namespace FactoryMethodExample;
public class AlpineCreator : BicycleCreator
{
    public override IBicycle CreateProduct(string modelName)
    {
        return modelName.ToLower() switch
        {
            "palo duro canyon ranger" =&gt; new MountainBike(),
            "galveston cruiser" =&gt; new Cruiser(),
            _ =&gt; throw new Exception("Invalid bicycle model")
        };
    }
}</pre>
<p>Kitty needs a quick <a id="_idIndexMarker209"/>test, so she adds this code to <code>Program.cs</code>:</p>
<pre class="source-code">using FactoryMethodExample;
Console.WriteLine("Let's make some bicycles"); 
 
var dallasBicycleFactory = new DallasCreator();
var phoebesBike = dallasBicycleFactory.CreateProduct("HILLCREST"); 
phoebesBike.Build(); 
 
var alpineBicycleFactory = new AlpineCreator(); 
var kittysBike = alpineBicycleFactory.CreateProduct("PALO DURO CANYON RANGER"); 
kittysBike.Build();</pre>
<p>Now is the moment of truth. Kitty hits the run button in the IDE and moves to the edge of her seat as her code compiles:</p>
<div><div><img alt="Figure 3.10 – Booyah! It works! The Factory Method pattern is running in Kitty’s code! " height="638" src="img/B18605_Figure_4.10.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Booyah! It works! The Factory Method pattern is running in Kitty’s code!</p>
<p>Kitty commits and pushes her <a id="_idIndexMarker210"/>code, which you can review in the <code>FactoryMethodExample</code> project within the source code for this chapter. Don’t forget that the <code>IBicycle</code> interface was added to the <code>BumbleBikesLibrary</code> project.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>The Abstract Factory pattern</h1>
<p>After Kitty finishes her initial <a id="_idIndexMarker211"/>design using the factory method, Phoebe checks Kitty’s work on GitHub. Phoebe has managed to finish the tooling that creates the frames and she’s hard at work on some of the other parts that go into making a bicycle.</p>
<p>“<em class="italic">Kitty!,</em>” Phoebe says, “<em class="italic">This code will allow us to make a bicycle object but that’s a little bit too abstract. A bicycle is made of lots of different parts.</em>” After a long discussion, the two decided to concentrate on manufacturing the bicycle frame and the handlebars for each bicycle type. The other parts, such as the wheels, tires, brakes, and gears, can be outsourced for the initial production of the bicycles.</p>
<p>It occurs to Phoebe that these parts can be made in families. The road bike uses dropped handlebars, while mountain bikes use a flat handlebar design. You shouldn’t interchange these parts. Flat handlebars on a road bike create a new class of bicycle called a <em class="italic">gravel bike</em> or <em class="italic">hybrid</em>. We’re not interested in changing our product line-up yet. Drop handlebars on a mountain bike make no sense at all and are dangerous. It makes sense for the physical bicycle factory to mirror the software pattern. The sisters conclude a better fit might be to use the <strong class="bold">Abstract Factory pattern</strong>.</p>
<p>This is a pattern a lot of people get wrong. It is a common misconception that the Abstract Factory pattern simply involves making your factory class abstract. Not so! The Abstract Factory pattern is designed to create objects that are related and to decouple those objects from the client’s dependency on a concrete type.</p>
<p>Our bicycle design consists of four families of bicycles:</p>
<ul>
<li>Road bicycles (the Hillcrest)</li>
<li>Mountain bicycles (The Palo Duro Canyon Ranger)</li>
<li>Recumbent bicycles (The Big Bend)</li>
<li>Cruiser bicycles (The Galveston Cruiser)</li>
</ul>
<p>Each type has a particular type of frame, as well as a different design for handlebars. We can say we will be making four <em class="italic">families</em> of bicycle components. When you encounter a problem that involves families of related objects, you <a id="_idIndexMarker212"/>should automatically think about the abstract factory pattern.</p>
<p>A second benefit of the abstract factory pattern is that it decouples the client’s dependency on any particular concrete object. Let’s look at the following diagram:</p>
<div><div><img alt="Figure 3.12 – The Abstract Factory Pattern. " height="913" src="img/B18605_Figure_4.11.jpg" width="1344"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – The Abstract Factory Pattern.</p>
<p>I have drawn the parts going from right to left, beginning with the client: </p>
<ol>
<li value="1">The client is whatever code consumes the objects created by the Abstract Factory. Here, I’m showing a private reference to an Abstract Factory as a property on the client object.</li>
<li>The client is dependent on the <code>AbstractFactory</code> interface. This interface defines two methods. Normally, I don’t put the return types in the UML, but in this case, it is truly important. The interface is going to refer to a pair of abstract classes. Maybe now you’re starting to see where this is going. The final product created by the Abstract Factory will be a concrete class that inherits from one of these abstract classes.</li>
<li>Two concrete factories are presented for each family of products. Our requirements have four families of products, but this diagram only shows two to keep things simple. You can add as many concrete factories as you need.</li>
<li>Two abstract classes are used to define two types of objects, independent of the family for the concrete object.</li>
<li>The final concrete products inherit from the abstract products. Phoebe and Kitty can model more specifics into their process because they are not just making bicycles – they are making the handlebars too. Each <a id="_idIndexMarker213"/>physical factory should make the frames and handlebars that are needed.</li>
</ol>
<p>The sisters head to the whiteboard and draw out the Abstract Factory pattern design. They will limit their diagramming to road bikes and mountain bikes to keep things simple:</p>
<div><div><img alt="Figure 3.13  – Phoebe and Kitty’s whiteboard design using the Abstract Factory pattern. " height="929" src="img/B18605_Figure_4.12.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13  – Phoebe and Kitty’s whiteboard design using the Abstract Factory pattern.</p>
<p>The client in this program is just the <code>Program.cs</code> file created by your IDE when you created a command-line project.</p>
<p>The diagram says <code>Program.cs</code> and depends on an object created from <code>IBicycleFactory</code>. Note that the arrowheads are different. These are significant in UML. The closed arrowhead on a solid line indicates inheritance. A closed arrowhead on a dashed line indicates a realization of an interface. The open arrowhead on a closed line indicates an association. The client depends on something that follows <code>IBicycleFactory</code>. The <code>Program.cs</code> class has a private field to hold an instance of an object that realizes this interface, which can be either <code>RoadBicycleFactory</code> or <code>MountainBicycleFactory</code>, as per the preceding diagram.</p>
<p>It is worth noting here that Phoebe drew <code>IBicyleFactory</code> as a literal interface. The code-level understanding of an interface may be either a literal interface or an abstract class because either can serve to define the structure an object must take.</p>
<p>We have concrete classes that realize the <code>IBicycleFactory</code> interface called <code>RoadBicycleFactory</code> and <code>MountainBicycleFactory</code>, respectively. Each concrete factory is responsible for creating a family of objects. In our case, the families are <code>Road</code> and <code>Mountain</code>. <code>RoadBicycleFactory</code> can create <code>RoadBicycleFrame</code> and <code>RoadBicycleHandlebars</code> based on the dependency line, but you can see that <code>RoadBicycleFrame</code> and <code>RoadBicycleHandlebars</code> inherit from the <code>BicycleFrame</code> and <code>BicycleHandlebars</code> abstract classes respectively.</p>
<p>When the client requests a bicycle frame and a set of handlebars, it can reference the abstract classes. Owing to Liskov substitution, the client doesn’t need to be strictly coupled to any concrete class. This makes our client <a id="_idIndexMarker214"/>very flexible. As our bicycle family line-up changes, we won’t need to alter the client because the client does not know what the factory is sending back. The client only knows it has methods called <code>CreateBicycleFrame</code> and <code>CreateBicycleHandlebars</code>.</p>
<p>Phoebe makes a branch on the repository. She knows you should always work in a branch and goes to work creating the code. She begins with the <code>IBicycleFactory</code> interface.</p>
<pre class="source-code">using BumbleBikesLibrary.BicycleComponents.BicycleFrame;
using BumbleBikesLibrary.BicycleComponents.Handlebars;
 
namespace BicycleAbstractFactoryExample;
 
public interface IBicycleFactory
{
  public IFrame CreateBicycleFrame();
  public IHandlebars CreateBicycleHandleBars();
}</pre>
<p>Note the first two <code>using</code> statements.  Since we are starting to break the bicycle into components, Kitty and Phoebe decided to refactor those components into a <code>BicycleComponents</code> namespace within <code>BumbleBikesLibrary</code>. The refactor isn’t particularly relevant to patterns – it’s just a refactor to get a little bit more organized. You can find the components in BumbleBikesLibrary in the GitHub repository for this chapter. </p>
<p>The sisters are coding by the book. Everything is typed into an interface for flexibility. We’re adding methods to handle creating frames and handlebars, two related classes specified by the interfaces. Naturally, we could make more. There are more component classes in the <code>BicycleComponents</code> namespace. We’re keeping it to two here to keep things simple. If you’d like to practice, see whether you can add the other components, such as seats, drivetrain, and brakes, to the pattern code.</p>
<p>Next, Kitty and Phoebe need to work in the concrete factories. These classes will only be used in this project, so you’ll find them in the <code>BicycleAbstractFactoryExample</code> project in the book’s sample source on GitHub. Remember, an <em class="italic">abstraction</em> can refer to an interface or an <em class="italic">abstract </em>class. In this case, the <a id="_idIndexMarker215"/>abstract part of the <em class="italic">abstract factory</em> is this interface. Kitty takes on writing <code>MountainBicycleFactory</code> based on the <code>IBicycleFactory</code> interface:</p>
<pre class="source-code">using BumbleBikesLibrary.BicycleComponents.BicycleFrame;
using BumbleBikesLibrary.BicycleComponents.Handlebars;
 
namespace BicycleAbstractFactoryExample;
 
public class MountainBicycleFactory : IBicycleFactory
{
  public IFrame CreateBicycleFrame()
  {
    return new MountainBikeFrame();
  }
 
  public IHandlebars CreateBicycleHandleBars()
  {
    return new MountainBikeHandlebars();
  }
}</pre>
<p>The concrete factory is responsible for creating the specific objects we need relative to the object family we’re creating. In this case, Kitty is making the parts for a mountain bike, so all the parts being returned are specific to that family. More product families can be added without modifying the abstract factory.</p>
<p>Here is what Phoebe wrote for the <code>RoadBicycleFactory</code> class, which also extends <code>IBicycleFactory</code>:</p>
<pre class="source-code">using BumbleBikesLibrary.BicycleComponents.BicycleFrame;
using BumbleBikesLibrary.BicycleComponents.Handlebars;
namespace BicycleAbstractFactoryExample;
public class RoadBicycleFactory : IBicycleFactory
{
  public IFrame CreateBicycleFrame()
  {
    return new RoadBikeFrame();
  }
 
  public IHandlebars CreateBicycleHandleBars()
  {
    return new RoadBikeHandlebars();
  }
}</pre>
<p>We now have an Abstract <a id="_idIndexMarker216"/>Factory pattern in place making two possible components, in two possible product families. Let’s look at the client. Phoebe writes that part:</p>
<pre class="source-code">using BicycleAbstractFactoryExample;
 
Console.WriteLine("Let's make some bicycles!");
 
IBicycleFactory roadBikeFactory = new RoadBicycleFactory();
 
var frame = roadBikeFactory.CreateBicycleFrame();
var handlebars = roadBikeFactory.CreateBicycleHandleBars();
 
Console.WriteLine("We just made a road bike!");
Console.WriteLine(frame.ToString());
Console.WriteLine(handlebars.ToString());</pre>
<p>We made a road bike using <code>RoadBikeFactory</code>! The key here is the use of the interface as the factory type. Coding this way makes it possible to change the factory without relying on concrete factory classes directly. You can see the console output showing the results of the operation. Phoebe continues and writes some code to generate a mountain bike using <code>MountainBikeFactory</code>:</p>
<pre class="source-code">IBicycleFactory mountainBikeFactory = new MountainBicycleFactory();
frame = mountainBikeFactory.CreateBicycleFrame();
handlebars = mountainBikeFactory.CreateBicycleHandleBars();
Console.WriteLine("We just made a mountain bike!");
Console.WriteLine(frame.ToString());
Console.WriteLine(handlebars.ToString());</pre>
<p>The same process could be<a id="_idIndexMarker217"/> repeated for any new bicycle type that Phoebe and Kitty could ever dream of making.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>The Builder pattern</h1>
<p>Phoebe finishes her<a id="_idIndexMarker218"/> implementation of the Abstract Factory and goes back to designing more on the robotics for the bicycle factory. How many times have you thought some job or project was simple, only to find out that once you got into the thick of working on it, things involved more than you realized?</p>
<p>Phoebe and Kitty are new to engineering, design, and software development. Phoebe’s unique understanding of the design problems surrounding building an automated factory solidifies over time. She realizes that building a bicycle is more complicated than she had first realized. The sisters built their prototypes by hand. They were able to use wood for the frames and off-the-shelf parts for everything else. They are now committed to making their own frames and handlebars using a lightweight aluminum alloy.</p>
<p>Phoebe realizes the frame is the hard part. The other components, such as the wheels, brakes, and drivetrain, as well as the handlebars, could easily be built in-house as part of the automated process. </p>
<p>Naturally, this increases the complexity of the machinery and the software that runs it. Phoebe calls Kitty.</p>
<p>“<em class="italic">Hey sis, how is the Abstract Factory pattern treating you?</em>” Kitty asks.</p>
<p>“<em class="italic">It’s fine, but I’ve been thinking,</em>” Phoebe replies.</p>
<p>“<em class="italic">Uh oh. Every time you do that Daddy’s credit card gets a workout. What is your idea?</em>” Kitty asks.</p>
<p>Phoebe told Kitty about her idea to make all the parts from the same aluminum alloy. “<em class="italic">Some of the parts will need to be reinforced, but the result will be a lighter bicycle that costs less to build than we initially thought,</em>” said Phoebe. Kitty loved the idea. The sisters were excited before, but now they are fired up. Phoebe says, “<em class="italic">I’ll get Dad’s credit card and source the aluminum I need for the first few bicycles.</em>” Kitty replies “<em class="italic">Great. While you’re doing that, I’ll incorporate your ideas into the control software. You merged your branch into main, right?</em>”</p>
<p>Kitty pulls the latest code from <em class="italic">GitHub</em> and starts a new branch. She starts thinking hard about how to accomplish coding a process that will build an entire bicycle per any possible specification a customer might have. The sisters have a set of four bicycles with constrained options for the first release. Kitty doesn’t want to lock her thinking and her software design into building just those four bicycles. That would make it a stovepipe system. Kitty heads to the whiteboard. She realizes that she might have to disregard the progress she’s made so far in the Abstract Factory pattern. A different pattern might not simply be a direct evolution of what they’ve done so far. She knows the elemental structures will remain the same. A bicycle will always need a frame, seat, handlebars, wheels, brakes, and a drivetrain.</p>
<p>The new problem entails creating a complex object. The construction will require multiple steps instead of a simple <code>BuildBicycle</code> method that creates the frame and handlebars, as she had in the earlier designs.</p>
<p>Deep in thought, her reverie is broken by a loud buzzing from her phone. It’s sitting on her metal worktable and the vibration, indicating she’s received a text, nearly bounced a small pile of screws and some tools right off the edge of the table:</p>
<div><div><img alt="Figure 3.15 – She checks the screen. There’s a text from her father. " height="118" src="img/B18605_Figure_4.15_NEW.jpg" width="1128"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – She checks the screen. There’s a text from her father.</p>
<p>Uh - oh. Kitty decides<a id="_idIndexMarker219"/> to rip off the proverbial band-aid and calls her father. Maybe her excitement over the latest developments will cushion the blow. “<em class="italic">Daddy will understand,</em>” she says quietly to herself as if she is quietly trying to convince herself out loud.</p>
<p>Kitty and Phoebe’s father was a software engineer. He’d lost his job a few years ago because he was always talking about crazy conspiracy theories on social media. He decided to just retire, and after a falling out with his extended family, Kitty and Phoebe’s parents moved to a small town in Southern Oklahoma, just north of the Texas border where the roads are<a id="_idIndexMarker220"/> unpaved and the internet access is non-existent. This is just the way he likes it. Kitty dials the number.</p>
<p>When he answered, her father’s language was, shall we say, colorful. This wasn’t the first time Phoebe had run up a bill. She had once charged over a thousand dollars in 1 day. Most teenage girls run up a bill traveling or shopping. Phoebe’s bill was from several reputable industrial suppliers, a tool and die shop, and a peanut butter factory. She never came clean on what she was up to, but shortly after that, she got into engineering school and the incident was all but forgotten.</p>
<p>Kitty talks him down from his anger and tells him about what’s going on. “<em class="italic">You should look at </em><strong class="bold">the Builder pattern</strong><em class="italic">,</em>” he says. “<em class="italic">Yeah, I once wrote a book on patterns and I remember this one. It is used to make complex objects using a flexible set of steps. It sounds like that’s what you need. Oh, and y’all are gonna pay me back! I want stock in your company and the first bicycle you two build.</em>”</p>
<p>“<em class="italic">Of course, Daddy,</em>” Kitty said in her sweetest voice, normally reserved for when she wanted ice cream but had already been told, “<em class="italic">No.</em>” She decided not to admonish him for not telling her he had written a book on patterns. Her father had taught the sisters to code when Phoebe was 11 and Kitty was 12. He had published a lot of books and videos over the years. Of course, he had done one on patterns. At that moment, Kitty’s call went to static. It was hard to hear anything. Her father was still speaking to her, but she only caught a few words. Something about alternate timelines and temporal recursion. “<em class="italic">He says the silliest things sometimes. He’s probably been watching old episodes of Doctor Who again,</em>” she thought. The call dropped.</p>
<p>Kitty shrugged and set to researching the Builder pattern. Her father’s book had been out of print for years, but it was a runaway international bestseller, so she was able to find a few of the<a id="_idIndexMarker221"/> diagrams among the many more<a id="_idIndexMarker222"/> recent books that cited his:</p>
<div><div><img alt="Figure 3.16 – The builder pattern consists of a builder interface, a director to control the creation process, and concrete builders based on the builder interface to produce specific products. " height="851" src="img/B18605_Figure_4.13.jpg" width="1160"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – The builder pattern consists of a builder interface, a director to control the creation process, and concrete builders based on the builder interface to produce specific products.</p>
<p>Let’s look at this diagram in more detail:</p>
<ol>
<li value="1">There are two important parts to the Builder pattern. The first is the IB. Remember, this <a id="_idIndexMarker223"/>can be a literal interface or an abstract class. I’ll stick to using a true interface for the sake of flexibility. The <code>Builder</code> interface defines <a id="_idIndexMarker224"/>all the methods that will be in a set of concrete builder classes. The second part that you’ll always find in the Builder pattern is the <code>Director</code> class.</li>
<li>A <code>Director class</code> is <a id="_idIndexMarker225"/>created, which contains logic that defines the creation process in a step-by-step fashion.</li>
<li>A set of concrete<a id="_idIndexMarker226"/> builder classes defines each type of object that can be created.</li>
<li>Different products come out of the concrete builder classes, depending on the logic contained within the director.</li>
</ol>
<p>Armed with this new knowledge, Kitty goes back to her whiteboard:</p>
<div><div><img alt="Figure 3.17 – Kitty’s whiteboard implementation of the builder pattern. " height="1067" src="img/B18605_Figure_4.14.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Kitty’s whiteboard implementation of the builder pattern.</p>
<p>Kitty was excited <a id="_idIndexMarker227"/>about this one. Having gone through a few different patterns, this one felt like it was the best representation of what the sisters are trying to accomplish. You can find this code in the <code>BicycleBuilderExample</code> project within this chapter’s GitHub repository.</p>
<p>Kitty starts by creating an abstraction for what the builders will be producing – that is, the product. She creates an interface called <code>IBicycleProduct</code>: </p>
<pre class="source-code">public interface IBicycleProduct
{
  public IFrame Frame { get; set; }
  public ISuspension Suspension { get; set; }
  public IHandlebars Handlebars { get; set; }
  public IDrivetrain Drivetrain { get; set; }
  public ISeat Seat { get; set; }
  public IBrakes Brakes { get; set; }
}</pre>
<p>The interface contains everything needed to make a complete bicycle. We have something of a design luxury at play here. All the bicycles follow the same interface. We no longer need to think <a id="_idIndexMarker228"/>about a road bike or a mountain bike. A road bike is simply a collection of parts:</p>
<ul>
<li>A road bike frame</li>
<li>A hardtail suspension (that is, no suspension at all)</li>
<li>Road bike handlebars (that is, dropped curved handlebars)</li>
<li>A road bike drive train (that is, a normal length chain and a group set with 3 front and 8 rear cogs for a total of 24 speeds)</li>
<li>Caliper brakes</li>
<li>A standard, cheap, very uncomfortable seat</li>
</ul>
<p>Phoebe and Kitty learned about seats during their internship. Bicycle manufacturers know that seats are a very personal choice and no two riders will pick the same seat if they are given a choice. They all sell bicycles with cheap, uncomfortable seats and offer separate products to upgrade the seat to the rider’s preference. This lowers the build cost for the bicycle and gives their dealers something to upcharge, as well as offering seat installation as a service.</p>
<p>Kitty codes a generic bicycle object for the builder called <code>BicycleProduct</code>:</p>
<pre class="source-code">public class BicycleProduct : IBicycleProduct
{
  public IFrame Frame { get; set; }
  public ISuspension Suspension { get; set; }
  public IHandlebars Handlebars { get; set; }
  public IDrivetrain Drivetrain { get; set; }
  public ISeat Seat { get; set; }
  public IBrakes Brakes { get; set; }
 
  public override string ToString()
  {
    var fullDescription = new StringBuilder("Here's your new bicycle:");
    fullDescription.AppendLine(Frame.ToString());
    fullDescription.AppendLine(Suspension.ToString());
    fullDescription.AppendLine(Handlebars.ToString());
    fullDescription.AppendLine(Drivetrain.ToString());
    fullDescription.AppendLine(Seat.ToString());
    fullDescription.AppendLine(Brakes.ToString());
 
    return fullDescription.ToString();
  }
}</pre>
<p>This class is just an <a id="_idIndexMarker229"/>implementation of<a id="_idIndexMarker230"/> the interface, plus a large <code>ToString()</code>override that we’re using as the meat of our sample code. </p>
<p>Next, Kitty creates the <code>IBicycleBuilder</code> interface, which will define the various builders for the bicycle lines:</p>
<pre class="source-code">namespace BicycleBuilderExample;
 
public interface IBicycleBuilder
{
  public void Reset();
  public void BuildFrame();
  public void BuildHandleBars();
 
  public void BuildSeat();
  public void BuildSuspension();
  public void BuildDriveTrain();
  public void BuildBrakes();
 
  public IBicycleProduct GetProduct();
}</pre>
<p>The interface defines what must be in a <code>builder</code> class. The next piece of the puzzle is the <code>Director</code> class. The classical implementation of the <code>Builder</code> pattern will always have one of these. In our case, we could skip this part because all of our bicycles fit the same interface. A <a id="_idIndexMarker231"/>director can create anything, given a builder. The director’s job is to call the methods in the builder according to any business logic required and to return the product created by the builder. In our case, every product has the same set of properties, and the builders all have the same methods. Just realize that if your builders don’t all follow the same interface, it’s okay to have a lot more logic in your director to figure out what to do with it. The point of the director is to run the build methods in the builder in the right order. Sometimes, that entails a lot more logic than what we have here:</p>
<pre class="source-code">public class Director
{
  public Director(IBicycleBuilder builder)
  {
    Builder = builder;
  }
  private IBicycleBuilder Builder { get; set; }</pre>
<p>Kitty starts with a private field to hold a reference to the builder she’ll be working with. You can pass in anything that <a id="_idIndexMarker232"/>extends the <code>IBicycleBuilder</code> interface. The constructor sets the actual builder object that is passed in. Next, she makes a method that allows us to change the builder without exposing it directly:</p>
<pre class="source-code">  public void ChangeBuilder(IBicycleBuilder builder)
  {
    Builder = builder;
  }</pre>
<p>Lastly, she creates a <code>Make</code> method per her UML diagram. It’s the <code>Make</code> method’s job to run the build steps in the right order. Kitty has this method follow the same process the robots will use. They’d start with a frame and then add parts to it. Nobody would think to start building a<a id="_idIndexMarker233"/> bicycle around the seat or the gears. Here, we can see a logical build process for a bicycle that starts with the bigger and more important parts, followed by smaller parts that attach to the larger ones:</p>
<pre class="source-code">  public IBicycleProduct Make()
  {
    Builder.BuildFrame();
    Builder.BuildHandleBars();
    Builder.BuildSeat();
    Builder.BuildSuspension();
    Builder.BuildDriveTrain();
    Builder.BuildBrakes();
 
    return Builder.GetProduct();
  }
}</pre>
<p>Next, Kitty creates the concrete builders for mountain and road bikes. Naturally, she created the code for the other bicycle types, but here, we’ll keep things short so that you don’t have to sort through so much code to see the pattern. Here’s the <code>RoadBikeBuilder</code> class <a id="_idIndexMarker234"/>based on the <code>IBicycleBuilder</code> class:</p>
<pre class="source-code">public class RoadBikeBuilder : IBicycleBuilder
{
  private BicycleProduct _bicycle;
 
  public RoadBikeBuilder()
  {
    Reset();
  }
 
  public void Reset()
  {
    _bicycle = new BicycleProduct();
  }</pre>
<p>Kitty creates a private field called <code>_bicycle</code> to hold the product to be built by the <code>Director</code> class. We have a public constructor and a <code>Reset()</code> method that sets the <code>_bicycle</code> field to a new bicycle based on the <code>BicycleProduct</code> class:</p>
<pre class="source-code">  public void BuildFrame()
  {
    _bicycle.Frame = new RoadBikeFrame();
  }
  public void BuildHandleBars()
  {
    _bicycle.Handlebars = new RoadBikeHandlebars();
  }
  public void BuildSeat()
  {
    _bicycle.Seat = new GenericSeat();
  }
  public void BuildSuspension()
  {
    _bicycle.Suspension = new HardTailSuspension();
  }
  public void BuildDriveTrain()
  {
    _bicycle.Drivetrain = new RoadDrivetrain();
  }
  public void BuildBrakes()
  {
    _bicycle.Brakes = new CaliperBrakes();
  }
  public IBicycleProduct GetProduct()
  {
    return _bicycle;
  }
}</pre>
<p>The same builders can<a id="_idIndexMarker235"/> be made for mountain, recumbent, and cruiser bikes. They look the same, but naturally, they use different parts as appropriate. The builder steps (methods) understand the parts needed to build, while the director understands the order needed for the steps (methods) to be called.</p>
<p>The client code that’s used to call these builders would look like this:</p>
<pre class="source-code">using BicycleBuilderExample;
 
Console.WriteLine("Let's make some bikes with the builder pattern!");</pre>
<p>Here’s where all the hard work pays off. You can build any bicycle with three lines of code. First, make the builder. Then, make a director, if you don’t have one yet, and pass in the builder you just created. Then, call the <code>Make()</code> method. The result is a perfectly built product:</p>
<pre class="source-code">var roadBikeBuilder = new RoadBikeBuilder();
var director = new Director(roadBikeBuilder);
 
var roadBike = director.Make();
Console.WriteLine(roadBike.ToString());</pre>
<p>Would you rather <a id="_idIndexMarker236"/>have a mountain bike? That’s easy! </p>
<pre class="source-code">var mountainBikeBuilder = new MountainBikeBuilder();
director.ChangeBuilder(mountainBikeBuilder);
 
var mountainBike = director.Make();
Console.WriteLine(mountainBike.ToString());</pre>
<p>We can make recumbents and cruisers just as easily, but in the interest of saving trees, I’ll leave that to your imagination. If you’re like me and have a weak imagination, the sample code for this chapter contains the builder for creating all four types.</p>
<p>Kitty is delighted with the <a id="_idIndexMarker237"/>way things turned out. She has a software architecture that is closed for modification but open for extension. She has leveraged interfaces and abstract classes wisely, so Kitty is ready for the next challenge the world of robotic bicycle manufacturing might have for her.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>The Object Pool pattern</h1>
<p>Back at the factory, Phoebe <a id="_idIndexMarker238"/>has made progress on the robotics. She has developed a mobile robotic arm to handle the welding during the manufacturing process. She was hoping to build 30 of these arms to allow for maximum factory output, but her father’s credit card mysteriously stopped working. This puzzled Phoebe. Could her sister have told on her, leading her father to block the card from further purchases? “<em class="italic">She wouldn’t do that!</em>” Phoebe thought, but as soon as she said it, she knew that’s exactly what had happened. She considered calling her sister out on it but decided to focus on her father’s words:</p>
<p>“<em class="italic">A good engineer is someone who makes the best product possible given constraints of time, materials, people, and budget with a minimum of complaining.</em>”</p>
<p>The last part is the hardest. Most engineers complain, “<em class="italic">If I’d gotten the budget, I’d asked for…</em>” or “<em class="italic">If only I had another year…</em>” It’s an ego thing. Phoebe swallows hers and decides she must figure out how to make do with just the 10 robot arms she was able to build. Her arm design looks a little like this:</p>
<div><div><img alt="Figure 3.18 – Phoebe’s design for a robotic arm to handle the welding on the bicycle frames. " height="758" src="img/B18605_Figure_4.15.jpg" width="942"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Phoebe’s design for a robotic arm to handle the welding on the bicycle frames.</p>
<p>Given that the arms are mobile, Phoebe decides it is possible to have the arms move between welding projects as needed. As the bicycles come through the line, only a few will need welding at any given point in time. Phoebe thought, “<em class="italic">Running with 30 arms would have been nice, but honestly, they’d be dormant most of the time. This will be better. I’m forced to be more efficient.</em>”</p>
<p>The pool of 10 arms sit on a track where they move to any of the assembly lines at a moment’s notice. As a weld is needed, Kitty’s software will move the arm to where it’s required. After the weld is finished, the arm can return to the pool and wait until it’s needed again. If several welders are needed on different projects, one arm will come out of the pool and do its work, then return. So long as we don’t need more than 10 arms at a time, we’re fine. If we do, the eleventh job will have to wait until one of the arms is available. Phoebe is happy with this because creating the arms is expensive, and as she’s discovered, she only needs a few. She can add more arms to the pool as the business expands.</p>
<p>Phoebe has<a id="_idIndexMarker239"/> unwittingly stumbled onto the <strong class="bold">O</strong><strong class="bold">bject Pool pattern</strong>. This pattern is used to create computationally expensive objects, and as such, they tend to slow software performance to a crawl. The most obvious case is working with relational databases. This is something every software developer does at some point, and for many of us, this is a skill we rely on daily.</p>
<p>Instantiating and connecting to a database is computationally costly and time-consuming. Sure, it takes maybe 100 milliseconds, but most relational databases are designed to handle millions of transactions every hour. When your software is under load at scale, 100 milliseconds is an eternity. Every commercially viable database has a driver that handles connection pooling for you. The driver creates a pool of open database connections. Just like with the robot arms, your software takes connections from the pool, runs queries, and then when the connection is closed (which should always be done as quickly as is feasible) the open connection, instead of being truly closed, is returned to the pool and is available for another process in your running program. Check out the following generic diagram:</p>
<div><div><img alt="Figure 3.19 – The object pool pattern creates an object that manages a collection of other objects. The client requests objects from the pool to use them and then releases them when it’s finished. " height="389" src="img/B18605_Figure_4.16.jpg" width="1499"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – The object pool pattern creates an object that manages a collection of other objects. The client requests objects from the pool to use them and then releases them when it’s finished.</p>
<p>There is a private collection called <code>PooledObjects</code> that holds the objects in the pool. The client, after gaining access to the object pool, can request objects from the pool using the <code>GetPooledObject</code> method. Once it is finished, the borrowed object is returned to the pool. If the pool is ever empty, a subsequent request to <code>GetInstance</code> will create a new <a id="_idIndexMarker240"/>object if it can. If it can’t, it is common for an implementation to wait until an object is returned to the pool.</p>
<p>Phoebe decides to add a pool to control access to her limited number of robot arms:</p>
<div><div><img alt="Figure 3.20 – Phoebe’s design for an object pool to control a limited number of available robot arms on her assembly line. " height="608" src="img/B18605_Figure_4.17.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20 – Phoebe’s design for an object pool to control a limited number of available robot arms on her assembly line.</p>
<p>Phoebe writes the code for the diagram:</p>
<pre class="source-code">public class WeldingArmPool
{
  private int _maxSize = 10;</pre>
<p>Phoebe only has 10 robot arms available, but she knows she’ll have more in the future. She makes a private variable here and initializes it to <code>10</code>. Next, she makes a constructor, but normally, a constructor would just handle creating the initialized object. The UML diagram contains an entry for a <code>Reset()</code> method, which does the same thing. She’ll write that in a moment but puts it in place within the constructor. The IDE protests, but she knows it’ll all work out when she has finished:</p>
<pre class="source-code">  public WeldingArmPool()
  {
    Reset();
  }</pre>
<p>The most important part of the object pool is some sort of collection to hold the pooled objects. Phoebe opted for a <code>List</code> of <code>WeldingArm</code> objects. This will be initialized in the <code>Reset()</code>meth<a id="_idIndexMarker241"/>od we mentioned a moment ago, though Phoebe hasn’t created it yet:</p>
<pre class="source-code">  private List&lt;WeldingArm&gt; Pool { get; set; }</pre>
<p>Phoebe wants to be able to change the max size of the pool so that she’s able to build more robot arms. She can increase the pool size or even decrease it if the arms are out of the pool for servicing:</p>
<pre class="source-code">  public int MaxSize
  {
    get =&gt; _maxSize;
    set
    {
      _maxSize = value;
      Reset();
    }
  }</pre>
<p>Phoebe decides it would be nice to have a way to see how many arms are in the pool:</p>
<pre class="source-code">  public int ArmsAvailable =&gt; Pool.Count;</pre>
<p>Finally, the fabled <code>Reset()</code> method we’ve been promised. It looks like code you’d put in a constructor. Phoebe wants a way to reset the pool if she needs to. Since being DRY is a good thing and calling a constructor with anything besides the <code>new</code> keyword seems weird and unnatural, Phoebe flips things around and puts the logic here and then calls it from wherever it’s needed, including the constructor. This drives my IDE crazy. It thinks I have a non-nullable list that is never initialized. That’s not true, but the automation in the IDE isn’t savvy enough to see that. The code itself initializes the list and then fills it with as many <a id="_idIndexMarker242"/>arms as indicated by the <code>MaxSize</code> property:</p>
<pre class="source-code">  public void Reset()
  {
    Pool = new List&lt;WeldingArm&gt;();
    for (var i = 0; i &lt; MaxSize; i++) Pool.Add(new WeldingArm());
  }</pre>
<p>We need a way to get arms from the pool. The following method checks whether there are any arms available, and if there are, it retrieves the first one in the pool. If there aren’t any arms, we throw an error:</p>
<pre class="source-code">public WeldingArm GetArmFromPool()
  {
    if (ArmsAvailable &gt; 0)
    {
      var returnArm = Pool[0];
      Pool.RemoveAt(0);
      return returnArm;
    }
 
    throw new Exception("You are out of arms. Return some to                        the pool and try again.");
  }</pre>
<p>In a real program, you would probably just return a new object and pay the performance penalty. In this case, we are physically constrained. We could implement some concurrent code that watches for an available arm as it becomes free, which directs to a new job, but that’s getting outside the scope of a pattern demonstration. Phoebe needs a way to return her arms to the pool. The arm stores the location of its last weld. Phoebe, to avoid confusion, decides to reset it to zero. This will indicate the arm isn’t working on anything and that it’s in the pool, ready for assignment:</p>
<pre class="source-code">  public void ReturnArmToPool(WeldingArm arm)
  {
    arm.CurrentPosition = 0; //not at any station
    Pool.Add(arm);
  }
}</pre>
<p>Wrapping things <a id="_idIndexMarker243"/>up, Phoebe writes a small test program in <code>Program.cs</code>:</p>
<pre class="source-code">Console.WriteLine("Here's a program that controls some welding                  robots from a pool of 10.");
 
var armPool = new WeldingArmPool
{
  MaxSize = 10
};
 
var arm01 = armPool.GetArmFromPool();
arm01.MoveToStation(1);
if (arm01.DoWeld()) armPool.ReturnArmToPool(arm01);</pre>
<p>As a tool, the Object Pool can seriously speed up most software because usually, you only think to use it when an object takes a lot of time or resources to create. The pool creates the objects in advance, and hopefully, never again.</p>
<p>“<em class="italic">BUT!</em>” Phoebe says aloud to herself, “<em class="italic">this seems like it would work best if you could guarantee only one pool was in use at a time.</em>” She’s right. Concerning the robot arms, it wouldn’t do to have the software simply create more instances of the arm. It stands to reason that eventually, the control software should be multithreaded. You can’t have multiple threads creating their own pool. Instantiating additional pools can’t magically generate more resources in the real world. “<em class="italic">If only there were a way to make sure the object pool is only ever instantiated once per program run,</em>” Phoebe thinks. She’d keep working, but it’s taco night, so she shuts down her laptop and prepares herself<a id="_idIndexMarker244"/> for dinner. You can find Phoebe’s source for the object pool pattern in this chapter’s source code in the <code>ObjectPoolExample</code> project.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>The Singleton pattern</h1>
<p>That night, perhaps<a id="_idIndexMarker245"/> inspired by her Object Pool singularity problem, perhaps by the tacos, or perhaps both, Phoebe had a strange dream. She was a judge dressed in long flowing black robes sitting high on her bench in a courtroom. A trial was in progress. The defendant was one Sing Elton. He was a well-dressed middle-aged gentleman who sat quietly behind a large elaborately carved oaken table next to his counsel.</p>
<p>The courtroom clerk cleared her throat and spoke without inflection into a microphone. “<em class="italic">The defendant, Sing Elton, stands accused of impersonating a beneficial design pattern and is, in fact, an antipattern.</em>”</p>
<p>There was a collective gasp from half of the gallery. It came from the back of the courtroom, which Phoebe only now notices. The room is filled with software developers, all of whom are clad in cargo shorts, Birkenstock sandals, and $300 replicas of vintage <em class="italic">Metallica</em> T-shirts. Phoebe bangs her gavel and shouts, “<em class="italic">ORDER IN THE COURT!</em>” She had seen that in a movie once and had always wanted to do that. With the gallery quietened, the clerk continued without looking up from her computer screen. “<em class="italic">These are very serious charges, Mr. Elton; how do you plead</em>?”</p>
<p>Elton’s counsel, a wiry nervous man in an inexpensive blue suit stood and in a squeaky voice said, “<em class="italic">Not guilty!</em>”</p>
<p>The clerk entered the plea and the trial began. The prosecutor rose for his opening remarks, delivered in a slow Southern drawl reminiscent of a cowboy Western movie. “<em class="italic">Your honor, we intend to show beyond a reasonable doubt that Sing Elton is not a pattern as he represents himself but is an antipattern. He is openly a member of an outlaw coding organization called The Golden Hammers.</em>” The prosecutor sat down, flashing a wry smile with far too many teeth to be human. Do you know why sharks never attack attorneys? Professional courtesy.</p>
<p>The defense called Mr. Elton to the stand and as he questioned him, the defense was able to establish several salient premises aiming to prove Sing Elton was a pattern.</p>
<p>First, it’s a widely used, popular pattern that was published in the <em class="italic">Gang of Four</em> book. This book is considered by many to be unassailable, given it is a seminal work in software design patterns. </p>
<p>“<em class="italic">OBJECTION!,</em>” the<a id="_idIndexMarker246"/> prosecutor yelled as he pounded his fist on the table. “<em class="italic">Your honor, neither popularity nor inclusion in a single book is sufficient evidence to prove this is a pattern.</em>”</p>
<p>Phoebe tapped her gavel lightly on the bench and said, “<em class="italic">Sustained. The defense will continue, but you’re on thin ice, counselor. To be a pattern, Sing Elton must solve a common problem faced by many software developers. This isn’t a popularity contest. You’ll have to do better.</em>”</p>
<p>“<em class="italic">Yes, your honor.</em>” The counselor blushed and was flustered, as though he were hoping the case would be dismissed based on this opening argument. He continued to question Mr. Elton.</p>
<p>“<em class="italic">Can you tell the court exactly what problems you solve?</em>”</p>
<p>“<em class="italic">Sometimes,</em>” began Mr. Elton, “<em class="italic">you need to ensure there is only one copy of a class instantiated at any given time while your program is running. For example, you need access to a database, perhaps via an object pool, or maybe you need access to a file or a configuration service. In these cases, you should only have one instance to handle that. The instance is available to all parts of your program, giving you tight control over the global state. These are problems I can solve, and I do it in one place within a single class rather than them being scattered throughout your code.</em>” </p>
<p>At one point during the trial, the bailiffs brought in a big whiteboard, and Mr. Elton was asked to draw a diagram of himself. It looks as follows:</p>
<div><div><img alt="Figure 3.21 – The Singleton pattern uses a private constructor (not shown) to create an instance of the object (itself) held in a private field. Any calls to new for that class will check to see whether an instance already exists. If it does, the existing object is returned. " height="326" src="img/B18605_Figure_4.18.jpg" width="1377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – The Singleton pattern uses a private constructor (not shown) to create an instance of the object (itself) held in a private field. Any calls to new for that class will check to see whether an instance already exists. If it does, the existing object is returned.</p>
<p>The defense<a id="_idIndexMarker247"/> continued and summarized its arguments this way:</p>
<ul>
<li>Shared resources used by your application, whether they be databases, files, remote services, or robotic arms, are granted and guaranteed a single point of access.</li>
<li>The global state of the program is protected because there is only one point of access.</li>
<li>Singletons are only initialized once, so any performance hit is taken only when the singleton is initialized.</li>
</ul>
<p>The defense attorney concluded with “<em class="italic">The defense rests.</em>”</p>
<p>The nearly silent courtroom suddenly boomed with the echoing sound of a loud slow golf clap. The prosecutor stood up and straightened his tie while hungrily eyeing the jury. You could feel the confidence emanating from him. It was electric. As he spoke, it almost sounded as if his Southern drawl was intentionally more pronounced.</p>
<p>“<em class="italic">Your honor, members of the jury, let me tell you why everything the defense just said is a gigantic load of BAM!</em>” The <em class="italic">BAM</em> came from Judge Phoebe, who saw where this was going and slammed her gavel on the bench. She’d only been a judge for a few minutes, and might never be again, so there was no way she was going to let that kind of language into her courtroom. A girl’s gotta have standards. Having admonished the prosecutor, to the bemusement of the clerk and defense attorney, the prosecutor called several witnesses who offered anecdotal evidence of Sing Elton being an antipattern and a Golden Hammer.</p>
<p>One software engineering manager testified that Sing Elton must be a Golden Hammer because in every job interview he had ever conducted, the applicants always claimed to have studied patterns. When the manager asked for an example of a pattern, the only pattern anyone could name was the singleton pattern. There are quite a few classes out there (you’d think there would be only one example) where the implementation doesn’t need to be a singleton. Everyone uses it because it’s the one pattern they understand and remember.</p>
<p>One software <a id="_idIndexMarker248"/>developer employed by a major software company specializing in defenestration pointed out the most damning arguments:</p>
<ul>
<li>According to the widely accepted tenet, every class should have one responsibility; it should only solve one problem. Ironically, a singleton solves two. It ensures only one single instance of the class exists and it provides a single point of access to some shared or constrained resource.</li>
<li>The Singleton pattern smells a lot like a global variable. Instead of just a variable, it’s a whole class. Globals are universally vilified throughout coder-land because they are considered unsafe. Any method on any given object within your running program can modify the global state, which typically leads to unstable software. This has compounded ramifications for software designed for threading or concurrency.</li>
<li>Singletons are cited as promoting tight coupling between classes. You really can’t get around this since there is no such thing as an abstract singleton. </li>
<li>Implementations of singletons are impossible to unit - test effectively. Besides our earlier stated problem of tight coupling, which is itself anathema to testing, you can’t mock the singleton class. It’s sealed and has no parent class, so using Liskov substitution is impossible as a tool for testing. Unit tests should be isolable and the effects of one test shouldn’t affect other tests. With a singleton in the mix, they probably will.</li>
</ul>
<p>The prosecutor concluded with, “<em class="italic">So you see, your honor, ladies and gentlemen of the jury, Sing Elton is nothing but a low-down dirty fraud. He’s no pattern at all and should be stripped of the title.</em>”</p>
<p>A chorus of harumphs erupted from the gallery. Phoebe smiled because that was her cue to bang the gavel again. She could get used to this. She hit the bench so hard that the resulting sound shook her from her dream. It was like that dream everybody has had at least once – the <a id="_idIndexMarker249"/>one where you dream you’re falling and you wake up just as you hit the ground.</p>
<p>“<em class="italic">I’m never eating tacos again!”</em> Phoebe exclaimed sleepily. She knew she was lying. She had a not-taco breakfast and went back to work. The details of her dream had some valid points, but she felt this was a case where she truly needed a singleton, given the very real constraints at play. </p>
<p>Phoebe models an object pool using a singleton to represent her constrained shared collection of robot arms in the control software:</p>
<div><div><img alt="Figure 3.22 – Phoebe has refactored her object pool into a singleton. Now, only one robot arm pool can exist within her running program at any given time. " height="620" src="img/B18605_Figure_4.19.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – Phoebe has refactored her object pool into a singleton. Now, only one robot arm pool can exist within her running program at any given time.</p>
<p>Phoebe moves to her IDE and starts refactoring the object pool for her robotic arms into a singleton. It’s pretty short work. First, she renames the class and seals it so that it can’t be extended. If the class were able to be extended, it would lose the protection afforded by the pattern. You can start to see why people hate the Singleton pattern. It’s breaking a lot of the rules we’ve come to admire about keeping things open for extension:</p>
<pre class="source-code">public sealed class WeldingArmPoolSingleton
{</pre>
<p>For a Singleton pattern to work, it needs a private static method to hold the singleton instance. In effect, this is a class that has a reference to itself, which is kinda odd. The key is that there can only be one of them, which is why we need the field to be static:</p>
<pre class="source-code">  private <strong class="bold">static</strong> WeldingArmPoolSingleton _instance;
  private int _maxSize = 10;</pre>
<p>The next oddity <a id="_idIndexMarker250"/>you don’t see often is a private constructor. There isn’t a public one. Right about now is when your IDE, if it is equipped with static analysis tools, will start to complain. It will tell you there is no way to instantiate the object. That’s good. That’s what we’re after. Phoebe keeps her <code>Reset()</code> logic in place. All she did was rename the constructor so that it matches the class name and changed the access modifier to private:</p>
<pre class="source-code">  private WeldingArmPoolSingleton()
  {
    Reset();
  }</pre>
<p>The last piece to the Singleton is a static method to gain access to the instance property we started with. Phoebe uses C#’s property syntax to expose it. The first time the client program references the <code>Instance</code> property, the getter checks to see whether an instance already exists. If not, it creates one and sets the backing field’s <code>_instance</code>. If <code>_instance</code> is not <code>null</code>, that means it’s been called once already, so it just returns the instance that is already there. Since it’s a static field, all references point to the same location in memory. Voila – you have a class that is impossible to instantiate twice:</p>
<pre class="source-code">  public static WeldingArmPoolSingleton Instance
  {
    get
    {
      if (_instance == null) _instance = new       WeldingArmPoolSingleton();
      return _instance;
    }
  }</pre>
<p>The rest of Phoebe’s code remains unchanged. You can find the complete refactor in the <code>SingletonExample</code> project <a id="_idIndexMarker251"/>of this chapter’s source code. </p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Summary</h1>
<p>In this chapter, we presented one idiom, the simple factory, and four patterns – the Factory Method pattern, the Abstract Factory pattern, the Object Pool pattern, and the Singleton pattern.</p>
<p>All of these patterns are classified as Creational patterns. This means they govern the creation of objects by encapsulating the creation logic in a structure that is more flexible than using strictly concrete objects with the <code>new</code> keyword.</p>
<p>The Factory Method pattern is what most people think of when they hear “factory pattern.” Using it entails abstracting creation logic into a factory class called a creator. The creator object is defined by an interface to maximize flexibility. We also create an interface for the objects the factory is producing. We call this the product. Each factory creator class is responsible for a subset of all the products in your program.</p>
<p>The Abstract Factory pattern involves creating families of objects that organically go together. Using it entails creating an abstract definition for multiple creator classes. Each creator is responsible for a concrete object.</p>
<p>The Builder pattern is used when you need to make objects using a complex set of steps. Using it is similar to the Abstract Factory pattern, but your builder classes are defined by an interface. Each method in the builder represents a step of the build process. It might be tempting to put a single method in each builder class to call the steps in order. However, this is usually delegated to a <code>Director</code> class. The builder houses the methods to build the object, but the <code>Director</code> class contains the logic behind the order in which those methods are called.</p>
<p>The Object pool Pattern is designed to help you manage objects that are either limited through a real constraint, such as our robot arms, or objects that are computationally expensive to create, such as a database, network service, or file connections. The idea is to pay the creation penalty once by creating a list of those objects that are kept available during your program’s run. When one of these objects is needed, the object is taken from the pool and it’s returned when it’s no longer needed. This allows other processes to use it later, without having to go through normal instantiation.</p>
<p>The Object Pool pattern can be effectively combined with the Singleton pattern. The Singleton pattern is controversial and often considered an antipattern because it cannot be extended, and it promotes tight coupling. Phoebe was able to use it in combination with her robot arm pool to ensure she didn’t accidentally create multiple robot arm pools. She only has 10 physical arms to work with, so duplicating pools could prove to be problematic.</p>
<p>These patterns were presented as progression. The sisters started with the simple factory and worked iteratively to the builder pattern. This wasn’t intentional – that’s just the way it worked out. You shouldn’t take this progression as an indication that the Builder pattern is better than the Factory Method or Abstract Factory. Each of these patterns has its place and often, patterns can be paired together like a fine wine and a good steak.</p>
<p>In the next chapter, we’ll look at structural patterns, which are patterns designed to refine the way you structure your class hierarchies for maximum flexibility and to fully achieve the open-closed principle.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">What is a programming idiom and how are they different from patterns?</li>
<li>What are some popular programming idioms besides <code>Hello, World</code>?</li>
<li>What is the downside to relying on the simple factory idiom?</li>
<li>Is the Singleton a pattern or an antipattern? Why?</li>
<li>What pattern should you use when you are dealing with creating a family of related objects?</li>
<li>What pattern should you use for objects that have a complex build process?</li>
<li>Which class in the Builder pattern is responsible for controlling the execution of the build steps in the proper order?</li>
</ol>
<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Ritchie, D. M., Kernighan, B. W., &amp; Lesk, M. E. (1988). <em class="italic">The C programming language</em>. Englewood Cliffs: Prentice Hall.</li>
<li><a href="https://sites.google.com/site/steveyegge2/singleton-considered-stupid">https://sites.google.com/site/steveyegge2/singleton-considered-stupid</a></li>
</ul>
</div>
</div>
</body></html>