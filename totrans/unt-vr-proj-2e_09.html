<html><head></head><body>
        

                            
                    <h1 class="header-title">Exploring Interactive Spaces</h1>
                
            
            
                
<p class="calibre3">In this chapter, we'll dig a bit more into level design, modeling, rendering, teleporting, and animation; implementing an interactive space you can experience in VR. The scene is a photo gallery, where you design a simple floor plan and use a Blender to extrude it vertically into the walls. Use your own photos.  You can move around the space via teleport or an animated ride through. </p>
<p class="calibre3">In this chapter, we are going to discuss the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Using Blender and Unity to build a simplistic art gallery</li>
<li class="calibre12">Interacting with objects and metadata</li>
<li class="calibre12">Data structures, lists, and scriptable objects</li>
<li class="calibre12">Using teleportation</li>
<li class="calibre12">Creating an animated walkthrough</li>
</ul>
<p>Note that the projects in this chapter are separate and not directly required by the other chapters in this book. If you decide to skip any of it or not save your work, that's OK.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Level design with Blender</h1>
                
            
            
                
<p class="calibre3">For this project, we're going to design an art gallery layout. We just need something simple, a small art gallery exhibit room about 24 by 36 feet. The room is so simple, in fact, it could easily be built within Unity using 3D cube primitives, but we'll take this opportunity to use Blender a little more since we introduced it in <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre10">Chapter 2</a>, <em class="calibre14">Content, Objects, and Scale,</em> keeping it minimal and instructive. If you prefer, you can skip this section and build the floor and walls using Unity cubes. Or, use the <kbd class="calibre13">Gallery.blend</kbd> file provided in the files for this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the walls</h1>
                
            
            
                
<p class="calibre3">To start, draw a simple floor plan on a piece of paper or use a drawing app. Mine is just an open space with two entrances and interior walls to display artwork (<kbd class="calibre13">Gallery-floorplan.jpg</kbd>), which looks like the following image:</p>
<div><img src="img/842f96cf-0055-4ab1-aa1b-3b03570ee2c7.jpg" class="calibre24"/></div>
<p class="calibre3">Now, open Blender. We'll use a common technique of starting with a simple object (plane) and then extruding it to make each of the wall segments. To accomplish this, perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Start with an empty scene, press the A key to select all, and then press the X key to delete.</li>
</ol>
<p class="calibre3"> </p>
<ol start="2" class="calibre15">
<li class="calibre12">Add the floor plan image for reference by pressing the N key to open the properties panel. In the Background Images pane, select Add Image, click on Open and select your image (<kbd class="calibre13">Gallery-floorplan.jpg</kbd>).<br class="title-page-name"/>
Depending on the size and scale of your floor plan reference image, you'll want to choose a scale factor so that it's correct in the Blender world coordinate space. A scale of <kbd class="calibre13">6.25</kbd> works for me. Actually, the most important thing is the relative scale of the features in the diagram, since we can always adjust the scale in Unity in the Import settings, or even in the Scene view itself.</li>
<li class="calibre12">In the Background Images pane, set Size to <kbd class="calibre13">6.25</kbd>. This pane, with the Size field highlighted, is shown in the following screenshot:
<div><img src="img/c1c87579-278c-49b6-a0d3-912a89ca2761.png" class="calibre69"/></div>
</li>
<li class="calibre12">Go to a top-down orthographic view by pressing 7 on the numpad (or navigating to View | Top) and the orthographic view by pressing 5 (or navigating to View | Persp/Ortho). Note that the background image only gets drawn when it's in the top-ortho view.</li>
</ol>
<p class="calibre3"> </p>
<ol start="5" class="calibre15">
<li class="calibre12">Now, we'll make a tiny square in one corner of the room that will be extruded into a wall. Add a pane by pressing <em class="calibre2">Shift</em> + <em class="calibre2">A</em> and select Plane. Then, press <em class="calibre2">Tab</em> to go into the Edit mode. Press <em class="calibre2">Z</em> to toggle from the solid to the wireframe view. Press <em class="calibre2">G</em> to drag it into a corner, click <em class="calibre2">Enter</em> to confirm. Press <em class="calibre2">S</em> to scale it to fit the width of the corner of the wall, as shown in the following screenshot (you may recall that you can use the mouse scroll wheel to zoom and <em class="calibre2">Shift</em> and click on the middle mouse button to pan):</li>
</ol>
<div><img class="calibre24" src="img/cc3a4220-f622-4200-ae61-977a9a0cc372.png"/></div>
<ol start="6" class="calibre15">
<li class="calibre12">Extrude the corner to make the outer walls. Go into the Edge Select mode (via the icon shown in the following screenshot), press <em class="calibre2">A</em> to unselect all, and then right-click on the edge that you want to extrude. Press <em class="calibre2">E</em> to begin extruding, press X or Y to constrain it to that axis, and then press <em class="calibre2">Enter</em> to complete the extrusion where you want it:</li>
</ol>
<div><img src="img/9b66a724-1280-4a89-bafd-c6a401decb8f.png" class="calibre24"/></div>
<ol start="7" class="calibre15">
<li class="calibre12">Repeat the previous steps for each outer wall. Create a small square at the corners so that you can extrude in the perpendicular direction. Leave gaps for the doorways. (You may recall that if you need to modify the existing edges, select it with a right-click, <em class="calibre2">Shift</em> and right-click to select multiple, and move with <em class="calibre2">G</em>. You can also duplicate the selected items.) Also, you can use <em class="calibre2">Shift</em> + <em class="calibre2">D</em> to duplicate in Object mode.</li>
</ol>
<div><img class="image-border8" src="img/cec1e6a0-d972-4b5b-9319-0e7d72626f5d.png"/></div>
<ol start="8" class="calibre15">
<li class="calibre12">To extrude out a face from the middle, we need to add an <em class="calibre2">edge loop</em>. With the mouse over the face, press <em class="calibre2">Ctrl</em> + <em class="calibre2">R</em> and left-click to create the cut. Slide the mouse to position it and left-click again to confirm. Repeat these steps for the width of the wall (making a square cut in the outer wall). Select the edge segment and press E to extrude it into the room:</li>
</ol>
<div><img src="img/e588ee45-e0e7-4579-a900-68e74e209443.png" class="calibre70"/></div>
<ol start="9" class="calibre15">
<li class="calibre12">Once the floor plan is done, we can extrude it along the <em class="calibre2">z</em> axis to create the walls. Change the view from Ortho to Persp by pressing <em class="calibre2">5</em>. Tilt it back using the middle mouse click and move. Select all by pressing <em class="calibre2">A</em>. Extrude with <em class="calibre2">E</em>. Begin to extrude with the mouse, press <em class="calibre2">Z</em> to constrain, and left-click to confirm.</li>
</ol>
<p class="calibre3"> </p>
<ol start="10" class="calibre15">
<li class="calibre12">Save the model to a file named <kbd class="calibre13">gallery.blend</kbd>:</li>
</ol>
<div><img class="calibre24" src="img/5018ca90-7f4a-4287-b178-2b01dde03155.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a ceiling</h1>
                
            
            
                
<p class="calibre3">Now, add a ceiling with two skylights. The ceiling will just be a flat slab build from a single cube. Let's see the steps to add a ceiling:</p>
<ol class="calibre15">
<li class="calibre12">Return to Object mode using <em class="calibre2">Tab</em></li>
<li class="calibre12">Add a cube using <em class="calibre2">Shift</em> + <em class="calibre2">A</em> and select Cube</li>
<li class="calibre12">Position it at the center using <em class="calibre2">G</em> and the mouse (<em class="calibre2">Alt</em> + <em class="calibre2">G</em> resets all its transforms)</li>
<li class="calibre12">Scale it along <em class="calibre2">x</em> and <em class="calibre2">y</em> so that it's size is the same as that of the room using <em class="calibre2">S</em> + <em class="calibre2">X</em> and <em class="calibre2">S</em> + <em class="calibre2">Y</em>)</li>
<li class="calibre12">Switch to Front view using <em class="calibre2">1</em>, scale it so that it is flattened using <em class="calibre2">S</em> + <em class="calibre2">Z</em>, and move it to the top of the walls using <em class="calibre2">G</em> + <em class="calibre2">Z</em>)</li>
</ol>
<p class="calibre3">The skylights will be holes cut out of the ceiling using another cube as a modifier, as show in the following screenshot:</p>
<div><img class="image-border9" src="img/0a12959d-bd0f-4560-836a-076088c634ec.png"/></div>
<ol class="calibre15">
<li class="calibre12">Add a cube, using <em class="calibre2">Shift</em> + <em class="calibre2">A</em>, scale it to size, and move it to the position where you want the skylight.</li>
<li class="calibre12">Position the cube's <em class="calibre2">z</em> axis so that it cuts through the ceiling slab.</li>
<li class="calibre12">Duplicate the cube by pressing <em class="calibre2">Shift</em> + <em class="calibre2">D</em> and move it to the other skylight's position, as shown in the following screenshot:
<div><img class="image-border10" src="img/c86f1c67-6db6-44f4-9bea-a2052b1d7e38.png"/></div>
</li>
<li class="calibre12">Select the ceiling slab with a right-click.</li>
<li class="calibre12">In the far right Properties Editor panel, select the wrench-icon.</li>
</ol>
<ol start="6" class="calibre15">
<li class="calibre12">Then, navigate to Add Modifier | Boolean and for the Operation option, select Difference. For the Object option, select the first cube (<kbd class="calibre13">Cube.001</kbd>):</li>
</ol>
<div><img src="img/da46e8ba-2867-40c2-8caf-c903c0684602.png" class="calibre71"/></div>
<ol start="7" class="calibre15">
<li class="calibre12">Click on Apply to make the operation permanent. Then, delete the cube (select it and press X).</li>
<li class="calibre12">Repeat the process, adding another Boolean modifier for the second cube.</li>
</ol>
<p class="calibre3">If you get stuck, I've included a copy of the finished model with the files for this book. This model is simple enough. You can build it using Unity cubes alone. So much more can, of course, be done to make this a more realistic architectural model, but we're going to move ahead as is:</p>
<div><img class="image-border11" src="img/f8f05377-e64a-451f-aded-bf1001b0f2e5.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Assembling the scene in Unity</h1>
                
            
            
                
<p class="calibre3">Now, we can use the gallery room model in Unity and add a floor and a ceiling with skylights. We will apply textures to the walls and add lighting.</p>
<p class="calibre3">We can start a new Unity scene, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Create a new scene by navigating to File | New Scene. Then, Save Scene As and name it <kbd class="calibre13">Gallery</kbd>.</li>
<li class="calibre12">Drag a copy of your <kbd class="calibre13">MeMyselfEye</kbd> prefab into the Hierarchy.</li>
<li class="calibre12">Delete the default Main Camera from Hierarchy.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">The gallery room level</h1>
                
            
            
                
<p class="calibre3">First, we'll build the art gallery's room structure by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Create a floor plane by navigating to GameObject | 3D Object | Plane. Reset its Transform option and rename it to <kbd class="calibre13">Floor</kbd>.</li>
<li class="calibre12">Create the material for the floor and color it brown. Create | Material, rename it, set its Albedo (<kbd class="calibre13">70</kbd>, <kbd class="calibre13">25</kbd>, <kbd class="calibre13">5</kbd>), and drag the material onto the <kbd class="calibre13">Floor</kbd>.</li>
<li class="calibre12">Our room is sized 24 by 36 feet, which in meters is roughly 7.3 by 11. A Unity plane is 10 units square. So, Scale it to (<kbd class="calibre13">0.73</kbd>, <kbd class="calibre13">2</kbd>, <kbd class="calibre13">1.1</kbd>).</li>
<li class="calibre12">Import the gallery model (for instance, <kbd class="calibre13">Gallery.blend</kbd>). Drag a copy from Project Assets into the Scene. Reset its Transform option.</li>
<li class="calibre12">Manually rotate and/or scale it to fit the floor, as needed (mine fits, but its Rotate Y value needed to be set to <kbd class="calibre13">90</kbd>). It may help if you first change the Scene view to Top Iso.</li>
<li class="calibre12">It is a good idea to add a collider to the walls so that a character doesn't just walk through them. To accomplish this, navigate to Add Component | Physics | Mesh Collider.</li>
</ol>
<p class="calibre3">Note that when imported, as we defined in Blender, the Gallery has separate objects for the walls from the ceiling. A material is created (perhaps named <kbd class="calibre13">unnamed</kbd>) that has a neutral gray Albedo (<kbd class="calibre13">204</kbd>, <kbd class="calibre13">204</kbd>, <kbd class="calibre13">204</kbd>). I like this color for the walls, but I made a new material, all White (<kbd class="calibre13">255</kbd>, <kbd class="calibre13">255</kbd>, <kbd class="calibre13">255</kbd>) for the ceiling.</p>
<p class="calibre3">For a good default skybox, we recommend <strong class="calibre5">Wispy Skybox</strong>, a free package on the Asset Store (<a href="https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737" class="calibre10">https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737</a>). Go ahead and download and import it into your project now if you want to use it.</p>
<p class="calibre3">Next, add some sky and sunlight, as follows:</p>
<ol class="calibre15">
<li class="calibre12">If a Lighting tab is not visible in your Unity Editor, navigate to Window | Lighting | Settings</li>
<li class="calibre12">In the Lighting pane, select the Scene tab</li>
<li class="calibre12">For sunlight, in the Lighting Scene pane, at the Sun input, select the (default) Directional Light from the Hierarchy and drag it onto the Sun Source slot</li>
<li class="calibre12">For the sky, if you imported Wispy Skybox (see previously), then in the Lighting Scene tab, select the doughnut icon on the Skybox Material slot and select the material named <kbd class="calibre13">WispySkyboxMat</kbd></li>
</ol>
<p class="calibre3">Since we selected the <kbd class="calibre13">Directional Light</kbd> for the sun source, you can play with the angle by selecting the Directional Light and modifying its Rotation, with the gizmo in the Scene window or directly in the Inspector, perhaps one that is consistent with the Skybox you chose (such as Rotation <kbd class="calibre13">60</kbd>, <kbd class="calibre13">175</kbd>, <kbd class="calibre13">0</kbd>).</p>
<p>You may consider textured materials for the floor and other surfaces. For example,  search the Asset Store for "Floor Materials." There are many free packages as well as paid ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The artwork rig</h1>
                
            
            
                
<p class="calibre3">Now, we can plan the art exhibition. We'll create a  reusable artwork rig prefab with a picture frame, lighting, positioning, artist info, and a teleportation viewing position. Then, we'll hang the art on the walls of the gallery. Later, we'll apply the actual images. The artwork rig will consist of a picture frame (cube), a photo plane (quad), and a spotlight, all relative to the artwork's placement on the wall. We will create the first one inside our Scene, save it as a <kbd class="calibre13">Prefab</kbd>, and then place duplicates on the walls throughout the gallery. I suggest doing this in the Scene view. Let's get started:</p>
<ol class="calibre15">
<li class="calibre12">Create a container object by navigating to GameObject | Create Empty. Name it<kbd class="calibre13">ArtworkRig</kbd>.</li>
<li class="calibre12">Create the frame. With <kbd class="calibre13">ArtworkRig</kbd> selected, right-click and navigate to GameObject | 3D Object | Cube. Name it <kbd class="calibre13">ArtFrame</kbd>. In Inspector, set its Scale Z to <kbd class="calibre13">0.05</kbd>. Also, let's assume a <kbd class="calibre13">3:4</kbd> aspect ratio. So, set its Scale Y value to <kbd class="calibre13">0.75</kbd>.</li>
<li class="calibre12">Position the rig on a wall (the one facing the entrance at the upper right of the original floor plan). It may help to hide the ceiling child of the <kbd class="calibre13">Gallery</kbd> object (uncheck its Enable checkbox option). Then, change the Scene view to Top and Iso using Scene View Gizmo on the upper right of the Scene panel. Click on the green Y icon for the Top view and the middle square icon for the Iso view.</li>
<li class="calibre12">Select <kbd class="calibre13">ArtworkRig</kbd>, ensure that the Translate gizmo is active (the second icon in the top left icon toolbar), and use the <em class="calibre2">x</em> and <em class="calibre2">z</em> axis arrows to position it. Be sure to select and move the <kbd class="calibre13">ArtworkRig</kbd>. Leave the frame position at (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>). Set the height at eye level (<kbd class="calibre13">Y=1.4</kbd>). The Transform Position value that works for me is (<kbd class="calibre13">2</kbd>, <kbd class="calibre13">1.4</kbd>, <kbd class="calibre13">-1.82</kbd>) and no Rotation at (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>), as shown in the screenshot that follows.</li>
<li class="calibre12">Make the frame black. Navigate to Assets | Create | Material, name it <kbd class="calibre13">FrameMaterial</kbd>, and set its Albedo color to black. Then in Hierarchy, select the Frame option and drag the <kbd class="calibre13">FrameMaterial</kbd> material onto <kbd class="calibre13">ArtFrame</kbd>.</li>
</ol>
<p class="calibre3"> </p>
<ol start="6" class="calibre15">
<li class="calibre12">Make the image placeholder. With <kbd class="calibre13">ArtFrame</kbd> selected in Hierarchy, right-click and navigate to 3D Object | Quad. Name it to <kbd class="calibre13">Image</kbd>. Position it just in front of the frame so that it's visible; set Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-0.8</kbd>) and scale it so that it's slightly smaller than the frame by setting Scale to (<kbd class="calibre13">0.9</kbd>, <kbd class="calibre13">0.9</kbd>, <kbd class="calibre13">1</kbd>).</li>
<li class="calibre12">To better appreciate the current scale and eye level, try inserting a copy of Ethan into the scene:
<div><img src="img/df7623ae-a44b-4cac-b4af-6737c555d1f0.png" class="calibre24"/></div>
</li>
</ol>
<p class="calibre3">Next, we'll add a spotlight to the rig, as follows:</p>
<ol class="calibre15">
<li class="calibre12">First, put the ceiling back in by checking off the Enable checkbox option for the child object of Gallery.</li>
<li class="calibre12">With <kbd class="calibre13">ArtworkRig</kbd> selected in Hierarchy, right-click, navigate to Light | Spotlight, and position it one and half meters away from the wall (Z=<kbd class="calibre13">-1.5</kbd>) and up near the ceiling. The exact height doesn't matter much since we don't actually have a light fixture. We just have a Vector3 location for the source. I set Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">1.5</kbd>, <kbd class="calibre13">-1</kbd>).</li>
</ol>
<p class="calibre3"> </p>
<ol start="3" class="calibre15">
<li class="calibre12">Now, adjust the <kbd class="calibre13">Spotlight</kbd> value so that it appropriately illuminates the artwork. I set Rotation X to <kbd class="calibre13">2</kbd>, and adjust the light parameters to your liking, such as Range to <kbd class="calibre13">5</kbd>, Spot Angle to <kbd class="calibre13">45</kbd>, and Intensity to <kbd class="calibre13">3</kbd>. The results are shown in the following screenshot:
<div><img src="img/71a054e2-240f-41e7-bd6b-169a3bc06f23.png" class="calibre72"/></div>
</li>
<li class="calibre12">Notice the spotlight is passing through the wall, illuminating the floor on the other side. We don't want that. Select the Spotlight and enable shadows via Shadow Type: Soft Shadows. </li>
<li class="calibre12">To preserve the rig as a prefab, select <kbd class="calibre13">ArtworkRig</kbd> in Hierarchy and drag it into your Project Assets Prefabs folder.</li>
</ol>
<p>Getting to know your Lighting settings can be important. If you see holes in your objects or shadows, for example, try sliding the Directional Light's Normal Bias to <kbd class="calibre26">0</kbd> and Bias to a low value like <kbd class="calibre26">0.1</kbd>. For more information on shadows and the bias property, see <a href="https://docs.unity3d.com/Manual/ShadowOverview.html" class="calibre20">https://docs.unity3d.com/Manual/ShadowOverview.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The exhibition plan</h1>
                
            
            
                
<p class="calibre3">The next step is to duplicate <kbd class="calibre13">ArtworkRig</kbd> on each wall where we want to display the images. Position it and rotate as needed. If you follow the plan shown in the following diagram, your exhibition will display ten images, indicated by the stars:</p>
<div><img class="image-border12" src="img/edfc5fd9-cb20-4655-bdc2-494ea912734c.png"/></div>
<p class="calibre3">The following are the steps to duplicate <kbd class="calibre13">ArtworkRig</kbd> on each wall:</p>
<ol class="calibre15">
<li class="calibre12">As before, it may be easier to hide the ceiling and change the Scene View panel to Top and Iso.</li>
<li class="calibre12">On the top left of the Scene View panel, change the Transform Gizmo toggles so that the tool handle is placed at the Pivot point rather than Center.</li>
<li class="calibre12">Create a new Empty game object, Reset its transform, and name it <kbd class="calibre13">Artworks</kbd>.</li>
<li class="calibre12">Move the existing <kbd class="calibre13">ArtworkRig</kbd> so it's a child of <kbd class="calibre13">Artworks</kbd>.</li>
</ol>
<p class="calibre3">For each location, place an artwork in the gallery, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select an existing <kbd class="calibre13">ArtworkRig</kbd> in the Hierarchy</li>
<li class="calibre12">Duplicate <kbd class="calibre13">Artworkrig</kbd> with right-click on Duplicate, or press <em class="calibre2">Ctrl</em> + <em class="calibre2">D</em></li>
<li class="calibre12">Rotate the rig so that it faces the correct direction by setting Rotation Y to <kbd class="calibre13">0</kbd>, <kbd class="calibre13">90</kbd>, <kbd class="calibre13">180</kbd>, or <kbd class="calibre13">-90</kbd></li>
<li class="calibre12">Position the rig on the wall</li>
</ol>
<p class="calibre3">The settings that work for my gallery are provided in the following table (and assume your Artworks transform is reset to the origin):</p>
<table class="calibre73">
<thead class="calibre74">
<tr class="calibre38">
<td class="calibre39"/>
<td class="calibre39">Position X</td>
<td class="calibre39">Position Z</td>
<td class="calibre39">Rotation Y</td>
</tr>
</thead>
<tbody class="calibre37">
<tr class="calibre38">
<td class="calibre39">0</td>
<td class="calibre39">2</td>
<td class="calibre39">-1.8</td>
<td class="calibre39">0</td>
</tr>
<tr class="calibre38">
<td class="calibre39">1</td>
<td class="calibre39">-1.25</td>
<td class="calibre39">-5.28</td>
<td class="calibre39">-180</td>
</tr>
<tr class="calibre38">
<td class="calibre39">2</td>
<td class="calibre39">-3.45</td>
<td class="calibre39">-3.5</td>
<td class="calibre39">-90</td>
</tr>
<tr class="calibre38">
<td class="calibre39">3</td>
<td class="calibre39">-3.45</td>
<td class="calibre39">-0.7</td>
<td class="calibre39">-90</td>
</tr>
<tr class="calibre38">
<td class="calibre39">4</td>
<td class="calibre39">-2</td>
<td class="calibre39">1.6</td>
<td class="calibre39">0</td>
</tr>
<tr class="calibre38">
<td class="calibre39">5</td>
<td class="calibre39">2</td>
<td class="calibre39">-1.7</td>
<td class="calibre39">180</td>
</tr>
<tr class="calibre38">
<td class="calibre39">6</td>
<td class="calibre39">3.5</td>
<td class="calibre39">0</td>
<td class="calibre39">90</td>
</tr>
<tr class="calibre38">
<td class="calibre39">7</td>
<td class="calibre39">3.5</td>
<td class="calibre39">3.5</td>
<td class="calibre39">90</td>
</tr>
<tr class="calibre38">
<td class="calibre39">8</td>
<td class="calibre39">1.25</td>
<td class="calibre39">5.15</td>
<td class="calibre39">0</td>
</tr>
<tr class="calibre38">
<td class="calibre39">9</td>
<td class="calibre39">-2</td>
<td class="calibre39">1.7</td>
<td class="calibre39">180</td>
</tr>
</tbody>
</table>
<p class="calibre3">Note that the objects are listed in the same order that we'll use in the animated ride-through of the scene. Place them, as children of <kbd class="calibre13">Artworks</kbd>, in this order in Hierarchy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding pictures to the gallery</h1>
                
            
            
                
<p class="calibre3">Please find 10 of your favorite photos from your photo library to use and add them to a new Project Assets folder named <kbd class="calibre13">Photos</kbd>. We are going to write a script that, given the list of images, will add them to each of the ArtworkRigs in the scene:</p>
<ol class="calibre15">
<li class="calibre12">To create the photos folder, navigate to Assets | Create | Folder and name it <kbd class="calibre13">Photos</kbd></li>
<li class="calibre12">Import 10 photos by dragging and dropping them from your File Explorer into the <kbd class="calibre13">Photos</kbd> folder that you just created (or navigate to Assets | ImportNew Asset...)</li>
</ol>
<p class="calibre3">Now, we'll write a script to populate Artworks Images:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, select <kbd class="calibre13">Artworks</kbd>. Then, in Inspector, navigate to Add Component | New Script and name it <kbd class="calibre13">PopulateArtFrames</kbd>.</li>
<li class="calibre12">Open the new script for editing.</li>
</ol>
<p class="calibre3">Write the code for <kbd class="calibre13">PopulateArtFrames.cs</kbd>, as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class PopulateArtFrames : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public Texture[] images;<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        int imageIndex = 0;<br class="title-page-name"/>        foreach (Transform artwork in transform)<br class="title-page-name"/>        {<br class="title-page-name"/>            GameObject art = artwork.Find("ArtFrame/Image").gameObject;<br class="title-page-name"/>            Renderer rend = art.GetComponent&lt;Renderer&gt;();<br class="title-page-name"/>            Material material = rend.material;<br class="title-page-name"/>            material.mainTexture = images[imageIndex];<br class="title-page-name"/>            imageIndex++;<br class="title-page-name"/>            if (imageIndex == images.Length)<br class="title-page-name"/>                break;<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">What is going on here? First, we declare a public array of <kbd class="calibre13">Textures</kbd> named <kbd class="calibre13">images</kbd>. You will see, this will appear in Inspector so we can specify what photos to include in the scene. </p>
<p class="calibre3">This script is attached to the Artworks container object, which contains as children the ArtworkRigs. When the app starts, in <kbd class="calibre13">Start()</kbd>, we loop through all <kbd class="calibre13">theArtworkRigs</kbd>, find the Image object. For each image, we get its Renderer component's Material, and assign a new Texture, that being the next image in the list. We use an <kbd class="calibre13">imageIndex</kbd> variable to increment through the list, and stop when we've run out of images or run out of ArtworkRigs:</p>
<p class="packtfigure"><img src="img/d312e822-26ad-413d-848f-ca8e4773e8b3.png" class="calibre75"/></p>
<p class="calibre3">The astute reader may wonder since all the ArtworkRigs use the same Material, and the Default-Material at that, why wouldn't changing the material on any ArtworkRig Image change them all? In fact, Unity takes care of that by cloning the material into a new unique one when you modify its texture (or other attributes) at runtime. So each ArtworkRig's Image gets its own Material with its own Texture, and thus, each picture in our gallery is different.</p>
<p class="calibre3">To finish this up, let's perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Save the script and return to the Unity editor</li>
<li class="calibre12">With <kbd class="calibre13">Artworks</kbd> selected in Hierarchy, unfold the Populate Art Frames script component in Inspector and unfold the Images parameter</li>
<li class="calibre12">Set the Images Size value to <kbd class="calibre13">10</kbd></li>
<li class="calibre12">Find the images you imported in the <kbd class="calibre13">Photos</kbd> folder under Project Assets and drag them, one at a time, into the Images slots as Element 0 through Element 9</li>
</ol>
<p class="calibre3">When you click on Play mode, the artwork in the scene will get populated with the images in the order that you specified:</p>
<p class="packtfigure"><img src="img/9f0c2a10-0ebb-4cd5-be55-5b137716d123.png" class="calibre75"/></p>
<p class="calibre3">To view the scene in VR, we can position the MeMyselfEye in front of the first ArtworkRig:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">MeMyselfEye</kbd> camera rig in Hierarchy</li>
<li class="calibre12">Set its Position to (<kbd class="calibre13">2</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-2.82</kbd>)</li>
</ol>
<p class="calibre3">That's pretty nice!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing art info data </h1>
                
            
            
                
<p class="calibre3">We could end here, but suppose we want to track more data than just the images for each artwork, such as artist, title, description, and so on. First, we'll consider several software design patterns to manage the data, including separate lists, data structures, and scriptable objects. Later, we'll update our ArtworkRig to display the info with each framed artwork.</p>
<p class="calibre3">The first two scenarios are for explanation only. We will actually implement the <kbd class="calibre13">ScriptableObjects</kbd> one last. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using lists</h1>
                
            
            
                
<p class="calibre3">One approach could be to add more lists to the <kbd class="calibre13">PopulateArtFrames</kbd> script for each of the data fields. For example, if the script had the following:</p>
<pre class="calibre18"> public Texture[] images;<br class="title-page-name"/> public string[] titles;<br class="title-page-name"/> public string[] artists;<br class="title-page-name"/> public string[] descriptions;</pre>
<p class="calibre3">The Inspector would show the following (I limited the list to four items for brevity):</p>
<div><img src="img/7b69f475-f8c3-42b8-adf5-4f06ed3e3eb7.png" class="calibre24"/></div>
<p class="calibre3">As you can imagine, this could get very unwieldy. To change Element 3, for example, you'd have to go to all the lists, which is easily prone to mistakes; things could fatally get very out of sync. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using data structures</h1>
                
            
            
                
<p class="calibre3">A better approach could be to write a C# <kbd class="calibre13">struct</kbd> (or <kbd class="calibre13">class</kbd>) as a data structure that contains each of the fields we want and then make the list in <kbd class="calibre13">PopulateArtFrames</kbd> as this type. For example, the script may read as follows:</p>
<pre class="calibre18">[System.Serializable]<br class="title-page-name"/>public struct ArtInfo<br class="title-page-name"/>{<br class="title-page-name"/>    public Texture image;<br class="title-page-name"/>    public string title;<br class="title-page-name"/>    public string artist;<br class="title-page-name"/>    public string description;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class PopulateArtFrames : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public List&lt;ArtInfo&gt; artInfos = new List&lt;ArtInfo&gt;();
ArtInfo</kbd> defining our data fields. Then, in <kbd class="calibre13">PopulateArtFrames</kbd> we declare it as a <kbd class="calibre13">List</kbd> (which must be initialized with the <kbd class="calibre13">new List&lt;ArtInfo&gt;()</kbd> call). In the script, we'd then reference the textures as <kbd class="calibre13">artInfos[i].image</kbd>. Likewise, you'd get its size using <kbd class="calibre13">artInfos.Count</kbd>  rather than <kbd class="calibre13">Length</kbd>. Also, we need to say it's <kbd class="calibre13">System.Serializable</kbd> so the list appears in the editor Inspector, as follows:</pre>
<div><img src="img/98c40591-62a0-470d-a882-63341bd8d4c2.png" class="calibre24"/></div>
<p class="calibre3">Now we have a list of <kbd class="calibre13">ArtInfo</kbd> elements that we can fill in, and the data for each element is grouped together.</p>
<p class="calibre3">Another benefit of this structure is it could be more easily populated from an external data source, such as cloud-based JSON data or a CSV (comma separated values) data file.</p>
<p>If you are interested in loading data from a database there are a number of approaches, outside the scope of this chapter. But briefly, if you do find a source of CSV data, this handy CSV parser (<a href="https://github.com/frozax/fgCSVReader" class="calibre20">https://github.com/frozax/fgCSVReader</a>)  is basic but gets the job done. If you are in need of a JSON parser, from a web-based REST API for example, consider the JSON .NET For Unity package (<a href="https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347" class="calibre20">https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347</a>) or another similar one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using scriptable objects</h1>
                
            
            
                
<p class="calibre3">In the previous examples, the art info data is maintained on a <kbd class="calibre13">GameObject</kbd> in the Scene Hierarchy. As a software design, this is not really where the data belongs. Data objects are not game objects and should be managed separately.</p>
<p class="calibre3">In the Scene hierarchy, we define the level design and game behaviors. ArtworkRigs have spatial coordinates (Transform) and renderers (and other potentially necessary runtime components such as colliders and RigidBodies for physics). But other data, still a project asset, can live outside the scene hierarchy. For this, Unity offers <em class="calibre14">ScriptableObjects</em>. We first introduced ScriptableObjects in <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables</em>, as a way of sharing input data across game objects. We will use them again here:</p>
<ol class="calibre15">
<li class="calibre12">In the Project window, create a new folder under <em class="calibre2">Assets</em> named <kbd class="calibre13">ScriptableObjects</kbd> if not already present</li>
<li class="calibre12">In the new folder, right-click and select Create | C# Script</li>
<li class="calibre12">Name the script <kbd class="calibre13">ArtInfo</kbd></li>
<li class="calibre12">Then, open the <kbd class="calibre13">ArtInfo.cs</kbd> script for editing</li>
</ol>
<p class="calibre3">Create the <kbd class="calibre13">ArtInfo.cs</kbd> script as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>[CreateAssetMenu(menuName = "My Objects/Art Info")]<br class="title-page-name"/>public class ArtInfo : ScriptableObject<br class="title-page-name"/>{<br class="title-page-name"/>    public Texture image;<br class="title-page-name"/>    public string title;<br class="title-page-name"/>    public string artist;<br class="title-page-name"/>    [Multiline]<br class="title-page-name"/>    public string description;<br class="title-page-name"/>}</pre>
<p class="calibre3">Rather than inheriting from <kbd class="calibre13">MonoBehaviour</kbd>, we define the class as a <kbd class="calibre13">ScriptableObject</kbd>. We added a <kbd class="calibre13">Multiline</kbd> attribute for description so the input field in Inspector will be a text area.</p>
<p>If you are importing JSON data into your project and want to generate ScriptableObject classes that match the JSON object properties, take a look at this tool: <a href="https://app.quicktype.io/#r=json2csharp" class="calibre20">https://app.quicktype.io/#r=json2csharp</a>.</p>
<p class="calibre3">At the top, we provide a <kbd class="calibre13">CreateAssetMenu</kbd> attribute, which generates a menu item in the Unity Editor for our object. Since scriptable objects are not added to the scene Hierarchy, we need a way to create them in the project. Using this attribute makes it easy, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Save the script and return to Unity.</li>
<li class="calibre12">In the Project window, select your Photos folder where you imported your image textures. We'll create the Art Info objects in the same folder.</li>
<li class="calibre12">In the Unity editor main menu, navigate to Assets | Create.</li>
<li class="calibre12">You will see a new item My Objects with a submenu with an item Art Info, as directed in the CreateAssetsMenu property attribute in our script. </li>
<li class="calibre12">Choose Art Info to create an instance. By default, it will be created in the same folder as the defining script (this can be changed in the property attribute options).</li>
<li class="calibre12">It maybe be helpful to rename the object similar to your images. For example, if you have PictureA, name it <kbd class="calibre13">PictureA Info</kbd>.</li>
<li class="calibre12">Drag the image texture onto the scriptable object's Image slot.</li>
<li class="calibre12">Add information for the Title, Artist, and Description too.</li>
</ol>
<p class="calibre3">Here is a screenshot of an ArtInfo object with data filled in:</p>
<div><img src="img/6433e606-c9dd-49d9-9849-21be5d159a94.png" class="calibre24"/></div>
<p class="calibre3">Repeat these steps for all your pictures.  When you're done, your art data will be Project assets.</p>
<p class="calibre3">To use the scriptable object assets in the project, we could modify the PopulateArtFrames much like we would have for the <kbd class="calibre13">struct</kbd> version of the code. We'll do a little bit of refactoring, creating a new component on the ArtworkRig to populate itself with an ArtInfo object, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select one of the ArtworkRigs in the Hierarchy</li>
<li class="calibre12">Add Component | New Script, name it <kbd class="calibre13">ArtworkController</kbd></li>
</ol>
<p class="calibre3">Open it for editing and write it as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class ArtworkController : MonoBehaviour {<br class="title-page-name"/>    public GameObject image;<br class="title-page-name"/><br class="title-page-name"/>    public void SetArtInfo(ArtInfo info)<br class="title-page-name"/>    {<br class="title-page-name"/>        Renderer rend = image.GetComponent&lt;Renderer&gt;();<br class="title-page-name"/>        Material material = rend.material;<br class="title-page-name"/>        material.mainTexture = info.image;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Save the script and back in Unity, on the <kbd class="calibre13">ArtworkRig</kbd> where we just added this component:</p>
<ol class="calibre15">
<li class="calibre12">Drag the image child onto the image slot</li>
<li class="calibre12">Press Apply to save the <kbd class="calibre13">ArtworkRig</kbd> prefab</li>
</ol>
<p class="calibre3">Now, update the <kbd class="calibre13">PopulateArtFrames</kbd> to iterate the list of <kbd class="calibre13">ArtInfo</kbd> and send the object to the <kbd class="calibre13">ArtworkRig</kbd>, as follows:</p>
<pre class="calibre18">using System.Collections.Generic;<br class="title-page-name"/>using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class PopulateArtFrames : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public List&lt;ArtInfo&gt; artInfos = new List&lt;ArtInfo&gt;();<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        int index = 0;<br class="title-page-name"/>        foreach (Transform artwork in transform)<br class="title-page-name"/>        {<br class="title-page-name"/>            artwork.GetComponent&lt;ArtworkController&gt;().SetArtInfo(artInfos[index]);<br class="title-page-name"/><br class="title-page-name"/>            index++;<br class="title-page-name"/>            if (index == artInfos.Count || artInfos[index]==null)<br class="title-page-name"/>                break;<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Now, the Inspector interface is much cleaner and workable. The Artworks' Populate Art Frames component maintains a list of Art Info objects, as shown next. We just need to populate the list and use it. The data the list references are maintained separately as <kbd class="calibre13">ScriptableObjects</kbd>:</p>
<div><img src="img/94eb8e15-f62a-4837-9fe8-35e6d34aeb68.png" class="calibre24"/></div>
<p class="calibre3">Press Play. The artwork images should get loaded during Start, just like before although we've greatly improved the underlying implementation and can now extend our app to include more info about each art picture.</p>
<p>Another advantage of using ScriptableObject in situations like this is once you have a distributable app, you can package these assets into an AssetBundle. This would allow, for example, changing out the gallery pictures, along with all the art info, in the live version.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying the art info</h1>
                
            
            
                
<p class="calibre3">Now that we have more information on each art piece, we can incorporate that into our project. We will add a UI canvas to the ArtworkRig. First, we'll include an info plaque with each picture. Then we'll make it interactive. If you'd like a reminder introduction to Unity's canvas and UI elements, please look at <a href="36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml" target="_blank" class="calibre10">Chapter 6</a>, <em class="calibre14">World Space UI</em>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the title plaque</h1>
                
            
            
                
<p class="calibre3">The title plaque will be a small canvas next to each picture, with a title text UI element:</p>
<ol class="calibre15">
<li class="calibre12">Select one of the ArtworkRig objects in Hierarchy.</li>
<li class="calibre12">Add a child canvas, Create UI | Canvas, named InfoPlaque.</li>
<li class="calibre12">Set its Render Mode to World Space.</li>
<li class="calibre12">Initially reset its position Pos to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">Set the canvas Width: <kbd class="calibre13">640</kbd>, Height: <kbd class="calibre13">480</kbd>.</li>
<li class="calibre12">If you recall, the canvas scaled in world space will be 640 meters wide! Set the Scale to <kbd class="calibre13">0.0006.</kbd></li>
<li class="calibre12">Now you can visually adjust the position using the move gizmo, we found this works: Pos (<kbd class="calibre13">0.8</kbd>, <kbd class="calibre13">-0.1</kbd>, <kbd class="calibre13">-0.01</kbd>).</li>
<li class="calibre12">Next, create a child pane, Create UI | Panel.</li>
<li class="calibre12">And a sub-child of the panel, create a child text element, Create UI | Text, rename it Title.</li>
<li class="calibre12">Set some default text, like Title title title title.</li>
<li class="calibre12">For Anchor Presets (the fancy icon in the top-left of the Transform panel), select Stretch / Stretch, click and also Alt-click it. This will let the text fill the panel area.</li>
<li class="calibre12">Font Size: <kbd class="calibre13">80</kbd>.</li>
<li class="calibre12">Alignment: Middle, Center.</li>
<li class="calibre12">Set its Horizontal Overflow: <kbd class="calibre13">Wrap</kbd>, and Vertical Overflow: <kbd class="calibre13">Truncate</kbd>.</li>
</ol>
<p class="calibre3">Now, we can modify <kbd class="calibre13">ArtworkController</kbd> script to add a new <kbd class="calibre13">public Text title</kbd> variable and set its <kbd class="calibre13">text</kbd> property to the <kbd class="calibre13">info.title</kbd>, as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><strong class="calibre1">using UnityEngine.UI;</strong><br class="title-page-name"/><br class="title-page-name"/>public class ArtworkController : MonoBehaviour {<br class="title-page-name"/><br class="title-page-name"/>    public GameObject image;<br class="title-page-name"/><strong class="calibre1">    public Text title;</strong><br class="title-page-name"/><br class="title-page-name"/>    public void SetArtInfo(ArtInfo info)<br class="title-page-name"/>    {<br class="title-page-name"/>        Renderer rend = image.GetComponent&lt;Renderer&gt;();<br class="title-page-name"/>        Material material = rend.material;<br class="title-page-name"/>        material.mainTexture = info.image;<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        title.text = info.title;</strong><br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">That was easy. Save the script, and then:</p>
<ol class="calibre15">
<li class="calibre12">Drag the Title element onto the Text slot</li>
<li class="calibre12">To save the prefab, make sure the <kbd class="calibre13">ArtworkRig</kbd> itself is selected in the Hierarchy, then press Apply</li>
</ol>
<p class="calibre3">Now when you press Play, the picture images and title text will get initialized on <kbd class="calibre13">Start</kbd> for each of the artwork rigs. Here's one of my photos with a title plaque:</p>
<div><img src="img/801eadda-a63e-4509-a2a3-c248557fe71f.png" class="calibre24"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Interactive info details</h1>
                
            
            
                
<p class="calibre3">We have more information on each picture that fits on the plaque, so we'll allow the player to click an input controller button to open the detail infobox. Let's create that canvas first, with text for artist and description:</p>
<ol class="calibre15">
<li class="calibre12">As a shortcut, duplicate the InfoPlaque and name it <kbd class="calibre13">DetailsCanvas</kbd>.</li>
<li class="calibre12">Scale and position it, perhaps out front and a slight angle. The following values work for me: Pos (<kbd class="calibre13">0.7</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-0.2</kbd>), Width Height (<kbd class="calibre13">1200</kbd>, <kbd class="calibre13">900</kbd>), Rotation (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">15</kbd>, <kbd class="calibre13">0</kbd>).</li>
</ol>
<p class="calibre3"> </p>
<ol start="3" class="calibre15">
<li class="calibre12">Rename the Title text element to <kbd class="calibre13">Description</kbd>.</li>
<li class="calibre12">Duplicate Description, rename it <kbd class="calibre13">Artist</kbd>, set to Top Alignment.</li>
<li class="calibre12">Press Apply to save the prefab.</li>
</ol>
<p class="calibre3">The <kbd class="calibre13">ArtworkController</kbd>  can now populate the details fields too:</p>
<pre class="calibre18"> public Text artist;<br class="title-page-name"/> public Text description;<br class="title-page-name"/> public GameObject detailsCanvas;</pre>
<p class="calibre3">And in the <kbd class="calibre13">SetArtInfo</kbd> function:</p>
<pre class="calibre18">     artist.text = info.artist;<br class="title-page-name"/>     description.text = info.description;</pre>
<p class="calibre3">Then, we'll add an <kbd class="calibre13">Update</kbd> handler to check for user input and display (or hide) the details canvas. And ensure the canvas starts out disabled in <kbd class="calibre13">Start</kbd>.</p>
<pre class="calibre18">    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        detailsCanvas.SetActive(false);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (Input.GetButtonDown("Fire1"))<br class="title-page-name"/>        {<br class="title-page-name"/>            detailsCanvas.SetActive(true);<br class="title-page-name"/>        }<br class="title-page-name"/>        if (Input.GetButtonUp("Fire1"))<br class="title-page-name"/>        {<br class="title-page-name"/>            detailsCanvas.SetActive(false);<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<p class="calibre3">For Daydream on Android, you would call <kbd class="calibre13">GvrControllerInput.ClickButtonDown</kbd> and <kbd class="calibre13">ClickButtonUp</kbd>.</p>
<p class="calibre3">Save the script.</p>
<ol class="calibre15">
<li class="calibre12">Drag the Artist and Description elements onto the corresponding slots</li>
<li class="calibre12">Drag the InfoDetails canvas onto the Details Canvas slot</li>
<li class="calibre12">Press Apply on the ArtworkRig to save the prefab changes</li>
</ol>
<p class="calibre3">Now, when you Play and press the Fire1 button on your input controller, the details canvas will show, as follows:</p>
<div><img src="img/039697ed-984c-4227-9332-bfec3c59ad5c.png" class="calibre76"/></div>
<p class="calibre3">If you would like to implement a different button, such as the finger trigger, or are using a device without a Fire1 mapping (Daydream), please refer to <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables,</em> for implementation options and handling input events.</p>
<p class="calibre3">As implemented, all the details canvases will appear when you press the button. If you want to control one canvas at a time, you could add a UI button to the InfoPlaque, for example, and then use click events on that to trigger the canvas visibility, using gaze-based look and click, or laser pointer &amp; click interactions. Reference <a href="36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml" target="_blank" class="calibre10">Chapter 6</a>, <em class="calibre14">World Space UI</em>, for implementation ideas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adjusting for image aspect ratio</h1>
                
            
            
                
<p class="calibre3">You probably noticed that some of your pictures appear squished since our framed image is shown at a fixed size and aspect ratio. What we really would like is for the frame and image to adjust themselves depending on the dimensions of the image.</p>
<p class="calibre3">When Unity imports a texture, it prepares it (by default) for GPU rendering as an object material texture, which includes resizing it to a square power of two (for example, 1024 x 1024, 2048 x 2048, and so on). If you adapt your project to read images at runtime, for example, from the Resources directory, the device's photo stream, or over the web, then you will have access to the image file's metadata header that includes its pixel width and height. In lieu of that, since we're using imported textures, we can change the Advanced import settings for the images we're using:</p>
<ol class="calibre15">
<li class="calibre12">From your Assets Photos folder, select an image texture</li>
<li class="calibre12">In Inspector, under Advanced, change Non Power of 2 to None</li>
<li class="calibre12">Press Apply</li>
</ol>
<p class="calibre3">Repeat this for each image in the project. Note that this also decompresses the image, so what might start out as a 400k <kbd class="calibre13">.jpg</kbd> file becomes a 3 MB, 24-bit image in the project, so be cautious of the width and height of the source images you choose to use.</p>
<p>Not scaling textures to a power of two is really bad for performance. If you have more than a few images, you should avoid this. One approach would be to add the image aspect ratio as another field of the ArtInfo, and manually set the value in the corresponding scripted objects. Then, change ArtworkController to use this value instead of calculating it. </p>
<p class="calibre3">In <kbd class="calibre13">ArtworkController.cs</kbd>, add the following helper function, which returns a normalized scale of a texture. The larger dimension will be 1.0 and the smaller one will be a fraction. For example, an image that is 1024w x 768h will get a scale of (1.0, 0.75). It also maintains the current relative scale of the picture using the Z scale value, since that's not changed by our aspect ratio calculation, but will be changed by the Scale tool!</p>
<p class="calibre3">Modify <kbd class="calibre13">ArtworkController</kbd> first by adding a private function <kbd class="calibre13">TextureToScale</kbd> which normalizes the image scale to 1.0 for the larger of width or height, and sets the other dimension to the aspect ratio, as follows:</p>
<pre class="calibre18">    private Vector3 TextureToScale(Texture texture, float depth)<br class="title-page-name"/>    {<br class="title-page-name"/>        Vector3 scale = Vector3.one;<br class="title-page-name"/>        scale.z = depth;<br class="title-page-name"/>        if (texture.width &gt; texture.height)<br class="title-page-name"/>        {<br class="title-page-name"/>            scale.y = (float)texture.height / (float)texture.width;<br class="title-page-name"/>        } else<br class="title-page-name"/>        {<br class="title-page-name"/>            scale.x = (float)texture.width / (float)texture.height;<br class="title-page-name"/>        }<br class="title-page-name"/>        return scale;<br class="title-page-name"/>    }</pre>
<p class="calibre3">The function also preserves the frame depth in the returned scale vector. Now, we can use this in <kbd class="calibre13">SetArtInfo</kbd> function. Add a new public variable for the <kbd class="calibre13">frame</kbd>:</p>
<pre class="calibre18">public Transform frame;</pre>
<p class="calibre3">And then, add this line to set the frame's scale:</p>
<pre class="calibre18">frame.localScale = TextureToScale(info.image, frame.localScale.z);</pre>
<p class="calibre3">Save the updates script. Then, in Unity:</p>
<ol class="calibre15">
<li class="calibre12">Drag the ArtFrame onto the Frame slot in the component</li>
<li class="calibre12">Press Apply to save the prefab</li>
</ol>
<p class="calibre3">Now when you play, the framed images are scaled with the correct aspect ratio, like the one shown here:</p>
<div><img src="img/7e4c8ce6-432d-473f-9e4b-75afef550bd3.png" class="calibre77"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving around the gallery</h1>
                
            
            
                
<p class="calibre3">We've done so much, and yet have not discussed moving about the gallery level. In <a href="f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml" target="_blank" class="calibre10">Chapter 7</a>, <em class="calibre14">Locomotion and Comfort</em>, we examined various ways of implementing locomotion and teleportation. Let's now consider setting up specific teleportation spawn points that provide an optimal viewing pose for each artwork picture in the gallery. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Teleporting between pictures</h1>
                
            
            
                
<p class="calibre3">I suppose a good viewing position is about one meter back from the picture. We can add a ViewPose object at that location, within the ArtworkRig. We'll place its origin on the floor. Let's add that now:</p>
<ol class="calibre15">
<li class="calibre12">Select a ArtworkRig in Hierarchy</li>
<li class="calibre12">Create a child Empty game object, name it <kbd class="calibre13">ViewPose</kbd></li>
<li class="calibre12">Reset the ViewPose transform</li>
<li class="calibre12">Set its Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">-1.4</kbd>, <kbd class="calibre13">-1.5</kbd>)</li>
</ol>
<p class="calibre3">In <a href="f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml" target="_blank" class="calibre10">Chapter 7</a>, <em class="calibre14">Locomotion and Comfort</em>, we examined various ways of implementing locomotion and teleportation, including our own home-grown scripts as well as higher-level toolkits. Here, we'll use teleportation toolkits for SteamVR and Daydream. For a more general introduction to these toolkits, or alternative solutions, please refer back to that chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Teleporting with SteamVR Interaction System</h1>
                
            
            
                
<p class="calibre3">To use the SteamVR Interaction System, we start with their Player prefab and add the components we want to use:</p>
<ol class="calibre15">
<li class="calibre12">Locate the Player prefab in <kbd class="calibre13">SteamVR/InteractionSystem/Core/Prefabs</kbd></li>
<li class="calibre12">Drag it as a child of <kbd class="calibre13">MeMyselfEye</kbd> in your scene Hierarchy</li>
<li class="calibre12">Delete or disable the <kbd class="calibre13">[CameraRig]</kbd> object</li>
<li class="calibre12">Drag a copy of Teleporting prefab from Project <kbd class="calibre13">Assets/SteamVR/InteractionSystem/Teleport/Prefabs</kbd> as a child of MeMyselfEye (this controller can actually go anywhere in the scene)</li>
<li class="calibre12">Select the Player in Hierarchy, and drag its parent <kbd class="calibre13">MeMyselfEye</kbd> onto its Tracking Origin Transform slot</li>
</ol>
<p class="calibre3"> </p>
<ol start="6" class="calibre15">
<li class="calibre12">Select the ViewPose object in the ArtworkRig </li>
<li class="calibre12">Drag a copy of the TeleportPoint prefab from Project <kbd class="calibre13">Assets/SteamVR/InteractionSystem/Teleport/Prefabs</kbd> into the Hierarchy as a child of ViewPose</li>
<li class="calibre12">Select the ArtworkRig and Apply to save the prefab changes</li>
</ol>
<p class="calibre3">That's it! Press Play. The teleport points do not show until you press the button on your controller, then they glow, a dashed laser arc lets you choose one, and you go there. Here is a screenshot of the Scene view while the teleport points are activated:</p>
<div><img src="img/6726e430-2dbe-454c-9a7c-5c0911c66d96.png" class="calibre78"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Teleporting with Daydream Elements</h1>
                
            
            
                
<p class="calibre3">The Daydream Elements toolkit is more granular so it takes a little more to get this working. By default, the TeleportController lets you teleport to any horizontal surface on the scene (provided it has a collider). To limit it to our teleport stations we'll restrict the search to a specific layer, named <kbd class="calibre13">Teleport</kbd>.</p>
<ol class="calibre15">
<li class="calibre12">In an ArtworkRig in Hierarchy, select its ViewPose object and create a child cylinder (Create | 3D Object | Cylinder) and name it <kbd class="calibre13">TeleportPod</kbd>.</li>
<li class="calibre12">Set its Scale to (<kbd class="calibre13">0.5</kbd>, <kbd class="calibre13">0.5</kbd>, <kbd class="calibre13">0.01</kbd>). You may choose to decorate its material, for example, with transparency.</li>
<li class="calibre12">Put it on Layer <kbd class="calibre13">"Teleport"</kbd> (If there is no layer named Teleport, from the Layers select list choose Add Layer... first).</li>
<li class="calibre12">Select the parent ArtworkRig and Apply to save the prefab changes.</li>
</ol>
<p class="calibre3">Now, we add the Daydream Elements teleport controller:</p>
<ol class="calibre15">
<li class="calibre12">Drag the TeleportController prefab into your Hierarchy as child of Player (for us, <kbd class="calibre13">MeMyselfEye / GVRCameraRig / Player</kbd>)</li>
<li class="calibre12">Reset its Transform, if necessary</li>
<li class="calibre12">Drag the <kbd class="calibre13">MeMyselfEye</kbd> object onto the <kbd class="calibre13">TeleportController</kbd> component's Player transform slot</li>
<li class="calibre12">Drag GvrControllerPointer (or whichever controller game object you're using) onto the Controller transform slot</li>
<li class="calibre12">On the TeleportController's Valid Teleport Layers, select Teleport (so both Default, Teleport are selected)</li>
<li class="calibre12">On Raycast Mask, we want only Teleport, so select Nothing (to deselect all), then select Teleport. The layer settings are shown in the screen capture here:</li>
</ol>
<div><img src="img/8d3fb548-93bd-43ed-bc0f-a196d0221075.png" class="calibre24"/></div>
<p class="calibre3">Press Play. When the controller pointer's arc touches a teleport pod, it will glow highlight. If you click, you will be teleported to that spot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Room-scale considerations</h1>
                
            
            
                
<p class="calibre3">The gallery level layout we have designed works best in seated, standing, or non-positionally tracked VR. Our use of the zig-zag partitions, for example, is not a good idea in room scale VR unless you take care to not allow the player's play space (chaperone boundaries) to cross these walls. This can be done, but you would need to make the overall space larger, perhaps adaptive to the actual play space size, and add conditions to the teleportation feature that we implement later in the chapter, complicating our examples. See <a href="f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml" target="_blank" class="calibre10">Chapter 7</a>, <em class="calibre14">Locomotion and Comfort</em> for more about room-scale considerations.</p>
<p class="calibre3">The following image is a depiction of an initial position for MeMyselfEye for a room scale OpenVR camera rig, showing the guardian boundaries fit neatly within the gallery viewing space for the first ArtworkRig. It may not fit so easily at the other viewing situations, so you'd need to make adjustments to discourage the player from walking through walls (or through Ethan!). Also, whereas this is the default length and width, the player's actual space will vary to their configuration requirements. To fully accommodate these possibilities, it may be necessary to go to a procedurally generated level layout, where the position and scale of the walls are determined at runtime based on the player settings.</p>
<div><img src="img/5187058a-dc58-40e1-acbc-a2e30e316ff0.png" class="calibre79"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating a ride-through</h1>
                
            
            
                
<p class="calibre3">If you can be certain the player will be seated or at least standing in one place, they might enjoy a ride-through guided tour of the gallery.</p>
<p class="calibre3">In conventional games, first-person animation is often used for a cut-scene, that is, a canned fly-through animation as a transition from one level to another. In VR, it's somewhat different. Walkthroughs can really be the VR experience itself. Head tracking is still active. So, it's not simply a prerecorded video. You can look around and experience it, and it is more like an amusement park ride. This is often called an on-the-rails VR experience.</p>
<p>Be cautious using ride-through animations in your VR apps. It can cause motion sickness. If you do, give your players as much control as possible. For example, we're animating the <kbd class="calibre26">MeMyselfEye</kbd> rig, allowing users to continue to look around. Placing the user in a cockpit or vehicle with stationary surfaces in the foreground can also reduce the tendency for sickness. On the other hand, if you're a thrill seeker, techniques similar to those here can be used for making roller-coaster rides on a track that moves in three dimensions!</p>
<p class="calibre3">In this topic, we are scripting the animations ourselves. In a later chapter, we will dive more deeply into other Unity animation and cinematic tools. We create a <kbd class="calibre13">RidethroughController</kbd> that animates the first-person character (<kbd class="calibre13">MeMyselfEye</kbd>) Transform position, and rotation over time. It works by defining the key-frame transforms, using the Unity <kbd class="calibre13">AnimationCurve</kbd> class (<a href="https://docs.unity3d.com/ScriptReference/AnimationCurve.html" class="calibre10">https://docs.unity3d.com/ScriptReference/AnimationCurve.html</a>). As the name suggests, for key-frame animation, we define the player's location at specific key times in the ride. The in-between frames are calculated automatically. </p>
<ol class="calibre15">
<li class="calibre12">At the root of Hierarchy, create a new Empty game object and name it <kbd class="calibre13">RidethroughController</kbd></li>
<li class="calibre12">Add a new C# script component and name it <kbd class="calibre13">RidethroughController</kbd></li>
<li class="calibre12">Open the script for editing </li>
</ol>
<p class="calibre3">First, we'll define some variables we will need:</p>
<pre class="calibre18"> public Transform playerRoot;<br class="title-page-name"/> public GameObject artWorks;<br class="title-page-name"/> public float startDelay = 3f;<br class="title-page-name"/> public float transitionTime = 5f;<br class="title-page-name"/><br class="title-page-name"/> private AnimationCurve xCurve, zCurve, rCurve;</pre>
<p class="calibre3"><kbd class="calibre13">playerRoot</kbd> is the player transform we will animate (<kbd class="calibre13">MeMyselfEye</kbd>). <kbd class="calibre13">artWorks</kbd> is the container of the ArtworkRigs. We've included an option to specify an initial delay and the transition time between pictures. The setup function will generate three curves, for position (<em class="calibre14">x </em>and <em class="calibre14">z</em>) and rotation (about the <em class="calibre14">y </em>axis).  </p>
<p class="calibre3">Next, we write a <kbd class="calibre13">SetupCurves</kbd> function that generates the animation curves, using each of ArtworkRig's ViewPose as nodes in the curve. We do this concurrently for the <em class="calibre14">x</em>, z, and rotation curves as follows:</p>
<pre class="calibre18">    private void SetupCurves()<br class="title-page-name"/>    {<br class="title-page-name"/>        int count = artWorks.transform.childCount + 1;<br class="title-page-name"/>        Keyframe[] xKeys = new Keyframe[count];<br class="title-page-name"/>        Keyframe[] zKeys = new Keyframe[count];<br class="title-page-name"/>        Keyframe[] rKeys = new Keyframe[count];<br class="title-page-name"/><br class="title-page-name"/>        int i = 0;<br class="title-page-name"/>        float time = startDelay;<br class="title-page-name"/>        xKeys[0] = new Keyframe(time, playerRoot.position.x);<br class="title-page-name"/>        zKeys[0] = new Keyframe(time, playerRoot.position.z);<br class="title-page-name"/>        rKeys[0] = new Keyframe(time, playerRoot.rotation.y);<br class="title-page-name"/><br class="title-page-name"/>        foreach (Transform artwork in artWorks.transform)<br class="title-page-name"/>        {<br class="title-page-name"/>            i++;<br class="title-page-name"/>            time += transitionTime;<br class="title-page-name"/>            Transform pose = artwork.Find("ViewPose");<br class="title-page-name"/>            xKeys[i] = new Keyframe(time, pose.position.x);<br class="title-page-name"/>            zKeys[i] = new Keyframe(time, pose.position.z);<br class="title-page-name"/>            rKeys[i] = new Keyframe(time, pose.rotation.y);<br class="title-page-name"/>        }<br class="title-page-name"/>        xCurve = new AnimationCurve(xKeys);<br class="title-page-name"/>        zCurve = new AnimationCurve(zKeys);<br class="title-page-name"/>        rCurve = new AnimationCurve(rKeys);<br class="title-page-name"/>    }</pre>
<p class="calibre3">We will define the <kbd class="calibre13">RidethroughController</kbd> to start animating when the game object is enabled:</p>
<pre class="calibre18">    void OnEnable()<br class="title-page-name"/>    {<br class="title-page-name"/>        SetupCurves();<br class="title-page-name"/>    }</pre>
<p class="calibre3">On each Update, we evaluate the X and Z curves to set the player's current position. And, we evaluate the rotation curve to set the player's current rotation. We use the native <kbd class="calibre13">Quaternion</kbd> representation of rotations since we're interpolating between two angles we do not want use Euler coordinates:</p>
<pre class="calibre18">    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        playerRoot.position = new Vector3(<br class="title-page-name"/>                xCurve.Evaluate(Time.time), <br class="title-page-name"/>                playerRoot.position.y, <br class="title-page-name"/>                zCurve.Evaluate(Time.time));<br class="title-page-name"/><br class="title-page-name"/>        Quaternion rot = playerRoot.rotation;<br class="title-page-name"/>        rot.y = rCurve.Evaluate(Time.time);<br class="title-page-name"/>        playerRoot.rotation = rot;<br class="title-page-name"/><br class="title-page-name"/>        // done?<br class="title-page-name"/>        if (Time.time &gt;= xCurve[xCurve.length - 1].time)<br class="title-page-name"/>            gameObject.SetActive(false);<br class="title-page-name"/>    }</pre>
<p class="calibre3">Lastly, we check whether we've completed the animation by comparing the current time with the time of the last node in the curve. If so, we disable the game object.</p>
<p>In this script, I used the <kbd class="calibre26">transform.rotation</kbd> Quaternion y value directly. It's usually not recommended to manipulate Quaternion's value directly, but since we're consistently changing only a single axis, it is safe. For more information on Quaternion versus Euler angles, see <a href="https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html" class="calibre20">https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html</a>.</p>
<p class="calibre3">As written, if/when the RidethroughController game object is enabled, the animation will play. You can save your scene with it enabled, and it will play when the app begins. We'll leave it up to you to modify it to be trigged by a player's option such as a <em class="calibre14">Start Ride</em> button within the app!</p>
<p class="calibre3">Save the script and then perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">From Hierarchy, drag <kbd class="calibre13">MeMyselfEye</kbd> onto the Player Root slot</li>
<li class="calibre12">Drag the <kbd class="calibre13">Artworks</kbd> (which contains all <kbd class="calibre13">ArtworkRigs</kbd>) onto the Artworks slot</li>
</ol>
<p class="calibre3">When you Play the scene, you get a nice easy ride through the art gallery, with a slight pause to view each photo. That's real nice! Hopefully, you picked images that can be shown by you to all your friends and family!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="calibre3">In this chapter, we built an art gallery scene from scratch, starting with a 2D plan drawing and going into Blender to construct a 3D architectural structure. We imported the model into Unity and added some environmental lighting. Then, we built an artwork rig consisting of an image, a picture frame, and a spotlight, and placed instances of the rig on various walls throughout the gallery. Next, we imported a bunch of personal photos and wrote a script that populates the art frames at runtime. Adding more detailed data about each artwork, we explored several ways of managing lists of non-graphical data. Finally, we added the ability to move around within the art gallery level, via teleportation and an automated first-person walkthrough of the scene.</p>
<p class="calibre3">In the next chapter, we will take a look at a different kind of VR experience using pre-recorded 360-degree media. You will build and learn about photospheres, equirectangular projections, and infographics.</p>


            

            
        
    </body></html>