- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Testing Your Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的代码
- en: '**Testing code** is an overloaded term when it comes to development. It can
    refer to several concepts, such as load testing, unit tests, or integration testing,
    just to name a few. All testing concepts are important for developers to understand
    regarding the **Software Development Life Cycle** (**SDLC**). Each has its purpose
    and is equally important to provide stability and confidence, and even provide
    documentation.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试代码**在开发中是一个多义词。它可以指代多个概念，例如负载测试、单元测试或集成测试，仅举几例。所有测试概念对于开发者理解**软件开发生命周期**（**SDLC**）都至关重要。每个概念都有其目的，并且对于提供稳定性和信心同样重要，甚至可以提供文档。'
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要主题：
- en: Understanding testing concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试概念
- en: Best approaches for testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的最佳方法
- en: Testing Entity Framework Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Entity Framework Core
- en: In the first section, we’ll cover the basic concepts of testing, including unit,
    integration, regression, load, system, and UI tests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将介绍测试的基本概念，包括单元测试、集成测试、回归测试、负载测试、系统测试和UI测试。
- en: Next, we’ll review some best approaches when writing solid tests for software,
    including why tests are necessary, how many unit tests are required, using the
    **Arrange, Act, Assert** (**AAA**) technique when writing unit tests, why unit
    test scaffolding should be avoided, why to avoid large unit tests, how and why
    to avoid static methods, and, finally, how to use tests for documentation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾编写稳健测试软件的一些最佳方法，包括为什么测试是必要的，需要多少单元测试，在编写单元测试时使用**安排（Arrange）、执行（Act）、断言（Assert）**（**AAA**）技术，为什么应该避免单元测试脚手架，为什么应该避免大型单元测试，如何以及为什么应该避免静态方法，以及最后如何使用测试进行文档化。
- en: Finally, we’ll apply our knowledge of this chapter by creating a full integration
    test using Entity Framework Core.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过创建一个完整的集成测试来应用本章的知识，使用Entity Framework Core。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We recommend using a favorite editor to view this book’s GitHub repository.
    Our recommendations include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用您喜欢的编辑器查看本书的GitHub仓库。我们的建议包括以下内容：
- en: Visual Studio (preferably 2022, though any version is fine)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio（最好是2022版，尽管任何版本都可以）
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: JetBrains Rider
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Rider
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work with the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的编辑器是Visual Studio 2022 Enterprise，但任何版本（社区版或专业版）都可以与代码一起使用。
- en: The code for this chapter is located in Packt Publishing’s GitHub repository,
    which is located in the `Chapter07` folder, at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于Packt Publishing的GitHub仓库中，位于`Chapter07`文件夹，网址为[https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices)。
- en: Understand testing concepts
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试概念
- en: Unit tests are important to developers because they provide stability to software,
    confidence in their code, and the added benefit of documenting complex code. Unit
    tests provide numerous benefits, as we’ll see in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对于开发者来说很重要，因为它们为软件提供稳定性，对其代码有信心，并且提供了记录复杂代码的额外好处。在本章中，我们将看到单元测试提供了许多好处。
- en: In this section, we’ll review the concepts of testing and why each one is important
    to the stability and confidence in building a website.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾测试的概念以及为什么每个概念对于构建网站时的稳定性和信心都至关重要。
- en: Unit tests
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: The smallest test we can write to confirm the code functions as expected is
    a unit test. Unit tests are usually created to test small(-ish) methods, as well
    as to test multiple parameters sent into those methods and expect a certain result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能编写的最小测试来确认代码按预期工作的是单元测试。单元测试通常用于测试小（或较小）的方法，以及测试发送到这些方法的多参数并期望得到特定结果。
- en: Identifying the types of unit tests to write is a simple process of finding
    conditions in a method and writing the relevant test for the behavior.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要编写的单元测试类型是一个简单的过程，即找到方法中的条件并编写相关的测试以实现该行为。
- en: 'The following scenarios could justify unit tests throughout a method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景可以证明在方法中编写单元测试的合理性：
- en: Successful flow of a method (that is, the happy path)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的成功流程（即，成功的路径）
- en: Failure of a method’s behavior (that is, the unhappy path)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法行为的失败（即，不愉快的路径）
- en: Any branching or condition (if..then, switch, inline if, and so on)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何分支或条件（例如if..then、switch、内联if等）
- en: Different parameters passed into the method
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法中传递的不同参数
- en: Exception handling
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: If we have a large system, the number of unit tests is expected to be in the
    hundreds since these small, granular methods comprise most of the system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个大型系统，单元测试的数量预计会有数百个，因为这些小而细粒度的方法构成了系统的大部分。
- en: 'The following example shows an extension method formatting a date/time object
    for display purposes. Since it’s self-contained, we can simply create a date/time
    object and test it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个扩展方法，用于格式化日期/时间对象以供显示。由于它是自包含的，我们可以简单地创建一个日期/时间对象并对其进行测试：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code creates a new date with a time. The unit test is formatted using the
    AAA technique (which we’ll cover in a bit) and returns a string to be displayed
    in our HTML.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个新的日期和时间。单元测试使用 AAA 技术进行格式化（我们将在稍后介绍），并返回一个要在我们的 HTML 中显示的字符串。
- en: Once unit tests are in place, the next step is to provide integration tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了单元测试，下一步就是提供集成测试。
- en: Integration tests
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: The next level of testing is integration tests, which require additional functionality
    as to how the system is tested. Integration tests involve grouping modules and
    the ability to test those components as a group, which contrasts with unit tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的下一级别是集成测试，这需要额外的系统测试功能。集成测试涉及将模块分组并能够作为一组测试这些组件，这与单元测试形成对比。
- en: In my experience, the primary difference between integration and unit tests
    is external resources. If a unit test accesses an external resource (such as a
    disk drive, database, network call, or API), it can be considered an integration
    test.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，集成测试和单元测试之间的主要区别是外部资源。如果一个单元测试访问外部资源（例如磁盘驱动器、数据库、网络调用或API），它可以被认为是集成测试。
- en: 'The following example shows a simple integration test where we’re connecting
    to a local test database to confirm the connection of the database and returning
    a valid `IndexModel` object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个简单的集成测试，其中我们连接到本地测试数据库以确认数据库的连接并返回一个有效的 `IndexModel` 对象：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In `DbContextOptionsBuilder`, we created a connection to our local database,
    created a valid `AttractionService` while passing in our valid `ThemeParkDbContext`,
    and confirmed we have the right type of model.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DbContextOptionsBuilder` 中，我们连接到我们的本地数据库，创建了一个有效的 `AttractionService`，同时传递了我们的有效
    `ThemeParkDbContext`，并确认我们拥有正确的模型类型。
- en: In the end, there are different ways to conduct integration tests, such as creating
    a mocked-up database or API, duplicating an environment, or even creating a new
    server for our tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有不同方式进行集成测试，例如创建模拟的数据库或API、复制环境，甚至为我们的测试创建新的服务器。
- en: Regression tests
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归测试
- en: Regression tests are the functional and nonfunctional tests we’ve performed
    in the past. By nature, these are the past successful tests we ran against the
    system. Regression tests are types of tests that are conducted to confirm new
    features don’t break existing features. These include the unit tests and integration
    tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试是我们过去执行的功能性和非功能性测试。根据其本质，这些是我们对系统运行过的成功测试。回归测试是进行以确认新功能不会破坏现有功能的测试类型。这包括单元测试和集成测试。
- en: Load testing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载测试
- en: Once you have the tests (unit and integration) running in the CI/CD pipeline
    (see [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031)) and are expecting a large
    number of users to hit the site, it is advantageous to create load test(s) for
    the site.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 CI/CD 流程中运行了测试（单元和集成测试）（见[*第2章*](B19493_02.xhtml#_idTextAnchor031)）并且预期会有大量用户访问网站，为该网站创建负载测试（或多个负载测试）是有利的。
- en: When load testing a website, subject it to stress levels beyond what a single
    developer experiences when running the site standalone. Load testing simulates
    a large number of users hitting the website concurrently and reports on whether
    the site can handle a large influx of users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当对网站进行负载测试时，将其置于单个开发者独立运行网站时体验到的压力水平之上。负载测试模拟了大量用户同时访问网站，并报告网站是否能够处理大量用户涌入。
- en: The results of a load test may require several team members to help with the
    performance of the website. Not only would developers be involved, but **database
    administrators** (**DBAs**), system administrators, and even architects would
    be involved with fixing the performance of the site.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试的结果可能需要多个团队成员帮助提高网站的性能。不仅开发者会参与，还包括**数据库管理员**（**DBAs**）、系统管理员，甚至架构师都会参与修复网站的性能问题。
- en: A continuous increase in performance should be the goal of the website and creating
    load tests to measure performance is key to that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的性能持续提升应该是目标，创建负载测试来衡量性能是实现这一目标的关键。
- en: System testing (end-to-end or E2E)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试（端到端或E2E）
- en: System testing is based on certain scenarios and is a team effort. Users of
    the system test new features introduced into the system while other team members
    conduct regression system testing to confirm new features don’t break existing
    features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试基于某些场景，是团队协作的结果。系统用户测试系统中新引入的功能，而其他团队成员则进行回归系统测试，以确认新功能不会破坏现有功能。
- en: Members of the team create scenarios for users. These users are then asked to
    walk through each scenario and provide feedback on whether it works or not.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 团队成员为用户创建场景。然后要求这些用户逐一走过每个场景，并提供关于其是否有效的工作反馈。
- en: 'One example scenario could be broken down into several categories, as shown
    here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例场景可以分解为几个类别，如下所示：
- en: 'Shopping cart:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车：
- en: Log in to the website
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录网站
- en: Place an item into the shopping cart
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将商品放入购物车
- en: Click on checkout
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击结账
- en: Receive a confirmation page with an order number
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收到带有订单号的确认页面
- en: If the scenario succeeds, the top scenario (“shopping cart”) will contain a
    green checkmark, meaning all steps passed with no issues. If one of the steps
    failed, a red “X” with a reason underneath it would appear and be placed into
    the backlog for developers to examine later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景成功，顶级场景（“购物车”）将包含一个绿色的勾选标记，表示所有步骤都通过且没有问题。如果某个步骤失败，则会出现一个带有原因的红色“X”，并将其放入待办事项中供开发人员稍后检查。
- en: These types of tests require multiple users to go through the site and find
    issues with certain scenarios. There are times when manually testing a site is
    necessary, but if there’s time available, it may make sense to automate these
    scenarios using a **user interface** (**UI**) testing approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的测试需要多个用户通过网站并找出特定场景中的问题。有时手动测试网站是必要的，但如果有时间，可能更有意义的是使用**用户界面**（**UI**）测试方法来自动化这些场景。
- en: UI testing
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI测试
- en: UI testing is visually conducted through a software tool such as Selenium or
    Cypress and automates an end user clicking around or a customer navigating the
    website based on a given scenario. This requires a tester to understand how the
    UI testing software works; they should know how to access elements on a page,
    know how to place values into those elements, and know how to activate events
    such as click and blur to simulate an end user clicking a button.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试通过如Selenium或Cypress等软件工具进行视觉操作，并自动化最终用户在给定场景下的点击或客户在网站上的导航。这要求测试人员了解UI测试软件的工作原理；他们应该知道如何访问页面上的元素，知道如何将这些值放入这些元素中，以及知道如何激活事件，如点击和模糊，以模拟最终用户点击按钮。
- en: These types of tests are usually done after work hours through a CI/CD pipeline
    but can be run during work hours on a dedicated server (that is, a QA server)
    to identify issues early.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的测试通常在下班后通过CI/CD管道进行，但也可以在工作时间内在专用服务器（即QA服务器）上运行，以尽早识别问题。
- en: In this section, we reviewed various types of testing, including unit tests,
    integration tests, regression tests, load tests, system tests, and UI testing,
    and how each one is important and leverages the other.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了各种类型的测试，包括单元测试、集成测试、回归测试、负载测试、系统测试和UI测试，以及每种测试的重要性及其如何利用其他测试。
- en: In the next section, we’ll look at what developers are accustomed to when it
    comes to unit tests, including why we write unit tests, debunking the 100% test
    coverage myth, how using AAA is a great approach for unit tests, why we should
    write a unit test library, creating large unit tests, why unnecessary mocks should
    be avoided, and why unit tests have the added benefit of documentation. We’ll
    also learn how to identify slow integration tests, when to write a unit test,
    and how to avoid testing .NET code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨开发人员对单元测试的习惯，包括为什么编写单元测试，驳斥100%测试覆盖率神话，使用AAA是单元测试的绝佳方法，为什么我们应该编写单元测试库，创建大型单元测试，为什么应该避免不必要的模拟，以及为什么单元测试具有额外的文档优势。我们还将学习如何识别缓慢的集成测试，何时编写单元测试，以及如何避免测试.NET代码。
- en: Best approaches for testing
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的最佳方法
- en: Every company has its way of testing software. Whether it’s manually or automated,
    it’s a requirement for developers. Developers are becoming more than just people
    who type code. We’re required to design, write, test, debug, document, build,
    and deploy software.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每家公司都有其测试软件的方式。无论是手动还是自动化，对开发人员来说都是一项要求。开发人员正在成为不仅仅是编写代码的人。我们被要求设计、编写、测试、调试、编写文档、构建和部署软件。
- en: Automating tests using a CI/CD approach is where companies can save time and
    provide consistent stability and quality when releasing software to the public.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CI/CD方法自动化测试可以帮助公司在向公众发布软件时节省时间，并提供一致性和质量。
- en: In this section, we’ll cover the standards of why testing is important, how
    to avoid the 100% test coverage myth, what AAA is and why it’s a great approach
    for unit tests, how to avoid writing a unit test library, large unit tests, and
    unnecessary mocks. We’ll also learn about why tests have the added benefit of
    documentation, how to identify slow integration tests, when to write a unit test,
    and how to avoid testing .NET code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论测试为什么重要，如何避免100%测试覆盖率的神话，AAA是什么以及为什么它是单元测试的绝佳方法，如何避免编写单元测试库、大型单元测试和不必要的模拟。我们还将了解为什么测试具有额外的文档优势，如何识别缓慢的集成测试，何时编写单元测试，以及如何避免测试.NET代码。
- en: Why do we write tests?
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么编写测试？
- en: While some believe testing starts with developers, I believe it should start
    with management.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当有些人认为测试应该从开发者开始时，我认为它应该从管理层开始。
- en: Developers consider tests as an absolute requirement when writing software,
    but if management believes tests are a waste of time, it may be time to update
    the resume.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者认为在编写软件时测试是一个绝对的要求，但如果管理层认为测试是浪费时间，那么可能是时候更新简历了。
- en: Management, and possibly some developers, have various opinions about the stability
    of their software and the impact tests have on timetables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 管理层以及可能的一些开发者对软件的稳定性以及测试对时间表的影响有不同的看法。
- en: 'The reason for tests is simple: it allows developers to confirm the code they
    write to perform as expected. Further, if tests are providing a simple way to
    consume a certain module of code, those tests provide clarity to others as well
    as the original author, for that matter.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的原因很简单：它允许开发者确认他们编写的代码按预期执行。此外，如果测试提供了简单的方式来消费某个代码模块，那么这些测试也为其他人以及原始作者提供了清晰度。
- en: The “100% test coverage” myth
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “100%测试覆盖率”的神话
- en: As we swing the pendulum to the other side, some managers require 100% test
    coverage. While some people believe it’s possible, 100% is not achievable or desirable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将摆锤摆向另一边时，一些管理者要求100%的测试覆盖率。尽管有些人认为这是可能的，但100%是无法实现或理想的。
- en: Tests should be created where they are needed, not just for the sake of coverage.
    This creates a false metric and presents an illusion of “100% test coverage” if
    some unit tests are included to fulfill a metric. Developers may build tests just
    to “make their quota” to achieve this mythical metric. Each test should provide
    integrity with solid results and value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该在需要的地方创建，而不仅仅是为了覆盖率的 sake。如果为了满足某个指标而包含一些单元测试，这会创造一个虚假的指标，并呈现出“100%测试覆盖率”的幻觉。开发者可能会为了“完成配额”而构建测试，以实现这个神话般的指标。每个测试都应该提供与坚实结果和价值的完整性。
- en: This metric goes hand in hand with the **Line-Of-Code** (**LoC**) false metric
    as well because a developer who can write code with the least amount of lines
    is more efficient than a developer who writes less efficient code. More doesn’t
    always mean better.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指标与**代码行数**（**LoC**）的虚假指标也密切相关，因为能够用最少的行数编写代码的开发者比编写效率低下的开发者更有效率。更多并不总是意味着更好。
- en: Using AAA
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AAA
- en: 'When we write our unit tests, the best way is to use the AAA technique:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写单元测试时，最好的方法是使用AAA技术：
- en: '**Arrange**: Initialize the code for a test'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：为测试初始化代码'
- en: '**Act**: Perform the actual test'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动**：执行实际测试'
- en: '**Assert**: Determine whether the result is the expected behavior'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：确定结果是否是预期的行为'
- en: The Arrange step should initialize the code and be as minimal as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**安排**步骤应该初始化代码，并尽可能保持最小化。'
- en: The Act step should execute the code in question and should look similar to
    (if not exactly) like code in production.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**行动**步骤应该执行相关代码，并且应该看起来类似于（如果不是完全一样）生产环境中的代码。'
- en: Finally, the Assert step compares the result with what we’re expecting back
    from the code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**断言**步骤将结果与我们期望从代码中返回的内容进行比较。
- en: The AAA technique provides the easiest way to identify how tests in a system
    are tested.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: AAA技术提供了识别系统测试如何进行的最容易的方法。
- en: Avoid writing unit test code for your code
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免为你的代码编写单元测试代码
- en: While the AAA concept is a simple way of writing unit tests, there is another
    approach that I consider a code smell.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AAA概念是编写单元测试的简单方法，但我认为还有另一种方法，我认为这是一种代码异味。
- en: 'Imagine this scenario: the developer has to write a unit test where they have
    to make a database call using Entity Framework Core. The Arrange step has 30 lines
    of code to prepare the Act step to work properly. The developer takes these 30
    lines of code and moves them into a library, making them available for other unit
    tests.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这个场景：开发者必须编写一个单元测试，其中他们必须使用 Entity Framework Core 进行数据库调用。安排步骤有30行代码来准备行动步骤以正常工作。开发者将这些30行代码移动到一个库中，使它们可用于其他单元测试。
- en: These 30 lines of code are the code smell I mentioned. It makes more sense to
    refactor the code and abstract it even further to simplify the code. The Arrange
    step should not include an additional library of custom code to run a unit test.
    It should focus on testing the production code already written, not writing additional
    testing code to make the code pass.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这30行代码是我提到的代码异味。将代码重构并进一步抽象以简化代码更有意义。安排步骤不应包含一个额外的自定义代码库来运行单元测试。它应该专注于测试已经编写好的生产代码，而不是编写额外的测试代码来使代码通过。
- en: However, if there is a need for a helper library, it shouldn’t contain any branching
    statements, which would require the need to unit test the unit testing helper
    library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果需要辅助库，它不应包含任何分支语句，这将需要单元测试单元测试辅助库的需求。
- en: Avoid large unit tests
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免大型单元测试
- en: Developers have various definitions of what “large” is considered. Unit tests
    with more than one page (a screen) of code or more than 30 lines of code should
    be avoided.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者对“大”的定义各不相同。应避免具有超过一页（一个屏幕）的代码或超过30行代码的单元测试。
- en: 'These types of unit test methods present a problem: they are one step away
    from creating a library for the Arrange step from our previous tip.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的单元测试方法存在一个问题：它们仅一步之遥就快要创建一个用于我们之前提示的安排步骤的库。
- en: Again, it’s considered a code smell, where someone may need to take a step back
    and look at better ways to produce smaller setups instead of large code blocks
    of initialization.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这被认为是一种代码异味，可能需要某人退一步，寻找更好的方法来产生更小的设置，而不是大块的初始化代码。
- en: Avoid unnecessary mocks, fakes, or stubs
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免不必要的模拟、伪造或存根
- en: There are times when a method on a class doesn’t have any dependencies and is
    completely isolated. When we encounter this, we may not need to create a mocked
    object to fully unit test the method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个类上的方法没有任何依赖项，并且是完全隔离的。当我们遇到这种情况时，我们可能不需要创建模拟对象来完全单元测试该方法。
- en: Mocking is when we want to test a predefined behavior where stubs return a predefined
    value. Fakes are fully populated objects with working implementations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是我们想要测试预定义行为时的情况，存根返回预定义的值。伪造是具有工作实现的完整填充对象。
- en: At the very beginning of this chapter, we mentioned what a unit test was. We
    also created a simple extension method called `.ToFormattedDateTime()`. Since
    it’s an isolated method, we don’t require a mocked date/time object. We simply
    call the method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到了单元测试是什么。我们还创建了一个简单的扩展方法，称为 `.ToFormattedDateTime()`。由于它是一个独立的方法，我们不需要模拟日期/时间对象。我们只需调用该方法。
- en: For example, if we have a large library of extension methods that contain strings,
    we can create a unit test, create a string, pass it in, and check the return value
    is what is expected. If it requires further testing, rinse and repeat with different
    parameters.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个包含字符串的大库的扩展方法，我们可以创建一个单元测试，创建一个字符串，传递它，并检查返回值是否如预期。如果需要进一步测试，可以用不同的参数重复这个过程。
- en: When there’s a simple method, sometimes, it’s easier to test its functionality.
    No mock, fake, or stub is necessary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一个简单的方法时，有时测试其功能更容易。不需要模拟、伪造或存根。
- en: Using tests as documentation
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试作为文档
- en: Every unit test should contain some explanation of what is tested either in
    the method signature or in a comment explaining the situation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元测试都应该包含一些解释，说明测试了什么，无论是在方法签名中还是在注释中解释情况。
- en: Unit tests should be informative to peers (and our future self) and indicate
    knowledge of what’s involved in the effort (or abstraction) of completing each
    unit test and how it relates to the production code under test.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该对同行（以及我们的未来自己）具有信息性，并表明对完成每个单元测试所涉及的内容以及它与测试的生产代码的关系的了解。
- en: Along with informative unit tests, directory structure can also act as documentation
    and can go a long way. We should mirror the directory structure of the application
    in the unit tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了信息性单元测试外，目录结构也可以作为文档，并且可以走很长的路。我们应该在单元测试中反映应用程序的目录结构。
- en: If we see a folder in the application (or have a project) named `Data`, create
    a similar folder or project for the unit tests called `Data.Tests`. While this
    may be a simple concept, it helps our peers know immediately where and what the
    tests relate to in the project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在应用程序（或项目中）看到一个名为`Data`的文件夹，为单元测试创建一个类似的文件夹或项目，命名为`Data.Tests`。虽然这可能是一个简单的概念，但它帮助我们的同事立即知道测试与项目中的哪些部分相关。
- en: 'For example, if we look at a sample project with unit tests, you may have seen
    this type of structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们查看一个带有单元测试的示例项目，你可能已经看到了这种结构：
- en: '![Figure 7.1 – Example of well-structured tests for a project](img/B19493_07_1.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 项目良好结构化测试的示例](img/B19493_07_1.jpg)'
- en: Figure 7.1 – Example of well-structured tests for a project
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 项目良好结构化测试的示例
- en: While some folders are missing in the `ThemePark.Tests` project, we can immediately
    see that the `Extensions`, `Pages`, and `Services` folders contain at least one
    type of test. The presence of test folders mirroring the project folders itself
    makes it known that they contain unit or integration tests and shows a need for
    additional tests to be included in the testing project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在`ThemePark.Tests`项目中可能缺少一些文件夹，但我们可以立即看到`Extensions`、`Pages`和`Services`文件夹至少包含一种测试类型。存在与项目文件夹相对应的测试文件夹表明它们包含单元或集成测试，并表明需要在测试项目中包含额外的测试。
- en: Identifying slow integration tests
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别缓慢的集成测试
- en: Integration tests are performed using external resources such as a database,
    filesystem, or API. Therefore, integration tests will always run slower than unit
    tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试使用外部资源（如数据库、文件系统或API）进行。因此，集成测试的运行速度总是比单元测试慢。
- en: If we are working with a test environment to mimic another environment (such
    as arranging a QA environment to mimic production), the ability to detect slow
    connections provides a safeguard that an environment is working as expected. Ever
    heard the statement “It works in QA, but not in production” before?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用测试环境来模拟另一个环境（例如，安排一个QA环境来模拟生产环境），检测缓慢连接的能力提供了一个保障，即环境按预期工作。你以前听说过“在QA中工作得很好，但在生产中不行”的说法吗？
- en: However, if we’re working with an in-memory representation of an environment,
    it doesn’t make sense to identify whether a test is slow or not, does it? Compared
    to an actual environment, an in-memory representation of an environment will always
    run faster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们正在处理环境的内存表示，确定测试是否缓慢就没有意义，对吧？与实际环境相比，环境的内存表示总是运行得更快。
- en: One example of this is using the `Stopwatch` class to gauge processes (a page
    or API) to determine whether they’re fast or *very* fast.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`Stopwatch`类来衡量过程（页面或API）以确定它们是否运行得快或*非常快*。
- en: 'If we look at our Entity Framework example from [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114),
    and we add an integration test to the project, we can create a simple way to identify
    whether our page call is slow or not, as shown in the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的Entity Framework示例来自[*第5章*](B19493_05.xhtml#_idTextAnchor114)，并且我们向项目中添加一个集成测试，我们可以创建一种简单的方法来识别我们的页面调用是否缓慢，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this integration test, we are testing the main page of our `ThemePark` application
    and finding out if it performs well or not. First, we arrange our classes, since
    `IndexModel` accepts `ILogger<PageModel>` and `IAttractionService`. Once we create
    our stopwatch, we call `IndexModel` (Act) and stop the stopwatch immediately.
    We convert it into seconds and conduct our Assert step.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个集成测试中，我们正在测试我们的`ThemePark`应用程序的主页，以确定其性能是否良好。首先，我们安排我们的类，因为`IndexModel`接受`ILogger<PageModel>`和`IAttractionService`。一旦我们创建好计时器，我们就调用`IndexModel`（Act）并立即停止计时器。我们将它转换为秒，并执行我们的断言步骤。
- en: Of course, we are performing an in-memory integration test for illustration
    purposes, but this concept is best suited to integration tests with external resources
    to identify latency issues.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们正在进行内存集成测试以供说明，但这个概念最适合与外部资源一起进行的集成测试，以识别延迟问题。
- en: In the example above, we can’t tell if it’s in memory or not just by reading
    the test. It’s encapsulated in `IndexModel` and its goal is meant to identify
    whether it performs quick or not.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，仅通过阅读测试我们无法判断它是否在内存中。它被封装在`IndexModel`中，其目的是确定它是否执行得快。
- en: Find a bug, write a test
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到错误，编写测试
- en: Unit tests are vital to a stable product, regardless of whether it’s a web application
    or a smartphone app. Every developer will most definitely experience bugs in the
    application, so it makes sense to always keep the unit tests up to date.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对于稳定的产品至关重要，无论它是 Web 应用程序还是智能手机应用程序。每个开发者都肯定会遇到应用程序中的错误，因此始终保持单元测试是最新的是有意义的。
- en: 'When we (or the users) encounter a bug, repeat this mantra: *Find a bug, write
    a test*. This may be a simple concept, but it’s recommended.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们（或用户）遇到错误时，重复这个咒语：*找到错误，编写测试*。这可能是一个简单的概念，但这是推荐的。
- en: When anyone finds a bug in the application, immediately write a unit test about
    that bug. This gives us peace of mind when deploying an application. If we had
    a bug and confirmed a unit test fixed the problem, we’ll have enough confidence
    to say it was tested before being deployed. It’s one thing to fix the problem,
    but adding a test makes the code more bulletproof and provides confidence that
    the bug won’t happen again.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何人发现应用程序中的错误时，立即为该错误编写一个单元测试。这使我们部署应用程序时感到安心。如果我们有一个错误并且确认单元测试修复了问题，我们将有足够的信心说它在部署前已经过测试。修复问题是一回事，但添加测试使代码更加坚不可摧，并提供了信心，即错误不会再次发生。
- en: Avoid testing .NET
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免测试 .NET
- en: .NET is a large framework. Unit tests are meant to test specific code. *YOUR
    code*. There is no need to create unit tests for .NET code (or other libraries/frameworks
    for that matter) when it’s already been tested by Microsoft.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 是一个庞大的框架。单元测试旨在测试特定的代码。*你的代码*。当微软已经测试过时，就没有必要为 .NET 代码（或其他库/框架）创建单元测试。
- en: For example, if there is a test for determining whether a substring method returns
    the right value, this is testing the .NET framework. *Don’t write this* *unit
    test*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果有一个测试用于确定子字符串方法是否返回正确的值，这实际上是测试 .NET 框架。*不要编写这个* *单元测试*。
- en: Our efforts are better suited to a higher scope of the method. Focus on unit
    testing the calling method where our code lives as opposed to a .NET method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的努力更适合于方法的高层次范围。专注于测试我们代码所在的位置的调用方法，而不是 .NET 方法。
- en: In this section, we examined why creating unit tests is important and why 100%
    test coverage is a myth. We also learned about various common unit testing strategies,
    such as how to use an AAA scaffolding for our unit tests, why it’s considered
    a code smell to write additional unit test libraries when creating large unit
    tests, and why sometimes mocking libraries aren’t necessary for everything.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了创建单元测试的重要性以及为什么 100% 的测试覆盖率是一个神话。我们还了解了各种常见的单元测试策略，例如如何使用 AAA 框架进行单元测试，为什么在创建大型单元测试时编写额外的单元测试库被认为是代码异味，以及为什么有时不需要为所有内容使用模拟库。
- en: We also learned about using tests as documentation using comments and folders,
    identifying slow integration tests by adding stopwatches, finding a bug and immediately
    writing a test to bulletproof our code even further, and how to avoid testing
    .NET methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用注释和文件夹将测试作为文档，通过添加计时器来识别慢速集成测试，找到错误并立即编写测试以进一步增强代码的坚不可摧性，以及如何避免测试
    .NET 方法。
- en: In the next section, we’ll review our strategies and apply them to our `ThemePark`
    application from [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾我们的策略并将它们应用于[第 5 章](B19493_05.xhtml#_idTextAnchor114)中的 `ThemePark`
    应用程序。
- en: Testing data access
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据访问
- en: Over the years, Entity Framework has strived to become unit testable and gives
    developers a better level of confidence when working with data access.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，Entity Framework一直努力成为可单元测试的，并在与数据访问工作时应开发者拥有更高的信心水平。
- en: Building on when we created a sample database with Entity Framework Core in
    [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114), in this section, we’ll cover
    a simple way to use a SQLite in-memory database to confirm the functionality of
    our application… even though we don’t have a database connection. Using the in-memory
    provider option, Microsoft has recommended avoiding this approach and using either
    SQLite to conduct database calls or using a production (or better, a QA) database
    for our queries.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[第 5 章](B19493_05.xhtml#_idTextAnchor114)中我们使用 Entity Framework Core 创建示例数据库的情况，在本节中，我们将介绍一种使用
    SQLite 内存数据库来确认应用程序功能的方法……即使我们没有数据库连接。使用内存提供者选项，微软建议避免这种方法，而是使用 SQLite 进行数据库调用或使用生产（或更好的，QA）数据库进行查询。
- en: Avoid in-memory providers
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存提供者
- en: 'Since in-memory is an extremely simplistic implementation of a database, Microsoft
    has recommended using alternative methods for testing and avoiding the in-memory
    provider for databases. Refer to the following URL for additional details: [https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database](https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存是一个极其简化的数据库实现，Microsoft建议使用替代方法进行测试，并避免使用内存提供程序进行数据库测试。有关详细信息，请参阅以下URL：[https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database](https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database)。
- en: Adding the SQLite provider
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加SQLite提供程序
- en: 'Since we don’t have a way to access data yet in our tests, we have to add SQLite
    to get as close to an implementation as possible. Using NuGet, we have to add
    the following NuGet packages:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有在测试中访问数据的方法，我们必须添加SQLite以尽可能接近实现。使用NuGet，我们必须添加以下NuGet包：
- en: '`Microsoft.EntityFrameworkCore.Sqlite`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.Sqlite`'
- en: '`Microsoft.EntityFrameworkCore.InMemory`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.InMemory`'
- en: Once we have those in our tests, we can proceed with creating our `AttractionService`
    and `LocationService` tests to confirm they work as expected.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在测试中有了这些，我们就可以继续创建我们的`AttractionService`和`LocationService`测试，以确认它们按预期工作。
- en: Creating the AttractionService test
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AttractionService测试
- en: Since we are using `AttractionService` as a “repository,” we only need to pass
    in `DbContext` for it to work as expected. Currently, `ThemeParkDbContext` creates
    seeded data for an empty database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`AttractionService`用作“仓库”，我们只需要传入`DbContext`即可按预期工作。目前，`ThemeParkDbContext`为空数据库创建种子数据。
- en: This is perfect for our needs because when passing in `ThemeParkDbContext`,
    `DbContext` could be an in-memory representation or an actual connection to a
    production database. In this case, we are creating an in-memory SQLite database
    for our purposes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常适合我们的需求，因为当传入`ThemeParkDbContext`时，`DbContext`可以是内存中的表示形式或实际连接到生产数据库。在这种情况下，我们正在创建一个内存中的SQLite数据库以供我们的目的使用。
- en: The SQLite provider opens connections when a call is made and deletes the connection
    when it’s closed. We create the connection during setup and provide a `[Cleanup]`
    attribute to deallocate the connection. This is specifically for SQLite.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite提供程序在调用时打开连接，并在关闭时删除连接。我们在设置期间创建连接，并提供一个`[Cleanup]`属性来释放连接。这专门针对SQLite。
- en: 'Our `AttractionService` integration test is shown in the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AttractionService`集成测试示例如下：
- en: '[PRE3]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we tell our tests to run the setup method using the
    `[TestInitialize]` attribute and clean up our mess using the `[TestCleanup]` attribute.
    The `[TestInitialize]` attribute attaches to a method for initialization purposes.
    The `[TestCleanup]` attribute identifies a method to clean up what was initialized
    with the `[``TestInitialize]` attribute.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`[TestInitialize]`属性告诉我们的测试运行设置方法，并使用`[TestCleanup]`属性清理我们的混乱。`[TestInitialize]`属性用于初始化目的的方法。`[TestCleanup]`属性标识一个用于清理由`[TestInitialize]`属性初始化的内容的方法。
- en: Since we’re using SQLite for our database, we must create a connection in the
    `Setup()` method and open the connection. Once we open it, we need to create `DbContextOptions`
    for our fake database. The final step is to ensure the databases were created
    for our tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用SQLite作为数据库，我们必须在`Setup()`方法中创建一个连接并打开它。一旦打开，我们需要为我们的模拟数据库创建`DbContextOptions`。最后一步是确保数据库已为我们测试创建。
- en: There are two things to notice here. The first is that we didn’t need a mocked
    object for `DbContext`. In the `OnConfiguring()` configuration method of `DbContext`,
    if we have a configuration (such as an `appsettings.json` file), we should use
    it. If not, we should create a SQLite in-memory database for our testing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方。首先，我们不需要为`DbContext`创建模拟对象。在`DbContext`的`OnConfiguring()`配置方法中，如果我们有配置（例如`appsettings.json`文件），我们应该使用它。如果没有，我们应该为测试创建一个SQLite内存数据库。
- en: The second thing to notice is our Act step in our integration test. This line
    should be the same one that we have in our production code. The closer we can
    get test calls to match what you have in production, the more confident we’ll
    feel about the code, along with the accuracy and value of those tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的地方是我们集成测试中的Act步骤。这一行应该与我们在生产代码中拥有的相同。我们越能使测试调用与生产中的调用相匹配，我们就越有信心，同时也会对代码、测试的准确性和价值更有信心。
- en: Creating the LocationService test
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LocationService测试
- en: 'Since we have a structure of what our tests consist of now, we can use those
    tests for `LocationService`. Our `LocationService` test consists of two methods
    – `GetAllLocationsAsync()` and `GetLocationAsync(int)`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了测试的结构，我们可以使用这些测试来针对`LocationService`。我们的`LocationService`测试包括两个方法——`GetAllLocationsAsync()`和`GetLocationAsync(int)`：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, notice that we didn’t need to mock `DbContext`. We created `LocationService`
    by passing in `ThemeParkDbContext` and used it as we would in a production environment.
    The ability to set up and tear down a full database is one of the greatest ways
    to test the database’s functionality. While using an existing database would be
    as equally beneficial, this provides a quicker way of “setting up” and “tearing
    down” database functionality without the clutter or modifications when others
    update the database. If others are using an existing database, this could cause
    integration tests to fail in a CI/CD pipeline.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们不需要模拟`DbContext`。我们通过传递`ThemeParkDbContext`来创建`LocationService`，并像在生产环境中一样使用它。设置和拆除完整数据库的能力是测试数据库功能的最有效方法之一。虽然使用现有数据库同样有益，但这提供了一种更快的“设置”和“拆除”数据库功能的方法，避免了当其他人更新数据库时的混乱或修改。如果其他人使用现有数据库，这可能导致集成测试在CI/CD管道中失败。
- en: In this section, we learned how to set up tests with SQLite and how to perform
    queries using an in-memory database to mimic a production database. We also gave
    three examples of testing Entity Framework Core.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用SQLite设置测试，以及如何使用内存数据库执行查询来模拟生产数据库。我们还提供了三个测试Entity Framework
    Core的示例。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing and documentation are often areas that get deprioritized or overlooked
    by development teams. However, testing is a requirement for code bases. As a final
    point, developers should make their tests as small and fast as possible using
    as close to production code in the Act step as possible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和文档通常是开发团队优先级较低或被忽视的领域。然而，测试是代码库的必要要求。作为一个最后的观点，开发者应该尽可能使用接近生产环境的代码在Act步骤中使测试尽可能小和快。
- en: In this chapter, we covered the different types of testing, which include unit,
    integration, regression, load testing, system (or E2E tests), and UI testing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了不同类型的测试，包括单元测试、集成测试、回归测试、负载测试、系统（或端到端测试）和UI测试。
- en: Once we understood the difference between these types of testing, we examined
    why creating unit tests is important and why test coverage goals shouldn’t be
    100%. We then covered common unit testing strategies, such as how to use AAA scaffolding
    for our unit tests, why writing too much code for our unit tests is considered
    a code smell, and why mocking libraries aren’t required.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了这些测试类型之间的区别，我们就探讨了为什么创建单元测试很重要，以及为什么测试覆盖率目标不应该达到100%。然后我们介绍了常见的单元测试策略，例如如何为我们的单元测试使用AAA脚手架，为什么为单元测试编写过多的代码被认为是代码异味，以及为什么不需要模拟库。
- en: Finally, we learned how to supplement documentation by using comments and folders,
    how to identify slow integration tests by adding stopwatches, how to find a bug
    and immediately write a test to bulletproof our code even further, and how to
    avoid testing .NET methods.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何通过使用注释和文件夹来补充文档，如何通过添加计时器来识别慢速集成测试，如何找到错误并立即编写测试来进一步增强我们的代码的安全性，以及如何避免测试.NET方法。
- en: In the next chapter, we’ll cover exception handling and some of the better ways
    to handle errors in the application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍异常处理以及处理应用程序错误的一些更好的方法。
