- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design Patterns and .NET 8 Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns can be defined as ready-to-use architectural solutions for common
    problems you encounter during software development. They are essential for understanding
    the .NET architecture and useful for solving ordinary problems that we face when
    designing any piece of software. In this chapter, we will look at the implementation
    of some design patterns. It is worth mentioning that this book does not explain
    all the known patterns we can use. The focus here is to explain the importance
    of studying and applying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns and their purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the design patterns available in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about some of the use cases
    that you can implement with design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need the free Visual Studio 2022 Community
    Edition or better.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)/tree/main/ch06.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns and their purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deciding on the design of a system is challenging, and the responsibility associated
    with this task is enormous. As software architects, we must always keep in mind
    that features such as great reusability, good performance, and good maintainability
    are important for delivering a good solution. This is where design patterns help
    and accelerate the design process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, design patterns are solutions that have already
    been discussed and defined so that they can solve common software architectural
    problems. This approach grew in popularity after the release of the book *Design
    Patterns – Elements of Reusable Object-Oriented Software*, where the **Gang of
    Four** (**GoF**) divided these patterns into three types: creational, structural,
    and behavioral.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A little bit later, Uncle Bob introduced the SOLID principles to the developer
    community, giving us the opportunity to efficaciously organize the functions and
    data structures of each system. The SOLID design principles indicate how the components
    of software should be designed and connected. It is worth mentioning that, compared
    to the design patterns presented by GoF, the SOLID principles do not deliver code
    recipes. Instead, they give you the basic principles to follow when you design
    your solutions, keeping the software’s structure strong and reliable. They can
    be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility**: A module or function should be responsible for a
    single purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-Closed**: A software artifact should be open for extension but closed
    for modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution**: The behavior of a program needs to remain unchanged
    when you substitute one of its components for another component that has been
    defined by a supertype of the primer object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation**: Depending on the way you create interfaces, you
    will promote dependencies that do not necessarily occur when you build their concrete
    objects, causing harm to the system architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion**: The most flexible systems are the ones where object
    dependencies only refer to abstractions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As technologies and software problems change, more patterns are conceived.
    The advance of cloud computing has brought a bunch of them, and some can be found
    at [https://docs.microsoft.com/en-us/azure/architecture/patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns).
    The content is organized into three different challenge areas: Data Management,
    Design and Implementation, and Messaging. Many of them are described in the chapters
    of this book, as we can see in the list below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous Request-Reply**: This pattern is presented while discussing
    Azure Durable Functions in *Chapter 16*, *Working with Serverless - Azure Functions*;
    the orchestrator function for **async HTTP APIs** solves this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulkhead Isolation**: This pattern is presented while discussing microservices
    design principles in *Chapter 11*, *Applying a Microservice Architecture to Your
    Enterprise Application*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache-Aside**: Caching was presented in *Chapter 1*, *Understanding the Importance
    of Software Architecture*. Its usage with Azure Redis is also presented in *Chapter
    12*, *Choosing Your Data Storage in the Cloud*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit-Breaker**: The strategy necessary to implement this is presented
    in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command Query Responsibility Segregation** (**CQRS**): CQRS is described
    in *Chapter 7*, *Understanding the Different Domains in Software Solutions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher/Subscriber**: This pattern will be explained in the subsections
    below and discussed in *Chapter 7*, *Understanding the Different Domains in Software
    Solutions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retry**: The *resilient task execution* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*, shows how to use
    Polly, a general framework for applying retries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue-Based Load Leveling**: The scenario presented in *Chapter 16*, *Working
    with Serverless – Azure Functions*, uses a queue that acts as a buffer between
    a task and a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason why new patterns emerge is related to the challenges we face when
    new solutions are developed. Today, availability, data management, messaging,
    monitoring, performance, scalability, resiliency, and security are aspects we
    must deal with when delivering cloud solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why you should always consider using design patterns in development
    is quite simple—as a software architect, you cannot spend time reinventing the
    wheel. However, there is another great reason for using and understanding them—you
    will find many of these patterns already implemented in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few subsections, we will cover some of the most well-known patterns.
    The idea of this chapter is just to let you know that they exist and need to be
    studied so that you can accelerate and simplify your projects. Moreover, each
    pattern will be presented with a C# code snippet so that you can implement it
    in your projects while always remembering that we are talking about samples, not
    code ready for production.
  prefs: []
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are cases where you will have a complex object with different behaviors
    due to its configuration. Instead of setting this object up while using it, you
    may want to decouple its configuration from its usage, using a customized configuration
    that is already built. This way, you have different representations of the instances
    you are building. This is where you should use the Builder pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The following class diagram shows the pattern that has been implemented for
    a scenario from this book’s use case, presented in *Chapter 21*, *Case Study*.
    The idea behind this design choice is to simplify the way rooms from WWTravelClub
    are described.
  prefs: []
  type: TYPE_NORMAL
- en: The Fluent API implemented in the `Room` class enables us to have the construction
    of each kind of room defined in each builder (`SimpleRoomBuilder` and `FamilyRoomBuilder`)
    more simply.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19280_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Builder pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this implementation is quite simple but clarifies the reason
    why you need to implement a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19280_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Builder pattern sample result'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you have the implementation, evolving this code becomes simpler.
    For example, if you need to build a different style of room, you can just create
    a new builder for that type of room, and you will be able to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why this implementation becomes quite simple is related to the usage
    of chaining methods, as we can see in the `Room` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, if you need to add the configuration settings for the product,
    all the concrete classes you used previously will be defined in the Builder interface
    and stored there so that you can update them with ease.
  prefs: []
  type: TYPE_NORMAL
- en: We will see a great implementation of the Builder pattern in .NET in the *Understanding
    the design patterns available in .NET* section. There, you will be able to understand
    how Generic Host was implemented using `HostBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Factory pattern is useful in situations where you have multiple objects
    from the same abstraction, and you only know which one needs to be created at
    runtime. This means you will have to create the instance according to a certain
    configuration or according to where the software lives now.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let us check out the WWTravelClub sample. Here, there is a user
    story that describes that this application will have customers from all over the
    world paying for their trips. However, in the real world, there are different
    payment services available for each country. The process of paying is similar
    for each country, but this system will have more than one payment service available.
    A good way to simplify this payment implementation is by using the Factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the basic idea of its architectural implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19280_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Factory pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that since you have an interface that describes what the payment service
    for the application is, you can use the Factory pattern to change the concrete
    class according to the services that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the service’s usage has been simplified due to the implemented pattern.
    If you had to use this code in a real-world application, you would change the
    instance’s behavior by defining the service you needed in the Factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you implement Singleton in your application, you will have a single instance
    of the object implemented in the entire solution. This is one of the most used
    patterns in every application. The reason is simple—there are many use cases where
    you need some classes to have just one instance. Singletons solve this by providing
    a better solution than a global variable does.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Singleton pattern, the class is responsible for creating and delivering
    a single object that will be used by the application. In other words, the Singleton
    class creates a single instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B19280_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Singleton pattern'
  prefs: []
  type: TYPE_NORMAL
- en: To do so, the object that is created is `static` and delivered in a static property
    or method. The `??=` operator assigns the value of its right operand to its left
    one if its value is null.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements the Singleton pattern, which has a `Message`
    property and a `Print()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Its usage is simple–you just need to call the static property every time you
    need to use the Singleton object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Be careful because the sample can have concurrency issues according to the usage
    defined! Please refer to *Chapter 2*, *Non-Functional Requirements*, to read a
    bit more about concurrency and multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the situations where you can use this pattern is when you need to deliver
    the app configuration in a way that can be easily accessed from anywhere in the
    solution. For instance, let us say you have some configuration parameters that
    are stored in a table, which your app needs to query at several decision points.
    Although we have standard solutions like `appsettings.json` or `web.config`, where
    caching is out of the box, you may want to use this custom solution. In this case,
    instead of querying the configuration table directly, you can create a Singleton
    class to help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B19280_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Singleton pattern usage'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you will need to implement a cache in this Singleton, thus improving
    the performance of the system since you will be able to decide whether the system
    will check each configuration in the database every time it needs it or if the
    cache will be used. The following screenshot shows the implementation of the cache,
    where the configuration is loaded every 5 seconds. The parameter that is read
    in this case is just a random number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing calendar  Description automatically generated](img/B19280_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Cache implementation inside the Singleton pattern'
  prefs: []
  type: TYPE_NORMAL
- en: This is great for the application’s performance. Besides, using parameters in
    several places in your code is simpler since you do not have to create configuration
    instances everywhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that due to the dependency injection implementation in
    .NET, Singleton pattern usage has become less common since you can set dependency
    injection to handle your Singleton objects. We will cover dependency injection
    in .NET in later sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Proxy pattern is used when you need to provide an object that controls access
    to another object. One of the biggest reasons why you should do this is related
    to the cost of creating the object that is being controlled. For instance, if
    the controlled object takes too long to be created or consumes too much memory,
    a proxy can be used to guarantee that the largest part of the object will only
    be created when it is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram is of a **Proxy** pattern implementation for loading
    pictures from **Room** (see *Figure 6.1*), but only when requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19280_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Proxy pattern implementation'
  prefs: []
  type: TYPE_NORMAL
- en: The client of this proxy will request its creation. Here, the proxy will only
    gather basic information (`Id`, `FileName`, and `Tags`) from the real object and
    will not query `PictureData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only when `PictureData` is requested in the first call will the proxy load
    it, as we can confirm with the message Now the picture is loaded!. After that,
    in the second picture data request, the proxy will not load the `PictureData`
    again, which causes a better performance, as we can see in *Figure 6.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If `PictureData` is requested again, since the image data is already in place,
    the proxy will guarantee that image reloading will not be repeated. The following
    screenshot shows the result of running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19280_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Proxy pattern result'
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique can be referred to by another name: **lazy loading**. In fact,
    the Proxy pattern is a way of implementing lazy loading. Another approach for
    implementing lazy loading is the usage of the `Lazy<T>` type. For instance, in
    Entity Framework Core, as discussed in *Chapter 13*, *Interacting with Data in
    C# – Entity Framework Core*, you can turn on lazy loading using proxies. You can
    find out more about this at [https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading).'
  prefs: []
  type: TYPE_NORMAL
- en: Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many cases where you need to execute a **command** that will affect
    the behavior of an object. The Command pattern can help you with this by encapsulating
    this kind of request in an object. The pattern also describes how to handle undo/redo
    support for a request.
  prefs: []
  type: TYPE_NORMAL
- en: There is another design pattern called Memento that also has the purpose of
    implementing undo actions. However, the Command pattern focuses on encapsulating
    requests as objects, whereas Memento focuses on capturing and externalizing an
    object’s internal state for the purpose of restoring it later.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let us imagine that, on the WWTravelClub website, users can evaluate
    packages by specifying whether they liked, disliked, or even loved their experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram is an example of what can be implemented to create
    this rating system with the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19280_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Command pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the way this pattern works – if you need a different command, such as
    `Hate`, you will only implement a new class based on the `ICommand` interface.
    You do not need to change the code from other action classes. The change in the
    `Package` class will not impact the commands already implemented. Besides that,
    if you want to implement the `Redo` method, it can be added in a similar way to
    the `Undo` method. The full code sample for this is available in this book’s GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: It might also help to mention that ASP.NET Core MVC uses the Command pattern
    for its `IActionResult` hierarchy. The business operation described in *Chapter
    7*, *Understanding the Different Domains in Software Solutions*, will make use
    of this pattern to execute business rules.
  prefs: []
  type: TYPE_NORMAL
- en: Publisher/Subscriber pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providing information from an object to a group of other objects is common in
    all applications. The Publisher/Subscriber pattern is almost mandatory when there
    is a large volume of components (subscribers) that will receive a message containing
    the information that was sent by the object (publisher).
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept here is quite simple to understand and is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19280_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Publisher/Subscriber sample case'
  prefs: []
  type: TYPE_NORMAL
- en: When you have an indefinite number of different possible subscribers, it is
    essential to decouple the component that broadcasts information from the components
    that consume it. The Publisher/Subscriber pattern does this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this pattern is complex since distributing environments is not
    a trivial task. Therefore, it is recommended that you consider pre-existing technologies
    for implementing the message broker that connects the input channel to the output
    channels instead of building it from scratch. Azure Service Bus is a reliable
    infrastructure component where you can find this pattern provided, so all you
    need to do is connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ, which we mention in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, and in *Chapter 14*, *Implementing Microservices
    with .NET*, is another service that can be used to implement a message broker,
    but it is a lower-level infrastructure and requires several manual implementations,
    such as retries in errors.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Dependency Injection pattern is considered a good way to implement the Dependency
    Inversion principle, guiding you to implement this SOLID principle.
  prefs: []
  type: TYPE_NORMAL
- en: The concept is quite simple. Instead of creating instances of the objects that
    the component depends on, you just need to define their dependencies, declare
    their interfaces, and enable the reception of the objects by **injection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to perform dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the constructor of the class to receive the objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag some class properties to receive the objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define an interface with a method to inject all the necessary components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the implementation of the Dependency Injection
    pattern using the constructor of the class to receive the objects. In this case,
    it receives `UserAddress` and `DestinationAddress` classes, which can be completely
    different, but both of them implement the `IAddress` interface, which enables
    the **DistanceCalculator** to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19280_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Dependency Injection pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these three ways mentioned above, Dependency Injection can be used
    with an **Inversion of Control** (**IoC**) container. This container enables the
    automatic injection of dependencies whenever they are asked for. There are several
    IoC container frameworks available on the market, but with .NET 8, for most cases,
    there is no need to use third-party software since it contains a set of libraries
    to solve this in the `Microsoft.Extensions.DependencyInjection` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'This IoC container is responsible for creating and disposing of the objects
    that are requested. The implementation of Dependency Injection is based on constructor
    types. There are three options for the injected component’s lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient**: The objects are created each time they are requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: The objects are created for each scope defined in the application.
    In a web app, a **scope** is identified with a web request unless you create a
    custom scope. A good example where custom scope can be used is in multi-tenant
    applications. In this case, you may want to manage dependencies per tenant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: Each object has the same application lifetime, so a single object
    is reused to serve all the requests for a given type. If your object contains
    state, you should not use this one unless it is thread-safe. Remember to refer
    to *Chapter 2*, *Non-Functional Requirements*, to learn more about multithreading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way you use these options depends on the business rules of the project you
    are developing. It is also a matter of how you register the services of the application.
    You need to be careful in deciding on the correct one since the behavior of the
    application will change according to the type of object you are injecting.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the design patterns available in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discovered in the previous sections, C# allows us to implement any of
    the patterns. .NET provides many implementations in its SDK that follow all the
    patterns we have discussed, such as Entity Framework Core proxy lazy loading.
    Another good example that has been available since .NET Core 2.1 is .NET Generic
    Host, which does not directly implement a specific pattern but combines many of
    them, providing a flexible and extensible host environment for .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 17*, *Presenting ASP.NET Core MVC*, we will detail the hosting that’s
    available for web apps in .NET 8\. This web host helps us since the startup of
    the app and lifetime management are set up alongside it. The idea of .NET Generic
    Host is to enable this way of working for applications that do not need HTTP implementation.
    With this Generic Host, any .NET program can have a startup class where we can
    configure the dependency injection engine. This can be useful for creating multi-service
    apps, using Composite patterns as a basis for that.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about .NET Generic Host at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host),
    which contains some sample code and is the current recommendation from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: The code provided in the GitHub repository is simple, but it focuses on the
    creation of a console app that can run a service for monitoring. The great thing
    about this is the way the console app is set up to run, where the builder configures
    the services that will be provided by the application and the way logging will
    be managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code gives us an idea of how .NET uses design patterns. Using
    the Builder pattern, .NET Generic Host allows you to set the classes that will
    be injected as services. In addition to this, the Builder pattern helps you configure
    some other features, such as the way logs will be shown/stored. This configuration
    allows the services to inject `ILogger<outTCategoryName>` objects into any instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other examples of Generic Host usage are worker services, described in *Chapter
    14*, *Implementing Microservices with .NET*, and Blazor’s Generic Host, described
    in *Chapter 19, Client Frameworks: Blazor*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood why design patterns help with the maintainability
    and reusability of the parts of the system you are building. We also looked at
    some typical use cases and code examples that you can consider in your projects,
    always remembering that they need to evolve to achieve professional delivery.
    Finally, we presented .NET Generic Host, which is a good example of how .NET uses
    design patterns to enable code reusability and enforce best practices.
  prefs: []
  type: TYPE_NORMAL
- en: All this content will help you while architecting new software or even maintaining
    something existing since design patterns are already-known solutions for some
    real-life problems in software development.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 7*, *Understanding the Diﬀerent Domains in Software Solutions*,
    we will cover the domain-driven design approach. We will also learn how to use
    the SOLID design principles so that we can map different domains to our software
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are design patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between design patterns and design principles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Builder pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Factory pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Singleton pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Proxy pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Command pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Publisher/Subscriber pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Dependency Injection pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some books and websites where you can find out more about
    what was covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clean Architecture*: *A Craftsman’s Guide to Software Structure and Design*,
    Martin, Robert C., Pearson Education, 2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns*: *Elements of Reusable Object-Oriented Software*, Erich Gamma,
    et al., Addison-Wesley, 1994.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns*, Martin, Robert C., 2000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to get more info about design patterns and architectural principles,
    please check out these links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to check specific cloud design patterns, you can find them at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to better understand the idea of a Generic Host, follow this link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a very good explanation about Service Bus messaging at this link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about dependency injection by checking out these links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
