- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Visual Effects with Particle Systems and Visual Effect Graph
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用粒子系统和视觉效果图进行视觉效果
- en: In this chapter, we will continue learning about visual effects for our game.
    We will be discussing particle systems, a way to simulate fire, waterfalls, smoke,
    and all kinds of fluids. Also, we will see the two Unity **particle systems**
    to create these kinds of effects, **Shuriken**, and **Visual Effect Graph**, the
    latter being more powerful than the first but requiring more hardware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续学习我们游戏中的视觉效果。我们将讨论粒子系统，这是一种模拟火焰、瀑布、烟雾和各种流体的方法。此外，我们还将看到两个 Unity **粒子系统**来创建这些效果，**Shuriken**和**视觉效果图**，后者比前者更强大，但需要更多的硬件。
- en: 'In this chapter, we will cover the following particle system topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下粒子系统主题：
- en: Introduction to Shuriken particle systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shuriken 粒子系统简介
- en: Creating fluid simulations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流体模拟
- en: Creating complex simulations with Visual Effect Graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视觉效果图创建复杂模拟
- en: Introduction to Shuriken particle systems
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shuriken 粒子系统简介
- en: All graphics and effects we have created so far use static meshes—3D models
    that can’t be skewed, bent, or deformed in any way. **Fluids** such as fire and
    smoke clearly can’t be represented using this kind of mesh, but actually, we can
    simulate these effects with a combination of static meshes, and this is where
    particle systems are useful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的所有图形和效果都使用静态网格——不能以任何方式倾斜、弯曲或变形的 3D 模型。**流体**如火焰和烟雾显然不能使用这种网格表示，但实际上，我们可以通过静态网格的组合来模拟这些效果，这就是粒子系统发挥作用的地方。
- en: '**Particle systems** are objects that emit and animate lots of **particles**
    or **billboards**, which are simple quad meshes that face the camera. Each particle
    is a static mesh, but rendering, animating, and combining lots of them can generate
    the illusion of a fluid.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子系统**是发射和动画化大量**粒子**或**标牌**的对象，这些是面向摄像机的简单四边形网格。每个粒子是一个静态网格，但渲染、动画和组合大量粒子可以产生流体的幻觉。'
- en: 'In *Figure 11.1* you can see a smoke effect using particle systems on the left,
    and on the right, the **Wireframe** view of the same particles. There you can
    see the quads that create the illusion of smoke, which is done by applying a smoke
    texture to each of the particles and animating them, so they spawn at the bottom
    and move up in random directions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 11.1*中，你可以看到左侧使用粒子系统创建的烟雾效果，右侧是相同粒子的**线框**视图。在那里，你可以看到创建烟雾幻觉的四边形，这是通过将烟雾纹理应用到每个粒子并对其动画化来实现的，使它们从底部产生并向上随机移动：
- en: '![](img/B18585_11_01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_01.png)'
- en: 'Figure 11.1: On the left side, a smoke particle system; on the right side,
    the wireframe of the same system'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：左侧，烟雾粒子系统；右侧，相同系统的线框
- en: 'In this section, we will cover the following topics related to particles:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与粒子相关的以下主题：
- en: Creating a basic particle system with Shuriken
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Shuriken 创建基本粒子系统
- en: Using advanced modules
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级模块
- en: Let’s start by discussing how to create our very first particle system using
    Shuriken.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何使用 Shuriken 创建我们第一个粒子系统。
- en: Creating a basic particle system with Shuriken
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Shuriken 创建基本粒子系统
- en: 'To illustrate the creation of a particle system, let’s create an explosion
    effect. The idea is to spawn lots of particles at once and spread them in all
    directions. Let’s start with creating the Shuriken particle system and configuring
    the basic settings it provides to change its default behavior. To do so, follow
    these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明粒子系统的创建，让我们创建一个爆炸效果。想法是同时产生大量粒子并将它们向所有方向扩散。让我们从创建 Shuriken 粒子系统并配置它提供的基本设置开始，以改变其默认行为。为此，请按照以下步骤操作：
- en: 'Select the **GameObject | Effects | Particle System** option:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**GameObject | Effects | Particle System**选项：
- en: '![](img/B18585_11_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_02.png)'
- en: 'Figure 11.2: Particle System button'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：粒子系统按钮
- en: 'You should see the effect in the following screenshot. The default behavior
    is a column of particles going up, like the smoke effect shown previously. Let’s
    change that:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在下面的屏幕截图中看到效果。默认行为是一列粒子向上移动，就像之前显示的烟雾效果。让我们改变一下：
- en: '![](img/B18585_11_03.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_03.png)'
- en: 'Figure 11.3: Default particle system appearance'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：默认粒子系统外观
- en: Click the created object in the scene and look at the Inspector.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中单击创建的对象并查看检查器。
- en: Open the **Shape** section by clicking on the title. Here you will be able to
    specify the particle emitter shape from where the particles are going to be spawned.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击标题打开**形状**部分。在这里，你可以指定粒子发射器的形状，粒子将从该形状中产生。
- en: 'Change the **Shape** property to **Sphere**. Now the particles should move
    in all possible directions instead of following the default cone:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**形状**属性更改为**球体**。现在粒子应该向所有可能的方向移动，而不是遵循默认的圆锥：
- en: '![](img/B18585_11_04.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_04.png)'
- en: 'Figure 11.4: Shape properties'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：形状属性
- en: In the particle system **module** (usually known as **Main**) set **Start Speed**
    to `10`. This will make the particles move faster.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粒子系统**模块**（通常称为**主模块**）中将**起始速度**设置为`10`。这将使粒子移动得更快。
- en: 'In the same module, set **Start Lifetime** to `0.5`. This specifies how long
    a particle will live. In this case, we have given a lifetime of half a second.
    In combination with the speed (10 meters per second), this makes the particles
    disappear after moving 5 meters:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的模块中，将**起始寿命**设置为`0.5`。这指定了粒子将存活多长时间。在这种情况下，我们给了一个半秒的寿命。与速度（每秒10米）结合，这使得粒子在移动5米后消失：
- en: '![](img/B18585_11_05.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_05.png)'
- en: 'Figure 11.5: Main Particle System module'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：主粒子系统模块
- en: Open the **Emission** module and set **Rate over Time** to `0`. This property
    specifies how many particles will be emitted per second, but for an explosion,
    we actually need a burst of particles, so we won’t emit particles constantly over
    time in this case.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**发射**模块并将**随时间变化率**设置为`0`。此属性指定每秒将发射多少粒子，但对于爆炸，我们实际上需要一个粒子爆发，所以在这种情况下我们不会随时间持续发射粒子。
- en: 'In the **Bursts** list, click the **+** button at the bottom, and in the created
    item in the list, set the count column to `100`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**爆发**列表中，点击底部的**+**按钮，然后在列表中创建的项目中，将计数列设置为`100`：
- en: '![](img/B18585_11_06.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_06.png)'
- en: 'Figure 11.6: Emission module'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：发射模块
- en: 'In the **Main** module (the one titled **Particle System**) set **Duration**
    to `1` and uncheck **Looping**. In our case, the explosion won’t repeat constantly;
    we just need one explosion:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主模块**（标题为**粒子系统**）中将**持续时间**设置为`1`并取消勾选**循环**。在我们的情况下，爆炸不会持续重复；我们只需要一次爆炸：
- en: '![](img/B18585_11_07.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_07.png)'
- en: 'Figure 11.7: Looping checkbox'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：循环复选框
- en: Now that the particle isn’t looping, you need to manually hit the **Play** button
    that is shown in the **Particle Effect** window in the bottom-right part of the
    Scene view to see the system. If you don’t see that window, remember to first
    select the GameObject with the Particle System in the Hierarchy.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在粒子不再循环，你需要手动点击场景视图右下角的**粒子效果**窗口中显示的**播放**按钮来查看系统。如果你看不到那个窗口，请记住首先在层次结构中选择带有粒子系统的GameObject。
- en: '![](img/B18585_11_08.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_08.png)'
- en: 'Figure 11.8: Particle system playback controls'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：粒子系统播放控制
- en: 'Set **Stop Action** to **Destroy**. This will destroy the object when the **Duration**
    time has passed. This will just work when you are running the game, so you can
    safely use this configuration while editing your scene:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**停止动作**设置为**销毁**。当**持续时间**时间过去时，这将销毁对象。这仅在运行游戏时才会起作用，因此你可以在编辑场景时安全地使用此配置：
- en: '![](img/B18585_11_09.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_09.png)'
- en: 'Figure 11.9: Stop Action set to Destroy'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：停止动作设置为销毁
- en: 'Set the **Start Size** of the **Main** module to `3`. This will make the particles
    bigger so they seem denser:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**主模块**的**起始大小**设置为`3`。这将使粒子更大，看起来更密集：
- en: '![](img/B18585_11_10.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_10.png)'
- en: 'Figure 11.10: Particle system Start Size'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：粒子系统起始大小
- en: Click on the down-pointing arrow at the right of the **Start Rotation** property
    of the **Main** module and select **Random Between Two Constants**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**主模块**中**起始旋转**属性右侧的向下箭头并选择**在两个常量之间随机**。
- en: 'Set the **Start Rotation** to `0` and `360` in the two input values that appeared
    after *step 14*. This allows us to give the particles a random rotation when they
    spawn to make them look slightly different from each other:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤14之后出现的两个输入值中将**起始旋转**设置为`0`和`360`。这允许我们在粒子生成时给它们一个随机旋转，使它们看起来略有不同：
- en: '![](img/B18585_11_11.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_11.png)'
- en: 'Figure 11.11: Random Start Rotation'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：随机起始旋转
- en: Now the particles behave as expected, but they don’t look as expected. Let’s
    change that. Create a new material by clicking on the **+** icon in the Project
    view and selecting **Material**. Call it `Explosion`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在粒子表现如预期，但看起来并不如预期。让我们改变一下。通过在项目视图中点击**+**图标并选择**材质**来创建一个新的材质。命名为`Explosion`。
- en: 'Set its shader to **Universal Render Pipeline/Particles/Unlit**. This is a
    special shader that is used to apply a texture to the Shuriken particle system:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其着色器设置为**Universal Render Pipeline/Particles/Unlit**。这是一个特殊的着色器，用于将纹理应用到Shuriken粒子系统：
- en: '![](img/B18585_11_12.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_12.png)'
- en: 'Figure 11.12: Particle system material shader'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：粒子系统材质着色器
- en: 'Download a smoke particle texture from the internet or the **Asset Store**.
    In this case, it is important to download one with a black background; ignore
    the others:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网或**资源商店**下载烟雾粒子纹理。在这种情况下，下载一个黑色背景的纹理很重要；忽略其他纹理：
- en: '![](img/B18585_11_13.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_13.png)'
- en: 'Figure 11.13: Smoke particle texture'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：烟雾粒子纹理
- en: Set this texture as the **Base Map** of the material.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此纹理设置为材料的**基础图**。
- en: 'Set the **Surface Type** to **Transparent** and the **Blending Mode** to **Additive**.
    Doing this will make the particles blend with each other, instead of being drawn
    on each other, to simulate a big mass of smoke instead of individual smoke puffs.
    We use **Additive** mode because our texture has a black background and because
    we want to create a lighting effect (the explosion will brighten the scene):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**表面类型**设置为**透明**，并将**混合模式**设置为**添加**。这样做会使粒子相互融合，而不是相互绘制，以模拟大量烟雾而不是单个烟雾团。我们使用**添加**模式，因为我们的纹理有黑色背景，并且我们想要创建一个光照效果（爆炸会使场景变亮）：
- en: '![](img/B18585_11_14.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_14.png)'
- en: 'Figure 11.14: Surface options for particles'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：粒子的表面选项
- en: 'Drag your material to the **Material** property of the **Renderer** module:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的材质拖动到**渲染器模块**的**材质**属性：
- en: '![](img/B18585_11_15.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_15.png)'
- en: 'Figure 11.15: Particle material settings'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：粒子材质设置
- en: 'Now your system should look like the following figure:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的系统应该看起来像以下图所示：
- en: '![](img/B18585_11_16.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_16.png)'
- en: 'Figure 11.16: Result of the previous settings'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：前述设置的输出结果
- en: With those steps, we have changed how the particles or billboards will spawn
    (using the **Emission** module), in which direction they will move (using the
    **Shape** module), how fast they will move, how long they will last, how big they
    will be (using the **Main** module), and what they will look like (using the **Renderer**
    module). Creating particle systems is a simple case of properly configuring their
    different settings. Of course, doing it properly is an art on its own; it requires
    creativity and knowledge of how to use all the settings and configurations they
    provide. So, to increase our skillset, let’s discuss some advanced modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们已经改变了粒子或广告牌的生成方式（使用**发射**模块），它们将向哪个方向移动（使用**形状**模块），它们的移动速度，它们的持续时间，它们的大小（使用**主**模块），以及它们的形状（使用**渲染器**模块）。创建粒子系统是正确配置它们不同设置的一个简单案例。当然，正确地做到这一点本身就是一门艺术；它需要创造力和了解如何使用它们提供的所有设置和配置。因此，为了提高我们的技能集，让我们讨论一些高级模块。
- en: Using advanced modules
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高级模块
- en: 'Our system looks nice, but we can improve it a lot, so let’s enable some new
    modules to increase its quality:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统看起来不错，但我们还可以大幅改进它，所以让我们启用一些新模块来提高其质量：
- en: 'Check the checkbox on the left of **Color over Lifetime** to enable it:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**颜色随寿命**的左侧复选框中勾选以启用它：
- en: '![](img/B18585_11_17.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_17.png)'
- en: 'Figure 11.17: Enabling the Color over Lifetime module'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：启用颜色随寿命模块
- en: Open the module by clicking on the title, and click the white bar on the right
    of the **Color** property. This will open the gradient editor.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击标题打开模块，然后点击**颜色**属性右侧的白色条。这将打开渐变编辑器。
- en: 'Click slightly to the right of the top-left white marker in the bar to create
    a new marker. Also, click slightly to the left of the top-right white marker to
    create the fourth marker. These markers will allow us to specify the transparency
    of the particles during their life:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条形图左上角的白色标记略微向右点击以创建一个新的标记。同样，在条形图右上角的白色标记略微向左点击以创建第四个标记。这些标记将允许我们指定粒子在其生命周期中的透明度：
- en: '![](img/B18585_11_18.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_18.png)'
- en: 'Figure 11.18: Color over Lifetime gradient editor'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：颜色随寿命渐变编辑器
- en: If you created unwanted markers, just drag them outside the window to remove
    them.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果创建了不需要的标记，只需将它们拖出窗口即可删除。
- en: 'Click on the top-left marker (not the one we created, the one that was already
    there) and set the **Alpha** slider at the bottom to `0`. Do the same with the
    top-right marker, as shown in the following screenshot. Now you should see the
    particles fading away instead of popping out of existence when the explosion is
    finishing:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的标记（不是我们创建的那个，而是已经存在的那个）并将底部的**Alpha**滑块设置为`0`。按照以下截图所示，对右上角的标记也进行同样的操作。现在你应该会看到粒子在爆炸结束时逐渐消失，而不是突然消失：
- en: '![](img/B18585_11_19.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_19.png)'
- en: 'Figure 11.19: Fade-in and fade-out gradient'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：淡入和淡出渐变
- en: Enable the **Limit Velocity over Lifetime** module by clicking on its checkbox.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击复选框启用**寿命内限制速度**模块。
- en: 'Set the **Dampen** setting to `0.1`. This will make the particles slowly stop
    instead of continuing to move:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**阻尼**设置调整为`0.1`。这将使粒子缓慢停止而不是继续移动：
- en: '![](img/B18585_11_20.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_20.png)'
- en: 'Figure 11.20: Dampen the velocity to make the particles stop'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：阻尼速度以使粒子停止
- en: 'Enable **Rotation over Lifetime** and set the **Angular Velocity** between
    `-90` and `90`. Remember that you should set the value in **Random Between Two
    Constants** by clicking on the down-pointing arrow to the right of the property.
    Now the particles should rotate during their lives to simulate more motion:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**寿命内的旋转**并设置**角速度**在`-90`和`90`之间。请记住，您应该通过点击属性右侧的向下箭头在**在两个常量之间随机**中设置值。现在粒子应该在它们的寿命期间旋转以模拟更多运动：
- en: '![](img/B18585_11_21.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_21.png)'
- en: 'Figure 11.21: Random rotation velocity'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21：随机旋转速度
- en: Some of these effects will be very subtle given the short **Lifetime** we set
    in the **Main Module** when we just created the particle. Feel free to increase
    the **Lifetime** value to see those effects in more detail, but consider that
    this could lead to an excessive number of particles if you spawn them frequently,
    reducing performance. Just be wary about how they impact your performance when
    tweaking those values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建粒子时，在**主模块**中设置的**寿命**很短，因此这些效果将非常微妙。您可以随意增加**寿命**值以更详细地查看这些效果，但请注意，如果您频繁地生成粒子，这可能会导致粒子数量过多，从而降低性能。只是要注意调整这些值时它们对性能的影响。
- en: 'As you can see, there are lots of extra modules that can be enabled and disabled
    to add layers of behavior on top of the existing ones, so again, use them creatively
    to create all kinds of effects. Remember that you can create Prefabs of these
    systems to replicate them all over your scene. I also recommend searching for
    and downloading particle effects from the Asset Store to see how other people
    have used the same system to create amazing effects. Seeing a variety of different
    systems is the best way to learn how to create them, and that is what we are going
    to do in the next section: create more systems!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有许多额外的模块可以启用和禁用，以在现有模块之上添加行为层，因此再次，要创造性地使用它们来创建各种效果。请记住，您可以为这些系统创建Prefab以在场景中复制它们。我还建议在Asset
    Store中搜索并下载粒子效果，以了解其他人如何使用相同的系统创建惊人的效果。看到各种不同的系统是学习如何创建它们的最佳方式，这就是我们在下一节将要做的：创建更多系统！
- en: Creating fluid simulations
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流体模拟
- en: As we said, the best way to learn how to create particle systems is to keep
    looking for already-created particle systems and explore how people have used
    the various system settings to create completely different simulations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，学习如何创建粒子系统的最佳方式是继续寻找已经创建的粒子系统，并探索人们如何使用各种系统设置来创建完全不同的模拟。
- en: 'In this section, we will learn how to create the following effects using particle
    systems:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用粒子系统创建以下效果：
- en: A waterfall effect
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瀑布效果
- en: A bonfire effect
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 篝火效果
- en: Let’s start with the simplest one, the waterfall effect.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的一个开始，瀑布效果。
- en: Creating a waterfall effect
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建瀑布效果
- en: 'In order to do this, follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤操作：
- en: Create a new particle system (**GameObject** | **Effects** | **Particle System**).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的粒子系统（**GameObject** | **Effects** | **Particle System**）。
- en: 'Set **Shape** to **Edge** and its **Radius** to `5` in the **Shape** module.
    This will make the particles spawn along a line of emission:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**形状模块**中将**形状**设置为**边缘**，并将其**半径**设置为`5`。这将使粒子沿着发射线生成：
- en: '![](img/B18585_11_22.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_22.png)'
- en: 'Figure 11.22: Edge shape'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22：边缘形状
- en: Set the **Rate over Lifetime** of the **Emission** module to `50`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**发射模块**的**寿命内速率**设置为`50`。
- en: 'Set the **Start Size** of the **Main** module to `3` and the **Start Lifetime**
    to `3`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**主模块**的**起始大小**设置为`3`，将**起始寿命**设置为`3`：
- en: '![](img/B18585_11_23.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_23.png)'
- en: 'Figure 11.23: Main module settings'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23：主模块设置
- en: 'Set the **Gravity Modifier** of the Main module to `0.5`. This will make the
    particles fall down:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主模块的**重力修改器**设置为`0.5`。这将使粒子下落：
- en: '![](img/B18585_11_24.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_24.png)'
- en: 'Figure 11.24: Gravity Modifier in the Main module'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24：主模块中的重力修改器
- en: 'Use the same `Explosion` material we created previously for this system:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前创建的相同的`Explosion`材质为这个系统：
- en: '![](img/B18585_11_25.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_25.png)'
- en: 'Figure 11.25: Explosion particle material'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25：爆炸粒子材质
- en: Enable **Color Over Lifetime** and open the **Gradient** editor.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**生命周期内颜色**并打开**渐变**编辑器。
- en: 'Click the bottom-right marker, and this time you should see a color picker
    instead of an alpha slider. The top markers allow you to change the transparency
    over time, while the bottom ones change the color of the particles over time.
    Set a light blue color in this marker:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下角的标记，这次你应该看到一个颜色选择器而不是alpha滑块。顶部的标记允许你随时间改变透明度，而底部的标记随时间改变粒子的颜色。在这个标记中设置浅蓝色：
- en: '![](img/B18585_11_26.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_26.png)'
- en: 'Figure 11.26: White to light blue gradient'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26：从白色到浅蓝色的渐变
- en: 'As a challenge, I suggest you add a little particle system where this one ends
    to create some water splashes, simulating the water colliding with a lake at the
    bottom. Now we can add this particle system to one of the hills of our scene to
    decorate it, like in the following screenshot. I have adjusted the system a little
    bit to look better in this scenario. I challenge you to tweak it by yourself to
    make it look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，我建议你添加一个小粒子系统，在这个粒子系统结束的地方创建一些水花，模拟水与底部湖泊的碰撞。现在我们可以将这个粒子系统添加到场景中的一个山丘上以装饰它，就像以下截图所示。我已经稍微调整了系统，使其在这个场景中看起来更好。我挑战你自己调整它，使其看起来像这样：
- en: '![](img/B18585_11_27.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_27.png)'
- en: 'Figure 11.27: The waterfall particle system being applied to our current scene'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27：瀑布粒子系统应用于当前场景
- en: 'Now, let’s create another effect: a bonfire.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个效果：篝火。
- en: Creating a bonfire effect
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建篝火效果
- en: 'In order to create a bonfire, do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建篝火，请执行以下操作：
- en: Create a particle system like we did in the section *Creating a basic particle
    system with Shuriken*, in **GameObject | Effects | Particle System**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个粒子系统，就像我们在*使用Shuriken创建基本粒子系统*部分所做的那样，在**GameObject | Effects | Particle
    System**中。
- en: 'Look for a **Fire Particle Texture Sheet** texture on the internet or the Asset
    Store. This kind of texture should look like a grid of different flame textures.
    The idea is to apply a flame animation to our particles swapping all those mini
    textures:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在互联网或资源商店上寻找一个**火焰粒子纹理图**。这种纹理应该看起来像不同火焰纹理的网格。想法是将火焰动画应用到我们的粒子中，交换所有这些小纹理：
- en: '![](img/B18585_11_28.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_28.png)'
- en: 'Figure 11.28: Particles texture sprite sheet'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28：粒子纹理精灵图
- en: Create a particle **material** that uses the **Universal Render Pipeline/Particles/Unlit**
    shader.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用**Universal Render Pipeline/Particles/Unlit**着色器的粒子**材质**。
- en: Set the flames sprite sheet texture as the **Base Map**.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将火焰精灵图纹理设置为**基础图**。
- en: Set the color at the right of the **Base Map** to white.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**基础图**右侧的颜色设置为白色。
- en: 'Set this material as the particle material. Remember to set **Surface Type**
    to **Transparent** and **Blending Mode** to **Additive**:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此材质设置为粒子材质。请记住将**表面类型**设置为**透明**，并将**混合模式**设置为**叠加**：
- en: '![](img/B18585_11_29.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_29.png)'
- en: 'Figure 11.29: A material with a particle sprite sheet'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29：带有粒子精灵图的材质
- en: 'Enable the **Texture Sheet Animation** module and set the **Tiles** property
    according to your fire sheet. In my case, I have a grid of 4x4 sprites, so I put
    `4` in **X** and `4` in **Y**. After this, you should see the particles swapping
    textures:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**纹理图动画**模块，并根据您的火焰图设置**瓷砖**属性。在我的情况下，我有一个4x4精灵的网格，所以我将`4`放在**X**上，将`4`放在**Y**上。之后，你应该会看到粒子在交换纹理：
- en: '![](img/B18585_11_30.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_30.png)'
- en: 'Figure 11.30: Enabling Texture Sheet Animation'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30：启用纹理图动画
- en: Set **Start Speed** to `0` and **Start Size** to `1.5` in the Main module.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主模块中将**起始速度**设置为`0`，将**起始大小**设置为`1.5`。
- en: Set **Radius** to `0.5` in **Shape**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**形状**中设置**半径**为`0.5`。
- en: 'Create a second particle system and make it a child of the fire system:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个粒子系统并将其设置为火焰系统的子系统：
- en: '![](img/B18585_11_31.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_31.png)'
- en: 'Figure 11.31: Parenting particle systems'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31：父子粒子系统
- en: Apply the **Explosion** material from the explosion example.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用爆炸示例中的**爆炸**材质。
- en: Set **Angle** to `0` and **Radius** to `0.5` in the **Shape** module.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**形状**模块中将**角度**设置为`0`，将**半径**设置为`0.5`。
- en: 'The system should look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应该看起来像这样：
- en: '![](img/B18585_11_32.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_32.png)'
- en: 'Figure 11.32: Result of combining fire and smoke particle systems'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32：结合火焰和烟雾粒子系统的结果
- en: As you can see, you can combine several particle systems to create a single
    effect. Take care when doing this because it’s easy to emit too many particles
    and affect the game’s performance. Particles are not cheap and may cause a reduction
    in the game’s **FPS (Frames Per Second)** if you are not cautious with them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以组合几个粒子系统来创建一个单一的效果。在做这件事时要小心，因为很容易发射过多的粒子并影响游戏性能。粒子并不便宜，如果你对它们不够谨慎，可能会降低游戏的**FPS（每秒帧数）**。
- en: So far, we have explored one of the Unity systems that you can use to create
    these kinds of effects, and while this system is enough for most situations, Unity
    recently released a new one that can generate more complex effects, called **Visual
    Effect Graph**. Let’s see how to use it and see how it differs from Shuriken.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了你可以用来创建这类效果的一种Unity系统，虽然这个系统对于大多数情况来说已经足够，但Unity最近发布了一个可以生成更复杂效果的新系统，称为**视觉效果图**。让我们看看如何使用它，以及它与Shuriken有何不同。
- en: Creating complex simulations with Visual Effect Graph
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视觉效果图创建复杂模拟
- en: 'The particle system we have used so far is called Shuriken, and it handles
    all calculations in the CPU. This has both pros and cons. A pro is that it can
    run on all possible devices that Unity supports, regardless of their capabilities
    (all of them have CPUs), but a con is that we can exceed CPU capabilities easily
    if we are not cautious with the number of particles we emit. Modern games require
    more complex particle systems to generate believable effects, and this kind of
    CPU-based particle system solution has started to reach its limit. This is where
    the Visual Effect Graph comes in:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止使用的粒子系统被称为Shuriken，它处理所有在CPU上的计算。这既有优点也有缺点。优点是它可以在Unity支持的所有可能的设备上运行，无论它们的性能如何（它们都有CPU），但缺点是如果我们对发射的粒子数量不够谨慎，我们很容易超过CPU的能力。现代游戏需要更复杂的粒子系统来生成可信的效果，而这种基于CPU的粒子系统解决方案已经开始达到其极限。这就是视觉效果图发挥作用的地方：
- en: '![](img/B18585_11_33.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_33.png)'
- en: 'Figure 11.33: On the left, a massive particle system, and on the right, an
    example of a Visual Effect Graph'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33：左侧是一个大规模粒子系统，右侧是视觉效果图的示例
- en: '**Visual Effect Graph** is a GPU-based particle system solution, meaning that
    the system is executed in the video card instead of the CPU. That’s because video
    cards are far more efficient at executing lots and lots of little simulations,
    like the ones each particle of a system needs, so we can reach far higher orders
    of magnitude in the number of particles with the GPU than we can with the CPU.
    The con here is that we need a fairly modern GPU that has **compute shader** capabilities
    to support this system, so we will exclude certain target platforms using this
    system (forget about most mobile phones), so use it if your target platform supports
    it (mid- to high-end PCs, consoles, and some high-end phones).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉效果图**是一个基于GPU的粒子系统解决方案，这意味着系统是在显卡上而不是CPU上执行的。这是因为显卡在执行大量小模拟方面要高效得多，比如系统中的每个粒子都需要，所以我们可以在GPU上达到比CPU更高的粒子数量级别。这里的缺点是我们需要一个具有**计算着色器**功能的相当现代的GPU来支持这个系统，因此我们将排除使用这个系统的一些目标平台（忘记大多数手机），所以如果你的目标平台支持它（中高端PC、游戏机和一些高端手机），请使用它。'
- en: 'In this section, we will discuss the following topics of Visual Effect Graph:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下关于视觉效果图的主题：
- en: Installing Visual Effect Graph
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装视觉效果图
- en: Creating and analyzing a Visual Effect Graph
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和分析视觉效果图
- en: Creating a rain effect
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建雨效果
- en: Let’s start by seeing how we can add support for Visual Effect Graph in our
    project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何在项目中添加对视觉效果图的支持。
- en: Installing Visual Effect Graph
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装视觉效果图
- en: So far, we have used lots of Unity features that were already installed in our
    project, but Unity can be extended with a myriad of plugins, both official and
    third-party. Visual Effect Graph is one of those features that needs to be independently
    installed if you are using **Universal Render Pipeline** **(URP)**. We can do
    that using the Package Manager, a Unity window dedicated to managing official
    Unity plugins.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了大量已经安装在我们项目中的Unity功能，但Unity可以通过大量插件进行扩展，包括官方和第三方插件。视觉效果图就是那些需要独立安装的功能之一，如果你使用的是**通用渲染管线**
    **(URP)**。我们可以使用包管理器来完成这项工作，这是一个专门用于管理官方Unity插件的Unity窗口。
- en: Something to think about when you are installing those packages is that each
    package or plugin has its own version, independent of the Unity version. That
    means that you can have Unity 2022.1 installed, but Visual Effect Graph 13.1.8
    or whatever version you want, and you can actually update the package to a newer
    version without upgrading Unity. This is important because some versions of these
    packages require a minimum version of Unity—for example, Visual Effect Graph 13.1.8
    requires Unity 2022.1 as a minimum. Moreover, some packages depend on other packages
    and specific versions of those packages, so we need to ensure we have the correct
    versions of every package to ensure compatibility. To be clear, the dependencies
    of a package are installed automatically, but sometimes we can have them installed
    separately, so in that scenario, we need to check the required version. It sounds
    complicated, but it is simpler than it sounds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装这些包时需要考虑的是，每个包或插件都有自己的版本，与 Unity 版本无关。这意味着您可以安装 Unity 2022.1，但也可以安装 Visual
    Effect Graph 13.1.8 或您想要的任何版本，并且实际上可以更新包到新版本而不必升级 Unity。这很重要，因为某些版本的这些包需要 Unity
    的最低版本——例如，Visual Effect Graph 13.1.8 需要 Unity 2022.1 作为最低版本。此外，一些包依赖于其他包和这些包的特定版本，因此我们需要确保我们拥有每个包的正确版本以确保兼容性。明确来说，包的依赖项会自动安装，但有时我们可以单独安装它们，因此在这种情况下，我们需要检查所需版本。听起来很复杂，但实际上比听起来简单。
- en: 'At the time of writing this book, in order to get Visual Effect Graph working
    properly we need version 13.1.8, and also we need the same version of **Universal
    RP**. Yes, Universal RP is another feature you can install using the Package Manager,
    but as we created the project using the Universal RP template, it was already
    installed for us with the proper version. With that in mind, let’s install the
    Visual Effect Graph as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，为了使视觉效果图正常工作，我们需要版本 13.1.8，并且还需要相同版本的**Universal RP**。是的，Universal RP
    是您可以使用包管理器安装的另一个功能，但因为我们使用 Universal RP 模板创建了项目，所以它已经为我们安装了正确的版本。考虑到这一点，让我们按照以下步骤安装视觉效果图：
- en: 'In the top menu of Unity, go to **Window | Package Manager**:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 的顶部菜单中，转到**窗口 | 包管理器**：
- en: '![](img/B18585_11_34.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_34.png)'
- en: 'Figure 11.34: Package Manager location'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.34：包管理器位置
- en: 'Remember to be sure the **Packages** dropdown is in **Unity Registry** mode,
    to see the Unity official packages list:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保**包**下拉菜单处于**Unity 注册表**模式，以查看 Unity 官方包列表：
- en: '![](img/B18585_11_35.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_35.png)'
- en: 'Figure 11.35: Package Manager Unity Registry mode'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.35：包管理器 Unity 注册表模式
- en: In the left column, locate **Universal RP** and check whether it says 13.1.8
    or higher to the right. If it does, jump to *step 6*. Remember, though, that a
    higher version may look different or have different steps for use than the ones
    displayed in this chapter.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列中，找到**Universal RP**并检查右侧是否显示 13.1.8 或更高版本。如果是这样，跳转到*步骤 6*。不过，请记住，更高版本可能看起来不同，或者使用步骤与本章中显示的不同。
- en: 'If you don’t have version 13.1.8 or higher, click on the right-pointing arrow
    at the left to display a list of all possible versions to install. Locate 13.1.8
    and click it. In my case it says **Currently installed** as I have that version
    already installed in the project, and there’s no other one available for Unity
    2022:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有 13.1.8 或更高版本，点击左侧的指向右的箭头以显示所有可能的安装版本。找到 13.1.8 并点击它。在我的情况下，它显示为**当前已安装**，因为我已经在项目中安装了该版本，并且没有其他版本可用于
    Unity 2022：
- en: '![](img/B18585_11_36.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_36.png)'
- en: 'Figure 11.36: Package version selector'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.36：包版本选择器
- en: Click on the **Update to 13.1.8** button in the bottom-right part of the window
    and wait for the package to update.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的右下角点击**更新到 13.1.8**按钮，等待包更新。
- en: 'Look for the **Visual Effect Graph** package on the left side of the window.
    As you did with Universal RP, make sure you select version 11.0.0 or the closest
    higher available:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的左侧查找**视觉效果图**包。就像您使用 Universal RP 一样，确保您选择版本 11.0.0 或更高版本：
- en: '![](img/B18585_11_37.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_37.png)'
- en: 'Figure 11.37: Visual Effect Graph package'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.37：视觉效果图包
- en: Click the **Install** button at the bottom-right of the window and wait for
    the package to install. Sometimes it is recommended to restart Unity after installing
    packages, so save your changes and restart Unity.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右下角的**安装**按钮，等待包安装。有时在安装包后重启 Unity 是推荐的，所以保存您的更改并重启 Unity。
- en: Now that we have installed Visual Effect Graph, let’s create our first particle
    system using it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了视觉效果图，让我们使用它创建第一个粒子系统。
- en: Creating and analyzing a Visual Effect Graph
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和分析视觉效果图
- en: 'The method to create a particle system using Visual Effect Graph is similar
    to a regular Particle System. We will chain and configure modules as parts of
    the behavior of the particles, each module adding some specific behavior, but
    the way we do it is very different than with Shuriken. First, we need to create
    a **Visual Effect Graph**, an asset that will contain all the modules and configurations,
    and then make a GameObject that will execute the Graph asset to spawn particles.
    Let’s do that with the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视觉效果图创建粒子系统的方法与常规粒子系统类似。我们将链式配置模块作为粒子行为的一部分，每个模块添加一些特定的行为，但我们的操作方式与Shuriken非常不同。首先，我们需要创建一个**视觉效果图**，这是一个将包含所有模块和配置的资产，然后创建一个将执行图资产以生成粒子的GameObject。让我们按照以下步骤进行：
- en: 'In the Project window, click on the **+** button and look for **Visual Effects
    | Visual Effect Graph**:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，点击**+**按钮，查找**视觉效果 | 视觉效果图**：
- en: '![](img/B18585_11_38.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_38.png)'
- en: 'Figure 11.38: Visual Effect Graph'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.38：视觉效果图
- en: 'Create an **Empty** GameObject using the **GameObject** | **Create Empty**
    option:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **创建空对象**选项创建一个**空对象**：
- en: '![](img/B18585_11_39.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_39.png)'
- en: 'Figure 11.39: Empty GameObject creation'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.39：创建空GameObject
- en: Select the created object and look at the **Inspector**.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建的物体，并查看**检查器**。
- en: 'Using the **Add Component** search bar, look for the **Visual Effect** component
    and click on it to add it to the object:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加组件**搜索栏，查找**视觉效果**组件，并点击它以将其添加到对象：
- en: '![](img/B18585_11_40.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_40.png)'
- en: 'Figure 11.40: Adding a component to the Visual Effect Graph'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.40：向视觉效果图添加组件
- en: 'Drag the **Visual Effect** asset we created to the **Asset Template** property
    of the **Visual Effect** component in our GameObject:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们创建的**视觉效果**资产拖动到我们的GameObject中**视觉效果**组件的**资产模板**属性：
- en: '![](img/B18585_11_41.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_41.png)'
- en: 'Figure 11.41: Visual Effect using the previously created Visual Effect asset'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.41：使用先前创建的视觉效果资产进行视觉效果
- en: 'You should see clock particles being emitted from our object, which is the
    default behavior included in a new Visual Effect asset, meaning it’s being executed
    correctly:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到从我们的物体中发射出时钟粒子，这是新视觉效果资产中包含的默认行为，意味着它正在正确执行：
- en: '![](img/B18585_11_42.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_42.png)'
- en: 'Figure 11.42: Default Visual Effect asset results'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.42：默认视觉效果资产结果
- en: 'Now that we have a base effect, let’s create something that requires a lot
    of particles, such as dense rain. Before doing so, we will explore some core concepts
    of Visual Effect Graph. If you double-click the Visual Effect asset, you will
    see the following editor:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基础效果，让我们创建一些需要大量粒子的东西，比如密集的雨。在这样做之前，我们将探索视觉效果图的一些核心概念。如果您双击视觉效果资产，您将看到以下编辑器：
- en: '![](img/B18585_11_43.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_43.png)'
- en: 'Figure 11.43: Visual Effect Graph editor window'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.43：视觉效果图编辑器窗口
- en: This window is composed of several interconnected nodes, generating a flow of
    actions to be executed. As with the Shader Graph, you can navigate this window
    by keeping the *Alt* key (*Option* on Mac) pressed and dragging with the mouse
    the empty areas of the graph. At first, it seems similar to the Shader Graph,
    but it works a little bit differently, so let’s study each section of the default
    graph.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口由几个相互连接的节点组成，生成要执行的动作流。与着色器图一样，您可以通过按住*Alt*键（Mac上的*Option*）并使用鼠标拖动图中的空白区域来导航此窗口。起初，它看起来与着色器图相似，但它的工作方式略有不同，所以让我们研究默认图的每个部分。
- en: 'The first area to explore is the dotted one that contains three nodes. This
    is what Unity calls a **System**. A System is a set of nodes that defines how
    a particle will behave, and you can have as many as you want, which is the equivalent
    of having several particle system objects. Each System is composed of **Contexts**,
    the nodes inside the dotted area, and in this case, we have **Initialize Particle**,
    **Update Particle**, and **Output Particle Quad**. Each Context represents a different
    stage of the particle system logic flow, so let’s define what each Context in
    our graph does:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首个要探索的区域是包含三个节点的虚线区域。这是Unity所说的**系统**。系统是一组节点，定义了粒子将如何表现，你可以拥有任意多个，这相当于拥有多个粒子系统对象。每个系统由**上下文**组成，即虚线区域内的节点，在这种情况下，我们有**初始化粒子**、**更新粒子**和**输出粒子四边形**。每个上下文代表粒子系统逻辑流程的不同阶段，因此让我们定义我们图中的每个上下文的作用：
- en: '**Initialize Particle**: This defines the initial data of each emitted particle,
    such as position, color, speed, and size. It is similar to the **Start** properties
    in the Main module of the particle system we saw at the beginning of this chapter.
    The logic in this node will only execute when a new particle is emitted.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化粒子**：这定义了每个发射粒子的初始数据，例如位置、颜色、速度和大小。它类似于我们在本章开头看到的粒子系统主模块中的**启动**属性。此节点中的逻辑仅在发射新粒子时执行。'
- en: '**Update Particle**: Here, we can apply modifications to the data of the living
    particles. We can change particle data such as the current velocity or particle
    size of all the frames. This is similar to the **Overtime** nodes of the Shuriken
    particle systems.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新粒子**：在这里，我们可以对活粒子的数据进行修改。我们可以更改粒子数据，如所有帧的当前速度或粒子大小。这类似于Shuriken粒子系统的**随时间**节点。'
- en: '**Output Particle Quad**: This Context will be executed when the particle needs
    to be rendered. It will read the particle data to see where to render, how to
    render, which texture and color to use, and the different visual settings. This
    is similar to the renderer module of the previous particle system.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出粒子四边形**：当粒子需要渲染时，将执行此上下文。它将读取粒子数据以确定渲染位置、渲染方式、使用的纹理和颜色以及不同的视觉设置。这类似于先前粒子系统的渲染器模块。'
- en: 'Inside each Context, apart from some base configurations, we can add **Blocks**.
    Each Block is an action that will be executed in the Context. We have actions
    that can be executed in any Context and then some specific Context actions. As
    an example, we can use an **Add Position Block** in the Initialize Particle Context
    to move the initial particle position, but if we use the same Block in the Update
    Particle Context, it will move the particle constantly. So basically, Contexts
    are different situations that happen in the life of the particle, and Blocks are
    actions that are executed in those situations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个上下文中，除了一些基本配置外，我们还可以添加**块**。每个块都是在上下文中执行的操作。我们有可以在任何上下文中执行的动作，以及一些特定上下文动作。例如，我们可以在**初始化粒子**上下文中使用**添加位置块**来移动初始粒子位置，但如果我们在**更新粒子**上下文中使用相同的块，它将使粒子持续移动。所以基本上，上下文是粒子生命周期中发生的情况，而块是在这些情况下执行的动作：
- en: '![](img/B18585_11_44.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_44.png)'
- en: 'Figure 11.44: A Set Velocity Random Block inside the Initialize Particle Context.
    This sets the initial velocity of a particle'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.44：初始化粒子上下文中的一个设置速度随机块。这设置了粒子的初始速度
- en: Also, we can have **Standalone Contexts**, Contexts outside Systems, such as
    **Spawn**. This Context is responsible for telling the System that a new particle
    needs to be created. We can add Blocks to specify when the context will tell the
    system to create the particle, such as at a fixed rate over time, bursts, and
    so on. The idea is that Spawn will create particles according to its Blocks, while
    a System is responsible for initializing, updating, and rendering each of them,
    again, according to the blocks we set up inside each one of those Contexts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以有**独立上下文**，即系统之外的上下文，例如**生成**。此上下文负责告诉系统需要创建新的粒子。我们可以添加块来指定上下文何时告诉系统创建粒子，例如以固定速率随时间进行、爆发等。其理念是，生成将根据其块创建粒子，而系统则负责根据我们在每个上下文中设置的块初始化、更新和渲染每个粒子。
- en: So, we can see that there are lots of similarities with Shuriken, but the way
    to create a system here is quite different. Let’s reinforce this by creating a
    rain effect, which will require lots of particles—a nice use case for Visual Effect
    Graph.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到与 Shuriken 有很多相似之处，但在这里创建系统的方式相当不同。让我们通过创建一个雨效果来加强这一点，这将需要大量的粒子——这是
    Visual Effect Graph 的一个很好的用例。
- en: Creating a rain effect
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建雨效果
- en: 'In order to create this effect, do the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建此效果，请执行以下操作：
- en: 'Set the **Capacity** property of the **Initialize Particle** Context to `10000`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**初始化粒子**上下文的**容量**属性设置为`10000`：
- en: '![](img/B18585_11_45.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_45.png)'
- en: 'Figure 11.45: Initialize Particle Context'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.45：初始化粒子上下文
- en: 'Set the **Rate** of the **Constant Spawn Rate** of the **Spawn** context to
    `10000`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Spawn**上下文的**恒定生成速率**的**速率**设置为`10000`：
- en: '![](img/B18585_11_46.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_46.png)'
- en: 'Figure 11.46: Constant Spawn Rate Block'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.46：恒定生成速率块
- en: 'Set the **A** and **B** properties to `0`, `-50`, and `0` and `0`, `-75`, and
    `0` respectively in the **Set Velocity Random** block in the **Initialize Particle**
    Context. This will set a random velocity pointing downward for our particles:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**初始化粒子**上下文中的**设置速度随机**块中，将**A**和**B**属性分别设置为`0`，`-50`和`0`，以及`0`，`-75`和`0`。这将为我们设置一个指向下方的随机速度：
- en: '![](img/B18585_11_47.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_47.png)'
- en: 'Figure 11.47: Set Velocity Random Block'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.47：设置速度随机块
- en: Right-click the **Initialize Particle** title, and select **Create Block**.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**初始化粒子**标题，并选择**创建块**。
- en: 'Search for the **Set Position Random** block and click on it:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索**设置位置随机**块并点击它：
- en: '![](img/B18585_11_48.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_48.png)'
- en: 'Figure 11.48: Adding blocks'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.48：添加块
- en: Set the **A** and **B** properties of the **Set Position Random** Block to `-50`,
    `0`, and `-50` and `50`, `0`, and `50` respectively. This will define an initial
    area in which to randomly spawn the particle.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**设置位置随机**块的**A**和**B**属性分别设置为`-50`，`0`和`-50`，`50`，`0`和`50`。这将定义一个初始区域，在该区域内随机生成粒子。
- en: Click the arrow at the left of the **Bounds** property of the **Initialize Particle**
    Block to display its properties, and set **Center** and **Size** to `0`, `-12.5`,
    and `0` and `100`, `25`, and `100` respectively. This will define the area where
    the particles should be visible. Particles can actually move outside this area,
    but it is important to render the particles only in the areas we are interested
    in them being visible.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**初始化粒子**块中**边界**属性的左侧箭头以显示其属性，并将**中心**和**大小**分别设置为`0`，`-12.5`和`0`，以及`100`，`25`和`100`。这将定义粒子应可见的区域。粒子实际上可以移动到这个区域之外，但只渲染我们感兴趣它们可见的区域是很重要的。
- en: Search `Frustum culling` on the internet for more information about bounds.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上搜索`视锥剔除`以获取有关边界的更多信息。
- en: '![](img/B18585_11_49.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_49.png)'
- en: 'Figure 11.49: Configuring blocks'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.49：配置块
- en: 'Select the GameObject that is executing the system, and in the bottom-right
    window in the Scene view check the **Show Bounds** checkbox to see the previously
    defined bounds:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择执行系统的 GameObject，在场景视图的右下角窗口中检查**显示边界**复选框以查看之前定义的边界：
- en: '![](img/B18585_11_50.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_50.png)'
- en: 'Figure 11.50: Visual Effect playback controls'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.50：视觉效果播放控制
- en: 'If you don’t see the window at the bottom right, click the **VE** (Visual Effect)
    button at the top-left side of the screen to display it. This button will be shown
    only if you have selected the **Rain** visual effect GameObject in the **Hierarchy**:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果看不到右下角的窗口，请点击屏幕左上角的**VE**（视觉效果）按钮以显示它。此按钮仅在您在**层次结构**中选择了**雨**视觉效果 GameObject
    时才会显示：
- en: '![](img/B18585_11_51.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_51.png)'
- en: 'Figure 11.51: Another way to display the Visual Effect playback controls'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.51：另一种显示视觉效果播放控制的方式
- en: 'If you can’t see the changes being applied, click the **Compile** button in
    the top left of the window, the one that looks like a paper bin beneath a downward-pointing
    arrow. Also, you can save your changes using *Ctrl* + *S* (*Command* + *S* on
    Mac):'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果看不到应用的变化，请点击窗口左上角的**编译**按钮，它看起来像箭头下方的纸篓。此外，您可以使用*Ctrl* + *S*（在 Mac 上为*Command*
    + *S*）保存您的更改：
- en: '![](img/B18585_11_52.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_52.png)'
- en: 'Figure 11.52: VFX asset saving controls'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.52：VFX 资产保存控制
- en: 'Set the object position to cover the whole base area. In my case, the position
    is `100`, `37`, and `100`. Remember that you need to change the **Position** of
    the **Transform** component for this:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象位置设置为覆盖整个底部区域。在我的例子中，位置是 `100`、`37` 和 `100`。记住，你需要更改**变换**组件的**位置**来完成这个操作：
- en: '![](img/B18585_11_53.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_53.png)'
- en: 'Figure 11.53: Setting a Transform position'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.53：设置变换位置
- en: 'Set the **A** and **B** properties of the **Set Lifetime Random** Block in
    the **Initialize Particle** to `0.5`. This will make the particles have a shorter
    life, ensuring that they are always inside the bounds:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**初始化粒子**中**设置寿命随机**块的**A**和**B**属性设置为 `0.5`。这将使粒子寿命更短，确保它们始终在边界内：
- en: '![](img/B18585_11_54.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_54.png)'
- en: 'Figure 11.54: Set Lifetime Random Block'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.54：设置寿命随机块
- en: 'Change the **Main Texture** property of the **Output Particle Quad** Context
    to another texture. In this case, the previously downloaded smoke texture can
    work here, even though it’s not water, because we will modify its appearance in
    a moment. Also, you can try to download a water droplet texture if you want to:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**输出粒子四边形**上下文的**主纹理**属性更改为另一个纹理。在这种情况下，之前下载的烟雾纹理可以在这里使用，即使它不是水，因为我们将在稍后修改其外观。你也可以尝试下载一个水滴纹理，如果你想的话：
- en: '![](img/B18585_11_55.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_55.png)'
- en: 'Figure 11.55: VFX Graph Main Texture'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.55：VFX 图主纹理
- en: 'Set **Blend Mode** of the **Output Particle Quad** Context to **Additive**:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**输出粒子四边形**上下文的**混合模式**设置为**添加**：
- en: '![](img/B18585_11_56.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_56.png)'
- en: 'Figure 11.56: Additive mode of VFX Graph'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.56：VFX 图的添加模式
- en: 'We need to stretch our particles a little bit to look like actual raindrops
    instead of falling balls. Before accomplishing that, first we need to change the
    orientation of our particles, so they don’t point at the camera all the time.
    In order to do this, right-click on the **Orient Block** in the **Output Particle
    Quad** Context and select **Delete** (or press *Delete* on PC or *Command* + *Backspace*
    on Mac):'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要稍微拉伸我们的粒子，使其看起来像真正的雨滴而不是下落的球体。在完成这个操作之前，首先我们需要改变我们粒子的方向，这样它们就不会总是指向摄像机。为了做到这一点，在**输出粒子四边形**上下文中的**定向块**上右键单击并选择**删除**（或在
    PC 上按 *Delete* 或在 Mac 上按 *Command* + *Backspace*）：
- en: '![](img/B18585_11_57.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_57.png)'
- en: 'Figure 11.57: Deleting a block'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.57：删除一个块
- en: We want to stretch our particles according to their velocity direction. Another
    preparation step before actually doing that is to select the title of the **Output
    Particle Quad** context and hit the space bar to look for a block to add. In this
    case, we need to search and add the **Orient Along Velocity** block.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望根据粒子的速度方向拉伸粒子。在实际上进行这一操作之前，另一个准备步骤是选择**输出粒子四边形**上下文的标题并按空格键以查找要添加的块。在这种情况下，我们需要搜索并添加**沿速度定向**块。
- en: 'Add a **Set Scale** Block to the **Initialize Particle** Context and set the
    **Scale** property to `0.25`, `1.5`, and `0.25`. This will stretch the particles
    to look like falling drops:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**设置比例**块添加到**初始化粒子**上下文，并将**比例**属性设置为 `0.25`、`1.5` 和 `0.25`。这将使粒子拉伸，看起来像下落的雨滴：
- en: '![](img/B18585_11_58.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_58.png)'
- en: 'Figure 11.58: Set Scale Block'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.58：设置比例块
- en: 'Click the **Compile** button in the top-left window again to see the changes.
    Your system should look like this:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击左上角的**编译**按钮以查看更改。你的系统应该看起来像这样：
- en: '![](img/B18585_11_59.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_59.png)'
- en: 'Figure 11.59: Rain results'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.59：雨效果
- en: We have just modified lots of different properties of the Visual Effect Graph,
    but if you want to have two instances of the same Visual Effect Graph, but with
    slight differences, I recommend you look at the Blackboard feature, which will
    allow you to expose properties in the Inspector. For example, you can make less
    dense rain on another scene, making the spawn rate lower, or change the particle
    color to make acid rain, all using the same graph, but let’s keep things simple
    for now.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚修改了视觉效果图的许多不同属性，但如果你想要两个相同视觉效果图的实例，但略有不同，我建议你查看黑板功能，这将允许你在检查器中公开属性。例如，你可以在另一个场景中制作密度较低的雨，降低生成率，或者更改粒子颜色以制作酸雨，所有这些都可以使用相同的图，但现在让我们保持简单。
- en: The Blackboard feature is also present in Shader Graph.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板功能也存在于着色器图中。
- en: 'From here, you can experiment by adding and removing Blocks from the Contexts
    as you wish, and again, I recommend you look for already-created Visual Effect
    Graphs to find ideas for other systems. Actually, you can get ideas for Visual
    Effect Graph by looking at effects made in Shuriken and using the analogous blocks.
    Also, I recommend you search for the Visual Effect Graph documentation online
    or at: [https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@13.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@13.1/manual/index.html)
    to learn more about this system. You can also access the documentation of any
    Unity Package by clicking the **View Documentation** button in the Package Manager
    while the package is selected.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以按照自己的意愿添加和删除上下文中的块，并且再次，我建议您查找已经创建的视觉效果图来获取其他系统的灵感。实际上，您可以通过查看Shuriken中制作的效果和使用类似块来获得视觉效果图的灵感。此外，我建议您在网上或以下链接中搜索视觉效果图文档：[https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@13.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@13.1/manual/index.html)，以了解更多关于这个系统。您还可以在包管理器中选择包时，通过点击**查看文档**按钮访问任何Unity包的文档。
- en: '![](img/B18585_11_60.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_60.png)'
- en: 'Figure 11.60: Package Manager documentation link'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.60：包管理器文档链接
- en: Now that we have learnt how to create different visual effects, let’s see how
    to use them via scripting to achieve effects that react to what’s happening in
    the game.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建不同的视觉效果，让我们看看如何通过脚本使用它们来实现对游戏中发生的事情做出反应的效果。
- en: Scripting Visual Effects
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化视觉效果
- en: Visual feedback is the concept of using different VFX, such as particles and
    a VFX graph, to reinforce what is happening. For example, say right now we are
    shooting our weapon, and we know that this is happening because we can see the
    bullets. However, it doesn’t feel like a real shooting effect, because a proper
    shooting effect should have a muzzle effect on the tip of our gun. Another example
    would be the enemy dying—it just disappears with no animation! That doesn’t feel
    as satisfying as it could be. We can instead add a little explosion (considering
    they are robots).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉反馈是使用不同的VFX（如粒子和一个VFX图）来加强正在发生的事情的概念。例如，假设我们现在正在射击我们的武器，我们知道这是在发生，因为我们可以看到子弹。然而，这并不像真正的射击效果，因为一个合适的射击效果应该在枪口处有一个枪口效果。另一个例子是敌人死亡——它只是没有动画地消失！这并不像它本可以那样令人满意。我们可以添加一个小爆炸（考虑到它们是机器人）。
- en: 'Let’s start making our enemies spawn an explosion when they die by doing the
    following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤开始让敌人死亡时产生爆炸：
- en: Create an explosion effect or download one from the Asset Store. It shouldn’t
    loop and it needs to be destroyed automatically when the explosion is over (ensure
    **Looping** is unchecked and **Stop Action** is set to `Destroy` in the main module).
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个爆炸效果或从资产商店下载一个。它不应该循环，并且在爆炸结束后需要自动销毁（确保**循环**未勾选，并且在主模块中将**停止动作**设置为`销毁`）。
- en: Some explosions in the Asset Store might use non-URP-compatible shaders. You
    can fix them by using **Window | Rendering | Render Pipeline Converter**, as we
    saw in *Chapter 4*, *Importing and Integrating Assets*.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资产商店中的一些爆炸可能使用与URP不兼容的着色器。您可以通过使用**窗口 | 渲染 | 渲染管线转换器**来修复它们，正如我们在第4章中看到的，*导入和集成资产*。
- en: Manually upgrade the materials that didn’t upgrade automatically.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动升级那些没有自动升级的材料。
- en: Add a script to the `Enemy` prefab called `ExplosionOnDeath`. This will be responsible
    for spawning the particles Prefab when the enemy dies.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Enemy`Prefab添加一个名为`ExplosionOnDeath`的脚本。这将负责在敌人死亡时生成粒子Prefab。
- en: Add a field of the `GameObject` type called `particlePrefab` and drag the explosion
    Prefab to it.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`particlePrefab`的`GameObject`类型字段，并将爆炸Prefab拖放到它上面。
- en: You may be expecting to add the explosion spawning to the `Life` component.
    In that case, you are assuming that anything to do with life will spawn a particle
    when dying, but consider scenarios where characters die with a falling animation
    instead, or maybe an object that just despawns with no effect whatsoever. If a
    certain behavior is not used in most scenarios, it is better to code it in a separate
    optional script to allow us to mix and match different components and get the
    exact behavior we want.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望将爆炸生成添加到`Life`组件中。在这种情况下，您假设与生命相关的一切在死亡时都会产生粒子，但考虑一下这样的场景：角色在死亡时带有下落动画，或者可能是一个没有任何效果就消失的对象。如果某些行为在大多数场景中都没有使用，那么最好在单独的可选脚本中编码它，这样我们可以混合和匹配不同的组件，以获得我们想要的确切行为。
- en: Make the script access the `Life` component and subscribe to its `onDeath` event.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让脚本访问`Life`组件并订阅其`onDeath`事件。
- en: 'In the `listener` function, spawn the particle system in the same location:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`listener`函数中，在相同的位置生成粒子系统：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_11_61.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成的描述](img/B18585_11_61.png)'
- en: 'Figure 11.61: The explosion spawner script'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.61：爆炸生成器脚本
- en: 'The Visual Scripting version would look like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Scripting版本看起来是这样的：
- en: '![](img/B18585_11_62.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_62.png)'
- en: 'Figure 11.62: The explosion spawner visual script'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.62：爆炸生成器视觉脚本
- en: As you can see, we are just using the same concepts we learned about in previous
    chapters but combining them in new ways. This is what programming is all about.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是在之前章节中学到的相同概念的基础上，以新的方式组合它们。这就是编程的全部内容。
- en: 'Let’s continue with the muzzle effect, which will also be a particle system,
    but we will take another approach this time:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论枪口效果，它也将是一个粒子系统，但这次我们将采取另一种方法：
- en: If you don’t have one already, download a weapon model from the Asset Store.
    The character in the package we used in the book already comes with one, so we
    will use that one.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有，请从Asset Store下载一个武器模型。我们书中使用的包中的角色已经自带了一个，所以我们将使用那个。
- en: If it’s not already in your character, instantiate the weapon so that it is
    the parent of the hand of the player. Remember that our character is rigged and
    has a hand bone, so you should put the weapon there.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的角色中还没有，请实例化武器，使其成为玩家手的父级。记住，我们的角色是绑定的，有一个手骨，所以你应该把武器放在那里。
- en: The weapon that comes with the character we downloaded in this book is a special
    scenario where the weapon has a **SkinnedMeshRenderer**. This component uses the
    *Skinning Animation* system that we will learn to use in *Chapter 17*, *Create
    Animations with Animator, Cinemachine, and Timeline*. In this case, the movement
    of the weapon will be affected by the animations we will use in that chapter,
    so for now let’s keep the weapon where it is located now, even if it looks odd.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书中下载的角色所带的武器是一个特殊场景，其中武器有一个**SkinnedMeshRenderer**。这个组件使用我们在第17章“使用Animator、Cinemachine和Timeline创建动画”中将要学习的*Skinning
    Animation*系统。在这种情况下，武器的移动将受到我们将在那一章中使用的动画的影响，所以现在让我们保持武器现在的位置，即使它看起来有点奇怪。
- en: Create or get a muzzle particle system. In this case, my muzzle particle system
    was created as a short particle system that has a burst of particles and then
    automatically stops. Try to get one with that behavior because there are others
    out there that will loop instead, and the script to handle that scenario would
    be different.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或获取一个枪口粒子系统。在这种情况下，我的枪口粒子系统被创建为一个短粒子系统，它爆发出一群粒子然后自动停止。尽量获取一个具有这种行为的东西，因为还有其他一些会循环，处理这种情况的脚本将不同。
- en: 'Create an instance of the particle system prefab in the editor and parent it
    inside the weapon, locating it in front of the weapon, aligned with the cannon
    of the gun. Make sure the **Play On Awake** property of the main module of the
    particle system is unchecked; we don’t want the muzzle to fire until we press
    the fire key:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建粒子系统预制件的实例，并将其放置在武器内部，位于武器前方，与枪管对齐。确保粒子系统主模块的**Play On Awake**属性未勾选；我们不希望在按下射击键之前发射枪口：
- en: '![](img/B18585_11_63.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_63.png)'
- en: 'Figure 11.63: The muzzle parented to the weapon'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.63：与武器关联的枪口效果
- en: Create a field of the `ParticleSystem` type called `muzzleEffect` in `PlayerShooting`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerShooting`中创建一个名为`muzzleEffect`的`ParticleSystem`类型的字段。
- en: Drag the muzzle effect GameObject that is parented in the gun to it in the Inspector.
    Now, we have a reference to the `ParticleSystem` component of the muzzle to manage
    it.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将枪口效果的GameObject拖到检查器中，它已经在枪上作为父级。现在，我们有了对枪口`ParticleSystem`组件的引用，可以管理它。
- en: 'Inside the `if` statement that checks whether we are shooting, execute `muzzleEffect.Play();`
    to play the particle system. It will automatically stop and is short enough to
    finish between key presses:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查我们是否在射击的`if`语句中，执行`muzzleEffect.Play();`来播放粒子系统。它将自动停止，并且足够短，可以在按键之间完成：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_11_64.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序  自动生成的描述](img/B18585_11_64.png)'
- en: 'Figure 11.64: The muzzle parented to the weapon'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.64：与武器关联的枪口效果
- en: 'The Visual Scripting version’s additional nodes and variables would be the
    following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Scripting 版本的附加节点和变量如下：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_11_65.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B18585_11_65.png)'
- en: 'Figure 11.65: The muzzle playing visual script'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.65：开火脚本的视觉脚本
- en: 'Finally, we need to play the muzzle effect also on the AI while shooting by
    doing the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在射击时通过以下方式在 AI 上也播放开火效果：
- en: As we did with `PlayerShooting`, create a field of the `ParticleSystem` type
    called `muzzleEffect` in `EnemyFSM`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们对 `PlayerShooting` 做的那样，在 `EnemyFSM` 中创建一个名为 `muzzleEffect` 的 `ParticleSystem`
    类型的字段。
- en: 'Inside the `Shoot` method, add the line `muzzleEffect.Play();` at the end of
    the method to play the particle system:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Shoot` 方法内部，在方法末尾添加 `muzzleEffect.Play();` 行以播放粒子系统：
- en: '![](img/B18585_11_66.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_11_66.png)'
- en: 'Figure 11.66: The muzzle playing C# script'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.66：开火脚本的 C# 脚本
- en: 'The Visual Scripting version’s additional nodes for the `Attack State` and
    `Attack Base` will be:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Scripting 版本为 `Attack State` 和 `Attack Base` 添加的附加节点如下：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_11_67.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息，自动生成的描述](img/B18585_11_67.png)'
- en: 'Figure 11.67: The muzzle playing script for the Attack State'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.67：攻击状态的开火脚本
- en: Remember to add those nodes to both attack states and to add the `muzzleEffect`
    variable to the AI Variables component.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将这些节点添加到攻击状态中，并将 `muzzleEffect` 变量添加到 AI 变量组件中。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed two different ways to create particle systems:
    using Shuriken and VFX Graph. We used them to simulate different fluid phenomena,
    such as fire, a waterfall, smoke, and rain. The idea is to combine particle systems
    with meshes to generate all the possible props needed for your scene. Also, as
    you can imagine, creating these kinds of effects professionally requires you to
    go deeper. If you want to dedicate yourself to this (another part of the job of
    a technical artist), you will need to learn how to create your own particle textures
    to get the exact look and feel you want, code scripts that control certain aspects
    of the systems, and several other aspects of particle creation. However, that
    is outside the scope of the book.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了创建粒子系统的两种不同方法：使用 Shuriken 和 VFX Graph。我们使用它们来模拟不同的流体现象，如火焰、瀑布、烟雾和雨。想法是将粒子系统与网格结合以生成场景所需的全部可能道具。此外，正如你可以想象的那样，创建这类效果需要专业水平，这要求你深入了解。如果你想致力于此（技术艺术家工作的另一部分），你需要学习如何创建自己的粒子纹理以获得你想要的确切外观和感觉，编写控制系统某些方面的脚本，以及粒子创建的几个其他方面。然而，这些都超出了本书的范围。
- en: Now that we have some rain in our scene, we can see that the sky and the lighting
    in the scene don’t really reflect a rainy day, so let’s fix that in the next chapter!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们场景中有了一些雨，我们可以看到天空和场景中的光照并不真正反映雨天，所以让我们在下一章中修复这个问题！
