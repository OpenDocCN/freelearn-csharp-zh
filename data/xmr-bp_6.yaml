- en: Chapter 6. Building a Chat Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 建立聊天应用
- en: In this chapter, we will be moving back into Xamarin native. Our user interface
    will move away from an MVVM design and follow a new paradigm called **Model-View-Presenter**
    (**MVP**). We will also step further into the backend and setup a SignalR hub
    and client to simulate a chat service, which data will be sent between the server
    and clients instantly as the messages become available. Another key topic of focus
    is project architecture, spending time on separating the project into modules,
    and creating a nicely tiered structure that will maximize code sharing across
    different platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回到Xamarin原生。我们的用户界面将远离MVVM设计，并遵循一个新的范式，称为**模型-视图-演示者**（**MVP**）。我们还将进一步深入后端，设置一个SignalR
    Hub和客户端来模拟聊天服务，数据将在服务器和客户端之间即时发送，因为消息变得可用。另一个关键的关注点是项目架构，花费时间将项目划分为模块，并创建一个分层结构，这将最大化不同平台之间的代码共享。
- en: 'The following knowledge is expected:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下知识是预期的：
- en: Some understanding of Xamarin native (iOS and Android)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Xamarin原生（iOS和Android）有一些了解
- en: Visual Studio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: Some understanding of the OWIN specification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对OWIN规范有一些了解
- en: Some understanding of OAuth
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对OAuth有一些了解
- en: 'In this chapter, you will learn the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: The Model-View-Presenter (MVP) pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-演示者（MVP）模式
- en: Architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构
- en: SignalR
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalR
- en: Starting with Open Web Interface for .NET (OWIN)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从.NET的Open Web接口（OWIN）开始
- en: Creating an authorization server using OWIN OAuth 2.0
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OWIN OAuth 2.0创建授权服务器
- en: '`OAuthAuthorizationServerProvider`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OAuthAuthorizationServerProvider`'
- en: Authorization server providers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器提供者
- en: '`UseOAuthBearerAuthentication`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseOAuthBearerAuthentication`'
- en: Setting up the Authentication Repository
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置认证存储库
- en: Configuring the Web API
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Web API
- en: Building the AccountController
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`AccountController`
- en: Configuring OAuth Authentication with our Web API
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Web API的OAuth身份验证
- en: Building the SignalR Hub
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`SignalR Hub`
- en: Setting up mobile projects
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置移动项目
- en: Creating the `SignalRClient`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`SignalRClient`
- en: Building the Web API access layer
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`Web API`访问层
- en: Application State
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用状态
- en: Setting up the navigation service
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置导航服务
- en: Building the iOS navigation service
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`iOS`导航服务
- en: Building the Android navigation service
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`Android`导航服务
- en: Building the iOS interface
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`iOS`界面
- en: Handling Hub proxy callbacks
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Hub代理回调
- en: Implementing the `LoginPresenter`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`LoginPresenter`
- en: Creating the connection between Presenter and View
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建演示者和视图之间的连接
- en: Building the `LoginActivity`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`LoginActivity`
- en: Implementing the `ClientsListPresenter`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`ClientsListPresenter`
- en: Creating the `ClientListViewController`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`ClientListViewController`
- en: The `TaskCompletionSource` framework
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource`框架'
- en: Creating the `ClientsListActivity`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`ClientsListActivity`
- en: Overriding the Activity `OnBackPressed()`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写`Activity`的`OnBackPressed()`
- en: Building the `ListAdapter`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`ListAdapter`
- en: Building the `ChatPresenter`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`ChatPresenter`
- en: Building the iOS `ChatView`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`iOS`的`ChatView`
- en: Extending the `UIColor` framework
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`UIColor`框架
- en: Android `TableLayouts`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android `TableLayouts`
- en: Building the Android `ChatActivity`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`Android`的`ChatActivity`
- en: Running the server and clients
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行服务器和客户端
- en: The Model-View-Presenter (MVP) pattern
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-演示者（MVP）模式
- en: In all our previous chapters we have focused our development patterns around
    the **Model-View-View-Model** (**MVVM**) approach. This time we are going to be
    setting up our project around the MVP design pattern. In MVP the presenter centralizes
    the user interface functionality between the model and the view, meaning all presentation
    logic is pushed to the presenter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的前几章中，我们围绕**模型-视图-视图-模型**（**MVVM**）方法进行开发模式。这次我们将围绕MVP设计模式设置我们的项目。在MVP中，演示者集中了模型和视图之间的用户界面功能，这意味着所有展示逻辑都推送到演示者。
- en: '![The Model-View-Presenter (MVP) pattern](img/B05293_06_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-演示者（MVP）模式](img/B05293_06_01.jpg)'
- en: So why bother with this approach?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那为什么还要采用这种方法呢？
- en: The advantage with this approach is we can apply unit testing to our presenters,
    meaning all UI logic is tested via the presenter. We also have the ability to
    keep our user interfaces in native, and share a great amount of the UI logic between
    the different platforms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是我们可以对我们的演示者应用单元测试，这意味着所有UI逻辑都是通过演示者进行测试的。我们还有能力保持我们的用户界面为原生，并在不同平台之间共享大量的UI逻辑。
- en: Architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'When it comes to cross-platform applications, our goal is to share as much
    code as possible. We focus our attention on architecture, having a nice clean
    project structure that lends itself to a maximization of code sharing across platforms.
    So how do we solve this problem? Ask yourself:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到跨平台应用时，我们的目标是尽可能多地共享代码。我们专注于架构，拥有一个干净的项目结构，这有助于最大化跨平台的代码共享。那么我们如何解决这个问题？问问自己：
- en: What are the different layers?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些不同的层级？
- en: How do we set up the folder structure?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何设置文件夹结构？
- en: What parts go in which projects?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些部分属于哪个项目？
- en: 'There are many different approaches to this problem; here are some of the most
    common architectural layers:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题有许多不同的方法；以下是一些最常见的架构层：
- en: '**Data layer**: This stores the database'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：这个层存储数据库'
- en: '**Data access layer**: This layer focuses on the objects and wrappers that
    apply operations on the data layer (Read, Write, Update)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**：这个层专注于对数据层（读取、写入、更新）应用操作的对象和包装器'
- en: '**Business layer (logic)**: This layer focuses on the different domains (domain-driven
    design), separating the different areas of logic into objects that handle operations
    for each domain'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务层（逻辑）**：这个层专注于不同的领域（领域驱动设计），将不同的逻辑区域分离成处理每个领域操作的对象'
- en: '**Service access layer**: The area that focuses operations on the web API,
    how we handle JSON, and data sent and received between the API Controllers'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务访问层**：这个区域专注于对Web API的操作，我们如何处理JSON，以及API控制器之间发送和接收的数据'
- en: '**Application/platform layer**: Code which is not shared, specific to the native
    platform'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用/平台层**：不共享的代码，特定于原生平台'
- en: '**Common layer**: A shared project, code which is shared to all native projects'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用层**：一个共享的项目，代码被共享到所有原生项目中'
- en: '**User interface layer**: The layer which contains all the UI design (XAML
    sheets, UIViewControllers, AXML)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面层**：包含所有UI设计的层（XAML表单，UIViewControllers，AXML）'
- en: How do we determine which layers our project needs?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何确定我们的项目需要哪些层？
- en: In this example it is quite simple; we don't have a database so we don't need
    the data layer or data access layer. Everything else we will require, so let's
    begin building our project from the ground up, starting with the lower layers
    first.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中相当简单；我们没有数据库，所以不需要数据层或数据访问层。我们需要的其他所有东西，让我们从零开始构建我们的项目，先从底层开始。
- en: We are going to start building the project from the service access layer; it
    will include everything involved with SignalR, so our first step is to build the
    backend SignalR hub.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从服务访问层开始构建项目；它将包括与SignalR相关的所有内容，因此我们的第一步是构建后端SignalR hub。
- en: SignalR
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SignalR
- en: SignalR is a library that provides real-time web functionality to applications
    using WebSocket transport (if HTML 5 is supported; older transport methods will
    be used if it is not supported). It has the ability for a server to push data
    to its clients in real-time as it becomes available; this means we do not have
    to repeatedly ask the server for data (such as refreshing/recalling the Web API).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR是一个库，它为使用WebSocket传输（如果支持HTML 5）的应用程序提供实时Web功能。它具有服务器实时将数据推送到其客户端的能力，这意味着我们不必反复请求服务器数据（如刷新/重新调用Web
    API）。
- en: In order to set up SignalR, we must first set up a SignalR **Hub** on the server
    side; our clients (mobile projects) will use access this **Hub** by creating a
    **HubConnection **and creating a **HubProxy** from which the server and client
    can call functions on either side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置SignalR，我们首先必须在服务器端设置一个SignalR **Hub**；我们的客户端（移动项目）将通过创建一个**HubConnection**并从其中创建一个**HubProxy**来访问这个**Hub**，从而服务器和客户端可以在任一侧调用函数。
- en: '![SignalR](img/B05293_06_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_02.jpg)'
- en: Now let's get into development; we will have the same hardware set up as the
    last chapter. We will set up a locally hosted backend via Visual Studio and build
    our mobile projects via Xamarin Studio on MacOSX. Open up Visual Studio, create
    a `newASP.NET` web application, and call it `Chat`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入开发阶段；我们将与上一章相同的硬件设置。我们将通过Visual Studio设置本地托管的后端，并在MacOSX上的Xamarin Studio中构建我们的移动项目。打开Visual
    Studio，创建一个`newASP.NET` Web应用，并将其命名为`Chat`。
- en: '![SignalR](img/B05293_06_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_03.jpg)'
- en: 'Then we must select a template; select the **Empty** template:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须选择一个模板；选择**空**模板：
- en: '![SignalR](img/B05293_06_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_04.jpg)'
- en: Great! We now have our empty project, let's start by adding the NuGet package, **Microsoft.AspNet.SignalR**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有了空项目，让我们先添加 NuGet 包，**Microsoft.AspNet.SignalR**。
- en: '![SignalR](img/B05293_06_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_05.jpg)'
- en: 'A readme file will appear with some basic directions on setting up the SignalR
    **Hub**. We also want to add Web API 2.2 features for OWIN as we will be adding
    a small Web API to the project to handle login, register, and account functionality.
    Let''s add in the following libraries:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将会显示一个包含设置 SignalR **Hub** 基本方向的说明文件。我们还想为 OWIN 添加 Web API 2.2 功能，因为我们将在项目中添加一个小型
    Web API 来处理登录、注册和账户功能。让我们添加以下库：
- en: '![SignalR](img/B05293_06_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_06.jpg)'
- en: 'This will install Web API functionality so we can create API controllers and
    map routes through the `Startup` class. We then want to add the Web API 2.2 OWIN
    library to integrate the OWIN pipeline to our HTTP configuration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Web API 功能，这样我们就可以创建 API 控制器并通过 `Startup` 类映射路由。然后我们想添加 Web API 2.2 OWIN
    库以将 OWIN 管道集成到我们的 HTTP 配置中：
- en: '![SignalR](img/B05293_06_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_07.jpg)'
- en: We also want to add the `OWIN.Security` libraries for handling account authorization
    using **Bearer tokens**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想添加 `OWIN.Security` 库来处理使用 **Bearer 令牌** 的账户授权。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bearer tokens are used in HTTP request headers for authorizing access to OAuth
    2.0 protected resources.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求头中使用 Bearer 令牌来授权访问 OAuth 2.0 受保护的资源。
- en: '![SignalR](img/B05293_06_08.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_08.jpg)'
- en: Finally, we have to add another package called `Microsoft.AspNet.Identity.Framework`.
    This library will be used to handle storage of user accounts (usernames and passwords)
    using the `UserManager` framework.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须添加另一个名为 `Microsoft.AspNet.Identity.Framework` 的包。这个库将用于使用 `UserManager`
    框架来处理用户账户（用户名和密码）的存储。
- en: '![SignalR](img/B05293_06_09.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B05293_06_09.jpg)'
- en: Now that we have all our packages added, let's start building the web application
    from the ground up.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所有包，让我们从头开始构建网络应用程序。
- en: Starting with Open Web Interface for .NET (OWIN)
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Open Web Interface for .NET (OWIN) 开始
- en: '**OWIN** is a standard interface between .NET servers and web applications.
    It provides a middleware for decoupling a web server from a web application. The
    biggest advantage of OWIN is that we are able to host the web application anywhere,
    and keep the server and application completely separated.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**OWIN** 是 .NET 服务器和 Web 应用程序之间的标准接口。它提供了一个中间件，用于解耦 Web 服务器和 Web 应用程序。OWIN
    的最大优点是我们能够将 Web 应用程序托管在任何地方，并保持服务器和应用程序完全分离。'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on OWIN, the best place to start is with the Katana Project.
    Katana is a collection of projects that support OWIN with various Microsoft components.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OWIN 的更多信息，最好的起点是 Katana 项目。Katana 是一系列支持 OWIN 的项目，它们使用各种 Microsoft 组件。
- en: So what does OWIN have to do with our project?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 OWIN 与我们的项目有什么关系呢？
- en: If you notice the code above we see all references to OWIN namespaces, and we
    register in the assembly the `OwinStartup` object to our `Startup` class. We must
    have at least one `Startup` class registered in the `OwinStartup` attribute. The
    `Startup` class has one function called `Configuration`. All `Startup` classes
    must include this function, and it must accept `IAppBuilder`. Additional services,
    such as `IHostingEnvironment` and `ILoggerFactory` may also be specified, in which
    case these services will be injected by the server if they are available. The
    `Configuration` specifies how the application will respond to individual HTTP
    requests. Finally, in our `Configuration` method, we will be calling the `MapSignalR` (an
    extension to the `IAppBuilder` object). This will define the route for clients
    to use to connect to your **Hub/s**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意上面的代码，我们会看到所有对 OWIN 命名空间的引用，并且我们在程序集中将 `OwinStartup` 对象注册到我们的 `Startup`
    类。我们必须在 `OwinStartup` 属性中注册至少一个 `Startup` 类。`Startup` 类有一个名为 `Configuration` 的函数。所有
    `Startup` 类都必须包含此函数，并且它必须接受 `IAppBuilder`。还可以指定其他服务，如 `IHostingEnvironment` 和
    `ILoggerFactory`，在这种情况下，如果它们可用，服务器将注入这些服务。`Configuration` 指定应用程序如何响应单个 HTTP 请求。最后，在我们的
    `Configuration` 方法中，我们将调用 `MapSignalR`（`IAppBuilder` 对象的扩展）。这将定义客户端用于连接到您的 **Hub/s**
    的路由。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The route is set to the app builder pipeline at the URL `/signalr` by default:
    we can also customize this URL if required.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，路由设置为 URL `/signalr` 的应用程序构建器管道：如果需要，我们也可以自定义此 URL。
- en: Our next step is to bring in some security.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是引入一些安全性。
- en: Creating an authorization server using OWIN OAuth 2.0
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OWIN OAuth 2.0 创建授权服务器
- en: The OAuth 2.0 framework enables a server to provide clients with limited access
    for HTTP services. Protected server resources can only be accessed via access
    tokens that expire after certain periods of time. Clients will shoot a HTTP request
    at a domain endpoint URL (normally `/token`), the server will send a response
    with token details (such as expiration, access token, time/date issued), and the
    access token will be used for a period of time with other HTTP request headers
    to authorize access to protected resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 框架允许服务器向客户端提供对 HTTP 服务的有限访问。受保护的资源只能通过在特定时间段后过期的访问令牌访问。客户端将向域端点 URL
    发送 HTTP 请求（通常是 `/token`），服务器将发送包含令牌详细信息（如过期时间、访问令牌、时间/日期）的响应，并且访问令牌将在一段时间内与其他
    HTTP 请求头一起使用，以授权访问受保护资源。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Access tokens are strings denoting specified scope, lifetime, and other access
    attributes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌是表示特定范围、生存期和其他访问属性的字符串。
- en: So where do we begin to set up server authorization?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们该从哪里开始设置服务器授权？
- en: Our first step is to build the logic behind granting clients access from username
    and password credentials.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是构建基于用户名和密码凭证授予客户端访问的逻辑。
- en: OAuthAuthorizationServerProvider
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuthAuthorizationServerProvider
- en: An `OAuthAuthorizationServerProvider` determines how we validate user credentials
    using `OAuthGrantResourceOwnerCredentialsContext`. Its job is to simply handle
    the authentication of users. This item provides the context in which we handle
    resource grants.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`OAuthAuthorizationServerProvider` 确定了我们如何使用 `OAuthGrantResourceOwnerCredentialsContext`
    验证用户凭证。其任务是简单地处理用户的身份验证。此项目提供了我们处理资源授予的上下文。'
- en: 'Let''s add a new folder called `Providers`, and add a new file in this folder
    called `AuthorizationServerProvider.cs`. Implement the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个名为 `Providers` 的新文件夹，并在该文件夹中添加一个名为 `AuthorizationServerProvider.cs` 的新文件。实现以下内容：
- en: '[PRE0]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our implementation of the `OAuthAuthorizationServerProvider` will override the
    `ValidateClientAuthentication` function, which simply returns whether the `usercontext`
    has been validated. We then override the `GrantResourceOwnerCredentials()` function,
    which is called when a request to the token endpoint (`/token`) arrives with a
    `grant_type` of `password` (this key is set in the request header along with the
    username and password). The function will simply initialize a new `AuthenticationRepository`
    to access the `UserManager` framework and check if the user exists; if it doesn't
    we return, and the context will still be invalid. If the user exists, we create
    a new `ClaimsIdentity` object with two claims, one for the *role* and *username* principles
    of there source owner (the user who sent the HTTP request). Finally, we then place
    the `ClaimsIdentity` object into the `context.Validated()` function in order to
    issue the access token. This `ClaimsIdentity` object is now the ticket that contains
    the claims about the resource owner (the user) associated with the access token.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `OAuthAuthorizationServerProvider` 的实现将覆盖 `ValidateClientAuthentication`
    函数，该函数简单地返回 `usercontext` 是否已验证。然后我们覆盖 `GrantResourceOwnerCredentials()` 函数，当带有
    `grant_type` 为 `password` 的请求到达令牌端点（`/token`）时，该函数会被调用（此键与用户名和密码一起设置在请求头中）。该函数将简单地初始化一个新的
    `AuthenticationRepository` 以访问 `UserManager` 框架并检查用户是否存在；如果不存在，我们返回，并且上下文仍然无效。如果用户存在，我们创建一个新的
    `ClaimsIdentity` 对象，包含两个声明，一个用于源所有者（发送 HTTP 请求的用户）的 *角色* 和 *用户名* 原则。最后，我们将 `ClaimsIdentity`
    对象放入 `context.Validated()` 函数中，以颁发访问令牌。这个 `ClaimsIdentity` 对象现在是包含与访问令牌关联的资源所有者（用户）声明的票据。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `ClaimsIdentity` is an object that is a collection of `Claim` objects to represent
    an entity's identity. Each `Claim` object is simply a statement describing an
    identity's role, permission, or an other quality of an entity.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClaimsIdentity` 是一个对象，它是一个 `Claim` 对象的集合，用于表示实体的身份。每个 `Claim` 对象只是一个描述身份角色、权限或其他实体质量的陈述。'
- en: Use OAuthBearerAuthentication
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OAuthBearerAuthentication
- en: 'Our next step is to add the logic behind handling bearer tokens (these are
    the access tokens granted by the authorization server provider). `UseOAuthBearerAuthentication`
    has the job of ensuring that only authenticated users can access your protected
    server resources (in our example the `ChatHub`). Add a new file called `OAuthBearerTokenAuthenticationProvider.cs` and
    implement the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是添加处理携带令牌（这些是由授权服务器提供者授予的访问令牌）的逻辑。`UseOAuthBearerAuthentication` 的任务是确保只有经过身份验证的用户才能访问您的受保护服务器资源（在我们的例子中是
    `ChatHub`）。添加一个名为 `OAuthBearerTokenAuthenticationProvider.cs` 的新文件并实现以下内容：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's look at this item more closely. We are overriding the `RequestToken()`
    function to access the `OAuthRequestTokenContext` from every HTTP request that
    hits the server. Inside the `OwinContext` object, we can access the HTTP request
    that just hit the server, check through the dictionary of headers for our `BearerToken`,
    and then extract this access token and assign it to the `OAuthRequestTokenContext.Token`
    property.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个项目。我们正在重写 `RequestToken()` 函数，以便从每个击中服务器的 HTTP 请求中访问 `OAuthRequestTokenContext`。在
    `OwinContext` 对象内部，我们可以访问刚刚击中服务器的 HTTP 请求，通过头部字典检查我们的 `BearerToken`，然后提取这个访问令牌并将其分配给
    `OAuthRequestTokenContext.Token` 属性。
- en: Setting up the AuthenticationRepository
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 AuthenticationRepository
- en: 'Now we move on to the `AuthenticationRepository`. This is the object that will
    handle access and storage using the `UserManager` framework provided by the `Identity.EntityFramework`
    library. Add in a new folder called `Repositories`, then add a new file called
    `AuthenticationRepository.cs`, and implement the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向 `AuthenticationRepository`。这是将处理访问和存储的对象，使用由 `Identity.EntityFramework`
    库提供的 `UserManager` 框架。添加一个名为 `Repositories` 的新文件夹，然后添加一个名为 `AuthenticationRepository.cs`
    的新文件，并实现以下内容：
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `UserManager` class is a facade for providing identity management in any
    ASP.Net application
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserManager` 类是任何 ASP.Net 应用程序提供身份管理的门面'
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our main concern here involves two functions, one for registering users if they
    don't exist, and one for finding users. The authorization server provider uses
    `FindUser` to determine whether a user exists to confirm authentication.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的主要关注点涉及两个函数，一个用于注册用户（如果他们不存在），另一个用于查找用户。授权服务器提供者使用 `FindUser` 来确定用户是否存在以确认身份验证。
- en: 'We also need to add another file called `AuthenticationContext.cs` and implement
    the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加另一个名为 `AuthenticationContext.cs` 的文件，并实现以下内容：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a very simple class which inherits the `IdentityDBContext` of type
    `IdentityUser`. This object is the access layer for retrieving data objects (`IdentityUser `objects)
    via the `EntityFramework`. The following diagram shows the layers of logic between
    your ASP.Net application and `EntityFramework`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类，它继承自 `IdentityDBContext` 类型的 `IdentityUser`。该对象是访问层，用于通过 `EntityFramework`
    获取数据对象（`IdentityUser` 对象）。以下图表显示了您的 ASP.Net 应用程序和 `EntityFramework` 之间的逻辑层：
- en: '![Setting up the AuthenticationRepository](img/B05293_06_10.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![设置 AuthenticationRepository](img/B05293_06_10.jpg)'
- en: Fantastic! Hopefully those topic weren't too confusing. Now let's start building
    the Web API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！希望那些主题没有太令人困惑。现在让我们开始构建 Web API。
- en: Configuring the Web API
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Web API
- en: Our next step is to configure the Web API. Let's add in a new folder called
    `App_Start`. Inside this folder add a new file called `WebApiConfig.cs` and implement
    the following:,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是配置 Web API。让我们添加一个名为 `App_Start` 的新文件夹。在这个文件夹内添加一个名为 `WebApiConfig.cs`
    的新文件，并实现以下内容：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Look more closely at the `routeTemplate`; notice the `{action}` addition? This
    means we have to include the `ActionName` attribute with each function in our
    `AccountController`. The `ActionName` attribute represents the URL extension,
    for example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更仔细地看看 `routeTemplate`；注意到 `{action}` 的添加吗？这意味着我们必须在每个 `AccountController` 中的函数上包含
    `ActionName` 属性。`ActionName` 属性代表 URL 扩展名，例如：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let's add another file called `Startup.cs` and implement the following:,
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加另一个名为 `Startup.cs` 的文件，并实现以下内容：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let's move on to building the `AccountController` to handle incoming HTTP
    requests for user login and registration.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续构建 `AccountController` 来处理用户登录和注册的传入 HTTP 请求。
- en: Building the AccountController
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 AccountController
- en: 'Now that we have configured the Web API, let''s build the first API controller.
    Add in a new folder called `Models`. Inside this folder, add a new file called
    `UserModel.cs`, and implement the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 Web API，让我们构建第一个 API 控制器。添加一个名为 `Models` 的新文件夹。在这个文件夹内，添加一个名为 `UserModel.cs`
    的新文件，并实现以下内容：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The object will contain the username and password fields passed in through
    the HTTP request from the client. The `Register` attribute is used to make sure
    that this property is included with the HTTP request. We can then map this attribute
    to the API controller `ModelState.IsValid` check, so if any of the properties
    with this attribute are missing, the `IsValid` property will be `false`. Next,
    let''s add in another folder called `Controllers`. Inside this folder add in a
    new file, `AccountController.cs`, and implement the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象将包含客户端通过HTTP请求传递的username和password字段。`Register`属性用于确保此属性包含在HTTP请求中。然后我们可以将此属性映射到API控制器的`ModelState.IsValid`检查，如果任何具有此属性的属性缺失，则`IsValid`属性将为`false`。接下来，让我们添加另一个名为`Controllers`的文件夹。在这个文件夹中添加一个名为`AccountController.cs`的新文件，并实现以下内容：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our first step is the `Register` function, which is responsible for storing
    a new user into the `UserManager` through the `AccountRepository`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是`Register`函数，它负责通过`AccountRepository`将新用户存储到`UserManager`中。
- en: Notice the if statement on `ModalState.IsValid`?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`ModalState.IsValid`上的if语句吗？
- en: If either the `Username` or `Password` properties are missing from the HTTP
    request, it will return `false`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP请求中缺少`Username`或`Password`属性，它将返回`false`。
- en: 'Let''s now add the `Login` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加`Login`函数：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is exactly the same as `Register` but we are using the `FindUser` function
    to check if the user exists in the `UserManager`. Finally, to avoid any memory
    leakage, we need to make sure that the `AuthenticationRepostiory` is disposed
    when the API controller is disposed. Let''s override the `Dispose` function like
    this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`Register`完全相同，但我们使用`FindUser`函数来检查用户是否存在于`UserManager`中。最后，为了避免任何内存泄漏，我们需要确保当API控制器被销毁时，`AuthenticationRepostiory`也被销毁。让我们像这样重写`Dispose`函数：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great! That's everything for the `AccountController`, now we must integrate
    the OAuth authentication and Web API together.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！对于`AccountController`来说，这就是全部内容；现在我们必须将OAuth身份验证和Web API集成在一起。
- en: Configuring OAuth Authentication with our Web API
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的Web API配置OAuth身份验证
- en: 'In order to integrate our OAuth module with the Web API we must add some extra
    configuration in `Startup.cs`. Add in a new function called `ConfigureOAuth` like
    this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的OAuth模块与Web API集成，我们必须在`Startup.cs`中添加一些额外的配置。添加一个名为`ConfigureOAuth`的新函数，如下所示：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looking more closely, we start with instantiating a new `OAuthAuthorizationServerOptions`
    object, we set the endpoint URL, expiration period for an access token, and the
    provider is set to our `AuthorizationServerProvider` class created in the preceding
    example. We then add this object into the `IAppBuilder` object using the function
    `UseOAuthAuthorizationServer`. Finally, we create a new `OAuthBearerAuthenticationOptions`
    object where the provider is set to our `OAuthBearerTokenAuthenticationProvider`
    object created in the preceding example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们首先实例化一个新的`OAuthAuthorizationServerOptions`对象，我们设置端点URL、访问令牌的过期期限，并将提供者设置为在先前的示例中创建的`AuthorizationServerProvider`类。然后我们使用`UseOAuthAuthorizationServer`函数将此对象添加到`IAppBuilder`对象中。最后，我们创建一个新的`OAuthBearerAuthenticationOptions`对象，其中提供者设置为在先前的示例中创建的`OAuthBearerTokenAuthenticationProvider`对象。
- en: That's all for now; we now have OAuth authentication integrated with our Web
    API. Now let's implement the final part of our server application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止；我们现在已经将OAuth身份验证集成到我们的Web API中。现在让我们实现服务器应用程序的最后一部分。
- en: Building the SignalR Hub
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建SignalR Hub
- en: 'The `ChatHub` will be responsible for routing messages between clients using
    a `ConnectionId`. Let''s add in a new file called `ChatHub` and start with overriding
    the `OnConnected` and `OnDisconnected` functions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatHub`将负责使用`ConnectionId`在客户端之间路由消息。让我们添加一个名为`ChatHub`的新文件，并从重写`OnConnected`和`OnDisconnected`函数开始：'
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`HashSetUsers` is static because we are going to use this later on in our `AccountController`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSetUsers`是静态的，因为我们将在`AccountController`中使用它。'
- en: Notice the Authorize attribute?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个Authorize属性吗？
- en: This is how we created a protected server resource; only clients with granted
    access tokens can connect to the `ChatHub`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们创建受保护服务器资源的方式；只有获得访问令牌的客户端才能连接到`ChatHub`。
- en: Now let's turn our attention to the `OnConnected` function. When a client connects
    to the `ChatHub`, the username is retrieved from the `HubCallerContext` property,
    which is actually a `ClaimsIdentity` object. When we login through the `AccountController`,
    inside the `AuthorizationServerProvider` we store the identity object inside the
    context when the function `GrantResourceOwnerCredentials` is called. We also store
    a `Claim` object of type `username` inside the identity, which we can now retrieve
    from the user's identity in the `HubCallerContext`. This is how we integrate OAuth
    with SignalR.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向`OnConnected`函数。当客户端连接到`ChatHub`时，用户名是从`HubCallerContext`属性中检索的，该属性实际上是一个`ClaimsIdentity`对象。当我们通过`AccountController`登录时，在`AuthorizationServerProvider`内部，当调用`GrantResourceOwnerCredentials`函数时，我们将身份对象存储在上下文中。我们还在身份中存储了一个类型为`username`的`Claim`对象，我们现在可以从`HubCallerContext`中的用户身份中检索它。这就是我们将OAuth与SignalR集成的样子。
- en: 'Now that we have the username, we are going to try and retrieve a `SigRUser`
    object from the `ConcurrentDictionary`; if the username doesn''t exist we create
    a new `SignRUser` and add it to the `HashSet`. We then lock the `ConnectionIdsConcurrentDictionary`
    making it thread safe as multiple threads (different user connections) can make
    changes on this property. Inside the lock statement we add the new `ConnectionId`
    and notify all other usernames connected to the `ChatHub` using the function `NotifyOtherConnectedUsers`.
    Let''s now add this function to the `ChatHub`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了用户名，我们将尝试从`ConcurrentDictionary`中检索一个`SigRUser`对象；如果用户名不存在，我们创建一个新的`SignRUser`并将其添加到`HashSet`中。然后我们锁定`ConnectionIdsConcurrentDictionary`，使其线程安全，因为多个线程（不同的用户连接）可以对此属性进行更改。在锁定语句中，我们添加新的`ConnectionId`并使用`NotifyOtherConnectedUsers`函数通知所有连接到`ChatHub`的其他用户。现在让我们将这个函数添加到`ChatHub`中：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function will call `displayMessage`, sending a serialized JSON object of
    the `ConcurrentDictionary Users` to all other connected clients (we will see why
    later).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将调用`displayMessage`，向所有其他连接的客户端发送`ConcurrentDictionary Users`的序列化JSON对象（我们稍后会看到原因）。
- en: Now let's turn our attention to the `OnDisconnected` function. This function
    will simply check there is a `SigRUser` with the username equal to the one retrieved
    from the `HubCallerContext` object. If this user exists, we try and remove it
    from the `ConcurrentDictionary` and call the `NotifyOtherConnectedUsers` again
    sending the updated dictionary of clients to the remaining connected clients.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向`OnDisconnected`函数。这个函数将简单地检查是否存在一个用户名为从`HubCallerContext`对象中检索到的`SigRUser`。如果此用户存在，我们尝试将其从`ConcurrentDictionary`中删除，并再次调用`NotifyOtherConnectedUsers`，将更新后的客户端字典发送给剩余的连接客户端。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We call this function every time a user connects or disconnects to the hub,
    so in our mobile application we can update a list of connected clients in real
    time without refreshing the page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次用户连接或断开与中心连接时都会调用这个函数，因此在我们的移动应用程序中，我们可以实时更新连接客户端的列表，而无需刷新页面。
- en: 'Now that we can handle an updated list of connected clients, our last step
    is to add the function which will send a message between two clients. The `Send`
    function will be called through the client''s hub proxy with two parameters (message
    and username):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够处理连接客户端的更新列表，我们的最后一步是添加一个在两个客户端之间发送消息的函数。`Send`函数将通过客户端的中心代理调用，带有两个参数（消息和用户名）：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's all for our backend. We have now created our first addition to the server's
    service access layer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的后端全部内容。我们现在已经为服务访问层添加了第一个功能。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The server service access layer will sit in a different service access layer
    to the mobile projects. With server and client code, each side of the system will
    have its own architecture and layers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器服务访问层将位于移动项目不同的服务访问层中。与服务器和客户端代码一样，系统的每一侧都将有自己的架构和层。
- en: Now let's move onto the client side and start building our mobile applications.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向客户端并开始构建我们的移动应用程序。
- en: Setting up mobile projects
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置移动项目
- en: Now we move back to the mobile side; in our mobile projects we are going to
    be setting up SignalR clients on both Android and iOS natively. We will also be
    creating a presenter layer to share the UI logic between both native platforms.
    Open up Xamarin Studio and create a new shared project called `Chat.Common`; inside
    this project add two empty folders called `Model` and `Presenter`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到移动端；在我们的移动项目中，我们将原生地在Android和iOS上设置SignalR客户端。我们还将创建一个表示层来在两个原生平台之间共享UI逻辑。打开Xamarin
    Studio并创建一个名为`Chat.Common`的新共享项目；在这个项目中添加两个名为`Model`和`Presenter`的空文件夹。
- en: 'We then want to create a **single view iOS application**, a **general Android
    application** and a shared project called `Chat.ServiceAccess`. Our project structure
    will look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要创建一个**单个视图iOS应用程序**，一个**通用Android应用程序**，以及一个名为`Chat.ServiceAccess`的共享项目。我们的项目结构将如下所示：
- en: '![Setting up mobile projects](img/B05293_06_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![设置移动项目](img/B05293_06_11.jpg)'
- en: Creating the SignalRClient
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SignalRClient
- en: 'We are going to start implementing a new class called `SignalRClient`. This
    will sit in the service access layer, the shared project called `Chat.ServiceAccess`.
    Create a new file called `SignalRClient.cs`, and implement the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始实现一个新的类，称为`SignalRClient`。这将位于服务访问层，名为`Chat.ServiceAccess`的共享项目中。创建一个名为`SignalRClient.cs`的新文件，并实现以下内容：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now let's look more closely. We have two `readonly` properties in which we only
    initialize once when the object is created, the hub connection which is set to
    the server URL, and the `HubProxy` which is created off the connection to the
    server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看看。我们有两个`readonly`属性，在对象创建时只初始化一次，一个是设置到服务器URL的hub连接，另一个是从连接到服务器的`HubProxy`创建的。
- en: 'Now let''s add two functions for connecting and disconnecting to the `ChatHub`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`ChatHub`添加两个用于连接和断开连接的功能：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Connect` function requires an access token which we add to the `Headers` dictionary
    of the `HubConnection` object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connect`函数需要一个访问令牌，我们将它添加到`HubConnection`对象的`Headers`字典中。'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The access token is used as a Bearer token to authorize access to the `ChatHub`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌用作Bearer令牌，以授权对`ChatHub`的访问。
- en: The function `On` called from the proxy takes in two parameters, the name of
    the function on the server we are listening for, and the action that will be performed
    every time this function is called on the Hub's connected clients. In this example,
    our proxy will fire this action whenever two strings are received from the server.
    The first string is an ID for the data passed in the second string (this could
    be a JSON list of connected clients or it could be a simple chat message). This
    data will then be passed a `Tuple<string, string>` object to the `EventHandler`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从代理中调用的`On`函数接受两个参数，即我们正在监听的服务器上函数的名称，以及每次在Hub的已连接客户端上调用此函数时将执行的操作。在这个例子中，我们的代理将在从服务器接收两个字符串时触发此操作。第一个字符串是传递到第二个字符串中的数据的ID（这可能是一个包含已连接客户端的JSON列表或一个简单的聊天消息）。然后，这些数据将通过一个`Tuple<string,
    string>`对象传递给`EventHandler`。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can call `On` for multiple functions, and fire different actions for as many
    different functions being called on the `Hub`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为多个函数调用`On`，并为在`Hub`上被调用的每个不同函数触发不同的操作。
- en: 'The `Disconnect` function simply closes the connection and disposes the `HubConnection`
    object. Finally, we add another function for invoking the `Send` function via
    the `ChatHub` object on the server:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Disconnect`函数简单地关闭连接并释放`HubConnection`对象。最后，我们添加另一个函数，通过服务器上的`ChatHub`对象调用`Send`函数：'
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When we invoke server functions, we use an array of objects, in order to match
    the parameters required on the server function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用服务器函数时，我们使用一个对象数组，以匹配服务器函数所需的参数。
- en: Since the `SignalRClient` will sit in a shared project, the same code will be
    used for each different platform, but the libraries referenced from the `using`
    statements will come from each platform project. Now let's have both the iOS and
    Android projects reference this shared project. We also want to add the `Microsoft.AspNet.SignalR.Client`
    NuGet package for all the platform projects (iOS and Android).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SignalRClient`将位于一个共享项目中，相同的代码将在每个不同的平台上使用，但引用的库将从每个平台项目提供。现在让我们让iOS和Android项目都引用这个共享项目。我们还想为所有平台项目（iOS和Android）添加`Microsoft.AspNet.SignalR.Client`
    NuGet包。
- en: '![Creating the SignalRClient](img/B05293_06_12.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![创建SignalRClient](img/B05293_06_12.jpg)'
- en: 'If you are trying to add the NuGet package for SignalR version 2.2.0 with Xamarin.iOS
    1.0, the package will fail to add. If so, visit the following link and add the
    correct `.dll` files from the `lib` folder to each platform project''s references:
    [https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr](https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用Xamarin.iOS 1.0添加SignalR版本2.2.0的NuGet包，该包将无法添加。如果出现这种情况，请访问以下链接，并将`lib`文件夹中的正确`.dll`文件添加到每个平台项目的引用中：[https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr](https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr)。
- en: '![Creating the SignalRClient](img/B05293_06_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![创建SignalRClient](img/B05293_06_13.jpg)'
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To add the references correctly, right-click the folder **References** for each
    project, click the **.Net assembly** tab, and click the **B****rowse** button
    to add the `.dll` files (`Microsoft.AspNet.SignalR.Client`, `System.Net.Http.Extensions`,
    and `System.Net.Http.Primitives`).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确添加引用，右键单击每个项目的**引用**文件夹，点击**.Net程序集**选项卡，然后点击**浏览**按钮添加`.dll`文件（`Microsoft.AspNet.SignalR.Client`、`System.Net.Http.Extensions`和`System.Net.Http.Primitives`）。
- en: For each platform project, we also need to add the `Json.Net` package from NuGet,
    then right-click on the **References****,** click the **All** tab, and select **System.Net**
    and **System.Net.Http**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个平台项目，我们还需要从NuGet添加`Json.Net`包，然后右键单击**引用**，点击**所有**选项卡，并选择**System.Net**和**System.Net.Http**。
- en: '![Creating the SignalRClient](img/B05293_06_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![创建SignalRClient](img/B05293_06_14.jpg)'
- en: Now that we have **SignalR** configured, let's move on to building the `WebApiAccess`
    layer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经配置了**SignalR**，让我们继续构建`WebApiAccess`层。
- en: Building the WebApiAccess layer
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建WebApiAccess层
- en: 'Our `WebApiAccess` object will be mapped to the `AccountController` on the
    server. Let''s add in a new file called `WebApiAccess.cs`, and implement the `LoginAsync` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`WebApiAccess`对象将被映射到服务器上的`AccountController`。让我们添加一个名为`WebApiAccess.cs`的新文件，并实现`LoginAsync`函数：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `_baseAddress` property will be the same as the `SignalRHubConnection` address;
    this is our server link. In our `LoginAsync` function, we start with creating
    a new `HttpRequestMessage` set as a `HttpMethod.Post`. We also set the content
    to a new `StringContent` object, which takes the username and password. This message
    is used in a new `HttpClient` to send to the server, and the response received
    is read as a string and parsed in to a new `bool` object to determine the success
    of the login.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`_baseAddress`属性将与`SignalRHubConnection`地址相同；这是我们服务器链接。在我们的`LoginAsync`函数中，我们首先创建一个新的`HttpRequestMessage`，将其设置为`HttpMethod.Post`。我们还设置了内容为一个新的`StringContent`对象，该对象包含用户名和密码。这条消息用于一个新的`HttpClient`，发送到服务器，并将接收到的响应作为字符串读取并解析为一个新的`bool`对象，以确定登录是否成功。'
- en: 'Let''s go ahead and implement the rest of the access layer:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现访问层的其余部分：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Register` function is very much the same, but we only check that the response
    status code is a `200(OK)` response; if so, then we have registered successfully.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`函数与之前非常相似，但我们只检查响应状态码是否为`200(OK)`响应；如果是这样，那么我们已成功注册。'
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `GetTokenAsync` function is responsible for retrieving the access token
    from the OAuth endpoint (`/token`). The JSON response will be of the type `TokenContract`;
    let''s go ahead and add this object into the `Chat.ServiceAccess` project. Create
    a new folder called `Contracts` inside the `Web` folder, add in a new file called
    `TokenContract.cs`, and implement the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetTokenAsync`函数负责从OAuth端点（`/token`）检索访问令牌。JSON响应将是`TokenContract`类型；让我们继续将此对象添加到`Chat.ServiceAccess`项目中。在`Web`文件夹内创建一个名为`Contracts`的新文件夹，添加一个名为`TokenContract.cs`的新文件，并实现以下内容：'
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice the `JsonProperty` attribute?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`JsonProperty`属性吗？
- en: We can map properties from the JSON objects into other named variables for the
    class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将JSON对象中的属性映射到类的其他命名变量中。
- en: Now for the final Web API function, `GetAllConnectedUsersAsync`. This function
    will be called when a user logs in for the first time. We need to have both an
    API call and a real-time update with the **SignalRClient** to keep track of the
    current connected clients because when a new user logs in, the server will call
    `displayMessage` on all other clients. Even if we were to call `displayMessage` on
    `Clients.All` (this is a reference to all the connected clients on any **SignalR
    Hub**), the newly connected client won't appear in the Clients list as there is
    a minor delay with the connection.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后的Web API函数`GetAllConnectedUsersAsync`。当用户首次登录时，将调用此函数。我们需要同时进行API调用和与**SignalRClient**的实时更新，以跟踪当前连接的客户端，因为当新用户登录时，服务器将在所有其他客户端上调用`displayMessage`。即使我们调用`displayMessage`在`Clients.All`（这是对任何**SignalR
    Hub**上所有连接客户端的引用），新连接的客户端也不会出现在客户端列表中，因为连接存在轻微的延迟。
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This minor delay is something we cannot control; only sometimes would the newly
    connected client receives the updated list through the `HubProxy` event. So, to
    make things more reliable, we add this update through the API access layer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轻微的延迟是我们无法控制的；只有有时新连接的客户端才会通过`HubProxy`事件接收到更新后的列表。因此，为了使事情更加可靠，我们在API访问层添加了这个更新。
- en: 'Let''s add the final Web API function for `GetAllConnectedUsersAsync`. This
    function will deserialized an IEnumerable of strings which represents the list
    of connected clients from the **ChatHub**:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `GetAllConnectedUsersAsync` 添加最终的 Web API 函数。此函数将反序列化一个表示连接客户端列表的字符串的 `IEnumerable`，来自
    **ChatHub**：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Great! We now have our Web API access layer. Our next step is to start building
    the application state and navigation service required for each presenter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在已经有了我们的 Web API 访问层。我们的下一步是开始构建每个演示者所需的每个应用程序状态和导航服务。
- en: Application state
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序状态
- en: In MVP, every presenter must include the current application state. When we
    cross between different screens, the persistent state of application data is kept
    alive throughout the entire life of the application (this includes search results,
    downloaded JSON objects, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVP 中，每个演示者都必须包含当前的应用程序状态。当我们跨不同屏幕时，应用程序数据的持久状态将在整个应用程序的生命周期中保持活跃（这包括搜索结果、下载的
    JSON 对象等）。
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In some most MVP applications, the application state will include a service
    for saving and loading this persistent data between different sessions. For an
    extra learning activity, try implementing a new service called `IApplicationStateService`.
    This will be responsible for saving and loading the `ApplicationState` object
    locally to your device.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多 MVP 应用程序中，应用程序状态将包括一个用于在不同会话之间保存和加载此持久数据的保存和加载服务。作为一个额外的学习活动，尝试实现一个名为 `IApplicationStateService`
    的新服务。这个服务将负责将 `ApplicationState` 对象本地保存到您的设备上。
- en: 'Excellent! Now let''s add another file called `ApplicationState.cs`, and implement
    the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在让我们添加另一个名为 `ApplicationState.cs` 的文件，并实现以下内容：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Nothing much to it, right?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别的，对吧？
- en: We only ever want one instance of this object throughout the entire life of
    the application, so we will build upon the persistent data to be kept alive between
    each screen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整个应用程序的生命周期中只想有一个此对象的实例，因此我们将基于需要在每个屏幕之间保持活跃的持久数据来构建。
- en: Setting up the navigation service
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置导航服务
- en: Implementing a navigation service in MVP is very different from our `Xamarin.Forms`
    navigation service. Our navigation service will not be used in an IoC container
    this time; instead, we will be instantiating one of these objects at the start
    of our application in the `AppDelegate` and `MainActivity` classes. Since we are
    working in native, we will also be implementing a separate navigation service
    for each platform that will share the same interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVP 中实现导航服务与我们的 `Xamarin.Forms` 导航服务非常不同。这次我们的导航服务将不会在 IoC 容器中使用；相反，我们将在应用程序启动时在
    `AppDelegate` 和 `MainActivity` 类中实例化这些对象之一。由于我们在原生环境中工作，我们还将为每个平台实现一个单独的导航服务，这些服务将共享相同的接口。
- en: 'Let''s start with creating the shared interface. Add a new file to the `Chat.Common`
    folder ****Presenter**** | **Services**, call it `INavigationService.cs`, and
    implement the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建共享接口开始。在 `Chat.Common` 文件夹中的 **Presenter** | **Services** 下添加一个新文件，命名为
    `INavigationService.cs`，并实现以下内容：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Building the iOS navigation service
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 iOS 导航服务
- en: 'Let''s start with the iOS navigation service. Add in a new folder called `Services`
    to the `Chat.iOS` project, create a new file called `NavigationService.cs`, and
    implement the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建 iOS 导航服务开始。在 `Chat.iOS` 项目中添加一个名为 `Services` 的新文件夹，创建一个名为 `NavigationService.cs`
    的新文件，并实现以下内容：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we instantiate this object we always want to pass in the `UINavigationController`
    that is assigned to our `RootViewController` of the `UIWindow` object created
    in our `AppDelegate`. We also have to implement the `Push` function, which takes
    a `BasePresenter` object (any presenter), and we perform a type check to determine
    which presenter is being passed, and pushing the related `UIViewController`, onto
    the navigation stack. We must always pass the presenter to the new `UIViewController`,
    so we can register the new view to the current presenter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化此对象时，我们总是想传递分配给我们在 `AppDelegate` 中创建的 `UIWindow` 对象的 `RootViewController`
    的 `UINavigationController`。我们还必须实现 `Push` 函数，该函数接受一个 `BasePresenter` 对象（任何演示者），我们执行类型检查以确定传递的是哪个演示者，并将相关的
    `UIViewController` 推送到导航堆栈中。我们必须始终将演示者传递给新的 `UIViewController`，这样我们就可以将新的视图注册到当前演示者。
- en: Building the Android navigation service
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Android 导航服务
- en: 'Before we move onto the Android navigation service, we have to add an extra
    class to hold persistent state on the current activity, current presenter, and
    current context. Add in a new file called `Application.cs` and implement the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向Android导航服务之前，我们必须添加一个额外的类来在当前活动、当前演示者和当前上下文中保持持久状态。添加一个名为`Application.cs`的新文件，并实现以下内容：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This class will extend off the Android application, so when we reference the
    Android application class in other parts of our application, we have reference
    to the extra persistent objects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将扩展Android应用程序，因此当我们在其他部分的应用程序中引用Android应用程序类时，我们将引用额外的持久对象。
- en: 'Now let''s implement the Android navigation service. Add in a new folder to
    the Android project called `Services`, add a new file called `NavigationService.cs`,
    and implement the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现Android导航服务。在Android项目中添加一个名为`Services`的新文件夹，添加一个名为`NavigationService.cs`的新文件，并实现以下内容：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the constructor, we pass in the `Application` object and keep this stored
    as a private variable inside the navigation service. The `Push` function requires
    the `Application` everytime we push a new `Activity` onto the stack, because we
    require the current activity reference to start the new intent from the current
    activity held inside the `Application` object.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们传入`Application`对象，并将其作为私有变量存储在导航服务中。`Push`函数每次我们向堆栈中推送一个新的`Activity`时都需要`Application`，因为我们需要当前活动引用来从`Application`对象中启动新的意图。
- en: Now that we have our navigation service and application state, let's start building
    our user interface for iOS.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了导航服务和应用程序状态，让我们开始构建iOS的用户界面。
- en: Building the iOS interface
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建iOS界面
- en: Since we don't really know how the user interface is going to look for each
    screen, we can't define the logic in our presenters. So let's loosely talk about
    how the user interface is going to look.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并不真正知道每个屏幕的用户界面将如何看起来，我们无法在我们的演示者中定义逻辑。所以让我们大致谈谈用户界面将如何看起来。
- en: Tip
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We should normally have screen mock-ups at this point before we move to the
    UI layer of a project.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向项目的UI层之前，我们通常应该有屏幕原型。
- en: We have three screens in our application, one of which is going to be list which
    displays all the connected clients live on the **ChatHub** on our server. A user
    will be able to select this user from the list; when a user selects another client
    from the list, this client should receive a message asking for permission to start
    a chat conversation. When a user accepts, this will move to another screen which
    will show a typical chat conversation, much the same as with any other SMS application
    (speech bubbles on either side). The following diagram is a quick mock-up of the
    three screens and workflow. All we see is the first screen showing a login screen,
    then another showing a list with the connected clients, and the last screen showing
    a conversation between two connected clients.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中有三个屏幕，其中一个将是一个列表，显示服务器上**ChatHub**上所有连接的客户端。用户可以从列表中选择这个用户；当用户从列表中选择另一个客户端时，这个客户端应该收到一条请求权限的消息，以开始聊天对话。当用户接受时，这将转到另一个屏幕，显示典型的聊天对话，与任何其他短信应用程序（两侧的语音气泡）类似。以下图表是三个屏幕和工作流程的快速原型。我们看到的是第一个屏幕显示登录屏幕，然后是另一个显示连接客户端的列表，最后是显示两个连接客户端之间对话的屏幕。
- en: '![Building the iOS interface](img/B05293_06_15.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![构建iOS界面](img/B05293_06_15.jpg)'
- en: Excellent! Now that we have an idea as to how our screens are going to look,
    let's talk about the logic behind the first screen that we can share. We have
    a screen with two entry boxes for a username and password. The screen will be
    able to perform logins and registrations on our Web API, so we will require a
    button for each. If we are successful with login, this will push the list page
    on to the navigation stack.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经有了关于屏幕外观的初步想法，让我们来谈谈第一个可以分享的屏幕背后的逻辑。我们有一个屏幕，包含两个输入框，用于输入用户名和密码。这个屏幕将能够在我们Web
    API上执行登录和注册操作，因此我们需要为每个操作提供一个按钮。如果我们登录成功，这将把列表页面推送到导航堆栈中。
- en: Let's consider a cross-platform approach; what can we share here?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个跨平台的方法；我们在这里可以共享什么？
- en: Web API layer
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API层
- en: '**EventHandlers** to handle the click events for a login and register'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理器**用于处理登录和注册的点击事件'
- en: Navigation service to handle push/pop onto our navigation stack
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航服务用于处理导航堆栈上的推送/弹出
- en: 'We have a rough idea of the logic behind our first screen; let''s build our
    first **Presenter**. Create two new files called `BasePresenter.cs` and `IView.cs`.
    We will start with the `IView` class:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对第一个屏幕背后的逻辑有一个大致的了解；让我们构建我们的第一个**演示者**。创建两个新的文件，分别命名为`BasePresenter.cs`和`IView.cs`。我们将从`IView`类开始：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We want all screens to have an `IsInProgress` variable, if any screen is loading
    or processing, we can display loading activity to the user. The `SetMessage` function
    is used to display any errors to the user through an alert dialog.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望所有屏幕都有一个`IsInProgress`变量，如果任何屏幕正在加载或处理，我们可以向用户显示加载活动。`SetMessage`函数用于通过警告对话框向用户显示任何错误。
- en: 'Now for the `BasePresenter`, this is an abstract class which will be used for
    all presenters. All presenters require the `ApplicationState`, `INavigationService`,
    and the `SignalRClient`. Throughout our entire application, each screen requires
    events from the `SignalRClient` to function, so we can bring it into the `BasePresenter`
    object. We have created two `EventHandlers`; these are fired based upon the data
    received via the **hub proxy** on the `SignalRClient`. If we receive a list of
    **Clients**, we will fire the `ConnectedClientsUpdated` event. If we receive a
    `string`, we will fire the `ChatReceived` event, so we can actually control all
    `SignalR` data via the `BasePresenter` class, and channel specific data types
    to specific events for our views to register. We also have the `WebApiAccess`
    object for accessing the Web API and a string for holding the access token when
    we login successfully:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于`BasePresenter`，这是一个抽象类，将被用于所有演示者。所有演示者都需要`ApplicationState`、`INavigationService`和`SignalRClient`。在整个应用程序中，每个屏幕都需要从`SignalRClient`接收事件才能正常工作，因此我们可以将其引入`BasePresenter`对象。我们已经创建了两个`EventHandlers`；这些是基于通过`SignalRClient`上的**hub代理**接收到的数据触发的。如果我们收到一个**客户端**列表，我们将触发`ConnectedClientsUpdated`事件。如果我们收到一个`string`，我们将触发`ChatReceived`事件，这样我们实际上可以通过`BasePresenter`类控制所有`SignalR`数据，并将特定数据类型通道到特定事件，以便我们的视图进行注册。我们还有一个`WebApiAccess`对象用于访问Web
    API，以及一个字符串用于在登录成功时保存访问令牌：
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Handling Hub proxy callbacks
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Hub代理回调
- en: 'Let''s turn our attention to the `SignalRClient`; we created an `EventHandler`, which
    fires every time data is received from the **Hub**. The `BasePresenter` will be
    responsible for handling the data received from this `EventHandler`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向`SignalRClient`；我们创建了一个`EventHandler`，每当从**Hub**接收到数据时都会触发。`BasePresenter`将负责处理从该`EventHandler`接收到的数据：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The private dictionary `_signalREvents` is used instead of a switch statement.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字典`_signalREvents`用于代替switch语句。
- en: With each `Tuple` received from the SignalRClient's `OnDataReceived` event,
    the first string will be the key matching the indexed `Action<string>` in the
    dictionary. The other string of the `Tuple` is the data string (either a serialized
    JSON of `HashSet<string>`, or a string which represents a chat message), which
    is passed as the input parameter for our `Action<string>`, then, out of this input
    parameter, we will create the correct arguments used for the specified event.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从SignalRClient的`OnDataReceived`事件接收到的`Tuple`，第一个字符串将是匹配字典中索引`Action<string>`的键。`Tuple`中的另一个字符串是数据字符串（要么是`HashSet<string>`的序列化JSON，要么是表示聊天消息的字符串），它作为我们的`Action<string>`的输入参数传递，然后，从这个输入参数中，我们将创建用于指定事件的正确参数。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could take things a step further and abstract a `view` object into the `BasePresenter`,
    as every presenter requires a `view`, but because each view logic is independent,
    it is very hard to centralize this logic in one area. The need for this will come
    if multiple views have similar behaviors. Then we can look at abstracting these
    areas into the `BasePresenter`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`view`对象进一步抽象到`BasePresenter`中，因为每个演示者都需要一个`view`，但由于每个视图逻辑都是独立的，将这种逻辑集中在一个区域是非常困难的。如果多个视图具有类似的行为，这种需求就会出现。然后我们可以将这些区域抽象到`BasePresenter`中。
- en: 'But wait! You may have noticed that we have two types of arguments being passed
    into each `EventHandler`. Add a new file to the `Events` folder in the `Chat.Common`
    project called `ConnectedClientsUpdatedEventArgs.cs`, and implement the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！你可能已经注意到，我们正在将两种类型的参数传递给每个`EventHandler`。在`Chat.Common`项目的`Events`文件夹中添加一个新的文件，命名为`ConnectedClientsUpdatedEventArgs.cs`，并实现以下内容：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We also need another file called `ChatEventArgs.cs`. Add this to the `Events`
    folder and implement the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个名为`ChatEventArgs.cs`的文件。将其添加到`Events`文件夹中，并实现以下内容：
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This object is the wrapper for every message received for a chat message. Now
    we have everything ready to implement our first presenter object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象是每个聊天消息接收到的消息的包装器。现在，我们已经准备好实现我们的第一个展示者对象。
- en: Implementing the LoginPresenter
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录展示者（LoginPresenter）
- en: 'Create a new file called `LoginPresenter.cs`, add it to the `Presenter` folder
    in the `Chat.Common` project, and implement the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`LoginPresenter.cs`的新文件，将其添加到`Chat.Common`项目中的`Presenter`文件夹，并实现以下内容：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our `LoginPresenter` contains a new `ILoginView` interface with two new event
    handlers for the two buttons that will appear on the login screen. We also include
    a new `WebApiAccess` object as we will need to perform logins and registrations
    on the Web API. We also need another function called `SetView`, this will take
    the user interface object and register any `EventHandlers` specified by the `ILoginView`
    interface. Let''s now add the function for handling logins:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`LoginPresenter`包含一个新的`ILoginView`接口，该接口为登录屏幕上出现的两个按钮提供了两个新的事件处理器。我们还包含了一个新的`WebApiAccess`对象，因为我们将在Web
    API上执行登录和注册操作。我们还需要另一个名为`SetView`的函数，这个函数将接受用户界面对象并注册`ILoginView`接口中指定的任何`EventHandlers`。现在让我们添加处理登录的函数：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `HandleLogin` function will check first if the screen is currently progressing
    from another login; we want to make sure that only one login or registration can
    occur at any one time. Firstly, we call the `LoginAsync` and check that the user
    exists in the `UserManager`, then we call the `GetTokenAsync` function to retrieve
    the access token which will be used in our `HubConnection`. If both are successful,
    we push on the `ClientsListViewController` using the `NavigationService`. If either
    fails, we use the `SetErrorMessage` function for displaying an error.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleLogin`函数将首先检查屏幕是否正在从另一个登录操作中继续进行；我们想要确保在任何时候只能发生一次登录或注册。首先，我们调用`LoginAsync`并检查用户是否存在于`UserManager`中，然后我们调用`GetTokenAsync`函数来检索将用于我们的`HubConnection`的访问令牌。如果两者都成功，我们使用`NavigationService`将`ClientsListViewController`推入。如果任一失败，我们使用`SetErrorMessage`函数来显示错误。'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We control the navigation stack by the presenter type passed into the `PushPresenter`/
    `PopPresenter` functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递给`PushPresenter`/ `PopPresenter`函数的展示者类型来控制导航堆栈。
- en: 'Now let''s add the function for handling registrations:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加处理注册的函数：
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Very much the same as the `LoginAsync`, but we call the `RegisterAsync` and
    simply wait for the call to finish and check we have the HTTP status code of `200
    (OK)`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与`LoginAsync`非常相似，但我们调用`RegisterAsync`并简单地等待调用完成并检查我们是否有HTTP状态码`200 (OK)`。
- en: Creating the connection between Presenter and View
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建展示者和视图之间的连接
- en: Now we move on to the user interface design and demonstrate how we set up the
    link between our presenters. Developing the user interface is no different to
    developing natively for iOS and Android; the only difference with MVP is that
    we initialize a view with its related presenter in the constructor.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转向用户界面设计，并展示我们如何设置展示者之间的链接。开发用户界面与为iOS和Android本地开发没有区别；与MVP的不同之处在于，我们在构造函数中初始化一个带有其相关展示者的视图。
- en: 'Let''s start by adding a new folder to the `Chat.iOS` project called `Views`,
    add in a new file called `LoginViewController.cs`, and implement the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Chat.iOS`项目中添加一个名为`Views`的新文件夹开始，添加一个名为`LoginViewController.cs`的新文件，并实现以下内容：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start off simply with the private properties and the constructor, where we
    are passing a new `LoginPresenter` object that we create from the `AppDelegate`
    as the starting presenter. The two text fields are used for the username and password
    entries. We have these as a local variable as we will need to access one instance
    of each from multiple functions. We also have a `UIActivityIndicatorView` for
    displaying the progress when we login and register.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从私有属性和构造函数开始，其中我们传递一个从`AppDelegate`创建的新`LoginPresenter`对象作为起始展示者。两个文本字段用于用户名和密码输入。我们将它们作为局部变量，因为我们将在多个函数中访问每个实例。我们还有一个`UIActivityIndicatorView`用于在登录和注册时显示进度。
- en: 'Let''s go ahead and add the `ViewDidLoad` function. We will implement this
    in a few parts. First we are going to set the view of the presenter and initialize
    all the UI elements and add them into the `View`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加`ViewDidLoad`函数。我们将分几个部分来实现这个函数。首先，我们将设置展示者的视图并初始化所有UI元素并将它们添加到`View`中：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a large block of code, but we are creating quite a few UI elements.
    All have the `TranslatesAutoresizingMaskIntoConstraints` set to `false` ready
    for `**NSLayout**` . Have a look at how we integrate the `ILoginView` implementation
    with the Login and `RegisterEventHandlers` as they are wired to the `TouchUpInside`
    event of each button.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段很大的代码块，但我们正在创建很多 UI 元素。所有元素都将 `TranslatesAutoresizingMaskIntoConstraints`
    设置为 `false`，以便进行 `**NSLayout**`。看看我们如何将 `ILoginView` 实现与登录和 `RegisterEventHandlers`
    集成，因为它们连接到每个按钮的 `TouchUpInside` 事件。
- en: 'Now let''s start building the `NSLayoutConstraints`. Add the following to the
    bottom of the `ViewDidLoad` function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始构建 `NSLayoutConstraints`。将以下内容添加到 `ViewDidLoad` 函数的底部：
- en: Tip
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are using the `DictionaryViews` object that we used in previous chapters.
    Create a new folder called `Extras` and add this object into the `Extras` folder.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用之前章节中使用的 `DictionaryViews` 对象。创建一个名为 `Extras` 的新文件夹，并将此对象添加到 `Extras`
    文件夹中。
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The constraints will position the `buttonView` to the center of the screen horizontally;
    each buttons inside will be positioned horizontally next to each other. The rest
    of the layout is very self-explanatory. We are simply stacking the remaining element
    vertically down the page. The `UIActivityIndicatorView` will be positioned to
    the top right of the screen next to the `TitleLabel`. The rest of the layout will
    make more sense when we try running the application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 约束将 `buttonView` 定位于屏幕中心水平位置；每个按钮内部将水平并排放置。其余布局非常直观。我们只是将剩余元素垂直堆叠在页面底部。`UIActivityIndicatorView`
    将位于屏幕右上角，靠近 `TitleLabel`。当我们尝试运行应用程序时，其余布局将更加合理。
- en: 'Finally, we add the remaining interface implementations; we require both Login
    and `Register` for the `ILoginView` interface. We also require `IsInProgress`
    bool and the `SetErrorMessage` function; this will create a new `UIAlertView`
    showing the error message. We also override the get and set of `IsInProgress`
    to control the start and stop animation of the `UIActivityIndicatorView`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加剩余的界面实现；我们需要 `ILoginView` 接口中的登录和 `Register`。我们还需要 `IsInProgress` 布尔值和
    `SetErrorMessage` 函数；这将创建一个新的 `UIAlertView` 显示错误消息。我们还重写了 `IsInProgress` 的获取和设置，以控制
    `UIActivityIndicatorView` 的开始和停止动画：
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The link between our first view and presenter is not as clean as an MVVM **BindingContext**
    with `Xamarin.Forms`, but the advantage is having no middle layer of rendering
    between the native user interface and the data to be displayed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个视图和演示者之间的链接不如 `Xamarin.Forms` 中的 MVVM **绑定上下文** 清晰，但优点是没有在本地用户界面和要显示的数据之间有中间渲染层。
- en: Building the LoginActivity
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建登录活动
- en: 'Let''s move back into the `Chat.Droid` project; before we create our `Activity`
    we need to create the layout using a new XML sheet. Add a new file called `LoginView.xml`
    into the **Resources** | **l**ayout**** and implement the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `Chat.Droid` 项目；在我们创建 `Activity` 之前，我们需要使用一个新的 XML 表单创建布局。在 **资源** | **布局**
    中添加一个名为 `LoginView.xml` 的新文件，并实现以下内容：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `XMLlayout` will stack the page vertically, with the two buttons placed
    side-by-side.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLlayout` 将页面垂直堆叠，两个按钮并排放置。'
- en: 'A quick way of checking your layouts in `Xamarin.Studio` is to click the **Designer**
    window:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Xamarin.Studio` 中快速检查布局的方法是点击 **设计师** 窗口：
- en: '![Building the LoginActivity](img/B05293_06_16.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![构建登录活动](img/B05293_06_16.jpg)'
- en: 'Now let''s create a new folder called `Views`, add in a new file called `LoginActivity.cs`,
    and implement the first section:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 `Views` 的新文件夹，添加一个名为 `LoginActivity.cs` 的新文件，并实现第一个部分：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we already have the UI logic in our presenter, building the interface
    for `LoginActivity` is much easier as the answers all lie in the presenter. This
    is the advantage of code-sharing using the MVP pattern.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在演示者中有了 UI 逻辑，因此构建 `LoginActivity` 的界面要容易得多，因为所有答案都在演示者中。这是使用 MVP 模式进行代码共享的优势。
- en: In our `OnCreate()` function, we will start with setting the `ContentView` to
    the `XMLlayout` we created previously. We will then register the button `Touch`
    events to the `ILoginView`interface, very much like the iOS version with the `TouchUpInside`
    events. We then retrieve the application from the `GetApplication` function**.**
    We also create an instance of the `ApplicationState`, and create a new `LoginPresenter`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `OnCreate()` 函数中，我们将首先将 `ContentView` 设置为我们之前创建的 `XMLlayout`。然后我们将按钮的 `Touch`
    事件注册到 `ILoginView` 接口，这与 iOS 版本的 `TouchUpInside` 事件非常相似。然后我们从 `GetApplication`
    函数中检索应用程序**。**我们还创建了一个 `ApplicationState` 实例，并创建了一个新的 `LoginPresenter`。
- en: We must also add the requirements of the `ILoginView` and `IView` interfaces.
    The `SetErrorMessage` will use the `AlertDialog.Builder` framework to create the
    same popup as the iOS version. We only set one button for this dialog which will
    simply close the dialog when we press ****OK**:**.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须添加`ILoginView`和`IView`接口的要求。`SetErrorMessage`将使用`AlertDialog.Builder`框架创建与iOS版本相同的弹出窗口。我们只为此对话框设置一个按钮，当我们按下****OK**时，它将简单地关闭对话框。
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See how the structure is the exact same as iOS?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 看看结构是否与iOS完全相同？
- en: 'We just have to match the UI elements for each platform independently. Our
    final part to the activity is the `OnResume` function. This function will reset
    the `CurrentActivity` in the `Application`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要独立匹配每个平台的UI元素。我们活动的最后一部分是`OnResume`函数。此函数将在`Application`中重置`CurrentActivity`：
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important that every time an activity is resumed we reset the `CurrentActivity`,
    otherwise the navigation service will not push/pop on the correct `Activity`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 每次活动恢复时重置`CurrentActivity`非常重要，否则导航服务不会在正确的`Activity`上推送/弹出。
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Excellent! Now we have created the first screen, presenter, and linked it up
    with the navigation service. Let's hop back into the `Chat.iOS` project and build
    the next screen of our application.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经创建了第一个屏幕、演讲者，并将其与导航服务链接起来。让我们回到`Chat.iOS`项目，构建我们应用程序的下一个屏幕。
- en: Implementing the ClientsListPresenter
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现客户端列表演讲者
- en: 'Create a new file called `ClientsListPresenter.cs`, add it to the `Presenter`
    folder in the `Chat.Common` project, and implement the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ClientsListPresenter.cs`的新文件，将其添加到`Chat.Common`项目中的`Presenter`文件夹，并实现以下内容：
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have declared a new **IClientsListView** interface specific to the current
    **UIViewController** (this must be done for every screen). It simply extends off
    the **IView** interface, and we add an extra event handler for selected items
    in our **UITableView**. We then have our constructor which we must pass in an
    **ApplicationState**,**NavigationService,** and an access token. We also initialize
    the **SignalRClient**: the `ConfigureAwait` function is set to false because we
    don''t want to wait for this task to finish.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已声明一个新的**IClientsListView**接口，专门针对当前的**UIViewController**（这必须为每个屏幕执行）。它简单地扩展了**IView**接口，并为我们的**UITableView**中的选中项添加了一个额外的事件处理器。然后我们有我们的构造函数，我们必须传递一个**ApplicationState**、**NavigationService**和一个访问令牌。我们还初始化了**SignalRClient**：`ConfigureAwait`函数设置为false，因为我们不希望等待此任务完成。
- en: We now need to add another function called `SetView`.This will take the action
    user interface object and register any `EventHandlers` specified by the **IClientsListView**
    interface. We also make another call to the Web API to retrieve the current clients
    connected to the **ChatHub**. We also specify that we don't want to wait on this
    task via the `ConfigureAwait`function.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加另一个名为`SetView`的函数。这将采取用户界面操作对象并注册**IClientsListView**接口中指定的任何`EventHandlers`。我们还调用Web
    API以检索连接到**ChatHub**的当前客户端。我们还指定不通过`ConfigureAwait`函数等待此任务。
- en: 'In each `SetView` that will be responding to real-time data updates from the
    **SignalRClient**, we have to reregister to the OnDataReceived`EventHandler` so
    the correct presenter function `HandleSignalRDataReceived` is called:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个将响应来自**SignalRClient**实时数据更新的`SetView`中，我们必须重新注册到`OnDataReceived`事件处理器，以便调用正确的演讲者函数`HandleSignalRDataReceived`：
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A presenter can also have the opposite to the `SetView` function called `ReleaseView`.
    It will be responsible for disposing EventHandlers when screens disappear. This
    ensures we don''t have events on any previous pages doing work when they are not
    visible. Add the following under the `SetView` function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 演讲者还可以有与`SetView`函数相反的`ReleaseView`函数。它将负责在屏幕消失时处理事件处理器。这确保了我们不会在之前的任何页面上有事件在它们不可见时执行工作。在`SetView`函数下添加以下内容：
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let''s add the `Signout` function.This will be called when a user wants
    to disconnect from the **ChatHub** (when the user leaves the **ClientsListViewController**):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加`Signout`函数。当用户想要从**ChatHub**断开连接（当用户离开**ClientsListViewController**）时，将调用此函数：
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s add two more functions: `HandleClientSelected` will use the **INavigationService**
    to push the next screen on to the stack, and the other function, `HandleConnectedClientsUpdated` will
    call the native implementation in the user interface object. We will also filter
    the list of clients using Linq to include all other clients but the current user:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加两个额外的函数：`HandleClientSelected`将使用**INavigationService**将下一个屏幕推入堆栈，另一个函数`HandleConnectedClientsUpdated`将调用用户界面对象中的本地实现。我们还将使用Linq过滤客户列表，包括所有其他客户但排除当前用户：
- en: '[PRE48]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we know that we require a **UITableView **on the **ClientsListView **screen,
    we need to create a **TableSource** object that will show all our clients that
    are connected to the **ChatHub**. We also need a model object to hold the data
    to be displayed for each **Client**.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道我们需要在`ClientsListView`屏幕上使用**UITableView**，我们需要创建一个**TableSource**对象来显示所有连接到**ChatHub**的客户。我们还需要一个模型对象来存储每个**Client**要显示的数据。
- en: 'Firstly, create a new folder in the **Chat.Common** project called **Model**,
    add in a new file called `Client.cs` and implement the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在**Chat.Common**项目中创建一个名为**Model**的新文件夹，添加一个名为`Client.cs`的新文件，并实现以下内容：
- en: '[PRE49]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For each cell, we are only going to display one text label showing the username
    of the connected client. Now let''s add in a new file called `ClientsTableSource.cs` and
    start with the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个单元格，我们只将显示一个文本标签，显示连接客户的用户名。现在让我们添加一个名为`ClientsTableSource.cs`的新文件，并从以下内容开始：
- en: '[PRE50]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We require a private `List` for holding the latest clients connected, we have
    our `CellIdentifier` label set as `ClientCell`, and we have an `EventHandler`
    for selected cell events that will occur from the `UITableView`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个私有的`List`来存储最新连接的客户，我们的`CellIdentifier`标签设置为`ClientCell`，并且我们有一个`EventHandler`用于处理从`UITableView`中选中的单元格事件。
- en: 'Every time one of these events are fired from the `TableSource`, we will be
    firing the event handler in our `ClientsListPresenter` presenter. Now let''s implement
    the rest of the overrides required by the `UITableViewSource` class:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 每当这些事件之一从`TableSource`触发时，我们将在我们的`ClientsListPresenter`演示者中触发事件处理器。现在让我们实现`UITableViewSource`类所需的其余重写方法：
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our `GetCell` function will use the default `UITableViewCellStyle`, and the
    text will be set to the username of the `Client` object. Our `RowSelected` function
    will fire our custom `EventHandlerItemSelected`. We will register a delegate on
    this `EventHandler` for firing our related presenter `Event`. Finally, our `UpdateClients`
    will be called whenever we receive a proxy event when the client count changes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GetCell`函数将使用默认的`UITableViewCellStyle`，文本将设置为`Client`对象的用户名。我们的`RowSelected`函数将触发我们的自定义`EventHandlerItemSelected`。我们将在该`EventHandler`上注册一个代理以触发相关的演示者`Event`。最后，我们的`UpdateClients`将在收到客户端计数变化时的代理事件时被调用。
- en: Creating ClientListViewController
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ClientListViewController
- en: Now we will move on to the user interface design and demonstrate how we set
    up the link between our presenters. Developing the user interface is no different
    to developing natively for iOS and Android; the only difference with MVP is that
    we initialize a view with its related presenter in the constructor.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向用户界面设计，并演示我们如何设置演示者之间的链接。开发用户界面与为iOS和Android本地开发没有不同；与MVP的不同之处在于我们在构造函数中初始化一个带有其相关演示者的视图。
- en: 'Let''s start by adding a new folder to the `Chat.iOS` project called `Views`,
    add in a new file called `ClientsListViewController.cs`, and implement the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向`Chat.iOS`项目添加一个名为`Views`的新文件夹开始，添加一个名为`ClientsListViewController.cs`的新文件，并实现以下内容：
- en: '[PRE52]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice how we pass the presenter in the constructor of the `UIViewController`?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何在`UIViewController`的构造函数中传递演示者的？
- en: We will be doing this with every view that is added to the navigation service.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对添加到导航服务中的每个视图都执行此操作。
- en: 'Inside the constructor, we are also registering the `itemSelected` event to
    fire the interface event for our presenter. Let''s add in the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们还注册了`itemSelected`事件来触发我们的演示者接口事件。让我们添加以下内容：
- en: '[PRE53]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `ViewDidLoad` function, we will always be calling the `SetView` on a
    presenter class, and passing the view itself to the presenter. We are also going
    to add another little trick on this screen to override the `navbar` back button.
    We must create a `UIBArButtonItem`, which will be set as the left button of the
    navigation bar. When we instantiate this item, the `HandleSignout` function will
    be called when this button is pressed. Let''s add this to the `UIViewController`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 函数中，我们总是会调用演示者类上的 `SetView`，并将视图本身传递给演示者。我们还将在这个屏幕上添加另一个小技巧来重写
    `navbar` 返回按钮。我们必须创建一个 `UIBarButtonItem`，它将被设置为导航栏的左侧按钮。当我们实例化此项目时，当按下此按钮时将调用
    `HandleSignout` 函数。让我们将其添加到 `UIViewController`：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The function will show an alert and wait for a response to be provided by the
    user. In this case, it will be `"Yes"` or `"No"`. We are going to add another
    function `ShowAlert()`, which will use the `TaskCompletionSource` framework to
    allow us to await a response from a `UIAlertView`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将显示一个警告并等待用户提供响应。在这种情况下，将是 `"是"` 或 `"否"`。我们将添加另一个函数 `ShowAlert()`，该函数将使用
    `TaskCompletionSource` 框架来允许我们从 `UIAlertView` 等待响应。
- en: The TaskCompletionSource framework
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource` 框架'
- en: 'The `ShowAlert` function will instantiate a new instance of a `TaskCompletionSource`
    of type `bool`. We then invoke the action on the main thread using the `UIApplication.SharedApplication`,
    and then return the `Task` object of the `TaskCompletionSource`. This means we
    can wait for the task to be returned When we create the `UIAlertView`, we set
    the `Clicked` event of the dialog to call the `SetResult`function of the `TaskCompletionSource`,
    so the `Task` will not finish until this click event has occurred:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowAlert` 函数将实例化一个 `TaskCompletionSource` 的新实例，其类型为 `bool`。然后我们使用 `UIApplication.SharedApplication`
    在主线程上调用操作，然后返回 `TaskCompletionSource` 的 `Task` 对象。这意味着我们可以等待任务返回。当我们创建 `UIAlertView`
    时，我们将设置对话框的 `Clicked` 事件以调用 `TaskCompletionSource` 的 `SetResult` 函数，这样 `Task`
    就不会完成，直到这个点击事件发生：'
- en: '[PRE55]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that we have overriden the back button, when a user tries to click back
    on the clients list screen to return to the login, the `UIAlertView` will appear,
    asking if the user wants to signout (meaning the user will disconnect from the
    `ChatHub`). If the user presses **Yes**, we will call the `Signout` function on
    the `ClientsListPresenter`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重写了返回按钮，当用户尝试在客户端列表屏幕上点击返回以返回登录时，将出现 `UIAlertView`，询问用户是否想要注销（这意味着用户将从
    `ChatHub` 断开连接）。如果用户按下 **是**，我们将调用 `ClientsListPresenter` 上的 `Signout` 函数。
- en: 'Now let''s get back to the `ViewDidLoad` function and add in the `NSLayoutConstraints`
    to build the screen:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `ViewDidLoad` 函数并添加 `NSLayoutConstraints` 以构建屏幕：
- en: '[PRE56]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We have all the elements stacked vertically, taking up the entire width of the
    screen with padding.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有元素垂直堆叠，占据整个屏幕宽度并添加填充。
- en: 'Finally, we also want to add the `ViewDidUnload` function, so we can remove
    the `OnDataReceived` event on the `SignalRClient`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还想添加 `ViewDidUnload` 函数，以便我们可以从 `SignalRClient` 中移除 `OnDataReceived` 事件：
- en: '[PRE57]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Creating the ClientsListActivity
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `ClientsListActivity`
- en: 'Let''s move back again to the `Chat.Droid` project. Create a new folder called
    `Views`, add in a new file called `ClientsListView.cs`, and implement the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到 `Chat.Droid` 项目。创建一个名为 `Views` 的新文件夹，添加一个名为 `ClientsListView.cs` 的新文件，并实现以下内容：
- en: '[PRE58]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For the first section of the `ClientsListActivity`, let's look at the `OnCreate`override.
    We will start with the `ChatApplication` instance and set the current `Activity`
    to the `ClientsListView` activity. We then instantiate a new `ClientsListPresenter`,
    add in the state, and add a new `NavigationService`. We will also set the view
    object of the presenter to the `ClientsListView`. Finally, we simply instantiate
    a new `ClientsListAdapter` and set it to the `ListAdapter` of the `Activity`,
    as we are inheriting a `ListActivity`. We are going to have a different layout
    to iOS and only show the `ListView` on this screen so we can demonstrate the `ListActivity`;
    therefore, we don't need an `XMLsheet` for the layout of this `Activity`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ClientsListActivity` 的第一个部分，让我们看看 `OnCreate` 重写方法。我们将从 `ChatApplication`
    实例开始，将当前 `Activity` 设置为 `ClientsListView` 活动。然后实例化一个新的 `ClientsListPresenter`，添加状态，并添加一个新的
    `NavigationService`。我们还将将演示者的视图对象设置为 `ClientsListView`。最后，我们简单地实例化一个新的 `ClientsListAdapter`
    并将其设置为 `Activity` 的 `ListAdapter`，因为我们正在继承 `ListActivity`。我们将有一个与 iOS 不同的布局，只在这个屏幕上显示
    `ListView` 以演示 `ListActivity`；因此，我们不需要为这个 `Activity` 的布局创建 `XMLsheet`。
- en: The `OnResume` function is the same as the `LoginActivity`; we have to maintain
    the current `Activity`shown to the user. We also want to override the `OnPause`
    function to call `ReleaseView` on the `ClientsListPresenter` so we remove the `EventHandler`
    on the `OnDataReceived` property of the `SignalRClient`. This ensures we don't
    call `HandleSignalRDataReceived` whilst the screen is not visible.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnResume` 函数与 `LoginActivity` 相同；我们必须保持向用户显示的当前 `Activity`。我们还想覆盖 `OnPause`
    函数，以便在 `ClientsListPresenter` 上调用 `ReleaseView`，这样我们就可以从 `SignalRClient` 的 `OnDataReceived`
    属性中移除 `EventHandler`。这确保了当屏幕不可见时，我们不会调用 `HandleSignalRDataReceived`。'
- en: '[PRE59]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now let''s add the `IClientsListView` and `IView` implementation.The `NotifyConnectedClientsUpdated` will
    call the `UpdateClients` function on the `ListAdapter`, and we must propogate
    the `NotifyDataSetChanged` on the main thread as we are making data changes to
    the `ListView`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来添加 `IClientsListView` 和 `IView` 的实现。`NotifyConnectedClientsUpdated` 将会在
    `ListAdapter` 上调用 `UpdateClients` 函数，并且我们必须在主线程上传播 `NotifyDataSetChanged`，因为我们正在对
    `ListView` 进行数据更改：
- en: '[PRE60]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `SetErrorMessage()` will initiate a dialog similar to iOS, using the `AlertDialog.Builder`
    framework. In this case, we only need to set the original button since we only
    need one button on the dialog.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetErrorMessage()` 将会启动一个类似于 iOS 的对话框，使用 `AlertDialog.Builder` 框架。在这种情况下，我们只需要设置原始按钮，因为我们只需要在对话框中有一个按钮。'
- en: Overriding the OnBackPressed activity
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖 `OnBackPressed` 活动
- en: 'With our iOS implementation we integrated an override to the navigation back
    button, so when a user leaves the `ClientListViewController`, we ask the user
    if they would like to signout from the `ChatHub`. We are going to do the same
    here but on the Android platform. We will be building the alert from the `AlertDialog.Builder`
    framework:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 iOS 实现中，我们集成了一个覆盖导航返回按钮的功能，所以当用户离开 `ClientListViewController` 时，我们会询问用户是否想要从
    `ChatHub` 中注销。我们在这里也将做同样的事情，但是在 Android 平台上。我们将从 `AlertDialog.Builder` 框架构建警报：
- en: '[PRE61]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We start with instantiating a new builder object which must take the `Activity`
    context as the only parameter. We then set the title and message of the dialog,
    and two buttons for the `"Yes"` and `"No"` selections. Only when the user selects
    `"Yes"` does an action occur by calling the same `Signout` as with iOS.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从实例化一个新的构建器对象开始，该对象必须只接受 `Activity` 上下文作为唯一参数。然后我们设置对话框的标题和消息，并为 `"Yes"` 和
    `"No"` 选择设置两个按钮。只有当用户选择 `"Yes"` 时，才会通过调用与 iOS 相同的 `Signout` 来执行操作。
- en: Our last piece of this `Activity` is to override the `OnListItemClick`. When
    an item in the list is selected, we want to fire the `ClientSelected` event specified
    by the interface, so we can tie this event logic into the `ClientsListPresenter:`
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个 `Activity` 的最后一部分是覆盖 `OnListItemClick`。当列表中的某个项目被选中时，我们希望触发接口中指定的 `ClientSelected`
    事件，这样我们就可以将此事件逻辑连接到 `ClientsListPresenter`：
- en: '[PRE62]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Building the ListAdapter
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 `ListAdapter`
- en: 'Before we build our `ListAdapter,` we need to create another AXML sheet for
    the **CustomCell**, add another file to the **Resources** | **layout** folder
    called `CustomCell.xml`, and implement the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建 `ListAdapter` 之前，我们需要为 **CustomCell** 创建另一个 AXML 表格，向 **Resources** |
    **layout** 文件夹中添加另一个文件，名为 `CustomCell.xml`，并实现以下内容：
- en: '[PRE63]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is another simple layout which has one `TextView` wrapped in a `LinearLayout`.
    The `TextView` will display the `ConnectionId` for each `Client`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个另一个简单的布局，其中包含一个包裹在 `LinearLayout` 中的 `TextView`。`TextView` 将显示每个 `Client`
    的 `ConnectionId`。
- en: 'Now let''s get back to the `ListAdapter`. Inside the `Views` folder, add another
    file called `ClientsListAdapter.cs` and implement the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到 `ListAdapter`。在 `Views` 文件夹内，添加另一个名为 `ClientsListAdapter.cs` 的文件，并实现以下内容：
- en: '[PRE64]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Firstly, we are just creating a new class which inherits the `BaseAdapter` class
    which is typecasted to the `Client` object. We also have a private `List` which
    is going to store the clients retrieved from the `SignalRClient`, and finally
    we have the current **Activity Context**. Now let's add in the required override
    functions from the `BaseAdapter:`
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只是创建一个新的类，该类继承自 `BaseAdapter` 类，并将其转换为 `Client` 对象。我们还有一个私有的 `List`，它将存储从
    `SignalRClient` 获取到的客户端，最后我们有当前的 **Activity 上下文**。现在让我们添加来自 `BaseAdapter` 的所需覆盖函数：
- en: '[PRE65]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first override is to implement an index reference to the `_clientslist`.
    All the override functions are the same as we implemented in [Chapter 1](ch01.html
    "Chapter 1.  Building a Gallery Application"), *Building a Gallery Application*.
    Let's turn our attention to the `GetView` function; we are simply creating a new
    `CustomCell` layout using the `LayoutInflater` framework (this will take any AXML
    file and create a new instance of the view).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个覆盖是实现对`_clientslist`的索引引用。所有覆盖函数都与我们实现的相同，如[第1章](ch01.html "第1章. 构建画廊应用程序")中所述，*构建画廊应用程序*。让我们将注意力转向`GetView`函数；我们只是使用`LayoutInflater`框架创建一个新的`CustomCell`布局（这将接受任何AXML文件并创建视图的新实例）。
- en: Then, now that we have our new view, we will set the `Text` property of the `TextView`
    object in the `CustomCell` view to the `Username` in our `Client` object.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，现在我们已经有了我们的新视图，我们将设置`CustomCell`视图中的`TextView`对象的`Text`属性为`Client`对象中的`Username`。
- en: 'Finally, our last step is to add a another function called `UpdateClients` (as
    specified in our presenter). This will simply take a new `IEnumerable` of **Clients**,
    and the `List` will be updated accordingly:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的最后一步是添加一个名为`UpdateClients`的另一个函数（如展示者中指定）。这将会简单地接受一个新的`IEnumerable`的**Clients**，并且`List`将会相应地更新：
- en: '[PRE66]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With complete direction from the presenter class, look how fast we developed
    the android interface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示者类的完全指导下，看看我们是如何快速开发Android界面的。
- en: Tip
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before we can test the connection to the server **Hub**, we have to make changes
    to the application.config and `http.sys` using `netsh` in the command prompt.
    Follow the section *Hosting the Web API project locally* in [Chapter 5](ch05.html
    "Chapter 5. Building a Stocklist Application"), *Building a Stocklist Application*.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够测试与服务器**Hub**的连接之前，我们必须在命令提示符中使用`netsh`对`application.config`和`http.sys`进行更改。遵循[第5章](ch05.html
    "第5章. 构建股票列表应用程序")中*在本地托管Web API项目*的部分，*构建股票列表应用程序*。
- en: You can try testing the first page. Startup the server **Hub** and watch the
    list update whenever we connect or disconnect a new client. A good test on this
    example is to use multiple running instances of the application on different devices.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试测试第一页。启动服务器**Hub**，并观察列表在连接或断开新客户端时更新。在这个例子中，使用多个在不同设备上运行的应用程序实例进行测试是一个很好的测试方法。
- en: Building the ChatPresenter
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天展示者
- en: 'Now we move on to the next screen; this will be our chat window in which we
    will be passing messages between different clients connected to the server **Hub**.
    Our first step is to build the `ChatPresenter`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向下一个屏幕；这将是我们聊天窗口，我们将在此窗口中传递连接到服务器**Hub**的不同客户端之间的消息。我们的第一步是构建`ChatPresenter`：
- en: '[PRE67]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We are going to start by inheriting the `BasePresenter` class. It will include
    two `private` properties, one for the `Client` selected from the previous `ClientListView`
    screen and another for the `IChatView` interface. The `IChatView` interface inherits
    the `IView` interface and it will include one function for handling messages received
    from the receiving `Client`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先继承`BasePresenter`类。它将包括两个`private`属性，一个用于从上一个`ClientListView`屏幕中选择的`Client`，另一个用于`IChatView`接口。`IChatView`接口继承自`IView`接口，它将包括一个用于处理从接收`Client`接收到的消息的功能。
- en: 'Let''s implement the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现以下内容：
- en: '[PRE68]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It is the same set up as the `ClientsListPresenter`; our `SetView` function
    will take the native view object and register the events. We also have another
    function, `SendChat` which will invoke the `SendChat` function on the **Hub**.
    Don''t forget the `ReleaseView` function; this will be exactly the same as the
    `ClientsListPresenter`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 它与`ClientsListPresenter`的设置相同；我们的`SetView`函数将接受原生视图对象并注册事件。我们还有一个名为`SendChat`的另一个函数，它将在**Hub**上调用`SendChat`函数。不要忘记`ReleaseView`函数；这将与`ClientsListPresenter`完全相同：
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now that we have built all our presenter objects, we need to make a small update
    to the navigation service implementations to allow navigation for the other screens.
    Open the Android `NavigationService.cs`, and in the `PushPresenter` function update
    the `if` statement to the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了所有展示者对象，我们需要对导航服务实现进行小更新，以允许导航到其他屏幕。打开Android的`NavigationService.cs`，并在`PushPresenter`函数中更新`if`语句为以下内容：
- en: '[PRE70]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For the iOS `NavigationService.cs`, update the if statement to the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS的`NavigationService.cs`，将if语句更新为以下内容：
- en: '[PRE71]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Building the iOS ChatView
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建iOS聊天视图
- en: 'Add a new file called `ChatViewController` into the `Views` project of the
    `Chat.iOS` project and implement the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chat.iOS`项目的`Views`项目中添加一个名为`ChatViewController`的新文件，并实现以下内容：
- en: '[PRE72]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We have multiple `Private` properties, one for the presenter, a local `UITextField`.
    We need this UI object to be local, as we need to extract the `Text` value to
    send through the `SignalRClient`, and we also need the `UIScrollView` to be local
    so we can change the content size and add in `ChatView` objects. The integers
    are use to record the current top (y-axis + height) of the all chat messages which
    will display on the screen. Finally, the remaining `nfloat` is used for recording
    the height and width of the screen.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个 `Private` 属性，一个用于演示者，一个用于本地的 `UITextField`。我们需要这个 UI 对象是本地的，因为我们需要提取 `Text`
    值通过 `SignalRClient` 发送，我们还需要 `UIScrollView` 是本地的，这样我们就可以更改内容大小并添加 `ChatView` 对象。整数用于记录所有聊天消息在屏幕上显示的当前顶部（y
    轴 + 高度）。最后，剩余的 `nfloat` 用于记录屏幕的高度和宽度。
- en: Note
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will see all these variables used further on through the class functions.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续的类函数中看到所有这些变量的使用。
- en: 'Let''s now add the `ViewDidLoad` function to build the user interface:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加 `ViewDidLoad` 函数来构建用户界面：
- en: '[PRE73]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The chat screen will contain a `UITextField`, a `UIButton`, and a `UIScrollView`.
    The button is for notifying the current `Text` value of the `UITextField` to be
    sent to the server **Hub**, and our `UIScrollView` will contain all the messages
    published from each client.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天屏幕将包含一个 `UITextField`、一个 `UIButton` 和一个 `UIScrollView`。按钮用于通知将 `UITextField`
    的当前 `Text` 值发送到服务器 **Hub**，我们的 `UIScrollView` 将包含来自每个客户端发布的所有消息。
- en: 'We also want to add the `ViewDidUnload()` function, so we can remove the `OnDataReceived`
    event on the `SignalRClient`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望添加 `ViewDidUnload()` 函数，以便我们可以从 `SignalRClient` 上移除 `OnDataReceived` 事件：
- en: '[PRE74]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s then add the `IView` implementation:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加 `IView` 实现：
- en: '[PRE75]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `IView` implementation is the same as with the `ClientsListViewController`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`IView` 的实现与 `ClientsListViewController` 相同。'
- en: 'Let''s create a new file called `ChatBoxView.cs` and add it to the `Views`
    folder. We will create a new one of these for every chat message:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `ChatBoxView.cs` 的新文件，并将其添加到 `Views` 文件夹中。我们将为每条聊天消息创建一个这样的新文件：
- en: '[PRE76]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is a very simple object that contains one `UILabel` for the chat message.
    We also set the height and width of this label to the height and width of the
    `UIView` using `NSAutoLayout`. We also round the corners of the `Layer` to `5`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的对象，包含一个用于聊天消息的 `UILabel`。我们还使用 `NSAutoLayout` 将这个标签的高度和宽度设置为 `UIView`
    的高度和宽度。我们还使用 `Layer` 将角落的圆角设置为 `5`。
- en: If you have ever used the **SMS** application on any iOS device, you will see
    we have two colors, distinguishing between you and the person you are talking
    to. We are going to do the same with our application but instead of using standard
    colors from the `UIColor` interface, we are going to use custom hex colors.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在任何 iOS 设备上使用过 **SMS** 应用程序，你会看到我们有两种颜色，用于区分你和你要交谈的人。我们将在我们的应用程序中做同样的事情，但我们将使用自定义的十六进制颜色，而不是使用
    `UIColor` 接口的标准颜色。
- en: Extending the UIColor framework
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 UIColor 框架
- en: 'In this section we are going to apply a common technique for extending on standard
    iOS classes. In the `UIColor` class, there is no function for applying hex strings
    to determine a color, so let''s add this on top. Create a new folder called `Extensions`,
    add in a new file called `UIColorExtensions.cs`, and implement the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用一种常见的扩展标准 iOS 类的技术。在 `UIColor` 类中，没有用于将十六进制字符串应用于确定颜色的函数，所以让我们在顶部添加这个功能。创建一个名为
    `Extensions` 的新文件夹，添加一个名为 `UIColorExtensions.cs` 的新文件，并实现以下内容：
- en: '[PRE77]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When we extend a class with extra functions, the first input parameter must
    always start with the `this` keyword; this represents the current object calling
    the function. The next two parameters are a string representing the hex value
    and an alpha percentage (between 0 and 1) for transparency.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过额外的函数扩展一个类时，第一个输入参数必须始终以 `this` 关键字开头；这代表调用该函数的当前对象。接下来的两个参数是一个表示十六进制值的字符串和一个透明度百分比（介于
    0 和 1 之间）。
- en: Firstly, we remove the `#` character from the hex string. We then double-check
    if the alpha character is below 0, if so, set the alpha to 0, and vice versa with
    the alpha if it is greater than 1\. Then our switch statement will select a case
    based on the hex string length (either an RGB or RRGGBB value). Then we simply
    extract the red, green, and blue string values and return a new `UIColor` from
    the red, green, and blue values.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从十六进制字符串中移除 `#` 字符。然后我们再次检查 alpha 字符是否小于 0，如果是，则将 alpha 设置为 0，反之亦然，如果 alpha
    大于 1。然后我们的 switch 语句将根据十六进制字符串的长度（RGB 或 RRGGBB 值）选择一个案例。然后我们简单地提取红色、绿色和蓝色字符串值，并从红色、绿色和蓝色值返回一个新的
    `UIColor`。
- en: 'Now we can apply a hex color string to the `UIColor` framework like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将十六进制颜色字符串应用到`UIColor`框架中，如下所示：
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Tip
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since MonoTouch 5.4, we have to apply the `FromHex` extension to a `Color.Clear`.
    Previously we were able to use a parameterless constructor like this: `new UIColor().FromHex("FFFFFF")`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 自从MonoTouch 5.4以来，我们必须将`FromHex`扩展应用到`Color.Clear`上。之前我们能够使用无参构造函数，如下所示：`new
    UIColor().FromHex("FFFFFF")`。
- en: 'Now that we have our `UIColor` additions, let''s use these for our chatbox
    `BackgroundColor` property. We are going to add in a new function to the `ChatView`,
    which will create a new `ChatBox` and set the color according to whether it was
    sent or received. We will also do the same with the x-axis position and set the
    `ChatBox` to the left if sent and to the right if received:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`UIColor`的添加，让我们将这些用于我们的chatbox `BackgroundColor`属性。我们将在`ChatView`中添加一个新函数，该函数将创建一个新的`ChatBox`并根据是发送还是接收来设置颜色。我们还将对x轴位置做同样的处理，如果发送则将`ChatBox`设置在左侧，如果接收则设置在右侧：
- en: '[PRE79]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We first update the `ContentSize` property of the `UIScrollView`; this represents
    the dimensions of the scroll area. The `currentTop` variable is used to record
    the last ChatBox's y-axis value so we know the height of the UIScrollView's content,
    and so we know the next y-axis position for the next `ChatBox`. Then we add the
    new `ChatBox` object, pass in the new message, and assign the message to the `Title`
    of the `UILabel`. We also use our new extension function to set the `BackgroundColor`
    property of the `ChatBox`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先更新`UIScrollView`的`ContentSize`属性；这代表了滚动区域的尺寸。`currentTop`变量用于记录最后一个ChatBox的y轴值，这样我们就知道UIScrollView内容的长度，以及下一个ChatBox的下一个y轴位置。然后我们添加新的`ChatBox`对象，传入新的消息，并将消息分配给`UILabel`的`Title`。我们还使用我们新的扩展函数来设置`ChatBox`的`BackgroundColor`属性。
- en: Now, where do we call this function?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在哪里调用这个函数？
- en: 'We have two areas, whenever the `Send` button is pressed, or when a message
    is received. Let''s add the `TouchUpInside` callback on the `_sendButton`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个区域，无论何时按下`Send`按钮，还是收到一条消息。让我们在`_sendButton`上添加`TouchUpInside`回调：
- en: '[PRE80]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `HandleSendButton` will also call the presenter function, `SendChat`, and
    send the message to the server **Hub**. We also need to add the `IChatView` implementation.
    The `NotifyChatMessageReceived` function will also use `CreateChatBox`, but this
    time we will set the `received` flag to `true`. This must also be invoked on the
    main thread as sometimes the event might fire this function on another thread:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleSendButton`也会调用表示函数`SendChat`，并将消息发送到服务器**Hub**。我们还需要添加`IChatView`的实现。`NotifyChatMessageReceived`函数也会使用`CreateChatBox`，但这次我们将`received`标志设置为`true`。这必须在主线程上调用，因为有时事件可能会在另一个线程上触发此函数：'
- en: '[PRE81]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Fantastic!
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: Now that we have finished the iOS `ChatView`, try testing. Connect two iOS clients
    to the **Hub**, select the other client from either client, try entering messages
    into the `UITextField`, press Send, and watch the magic happen.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了iOS `ChatView`，尝试测试。连接两个iOS客户端到**Hub**，从任一客户端选择另一个客户端，尝试在`UITextField`中输入消息，按下发送，看看魔法发生。
- en: That's enough of iOS development, let's move back over to Android and complete
    the `ChatView`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: iOS开发已经足够了，让我们回到Android，完成`ChatView`。
- en: Android TableLayouts
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android TableLayouts
- en: Let's move back to the Android implementation. This part is easy, we have already
    mapped the UI logic to the `ChatPresenter` so let's get straight into building
    the interface. For our `ChatView.xml` file, we are going to introduce a `TableLayout`.
    TableLayouts are similar to **Grids** in `Xamarin.Forms`; we simply split an area
    into rows and columns. We are able to set UI objects to specific rows and columns
    as well as span specific UI objects across multiple rows and columns.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Android实现。这部分很简单，我们已经将UI逻辑映射到`ChatPresenter`，所以让我们直接构建界面。对于我们的`ChatView.xml`文件，我们将引入一个`TableLayout`。TableLayouts类似于`Xamarin.Forms`中的**Grids**；我们只是将一个区域分割成行和列。我们还可以将UI对象设置到特定的行和列，以及跨多行多列设置特定的UI对象。
- en: 'Let''s add a new file called `ChatView.xml` to the **Resources** | **layout**
    folder and implement the following:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**Resources** | **layout**文件夹中添加一个名为`ChatView.xml`的新文件，并实现以下内容：
- en: '[PRE82]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Each row is declared using the `<TableRow>` tag; our first row contains an `EditText`
    item for the messages, and a button to call the `SendChat` function on the `SignalRClient`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都使用`<TableRow>`标签声明；我们的第一行包含一个用于消息的`EditText`项和一个按钮，用于在`SignalRClient`上调用`SendChat`函数。
- en: Building the Android ChatActivity
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Android ChatActivity
- en: 'Let''s move back to the Android implementation. This part is easy, we have
    already mapped the UI logic to the `ChatPresenter`, so let''s get straight into
    building the interface. Add a new file to the `Views` folder in the `Chat.Droid`
    project, call it `ChatActivity.cs`, and implement the first part:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Android 的实现。这部分很简单，我们已经将 UI 逻辑映射到了 `ChatPresenter`，所以让我们直接开始构建界面。在 `Chat.Droid`
    项目的 `Views` 文件夹中添加一个新文件，命名为 `ChatActivity.cs`，并实现第一部分：
- en: '[PRE83]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the `OnCreate` function, we are setting the content view to the `ChatView`
    layout. We then retrieve the width of the screen as we need to be able position
    the x-axis of the chat box to the left or right of the screen, based on whether
    it was sent/received. We then assign the SendButton''s `Touch` event to call the
    `HandleSendButton` function. Finally, we retrieve the `ChatApplication` object
    and cast the presenter to a `ChatPresenter`, call the `SetView`  function, and
    pass the `ChatActivity`. Then we set the `CurrentActivity` of the `ChatApplication`
    object to the `ChatActivity`. Let''s also add an override on the `OnPause` so
    we can call `ReleaseView` on the `ChatPresenter` to remove the `OnDataReceived`
    event from the `SignalRClient`. This is the equivalent to the `ViewDidUnload` override
    on a `UIViewController`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnCreate` 函数中，我们将内容视图设置为 `ChatView` 布局。然后我们获取屏幕宽度，因为我们需要能够将聊天框的 x 轴定位在屏幕的左侧或右侧，这取决于它是发送还是接收。然后我们将
    SendButton 的 `Touch` 事件分配给调用 `HandleSendButton` 函数。最后，我们检索 `ChatApplication` 对象，并将表示器强制转换为
    `ChatPresenter`，调用 `SetView` 函数，并传递 `ChatActivity`。然后我们将 `ChatApplication` 对象的
    `CurrentActivity` 设置为 `ChatActivity`。我们还在 `OnPause` 上添加了一个覆盖，这样我们就可以在 `ChatPresenter`
    上调用 `ReleaseView` 来从 `SignalRClient` 中移除 `OnDataReceived` 事件。这相当于在 `UIViewController`
    上的 `ViewDidUnload` 覆盖：
- en: '[PRE84]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now we have to add the `IChatView` implementation; `CreateChatBox` must be
    propagated to the main thread as this event will sometimes call this function
    on a different thread:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须添加 `IChatView` 实现；`CreateChatBox` 必须传播到主线程，因为这个事件有时会在不同的线程上调用这个函数：
- en: '[PRE85]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now we have to add the `IView` implementation, which we can simply copy from
    the previous activity:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须添加 `IView` 实现，我们可以简单地从先前的活动复制：
- en: '[PRE86]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Before we add the remaining functions, we are going to add another layout for
    the `ChatBoxView` in Android. Add a new file called `ChatBoxView.xml`, add it
    to the **Resources** | **layout** folder, and implement the following:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加剩余的函数之前，我们将在 Android 中为 `ChatBoxView` 添加另一个布局。添加一个名为 `ChatBoxView.xml` 的新文件，将其添加到
    **资源** | **布局** 文件夹中，并实现以下内容：
- en: '[PRE87]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This is a very simple view which contains a `LinearLayout` that contains one
    `TextView` to display the chat message.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的视图，它包含一个 `LinearLayout`，其中包含一个 `TextView` 来显示聊天消息。
- en: 'Finally, we add the remaining `HandleSendButton` and `CreateChatBox` functions;
    they are the same functions as iOS, but use Android objects:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加剩余的 `HandleSendButton` 和 `CreateChatBox` 函数；它们与 iOS 中的函数相同，但使用 Android
    对象：
- en: '[PRE88]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `HandleSendButton` function will do the exact same: call the presenter
    function, `SendChat`, create a new chatbox, and add it to the `ScrollView`. The
    `CreateChatBox` function will use the context''s `LayoutInflator` and create a
    new `ChatBoxView`. We will then set the x, y, width and height properties, retrieve
    the `TextView` property of the view, and set the `Text` property to the message.
    We then call `SetBackgroundColor` on the view and change the background color
    according to whether it has been sent or received. Finally, we add the new view
    to the `ScrollView` and record the current y-axis value.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleSendButton` 函数将做完全相同的事情：调用表示器函数 `SendChat`，创建一个新的聊天框，并将其添加到 `ScrollView`。`CreateChatBox`
    函数将使用上下文的 `LayoutInflator` 创建一个新的 `ChatBoxView`。然后我们将设置 x、y、宽度和高度属性，检索视图的 `TextView`
    属性，并将 `Text` 属性设置为消息。然后我们在视图上调用 `SetBackgroundColor` 并根据是否已发送或接收更改背景颜色。最后，我们将新视图添加到
    `ScrollView` 并记录当前的 y 轴值。'
- en: Running the server and clients
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务器和客户端
- en: Before we can test everything together, please revisit the section in [Chapter
    5](ch05.html "Chapter 5. Building a Stocklist Application"), *Building a Stocklist
    Application*, called **Hosting a Web API project locally**. This must be done
    before we can connect to the server side from our mobile clients. Once we have
    the server application running, build and run the mobile application from either
    platform and register a user first before we login. The `Register` button will
    place the new account in the `UserManager`, allowing us to perform a **Login**
    with those account details as they now exist in the `UserManager`. Once we login,
    we can't do anymore unless we have another mobile client that can run the app
    and login. It is best to test this application with two mobile devices running
    the mobile application. Once both have logged in and the clients list screen has
    been loaded, each user will be connected to the user, and both users can now click
    on each other to navigate to the chat window and begin sending messages to each
    other.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够一起测试所有内容之前，请重新查看[第5章](ch05.html "第5章。构建股票清单应用程序")中的部分，名为**本地托管Web API项目**，即*构建股票清单应用程序*。这必须在我们可以从我们的移动客户端连接到服务器端之前完成。一旦我们有了运行的服务器应用程序，就可以从任一平台构建并运行移动应用程序，并在登录之前先注册一个用户。点击`注册`按钮将新账户放入`UserManager`中，允许我们使用这些账户详情（它们现在存在于`UserManager`中）进行**登录**。一旦我们登录，除非我们有一个可以运行应用程序并登录的另一个移动客户端，否则我们不能再做任何事情。最好使用运行移动应用程序的两个移动设备来测试这个应用程序。一旦两者都登录并且客户端列表屏幕已加载，每个用户都将连接到用户，现在两个用户都可以点击对方导航到聊天窗口并开始互相发送消息。
- en: To further understand everything going on, try adding debug breakpoints to server
    functions, and test these server functions by clicking between the different screens
    of the mobile application. This will give a better overview as to what is happening
    between server and client on each screen.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解正在发生的一切，尝试向服务器函数添加调试断点，并通过点击移动应用程序的不同屏幕来测试这些服务器函数。这将提供更好的概述，了解每个屏幕上服务器和客户端之间发生的事情。
- en: Summary
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an application for iOS and Android using the native
    libraries. We integrated SignalR on the client and server side by building a hub
    and proxy connections via a client. In the next chapter, we will see how to store
    files locally with `Xamarin.Forms` using dependency services. You will learn about shared
    projects and their differences to PCL projects. We will also run through SQLite, setting
    it up with Android, iOS, and WinPhone and share the same code using different platform-specific
    libraries.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用原生库为iOS和Android创建了一个应用程序。我们通过构建一个中心代理和通过客户端建立代理连接在客户端和服务器端集成了SignalR。在下一章中，我们将看到如何使用依赖服务通过`Xamarin.Forms`在本地存储文件。你将了解共享项目和它们与PCL项目的不同之处。我们还将运行SQLite，与Android、iOS和WinPhone一起设置它，并使用不同的平台特定库共享相同的代码。
