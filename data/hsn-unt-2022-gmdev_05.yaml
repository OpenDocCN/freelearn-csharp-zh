- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Introduction to C# and Visual Scripting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 和可视化脚本简介
- en: 'Unity has a lot of great built-in tools to solve the most common problems in
    game development, such as the ones we have seen so far. Even two games of the
    same genre have their own little differences that make the game unique, and Unity
    cannot foresee that, so that’s why we have scripting. Through coding, we can extend
    Unity’s capabilities in several ways to achieve the exact behavior we need, all
    through a well-known language—C#. But aside from C#, Unity also has **Visual Scripting**,
    a way to generate code through a node graph tool. This means you can create scripts
    without writing code but by dragging **nodes**, boxes that represent actions that
    can be chained:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 拥有很多优秀的内置工具来解决游戏开发中最常见的问题，比如我们之前看到的问题。即使是同一类型的两个游戏也有它们自己的一些细微差别，使游戏变得独特，Unity
    无法预见这一点，这就是为什么我们需要脚本。通过编码，我们可以以几种方式扩展 Unity 的功能，以实现我们需要的精确行为，所有这些都可以通过一个众所周知的语言——C#
    来完成。但除了 C#，Unity 还有 **可视化脚本**，这是一种通过节点图工具生成代码的方法。这意味着你可以通过拖动 **节点**（代表可以链式连接的操作的盒子）来创建脚本，而不需要编写代码：
- en: '![](img/B18585_05_01.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_05_01.png)'
- en: 'Figure 5.1: Example of a Visual Scripting graph'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：可视化脚本图的示例
- en: While essentially both ways can achieve the same result, we can use them for
    different things. Usually, the core logic of the game is written in C# due to
    it being usually huge and very performance sensitive. But sometimes using visual
    scripts instead allows non-programmer team members, like artists or game designers,
    to have more freedom to edit minor changes in the game, especially regarding balancing
    or visual effects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本质上两种方法都可以达到相同的结果，但我们可以根据不同的用途使用它们。通常，由于通常很大且对性能非常敏感，游戏的核心逻辑是用 C# 编写的。但有时使用可视化脚本而不是代码可以让非程序员团队成员，如艺术家或游戏设计师，在游戏中有更多自由来编辑小的更改，尤其是在平衡或视觉效果方面。
- en: Another example would be game designers prototyping ideas through visual scripts
    that later programmers will convert to C# scripts when the idea is approved. Also,
    C# programmers can create nodes for Visual Script programmers to use.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是游戏设计师通过可视化脚本原型设计想法，后来程序员将在想法获得批准后将这些想法转换为 C# 脚本。此外，C# 程序员可以为可视化脚本程序员创建节点。
- en: The way to mix these tools varies widely between teams, so while in the next
    chapters we are going to focus mainly on C#, we are going to also see the Visual
    Scripting equivalent version of the scripts we are going to create. This way you
    will have the opportunity to experiment when convenient to use one or the other
    according to your team structure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的混合方式在团队之间差异很大，所以尽管在下一章我们将主要关注 C#，我们还将查看我们将要创建的脚本的可视化脚本等效版本。这样，你将有机会在方便的时候根据团队结构选择使用其中一个。
- en: 'In this chapter, we will examine the following scripting concepts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下脚本概念：
- en: Creating scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建脚本
- en: Using events and instructions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件和指令
- en: We are going to create our own Unity components, learning the basic structure
    of a script and the way that we can execute actions and expose properties to be
    configured, both with C# and Visual Scripting. We are not going to create any
    of our actual game codes here, just some example scripts to set the ground to
    start doing that in the next chapter. Let’s start by discussing the basics of
    script creation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的 Unity 组件，学习脚本的基本结构以及我们可以如何执行操作和公开属性以进行配置，无论是使用 C# 还是可视化脚本。我们在这里不会创建任何实际的游戏代码，只是提供一些示例脚本，以便在下一章开始这样做。让我们先讨论脚本创建的基本知识。
- en: Creating scripts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建脚本
- en: The first step to creating behavior is to create script assets; these are files
    that will contain the logic behind the behavior of our components. Both C# and
    Visual Scripting have their own type of asset to achieve that, so let’s explore
    how to do that in both tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建行为的第一步是创建脚本资产；这些文件将包含我们组件行为背后的逻辑。C# 和可视化脚本都有自己的资产类型来实现这一点，所以让我们来探讨如何在两个工具中实现这一点。
- en: Having some programming knowledge is required in this book. However, in this
    first section, we are going to discuss a basic script structure to make sure you
    have a strong foundation to follow when we code the behaviors of our game in the
    following chapters. Even if you are familiar with C#, try not to skip this section
    because we will cover Unity-specific structures of the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中需要一些编程知识。然而，在本节中，我们将讨论基本的脚本结构，以确保你在下一章编写游戏行为时有一个坚实的基础。即使你对 C# 熟悉，也尽量不要跳过这一节，因为我们将涵盖
    Unity 特定的代码结构。
- en: 'In this section, we will examine the following script creation concepts:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下脚本创建概念：
- en: Initial setup
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始设置
- en: Creating a C# script
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建C#脚本
- en: Adding fields
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加字段
- en: Creating a Visual Script graph
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Visual Scripting图
- en: We are going to create our first script, which will serve to create our component,
    discussing the tools needed to do so and exploring how to expose our class fields
    to the editor. Let’s start with the basics of script creation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的第一个脚本，这个脚本将用于创建我们的组件，讨论创建所需工具，并探讨如何将我们的类字段暴露给编辑器。让我们从脚本创建的基本知识开始。
- en: Initial setup
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始设置
- en: Support for Visual Scripting is added by installing the **Visual Scripting**
    package in the **Package Manager** as we did with other packages in previous chapters,
    but as Unity does that automatically for us when we create the project, we don’t
    need any further setup. That means the rest of this section will take care of
    setting up the tools needed to work with C#.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在**包管理器**中安装**Visual Scripting**包，我们可以添加对Visual Scripting的支持，就像我们在前几章中添加其他包一样，但由于Unity在创建项目时会自动为我们完成这项工作，所以我们不需要进行任何进一步的设置。这意味着本节的其余部分将负责设置与C#一起工作的工具。
- en: One thing to consider before creating our first C# script is how Unity compiles
    the code. While coding, we are used to having an **Integrated Development Environment**
    (**IDE**), which is a program to create our code and compile or execute it. In
    Unity, we will just use an IDE as a tool to create the scripts easily with coloring
    and auto-completion because Unity doesn’t have a custom code editor (if you have
    never coded before, these are valuable tools for beginners). The scripts will
    be created inside the Unity project and Unity will detect and compile them if
    any changes are made, so you won’t compile them in the IDE. Don’t worry, even
    if not compiling and running the code in the IDE, it is possible to debug, add
    breakpoints, and check the data on the variables and structures using the IDE
    and Unity together.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的第一个C#脚本之前，我们需要考虑Unity如何编译代码。在编码时，我们习惯于使用**集成开发环境**（**IDE**），这是一个用于创建我们的代码并编译或执行它的程序。在Unity中，我们只会使用IDE作为一个工具，通过着色和自动完成功能轻松地创建脚本，因为Unity没有自定义代码编辑器（如果您之前从未编码过，这些是初学者的宝贵工具）。脚本将在Unity项目中创建，如果进行任何更改，Unity将检测并编译它们，因此您不需要在IDE中编译。不用担心，即使不在IDE中编译和运行代码，也可以使用IDE和Unity一起进行调试、添加断点以及检查变量和结构中的数据。
- en: 'We can use Visual Studio, Visual Studio Code, Rider, or whatever C# IDE you’d
    like to use, but when you install Unity, you will probably see an option to install
    Visual Studio automatically, which allows you to have a default IDE. This installs
    the free version of Visual Studio, so don’t worry about the licenses here. If
    you don’t have an IDE on your computer and didn’t check the Visual Studio option
    while installing Unity, you can do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Visual Studio、Visual Studio Code、Rider或您想使用的任何C# IDE，但安装Unity时，您可能会看到一个自动安装Visual
    Studio的选项，这允许您有一个默认的IDE。这会安装Visual Studio的免费版本，所以在这里不用担心许可证问题。如果您电脑上没有IDE，并且在安装Unity时没有勾选Visual
    Studio选项，您可以执行以下操作：
- en: Open **Unity Hub**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Unity Hub**。
- en: Go to the **Installs** section.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**安装**部分。
- en: 'Click on the wheel button in the top-right area of the Unity version you are
    using and click on **Add Modules**:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您正在使用的Unity版本右上角的轮形按钮，然后点击**添加模块**：
- en: '![](img/B18585_05_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_02.png)'
- en: 'Figure 5.2: Adding a module to the Unity installation'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：向Unity安装添加模块
- en: Check the option that says **Visual Studio**; the description of the option
    will vary depending on the version of Unity and the platform you are using.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查表示**Visual Studio**的选项；该选项的描述将根据您使用的Unity版本和平台而有所不同。
- en: 'Hit the **Continue** button at the bottom-right:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下角的**继续**按钮：
- en: '![](img/B18585_05_03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_03.png)'
- en: 'Figure 5.3: Installing Visual Studio'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：安装Visual Studio
- en: 'Check that you accept the terms and conditions and click **Install**:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您接受条款和条件，然后点击**安装**：
- en: '![](img/B18585_05_04.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_04.png)'
- en: 'Figure 5.4: Accepting the terms and conditions'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：接受条款和条件
- en: Wait for the operation to end. This might take a few minutes. There may be additional
    Visual Studio steps that vary between platform and version; if so, just follow
    them.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待操作结束。这可能需要几分钟。可能会有一些与平台和版本相关的Visual Studio步骤；如果是这样，只需按照它们进行即可。
- en: 'If you have a preferred IDE, you can install it yourself and configure Unity
    to use it. If you can afford it or you are a teacher or a student (as it is free
    in these cases), I recommend Rider. It is a great IDE with lots of C# and Unity
    features that you will love; however, it is not vital for this book. In order
    to set up Unity to use a custom IDE, do the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个首选的 IDE，你可以自己安装它并配置 Unity 使用它。如果你负担得起或者你是教师或学生（在这些情况下它是免费的），我推荐 Rider。这是一个功能强大的
    IDE，拥有许多你将喜欢的 C# 和 Unity 功能；然而，它对于本书并不是必需的。为了设置 Unity 使用自定义 IDE，请按照以下步骤操作：
- en: Open the project.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目。
- en: Go to **Edit | Preferences** in the top menu of the editor (**Unity | Preferences**
    on Mac).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器顶部菜单中转到**编辑** | **首选项**（在 Mac 上为**Unity** | **首选项**）。
- en: Select the **External Tools** menu from the left panel.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧面板选择**外部工具**菜单。
- en: 'From the external script editor, select your preferred IDE; Unity will automatically
    detect the supported IDEs:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从外部脚本编辑器中选择你首选的 IDE；Unity 将自动检测支持的 IDE：
- en: '![](img/B18585_05_05.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_05.png)'
- en: 'Figure 5.5: Selecting a custom IDE'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：选择自定义 IDE
- en: If you don’t find your IDE in the list, you can use the **Browse…** option.
    Note that usually, IDEs that require you to use this option are not very well
    supported—but it’s worth a shot.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有在列表中找到你的 IDE，你可以使用**浏览…**选项。请注意，通常需要使用此选项的 IDE 并没有得到很好的支持——但值得一试。
- en: 'Finally, some IDEs, such as Visual Studio, Visual Studio Code, and Rider, have
    Unity integration tools that you need to install in your project, which is optional
    but can be useful. Usually, Unity installs these automatically, but if you want
    to be sure that they are installed, follow these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些 IDE，如 Visual Studio、Visual Studio Code 和 Rider，都有 Unity 集成工具，你需要在项目中安装这些工具，这是可选的但可能很有用。通常，Unity
    会自动安装这些工具，但如果你想确保它们已安装，请按照以下步骤操作：
- en: Open **Package Manager** (**Window** | **Package Manager**).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**包管理器**（**窗口** | **包管理器**）。
- en: 'Set the **Packages** dropdown to **Unity Registry** mode:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**包**下拉菜单设置为**Unity 注册表**模式：
- en: '![](img/B18585_05_06.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_06.png)'
- en: 'Figure 5.6: Enabling Unity Registry mode'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：启用 Unity 注册表模式
- en: 'Search the list for your IDE or filter the list by using the search bar. In
    my case, I used Rider, and I can find a package called **JetBrains Rider Editor**:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中搜索你的 IDE 或使用搜索栏进行过滤。在我的情况下，我使用了 Rider，我可以找到一个名为 **JetBrains Rider Editor**
    的包：
- en: '![](img/B18585_05_07.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_07.png)'
- en: 'Figure 5.7: Custom IDE editor extension installation—in this case, the Rider
    one'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：自定义 IDE 编辑器扩展安装——在这个例子中是 Rider 的
- en: Check whether your IDE integration package is installed by looking at the buttons
    at the bottom-right part of the package manager. If you see an **Install** or
    **Update** button, click on it, but if it says **Installed**, everything is set
    up.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看包管理器右下角的按钮来检查你的 IDE 集成包是否已安装。如果你看到一个**安装**或**更新**按钮，点击它，但如果它显示为**已安装**，则一切设置就绪。
- en: Now that we have an IDE configured, let’s create our first script.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了一个 IDE，让我们创建我们的第一个脚本。
- en: Creating a C# script
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 C# 脚本
- en: C# is an object-oriented language, and this is no different in Unity. Any time
    we want to extend Unity, we need to create our own class—a script with the instructions
    we want to add to Unity. If we want to create custom components, we need to create
    a class that inherits from `MonoBehaviour`, the base class of every custom component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种面向对象的语言，在 Unity 中也是如此。任何想要扩展 Unity 的时候，我们都需要创建自己的类——一个包含我们想要添加到 Unity
    中的指令的脚本。如果我们想要创建自定义组件，我们需要创建一个继承自 `MonoBehaviour` 的类，这是每个自定义组件的基类。
- en: 'We can create C# script files directly within the Unity project using the editor,
    and you can arrange them in folders right next to other `assets` folders. The
    easiest way to create a script is by following these steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在 Unity 项目中使用编辑器创建 C# 脚本文件，并将它们排列在其他 `assets` 文件夹旁边的文件夹中。创建脚本的最简单方法是按照以下步骤操作：
- en: Select any GameObject that you want to have the component we are going to create.
    As we are just testing this out, select any object.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要添加我们即将创建的组件的任何 GameObject。由于我们只是在测试，所以选择任何对象。
- en: 'Click on the **Add Component** button at the bottom of the Inspector and look
    for the **New script** option at the bottom of the list, displayed after clicking
    on **Add Component**:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器底部点击**添加组件**按钮，并在点击**添加组件**后列表底部查找**新脚本**选项：
- en: '![](img/B18585_05_08.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_08.png)'
- en: 'Figure 5.8: The New script option'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：新脚本选项
- en: 'In the **Name** field, enter the desired script name, and then click **Create
    and Add**. In my case, I will call it `MyFirstScript`, but for the scripts that
    you will use for your game, try to enter descriptive names, regardless of the
    length:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **名称** 字段中输入所需的脚本名称，然后点击 **创建并添加**。在我的情况下，我将命名为 `MyFirstScript`，但为您游戏中的脚本尝试输入描述性的名称，无论长度如何：
- en: '![](img/B18585_05_09.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_09.png)'
- en: 'Figure 5.9: Naming the script'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：命名脚本
- en: It is recommended that you use Pascal case for script naming. In Pascal case,
    a script for the player’s shooting functionality would be called `PlayerShoot`.
    The first letter of each word of the name is in uppercase and you can’t use spaces.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用帕斯卡大小写（Pascal case）来命名脚本。在帕斯卡大小写中，用于玩家射击功能的脚本会被命名为 `PlayerShoot`。每个单词的首字母都大写，且不能使用空格。
- en: 'You can check how a new asset with the same name as your script is created
    in **Project View**. Remember that each component has its own asset, and I suggest
    you put each component in a `Scripts` folder:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 **项目视图** 中检查如何创建与你的脚本同名的新的资产。请记住，每个组件都有自己的资产，我建议你将每个组件放在一个 `Scripts` 文件夹中：
- en: '![](img/B18585_05_10.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_10.png)'
- en: 'Figure 5.10: Script asset'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：脚本资产
- en: 'Now, you will also see that your GameObject has a new component in the Inspector
    window, which has the same name as your script. So, you have now created your
    first `component` class:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你也会看到你的 GameObject 在检查器窗口中有一个新的组件，其名称与你的脚本相同。所以，你现在已经创建了你第一个 `component`
    类：
- en: '![](img/B18585_05_11.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_11.png)'
- en: 'Figure 5.11: Our script added to a GameObject'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：脚本添加到 GameObject 中
- en: Now that we have created a `component` class, remember that a class is not the
    component itself. It is a description of what the component should be—a blueprint
    of how a component should work. To actually use the component, we need to instantiate
    it by creating a component based on the class. Each time we add a component to
    an object using the editor, Unity is instantiating it for us. Generally, we don’t
    instantiate components using the newC# keyword, but by using the editor or specialized
    functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个 `component` 类，请记住，类本身不是组件。它是对组件应该是什么的描述——组件应该如何工作的蓝图。要实际使用组件，我们需要通过基于类创建组件来实例化它。每次我们使用编辑器将组件添加到对象时，Unity
    都会为我们实例化它。通常，我们不会使用 newC# 关键字来实例化组件，而是通过使用编辑器或专用函数。
- en: 'Now, you can add your new empty component to other objects as you would any
    other component by using the **Add Component** button in the Inspector window.
    Then you can look for the component in the **Scripts** category or search it by
    name:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像添加任何其他组件一样，使用检查器窗口中的 **添加组件** 按钮将你的新空组件添加到其他对象中。然后你可以在 **脚本** 类别中查找该组件或通过名称搜索它：
- en: '![](img/B18585_05_12.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_12.png)'
- en: 'Figure 5.12: Adding a custom component in the Scripts category'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：在脚本类别中添加自定义组件
- en: Something that you need to consider here is that we can add the same component
    to several GameObjects. We don’t need to create a class for each GameObject that
    uses the component. I know this is basic programmers’ knowledge but remember that
    we are trying to recap the basics here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的是，我们可以将相同的组件添加到多个 GameObject 中。我们不需要为每个使用该组件的 GameObject 创建一个类。我知道这是基本的程序员知识，但请记住，我们在这里试图回顾基础知识。
- en: 'Now that we have our component, let’s explore how it looks and carry out a
    class structure recap by following these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的组件，让我们通过以下步骤来探索它的外观并进行类结构回顾：
- en: Locate the script asset in **Project View** and double-click on it. Remember
    that it should be in the `Scripts` folder you created previously.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目视图** 中定位脚本资产，并双击它。请记住，它应该在你之前创建的 `Scripts` 文件夹中。
- en: 'Wait for the IDE to open; this can take a while. You will know that the IDE
    has finished the initialization when you see your script code and its keywords
    properly colored, which varies according to the desired IDE. In Rider, it looks
    like what is shown in *Figure 5.13*. In my case, I knew that Rider had finished
    initializing because the `MonoBehaviour` type and the script name are colored
    the same:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 IDE 打开；这可能需要一段时间。当你看到你的脚本代码及其关键字被正确着色时，你就知道 IDE 已经完成了初始化，这会根据所需的 IDE 而有所不同。在
    Rider 中，它看起来就像 *图 5.13* 中所示的那样。在我的情况下，我知道 Rider 已经完成了初始化，因为 `MonoBehaviour` 类型与脚本名称的颜色相同：
- en: '![](img/B18585_05_13.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_13.png)'
- en: 'Figure 5.13: A new script opened in the Rider IDE'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：在 Rider IDE 中打开的新脚本
- en: 'The first three lines—the ones that start with the `using` keyword—include
    common namespaces. **Namespaces** are like code containers, which is, in this
    case, code created by others (such as Unity, C# creators, and so on). We will
    be using namespaces quite often to simplify our tasks; they already contain solved
    algorithms that we will use. We will be adding and removing the `using` component
    as we need; in my case, Rider is suggesting that the first two `using` components
    are not necessary because I am not using any code inside them, and so they are
    grayed out. But for now, keep them as you will use them in later chapters of this
    book. Remember, they should always be at the beginning of the file:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前三条线——以 `using` 关键字开头的线——包括常见的命名空间。**命名空间**就像代码容器，在这种情况下，是其他人（如 Unity、C# 创建者等）创建的代码。我们将经常使用命名空间来简化我们的任务；它们已经包含了我们将要使用的已解决算法。我们将根据需要添加和删除
    `using` 组件；在我的情况下，Rider 建议前两个 `using` 组件不是必需的，因为我没有使用它们内部的任何代码，所以它们被灰色显示。但到目前为止，请保留它们，因为你在本书的后续章节中会用到它们。记住，它们应该始终位于文件的开头：
- en: '![](img/B18585_05_14.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_05_14.png)'
- en: 'Figure 5.14: The using sections'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：使用部分
- en: 'The next line, the one that starts with `public class`, is where we declare
    that we are creating a new class that inherits from `MonoBehaviour`, the base
    class of every custom component. We know this because it ends with `: MonoBehaviour`.
    You can see how the rest of the code is located inside brackets right below that
    line, meaning that the code inside them belongs to the component:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '下一行，即以 `public class` 开头的行，是我们声明正在创建一个新的类，该类继承自 `MonoBehaviour`，这是每个自定义组件的基类。我们知道这一点，因为它以
    `: MonoBehaviour` 结尾。你可以看到其余的代码位于该行下面的括号内，这意味着括号内的代码属于该组件：'
- en: '![](img/B18585_05_15.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_05_15.png)'
- en: 'Figure 5.15: The MyFirstScript class definition inherits from MonoBehaviour'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：MyFirstScript 类定义继承自 MonoBehaviour
- en: Now that we have our C# script, let’s add fields to configure it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的 C# 脚本，让我们添加字段来配置它。
- en: Adding fields
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加字段
- en: In previous chapters, when we added components as `Rigidbody` or as different
    kinds of colliders, adding the components wasn’t enough. We needed to properly
    configure them to achieve the exact behavior that we need. For example, `Rigidbody`
    has the `Mass` property to control the object’s weight, and the colliders have
    the `Size` property to control their shape. This way, we can reuse the same component
    for different scenarios, preventing the duplication of similar components. With
    a `Box` collider, we can represent a cube or rectangular box just by changing
    the size properties. Our components are no exception; if we have a component that
    moves an object and if we want two objects to move at different speeds, we can
    use the same component with different configurations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，当我们添加 `Rigidbody` 或不同类型的碰撞体作为组件时，仅仅添加组件是不够的。我们需要正确配置它们以实现我们需要的精确行为。例如，`Rigidbody`
    有 `Mass` 属性来控制物体的重量，而碰撞体有 `Size` 属性来控制它们的形状。这样，我们可以为不同的场景重用相同的组件，防止类似组件的重复。使用
    `Box` 碰撞体，我们可以通过改变大小属性来表示一个立方体或矩形盒子。我们的组件也不例外；如果我们有一个移动对象的组件，并且我们想让两个对象以不同的速度移动，我们可以使用具有不同配置的相同组件。
- en: 'Each configuration is a **field** or **variable** where we can hold the parameter’s
    value. We can create class fields that can be edited in the editor in two ways:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置都是一个 **字段** 或 **变量**，我们可以在这里存储参数的值。我们可以以两种方式在编辑器中创建可编辑的类字段：
- en: By marking the field as `public`, but breaking the encapsulation principle
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将字段标记为 `public`，但打破了封装原则
- en: By making a private field and exposing it with an attribute
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建私有字段并使用属性公开它
- en: Now, we are going to cover both methods, but if you are not familiar with **Object-Oriented
    Programming** (**OOP**) concepts, such as encapsulation, I recommend you use the
    first method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍这两种方法，但如果你对 **面向对象编程**（**OOP**）概念不熟悉，例如封装，我建议你使用第一种方法。
- en: 'Suppose we are creating a movement script. We will add an editable number field
    representing the velocity using the first method—that is, by adding the `public`
    field. We will do this by following these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在创建一个移动脚本。我们将使用第一种方法——即通过添加 `public` 字段——添加一个表示速度的可编辑数字字段。我们将按照以下步骤进行：
- en: Open the script by double-clicking it as we did before.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击脚本打开它，就像我们之前做的那样。
- en: 'Inside the class brackets, but outside any brackets within them, add the following
    code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类括号内，但不在它们内部的任何括号内，添加以下代码：
- en: '![](img/B18585_05_16.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_05_16.png)'
- en: 'Figure 5.16: Creating a speed field in our component'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：在我们的组件中创建速度字段
- en: The `public` keyword specifies that the variable can be seen and edited beyond
    the scope of the class. The `float` part of the code says that the variable is
    using the decimal number type, and `speed` is the name we chose for our field—this
    can be whatever you want. You can use other value types to represent other kinds
    of data, such as `bool` to represent checkboxes or `Booleans` and `string` to
    represent text.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 关键字指定变量可以在类的作用域之外被看到和编辑。代码中的 `float` 部分表示变量使用的是十进制数字类型，而 `speed` 是我们为我们的字段选择的名称——这可以是任何你想要的内容。你可以使用其他值类型来表示其他类型的数据，例如
    `bool` 用于复选框或 `Booleans` 和 `string` 用于文本。'
- en: 'To apply the changes, just save the file in the IDE (usually by pressing *Ctrl*
    + *S* or *Command* + *S*) and return to Unity. When you do this, you will notice
    a little loading wheel at the bottom-right part of the editor, indicating that
    Unity is compiling the code. You can’t test the changes until the wheel finishes:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要应用更改，只需在 IDE 中保存文件（通常通过按 *Ctrl* + *S* 或 *Command* + *S*）并返回 Unity。当你这样做时，你会在编辑器的右下角注意到一个小型加载轮，这表明
    Unity 正在编译代码。你必须在轮子停止转动之前不能测试更改：
- en: '![](img/B18585_05_17.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_17.png)'
- en: 'Figure 5.17: The loading wheel'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：加载轮
- en: Remember that Unity will compile the code; don’t compile it in the IDE.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Unity 会编译代码；不要在 IDE 中编译。
- en: 'After the compilation is finished, you can see your component in the Inspector
    window and the **Speed** variable should be there, allowing you to set the speed
    you want. Of course, right now, the variables do nothing. Unity doesn’t recognize
    your intention by the name of the variable; we need to set it for use in some
    way, but we will do that later:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，你可以在检查器窗口中看到你的组件，并且应该有一个 **Speed** 变量，允许你设置你想要的速度。当然，现在，这些变量没有任何作用。Unity
    不会通过变量的名称来识别你的意图；我们需要以某种方式设置它以便使用，但我们将稍后进行操作：
- en: '![](img/B18585_05_18.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_18.png)'
- en: 'Figure 5.18: A public field to edit data that the component will use later'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：一个公共字段，用于编辑组件稍后将要使用的数据
- en: In case you don’t see the speed variable, please check the section at the end
    of this chapter called *Common beginner C# script errors*, which will give you
    tips about how to troubleshoot compilation errors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到速度变量，请检查本章末尾的 *常见初学者 C# 脚本错误* 部分，它将提供有关如何调试编译错误的提示。
- en: Try adding the same component to other objects and set a different speed. This
    will show you how components in different GameObjects are independent, allowing
    you to change some of their behaviors via different settings.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将相同的组件添加到其他对象中，并设置不同的速度。这将向你展示不同 GameObject 中的组件是如何独立的，允许你通过不同的设置更改它们的一些行为。
- en: The second way to define properties is similar, but instead of creating a `public`
    field, we create a `private` field, encouraging encapsulation and exposing it
    using the `SerializeField` attribute, as shown in the following screenshot.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义属性的第二种方法类似，但不是创建一个 `public` 字段，而是创建一个 `private` 字段，鼓励封装，并通过 `SerializeField`
    属性将其公开，如图中所示。
- en: '![](img/B18585_05_19.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_19.png)'
- en: 'Figure 5.19: Exposing private attributes in the Inspector window'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：在检查器窗口中公开私有属性
- en: If you are not familiar with the OOP concept of encapsulation, just use the
    first method, which is more flexible for beginners. If you create a `private`
    field, it won’t be accessible to other scripts because the `SerializeField` attribute
    only exposes the variable to the editor. Remember that Unity won’t allow you to
    use constructors, so the only way to set initial data and inject dependencies
    is via serialized `private` fields or `public` fields and setting them in the
    editor (or using a dependency injection framework, but that is beyond the scope
    of this book). For simplicity, we will use the first method in most of the exercises
    in this book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉面向对象编程中的封装概念，只需使用第一种方法，这对于初学者来说更加灵活。如果你创建一个 `private` 字段，它将不会被其他脚本访问，因为
    `SerializeField` 属性只将变量暴露给编辑器。记住，Unity 不允许你使用构造函数，所以设置初始数据和注入依赖的唯一方法是通过序列化的 `private`
    字段或 `public` 字段，并在编辑器中设置它们（或者使用依赖注入框架，但这超出了本书的范围）。为了简单起见，我们将在本书的大部分练习中使用第一种方法。
- en: If you want, try to create other types of variables and check how they look
    in the Inspector. Try replacing `float` for `bool` or `string`, as previously
    suggested. Consider that not every possible C# type is recognized by Unity; through
    this book, we will learn the most commonly supported ones. Now that we know how
    to configure our components through data, let’s use that data to create some behavior.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想，尝试创建其他类型的变量并检查它们在检查器中的外观。尝试将`float`替换为`bool`或`string`，如之前建议的那样。请注意，并非所有可能的C#类型都由Unity识别；通过这本书，我们将学习最常用的支持类型。现在我们知道了如何通过数据配置我们的组件，让我们使用这些数据来创建一些行为。
- en: Now that we have our C# script, let’s see how to do the same in Visual Scripting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的C#脚本，让我们看看如何在视觉脚本中做同样的事情。
- en: Creating a Visual Script
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视觉脚本
- en: As we need to create a **Script Asset** for C# scripts, we need to create the
    Visual Scripting equivalent called **Script Graph** and also attach it to our
    GameObject, although using a different approach this time. Before continuing,
    it is worth noticing that our objects must only have C# or the Visual Scripting
    version, but not both, or the behavior will be applied twice, once per version.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要为C#脚本创建**脚本资产**，因此需要创建视觉脚本编写的等效项，即**脚本图形**，并将其附加到我们的GameObject上，尽管这次采用不同的方法。在继续之前，请注意，我们的对象必须只有C#或视觉脚本版本，但不能两者兼有，否则行为将被应用两次，每次一个版本。
- en: Essentially, only do the steps for the version you want to try or do both steps
    in different objects if you want to experiment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，只需为要尝试的版本执行步骤，或者如果您想进行实验，则在不同的对象中执行这两个步骤。
- en: 'Let’s create a Visual Script doing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个执行以下操作的视觉脚本：
- en: Create a new GameObject to which we will add the Visual Script.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的GameObject，我们将向其中添加视觉脚本。
- en: 'Add the **Script Machine** component to it. This component will execute the
    **Visual Script Graph** we will be creating shortly:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加**脚本机器**组件。此组件将执行我们即将创建的**视觉脚本图形**：
- en: '![](img/B18585_05_20.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_20.png)'
- en: 'Figure 5.20: Adding a Script Machine component'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20：添加脚本机器组件
- en: 'In the **Script Machine** component, click the **New** button and select a
    folder and a name to save the **Visual Script Graph** asset. This asset will contain
    the instructions of our script, and the **Script Machine** component will execute
    those:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**脚本机器**组件中，点击**新**按钮，选择一个文件夹和一个名称以保存**视觉脚本图形**资产。此资产将包含我们脚本的指令，**脚本机器**组件将执行这些指令：
- en: '![](img/B18585_05_21.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_21.png)'
- en: 'Figure 5.21: Using the New button to create a Visual Scripting Graph asset'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21：使用新按钮创建视觉脚本图形资产
- en: If a warning appears, click the **Change now** option. This will prevent those
    changes on the script from affecting the game while its running, because as the
    warning says, it can cause instability of the code. Always stop the game, change
    the code, and then play again.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现警告，请点击**立即更改**选项。这将防止在脚本上的更改在游戏运行时影响游戏，因为警告所说，它可能导致代码不稳定。始终停止游戏，更改代码，然后再次播放。
- en: 'Click the **Edit Graph** Button to open the Visual Script editor window. You
    can drag the **Script Graph** tab to any part of the editor to merge that window:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑图形**按钮以打开视觉脚本编辑器窗口。您可以将**脚本图形**标签拖动到编辑器的任何部分以合并该窗口：
- en: '![](img/B18585_05_22.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_22.png)'
- en: 'Figure 5.22: Visual Scripting asset editor'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22：视觉脚本资产编辑器
- en: Put the mouse in an empty area in the grid of the **Visual Script** editor,
    and while holding the middle mouse button, move the mouse to scroll through the
    graph. On MacBooks and Apple Magic Mouses you can scroll using two fingers on
    the trackpad.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标放在**视觉脚本**编辑器网格的空白区域，同时按住中间鼠标按钮，移动鼠标以滚动通过图形。在MacBooks和Apple Magic Mouses上，您可以使用两个手指在触控板上进行滚动。
- en: What we did is create the **Visual Graph** asset that will contain the code
    of our script, and attached it to a GameObject through the **Script Machine**
    component. Unlike C# scripts, we can’t attach the **Graph Asset** directly; that’s
    why we need the **Script Machine** to run the component for us.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是创建包含我们脚本代码的**视觉图形**资产，并通过**脚本机器**组件将其附加到GameObject上。与C#脚本不同，我们无法直接附加**图形资产**；这就是为什么我们需要**脚本机器**为我们运行组件。
- en: 'Regarding fields, the ones we created in the C# scripts are contained in the
    script itself, but for **Visual Graph** they work a little bit differently. When
    we added the **Script Machine** component, another one was added: the **Variables**
    component. This will hold all the variables for all the **Visual Script Graph**
    that a GameObject can contain. That means that all graphs we add to our object
    will share those variables. You can create graph-specific variables if you want,
    but they won’t be exposed in the Inspector, and this way also simplifies the access
    of variables from other objects’ scripts. Also remember you will want to add several
    graphs to the object, given that each graph will take care of different behaviors,
    in a way in which we can mix and match them according to our needs.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字段，我们在C#脚本中创建的字段包含在脚本本身中，但对于**Visual Graph**来说，它们的工作方式略有不同。当我们添加了**Script
    Machine**组件时，还添加了另一个组件：**Variables**组件。这将保存所有**Visual Script Graph**的变量，一个GameObject可以包含。这意味着我们添加到对象的所有图表都将共享这些变量。如果你想创建特定于图表的变量，也可以，但它们不会在Inspector中暴露，这种方式也简化了从其他对象的脚本中访问变量的过程。也要记住，你可能需要向对象添加多个图表，因为每个图表将负责不同的行为，这样我们就可以根据需要混合和匹配它们。
- en: 'In order to add a variable to our GameObject that can be used by our graph,
    let’s do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个变量添加到我们的GameObject中，以便我们的图表可以使用它，让我们做以下操作：
- en: Select a GameObject with a **Visual Script** added (with the **Script Machine**
    component) and look at the **Variables** component.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个添加了**Visual Script**的GameObject（带有**Script Machine**组件）并查看**Variables**组件。
- en: Click the input field that says **(New Variable Name)** and type the name of
    the variable. In my case, this is `speed`. If you don’t see that option, click
    the triangle at the left of the **Variables** component name.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示**（New Variable Name）**的输入字段，并输入变量的名称。在我的例子中，这是`speed`。如果你看不到这个选项，点击**Variables**组件名称左侧的三角形。
- en: Click the **Plus (+)** button of the **Variables** component.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Variables**组件的**Plus (+)**按钮。
- en: In the **Type** dropdown, select **Float**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Type**下拉菜单中，选择**Float**。
- en: 'Optionally you can set an initial value in the **Value** field:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你可以在**Value**字段中设置一个初始值：
- en: '![](img/B18585_05_23.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_23.png)'
- en: 'Figure 5.23: Creating variables for the Visual Graph'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：为Visual Graph创建变量
- en: We created a `speed` variable that we can configure in the GameObject to alter
    the way all **Visual Scripts Graphs** attached to our GameObject will work, or
    at least the ones that use that `Variable` value. Consider that maybe you will
    have different kinds of speed, like movement and rotational speed, so in real
    cases you might want to be a little bit more specific with the variable name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`speed`变量，我们可以在GameObject中配置它来改变所有附加到我们的GameObject的**Visual Scripts Graphs**的工作方式，或者至少是使用那个`Variable`值的那些。考虑一下，你可能会有不同种类的速度，比如移动速度和旋转速度，所以在实际情况下，你可能希望变量名更加具体一些。
- en: The `Variables` component used in Visual Scripting is also called **Blackboard**,
    a common programming technique. This Blackboard is a container of several values
    of our object, like a memory or database, that several other components of our
    object will then query and use. C# scripts usually contain their own variables
    inside instead. With our scripts created and ready to be configured, let’s see
    how to make both of them do something.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Scripting中使用的`Variables`组件也被称为**黑板**，这是一种常见的编程技术。这个黑板是我们对象几个值的容器，就像内存或数据库一样，我们的对象的其他几个组件将查询并使用这些值。C#脚本通常在其内部包含自己的变量。随着我们的脚本创建并准备配置，让我们看看如何让它们都做些事情。
- en: Using events and instructions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件和指令
- en: Now that we have a script, we are ready to do something with it. We won’t implement
    anything useful in this chapter, but we will settle the base concepts to add interesting
    behavior to the scripts we are going to create in the next chapters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了脚本，我们准备用它做些事情。在本章中，我们不会实现任何有用的功能，但我们将确定基础概念，以便在下一章中添加我们将要创建的脚本的有趣行为。
- en: 'In this section, we are going to cover the following concepts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下概念：
- en: Events and instructions in C#
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中的事件和指令
- en: Events and instructions in Visual Scripting
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Scripting中的事件和指令
- en: Using fields in instructions
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指令中使用字段
- en: Common beginner C# script errors
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见初学者C#脚本错误
- en: We are going to explore the **Unity event system**, which will allow us to respond
    to different situations by executing instructions. These instructions will also
    be affected by the value of the editor. Finally, we are going to discuss common
    scripting errors and how to solve them. Let’s start by introducing the concept
    of Unity events in C#.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索**Unity事件系统**，这将允许我们通过执行指令来响应不同的情况。这些指令也将受到编辑器值的影响。最后，我们将讨论常见的脚本错误及其解决方法。让我们从介绍Unity事件在C#中的概念开始。
- en: Events and instructions in C#
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的事件和指令
- en: Unity allows us to create behavior in a cause-effect fashion, which is usually
    called an **event system**. An event is a situation that Unity is monitoring—for
    example, when two objects collide or are destroyed, Unity tells us about this
    situation, allowing us to react according to our needs. As an example, we can
    reduce the life of a player when it collides with a bullet. Here, we will explore
    how to listen to these events and test them by using some simple actions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Unity允许我们以因果关系的方式创建行为，这通常被称为**事件系统**。事件是Unity正在监控的情况——例如，当两个对象碰撞或被销毁时，Unity会告诉我们这种情况，使我们能够根据我们的需求做出反应。例如，当玩家与子弹碰撞时，我们可以减少玩家的生命值。在这里，我们将探讨如何监听这些事件，并通过一些简单的操作来测试它们。
- en: If you are used to event systems, you will know that they usually require us
    to subscribe to some kind of listener or delegate, but in Unity, there is a simpler
    method available. For C# scripts we just need to write a function with the exact
    same name as the event we want to use—and I mean *exactly*. If a letter of the
    name doesn’t have the correct casing, it won’t execute, and no warning will be
    raised. This is the most common beginner’s error that is made, so pay attention.
    For Visual Scripting we will be adding a special kind of node, but will discuss
    that after the C# version.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了事件系统，你会知道它们通常要求我们订阅某种监听器或代理，但在Unity中，有一个更简单的方法可用。对于C#脚本，我们只需要编写一个与我们要使用的事件名称完全相同的函数——我的意思是**完全相同**。如果名称中的任何一个字母的格式不正确，它将不会执行，并且不会发出警告。这是最常见的初学者错误，所以请注意。对于视觉脚本，我们将添加一种特殊的节点，但稍后再讨论C#版本。
- en: There are lots of events or messages to listen to in Unity, so let’s start with
    the most common one—`Update`. This event will tell you when Unity wants you to
    update your object, depending on the purpose of your behavior; some don’t need
    them. The `Update` logic is usually something that needs to be executed constantly—to
    be more precise, in every frame. Remember that every game is like a movie—a sequence
    of images that your screen switches through fast enough to look like we have continuous
    motion. A common action to do in the `Update` event is to move objects a little
    bit, and by doing this, every frame will make your object constantly move.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中有很多事件或消息需要监听，所以让我们从最常见的一个开始——`Update`。这个事件将告诉你Unity何时想要更新你的对象，这取决于你行为的目的；有些不需要。`Update`逻辑通常是需要不断执行的事情——更准确地说，是在每一帧执行。记住，每个游戏都像是一部电影——一系列快速切换到屏幕上的图像，看起来我们有了连续的运动。在`Update`事件中执行的一个常见操作是稍微移动对象，通过这样做，每一帧都会使你的对象持续移动。
- en: 'We will learn about the sorts of things we can do with `Update` and other events
    or messages later. Now, let’s focus on how to make our component at least listen
    to this event. Actually, the base script already comes with two event functions
    that are ready to use, one being `Update` and the other one `Start`. If you are
    not familiar with the concept of methods in C#, we are referring to the snippet
    of code in the following screenshot, which is already included in our script.
    Try to find it in yours:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后了解我们可以使用`Update`和其他事件或消息做什么。现在，让我们专注于如何使我们的组件至少能够监听这个事件。实际上，基本脚本已经包含两个可以立即使用的函数，一个是`Update`，另一个是`Start`。如果你不熟悉C#中的方法概念，我们指的是以下截图中的代码片段，它已经包含在我们的脚本中。试着在你的脚本中找到它：
- en: '![](img/B18585_05_24.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_24.png)'
- en: 'Figure 5.24: A function called Update, which will be executed with every frame'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24：一个名为Update的函数，它将在每一帧执行
- en: You will notice a (usually) green line of text (depending on the IDE) above
    the `void Update()` line—this is called a **comment**. These are basically ignored
    by the compiler. They are just notes that you can leave to yourself and must always
    begin with `//` to prevent Unity from trying to execute them and failing. We will
    use this to temporarily disable lines of code later.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到（通常是）在`void Update()`行上方的绿色文本行（取决于IDE）——这被称为**注释**。这些基本上被编译器忽略。它们只是你可以为自己留下的笔记，并且必须始终以`//`开头，以防止Unity尝试执行它们并失败。我们将使用这个来暂时禁用代码行。
- en: Now, to test whether this actually works, let’s add an instruction to be executed
    all the time. There’s no better test function than `print`. This is a simple instruction
    that tells Unity to print a message to the console, where all kinds of messages
    can be seen by the developers to check whether everything is properly working.
    The user will never see these messages. They are similar to the classic log files
    that developers sometimes ask you for when something goes wrong in the game and
    you are reporting an issue.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试这个功能是否真的起作用，让我们添加一个始终要执行的指令。没有比`print`更好的测试函数了。这是一条简单的指令，告诉Unity将消息打印到控制台，开发者可以在那里看到各种消息，以检查一切是否正常工作。用户永远不会看到这些消息。它们类似于开发者有时在游戏中出现问题时要求你提供的经典日志文件。
- en: 'In order to test events in C# using functions, follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用函数测试C#中的事件，请按照以下步骤操作：
- en: Open the script by double-clicking on it.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击脚本文件来打开它。
- en: 'To test, add `print("test");` within the event function. In the following screenshot,
    you can see an example of how to do that in the `Update` event. Remember to write
    the instruction *exactly*, including the correct casing, spaces, and quote symbols:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试，在事件函数中添加`print("test");`。在下面的屏幕截图中，你可以看到一个如何在`Update`事件中执行此操作的示例。请记住，必须*精确地*写入指令，包括正确的大小写、空格和引号符号：
- en: '![](img/B18585_05_25.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_25.png)'
- en: 'Figure 5.25: Printing a message in all the frames'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25：在所有帧中打印消息
- en: Save the file, go to Unity, and play the game.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，转到Unity，并玩游戏。
- en: Remember to save the file before switching back to Unity from the IDE. This
    is the only way that Unity knows your file has changed. Some IDEs, such as Rider,
    save the file automatically for you, but I don’t recommend you use auto-save,
    at least in big projects (you don’t want accidental recompilations of unfinished
    work—that takes too long in projects with lots of scripts).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在从IDE切换回Unity之前保存文件。这是Unity知道你的文件已更改的唯一方式。一些IDE，如Rider，会自动为你保存文件，但我不建议你在大型项目中使用自动保存（你不想意外地重新编译未完成的工作——在包含大量脚本的项目中，这会花费很长时间）。
- en: Look for the **Console** tab and select it. This is usually found next to the
    **Project View** tab. If you can’t find it, go to **Window | General | Console**,
    or press *Ctrl* + *Shift* + *C* (*Command* + *Shift* + *C* on macOS).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找**控制台**标签并选择它。这通常位于**项目视图**标签旁边。如果你找不到它，请转到**窗口 | 通用 | 控制台**，或按*Ctrl* + *Shift*
    + *C*（在macOS上为*Command* + *Shift* + *C*）。
- en: You will see a new printed message saying `"test"` every frame on the **Console**
    tab. If you don’t see this, remember to save the script file before playing the
    game.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在**控制台**标签页上看到每帧都打印出新的消息“`test`”。如果你看不到这个，记得在玩游戏之前保存脚本文件。
- en: You might see a single message but with a number increasing to its right; that
    means the same message is appearing several times. Try clicking the **Collapse**
    button of the **Console** to change that behavior.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会看到一个单独的消息，但它的右侧数字在增加；这意味着相同的消息出现了多次。尝试点击**控制台**的**折叠**按钮来改变这种行为。
- en: 'Let’s also test the `Start` function. Add `print("test Start");` to it, save
    the file, and play the game. The full script should look as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也测试一下`Start`函数。向其中添加`print("test Start");`，保存文件，并玩游戏。完整的脚本应如下所示：
- en: '![](img/B18585_05_26.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_26.png)'
- en: 'Figure 5.26: The script that tests the Start and Update functions'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26：测试Start和Update函数的脚本
- en: If you check the console now and scroll all the way up, you will see a single
    `"test Start"` message and lots of `"test"` messages following it. As you can
    guess, the `Start` event tells you that the GameObject is created and allows you
    to execute the code that needs to happen just once at the beginning of its lifetime.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在检查控制台并滚动到最上方，你会看到一个单独的`"test Start"`消息和随后的许多`"test"`消息。正如你所猜到的，`Start`事件告诉你GameObject已被创建，并允许你在其生命周期的开始执行一次需要发生的代码。
- en: For the `void Update()` syntax, we will say to Unity that whatever is contained
    within the brackets below this line is a function that will be executed in all
    the frames. It is important to put the `print` instruction *inside* the `Update`
    brackets (the ones inside the brackets of the class). Also, the `print` function
    expects to receive a value to print inside its parenthesis, called an argument
    or parameter. In our example we want to print simple text, and in C# it must be
    enclosed with quotation marks. Finally, all instructions inside functions such
    as **Update** or **Start** *must* end with a semicolon.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `void Update()` 语法，我们将告诉 Unity，此行以下括号内的任何内容都是一个将在所有帧中执行的功能。将 `print` 指令**放在**
    `Update` 括号内（类括号内的括号）内非常重要。此外，`print` 函数期望在其括号内接收一个要打印的值，称为参数或参数。在我们的例子中，我们想要打印简单的文本，在
    C# 中它必须用引号括起来。最后，函数中如 **Update** 或 **Start** 的所有指令**必须**以分号结束。
- en: Here, I challenge you to try to add another event called `OnDestroy` using a
    `print` to discover when it executes. A small suggestion is to play and stop the
    game and look at the bottom of the console to test this one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我挑战您尝试添加另一个名为 `OnDestroy` 的事件，使用 `print` 来发现它何时执行。一个小建议是播放和停止游戏，查看控制台底部以测试此功能。
- en: 'For advanced users, you can also use breakpoints if your IDE allows you to
    do that. **Breakpoints** allow you to freeze Unity completely before executing
    a specific code line to see how our field’s data changes over time and to detect
    errors. Here, I will show you the steps to use breakpoints in Rider, but the Visual
    Studio version should be similar:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级用户，如果您的 IDE 允许，您也可以使用断点。**断点**允许在执行特定代码行之前完全冻结 Unity，以查看我们的字段数据随时间的变化并检测错误。在这里，我将向您展示在
    Rider 中使用断点的步骤，但 Visual Studio 版本应该类似：
- en: Install the Unity package belonging to your IDE if not already installed. Check
    the **Package Manage** for the **JetBrains Rider Editor** package. In the case
    of Visual Studio, install the **Visual Studio Editor** package.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未安装，请安装属于您 IDE 的 Unity 包。检查 **包管理器** 中的 **JetBrains Rider 编辑器** 包。在 Visual
    Studio 的情况下，安装 **Visual Studio 编辑器** 包。
- en: 'Click on the vertical bar at the left of the line where you want to add the
    breakpoint:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您想要添加断点的行的左侧垂直栏上单击：
- en: '![](img/B18585_05_27.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_27.png)'
- en: 'Figure 5.27: A breakpoint in the print instruction'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27：打印指令中的断点
- en: 'Go to **Run | Attach to Unity Process**. If you are using Visual Studio, go
    to **Debug | Attach Unity Debugger**:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **运行 | 连接到 Unity 进程**。如果您正在使用 Visual Studio，请前往 **调试 | 连接 Unity 调试器**：
- en: '![](img/B18585_05_28.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_28.png)'
- en: 'Figure 5.28: Attacking our IDE with a Unity process'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28：用 Unity 进程攻击我们的 IDE
- en: From the list, look for the specific Unity instance you want to test. The list
    will show other opened editors or executing debugging builds if any.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中查找您想要测试的特定 Unity 实例。如果有的话，列表将显示其他打开的编辑器或正在执行的调试构建。
- en: 'If this doesn’t work, check if the editor is in debug mode, looking at the
    bug icon at the bottom-right part of the editor. If the bug looks blue with a
    checkbox, then it is ok, but if it looks gray and crossed out, click it and click
    **Switch to debug mode**:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这不起作用，请检查编辑器是否处于调试模式，查看编辑器右下角的错误图标。如果错误图标看起来是蓝色的带有复选框，那么它是正常的，但如果它看起来是灰色的并且被划掉，请单击它并单击
    **切换到调试模式**：
- en: '![](img/B18585_05_29.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_29.png)'
- en: 'Figure 5.29: Changing from release mode to debug mode'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29：从发布模式切换到调试模式
- en: Stopping the debugging process won’t close Unity. It will just detach the IDE
    from the editor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 停止调试过程不会关闭 Unity。它只会将 IDE 从编辑器中分离出来。
- en: Now let’s explore the Visual Scripting equivalent of using events and instructions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索使用事件和指令的视觉脚本等效方法。
- en: Events and instructions in Visual Scripting
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉脚本中的事件和指令
- en: 'The same concept of events and instructions remains in Visual Scripting, but
    of course this will be done with nodes in the graph. Remember a node represents
    an instruction of the graph, and we can connect them to chain the effects of each
    instruction. In order to add events and the print instruction on our graph, do
    the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉脚本中，事件和指令的概念保持不变，但当然这将通过图中的节点来完成。记住，一个节点代表图中的一个指令，我们可以将它们连接起来以链式连接每个指令的效果。为了在我们的图中添加事件和打印指令，请执行以下操作：
- en: Open the **Visual Script Graph** (double-click the Visual Script asset).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **视觉脚本图**（双击视觉脚本资产）。
- en: 'Right-click the **On Start** and **On Update** nodes that are created by default
    and then click **Delete**. Even if those events are the ones we need, I want you
    to see how to create them from scratch:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击默认创建的 **On Start** 和 **On Update** 节点，然后单击 **Delete**。即使这些事件是我们需要的，我也想让你看到如何从头创建它们：
- en: '![](img/B18585_05_30.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_30.png)'
- en: 'Figure 5.30: Deleting nodes'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30：删除节点
- en: Right-click in any empty space of the **Graph** and type `start` inside the
    **Search** box. It can take a while the first time.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Graph** 的任何空白区域右键单击，并在 **Search** 框中输入 `start`。第一次可能需要一段时间。
- en: 'Select the **On Start** element in the list with the green checkbox to its
    left. In this case I knew this was an event because I was aware of it, but usually
    you will recognize it as an event because it won’t have input pins (more on that
    in the next steps):'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧带有绿色复选框的列表中选择 **On Start** 元素。在这种情况下，我知道这是一个事件，因为我了解它，但通常你会因为它们没有输入引脚（在下一步中会有更多关于这个的说明）而将其识别为事件：
- en: '![](img/B18585_05_31.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_31.png)'
- en: 'Figure 5.31: Searching the On Start event node'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31：搜索 On Start 事件节点
- en: Drag the white arrow at the right of the event node, also known as the Output
    Flow Pin, and release the mouse button in any empty space.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件节点右侧的白色箭头（也称为输出流程引脚）拖动并释放鼠标按钮到任何空白区域。
- en: 'In the **Search** box search for the `print` node, select the one that says
    **Mono Behaviour:Print**. This means that when the **On Start** event happens,
    the connected node will be executed, in this case **print**. This is how we start
    to chain instructions to events:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Search** 框中搜索 `print` 节点，选择显示为 **Mono Behaviour:Print** 的节点。这意味着当 **On Start**
    事件发生时，连接的节点将被执行，在这种情况下是 **print**。这就是我们开始将指令链接到事件的方式：
- en: '![](img/B18585_05_32.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_32.png)'
- en: 'Figure 5.32: Creating a print node connected to the event'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32：创建一个连接到事件的打印节点
- en: Drag the empty circle at the left of the **Message** input pin of the **Print**
    node and release it in any empty space. This pin has a circle indicating that
    is a parameter pin, data that will be used when executing the pin. The flow pins,
    the ones with a green arrow, represent the order in which the nodes will be executed.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位于 **Print** 节点 **Message** 输入引脚左侧的空圆圈拖动到任何空白区域并释放。这个引脚有一个圆圈表示它是一个参数引脚，当执行引脚时将使用的数据。带有绿色箭头的流程引脚代表节点将被执行的顺序。
- en: 'Select the **String Literal** option, which will create a node to allow us
    to specify the message to print:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **String Literal** 选项，这将创建一个节点，允许我们指定要打印的消息：
- en: '![](img/B18585_05_33.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_33.png)'
- en: 'Figure 5.33: Creating a string literal node'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33：创建一个字符串字面量节点
- en: 'In the empty white box write the message to be printed:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空白的白色框中写入要打印的消息：
- en: '![](img/B18585_05_34.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_34.png)'
- en: 'Figure 5.34: Specifying the message to print'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34：指定要打印的消息
- en: Play the game and see the message printed in the console. Be sure you have only
    the Visual Scripting version in the scene to avoid confusing the message in the
    console with the C# version. You can also use different message texts in the Visual
    Scripts to be sure which ones are really executing.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并查看控制台打印的消息。确保场景中只有视觉脚本版本，以避免将控制台中的消息与 C# 版本混淆。您还可以在视觉脚本中使用不同的消息文本，以确保哪些是真正执行的。
- en: You can chain more actions to the **On Start** by dragging the pin at the right
    (Flow Output Pin) of the **Print** node, and chaining new nodes, but we will do
    that later. Now that we have our scripts doing something, let’s make the instructions
    use the fields we created so the scripts use their configurations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将 **Print** 节点右侧的引脚（流程输出引脚）拖动到 **On Start** 上来将更多操作链接到 **On Start**，并链接新的节点，但我们将在稍后进行。现在，我们的脚本正在做些事情，让我们让指令使用我们创建的字段，以便脚本使用它们的配置。
- en: Using fields in instructions
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在指令中使用字段
- en: We have created fields to configure our components’ behavior, but we have not
    used them so far. We will create meaningful components in the next chapter, but
    one thing we will often need is to use the fields we have created to change the
    behavior of the object. So far, we have no real use of the `speed` field that
    we created. However, following the idea of testing whether our code is working
    (also known as debugging), we can learn how to use the data inside a field with
    a function to test whether the value is the expected one, changing the output
    of `print` in the console according to the field’s value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了字段来配置组件的行为，但到目前为止我们还没有使用它们。我们将在下一章创建有意义的组件，但我们会经常需要使用我们创建的字段来改变对象的行为。到目前为止，我们还没有真正使用我们创建的
    `speed` 字段。然而，按照测试代码是否工作（也称为调试）的想法，我们可以学习如何使用函数中的字段数据来测试值是否为预期的，根据字段值改变控制台 `print`
    的输出。
- en: In our current C# script, our `speed` value doesn’t change during runtime. However,
    as an example, if you are creating a life system with shield damage absorption
    and you want to test whether the reduced damage calculation is working properly,
    you might want to print the calculation values to the console and check whether
    they are correct.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的 C# 脚本中，我们的 `speed` 值在运行时不会改变。然而，作为一个例子，如果你正在创建一个带有护盾伤害吸收的生命系统，并且想要测试减少的伤害计算是否正常工作，你可能想要将计算值打印到控制台并检查它们是否正确。
- en: 'The idea here is to replace the fixed message inside the `print` functions
    with a field. When you do that, `print` will show the field’s value in the console.
    So, if you set a value of `5` in `speed` and you print it, you will see lots of
    messages saying `5` in the console, and the output of the `print` function is
    governed by the field. To test this, your `print` message within the `Update`
    function should look as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是将 `print` 函数内部的固定消息替换为字段。当您这样做时，`print` 将在控制台中显示字段的值。所以，如果您在 `speed` 中设置一个值为
    `5` 并打印它，您将在控制台中看到很多显示 `5` 的消息，`print` 函数的输出由字段控制。为了测试这一点，您在 `Update` 函数中的 `print`
    消息应该如下所示：
- en: '![](img/B18585_05_35.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_35.png)'
- en: 'Figure 5.35: Using a field as a print function parameter'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35：使用字段作为 `print` 函数的参数
- en: 'As you can see, we just put the name of the field without quotation marks.
    If you use quotation marks, you will print a `"``speed"` message. In other scenarios,
    you can use this `speed` value within some moving functions to control how fast
    the movement will be, or you can perhaps create a field called `"fireRate"` (fields
    use **camel case** instead of Pascal case, with the first letter being in lowercase)
    to control the cooldown time between one bullet and the next:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是将字段的名称放在引号之外。如果您使用引号，您将打印一个 `"``speed"` 消息。在其他场景中，您可以在某些移动函数中使用这个 `speed`
    值来控制移动速度，或者您可能创建一个名为 `"fireRate"`（字段使用 **驼峰命名法** 而不是 Pascal 命名法，首字母小写）的字段来控制一枪和下一枪之间的冷却时间：
- en: '![](img/B18585_05_36.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_36.png)'
- en: 'Figure 5.36: Printing the current speed'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36：打印当前速度
- en: Now, to make the Visual Script graph print the value of the **speed** variable
    we created in the **Variables** component, let’s do the following.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使 Visual Script 图形打印出我们在 **Variables** 组件中创建的 **speed** 变量的值，让我们做以下操作。
- en: Open the Visual Scripting graph asset (double-click it).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Scripting 图形资产（双击它）。
- en: In the panel at the left, select the **Object** tab to display all the variables
    our object has—essentially the ones we defined in the **Variables** component
    previously.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的面板中，选择 **Object** 选项卡以显示对象拥有的所有变量——基本上是我们之前在 **Variables** 组件中定义的变量。
- en: 'Drag the **speed** variable using the two lines to the left of the variable
    box to any empty area of the graph. This will create a **GetVariable** node in
    the graph to represent the variable. Consider the drag has a bug at the moment,
    so you might need to try a couple of times, trying to drag from the left part:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变量框左侧的两条线将 `speed` 变量拖动到图形的任何空白区域。这将在图形中创建一个 **GetVariable** 节点来表示变量。请注意，目前拖动可能存在一个错误，所以您可能需要尝试几次，尝试从左侧部分拖动：
- en: '![](img/B18585_05_37.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_37.png)'
- en: 'Figure 5.37: Dragging variables to the graph to be used in the nodes'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.37：将变量拖动到节点中以供使用
- en: 'Drag the empty circle at the right of the **Get Variable** node to the circle
    to the left of the **Message** input pin of the **Print** node. This will replace
    the previous connection to the **String Literal** node. This node doesn’t have
    **Input** or **Output** flow nodes (the green arrow ones), as they are data-only
    nodes that provide data to other nodes. In this case, when `Print` needs to execute,
    it will execute `Get Variable` to get the text to read:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**获取变量**节点右侧的空圆圈拖动到**打印**节点**消息**输入引脚左侧的圆圈上。这将替换之前连接到**字符串文本**节点的连接。此节点没有**输入**或**输出**流节点（绿色箭头节点），因为它们是仅提供数据给其他节点的数据节点。在这种情况下，当**打印**需要执行时，它将执行**获取变量**以获取要读取的文本：
- en: '![](img/B18585_05_38.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_05_38.png)'
- en: 'Figure 5.38: Connecting the speed variable to the print node'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.38：将速度变量连接到打印节点
- en: Right-click on the **String Literal** node and delete it.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**字符串文本**节点并删除它。
- en: Play the game and observe.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放游戏并观察。
- en: With all this, we now have the necessary tools to start creating actual components.
    Before moving on, let’s recap some of the common errors that you will likely encounter
    if this is your first time creating scripts in C#.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，我们现在有了开始创建实际组件所需的工具。在继续之前，让我们回顾一下你可能会遇到的一些常见错误，如果你这是第一次在C#中创建脚本。
- en: Common beginner C# script errors
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的新手C#脚本错误
- en: The Visual Scripting scripts are prepared in a way in which you make fewer errors,
    not allowing you to write incorrect syntax like C# script does. If you are an
    experienced programmer, I bet you are quite familiar with them, but let’s recap
    the common errors that will make you lose lots of time when you are starting with
    C# scripting. Most of them are caused by not copying the shown code *exactly*.
    If you have an error in the code, Unity will show a red message in the console
    and won’t allow you to run the game, even if you are not using the script. So,
    never leave anything unfinished.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化脚本脚本是以一种方式准备的，你犯的错误更少，不允许你写出像C#脚本那样的错误语法。如果你是一个经验丰富的程序员，我敢打赌你对它们相当熟悉，但让我们回顾一下当你开始C#脚本编写时会让你浪费很多时间的常见错误。其中大多数是由于没有**完全**复制显示的代码造成的。如果你在代码中有错误，Unity将在控制台显示红色消息，并且不允许你运行游戏，即使你没有使用脚本。所以，永远不要留下未完成的事情。
- en: 'Let’s start with a classic error, a missing semicolon, which has resulted in
    many programmer memes and jokes. All fields and most instructions inside functions
    (such as `print`), when called, need to have a semicolon at the end. If you don’t
    add a semicolon, Unity will show an error, such as the one in the screenshot on
    the left in *Figure 5.39*, in the console. You will also notice that this also
    has an example of bad code, where the IDE is showing a red icon suggesting something
    is wrong in that place:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从经典的错误开始，一个缺少分号，这导致了许多程序员的梗和笑话。所有字段和函数（如`print`）内部的大多数指令（在调用时）需要在末尾有一个分号。如果你不添加分号，Unity将在控制台显示错误，如*图5.39*左边的截图所示。你还会注意到，这也有一个坏代码的例子，其中IDE显示一个红色图标，表明该位置有问题：
- en: '![](img/B18585_05_39.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_05_39.png)'
- en: 'Figure 5.39: An error in the print line hinted by the IDE and the Unity console'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.39：IDE和Unity控制台提示的打印行错误
- en: You will notice that the error shows the exact script (`MyFirstScript.cs`),
    the exact line of code (`14`, in this case), and usually, a descriptive message—in
    this case, `;` `expected—`as a way to specify the instruction ends there, so the
    compiler can process the next instruction as a separate one. You can simply double-click
    the error and Unity will open the IDE highlighting the problematic line. You can
    even click on the links in the stack to jump to the line of the stack that you
    want.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到错误显示了确切的脚本（`MyFirstScript.cs`），确切的代码行（在这种情况下是`14`），通常还有一个描述性的消息——在这种情况下，`;`
    `expected`——作为指定指令在那里结束的方式，以便编译器可以处理下一个指令作为单独的一个。你可以简单地双击错误，Unity将打开IDE并突出显示有问题的行。你甚至可以点击堆栈中的链接跳转到你想要的堆栈行。
- en: I already mentioned why it is important to use the *exact* case for every letter
    of the instruction. However, based on my experience of teaching beginners, I need
    to stress this particular aspect more.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到为什么使用指令中每个字母的**确切**大小写很重要。然而，根据我教授新手的经验，我需要强调这个特定的方面。
- en: 'The first scenario where this can happen is in instructions. In the following
    screenshots, you can see how a badly written `print` function looks—that is, the
    error that the console will display and how the IDE will suggest that there is
    something wrong. First, in the case of Rider, the instruction is colored red,
    saying that the instruction is not recognized (in Visual Studio, it will show
    a red line instead). Then, the error message says that `Print` does not exist
    in the current context, meaning that Unity (or C#, actually) does not recognize
    any instruction named `Print`. In another type of script, `Print` in uppercase
    may be valid, but not in regular components, which is why the “**in the current
    context**” clarification exists:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能发生的第一个场景是在指令中。在下面的屏幕截图中，你可以看到一个写得不好的`print`函数的样子——即控制台将显示的错误以及IDE将建议存在错误。首先，在Rider的情况下，指令被标记为红色，表示指令不被识别（在Visual
    Studio中，将显示为红色横线）。然后，错误信息表明`Print`在当前上下文中不存在，这意味着Unity（或实际上C#）不识别任何名为`Print`的指令。在另一种类型的脚本中，大写的`Print`可能是有效的，但在常规组件中则不行，这就是为什么存在“**在当前上下文中**”的说明：
- en: '![](img/B18585_05_40.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_40.png)'
- en: 'Figure 5.40: Error hints when writing an instruction wrong'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.40：编写错误指令时的错误提示
- en: 'Now, if you write an event with the wrong casing, the situation is worse. You
    can create functions such as `Start` and `Update` with whatever name you want
    for other purposes. Writing `update` or `start` is perfectly valid as C# will
    think that you are going to use those functions not as events but as regular functions.
    So, no error will be shown, and your code will just not work. Try to write `update`
    instead of `Update` and see what happens:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用错误的大小写编写事件，情况会更糟。你可以为其他目的创建名为`Start`和`Update`的函数，无论你想要什么名字。将`update`或`start`写成小写是完全有效的，因为C#会认为你打算将这些函数用作常规函数，而不是事件。因此，不会显示错误，你的代码将无法正常工作。尝试将`update`写成`Update`，看看会发生什么：
- en: '![](img/B18585_05_41.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_41.png)'
- en: 'Figure 5.41: The wrong casing in the Update function will compile the function
    but won’t execute it'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.41：Update函数中的错误大小写将编译函数但不会执行
- en: Another error is to put instructions outside the function brackets, such as
    inside the brackets of the class or outside them. Doing this will give no hint
    to the function as to when it needs to execute. So, a `print` function outside
    an `Event` function makes no sense, and it will show an error such as the ones
    in the following *Figures 5.42* and *5.43*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误是将指令放在函数括号之外，例如在类的括号内或括号外。这样做将不会给函数任何提示，说明何时需要执行。因此，在`Event`函数之外的`print`函数是没有意义的，它将显示如下*图5.42*和*图5.43*中的错误之一。
- en: 'This time, the error is not super descriptive. C# is expecting you to create
    a function or a field—the kind of structures that can be put directly inside a
    class:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，错误信息并不非常详细。C#期望你创建一个函数或字段——可以直接放在类中的结构：
- en: '![](img/B18585_05_42.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_42.png)'
- en: 'Figure 5.42: Misplaced instruction or function call'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.42：放置错误的指令或函数调用
- en: 'Finally, another classic mistake is to forget to close open brackets. If you
    don’t close a bracket, C# won’t know where a function finishes and another starts
    or where the class function ends. This may sound redundant, but C# needs that
    to be perfectly defined. In the following screenshots, you can see how this would
    look:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，另一个经典的错误是忘记关闭打开的括号。如果你不关闭一个括号，C#将不知道一个函数在哪里结束，另一个函数在哪里开始，或者类函数在哪里结束。这可能听起来有些多余，但C#需要这一点才能定义得完美。在下面的屏幕截图中，你可以看到这会是什么样子：
- en: '![](img/B18585_05_43.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_05_43.png)'
- en: 'Figure 5.43: Missing closed brackets'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.43：缺少闭合括号
- en: This one is a little bit difficult to catch because the error in the code is
    shown way after the actual error. This is caused by the fact that C# allows you
    to put functions inside functions (not used often) and so C# will detect the error
    later, asking you to add a closing bracket. However, as we don’t want to put `Update`
    inside `Start`, we need to fix the error before, at the end of `Start`. The error
    message will be descriptive in the console, but again, don’t put the close bracket
    where the message suggests you do so unless you are 100% sure that position is
    correct.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误有点难以捕捉，因为代码中的错误显示在实际错误之后。这是由于C#允许你将函数放在函数内部（不常用）的事实，因此C#会在稍后检测到错误，要求你添加一个闭合括号。然而，由于我们不希望在`Start`中放置`Update`，我们需要在`Start`的末尾之前修复错误。控制台中的错误信息将是描述性的，但同样，除非你100%确定位置是正确的，否则不要按照消息建议的位置放置闭合括号。
- en: 'You will likely face lots of errors aside from these ones, but they all work
    the same. The IDE will show you a hint and the console will display a message;
    you will learn them with time. Just have patience as every programmer experiences
    this. There are other kinds of errors, such as runtime errors, code that compiles
    but will fail when being executed due to some misconfiguration, or the worst:
    logic errors, where your code compiles and executes with no error but doesn’t
    do what you intended.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到很多错误，除了这些之外，但它们都是一样的。IDE会为你提供提示，控制台会显示消息；随着时间的推移，你会学会它们。只需保持耐心，因为每个程序员都会经历这个过程。还有其他类型的错误，例如运行时错误，代码可以编译但在执行时由于某些配置错误而失败，或者最糟糕的是：逻辑错误，你的代码可以编译并执行而没有错误，但并没有做你想要的事情。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the basic concepts that you will use while creating
    scripts. We discussed the concept of a script’s assets and how the C# ones must
    inherit from `MonoBehaviour` to be accepted by Unity to create our own scripts.
    We also saw how to mix events and instructions to add behavior to an object and
    how to use fields in instructions to customize what they do. All of this was done
    using both C# and Visual Scripting.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了你在创建脚本时将使用的的基本概念。我们讨论了脚本资产的概念以及C#脚本必须继承自`MonoBehaviour`才能被Unity接受以创建我们自己的脚本。我们还看到了如何混合事件和指令来为对象添加行为，以及如何在指令中使用字段来自定义它们的行为。所有这些操作都是使用C#和视觉脚本完成的。
- en: We just explored the basics of scripting to ensure that everyone is on the same
    page. However, from now on, we will assume that you have basic coding experience
    in some programming language, and you know how to use structures such as `if`,
    `for`, `array`, and so on. If not, you can still read through this book and try
    to complement the areas you don’t understand with a C# introduction book as you
    need.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚探索了脚本的基础知识以确保每个人都处于同一水平线上。然而，从现在开始，我们将假设你具备一些编程语言的基本编码经验，并且知道如何使用诸如`if`、`for`、`array`等结构。如果不具备，你仍然可以阅读这本书，并在需要时通过C#入门书籍来补充你不理解的部分。
- en: In the next chapter, we are going to start seeing how we can use what we have
    learned to create movement and spawning scripts.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始看到如何使用我们所学的内容来创建移动和生成脚本。
- en: Join us on Discord!
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord频道！
- en: Read this book alongside other users, Unity game development experts, and the
    author himself.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过Ask Me Anything（问我任何问题）环节与作者聊天，等等。
- en: Scan the QR code or visit the link to join the community.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接加入社区。
- en: '![](img/Nicolas_QR_Code.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/Nicolas_QR_Code.png)'
- en: '[https://packt.link/handsonunity22](Chapter_5.xhtml)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/handsonunity22](Chapter_5.xhtml)'
