- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Continuing the FPS Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续开发FPS游戏
- en: In [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187), we made some updates to
    our GDD for our new 3D FPS game. We added specific details about the level design,
    which helped us to create the habitat’s interior-level environment using a grayboxing
    kit of modular parts that *snap* together. We also used Unity **ProBuilder** to
    draw out a level map.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18347_10.xhtml#_idTextAnchor187)中，我们对我们的新3D第一人称射击游戏的GDD进行了一些更新。我们添加了关于关卡设计的具体细节，这有助于我们使用模块化部件的灰色盒子套件创建栖息地的内部关卡环境。我们还使用了Unity
    **ProBuilder**来绘制关卡地图。
- en: We finished by learning how to quickly add an FPS player character to our game
    by utilizing the **Unity Starter Assets First Person Character Controller**. We
    added the health system and healing pickups to engage the player’s abilities by
    reusing previous systems and code. We also refactored to 3D API method counterparts
    to make an animated door that opens when the player triggers it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习如何利用**Unity Starter Assets First Person Character Controller**快速添加FPS玩家角色到我们的游戏来结束。我们通过重用之前的系统和代码添加了健康系统和治疗拾取，以激发玩家的能力。我们还重构了3D
    API方法对应物，制作了一个当玩家触发时可以打开的动画门。
- en: In this chapter, we will update and finalize the 3D environment with polished
    assets, scatter objects to increase realism, and incorporate wear-and-tear effects.
    Additionally, we will improve the lighting to create an immersive experience for
    the player and ensure optimal game performance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用抛光资产更新和最终确定3D环境，添加散布对象以增加真实感，并融入磨损和磨损效果。此外，我们将改进光照以创造一个让玩家沉浸其中的体验，并确保最佳游戏性能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Decorating the 3D environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰3D环境
- en: Immersing the player using Polybrush and Decals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Polybrush和贴图让玩家沉浸其中
- en: Lighting design – Probes, Decals, light baking, and performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光设计 – 探针、贴图、光照烘焙和性能
- en: By the end of this chapter, you will have the skills to enhance a 3D environment
    by replacing **Prefabs** and materials, increase realism and immerse the player
    by decorating the environment using Unity artist tools such as **Polybrush** and
    **Decals**, and bake lighting along with techniques to overcome limitations for
    lighting and shadows of dynamic objects in the scene. Additionally, you will gain
    knowledge on performance considerations related to lighting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备通过替换**Prefab**和材质来增强3D环境、通过使用Unity艺术家工具如**Polybrush**和**贴图**来装饰环境以增加真实感和沉浸感，以及烘焙光照以及克服场景中动态对象光照和阴影限制的技术。此外，你还将了解与光照相关的性能考虑因素。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the same artwork that was created for the project in this
    book, download the assets from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本书中为项目创建的相同艺术品，请从GitHub下载资源：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets)。
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载完整项目：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: To follow along with your own 3D artwork, you’ll need to create similar artwork
    using 3D modeling and texturing software (for example, Blender, Maya, 3ds Max,
    Cinema 4D, ZBrush, Silo, Substance 3D Painter, Quixel Mixer, or 3DCoat).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随自己的3D艺术品，你需要使用3D建模和纹理软件（例如，Blender、Maya、3ds Max、Cinema 4D、ZBrush、Silo、Substance
    3D Painter、Quixel Mixer或3DCoat）创建类似的艺术品。
- en: Decorating the 3D environment
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰3D环境
- en: Our 3D FPS game is well on its way to becoming something of a real game, but
    it must graduate from its graybox environment first if we want it to be attractive
    to potential players. This section will explore Unity 2022 features for replacing
    the graybox kit module’s Prefabs with polished and textured 3D mesh Prefabs that
    properly represent our habitat’s interior environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的3D第一人称射击游戏正在稳步发展，有望成为一款真正的游戏，但如果我们希望它对潜在玩家有吸引力，它必须首先从其灰色盒子环境中毕业。本节将探讨Unity
    2022的功能，用于用经过抛光和纹理处理的3D网格Prefab替换灰色盒子工具包模块的Prefab，以正确地表示我们栖息地的内部环境。
- en: We’ll not only replace the existing graybox Prefabs but also introduce new assets
    to decorate the environment to make it feel more complete and lived-in. This will
    be a combination of both 3D models and textures that we’ll apply in different
    ways, again, using Unity’s artist feature tooling (specific to **Universal RP**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将替换现有的灰色盒子预制件，还会引入新的资产来装饰环境，使其感觉更加完整和有人居住。这将是3D模型和纹理的组合，我们将以不同的方式应用它们，再次使用Unity的艺术师功能工具（特定于**Universal
    RP**）。
- en: 'Here is an example of what our interior habitat environment – which has gone
    through the processes outlined in this chapter – will look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子，展示了我们的室内栖息地环境——它已经经历了本章概述的过程——将是什么样子：
- en: '![Figure 11.1 – Habitat interior scene lighting](img/B18347_11_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 栖息地内部场景照明](img/B18347_11_1.jpg)'
- en: Figure 11.1 – Habitat interior scene lighting
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 栖息地内部场景照明
- en: Our first order of business is to replace those boring graybox Prefabs. Having
    the environment look correct will help with the following steps as we decorate
    and detail it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是替换那些无聊的灰色盒子预制件。让环境看起来正确将有助于我们在装饰和细化过程中的以下步骤。
- en: Updating and replacing Prefabs
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和替换预制件
- en: Replacing Prefabs is more of a structured approach to dealing with the art assets;
    since we’re working with fixed modular parts, the art is in creating polished
    3D assets. In this case, we’re going to be using 3D assets produced by my friends
    over at Polypix Studios ([https://polypixstudios.com/](https://polypixstudios.com/)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 替换预制件是一种处理艺术资产的结构化方法；由于我们使用的是固定模块化部件，艺术创作在于创建精炼的3D资产。在这种情况下，我们将使用来自Polypix Studios的朋友制作的3D资产（[https://polypixstudios.com/](https://polypixstudios.com/)）。
- en: Note of gratitude
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢信
- en: Miguel Dumars was kind enough to provide select assets from their *Neon Street*
    and *Stylized Scifi Modular Corridor* Unreal kits for use in this Unity project,
    and I’m very excited to be working with these assets!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Miguel Dumars非常慷慨，提供了他们*霓虹街道*和*风格化科幻模块化走廊*Unreal套件中的部分资产供这个Unity项目使用，我很高兴能与这些资产合作！
- en: Polypix Studios has permitted the use of the provided game art for learning
    purposes only; commercial use is strictly prohibited. Polypix Studio’s portfolios
    can be viewed on ArtStation at [https://www.artstation.com/polypixcc](https://www.artstation.com/polypixcc)
    and Unreal Marketplace at [https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios](https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Polypix Studios允许仅用于学习目的使用提供的游戏艺术资产；商业用途是严格禁止的。Polypix Studio的精选作品可以在ArtStation上查看，网址为[https://www.artstation.com/polypixcc](https://www.artstation.com/polypixcc)，以及Unreal
    Marketplace上的[https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios](https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios)。
- en: To get started, let’s import the Polypix artwork.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们导入Polypix艺术作品。
- en: Importing and reviewing the assets
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入和审查资产
- en: You should be a pro in the process of importing assets into Unity projects by
    now, so we won’t waste any time detailing each little step. Download the 3D art
    assets file, `3DArtwork.zip`, from this book’s GitHub repository (link in the
    *Technical requirements* section) to a temporary directory, then import the `.unitypackage`
    files into your current 3D FPS project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经精通将资产导入Unity项目的过程，所以我们不会浪费时间详细说明每个小步骤。从本书的GitHub仓库（*技术要求*部分中的链接）下载3D艺术资产文件`3DArtwork.zip`到临时目录，然后将`.unitypackage`文件导入到当前的3D
    FPS项目中。
- en: 'In *Figure 11**.2*, we can see the new modular kit parts in the **Polypix Modular
    Kit** scene provided in the package:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图11.2**中，我们可以看到包中提供的**Polypix模块化套件**场景中的新模块化部件：
- en: '![Figure 11.2 – Polypix Studios modular kit](img/B18347_11_2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – Polypix Studios模块化套件](img/B18347_11_2.jpg)'
- en: Figure 11.2 – Polypix Studios modular kit
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – Polypix Studios模块化套件
- en: 'Since this is the first time we’re working with third-party 3D assets, let’s
    have a look at the files that were imported into the `Assets/Polypix 3D Assets/Modular
    Kit` folder (also shown in *Figure 11**.2*):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次使用第三方3D资产，让我们看看导入到`Assets/Polypix 3D Assets/Modular Kit`文件夹中的文件（如图11.2所示）：
- en: '**Materials**: These materials are applied and shared across 3D models of the
    same category (walls, doorways, and so on). The same material is shared across
    several models to keep things more optimized as this reduces draw calls for the
    renderer (that is, it’s less work, resulting in higher FPS).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质**：这些材质应用于并共享同一类别的3D模型（墙壁、门廊等）。相同的材质在多个模型之间共享，以保持事物更加优化，因为这减少了渲染器的绘制调用（也就是说，工作量更少，从而提高了FPS）。'
- en: '**Models**: These are the optimized polygon meshes (vertices, edges, and faces)
    that make up the 3D geometry representing the shape of the objects.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这些是构成表示物体形状的 3D 几何形状的优化多边形网格（顶点、边和面）。'
- en: '**Prefabs** (yes, I know you know what Prefabs are): These are the Polypix
    models with the materials applied and colliders added as finished objects we can
    use directly in our game.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预制件**（是的，我知道你们知道预制件是什么）：这些是已经应用了材质并添加了碰撞器的 Polypix 模型，作为可以直接在我们的游戏中使用的完成对象。'
- en: '**Textures**: Textures are the image files that are mapped onto the 3D geometry
    via assignment to the material that’s applied to 3D geometry to give it color
    and details.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：纹理是通过分配给应用于 3D 几何形状的材质来映射到 3D 几何形状上的图像文件，以给其上色和添加细节。'
- en: We’ll mainly be concerned with the Prefabs since we’ll use them to replace the
    initial graybox kit modular parts we made to build the level. In the `/Prefabs`
    folder, we have the same graybox wall assets but all textured and fancy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要关注预制件，因为我们将使用它们来替换我们为构建关卡而制作的初始灰盒套件模块化部件。在 `/Prefabs` 文件夹中，我们有相同的灰盒墙壁资产，但都添加了纹理和装饰。
- en: Now, let’s see how we can rapidly replace the modular graybox kit Prefabs with
    this new artwork.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何快速用这个新艺术作品替换模块化灰盒套件预制件。
- en: Replacing Prefab instances
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换预制件实例
- en: With the replacement art assets imported into the project, we can go ahead and
    start replacing Prefabs. Unity 2022 has introduced some new Prefab workflow features
    and **Search**, which will greatly help us in this endeavor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将替换的艺术资产导入到项目中后，我们可以开始替换预制件。Unity 2022 引入了一些新的预制件工作流程功能和 **搜索**，这将极大地帮助我们在这个任务中。
- en: Additional reading | Unity Blog
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 博客
- en: 'Unity’s new Prefab workflow features go far beyond simple Prefab replacement,
    transfer overrides, reconnecting Prefabs, and inspecting Prefab Variant relationships.
    You can read about these additional features in the following Unity Blog article:
    *What’s new for Prefabs in* *2022.2?* [https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2](https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的新预制件工作流程功能远远超出了简单的预制件替换、传输覆盖、重新连接预制件和检查预制件变体关系。您可以在以下 Unity 博客文章中了解这些附加功能：*2022.2
    中预制件的新功能是什么？* [https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2](https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2)。
- en: Unity Blog is a fantastic resource for learning content! I highly recommend
    regularly consuming Unity’s blog articles to rapidly broaden your knowledge and
    elevate your understanding of what Unity is capable of.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 博客是学习内容的绝佳资源！我强烈推荐定期阅读 Unity 的博客文章，以快速拓宽知识面并提高对 Unity 能力的理解。
- en: We will use the following process as much as possible to mass-replace the Prefabs
    in our level. However, we’ll no doubt still have to make some manual adjustments
    to some of the layout’s finer details – due to some changes in the art direction
    (that may or may not have been my fault).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽可能使用以下过程来大量替换我们关卡中的预制件。然而，我们无疑仍需要对布局的一些细节进行一些手动调整——由于艺术方向的一些变化（这可能或可能不是我的错）。
- en: Some of the Prefabs that we’ve added behavior to already are examples of Prefabs
    that we must manually update and cannot simply replace in the scene with new art,
    but we’ll still be able to merely replace the art within the Prefab because we’ve
    maintained keeping the *graphics* as separate child objects in the Prefab (as
    you may recall, we’ve been using this practice throughout this book thus far,
    and this is just another example of the benefit of being consistent in terms of
    our approach).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了行为的某些预制件是必须手动更新且不能简单地用新艺术作品替换场景中的预制件的例子，但因为我们仍然保持了将 *图形* 作为预制件中独立的子对象来维护，所以我们仍然能够仅替换预制件中的艺术作品（如您所回忆的，我们到目前为止一直在使用这种做法，这又是我们方法一致性的另一个例子）。
- en: 'Let’s get to it and make our first Prefab replacement. We’ll replace the `Wall
    1` graybox Prefab in the scene with the `Wall 1` Prefab from the Polypix `/Prefabs`
    folder. We’ll use both the new **Search** feature as well as the **Prefab Replace**
    workflow by following these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，制作我们的第一个预制件替换。我们将用 Polypix `/Prefabs` 文件夹中的 `Wall 1` 预制件替换场景中的 `Wall 1`
    灰盒预制件。我们将通过以下步骤使用新的 **搜索** 功能以及 **预制件替换** 工作流程：
- en: Open **Search** by going to **Window** | **Search** | **New Window**, clicking
    the **Open in Search** button at the top of the **Hierarchy** window, or pressing
    *Ctrl*/*Cmd* + *K*.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 **窗口** | **搜索** | **新窗口**，点击 **层次** 窗口顶部的 **在搜索中打开** 按钮，或按 *Ctrl*/*Cmd*
    + *K* 来打开 **搜索**。
- en: In the `Wall 1` with quotes to search explicitly for this string (removing the
    quotes will search for all occurrences; note that **Search** is not case sensitive).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Wall 1` 中使用引号来显式搜索此字符串（移除引号将搜索所有出现；请注意，**搜索** 不区分大小写）。
- en: Select the **Hierarchy** tab to filter the search to only objects in the open
    scene **Hierarchy**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **层次结构** 选项卡以过滤搜索，仅限于打开场景的 **层次结构** 中的对象。
- en: Now, select all the items in the results list by clicking on the first item,
    then scroll to the bottom and hold *Shift* and click the last item.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过单击第一个项目，然后滚动到列表底部并按住 *Shift* 并单击最后一个项目来选择结果列表中的所有项目。
- en: 'Right-click and click **Select** (or hit the *Enter* key):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并点击 **选择**（或按 *Enter* 键）：
- en: '![Figure 11.3 – Unity Search for easy scene Prefab selection](img/B18347_11_3.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Unity 搜索轻松场景预制件选择](img/B18347_11_3.jpg)'
- en: Figure 11.3 – Unity Search for easy scene Prefab selection
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Unity 搜索轻松场景预制件选择
- en: 'With all of the `Wall 1` Prefabs in the scene now selected, we can easily replace
    them with **Prefab Replace** – which is only a two-step process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景中所有 `Wall 1` 预制件都已选中，我们可以轻松地使用 **预制件替换** 来替换它们 – 这只是一个两步的过程：
- en: 'Right-click one of the selected `Wall 1` Prefabs in the **Hierarchy** area,
    then select **Prefab |** **Replace…**:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 区域右键单击选定的 `Wall 1` 预制件，然后选择 **预制件 |** **替换…**：
- en: '![Figure 11.4 – Prefab – replace instance selection](img/B18347_11_4.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 预制件 – 替换实例选择](img/B18347_11_4.jpg)'
- en: Figure 11.4 – Prefab – replace instance selection
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 预制件 – 替换实例选择
- en: 'Select the replacement Prefab in the `Assets/Polypix 3D Assets/Modular Kit/Prefabs`
    folder (using *Table 11.1* as a reference):'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Polypix 3D Assets/Modular Kit/Prefabs` 文件夹中选择替换预制件（使用 *表 11.1* 作为参考）：
- en: '![Figure 11.5 – Selecting the replacement Prefab](img/B18347_11_5.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 选择替换预制件](img/B18347_11_5.jpg)'
- en: Figure 11.5 – Selecting the replacement Prefab
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 选择替换预制件
- en: 'You can use the replacements indicated in the following table for the graybox
    kit Prefab and corresponding Polypix imported Prefab as a guide:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用下表中指示的替换内容作为灰盒套件预制件和相应 Polypix 导入预制件的指南：
- en: '| **Greybox Prefab** | **Polypix Prefab** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **灰盒预制件** | **Polypix 预制件** |'
- en: '| --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Wall 1` | `Wall_01 Variant` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Wall 1` | `Wall_01 Variant` |'
- en: '| `Wall 2` | `Wall_02 Variant` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Wall 2` | `Wall_02 Variant` |'
- en: '| `Wall 4` | `Wall_04 Variant` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Wall 4` | `Wall_04 Variant` |'
- en: '| `Doorway 1` | `Doorway_01 Variant` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Doorway 1` | `Doorway_01 Variant` |'
- en: Table 11.1 – Replacement graybox Prefabs
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 – 替换灰盒预制件
- en: New to Unity 2022 – 3D models are Prefabs
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 新增于 Unity 2022 – 3D 模型是预制件
- en: You might be wondering why the Polypix replacement Prefabs listed in *Table
    11.1* all have *Variant* in their naming. Well, that’s because you can no longer
    make original Prefabs from 3D models (for example, FBX files). Unity now imports
    3D models as **Model Prefabs**, so when you create a Prefab out of a 3D model,
    it must be a **Prefab Variant**. This change goes a long way to help ensure we
    don’t break Prefab content for our 3D model assets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么 *表 11.1* 中列出的 Polypix 替换预制件名称中都带有 *Variant*。嗯，那是因为您现在不能再从 3D 模型（例如，FBX
    文件）中创建原始预制件了。Unity 现在将 3D 模型导入为 **模型预制件**，因此当您从 3D 模型创建预制件时，它必须是 **预制件变体**。这一变化在很大程度上有助于确保我们不会破坏
    3D 模型资产的内容。
- en: Since all of the Polypix assets have been pre-produced in Unity for immediate
    use in our scene with the proper materials, textures, scale, and so on and re-saved,
    they become variants of the original 3D Model Prefabs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有 Polypix 资产都已预先在 Unity 中制作，并立即用于场景中，具有适当的材质、纹理、比例等，并重新保存，因此它们成为原始 3D 模型预制件的变体。
- en: '*Figure 11**.6* shows the results of my efforts in doing these simple Prefab
    replacement steps for the walls and doorway listed in *Table 11.1*. The job of
    updating the artwork is already more than halfway done! Easy-peasy:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.6* 展示了我对表中 11.1 列出的墙体和门道进行简单预制件替换步骤的努力成果。更新艺术作品的工作已经完成了一半以上！轻而易举：'
- en: '![Figure 11.6 – Wall Prefabs replaced in the scene](img/B18347_11_6.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 场景中替换的墙体预制件](img/B18347_11_6.jpg)'
- en: Figure 11.6 – Wall Prefabs replaced in the scene
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 场景中替换的墙体预制件
- en: Tip
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that in my level design, I found that I could not use all the replacements
    directly with the finished artwork and instead changed some of the wall modules
    out for different ones. So, your mileage may vary as well. It’s all part of the
    design process; much like coding, it’s an iterative process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我的关卡设计中，我发现我无法直接使用所有替换内容与完成的艺术作品，而是将一些墙体模块更换为不同的模块。因此，您的使用效果可能会有所不同。这都是设计过程的一部分；就像编码一样，它是一个迭代的过程。
- en: Just repeat the preceding steps to replace all the static graybox modular parts
    – *static* means these are structural and don’t contain any behavior, interactivity,
    or animation. We’ll address the `Door_Triggered` Prefab next since it has animation
    and won’t be directly replaced.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只需重复前面的步骤来替换所有静态灰盒模块化组件 – *静态*意味着这些是结构性的，不包含任何行为、交互或动画。我们将首先处理具有动画的 `Door_Triggered`
    预制件，因为它不会直接替换。
- en: These additional updates on the graybox kit parts will occur in **Prefab Edit
    Mode**, but we’ll still simply replace the *graphics* with the updated artwork.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对灰盒组件包的额外更新将在**预制件编辑模式**下进行，但我们仍然会简单地用更新的艺术品替换掉*图形*。
- en: Updating the existing modular Prefabs
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新现有的模块化预制件
- en: 'Some Prefabs, such as `Doorway_Trigger`, cannot just be replaced because they
    have the behavior we added in the form of a collider-triggered animation. Using
    this as an example workflow, let’s update `Doorway_Trigger` by performing the
    following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些预制件，如 `Doorway_Trigger`，不能简单地替换，因为它们具有我们添加的行为，即通过碰撞触发动画。以这个为例工作流程，让我们通过以下步骤更新
    `Doorway_Trigger`：
- en: Open the `Door_Triggered` Prefab in **Prefab Edit Mode** for direct editing.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**预制件编辑模式**下打开 `Door_Triggered` 预制件以进行直接编辑。
- en: Add the `Door_Trigger` `/``Prefabs` folder.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Door_Trigger` `/``Prefabs` 文件夹添加到项目中。
- en: Reconnect the animation for the new `Sliding_Door_01` object that replaced the
    `Door` object’s animation – ensure you disable or delete the `Door` object since
    we’re replacing it and don’t need it anymore.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新连接替换 `Door` 对象动画的新 `Sliding_Door_01` 对象的动画 – 确保你禁用或删除 `Door` 对象，因为我们正在替换它，不再需要它。
- en: 'Update `TriggeredEvent.OnTriggered()` `Animator.Play(string)` to reference
    the new `Sliding_Door_01` object that replaced the `Door` object so that our `Door-open`
    animation will still be functional on the new door mesh. Remember that the string
    value for the `Animator.Play()` function is the same as the animation’s name:
    *Door-open*.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TriggeredEvent.OnTriggered()` `Animator.Play(string)` 更新为引用替换 `Door` 对象的新
    `Sliding_Door_01` 对象，以便我们的 `Door-open` 动画在新门网格上仍然有效。记住，`Animator.Play()` 函数的字符串值与动画的名称相同：*Door-open*。
- en: '*Figure 11**.7* illustrates the refactored setup:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11*.7 展示了重构后的设置：'
- en: '![Figure 11.7 – Updating the door trigger Prefab](img/B18347_11_7.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 更新门触发预制件](img/B18347_11_7.jpg)'
- en: Figure 11.7 – Updating the door trigger Prefab
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 更新门触发预制件
- en: I believe this leaves only the **connector** Prefabs that need updating. The
    Polypix assets don’t include direct replacement Prefabs for connectors, so just
    make them yourself! You can create a new connector Prefab by duplicating the original
    graybox asset and then replacing the child graphics – as **nested Prefabs** –
    to create the replacement connector Prefabs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这仅剩下需要更新的**连接器**预制件。Polypix 资产不包括连接器的直接替换预制件，所以请自己制作！你可以通过复制原始灰盒资产并替换子图形（作为**嵌套预制件**）来创建新的连接器预制件。
- en: I won’t provide the steps for this process since you have all the required knowledge
    to accomplish this now. Still, if you get stuck, you can always reference the
    new connector Prefabs in the completed project files in this book’s GitHub repository.
    You’ve got this!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会提供这个过程的步骤，因为现在你已经拥有了完成这个任务所需的所有知识。不过，如果你遇到困难，你始终可以参考本书 GitHub 仓库中完成的项目文件中的新连接器预制件。你行得通！
- en: With that, we have replacement Prefabs from Polypix and some new material textures
    we can apply.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了来自 Polypix 的替换预制件和一些我们可以应用的新材质纹理。
- en: Applying new materials
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用新材料
- en: While we’re doing some art updates, we also have some new materials we can use
    to update our floor planes’ appearance (our `/Materials` folder, we have a **FloorPlate**
    material, so let’s assign that to our map to have it become our textured floor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在进行一些艺术更新时，我们还有一些新材料可以用来更新我们的地板平面的外观（我们的 `/Materials` 文件夹，我们有一个**FloorPlate**材质，所以让我们将其分配给我们的地图，使其成为我们的纹理地板。
- en: 'In *Figure 11**.8*, you can see that I have renamed the **Map** root’s GameObject
    in the **Hierarchy** area to **Floors**. With **Floors** selected, pressing *Shift*
    + *H* will enter **Isolation View** (*A*) – temporarily hiding all the other objects
    in the **Hierarchy** area, which makes it easy for us to assign a new material
    to the selected object by clicking and dragging the **FloorPlate** material (*B*)
    onto a plane in the **Scene** view area:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图11.8*中，你可以看到我已经将**层次结构**区域中**Map**根的GameObject重命名为**Floors**。选择**Floors**后，按下*Shift*
    + *H*将进入**隔离视图**（*A*）——暂时隐藏**层次结构**区域中的所有其他对象，这使得我们可以通过点击并拖动**FloorPlate**材质（*B*）到**场景**视图区域中的平面上来轻松地为选中对象分配新材料：
- en: '![Figure 11.8 – Updating the floor material](img/B18347_11_8.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 更新地板材质](img/B18347_11_8.jpg)'
- en: Figure 11.8 – Updating the floor material
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 更新地板材质
- en: Toggle visibility shortcut
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 切换可见性快捷键
- en: Note that you can also use *Alt/Option* + *Shift* + *A* to toggle the visibility
    of the currently selected object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你也可以使用*Alt/Option* + *Shift* + *A*来切换当前选中对象的可见性。
- en: 'Alternatively, since these planes are ProBuilder objects, we can open the **ProBuilder
    Window** area (**Tools** | **ProBuilder** | **ProBuilder Window**), select **Material
    Editor** from the toolbar, and assign the **FloorPlate** material to the next
    available slot (see *Figure 11**.9*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于这些平面是ProBuilder对象，我们可以打开**ProBuilder窗口**区域（**工具** | **ProBuilder** | **ProBuilder窗口**），从工具栏中选择**材质编辑器**，并将**FloorPlate**材质分配给下一个可用的槽位（见*图11.9*）：
- en: '![Figure 11.9 – ProBuilder Material Editor assignment](img/B18347_11_9.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – ProBuilder材质编辑器分配](img/B18347_11_9.jpg)'
- en: Figure 11.9 – ProBuilder Material Editor assignment
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – ProBuilder材质编辑器分配
- en: With the material assigned, you can now select all the floor planes in the **Hierarchy**
    area and press the shortcut key assigned to the **FloorPlate** material in one
    shot – in our case, that’s *Alt* + *3*. Simple!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 分配了材质后，你现在可以选中**层次结构**区域中的所有地板平面，并一次性按下分配给**FloorPlate**材质的快捷键——在我们的案例中，那就是*Alt*
    + *3*。很简单！
- en: 'While we’re at it with the floor, let’s add a ceiling to our habitat interior
    too! This is quite simple for us now:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理地板时，让我们也给我们的栖息地内部添加一个天花板！现在这对我们来说很简单：
- en: Use **ProBuilder** and create a new plane.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**ProBuilder**创建一个新的平面。
- en: Scale it to contain all of the rooms in our level, then position its height
    at the top of the wall Prefabs – just where a ceiling should be (in my level,
    this comes out to a Y transform position value of `4`).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放到包含我们级别中的所有房间，然后将其高度定位在墙壁预制件顶部——正好是天花板的位置（在我的级别中，这对应于Y变换位置的值`4`）。
- en: From the Polypix `/Materials` folder, assign the **CeilingPlate** material to
    the ceiling plane.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Polypix `/Materials` 文件夹，将**CeilingPlate**材质分配给天花板平面。
- en: Lastly, for the texture to be visible from the bottom of the plane, not the
    top, as is the default and not what we want since our player is below the ceiling
    and looking up at it, in the **ProBuilder** window, click **Flip Normals**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使纹理从平面的底部而不是顶部可见，这是默认设置，但不是我们想要的，因为我们的玩家在天花板下方向上看它，在**ProBuilder**窗口中，点击**翻转法线**。
- en: Surface normals
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表面法线
- en: '**Normals** – or **surface normals** – depict the direction a polygon’s surface
    faces (that is, its visible side):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**法线**——或**表面法线**——描述了多边形表面的方向（即其可见侧面）：'
- en: '![](img/B18347_11_Collout-Image.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18347_11_Collout-Image.jpg)'
- en: The surface on the left has its normals (the orange lines) pointing up, facing
    the camera so that we can see the texture. In contrast, the surface on the right
    has its normals pointing down and away from the camera, so we cannot see the texture.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的表面其法线（橙色线条）向上指向，面向摄像机，这样我们就可以看到纹理。相比之下，右侧的表面其法线向下并远离摄像机，所以我们看不到纹理。
- en: And with that, we have our graybox level all updated with polished artwork!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的灰色盒子级别已经全部更新，艺术作品已经打磨完成！
- en: In this section, we saw how to replace graybox assets used for prototyping with
    imported polished artwork using Unity’s new **Prefab Workflow** and **Search**.
    We then finished up the interior 3D habitat environment refresh by applying some
    new materials.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用Unity的新**Prefab工作流程**和**搜索**替换用于原型设计的灰色盒子资产，并使用导入的打磨完成的艺术作品。然后，我们通过应用一些新材料完成了内部3D栖息地环境的更新。
- en: Next, since our 3D habitat environment still looks a bit boring, we can quickly
    fix that by scattering some Prefabs about the place.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于我们的3D栖息地环境看起来还是有点无聊，我们可以通过在周围散布一些预制件来快速解决这个问题。
- en: Immersing the player using Polybrush and Decals
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Polybrush和Decals让玩家沉浸其中
- en: In contrast to the previous structured method of using fixed, modular parts
    such as Prefab replacements, a more freeform method offers a different perspective
    to the artistic approach. So, instead of relying on prefabricated objects, we’ll
    create dynamic, spontaneous pieces from scratch (well, randomization) using Polybrush.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前使用固定、模块化部件（如预制体替换）的结构化方法相比，一种更自由的形式方法为艺术方法提供了不同的视角。因此，我们不会依赖于预制体对象，而是将从零开始（好吧，随机化）使用Polybrush创建动态、自发的部件。
- en: Painting objects with Polybrush
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Polybrush绘画对象
- en: '**Polybrush** offers us an unconstrained way to decorate the environment and
    randomly scatter Prefabs for their placement – so, not modular at all. Considering
    this, we’re only going to cover the **Scatter Objects** feature of Polybrush,
    but know that it has more capabilities than that.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Polybrush**为我们提供了一种不受限制的方式来装饰环境，并随机散布预制体以进行放置 – 因此，根本不是模块化的。考虑到这一点，我们只将介绍Polybrush的**散布对象**功能，但要知道它还有更多功能。'
- en: Additional reading | Unity documentation
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'You can read more about Polybrush here: [https://unity.com/features/polybrush](https://unity.com/features/polybrush).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于Polybrush的信息：[https://unity.com/features/polybrush](https://unity.com/features/polybrush)。
- en: While preparing for writing, I experienced some issues using Polybrush to paint
    objects onto ProBuilder’ized meshes, so while waiting for Unity to respond to
    my bug report concerning this, we’ll continue with a workaround, which is simply
    to enable **Use Additional Vertex Streams** in **Preferences** | **Polybrush**.
    Remember this should you run into any problems with ProBuilder objects! As an
    alternative, you can mesh’ify the ProBuilder objects by selecting them and going
    to **Tools** | **ProBuilder** | **Actions** | **Strip ProBuilder Scripts in Selection**,
    but this also means you will no longer be able to edit the mesh with ProBuilder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备写作的过程中，我使用Polybrush在ProBuilder化网格上绘画对象时遇到了一些问题，因此在我等待Unity对我的关于此问题的错误报告做出回应时，我们将继续使用一个简单的解决方案，即在**首选项**
    | **Polybrush**中启用**使用额外的顶点流**。如果你在使用ProBuilder对象时遇到任何问题，请记住这一点！作为替代方案，你可以通过选择它们并转到**工具**
    | **ProBuilder** | **动作** | **在所选内容中剥离ProBuilder脚本**来将ProBuilder对象网格化，但这也意味着你将无法再使用ProBuilder编辑网格。
- en: Now that we’ve learned how to avoid issues while painting on specific object
    meshes, let’s paint!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在特定对象网格上绘画时避免问题，让我们开始绘画吧！
- en: Painting/scattering objects
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘画/散布对象
- en: We’ll need some objects to scatter throughout our environment, so if you haven’t
    already, import `Sci_Fi_Assets.unitypackage` from the GitHub artwork download.
    You’ll want to do it now, if not earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些对象来散布到我们的环境中，所以如果你还没有做，请从GitHub艺术作品下载中导入`Sci_Fi_Assets.unitypackage`。如果你之前没有做，现在就做吧。
- en: 'Now, while referencing *Figure 11**.10*, follow these steps to set up the Prefab
    painting:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在参考 *图11.10* 的同时，按照以下步骤设置预制体绘画：
- en: Open **Polybrush** by going to **Tools** | **Polybrush** | **Polybrush Window**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**工具** | **Polybrush** | **Polybrush 窗口**来打开**Polybrush**。
- en: Click the **Scatter Prefabs on meshes** button (*A* in *Figure 11**.10*).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**在网格上散布预制体**按钮 (*A* 见 *图11.10*).
- en: 'Drag the `Barrels` and `Trashcan` Prefabs from the `Assets/Polypix 3D Assets/Prefabs`
    folder from the **Project** window to the **Current Palette** section (*B* in
    *Figure 11**.10*):'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将**Barrels**和**Trashcan**预制体从**项目**窗口中的`Assets/Polypix 3D Assets/Prefabs`文件夹拖到**当前调色板**部分
    (*B* 见 *图11.10*):'
- en: '![Figure 11.10 – Polybrush Prefab painting setup](img/B18347_11_10.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – Polybrush 预制体绘画设置](img/B18347_11_10.jpg)'
- en: Figure 11.10 – Polybrush Prefab painting setup
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – Polybrush 预制体绘画设置
- en: By default, **Hit Surface is Parent** is enabled in the **Polybrush Window**
    area, making all the painted Prefabs a child of the mesh being painted on. In
    *Figure 11**.10*, you can see that I have disabled **Hit Surface is Parent** so
    that all the painted objects can be collected into a single parent **GameObject**
    in the **Hierarchy** area (this is my preference, but you may prefer to have the
    painted objects as children of the mesh they were painted on). If you’re keeping
    this option disabled, once you’ve painted objects throughout the environment,
    ensure you select all the painted objects from the root of the **Hierarchy** area
    and move them into a new, empty *Scattered Objects* root GameObject.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**击中表面是父对象**在**Polybrush窗口**区域中是启用的，使得所有绘制的预制对象成为被绘制网格的子对象。在图11.10中，你可以看到我已经禁用了**击中表面是父对象**，这样所有绘制的对象都可以收集到**层次结构**区域的单个父**GameObject**中（这是我的偏好，但你可能更喜欢将绘制的对象作为它们被绘制网格的子对象）。如果你保持此选项禁用，一旦你在整个环境中绘制了对象，请确保从**层次结构**区域的根处选择所有绘制的对象，并将它们移动到一个新的、空的*散布对象*根GameObject中。
- en: We can now proceed to decorate the environment by using the assets that were
    added to the **Current Palette** area (wearing our *interior designer* hat?).
    First, add the Prefabs for our brush from the **Current Palette** area to the
    **Brush Loadout** selection (as seen in *B* in *Figure 11**.10*) by checking off
    the item (selecting the item in the **Current Palette** area will also produce
    a drop-down section below it where you can adjust settings for how the item should
    be considered for painting).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用添加到**当前调色板**区域的资产来装饰环境（戴上我们的*室内设计师*帽子？）。首先，将**当前调色板**区域中的刷子预制对象添加到**刷子配置**选择中（如图11.10中的*图B*所示），通过勾选项目（在**当前调色板**区域中选择项目也会在其下方产生一个下拉部分，你可以调整项目在绘制时应如何考虑的设置）。
- en: Painting Prefab objects in the environment is now as simple as hovering the
    mouse cursor over the floor mesh in the **Scene** view and holding the left mouse
    button down while dragging in the area you want to have objects scattered – as
    seen in *C* in *Figure 11**.10*. Holding down *Ctrl*/*Cmd* while painting will
    work as an eraser and remove objects should you dislike any placements. Have fun!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境中绘制预制对象现在就像在**场景**视图中将鼠标光标悬停在地板网格上，然后按住鼠标左键拖动到你想要散布对象区域一样简单——如图11.10中的*图C*所示。在绘制时按住*Ctrl*/*Cmd*键将作为橡皮擦使用，并移除你不喜欢的任何放置。祝您玩得开心！
- en: Tip
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Polybrush works on vertical surfaces too, so you can scatter Prefabs on the
    walls (just know that you may need to re-orient or position the Prefab’s anchor
    for the objects to paint as intended; I have provided an example Prefab for this
    with **Exhaust_01 Pb**).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Polybrush也可以在垂直表面上工作，所以你可以在墙上散布预制对象（只是要知道你可能需要重新定位或调整预制对象的锚点，以便对象按预期绘制；我已经提供了一个带有**Exhaust_01
    Pb**的示例预制对象）。
- en: Scattering objects to break up the environment is one part of environment design
    that can lead to the better immersion of the player, while another is also breaking
    up visually repeating patterns. We can solve the latter with another Unity artist
    tool that recently got some love in version 2022.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 散布对象以打破环境是环境设计的一部分，可以使玩家的沉浸感更好，而另一部分也是打破视觉重复模式。我们可以通过Unity艺术家工具解决后者，该工具在2022版本中得到了一些关注。
- en: Surface story with Decals
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用贴图进行表面故事
- en: As my friend Miguel, over at Polypix Studios, would say, *surface story matters*,
    and I wholeheartedly agree! Unless you’re going for a super-pristine futuristic-clean
    look, you’ll want to ensure your environments are grounded in the real world.
    This means that these environments will communicate their history of usage – wear
    and tear – through their texture details. Let’s say our habitat station’s maintenance
    robots are not very good at janitorial duties, so the environment should be indicated
    as such. Plus, you know that there should be some indication of the plant entity’s
    effect on the environment!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我朋友米格尔在Polypix Studios说的那样，*表面故事很重要*，我完全同意！除非你追求超级纯净的未来清洁外观，否则你希望确保你的环境扎根于现实世界。这意味着这些环境将通过其纹理细节传达其使用历史——磨损和损坏。比如说，我们栖息地站的维护机器人不太擅长清洁工作，所以环境应该表明这一点。此外，你知道应该有一些迹象表明植物实体对环境的影响！
- en: This is a great opportunity to either refer back to the GDD or expand upon the
    details that support the story we’re telling through the environmental design.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的机会，要么回顾GDD，要么扩展支持我们通过环境设计讲述的故事的细节。
- en: As designers (or developers wearing the hat of a designer), we don’t need much
    in the way of 3D artistic skills to leverage surface story in our environment
    design. We can use tooling that Unity provides (surprised?) to add surface details
    to the environment, and we do that with **Decals**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计师（或者戴着设计师帽子的开发者），我们不需要太多的3D艺术技能就能利用环境设计中的表面故事。我们可以使用Unity提供的工具（惊讶吗？）来添加环境中的表面细节，我们通过**贴图**来实现这一点。
- en: Additional reading | Unity documentation
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'You can read more about the Decal renderer feature (URP) here: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于贴图渲染器功能（URP）的信息：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml)。
- en: Before we can use Decals in our project, we have to enable the feature.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在项目中使用贴图之前，我们必须启用该功能。
- en: Enabling the Decal feature in URP
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在URP中启用贴图功能
- en: 'To enable **Decals** in the **Universal RP** settings, while referring to *Figure
    11**.11*, follow these steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**Universal RP**设置中启用**贴图**，参考*图11*.11，按照以下步骤操作：
- en: In the `Assets/Settings` folder, select the **URP-HighFidelity-Renderer** asset
    (*A* in *Figure 11**.11*). Note that this is the default setting unless you’ve
    changed the default **Quality** value in the **Project** **Settings** area.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Settings`文件夹中，选择**URP-HighFidelity-Renderer**资产（*图11*.11中的*A*）。请注意，除非你已经在**项目****设置**区域更改了默认**质量**值，否则这是默认设置。
- en: 'Click the **Add Renderer Feature** button (*B* in *Figure 11**.11*) in the
    **Inspector** area, then select **Decal** from the list:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**区域点击**添加渲染器功能**按钮（*图11*.11中的*B*），然后从列表中选择**贴图**：
- en: '![Figure 11.11 – Enabling Decal for Universal RP](img/B18347_11_11.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 在Universal RP中启用贴图](img/B18347_11_11.jpg)'
- en: Figure 11.11 – Enabling Decal for Universal RP
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 在Universal RP中启用贴图
- en: Now, we need some decal textures to use for our Decals!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些贴图纹理来用于我们的贴图！
- en: Decal textures
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贴图纹理
- en: First, we’ll need to get some detailed textures into our environment via textures
    files. I’ve already sourced some royalty-free textures we can use in our project.
    Download the `cgtrader_2048986_Damage.zip` file from this chapter’s GitHub repository
    at [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过纹理文件将一些详细的纹理导入到我们的环境中。我已经找到了一些可以用于我们项目的免费纹理。从本章的GitHub仓库[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets)下载`cgtrader_2048986_Damage.zip`文件。
- en: Free decal textures | cgtrader
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 免费贴图纹理 | cgtrader
- en: The decal textures we’re using in the project are from the *Decals Damage 48
    Texture* files (royalty-free license) at cgtrader, available at [https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture](https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目中使用的贴图纹理来自cgtrader的*Decals Damage 48 Texture*文件（免费许可），可在[https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture](https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture)找到。
- en: Unzip the file and import the images to a new `Assets/Textures/Decals` folder.
    While you’re creating folders, go ahead and create a new `Assets/Materials/Decals`
    folder too, since we’ll need that for creating decal materials in the next step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 解压文件并将图像导入到新的`Assets/Textures/Decals`文件夹中。在你创建文件夹的同时，也可以创建一个新的`Assets/Materials/Decals`文件夹，因为我们在下一步创建贴图材质时需要它。
- en: Creating decal materials
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建贴图材质
- en: The Decal feature is based on materials that are assigned to a `Shader` `Graphs/Decal`
    shader.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 贴图功能基于分配给`Shader` `Graphs/Decal`着色器的材质。
- en: 'Let’s create our first Decal material by following these steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建我们的第一个贴图材质：
- en: In the `Assets/Materials/Decals` folder in the **Project** window, create a
    new **Material** (by going to **Create** | **Material**).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中的`Assets/Materials/Decals`文件夹中，创建一个新的**材质**（通过**创建** | **材质**）。
- en: Name the new material with the same name as the damage texture we’ll be using;
    for this first example, we’ll use `DecalsDamage0032_1_S`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新材质命名为我们将使用的损坏纹理相同的名称；在这个第一个例子中，我们将使用`DecalsDamage0032_1_S`。
- en: With the new material selected, in the `Shader Graphs/Decal` shader from the
    **Shader** drop-down list at the top.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的**着色器**下拉列表中选择**Shader Graphs/Decal**着色器，并选择新材质。
- en: From the `Assets/Textures/Decals` folder, drag the `DecalsDamage0032_1_S` image
    to the **Base** **Map** field.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Textures/Decals` 文件夹中，将 `DecalsDamage0032_1_S` 图像拖到 **Base** **Map**
    字段。
- en: Note that if we have a Normal Map image included with our damaged textures,
    then assign that to the **Normal Map** field (I suggest using normal maps for
    greater detail in your Decals; we just don’t, however, have one included in the
    provided textures).
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果我们包含了与损伤纹理一起的 Normal Map 图像，那么将其分配给 **Normal Map** 字段（我建议使用法线图来为你的贴图提供更多细节；然而，我们提供的纹理中并没有包含一个）。
- en: With that, our first damage Decal material is ready to go! We’re almost ready
    to start applying damage to our environment with the Decal projector component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的第一个损伤贴图材质就准备好了！我们几乎准备好开始使用贴图投影组件对我们的环境应用损伤了。
- en: Rendering Layers for Decals
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贴图的渲染层
- en: Decals are projectors! Due to the nature of a projection in the scene, some
    objects may pass between the projector and the target mesh(es) and get hit by
    the projection, producing an undesirable result. So, although we can take a more
    freeform approach to the art direction here – since we aren’t limited to where
    we can place Decals in the environment – we may still have to control how Decals
    are projected and protect some objects from receiving the decal texture. Fortunately,
    using **Rendering Layers**, we can limit what meshes the decal affects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 贴图是投影器！由于场景中投影的性质，一些对象可能会在投影器和目标网格之间穿过，并被投影击中，产生不理想的结果。所以，尽管我们可以在这里采取更自由的艺术指导方法
    – 因为我们不受限于在环境中放置贴图的位置 – 我们仍然可能需要控制贴图的投影并保护一些对象免受贴图纹理的影响。幸运的是，使用 **Rendering Layers**，我们可以限制贴图影响的网格。
- en: New to Unity 2022
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Unity 2022
- en: 'Rendering Layers | How to use Rendering Layers with Decals: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染层 | 如何使用渲染层与贴图：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals)。
- en: 'For example, we will want to have our Decals affect the walls but not the objects
    we’ve scattered throughout the environment from our painting with Polybrush! Let’s
    ensure we have Rendering Layers for Decals enabled now. So, let’s revisit the
    **URP-HighFidelity-Renderer** asset (refer to *Figure 11**.11*) and enable **Use
    Rendering Layers** (it’s turned off by default):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望我们的贴图影响墙壁，但不影响我们从 Polybrush 绘画中散布在环境中的对象！让我们确保我们现在启用了贴图的渲染层。所以，让我们重新访问
    **URP-HighFidelity-Renderer** 资产（参见图 11.11*）并启用 **Use Rendering Layers**（默认情况下是关闭的）：
- en: '![Figure 11.12 – Use Rendering Layers enabled](img/B18347_11_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 启用 Use Rendering Layers](img/B18347_11_12.jpg)'
- en: Figure 11.12 – Use Rendering Layers enabled
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 启用 Use Rendering Layers
- en: 'The next requirement for a functional Decals **Rendering Layers** setup is
    to ensure a layer is specified for our Decals case. We can do that by editing
    the **Rendering Layers (3D)** list of layers:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个功能性的贴图 **Rendering Layers** 设置的下一个要求是确保为我们的贴图案例指定了一个层。我们可以通过编辑 **Rendering
    Layers (3D)** 层列表来完成：
- en: Select the `Assets/` folder.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Assets/` 文件夹。
- en: 'As shown in *Figure 11**.13*, we’ll create our Decal layer by renaming the
    `Receive Decals`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如 *图 11.13* 所示，我们将通过重命名 `Receive Decals` 来创建我们的贴图层：
- en: '![Figure 11.13 – Decal Rendering Layers](img/B18347_11_13.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 贴图渲染层](img/B18347_11_13.jpg)'
- en: Figure 11.13 – Decal Rendering Layers
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 贴图渲染层
- en: Now that we have an assignable layer, we’ll go back and modify all of the Prefabs
    we want to be able to receive decal projections on – ensuring that only objects
    that have the *Receive Decals* layer selected will show our damage textures. Working
    with the setup is straightforward – that is, once you wrap your head around the
    layers being the glue that binds all the parts together.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可分配的层，我们将返回并修改所有我们希望能够接收贴图投影的预制件 – 确保只有选择了 *Receive Decals* 层的对象才会显示我们的损伤纹理。与这个设置一起工作很简单
    – 也就是说，一旦你明白了层是粘合所有部件在一起的东西。
- en: 'As shown in *Figure 11**.14*, we’ll modify the `Wall_02 Variant` Prefab (in
    `Assets/Polypix 3D Assets/Modular Kit/Prefabs` folder so that it includes the
    *Receive Decals* layer in the `Mesh` `Renderer` component:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11.14* 所示，我们将修改 `Wall_02 Variant` 预制件（位于 `Assets/Polypix 3D Assets/Modular
    Kit/Prefabs` 文件夹中），使其包含 `Mesh` `Renderer` 组件中的 *Receive Decals* 层：
- en: '![Figure 11.14 – Assigning a decal rendering layer to Prefabs](img/B18347_11_14.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 将贴图渲染层分配给预制体](img/B18347_11_14.jpg)'
- en: Figure 11.14 – Assigning a decal rendering layer to Prefabs
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 将贴图渲染层分配给预制体
- en: You’ll want to update all the Prefabs you intend to project Decals onto with
    the *Receive Decals* layer. If your Decals aren’t showing where you believe they
    should be, you’ll want to double-check the layer assignments (and, of course,
    that Decals are enabled in the renderer settings).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将所有打算投射贴图的预制体更新为带有 *接收贴图* 层。如果您的贴图没有显示在您认为应该出现的位置，您需要检查层分配（当然，还要确保在渲染器设置中启用了贴图）。
- en: Now, we can create our first **Decal Projector** in the scene and start fleshing
    out the environment’s story. Yay!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在场景中创建第一个 **贴图投射器** 并开始充实环境的故事。耶！
- en: Using the Decal Projector component
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用贴图投射器组件
- en: 'To add a Decal, you can either create a new `Decal Projector` GameObject or
    add a `Decal Projector` component to an existing object in the scene. Since we
    don’t have any objects in the scene that are appropriate for adding a `Decal Projector`
    component, we’ll create a new one: in the **Hierarchy** window, go to **Create**
    | **Rendering** | **URP** **Decal Projector**.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加贴图，您可以选择创建一个新的 `Decal Projector` 游戏对象，或者将 `Decal Projector` 组件添加到场景中现有的对象上。由于场景中没有适合添加
    `Decal Projector` 组件的对象，我们将创建一个新的：在 **层次** 窗口中，转到 **创建** | **渲染** | **URP 贴图投射器**。
- en: 'As shown in *Figure 11**.15*, we must assign the Decal material we previously
    made for the `DecalsDamage0032_1_S` texture to the **Material** field and select
    the *Receive Decals* layer in the **Rendering** **Layers** field:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11*.15 所示，我们必须将之前为 `DecalsDamage0032_1_S` 纹理制作的贴图材料分配到 **材质** 字段，并在 **渲染**
    **层** 字段中选择 *接收贴图* 层：
- en: '![Figure 11.15 – Decal projected onto the wall Prefab](img/B18347_11_15.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 贴图投射到墙面预制体上](img/B18347_11_15.jpg)'
- en: Figure 11.15 – Decal projected onto the wall Prefab
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 贴图投射到墙面预制体上
- en: As shown in *Figure 11**.15*, I’ve positioned and rotated the **Decal Projector**
    *cube gizmo* (which shows its bounds) using the **Transform** tool. The base of
    the gizmo has a thicker line, and the projection direction is indicated by the
    white arrow emanating from the pivot point anchor (on the Z-axis).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11*.15 所示，我已使用 **变换** 工具定位和旋转了 **贴图投射器** *立方体辅助工具*（它显示了其边界）。辅助工具的底部有一条较粗的线，投影方向由从旋转中心锚点（在
    Z 轴上）发出的白色箭头指示。
- en: You can get away with using the **Transform** tool for the initial positioning
    and rotation of the projection. Still, you’ll likely want to use the **Scene**
    view editing tools to fine-tune the decal further – this requires further exploration
    and experimentation on your part, so I recommend additional reading.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **变换** 工具进行投影的初始定位和旋转。不过，您可能还想使用 **场景** 视图编辑工具进一步微调贴图 – 这需要您进行进一步的探索和实验，因此我建议阅读更多相关内容。
- en: Additional reading | Unity documentation
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多 | Unity 文档
- en: 'Decal Projector component: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 贴图投射器组件：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component)。
- en: Continue to decorate – ah – design the level environment further and add *surface
    story* details to sell your environment to the player by utilizing the varying
    damage textures we have at our disposal. Again, playtesting and feedback are essential
    here to help guide the art direction.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 继续装饰 – 哎 – 进一步设计关卡环境，并添加 *表面故事* 细节，通过利用我们可用的不同损伤纹理来向玩家推销您的环境。再次强调，测试和反馈在这里至关重要，有助于指导艺术方向。
- en: As you start projecting textures everywhere, you may be thinking, what is this
    doing to my game’s performance?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始将纹理投射到各个地方时，您可能会想，这对我的游戏性能有什么影响？
- en: Decal performance
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贴图性能
- en: Well, Unity has got us covered for performance optimization too. If we ensure
    that the Decals in the scene with the same damage texture use the same *Material*,
    and if we turn on **Enable GPU Instancing** for the *Material*, Unity will use
    a technique called **instancing** to make rendering more efficient. Instancing
    on the GPU can minimize the work Unity has to do by reducing the number of draw
    calls (which is like drawing all the Decals at once instead of each decal individually).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Unity 也为我们提供了性能优化的解决方案。如果我们确保场景中具有相同损伤纹理的贴图使用相同的 *材质*，并且如果我们将 *材质* 的 **启用
    GPU 实例化** 功能打开，Unity 将使用一种称为 **实例化** 的技术来提高渲染效率。在 GPU 上实例化可以减少绘制调用次数（这就像一次性绘制所有贴图，而不是单独绘制每个贴图）。
- en: Furthermore, to reduce the different number of materials we need for Decals
    (because, again, each *Material* is grouped to draw at once), we can put many
    damage texture images into one larger image (that is, a texture atlas). Then,
    the **Decal Projector** component allows us to use **UV offset** properties to
    select which part of the texture atlas we want to show – our selected individual
    texture image. This way, we can manage all the decal images more efficiently and
    keep our games running smoothly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了减少我们为贴图所需的材质数量（因为，同样，每个 *材质* 都被分组一次性绘制），我们可以将许多损伤纹理图像放入一个更大的图像中（即，纹理图集）。然后，**贴图投影器**组件允许我们使用
    **UV 偏移**属性来选择我们想要显示的纹理图集的哪个部分 – 我们选择的单个纹理图像。这样，我们可以更有效地管理所有贴图图像，并保持游戏运行顺畅。
- en: Additional reading | Unity documentation
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Decal Renderer Feature | Performance: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'Decal 渲染器功能 | 性能: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance).'
- en: In this section, we learned how to polish our 3D environment by replacing graybox
    Prefabs with finished art assets using Unity’s new Prefab workflow and manually
    updating Prefabs with new graphics while maintaining their existing behavior in
    Prefab Mode. We continued by polishing the environment design by painting scattered
    objects with Polybrush and immersing the player in *surface story* by adding Decal
    textures.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过使用 Unity 的新 Prefab 工作流程用完成的艺术资产替换灰盒 Prefab，并在 Prefab 模式下手动更新 Prefab
    以使用新的图形，同时保持 Prefab 中现有的行为。然后，我们继续通过使用 Polybrush 绘制散布的对象来润色环境设计，并通过添加贴图纹理来让玩家沉浸在
    *表面故事* 中。
- en: In the next section, we’ll continue to add polish to the habitat’s interior
    environment with lighting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续通过灯光来提升栖息地的内部环境。
- en: Lighting design – Probes, Decals, light baking, and performance
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光设计 – 探测器、贴图、光照烘焙和性能
- en: Let me immediately set some expectations for this section – we won’t spend much
    time on lighting design. It’s a subject worthy of an entire book all on its own.
    So, what we will be covering are some basics any game developer should be familiar
    with when working with lighting 3D scenes in Unity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我立即为这一节设定一些预期 – 我们不会在灯光设计上花费太多时间。这是一个值得单独出一本书的主题。因此，我们将涵盖一些任何游戏开发者都应该熟悉的基本知识，当他们在
    Unity 中处理 3D 场景的灯光时。
- en: The first thing I would like to address is that Unity has released a new rendering
    path for **Universal RP** (**URP**) with the 2022.3 LTS version called **Forward+
    Rending**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先想说的是，Unity 已经在 2022.3 LTS 版本中为 **通用渲染管线**（**URP**）（**URP**）发布了一条新的渲染路径，称为
    **Forward+ 渲染**。
- en: Additional reading | Unity documentation
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Forward+ Rendering Path: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'Forward+ 渲染路径: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml).'
- en: The **Forward+ Rendering Path** (Forward+) gives several advantages over the
    previous **Forward Rendering Path** (Forward), but it primarily overcomes the
    per-object limit on the number of lights that can affect GameObjects in the scene
    (note that the per-camera limitation does still apply). Let’s see how we can update
    our project URP settings to use **Forward+**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Forward+ 渲染路径**（Forward+）相对于之前的**Forward 渲染路径**（Forward）有几个优势，但它主要克服了场景中影响GameObject的灯光数量的对象限制（注意，每台相机的限制仍然适用）。让我们看看我们如何更新我们的项目URP设置以使用**Forward+**。'
- en: Setting the URP Forward+ Rendering Path
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置URP Forward+ 渲染路径
- en: 'Now, let’s change our URP **Rendering Path** setting to use the **Forward+
    Rendering Path**. We can do that in the **Universal RP settings** area (the same
    asset we added to the **Decal** feature in *Figure 11**.11*):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的URP**渲染路径**设置更改为使用**Forward+ 渲染路径**。我们可以在**Universal RP设置**区域（我们在*图11.11*中添加到**Decal**功能的同一资产）中这样做：
- en: In the `Assets/Settings` folder, select the **URP-HighFidelity-Renderer** asset.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Settings`文件夹中，选择**URP-HighFidelity-Renderer**资产。
- en: 'Under the **Rendering** section, select **Forward+** in the **Rendering** **Path**
    dropdown:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**渲染**部分，在**渲染路径**下拉菜单中选择**Forward+**。
- en: '![Figure 11.16 – Setting the Forward+ Rendering Path](img/B18347_11_16.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图11.16 – 设置Forward+ 渲染路径](img/B18347_11_16.jpg)'
- en: Figure 11.16 – Setting the Forward+ Rendering Path
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 设置Forward+ 渲染路径
- en: As with most decisions about the tech stack that you’ll be making for your Unity
    projects, you’ll have to experiment and test to see what fits best for the project’s
    direction or target platform (mobile, we’re looking at you), and the renderer
    pipeline choice is no exception. It’s pretty important. So, we will be changing
    this project to the **Forward+ Rendering Path** now. Just know that we may end
    up reverting this decision in the future should we need to change our lighting
    approach (for example, from real time to baked lighting; more on this in the *Bake
    that* *lighting?* section).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你将为你的Unity项目做出的大多数关于技术栈的决定一样，你将不得不进行实验和测试，以查看什么最适合项目的方向或目标平台（我们正在关注移动平台），渲染管线选择也不例外。这非常重要。因此，我们现在将把这个项目改为**Forward+
    渲染路径**。只需知道，如果我们需要改变我们的照明方法（例如，从实时照明到烘焙照明；更多内容请参阅*烘焙那些*照明？部分），我们可能会在未来撤销这个决定。
- en: The consensus with performance – concerning **Forward+** over **Forward** –
    is that gains are realized with greater than six real-time lights due to the overhead
    **Forward+** introduces when clustering lights (**Forward+** gathers light data
    into clusters computed in the fragment shader rather than individual light data).
    That’s excellent news for lighting designers because **Forward+ Rendering** gives
    us precisely what we may need – more real-time lights in a scene!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于性能方面的共识——涉及**Forward+**与**Forward**的比较——是，由于**Forward+**在聚类光线时引入的额外开销（**Forward+**将光线数据聚集成在片段着色器中计算的簇，而不是单独的光线数据），当光线数量超过六个时，可以实现增益。这对灯光设计师来说是个好消息，因为**Forward+
    渲染**正好提供了我们可能需要的——场景中更多的实时光线！
- en: Speaking of lights, we can get away with adding lighting effects to our scenes,
    and not touch a single light – this is accomplished with proxy lighting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 说到灯光，我们可以通过添加照明效果到我们的场景中，而不需要触摸任何灯光——这是通过代理照明实现的。
- en: Proxy lighting with Decals (yes, Decals)
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用贴图的代理照明（是的，贴图）
- en: Decals here refer to *lighting decals* (that is, proxy lighting) and not *texture
    decals*, which we’re already familiar with. To accomplish this effect, **Decal
    Projector** uses a special shader to modify the emissive color of affected surfaces
    without any real-time lights being involved.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，贴图指的是**照明贴图**（即代理照明），而不是我们已熟悉的**纹理贴图**。为了实现这种效果，**Decal Projector**使用一种特殊的着色器来修改受影响表面的发射颜色，而不涉及任何实时光线。
- en: The *Material* we’ll be using for the proxy lighting **Decal Projector** in
    our scene is based on a **Shader Graph** shader, **Spotlight**, that comes from
    the **Universal** **RP** samples.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在场景中的代理灯光**Decal Projector**中使用的**Material**是基于来自**Universal** **RP**样本的**Shader
    Graph**着色器、**Spotlight**。
- en: Additional reading | Unity Blog
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity博客
- en: 'You can explore the latest package samples for the Universal Render Pipeline
    here: [https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline](https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里探索Universal Render Pipeline的最新包样本：[https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline](https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline)。
- en: These are not just for **Universal RP**! You should always check the Unity package
    content to see what samples are provided as examples that supplement the Unity
    documentation for learning the feature and can give a jump start on implementation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不仅适用于**Universal RP**！你应该始终检查Unity包内容，以查看提供了哪些示例，这些示例可以作为补充Unity文档的学习资料，并可以在实现功能时提供快速入门。
- en: 'To import the **Universal RP** samples, follow these steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入**Universal RP**示例，请按照以下步骤操作：
- en: Open **Package Manager** by going to **Window** | **Package Manager**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**窗口** | **包管理器**来打开**包管理器**。
- en: Ensure you have **In Project** selected in the **Packages** dropdown.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**包**下拉菜单中选择了**项目内**。
- en: Find and select **Universal RP** from the list (left-hand side).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表（左侧）中找到并选择**Universal RP**。
- en: On the right-hand side of the window, click the **Samples** tab.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的右侧，点击**示例**选项卡。
- en: For `Assets/Samples/Universal RP/14.x.x/URP Package` `Samples` folder.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Assets/Samples/Universal RP/14.x.x/URP Package` `Samples`文件夹。
- en: 'Once the samples have been imported, find and open the `/URP Package` `Samples/Decals/ProxyLighting`
    folder:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 样本导入完成后，找到并打开`/URP Package` `Samples/Decals/ProxyLighting`文件夹：
- en: '![Figure 11.17 – Unity Universal RP ProxyLighting sample](img/B18347_11_17.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – Unity Universal RP ProxyLighting示例](img/B18347_11_17.jpg)'
- en: Figure 11.17 – Unity Universal RP ProxyLighting sample
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – Unity Universal RP ProxyLighting示例
- en: Now, go ahead and find the `Assets/Prefabs` folder. Name it `Decal Spotlight`
    so that we can use it as a *lighting Decal spotlight* in our habitat interior
    scene. It’s already pre-configured with the **Spotlight** material (and the default
    **Rendering Layer** so that it will affect any object in the scene), so we’re
    all set!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往`Assets/Prefabs`文件夹。将其命名为`Decal Spotlight`，这样我们就可以在我们的栖息地内部场景中使用它作为*照明贴图聚光灯*。它已经预先配置了**聚光灯**材质（以及默认的**渲染层**，以便它会影响场景中的任何对象），所以我们已经准备好了！
- en: Now, go back to our interior habitat scene and place a **Decal Spotlight** material
    into a wall overhang (as pictured in *Figure 11**.18*), adjust the **Decal Projector**
    component’s **Opacity** setting (refer to *Figure 11**.17*) to a lovely lighting
    value, then duplicate it several times (three times in this example; four in total).
    Don’t worry that they’re all sitting on top of each other at the moment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的内部栖息地场景，将一个**Decal Spotlight**材质放置在墙的悬挑处（如图*图11.18*所示），调整**贴图投影器**组件的**不透明度**设置（参见图11.17），到一个漂亮的照明值，然后复制几次（本例中为三次；总共四次）。不用担心它们目前都堆叠在一起。
- en: We could manually place the spotlights further along the wall, or, to make things
    easier on ourselves, we can use a bit of math in the `cos(a)` and `sin(a)` too!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将聚光灯手动放置在墙的更远处，或者，为了使事情变得更容易，我们也可以在`cos(a)`和`sin(a)`中使用一点数学知识！
- en: Additional reading | Unity documentation
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'Editing Properties | Numeric field expressions: [https://docs.unity3d.com/Manual/EditingValueProperties.xhtml](https://docs.unity3d.com/Manual/EditingValueProperties.xhtml).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑属性 | 数字字段表达式：[https://docs.unity3d.com/Manual/EditingValueProperties.xhtml](https://docs.unity3d.com/Manual/EditingValueProperties.xhtml)。
- en: Select all the spotlights we just added to the `L(-5.4,-17.3)` in the `L(a,b)`
    is a linear ramp expression where the selected objects are distributed between
    the values.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 选择我们刚刚添加到`L(-5.4,-17.3)`的所有聚光灯，在`L(a,b)`是一个线性渐变表达式，其中选定的对象分布在这些值之间。
- en: While you have the expression in the field, you can play around with the values
    until you have the spotlights positioned where you want (your values may differ
    from mine based on your wall position and so on).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在字段中有表达式时，你可以调整值，直到聚光灯放置到你想要的位置（你的值可能因你的墙位置等因素而与我的不同）。
- en: 'You should end up with something like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终应该得到类似这样的结果：
- en: '![Figure 11.18 – Decal spotlights array on the wall](img/B18347_11_18.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – 墙上的贴图聚光灯阵列](img/B18347_11_18.jpg)'
- en: Figure 11.18 – Decal spotlights array on the wall
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – 墙上的贴图聚光灯阵列
- en: Pretty cool, right? And remember, no real-time lights are involved! We can save
    on lighting resources while still enjoying additional lighting effects in our
    environment design. Just note that **Decal Material** performance considerations
    are still applicable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很酷，对吧？而且记住，这里没有涉及实时灯光！我们可以在享受环境设计中额外的照明效果的同时节省照明资源。只需注意，**贴图材质**的性能考虑仍然适用。
- en: Speaking of performance, we have another approach to lighting that we can consider
    besides the use of real-time lighting, and that’s baked lighting.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 说到性能，我们除了使用实时照明之外，还可以考虑另一种照明方法，那就是烘焙照明。
- en: Bake that lighting?
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要烘焙这些照明吗？
- en: 350° F (175° C) for 45 minutes… sure!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 350°F（175°C）持续45分钟……当然可以！
- en: 'Using baked lighting in Unity can have several benefits over real-time lighting
    in your game, but deciding to use one or the other depends greatly on the target
    platform and the target framerate you’ve determined the game needs to hit on specific
    hardware specs (you may have already been introduced to this type of information
    related to games you’d like to play on your PC or mobile device – system requirements:
    minimum and recommended).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中使用烘焙光照与实时光照相比，在游戏中可能会有几个好处，但决定使用哪一个很大程度上取决于目标平台和您为特定硬件规格确定的游戏需要达到的目标帧率（您可能已经接触过有关您想在PC或移动设备上玩的游戏的相关信息——系统需求：最低和推荐配置）。
- en: 'Let’s look at the three main benefits of baked lighting:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看烘焙光照的三个主要好处：
- en: '**Performance**: Baking the lighting means all of the light interactions in
    the scene regarding objects’ surfaces are computed ahead of time (in the editor)
    and saved into lightmap textures files. During runtime, the lightmaps are used
    to determine the light that’s received by the objects’ surfaces in the scene,
    which is much faster than real-time calculations.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：烘焙光照意味着场景中关于物体表面的所有光照交互都是预先（在编辑器中）计算并保存到光照图纹理文件中的。在运行时，使用光照图来确定场景中物体表面接收到的光照，这比实时计算要快得多。'
- en: '**Quality**: Baked lighting usually produces better lighting fidelity, especially
    when it comes to indirect bounced light, soft shadows, and more complex light
    diffusion effects.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：烘焙光照通常能产生更好的光照保真度，尤其是在处理间接反弹光、柔和阴影以及更复杂的光扩散效果时。'
- en: '**Lighting complexity**: Baked lighting can handle higher levels of lighting
    complexity with lots of lights and complex shadow interactions (just be prepared
    for longer bake times!).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照复杂性**：烘焙光照可以处理具有大量灯光和复杂阴影交互的高级别光照复杂性（只是要做好更长时间烘焙的准备！）。'
- en: 'Now, let’s consider some disadvantages of baked lighting:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一下烘焙光照的一些缺点：
- en: '**Lightmaps**: The size of the generated lightmap texture files can be of concern
    for both memory usage at runtime and the size of the game on disk (that is, mobile
    and lower-end platforms). Optimizing lightmaps is generally a balancing act between
    performance and quality (which, of course, takes time; see *Long* *iteration time*).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照图**：生成的光照图纹理文件的大小可能会对运行时的内存使用和游戏在磁盘上的大小（即移动和低端平台）造成关注。优化光照图通常是在性能和质量之间进行权衡（当然，这需要时间；参见*长迭代时间*）。'
- en: '**Static**: The baked lightmaps only work for objects that don’t move in the
    scene (that is, static objects; they are assigned as such in the **Inspector**
    area). Dynamic lights and moving objects are more suitable for real-time lighting.
    Unity does, however, provide a solution for dynamic objects with baked lighting
    via **Light Probes**, but they come with their own limitations (such as area lights
    and volumetric lighting not being supported, not working well with some materials,
    and no real-time reflections), so often, a combination of techniques applied with
    real-time direct lighting and shadow casting is necessary to obtain the desired
    results.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**：烘焙光照图仅适用于场景中不移动的物体（即静态物体；它们在**检查器**区域被指定为静态）。动态光照和移动物体更适合实时光照。然而，Unity确实通过**光照探针**为具有烘焙光照的动态物体提供了解决方案，但它们也有自己的限制（例如不支持区域光照和体积光照，与某些材质配合不佳，且没有实时反射），因此，通常需要结合实时直接光照和阴影投射的技术来获得期望的结果。'
- en: '**Additional work**: Additional work must be done in the form of setting objects
    as static, setting up **Light Probes** for dynamic objects in the scene, a solution
    for basic shadow needs, and balancing the generated lightmap quality, for starters.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外工作**：必须进行额外的工作，例如将物体设置为静态，为场景中的动态物体设置**光照探针**，解决基本的阴影需求，以及平衡生成的光照图质量，仅举几例。'
- en: '**Long iteration time**: The process of baking lightmaps can be resource-intensive
    and, therefore, time-consuming on lower-end development system CPU/GPU hardware,
    which can cause a significant slowdown in the environment design iteration process.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长迭代时间**：烘焙光照图的过程可能非常消耗资源，因此在低端开发系统CPU/GPU硬件上可能耗时较长，这可能导致环境设计迭代过程显著减慢。'
- en: There’s no doubt that lighting an environment with real-time lighting is more
    accessible. Still, you may not have a choice if you’re going to target mobile
    or lower-end hardware specs (for example, the Nintendo Switch). Baked lighting
    is generally more performant across devices and platforms compared to real-time
    lighting.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，使用实时光照对环境进行光照更加容易上手。然而，如果你要针对移动或低端硬件规格（例如，任天堂Switch）进行目标定位，你可能没有选择。与实时光照相比，烘焙光照通常在设备和平台上的性能更佳。
- en: Our approach so far has been to use the default lighting setup with the **Directional
    Light** property provided by the **Standard (URP) Scene Template** and create
    additional lights in the scene – which are *Realtime* by default. Now, we must
    change our approach because we will target a lower-end platform but still want
    to target 60 FPS. So, we’re going to need baked lighting.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的方法一直是使用默认的光照设置，利用 **标准（URP）场景模板** 提供的 **方向光** 属性，并在场景中创建额外的灯光——这些灯光默认为
    **实时**。现在，我们必须改变我们的方法，因为我们将针对低端平台，但仍然希望达到60 FPS。因此，我们需要烘焙光照。
- en: Setting up baked lighting
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置烘焙光照
- en: To set up our baked lighting, let’s duplicate our current habitat interior scene
    with real-time lighting so that we can non-destructively experiment with converting
    it into baked lighting.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的烘焙光照，让我们复制当前的实时光照栖息地内部场景，这样我们就可以无损地实验将其转换为烘焙光照。
- en: 'Select your `Assets/Scenes` folder in the **Project** window, press *Ctrl*/*Cmd*
    + *D* to duplicate, and rename it with a (*baked*) suffix. Let’s open the duplicate
    scene and start the setup:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **项目** 窗口中选择你的 `Assets/Scenes` 文件夹，按 *Ctrl*/*Cmd* + *D* 进行复制，并使用 (*baked*)
    后缀重命名。让我们打开复制的场景并开始设置：
- en: Select `Light` component’s **General** section, select **Baked** in the **Mode**
    field dropdown instead of **Realtime**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Light** 组件的 **通用** 部分中，在 **模式** 字段下拉菜单中选择 **烘焙** 而不是 **实时**。
- en: Please do the same for any additional lights you may have added to the scene
    that we want Unity to include in the baking. Note that we won’t have to change
    the **Decal** spotlights we added in the *Proxy lighting with Decals (yes, Decals)*
    section – remember, these are not lights!
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于场景中可能添加的任何其他灯光，请执行相同的操作，以便Unity在烘焙时包含它们。请注意，我们不需要更改在 *使用贴图的代理光照（是的，贴图）* 部分中添加的
    **Decal** 聚光灯——记住，这些不是灯光！
- en: 'We need to let Unity know what objects won’t move so that their lighting can
    be baked. So, for all of the modular Prefabs that make up the walls, the floors,
    the doorway, and scattered Prefab objects in the scene, select them in the **Hierarchy**
    area. Then, in the **Inspector** area, enable **Static** (the top right of the
    window):'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要让Unity知道哪些对象不会移动，以便它们的照明可以烘焙。因此，对于构成墙壁、地板、门道以及场景中散布的Prefab对象的模块化Prefab，在
    **层次** 区域中选择它们。然后在 **检查器** 区域中，启用 **静态**（窗口右上角）：
- en: '![Figure 11.19 – Marking a GameObject as static](img/B18347_11_19.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图11.19 – 将GameObject标记为静态](img/B18347_11_19.jpg)'
- en: Figure 11.19 – Marking a GameObject as static
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 – 将GameObject标记为静态
- en: When you’re asked whether you want to mark the child objects as static too,
    click the **Yes, change** **children** button.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当询问你是否想将子对象也标记为静态时，点击 **是，更改** **子对象** 按钮。
- en: Now that the objects in the scene have been set up, we will configure **Lightmapping
    Settings** just before baking.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景中的对象已经设置好了，我们将在烘焙之前配置 **光照贴图设置**。
- en: Lighting settings
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光照设置
- en: '**Lightmapping Settings** configure the light baking calculation and how it
    applies to the scene. We need to use the **Lighting** window to create a new **Lighting
    Settings Asset** to store our configuration. Unity will use default read-only
    light settings to bake the scene lighting until we create an asset.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**光照贴图设置** 配置光照烘焙计算及其如何应用于场景。我们需要使用 **光照** 窗口创建一个新的 **光照设置资产** 来存储我们的配置。Unity将使用默认的只读光照设置来烘焙场景光照，直到我们创建资产。'
- en: Additional reading | Unity documentation
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'The Lighting window: [https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 光照窗口：[https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml)。
- en: 'To create a new **Lighting Settings Asset**, follow these steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 **光照设置资产**，请按照以下步骤操作：
- en: Open the **Lighting** window by going to **Window** | **Rendering** | **Lighting**.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **窗口** | **渲染** | **光照** 打开 **光照** 窗口。
- en: 'At the top of the **Lighting** window, under the **Lighting Settings** section,
    click the **New** button to the right of the **Lighting Settings Asset** field
    to create a new **Lighting Settings Asset** in the **Project** window; it will
    be assigned immediately:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**灯光**窗口的顶部，在**灯光设置**部分下，点击**灯光设置资产**字段右侧的**新建**按钮，在**项目**窗口中创建一个新的**灯光设置资产**；它将被立即分配：
- en: '![Figure 11.20 – New Lighting Settings Asset](img/B18347_11_20.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图11.20 – 新的灯光设置资产](img/B18347_11_20.jpg)'
- en: Figure 11.20 – New Lighting Settings Asset
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 – 新的灯光设置资产
- en: Name the asset the same as the scene name so that it’s easy to keep track of
    – for reference, in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187), we created
    a new scene named `Habitat Interior 1`; but use the current scene name you’re
    using here.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资产命名为与场景名称相同，以便于跟踪 – 以供参考，在[*第10章*](B18347_10.xhtml#_idTextAnchor187)中，我们创建了一个名为`Habitat
    Interior 1`的新场景；但请使用此处正在使用的当前场景名称。
- en: Additional reading | Unity documentation
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity文档
- en: 'Lighting Settings Asset: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光设置资产：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml).
- en: We’ll work in the **Scene** tab to optimize our settings for the desired balance
    of quality, lightmap texture size, and bake time. Using the default values is
    a good starting baseline for your baking.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在**场景**选项卡中工作，以优化我们的设置，以实现所需的质量、光照贴图纹理大小和烤制时间的平衡。使用默认值是烤制的基础良好起点。
- en: Okay, click that **Bake** button! Sadly, no. The actual button to click for
    baking the lighting is the **Generate Lighting** button, located at the bottom
    of the **Lighting** window. When started, the lighting process will display a
    progress indicator at the bottom right of the **Editor** window with an estimated
    time for completion.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，点击那个**烤制**按钮！遗憾的是，不是的。实际用于烤制灯光的按钮是位于**灯光**窗口底部的**生成灯光**按钮。当开始时，灯光过程将在**编辑器**窗口的右下角显示进度指示器，并显示完成估计时间。
- en: After some time – depending on the power of your system hardware – the generated
    lighting process will finish, and the **Scene** view will update with the new
    baked lighting. Inspect the result of the baked lighting in your scene, and, if
    it’s not to your satisfaction, adjust **Lightmapping Settings** and/or both the
    settings and position or rotation of light sources in the scene and bake again;
    repeat as needed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间（取决于您的系统硬件性能）后，生成的灯光过程将完成，**场景**视图将更新为新的烤制灯光。检查场景中烤制灯光的结果，如果它不符合您的期望，请调整**光照贴图设置**和/或场景中灯光的设置、位置或旋转，然后再次烤制；根据需要重复此操作。
- en: 'Let’s have a gander at the results of our labor by comparing screenshots of
    the same view with baked and real-time lighting:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过比较相同视图的截图来查看我们劳动的结果，这些截图显示了烤制和实时灯光：
- en: '![Figure 11.21 – Baked versus Realtime renders](img/B18347_11_21.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图11.21 – 烤制与实时渲染对比](img/B18347_11_21.jpg)'
- en: Figure 11.21 – Baked versus Realtime renders
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 – 烤制与实时渲染对比
- en: Tip
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You’ll also want to compare the results of the baked lighting to the real-time
    lighting. Analyze the quality of the light, the lighting features, memory usage,
    and, most importantly, the FPS the game is running at compared to your target
    framerate on the desired platform(s).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您还希望将烤制灯光的结果与实时灯光进行比较。分析灯光的质量、灯光功能、内存使用情况，以及最重要的是，与目标平台上的期望帧率相比，游戏运行的FPS。
- en: You can get some performance gauge while running in **Play** mode in **Unity
    Editor**, but you’ll want to build and test on the target device(s) for the best
    results. Graphy – Ultimate Stats Monitor & Debugger ([https://github.com/Tayx94/graphy](https://github.com/Tayx94/graphy))
    is a free tool that is greatly helpful in analyzing your game’s performance. Output
    from Graphy can be seen in the game screenshots in the top-right corner in *Figure
    11**.21*, where the baked lighting shows a slight FPS benefit over real time (this
    is in the **Editor** window, so I expect greater gains in a build).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**Unity编辑器**的**播放**模式下运行时获取一些性能指标，但您将需要在目标设备上构建和测试以获得最佳结果。Graphy – Ultimate
    Stats Monitor & Debugger ([https://github.com/Tayx94/graphy](https://github.com/Tayx94/graphy))是一个非常有用的免费工具，可以帮助分析您游戏的表现。Graphy的输出可以在*图11*.21的右上角的屏幕截图中看到，其中烤制灯光在实时渲染上显示轻微的FPS提升（这是在**编辑器**窗口中，所以我预计在构建中会有更大的提升）。
- en: You may not be happy at all with how long the baked lighting generation took
    with the default **Lightmapper** setting set to **Progressive CPU**. Fortunately,
    if your hardware supports it, we can improve the calculation time using the GPU-based
    lightmapper.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对默认**光照贴图器**设置为**渐进式 CPU**时烘焙光照生成所需的时间并不满意。幸运的是，如果你的硬件支持，我们可以使用基于 GPU 的光照贴图器来提高计算时间。
- en: Tip
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you notice graphical artifacts appearing on models in your baked lighting,
    then imported model UVs for baked lightmaps may not be provided. In that case,
    you can tell Unity to generate them automatically to fix their appearance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到烘焙光照中的模型上出现了图形伪影，那么可能是因为导入的模型 UV 对于烘焙光照贴图没有提供。在这种情况下，你可以告诉 Unity 自动生成它们以修复其外观。
- en: To have Unity generate lightmap UVs, select the offending model in the **Project**
    window to view **Model Import Settings** in the **Inspector** area. Once you’ve
    done this, ensure the **Model** tab is selected, and then, in the **Geometry**
    section, *enable* the **Generate Lightmap** **UVs** option.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 Unity 生成光照贴图 UV，请在**项目**窗口中选择有问题的模型，以在**检查器**区域查看**模型导入设置**。完成此操作后，确保已选择**模型**选项卡，然后在**几何**部分，*启用***生成光照贴图
    UV**选项。
- en: 'Unity Documentation | Generating lightmap UVs: [https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml](https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 文档 | 生成光照贴图 UV：[https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml](https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml).
- en: Now, about that iteration time.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在谈谈那个迭代时间。
- en: Improving iteration time
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高迭代时间
- en: '**Lightmapping Settings** allows us to choose between the **Progressive CPU**
    and **Progressive GPU** lightmappers (the latter still being in preview for 2022.3.1f1).
    **Progressive GPU** may be much, much, quicker to generate lighting, but it all
    depends on what GPU (that is, what graphics card) you have installed in your system
    running Unity. In my example, **Progressive CPU** is estimated to take 3+ hours,
    whereas **Progressive GPU** (on modest GPU hardware) is estimated to take 40+
    minutes.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**光照贴图设置**允许我们选择**渐进式 CPU**和**渐进式 GPU**光照贴图器（后者仍在 2022.3.1f1 版本中处于预览状态）。**渐进式
    GPU**可能生成光照的速度要快得多，但这完全取决于你系统中运行 Unity 的 GPU（即显卡）。在我的例子中，**渐进式 CPU**估计需要 3 个多小时，而**渐进式
    GPU**（在中等 GPU 硬件上）估计需要 40 多分钟。'
- en: Additional reading | Unity documentation
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'The Progressive Lightmapper: [https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式光照贴图器：[https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml).
- en: Now that we’ve covered baked lighting for static objects in the scene (that
    is, objects we marked as *Static* because they don’t move), we just need to cover
    a bit about how dynamic or moving objects in the scene can be affected by light
    when there is no real-time lighting!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了场景中静态对象（即我们标记为 *Static* 的对象，因为它们不会移动）的烘焙光照，我们只需要简要说明一下，当没有实时光照时，场景中的动态或移动对象会受到怎样的光照影响！
- en: Light Probes
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光探针
- en: Again, Unity has us covered for dynamic object lighting. We can use **Light
    Probes** to apply our baked lighting to moving objects – as mentioned previously;
    however, this is additional work compared to real-time lighting (as indicated
    in the *Additional work* bullet point in the *Bake that lighting?* section). Note
    that light probes will not affect the objects we marked as **Static** – moving
    objects should never be marked **Static**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Unity 为动态对象光照提供了支持。我们可以使用**光探针**将烘焙光照应用到移动对象上——如前所述；然而，这与实时光照（如“烘焙光照？”部分中“额外工作”项目所示）相比是额外的工作。请注意，光探针不会影响我们标记为**Static**的对象——移动对象不应该被标记为**Static**。
- en: '**Light Probes** are placed throughout the environment, not only where the
    moving objects will be but also in areas where lighting changes (especially dramatic
    changes). The light probes we put in the scene will capture the light information
    when baking and then use that data to light the moving objects based on their
    relative position to the probes.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**光探针**被放置在整个环境中，不仅是在移动对象将会出现的地方，还包括光线变化（尤其是显著变化）的区域。我们在场景中放置的光探针将在烘焙时捕捉光线信息，然后根据物体相对于探针的相对位置使用这些数据来照亮移动对象。'
- en: Additional reading | Unity documentation
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Light Probes: [https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 光探针：[https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml)。
- en: Let’s place our first **Light Probe Group** in our scene by going to **Create**
    | **Light** | **Light Probe Group**. Then, using the **Transform** tool, move
    the new **Group** to the center of a room in the level. Light changes occur primarily
    along the walls in these rooms since the lighting is pretty uniform, so we’ll
    spread out the probes to cover a wider area.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中放置第一个 **光探针组**，方法是转到 **创建** | **光照** | **光探针组**。然后，使用 **变换** 工具，将新的 **组**
    移动到级别中房间中央。由于这些房间的照明相当均匀，光线变化主要沿着墙壁发生，因此我们将探针分散开来，以覆盖更广的区域。
- en: In *Figure 11**.22*, you can see that I first used the toggle pickability feature
    (*A* in *Figure 11**.22*) in the **Hierarchy** area to turn off the selection
    of the wall, floor, and ceiling so that we can work with the probes and not accidentally
    select anything else in the scene (that would be not very pleasant, after all).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11.22* 中，您可以看到我首先在 **层次** 区域使用了切换可拾取性功能（*图 11.22 中的 *A*），关闭了墙壁、地板和天花板的选中，这样我们就可以与探针一起工作，而不会意外选中场景中的其他任何东西（毕竟，这不会很愉快）。
- en: 'You can now enable **Light Probe Editing** (*B* in *Figure 11**.22*) and drag
    a selection window (*C* in *Figure 11**.22*) in the **Scene** view to select the
    probes on the right-hand side of the group. Use the **Duplicate Selected** button
    – or the tried-and-true *Ctrl*/*Cmd* + *D* shortcut – to duplicate the selected
    probes, then use the **transform move** tool to position the duplicated probes
    near the wall:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以启用 **光探针编辑**（*图 11.22 中的 *B*）并在 **场景** 视图中拖动一个选择窗口（*图 11.22 中的 *C*）来选择组右侧的探针。使用
    **复制所选** 按钮 – 或者经过验证的 *Ctrl*/*Cmd* + *D* 快捷键 – 来复制所选探针，然后使用 **变换移动** 工具将复制的探针定位在墙壁附近：
- en: '![Figure 11.22 – Editing Light Probes in the scene](img/B18347_11_22.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – 场景中编辑光探针](img/B18347_11_22.jpg)'
- en: Figure 11.22 – Editing Light Probes in the scene
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – 场景中编辑光探针
- en: Additional reading | Unity documentation
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Pick and select GameObjects: [https://docs.unity3d.com/Manual/ScenePicking.xhtml](https://docs.unity3d.com/Manual/ScenePicking.xhtml).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 选择和选择 GameObjects：[https://docs.unity3d.com/Manual/ScenePicking.xhtml](https://docs.unity3d.com/Manual/ScenePicking.xhtml)。
- en: 'Scene visibility: [https://docs.unity3d.com/Manual/SceneVisibility.xhtml](https://docs.unity3d.com/Manual/SceneVisibility.xhtml).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 场景可见性：[https://docs.unity3d.com/Manual/SceneVisibility.xhtml](https://docs.unity3d.com/Manual/SceneVisibility.xhtml)。
- en: 'Repeat the process of selecting, duplicating, and positioning probes until
    you have something similar to the probe group setup shown in *Figure 11**.23*:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 重复选择、复制和定位探针的过程，直到您拥有类似于 *图 11.23* 中显示的探针组设置：
- en: '![Figure 11.23 – Light Probes placement example](img/B18347_11_23.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.23 – 光探针放置示例](img/B18347_11_23.jpg)'
- en: Figure 11.23 – Light Probes placement example
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – 光探针放置示例
- en: Tip
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, in *Figure 11**.23*, as uniform as the probes grouping looks in this
    scene, you won’t always have it set up this way because you’ll want to position
    probes where the light changes (again, especially where the light changes dramatically)
    for the best results.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 *图 11.23* 中，尽管探针分组在这个场景中看起来很均匀，但您并不总是以这种方式设置，因为您希望将探针放置在光线变化的地方（再次强调，尤其是在光线发生剧烈变化的地方）以获得最佳效果。
- en: Once you have the **Light Probe Groups** set up in your level, you’ll have to
    bake (err, generate) the lighting again so that the probes have all the lighting
    information stored. The probe lighting data will then be used at runtime to light
    dynamic objects.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在您的级别中设置了 **光探针组**，您将不得不再次烘焙（嗯，生成）光照，以便探针存储所有光照信息。然后，探针光照数据将在运行时用于照亮动态对象。
- en: 'You can visualize the effect light probes have on dynamic objects by using
    the **Light Probe Visualization** setting in the **Lighting** window. When you
    have a dynamic object selected in the scene, the probes that influence the object
    will be shown when set to **Only Probes Used By Selection**, with the selected
    **Sphere** (temporarily added to the scene for the sole purpose of visualizing
    the Light Probes), as shown in *Figure 11**.24*:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 **光照** 窗口中使用 **光探针可视化** 设置来可视化光探针对动态对象的影响。当您在场景中选择一个动态对象时，当设置为 **仅选择使用的探针**
    时，将显示影响该对象的探针，与所选的 **球体**（临时添加到场景中，仅用于可视化光探针），如图 *图 11.24* 所示：
- en: '![Figure 11.24 – Light Probes visualization selection](img/B18347_11_24.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24 – 光探头可视化选择](img/B18347_11_24.jpg)'
- en: Figure 11.24 – Light Probes visualization selection
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – 光探头可视化选择
- en: Tip
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unity has another useful lighting tool called **Reflection Probes**. Their use
    can significantly enhance the visual fidelity of scenes by contributing to the
    quality of both baked and real-time lighting – that is, these probes work with
    both static and dynamic objects.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 还有一个有用的照明工具，称为**反射探头**。它们的使用可以通过贡献烘焙和实时照明的质量来显著提高场景的视觉保真度——也就是说，这些探头与静态和动态对象一起工作。
- en: As the name indicates, reflection probes add the effect of reflections of shiny
    things in the environment. I recommend exploring **Reflection Probes** further
    to enhance the quality of your game’s visuals!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，反射探头增加了环境中闪亮物体反射的效果。我建议进一步探索**反射探头**，以提升你游戏视觉质量！
- en: 'Unity documentation | Reflection Probes: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 文档 | 反射探头：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml)。
- en: There is one additional subject we need to cover regarding baked lighting, and
    that is shadows for dynamic objects. Baked shadows are a part of baked lighting
    for static objects – the shadows were baked into the lightmaps. Our lights in
    the scene were also set to *Baked*, so that doesn’t leave any means for providing
    shadows to our dynamic objects.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 关于烘焙照明，我们还需要讨论一个额外的主题，那就是动态对象的阴影。烘焙阴影是静态对象烘焙照明的一部分——阴影被烘焙到光照图中。场景中的灯光也被设置为**烘焙**，这样就没有提供阴影给我们的动态对象的方法了。
- en: We can achieve a semi-dynamic shadow effect for baked lighting in a few different
    ways. We’ll cover two in the following section.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种不同的方式实现烘焙光照的半动态阴影效果。我们将在下一节中介绍两种。
- en: Baked lighting dynamic shadows
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙光照动态阴影
- en: The first thing we can do for dynamic object shadows is use **Mixed** mode for
    lights. **Mixed** mode will bake shadows (just like the **Baked** mode setting)
    for static objects *and* compute real-time shadows for dynamic objects (just like
    the **Realtime** mode setting).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态对象阴影，我们可以做的第一件事是为灯光使用**混合**模式。**混合**模式将为静态对象烘焙阴影（就像**烘焙**模式设置一样），并为动态对象计算实时阴影（就像**实时**模式设置一样）。
- en: '**Light Probes** don’t solve this problem because they don’t represent any
    direct lighting and don’t produce shadows; they only influence the lighting applied
    to dynamic objects, so we’ll use them in combination with this mixed lighting
    mode technique.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**光探头**不能解决这个问题，因为它们不表示任何直接光照，也不产生阴影；它们只影响应用于动态对象的照明，因此我们将与这种混合照明模式技术结合使用。'
- en: So, to implement it, simply set **Directional Light** to **Mixed** mode and
    bake. Done.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要实现它，只需将**方向光**设置为**混合**模式并烘焙。完成。
- en: The second thing we can do is fake it (yes, fake it – often, the game developer
    must resort to creative techniques that produce the desired results visually or
    close to it, but in clever and creative ways behind the scenes). No worries –
    Unity still has us covered.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第二件事是伪造（是的，伪造——通常，游戏开发者必须求助于创造性的技术，以视觉上或接近视觉上产生期望的结果，但在幕后以巧妙和创造性的方式）。不用担心——Unity
    仍然为我们提供了支持。
- en: Blob shadows
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blob 阴影
- en: A shadow projector can be used as a more optimized way to represent a simple
    *blob* *shadow* on the ground under objects. This technique benefits performance-constrained
    platforms (for example, mobile games and low-end hardware) where real-time shadow
    casting can be too performance-heavy.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影投射器可以用作在物体下方表示简单 *blob* 阴影的更优化方式。这项技术对性能受限的平台（例如，移动游戏和低端硬件）有益，在这些平台上，实时阴影投射可能过于消耗性能。
- en: To use a blob shadow projector, we don’t need to look further than the `Assets/Samples/Universal
    RP/14.0.8/URP Package` `Samples/Decals/BlobShadow` folder.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 blob 阴影投射器，我们不需要查看 `Assets/Samples/Universal RP/14.0.8/URP Package` `Samples/Decals/BlobShadow`
    文件夹。
- en: With the scene open, find the **Capsule** object in the **Hierarchy** area.
    The **BlobShadow** child object contains the **URP Decal Projector** component
    (this should be familiar to you) with the provided **BlobShadow_Mat** material
    assigned.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景打开的情况下，在**层次**区域找到**胶囊**对象。**BlobShadow**子对象包含**URP Decal Projector**组件（这应该对你来说很熟悉），并分配了提供的**BlobShadow_Mat**材质。
- en: Create a Prefab of it and use it for dynamic objects in your scene that require
    dynamic shadows in a baked lighting setup. It couldn’t be easier!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Prefab并将其用于场景中需要动态阴影的动态对象。这 couldn’t be easier!（这真是太简单了！）
- en: In this section, we learned how to light an interior environment scene with
    both real-time and baked lighting and weighed the visual differences and the performance
    tradeoffs between these approaches. We also learned some techniques to overcome
    lighting limitations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用实时和烘焙光照来照亮室内环境场景，并权衡了这些方法之间的视觉差异和性能权衡。我们还学习了一些克服光照限制的技术。
- en: With that and the knowledge and technique learned in this chapter, take the
    time to finish your level’s interior environment design to make it appear lived-in
    – immersive and engaging for the player. Tell a story. Iterate as necessary with
    feedback from your playtesting group. Most importantly, just have fun!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些以及本章中学到的知识和技巧，花时间完成你关卡的室内环境设计，使其看起来有人居住——对玩家来说既沉浸又吸引人。讲述一个故事。根据你的游戏测试小组的反馈进行必要的迭代。最重要的是，尽情享受吧！
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the process of transforming a grayboxed prototype
    environment by importing and replacing modular Prefabs with high-quality 3D model
    assets using Unity’s new 2022 Prefab workflow, preserved Prefabs with additional
    behavior using Prefab Mode, and applied new materials to finish up the level’s
    structural visuals.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了通过使用Unity新2022 Prefab工作流程导入和替换模块化Prefab，以及使用Prefab模式保留具有额外行为的Prefab，并应用新材料来完成关卡的结构视觉效果，从而将灰盒原型环境进行转换的过程。
- en: We continued to decorate the environment by painting scattered Prefabs with
    **Polybrush**, strategically placing wear-and-tear **Decal** projectors for an
    additional layer of uniqueness and detail, and finalizing our artistic vision
    with technical implementations of both real-time and baked lighting setups, where
    we addressed additional considerations for lighting and shadows for dynamics objects
    while using baked lightmaps.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续通过使用**Polybrush**绘制散布的Prefab，战略性地放置磨损**贴图**投影仪以增加独特性和细节，以及通过实时和烘焙光照设置的技术实现来最终确定我们的艺术愿景，其中我们针对动态对象在烘焙光照设置中考虑了额外的光照和阴影问题。
- en: In the next chapter, we’re going to continue enhancing the player experience
    by adding some much-needed sound design (so far, audio is something we haven’t
    spent any time on). We’ll code `AudioManager` and create reusable *audio* *player*
    components to make adding music, **sound effects** (**SFX**), and ambient sounds
    simple and straightforward (even for artists and designers).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过添加一些急需的声音设计（到目前为止，我们还没有在这方面花费任何时间）来提升玩家的体验。我们将编写`AudioManager`并创建可重用的*音频*
    *播放器*组件，使添加音乐、**音效**（**SFX**）和环境声音变得简单直接（即使是对于艺术家和设计师来说也是如此）。
