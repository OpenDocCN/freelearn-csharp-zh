- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Linux Leaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Systems Programming in C#* *on Linux*'
  prefs: []
  type: TYPE_NORMAL
- en: I remember the time when only the really cool kids worked on Linux. Windows
    was for serious people. That was where the work was done. Sure, many servers ran
    Unix or Linux, but those working on those platforms were considered somewhat weird.
    They usually had beards, wore sandals, and spoke a language none of the rest of
    the people had ever heard.
  prefs: []
  type: TYPE_NORMAL
- en: OK, maybe I am exaggerating. Perhaps this shows how I felt about Linux or how
    intimidated I was by that operating system and its users. Linux has always been
    considered a more mature but complex operating system. It is more secure, faster,
    and better to maintain. It is also more complicated to use. Most of the work is
    done in the command line, although graphical user interfaces exist.
  prefs: []
  type: TYPE_NORMAL
- en: These days, things are different. Linux is everywhere. And for good reasons,
    too – Linux is an excellent operating system to run your system in the current
    online, connected world.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of **.NET Core** and **.NET 5**, developers who traditionally
    only used Windows can also compile their code to run on Linux. And that opens
    up a whole new world.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are downsides. Linux is more complex than Windows, especially
    if you have worked on Windows for a long time. Even though .NET can run on Linux,
    not all the classes and tools you might be used to are available.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to help you get on your way should you want to run your
    .NET applications on Linux. Don’t worry – I do not want you to start wearing sandals
    or become a typical 1970s-type developer. That is entirely optional. So, let’s
    get your inner penguin out and start hacking on Linux!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will ask the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Linux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I do basic things in Linux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I develop for Linux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I deploy to Linux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I write background services for Linux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter contains some history, some theory, and a lot of practical information
    and samples. Are you ready to follow along?
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will find all the code in this chapter in our repository at this URL: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14).'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow along, you need a Linux machine. But during development,
    you actually do not need that. All you need is WSL. **WSL** stands for **Windows
    Subsystem for Linux**. The official name is WSL2, as we are at version 2 these
    days, but let’s stick with WSL here.
  prefs: []
  type: TYPE_NORMAL
- en: WSL is a lightweight virtual machine that runs a Linux distribution (I will
    explain what that is later on) on your Windows machine. You can quickly move to
    that machine and use it like a “real” Linux machine. You can even deploy directly
    from Visual Studio and debug your apps on WSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install WSL, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In Powershell, use the `wsl --install` command (you have to be an administrator
    to do this). Be aware that this might take a couple of gigabytes of hard disk
    space on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that’s it. No *step 2*. You can now go to the `Ubuntu`. That looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF4.1: Running Ubuntu from the Windows Start menu](img/B20924_15_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Running Ubuntu from the Windows Start menu'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can install other versions of Linux, but I will use **Ubuntu
    20.04** in this book. What you pick doesn’t matter; just do what you feel most
    comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can create a virtual machine using HyperV, deploy a Docker
    container with Linux, get a second machine to install Linux on, or run Linux from
    a bootable USB stick. The choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before discussing how to program for Linux, we should discuss what it is. The
    short answer is that it is an operating system. While that is absolutely true,
    it does not sufficiently explain all that Linux can do. I can say that a bike
    is a transporting device, but that also applies to the Saturn 5 rocket that took
    astronauts to the moon. We need a bit more information.
  prefs: []
  type: TYPE_NORMAL
- en: A short history of Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The history of Linux is quite fascinating. Understanding the timeline and circumstances
    under which it was developed can help you appreciate some of the design decisions
    and choices. So, here is a short timeline of the history of Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early beginnings**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 1983, Richard Stallman announced the GNU Project. The idea was to create
    a free Unix-like operating system. Unix was the leading operating system in those
    days. The GNU Project developed many components, but one key piece, the kernel,
    was missing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In 1987, Andrew S. Tanenbaum created Minix. Minix was a Unix-like system. It
    was intended for educational purposes and was very popular among students. One
    of them was a young man named Linus Torvalds.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The birth** **of Linux**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 1991, Linus Torvalds, a student at the University of Helsinki in Finland,
    started developing his kernel. It was just a hobby; he wanted to have something
    to do. On August 25, 1991, he announced his project in a newsgroup posting, seeking
    input from others. This is what later became the Linux kernel.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On 5th October, 1991, Torvalds released version 0.02 of Linux. It could run
    Bash (a terminal) and GCC (a C-compiler).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development** **and growth**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 1992, Linux was released under the GNU **General Public License** (**GPL**),
    allowing anyone to use, modify, and distribute the software.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the mid 1990s, Linux snowballed in popularity. Distributions, such as Slackware
    and Debian, were both released in 1993.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In 1994, Linux version 1.0 was released. It was a significant milestone; this
    was the first stable release.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commercial and** **community expansion**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 1996, Tux the Penguin was chosen as the official Linux mascot.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The late 1990s saw companies such as Red Hat and SUSE begin to offer commercial
    Linux distributions. Since these also included support, this was the moment enterprises
    jumped on board.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In 1999, IBM announced support for Linux.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The 21st century and** **mainstream adoption**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 2001, version 2.4 of the Kernel was released, including USB, PC cards, and
    other hardware support.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2002–2003 saw major companies such as HP and Dell offering Linux on their servers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2004, Canonical released its Linux distribution, which was way more user-friendly.
    This enabled the general public to use it as well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2005, Linus Torvalds released a side project called Git. Yes, that Git. The
    tool you probably use every day. Git was an essential tool for Linux development.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** **modern era**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 2011, Linux was the dominant operating system in the server market. It powers
    the majority of web servers, including those of major companies such as Google,
    Amazon, and Facebook.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2013, Google released Android, a mobile, Linux-based smartphone operating
    system.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the 2020s, Linux continues to dominate the server space, cloud infrastructure,
    supercomputing, and IOT devices.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the key factors that led to the success of Linux was its open source
    nature. Everybody can look at the sources, download them, adopt them, and do whatever
    they want. And it is and always will be for free.
  prefs: []
  type: TYPE_NORMAL
- en: Will all this in mind, it is no wonder that we, as system programmers, also
    need to learn about Linux.
  prefs: []
  type: TYPE_NORMAL
- en: What is Linux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name Linux itself can be confusing at times. Let me shed some light on that
    and help you clarify things.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Linux kernel** is the heart of what we call Linux. It is the core of
    the operating system. The kernel manages the systems’ hardware and resources,
    such as memory and CPUs. Some of the key responsibilities of the Kernel are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process management**: It decides which process runs and for how long'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory management**: It keeps track of every byte in the systems’ memory
    and manages the allocation and deallocation of memory space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device management**: It manages communications with all devices attached
    to the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System calls**: It also provides an interface between the aforementioned
    systems and the applications that want to use them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel is comparable with the **Windows** **NT kernel**.
  prefs: []
  type: TYPE_NORMAL
- en: Other components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Linux usually comes with a set of other components as well. Some of the most
    commonly found components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System libraries**: These are essential collections of functions that programs
    can use to perform tasks, such as file handling and mathematical computations.
    A good example is the GNU C library, the foundation for most C or C++ programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init` program. This program manages system startup. Other examples are Bash,
    a shell program, and various command-line tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Daemons**: These are background services that perform various tasks, such
    as handling print jobs, managing network connections, or scheduling tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash? What is that?
  prefs: []
  type: TYPE_NORMAL
- en: Names of software or parts in Linux differ from the names you’ll find in Windows.
    Windows is more serious in its naming, while Linux is more playful. **Bash**,
    for instance, stands for **Bourne Again Shell**, named after its creator, Stephen
    Bourne. He wanted to create a better shell than the most used shell back then
    – the Thompson shell. So he merged “born again” with his own surname and came
    up with this new name. You’ll find these kinds of names a lot when working with
    Linux!
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot more components, and sometimes, the choice of where to place
    components might seem arbitrary. But in general, this distinction works.
  prefs: []
  type: TYPE_NORMAL
- en: Added software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you install Linux, you often get a lot more software. These are the user-facing
    programs and the software that the users interact with. There are command-line-based
    programs and GUI-based programs. Which ones are distributed depends on what package
    you have downloaded or purchased.
  prefs: []
  type: TYPE_NORMAL
- en: Distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Linux `Ubuntu` in the Windows Store and click **Get**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hundreds of distros are available, mostly for free, but some you have to pay
    for. The following table is a list of the most used distros, grouped by usage
    category:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Distribution** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **General** **desktop use** | Ubuntu | Known for its user-friendliness, large
    community, and robust support |'
  prefs: []
  type: TYPE_TB
- en: '|  | Linux Mint | Based on Ubuntu, popular due to its ease of use and traditional
    desktop environment |'
  prefs: []
  type: TYPE_TB
- en: '|  | Fedora | Known for its cutting-edge features and close relationship with
    Red Hat |'
  prefs: []
  type: TYPE_TB
- en: '| **Lightweight** | Lubuntu | A lighter, faster, and energy-saving variant
    of Ubuntu that uses LXQt |'
  prefs: []
  type: TYPE_TB
- en: '|  | Xubuntu | An official Ubuntu variant that uses the XFCE desktop environment
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | Puppy Linux | Extremely lightweight, designed to run on older hardware
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Privacy** **and security** | Tails | Aimed at preserving privacy and anonymity,
    based on Debian |'
  prefs: []
  type: TYPE_TB
- en: '|  | Qubes OS | Focuses on security through isolation, using virtual machines
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | Kali Linux | Designed for penetration testing and security auditing |'
  prefs: []
  type: TYPE_TB
- en: '| **Server** **and enterprise** | CentOS/AlmaLinux/Rocky Linux | Community-supported
    rebuilds of **Red Hat Enterprise** **Linux** (**RHEL**) |'
  prefs: []
  type: TYPE_TB
- en: '|  | Ubuntu Server | The server edition of Ubuntu, known for its ease of use
    and broad support |'
  prefs: []
  type: TYPE_TB
- en: '|  | Debian | Known for its stability and robustness, often used on servers
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Development** | Arch Linux | Favored by developers for its simplicity and
    control |'
  prefs: []
  type: TYPE_TB
- en: '|  | Fedora | Offers cutting-edge software and technologies |'
  prefs: []
  type: TYPE_TB
- en: '|  | openSUSE | Known for its developer-friendly tools and YaST configuration
    tool |'
  prefs: []
  type: TYPE_TB
- en: '| **Media** **production** | Ubuntu Studio | Specifically tailored for audio,
    video, and graphic design |'
  prefs: []
  type: TYPE_TB
- en: '|  | AV Linux | Custom-built for multimedia content creators |'
  prefs: []
  type: TYPE_TB
- en: '|  | Fedora Design Suite | Comes with a range of open source creative applications
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Education** | Edubuntu | An Ubuntu flavor designed for use in classrooms
    and educational environments |'
  prefs: []
  type: TYPE_TB
- en: '|  | Kano OS | Designed for use with the Kano computer kit, aimed at teaching
    kids how to code |'
  prefs: []
  type: TYPE_TB
- en: '|  | Debian Edu/Skolelinux | A custom Debian Pure Blend, designed for educational
    use |'
  prefs: []
  type: TYPE_TB
- en: '| **Gaming** | SteamOS | Developed by the Valve Corporation for gaming consoles
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | Ubuntu GamePack | Comes pre-installed with many games and emulators |'
  prefs: []
  type: TYPE_TB
- en: '|  | Lakka | A lightweight Linux distribution that transforms a small computer
    into a full-blown game console |'
  prefs: []
  type: TYPE_TB
- en: '| **Special** **Purpose** | Raspberry Pi OS (formerly Raspbian) | Optimized
    for the Raspberry Pi hardware |'
  prefs: []
  type: TYPE_TB
- en: '|  | Clear Linux | Developed by Intel, optimized for performance and security
    on Intel hardware |'
  prefs: []
  type: TYPE_TB
- en: '|  | Tiny Core Linux | An extremely small, highly modular, and flexible Linux
    distribution |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.1: Some of the available Linux distros'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is a distro tailored just for you. However, remember that
    the kernel is probably the same or at least very similar for all of them. The
    biggest difference between the distros is the added software and the configuration
    you get out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: A quick primer to use Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early days of my career, I knew I was very good with computers. They
    held no surprises for me. I knew how to control them; I was the master of the
    machine. That lasted until I sat behind my first Linux machine. That was when
    I realized I only knew a lot about Windows and how to use that platform. I was
    at a loss. I could not even get the contents of a directory on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To my defense, this was in the early 1990s. Linux was just released, and we
    did not have the wealth of information online that we have today. The World Wide
    Web had just been invented, search engines did not exist, and information was
    hard to find. Today, things are more straightforward – there are tons of sources
    out there that can help you get up to speed with something new.
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to help you learn some of the basics so that you can play around with
    Linux without pulling your hair out. I am not going to discuss any of the available
    GUI systems. There are plenty of them, and some of them are very good. But using
    them is as easy as using Windows. Honestly, real work happens when you are on
    a command line. So, that is what I focus on from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also assume you have figured out how to install WSL on your machine and can
    open a Terminal. I also have a tip – install the Windows Terminal from the Windows
    Store. The Windows Terminal is an excellent tool for opening different shells,
    including Linux ones. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF4.2: A Terminal application opening a new Linux shell](img/B20924_15_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: A Terminal application opening a new Linux shell'
  prefs: []
  type: TYPE_NORMAL
- en: You can open multiple windows, each with its shell. You can open a PowerShell
    window next to a Ubuntu window and even the old-style Command Prompt. You have
    everything you need ready at your fingertips.
  prefs: []
  type: TYPE_NORMAL
- en: Casing – beware!
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the commands, there is one thing you should know – *Linux
    is case-sensitive; Windows is not*. Trust me – this has tripped up many people
    in the past and will probably confuse people in the future. So, keep this in mind.
    A directory can have two files with the same name that only differ in casing.
    It is possible to have the `MyAwesomeApp` and `myAwesomeApp` files in the same
    place. If you come from a Windows background, you will often make this mistake;
    you cannot find a file that you know is there, which I see a lot. Check your casing.
  prefs: []
  type: TYPE_NORMAL
- en: If you have chosen a Terminal, open the shell for Linux. Now, you are ready
    to try out some commands!
  prefs: []
  type: TYPE_NORMAL
- en: Basic commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I want to give you a list of the most used Linux commands with their equivalents
    on Windows. But before diving into those lists, I want to share the best command
    – `man`. This keyword opens the manual pages for any command you want to learn
    more about. For instance, the equivalent of `dir` on Windows is `ls`. Type `man
    ls` and press *Enter* to learn more about it. Doing this results in pages and
    pages of information about the command, parameters, and examples. This works for
    almost all commands.
  prefs: []
  type: TYPE_NORMAL
- en: Basic navigation and file management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigating the filesystem is probably essential when using an OS. For Linux,
    you should know these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Task** | **Windows command** | **Linux command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **List** **directory contents** | `dir` | `ls` | Lists files and directories
    in the current path |'
  prefs: []
  type: TYPE_TB
- en: '| **Change directory** | `cd` | `cd` | Changes the current directory |'
  prefs: []
  type: TYPE_TB
- en: '| **Print** **working directory** | `cd` | `pwd` | Displays the current directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Copy files** | `copy` | `cp` | Copies files |'
  prefs: []
  type: TYPE_TB
- en: '| **Move/rename files** | `move` | `mv` | Moves or renames files |'
  prefs: []
  type: TYPE_TB
- en: '| **Delete files** | `del` or `erase` | `rm` | Removes files |'
  prefs: []
  type: TYPE_TB
- en: '| **Delete directories** | `rmdir` or `rd` | `rmdir` or `rm -r` | Removes directories
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Create directories** | `mkdir` | `mkdir` | Creates directories |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.2: Navigation and file management commands'
  prefs: []
  type: TYPE_NORMAL
- en: The commands work more or less as you would expect. So, try them!
  prefs: []
  type: TYPE_NORMAL
- en: File viewing and editing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to learn more about the contents of a file or edit the contents,
    these commands are there to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Task** | **Windows c****ommand** | **Linux command** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **View** **file contents** | `type` | `cat` | Displays file contents |'
  prefs: []
  type: TYPE_TB
- en: '| **Edit files** | `notepad` | `nano`, `vi`, or `vim` | Edits files |'
  prefs: []
  type: TYPE_TB
- en: '| **View file** **contents (paged)** | `more` | `less` | Views file contents
    page by page |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.3: File viewing and editing'
  prefs: []
  type: TYPE_NORMAL
- en: A word of warning – if you start using VI or VIM for the first time, ensure
    that you have a web page open with the commands to use in those tools. Working
    with those tools can be pretty complicated when you have no experience with them!
  prefs: []
  type: TYPE_NORMAL
- en: System information and processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to learn more about the system you are on or are keen to learn
    about the running processes, give these commands a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Task** | **Windows command** | **Linux command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Display** **system info** | `systeminfo` | `uname -a` | Displays system
    information |'
  prefs: []
  type: TYPE_TB
- en: '| **Display** **process info** | `tasklist` | `ps` | Lists running processes
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Kill processes** | `taskkill` | `kill` | Terminates processes |'
  prefs: []
  type: TYPE_TB
- en: '| **Show** **disk usage** | `dir` `or chkdsk` | `df` | Displays disk space
    usage |'
  prefs: []
  type: TYPE_TB
- en: '| **Show** **file size** | `dir` | `du` | Displays file and directory sizes
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.4: System information and process commands'
  prefs: []
  type: TYPE_NORMAL
- en: These commands are invaluable when you start to write your own software on Linux.
    Running these commands gives you a lot of information that you might need later
    on!
  prefs: []
  type: TYPE_NORMAL
- en: Network commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As system programmers, we often work with networks or have our software communicate
    over networks. In those cases, it is good to know how to learn more about the
    network on our systems. These are commands that can help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Task** | **Windows command** | **Linux command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Ping** | `ping` | `ping` | Checks network connectivity |'
  prefs: []
  type: TYPE_TB
- en: '| **IP configuration** | `ipconfig` | `ifconfig` or `ip` | Displays or configures
    IP network settings |'
  prefs: []
  type: TYPE_TB
- en: '| **Trace route** | `tracert` | `traceroute` | Traces the path to a network
    host |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.5: Networking commands'
  prefs: []
  type: TYPE_NORMAL
- en: Most of these commands are similar to their Windows counterparts, so you should
    have no problem remembering and using them.
  prefs: []
  type: TYPE_NORMAL
- en: Package management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many distros come packed with software, but it is very likely your distro might
    miss something that you may find invaluable. But don’t worry – Linux has tools
    to install them. This is a short list of some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Task** | **Windows command** | **Linux c****ommand** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Install software** | Varies (e.g., `msiexec`) | `apt-get install`, `yum
    install`, or `dnf install` | Installs software packages |'
  prefs: []
  type: TYPE_TB
- en: '| **Update software** | Windows Update | `apt-get update` or `apt-get upgrade`
    | Updates software packages |'
  prefs: []
  type: TYPE_TB
- en: '| **Remove software** | Varies (e.g., Control Panel) | `apt-get remove`, `yum
    remove`, or `dnf remove` | Removes software packages |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.6: Package management commands'
  prefs: []
  type: TYPE_NORMAL
- en: You will run into these commands a lot more later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Elevated privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux is built around security. One of the effects is that you are more or less
    forced to run all the commands as a regular user. You are not an administrator,
    even though you logged in as one. You cannot do everything you want.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily change that. You can give yourself root privileges using the
    `su` command, meaning **super-user**. **Root** here means you are at the top level
    of all user rights; you can do anything you want. However, don’t do that. I have
    rarely had a reason to become the root of my systems. In the Linux community,
    becoming root is frowned upon.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to elevate your rights to do something, use the `sudo` command.
    This command stands for `sudo`. If so, you give the command the root rights it
    might need once, and then the system immediately returns to the normal privilege.
    Only the command on that line can use these elevated privileges.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you use `sudo` in a session, you must supply the administrative
    password you entered when installing your distro. Your system remembers those
    credentials for the duration of the session, so you do not have to do that every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you how that works. I use the `whoami` command, which provides
    information about the currently logged-in user. If I use that command, it returns
    my name. However, when I do that again, I add `sudo` before it, and it returns
    `root`. Immediately after that, it reverts to returning my name. This screenshot
    shows that in action:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF4.3: Sudo in action](img/B20924_15_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Sudo in action'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it also asks me for my password. If I issue the same or another
    command and use `sudo`, it will use the cached credentials. But remember that
    this is only valid in this session. If I open another Terminal window and repeat
    the same exercise, the system will ask me for my password again.
  prefs: []
  type: TYPE_NORMAL
- en: Using `sudo` is another example of how Linux makes things as secure as possible.
  prefs: []
  type: TYPE_NORMAL
- en: It’s useful to know many more commands, but this at least gives you a starting
    point. Remember that `man` is your friend here!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can confidently find your way in your Linux distro, it’s time to
    see how we can work with the OS as developers.
  prefs: []
  type: TYPE_NORMAL
- en: Developing for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first pieces of software written for Linux was GCC, created in 1991\.
    `python3` command into the terminal, and you are ready to go. But we do not do
    Python; we do .NET. And that means we have another road to take.
  prefs: []
  type: TYPE_NORMAL
- en: Installing .NET on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned previously that Linux usually has a lot of development tools pre-installed.
    However, .NET is not one of those pre-installed environments. The good news is
    that it is not hard to install.
  prefs: []
  type: TYPE_NORMAL
- en: Before I tell you how to get .NET on the system, I want to discuss my choice
    of development machines.
  prefs: []
  type: TYPE_NORMAL
- en: I love Visual Studio. I think it is by far the best IDE available. There are
    others, and I know many people who prefer other tools over Visual Studio, but
    I am not one of them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the IDEs that many people use is **Visual Studio Code**. And I agree
    with them that **VS Code** (to use its shorter name) is a great tool. However,
    I prefer the richness of the complete edition of Visual Studio when I work on
    a real-world system.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer VS Code, you can use that, of course. You can install VS Code
    on many different platforms, including Linux. There are many tutorials online
    that tell you how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: I have bad and good news if you want to stay with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: The bad news is that you cannot install Visual Studio on a Linux machine. The
    good news is that you do not have to. You can install it on your Windows machine
    and then deploy and debug directly on the Linux system. And that is what we will
    do in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, to run .NET applications on your Linux system, you must have the Runtime.
    The Runtime contains all that is needed to run your .NET applications. This is
    great if you want to prepare your production system for your applications. But
    if you want to debug and test your applications on a Linux machine, you also need
    the **.NET SDK**. The SDK contains the Runtime, so you do not need to install
    both.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the .NET Runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s discuss installing the Runtime first. Again, you only need the Runtime
    on machines that will run your software. If you want to compile your code, you
    need the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal on your Linux distro (or a Ubuntu Terminal on your Windows machine).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first command updates all packages on your system. The second one installs
    the HTTPS transport software if it is not already there. It is probably already
    on your system, but this ensures that is the case. We need `https` to download
    the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft ensures all their software is signed, so you can trust it. However,
    to verify that signature, you need to have their public key. This is how we get
    that key on our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These commands get the keys and install them on our system. Now, we can use
    them to verify the downloads from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was all only preparation. Now, it is finally time to install the Runtime.
    This is how we do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we make sure everything is updated. Then, we get the Runtime package.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s it. If this command finishes, we can test it by running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should see the .NET 8 Runtime in the (concise) list of runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to build and debug your Linux distro, you need more software. You
    must install the SDK. Fortunately, that process is almost the same as installing
    the Runtime. If you have installed the Runtime, you can enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This set of commands first updates all packages and then installs the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t installed the Runtime, you first have to repeat all the steps
    I showed you during the Runtime installation, except for the last one (the installation
    of the Runtime itself). You still need to update, get, and install the keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the installation of the SDK by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should now see a list of the SDKS – well, I say list, but you will probably
    only see one item.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can further test the installation by doing a quick test, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new console application. When that is done, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This builds `.csproj` in the current folder. The result ends up in the `/bin/Debug/net8.0`
    folder. The program’s name is the same as the folder in which you placed your
    project. If you didn’t create a directory, it is the name of your user. In my
    case, the program is called `dvroegop`, so I can run it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I can see a friendly `Hello, World` message, so apparently it all works!
  prefs: []
  type: TYPE_NORMAL
- en: Running a .NET background worker on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have had enough theory for the moment, I think. Let’s get practical. Fire
    up Visual Studio and start a new background worker project. In the wizard, accept
    all defaults until the project is ready. In the code, we leave everything as it
    is, including the default template printing a message every second. Run it to
    see that it all works.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, you will have a new background worker running on Windows.
    Great! But we have seen tons of those already. Let’s move our program to Linux.
    To do that, we have to do a couple of things.
  prefs: []
  type: TYPE_NORMAL
- en: Run your app in the WSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can publish directly from Visual Studio to your WSL installation. To do that,
    do the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your project, and go to the run menu. In the dropdown, you should see
    the option to deploy to WSL. This looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF4.4: Use WSL as your debugging environment in Visual Studio](img/B20924_15_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Use WSL as your debugging environment in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **WSL** option in the dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than one distro installed in WSL, you might get a warning in
    Visual Studio that the default WSL does not have the correct SDK installed. If
    that is the case, just click the **Install** button to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `launchSettings.json` file in the `Properties` folder of your project should
    also have the WSL option. This determines which distro Visual Studio will launch.
    If none is specified, it takes the default. In my case, I have both Ubuntu 20
    and Ubuntu 22 installed, so I have to make a choice. I can instruct Visual Studio
    to take version 22 by changing my `launchSettings.json` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The distribution name is an empty string by default, resulting in Visual Studio
    using the default environment to run your system. Since I have specified my desired
    distro name, it uses that distro instead.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the default distro by opening a command prompt or using the PowerShell
    Terminal. Then, get the list of installed distros using this command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the list of installed distros on your machine. On my machine,
    this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can pick one to be the default by issuing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can specify whatever distro you want. I happen to like `Ubuntu-22.04`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens is quite interesting. Visual Studio does a lot of work to ensure
    we do not have to worry about deployment. Here is a simplified overview of what
    happens when you click **Run** after you select WSL as your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio builds your project as a cross-platform system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio then uses WSL to start up an instance of the subsystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using WSL, Visual Studio then copies all the output files to the subsystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio copies VSDBG, which is the remote debugger, to WSL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets up VSDBG, giving it the proper permissions and enabling network communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio then starts VSDBG in the WSL and attaches your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, Visual Studio attaches itself to the running VSDBG instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is that you can use the IDE just like you are used to. You can set
    breakpoints, break the application, inspect variables, read system information,
    and so on. You will see little difference between running your app locally and
    running it on the WSL.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy your app to a Linux environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running your application directly from Visual Studio is pretty cool. Still,
    ultimately, you want to deploy your app to the system. That’s not that hard to
    do.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, right-click on your project and choose to publish.
  prefs: []
  type: TYPE_NORMAL
- en: Build a new publish profile like you are used to, with a tiny difference – set
    the target runtime to **linux-x64**. Setting this framework will ensure that your
    app runs on Linux!
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can also deploy your app to your WSL distro. You can use a
    handy shortcut in Windows Explorer – navigate to the `\\wsl.localhost\Ubuntu-22.04\home\[username]\`
    folder. Make sure to replace `[username]` with your username from the WSL. You
    can create a new folder to act as the publish profile recipient.
  prefs: []
  type: TYPE_NORMAL
- en: You can enter that folder in the profile’s target location – that way, Visual
    Studio automatically sends all the artifacts to the right place. My profile settings
    look like this.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF4.5: A publish profile for a Linux/WSL target](img/B20924_15_5.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: A publish profile for a Linux/WSL target'
  prefs: []
  type: TYPE_NORMAL
- en: If you do this and then press the **Publish** button, your code ends up where
    it needs to be. Now, you can run the program from the WSL distro. Of course, if
    you have another Linux system running, you can use the same mechanism. If you
    can’t make a share, you can always publish it locally and then use a tool such
    as SCP to copy the files.
  prefs: []
  type: TYPE_NORMAL
- en: I think we have discussed this matter enough. Next, let’s discuss developing
    for Linux!
  prefs: []
  type: TYPE_NORMAL
- en: Make your code cross-platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of .NET is that it is cross-platform. The IL runs almost everywhere.
    If you build an application, it will work on your Windows and Linux machines.
  prefs: []
  type: TYPE_NORMAL
- en: Running an exe on Linux?
  prefs: []
  type: TYPE_NORMAL
- en: No, you cannot run your Windows `exe` on Linux. An EXE file is a typical Windows
    construct. The file layout is specific to that platform, and Linux systems have
    another way to handle executables. However, the compiler also produces a DLL file
    if you build your system. That file can be run with the `dotnet` command. So,
    if your system is called `MyAwesomeApp.exe`, you will also find a `MyAwesomeApp.dll`
    in the `Build` directory. On all supported platforms, you can run your application
    using the `dotnet MyAwesomeApp.dll command`, which works on Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: But that doesn’t mean you can copy your binaries, run them, and expect everything
    to work fine. There are some caveats you should be aware of. But don’t worry –
    we’ll cover them one by one here.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions in Linux
  prefs: []
  type: TYPE_NORMAL
- en: Here is the first caveat – scripts and applications cannot run by default. They
    do not have the correct permissions. Each file has a set of permissions, telling
    the OS what it can do with it. These permissions differ per category. There are
    permissions for the user, a group, and others. The permissions themselves can
    be read, write, or execute. You use the `chmod` (`man chmod` to get all the inside
    information, but remember that to make your application runnable, you have to
    use the `chmod +x [yourapplicationname]` command. The `+x` part tells Linux you
    can execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get the hang of it, you will find it is easy to switch between Windows
    and Linux. But to be completely honest, I have been known to try the `chmod` command
    on my Windows machine. Don’t tell anyone I confessed to this!
  prefs: []
  type: TYPE_NORMAL
- en: How code can help you
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The people who made .NET have gone out of their way to make it as easy as possible
    for those who need to support multiple platforms. Whereas in the “old days,” you
    had to have a lot of compiler directives or even different versions of your code,
    you can now do a lot in code and have the system figure out how to handle things.
    Let’s look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out where you run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now and then, you want to know what platform a system runs on. There is a class
    called `OperatingSystem` that helps with that. It is a very simple class, but
    it can be tremendously powerful. Look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `OperatingSystem` class has many more methods like this, but I am sure you
    get the idea. You can also use this class to determine the software’s specific
    version of a platform if you need to know that. So, all the information you need
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: Paths and directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you played around in WSL using the commands I gave you earlier in this chapter,
    you might have noticed that paths look quite different from what you may be used
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the path to my home directory when I browse in Windows looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: My main drive is the C drive, with a `Users` folder with a subfolder, `dvroe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my Linux distro, my `home` folder can be found at this location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, it can be found by going to the root, then the `home` subfolder,
    and finally, to the `dvroegop` folder.
  prefs: []
  type: TYPE_NORMAL
- en: There is no mention of a drive. In addition, all the slashes are the other way
    around.
  prefs: []
  type: TYPE_NORMAL
- en: Drives are available, but they are in a different place. Linux has a root path
    called `/mnt`. You can find a folder for all the drives on your machine in that
    folder. So, in Windows, the drive is the root of all paths; in Linux, it is a
    subfolder of `/mnt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your code, you should never need to worry about what kind of slashes to
    use or how to structure your path to contain the right drive. The `Path` class
    contains all the tools you need. Look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this sample, I combine two parts of a path. You should never do that. I just
    wanted to show you what happens if you use `DirectorySeparator`. A better way
    to do this is to use `Path.Combine()`, as I also show in this code. That way,
    you can be sure to always get the right results.
  prefs: []
  type: TYPE_NORMAL
- en: A path separator versus a directory separator
  prefs: []
  type: TYPE_NORMAL
- en: I have shown you both a path separator and a directory separator in the sample.
    Many developers use path separators and directory separators interchangeably,
    but they are different things in this case. A directory separator is a character
    that separates different parts of an entire directory name. For instance, the
    `c:\users\yourname\mydata` path contains the three `\` directory separators. A
    path separator is used if you need multiple directories in one string.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is the `%PATH%` environment variable, which shows all the directories
    that Windows uses to search for executables. They come in a long list separated
    by a path separator. In Windows and Linux, all these characters differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar thing happens with line endings. Windows uses two characters – return
    and line feed `(''\r\n'')`. Linux uses line feed only – `(''\n'')`. If you want
    to be sure your code works everywhere, use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That solves this problem for you.
  prefs: []
  type: TYPE_NORMAL
- en: Writing services for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book has mentioned background processes quite a lot. We’ve seen how to
    write them and how to deploy them. But how does that work on Linux? Let’s find
    out!
  prefs: []
  type: TYPE_NORMAL
- en: A background service in Linux is called a **daemon**. This software runs in
    the background and doesn’t immediately interact with a user. That sounds like
    something we, as system programmers, should recognize.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a Worker Service in Visual Studio to write such software. Build
    it, then deploy it to a folder on your Linux distro.
  prefs: []
  type: TYPE_NORMAL
- en: The service description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you do that, add a new file to the project; this is the system description
    that Linux needs to register your services.
  prefs: []
  type: TYPE_NORMAL
- en: 'I called my file `crossplatformservice.service`. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you should make sure the paths in this file correspond to your paths.
    I doubt you have a folder called `dvroegop' on your machine. Let’s investigate
    what this file does.
  prefs: []
  type: TYPE_NORMAL
- en: The `Unit` section contains metadata and the dependencies for the service. A
    `Description` is a human-readable description.
  prefs: []
  type: TYPE_NORMAL
- en: '`After` specifies when the service should start. Here, we state that the service
    should start when the network has been initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Service` section configures how the service should be run and managed.
    The parts of this section are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `WorkingDirectory` | This is where the application will be executed. Can
    be used for relative path resolution. |'
  prefs: []
  type: TYPE_TB
- en: '| `ExecStart` | This is the command used to start the service. |'
  prefs: []
  type: TYPE_TB
- en: '| `Restart` | Defines the restart policy. `always` means it always restarts
    after a crash or unexpected stop. |'
  prefs: []
  type: TYPE_TB
- en: '| `RestartSec` | This is the delay before restarting the service. |'
  prefs: []
  type: TYPE_TB
- en: '| `KillSignal` | This defines the signal used to terminate the service. `SIGINT`
    is the most used one; we’ll look into this later on. |'
  prefs: []
  type: TYPE_TB
- en: '| `SyslogIdentifier` | Sets a name for the service’s log entries. |'
  prefs: []
  type: TYPE_TB
- en: '| `User` | Runs the service as a specified user. |'
  prefs: []
  type: TYPE_TB
- en: '| `Environment` | Sets the environment variables needed for the service. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.7: The service elements for a service description'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `Install` section. This indicates how and when a service
    should be installed and started. The `WantedBy` element specifies the target to
    which this service should be linked. In our case, we used `multi-user.target`,
    which means it runs in a multi-user, non-graphical environment. This is typical
    for services such as ours.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you add this file to your deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can install the service once you have the binaries and the service description
    file on your Linux distro. In a Terminal, do the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the service description file to the correct directory. If you are in the
    publish directory on your distro, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You need to use `sudo`; a regular user has no right to access that folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to restart the system manager configuration. Do that with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the configuration is reloaded and has read our service description file,
    we can enable the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The name `crossplatformservice` is the one that I used in the `SyslogIdentifier`
    setting in the description file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Linux system restarts, our service will also start. But you don’t have
    to reboot – you can also manually start the service to see whether everything
    works out fine. Do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are probably disappointing; you see nothing. But you can verify
    if it all worked out by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command returns the status, confirming that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more information, you can look in the log files. All logs are collected
    by Linux, and acquiring them is done with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This command shows the last entries in the logs. Since many applications use
    the log, we can filter the results to only show the ones belonging to our service.
    That is what the -u parameter does.
  prefs: []
  type: TYPE_NORMAL
- en: You should get the expected data on your screen to confirm that the service
    works!
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might want to get rid of the service on your development machine. That’s
    not too difficult; just reverse the steps we just took.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, stop the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, disable the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the service description file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, reload the daemon configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that’s it. To verify that the service really is deleted, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That last command should return an error, as our service no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: Handling signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the service description file, we told the system that our application could
    be stopped with the `SIGINT` signal. But that was not really true, as we haven’t
    done anything to process signals.
  prefs: []
  type: TYPE_NORMAL
- en: What are signals?
  prefs: []
  type: TYPE_NORMAL
- en: A signal can be compared to events on a Windows machine, or, if you remember
    from earlier chapters, instances of Windows messages. In other words, they are
    messages that are sent to your application. Some are predefined, while others
    are user-defined, meaning you can also use them to communicate between programs.
    In this case, we are talking about the two most used messages in Linux. That’s
    all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Signals are ways for the operating system to send messages to your application
    or service. Two of the most used signals are `SIGINT` and `SIGTERM`. The first
    one, `SIGINT`, requests an interrupt – the OS wants to stop the service. The second,
    `SIGTERM`, is meant to stop the application immediately. I agree that it is hard
    to see the difference between these two, but there is logic here – `SIGINT` is
    usually a response to a user doing something, such as pressing *Ctrl* + *C*. You
    could say that a user is responsible for sending `SIGINT`. The `SIGTERM` signal
    is from the OS or other services if they think our service needs to be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: We must write code to handle these signals and make our application behave nicely.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we must import a NuGet package. In this case, we need `Mono.Posix.NETStandard`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have done that, go to the `Worker` class and add the following method
    to that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This method does two things. First, it registers `eventhandler` for the “normal”
    `ProcessExit` event. This event is called when a process needs to terminate and
    is part of the .NET Runtime. In Linux, this is called when `SIGTERM` is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we tell the system to listen to the `SIGINT` and `SIGTERM` signals. We
    create an array with these values and start a new background thread. All that
    the thread does is wait for those signals to arrive. When they do, it calls the
    `SignalHandler()` method. This method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method is simple enough – we write to the log that we received and then
    terminate the program.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor of the `Worker` class, we add the call to `RegisterSignalHandlers()`,
    and then we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Run the program from Linux (not as a service, but as a regular program), press
    *Ctrl* + *C*, and note the messages telling you that we managed to capture the
    signal. Cool, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Summing up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you should have all the knowledge to start working on Linux programs. Linux
    is the platform of choice for many services. Services, of course, are something
    we as system programmers work with all the time. Although a great platform, Linux
    has a steep learning curve. Many things are similar to what you are used to in
    Windows but differ slightly, whereas other things are entirely new or unique to
    the platform.
  prefs: []
  type: TYPE_NORMAL
- en: It takes time to learn it well. But with what we’ve discussed in this chapter,
    you are well on your way to feeling at home with Linux. We explored the history
    of the platform, and we discussed some of its most used commands. We discussed
    development and looked at how to write daemons for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sit back. Take a deep breath. You’ve made it. You’ve reached the end of the
    book. And I hope you learned a thing or two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t underestimate what we’ve done. We’ve answered so many questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is systems programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we use low-level APIs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we use the Win32 API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we make our software run faster?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we make our software memory efficient?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is I/O and how do we use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the best way to have systems communicate over a network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we monitor and log what our systems are doing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the ultimate way to debug these low-level systems?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we even deploy it all?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we work with Linux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s a lot of information! But you have taken the challenge. You can call
    yourself a specialist in writing fast-performing, memory-efficient, network-aware,
    secure, and cross-platform low-level system software. That’s a long title, but
    you deserve it!
  prefs: []
  type: TYPE_NORMAL
- en: And don’t forget – these newfound skills made you a better developer. These
    skills can be applied to all sorts of projects, not only systems programming.
    The basic principles stand and are applicable everywhere. I look forward to hearing
    from you and discovering what you are going to do with what you have learned.
    The best way to learn new techniques is to try them out. So, I urge you to try
    the samples and write awesome system software. I have faith in you!
  prefs: []
  type: TYPE_NORMAL
