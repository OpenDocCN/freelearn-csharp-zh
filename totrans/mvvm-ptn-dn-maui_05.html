<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer047">
<h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor086"/>5</h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Community Toolkits</h1>
<p>In this chapter, we will explore some of the popular <strong class="bold">Community Toolkits</strong> that have been developed to assist<a id="_idIndexMarker352"/> developers in using data binding and the MVVM pattern more efficiently and effectively in .NET MAUI. These toolkits offer valuable components and utilities that can greatly enhance your development experience and help you build robust and maintainable applications. There are numerous large and small frameworks or toolkits that facilitate data binding and the application of the MVVM pattern in your projects. Some of them have a significant overall impact on your code, while others are more focused on providing developers with a set of helpers or components that you typically rewrite for each <span class="No-Break">new project.</span></p>
<p>Every existing toolkit or framework is the product of dedicated developers investing their time and expertise, and each one provides value to its users, whether or not it suits your particular coding style. In this book, I don’t want to favor any specific framework or toolkit over others but rather showcase community-driven efforts that can be beneficial to developers. For this reason, we’ll be exploring two Community Toolkits that provide some helpers and base classes that you can build upon but don’t have a large impact on <span class="No-Break">your code.</span></p>
<p>In this chapter, we will be discussing <span class="No-Break">the following:</span></p>
<ul>
<li>The <span class="No-Break">MVVM Toolkit</span></li>
<li>The .NET MAUI <span class="No-Break">Community Toolkit</span></li>
<li>Other <span class="No-Break">popular frameworks</span></li>
<li>Contributing to <span class="No-Break">the community</span></li>
</ul>
<p>These toolkits were chosen as examples because they offer tools and components that can be integrated into your projects as needed, without imposing a specific architectural style or coding paradigm. This feature makes these toolkits particularly flexible and adaptable to a variety of coding styles and project requirements. Being part of the .NET Community Toolkits, they benefit from a wide community of contributors, including both Microsoft employees and independent developers. This collaboration ensures the toolkits remain up to date, reliable, and effective for developers across <span class="No-Break">the board.</span></p>
<p>These toolkits aim to simplify many common tasks you will encounter when building .NET MAUI applications. The features they provide are often things we’ve covered in earlier chapters, but now, they’ve been conveniently implemented for you. It’s important to understand that these toolkits are not magical entities; they encapsulate strategies and techniques that you could implement yourself. However, their true value lies in offering a ready-made, community-approved solution, saving you significant time and effort. By knowing what’s available in these toolkits, you can make informed decisions about when to leverage them and when to customize your solutions. So, without further ado, let’s dive in and see what they have <span class="No-Break">to offer!</span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Technical requirements</h1>
<p>Throughout this chapter, we will be updating some code from the <em class="italic">Recipes!</em> app. The updated code can be found on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05</a> for reference <span class="No-Break">and comparison.</span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>The MVVM Toolkit</h1>
<p>The <strong class="bold">MVVM Toolkit</strong> (<strong class="bold">CommunityToolkit.Mvvm</strong>) is a comprehensive library that’s designed to simplify<a id="_idIndexMarker353"/> and streamline the implementation of the MVVM pattern in your applications. Developed and maintained by the .NET community, this toolkit provides a robust set of framework-independent tools, components, and utilities that help you build applications using the MVVM pattern. It’s important to note that this toolkit isn’t .NET MAUI-specific; it’s <span class="No-Break">UI framework-agnostic.</span></p>
<p>Here are some of the key features<a id="_idIndexMarker354"/> of the <span class="No-Break">MVVM Toolkit:</span></p>
<ul>
<li><strong class="bold">ObservableObject</strong>: This class serves as a base class that implements<a id="_idIndexMarker355"/> the <strong class="source-inline">INotifyPropertyChanged</strong> interface, simplifying the process of raising the <strong class="source-inline">PropertyChanged</strong> event. Its <strong class="source-inline">SetProperty</strong> method streamlines setting property values and automatically raises the <strong class="source-inline">PropertyChanged</strong> event when needed. By using this class, developers can reduce the boilerplate code associated with checking for property updates and triggering the <strong class="source-inline">PropertyChanged</strong> <span class="No-Break">event accordingly.</span></li>
<li><strong class="bold">ObservableValidator</strong>: <strong class="source-inline">ObservableValidator</strong> extends the <strong class="source-inline">ObservableObject</strong> class and includes<a id="_idIndexMarker356"/> built-in validation logic. This means that any object that inherits from <strong class="source-inline">ObservableValidator</strong> will have both observable and <span class="No-Break">validating features.</span></li>
<li><strong class="bold">RelayCommand</strong> and <strong class="bold">AsyncRelayCommand</strong>: Both classes provide simple, lightweight, flexible, and <a id="_idIndexMarker357"/>framework-agnostic<a id="_idIndexMarker358"/> implementations of the <strong class="source-inline">ICommand</strong> interface. <strong class="source-inline">RelayCommand</strong> handles synchronous operations, while <strong class="source-inline">AsyncRelayCommand</strong> is designed for asynchronous tasks. Both support optional <span class="No-Break"><strong class="source-inline">CanExecute</strong></span><span class="No-Break"> logic.</span></li>
<li><strong class="bold">WeakReferenceMessenger</strong>: <strong class="source-inline">WeakReferenceMessenger</strong> is a messaging system that enables<a id="_idIndexMarker359"/> communication between loosely coupled components. It uses weak references to manage message subscriptions, which helps you avoid memory leaks and unintended strong dependencies between objects in your application. Messaging will be discussed in more depth in <a href="B20941_07.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Dependency Injection, Services, </em><span class="No-Break"><em class="italic">and Messaging</em></span><span class="No-Break">.</span></li>
<li><strong class="bold">Source Generators</strong>: The toolkit includes some source generators<a id="_idIndexMarker360"/> that help automate the creation of boilerplate code, improving productivity and reducing the chance of errors. <strong class="source-inline">ObservablePropertyAttribute</strong> simplifies the implementation of properties that trigger the <strong class="source-inline">PropertyChanged</strong> event, and <strong class="source-inline">RelayCommandAttribute</strong> automates<a id="_idIndexMarker361"/> the creation of <span class="No-Break">commands, respectively.</span></li>
</ul>
<p>These are only a few examples of the components of an MVVM Toolkit. The idea here was to let you know what the MVVM library has to offer. Now, let’s look into how to effectively use it in <span class="No-Break">our project.</span></p>
<p>Adding the MVVM Toolkit to your project<a id="_idIndexMarker362"/> is <span class="No-Break">very easy:</span></p>
<ol>
<li>Right-click the <strong class="source-inline">Recipes.Client.Core</strong> project and select <strong class="bold">Manage </strong><span class="No-Break"><strong class="bold">Nuget Packages</strong></span><span class="No-Break">.</span></li>
<li>Search for <strong class="source-inline">MVVM Toolkit</strong> and select <strong class="bold">CommunityToolkit.Mvvm</strong> from the list. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.1</em> shows the NuGet package we are <span class="No-Break">searching for:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 5.1: CommunityToolkit.Mvvm NuGet package" height="116" src="image/B20941_05_01.jpg" width="1198"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: CommunityToolkit.Mvvm NuGet package</p>
<ol>
<li value="3">Hit <strong class="bold">Install</strong> to add the NuGet package to the <span class="No-Break"><strong class="source-inline">Recipes.Client.Core</strong></span><span class="No-Break"> project.</span></li>
</ol>
<p>In the following example, we will be updating <strong class="source-inline">RecipeDetailViewModel</strong> and <strong class="source-inline">IngredientsListViewModel</strong> so that they<a id="_idIndexMarker363"/> use <strong class="source-inline">ObservableObject</strong> from the <span class="No-Break">MVVM Toolkit.</span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>ObservableObject</h2>
<p>Implementing the <strong class="source-inline">INotifyPropertyChanged</strong> interface<a id="_idIndexMarker364"/> in each ViewModel can become<a id="_idIndexMarker365"/> tedious and repetitive. That’s why developers often create a base class that takes care of this task. The MVVM Toolkit provides such a base class for free in the form <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ObservableObject</strong></span><span class="No-Break">.</span></p>
<p>By inheriting from <strong class="source-inline">ObservableObject</strong>, your ViewModel classes can automatically notify the View of property changes, keeping the UI synchronized with the underlying data. <strong class="source-inline">ObservableObject</strong> also provides the <strong class="source-inline">SetProperty</strong> method, which allows developers to set a property’s value. As a result, if the value has changed, it automatically triggers the <strong class="source-inline">PropertyChanged</strong> event to update <span class="No-Break">the UI.</span></p>
<p>Let’s update our code so that our ViewModels inherit from <strong class="source-inline">ObservableObject</strong> instead of each one having its own implementation of the <span class="No-Break"><strong class="source-inline">INotifyPropertyChanged</strong></span><span class="No-Break"> interface:</span></p>
<ol>
<li>Head over to <strong class="source-inline">IngredientsListViewModel</strong> and let this class inherit from <strong class="source-inline">ObservableObject</strong> instead of implementing the <strong class="source-inline">INotifyPropertyChanged</strong> interface, as <span class="No-Break">seen here:</span><pre class="source-code">
<strong class="bold">using CommunityToolkit.Mvvm.ComponentModel;</strong>
namespace Recipes.Client.Core.ViewModels;
public class IngredientsListViewModel :
  <strong class="bold">ObservableObject</strong>
{
    private int _numberOfServings = 4;
    public int NumberOfServings
    {
        ...
    }
    //ToDo: add list of Ingredients
}</pre></li> <li>By inheriting <strong class="source-inline">ObservableObject</strong>, we can remove the <strong class="source-inline">OnPropertyChanged</strong> method and the <strong class="source-inline">PropertyChanged</strong> event that we <span class="No-Break">had before.</span></li>
<li>Next, we can update<a id="_idIndexMarker366"/> the setter of the <strong class="source-inline">NumberOfServings</strong> property<a id="_idIndexMarker367"/> so that it uses the <strong class="source-inline">SetProperty</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ObservableObject</strong></span><span class="No-Break">:</span><pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set =&gt; SetProperty(ref _numberOfServings, value);
}</pre><p class="list-inset">The <strong class="source-inline">SetProperty</strong> method eases the implementation of calling the <strong class="source-inline">PropertyChanged</strong> event when the value is being updated. This method will update the provided backing field (<strong class="source-inline">_numberOfServings</strong>) and trigger the <strong class="source-inline">PropertyChanged</strong> event automatically when the value is <span class="No-Break">being updated.</span></p></li> </ol>
<p>We can start doing <a id="_idIndexMarker368"/>the same thing<a id="_idIndexMarker369"/> for <strong class="source-inline">RecipeDetailViewModel</strong> <span class="No-Break">as well:</span></p>
<ol>
<li>Inherit <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">ObservableObject</strong></span><span class="No-Break">.</span></li>
<li>Remove the <strong class="source-inline">OnPropertyChanged</strong> method and the <span class="No-Break"><strong class="source-inline">PropertyChanged</strong></span><span class="No-Break"> event.</span></li>
<li>Update the setter of <strong class="source-inline">HideAllergenInformation</strong> so that it uses the <strong class="source-inline">SetProperty</strong> method, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
private bool _hideAllergenInformation = true;
public bool HideAllergenInformation
{
    get =&gt; _hideAllergenInformation;
    set =&gt; <strong class="bold">SetProperty(ref _hideAllergenInformation, value);</strong>
}</pre></li> </ol>
<p>By ensuring our ViewModels inherit from <strong class="source-inline">ObservableObject</strong> and utilize the <strong class="source-inline">SetProperty</strong> method, we can eliminate excessive boilerplate code. This would benefit us by reducing a significant amount of ceremony. This helps maintain the conciseness and clarity of our ViewModels, allowing them to stay focused on their core responsibilities. Unless you are being paid by lines of code, I think you would agree that these updated classes look a lot better with a lot less <span class="No-Break">boilerplate code!</span></p>
<p>One of the most helpful features<a id="_idIndexMarker370"/> in the MVVM Toolkit is the <a id="_idIndexMarker371"/>different <strong class="source-inline">ICommand</strong> implementations. Let’s take <span class="No-Break">a look!</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>RelayCommand</h2>
<p>The MVVM Toolkit provides<a id="_idIndexMarker372"/> several robust implementations of the <strong class="source-inline">ICommand</strong> interface. Each implementation serves a unique purpose, addressing varied needs for communication between the ViewModel and View in different scenarios. These implementations<a id="_idIndexMarker373"/> help streamline <span class="No-Break">command operations:</span></p>
<ul>
<li><strong class="source-inline">RelayCommand</strong>: This straightforward implementation of <strong class="source-inline">ICommand</strong> allows you to specify <strong class="source-inline">Execute</strong> and <strong class="source-inline">CanExecute</strong> methods using delegates, tailoring what the command does and whether it can be executed at a given time. This implementation is similar to <strong class="source-inline">Microsoft.Maui.Controls.Command</strong>, which we used earlier. However, the <strong class="source-inline">Command</strong> implementation had the <strong class="source-inline">ChangeCanExecute</strong> method, which we can call to trigger the re-evaluation of the <strong class="source-inline">CanExecute</strong> method. On the <strong class="source-inline">RelayCommand</strong> class, a method with this behavior is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">NotifyCanExecuteChanged</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">RelayCommand&lt;T&gt;</strong>: This is a variant of <strong class="source-inline">RelayCommand</strong> that adds support for a parameter that can be passed to the <strong class="source-inline">Execute</strong> and <strong class="source-inline">CanExecute</strong> methods. The type of the parameter is determined by the generic type parameter. This implementation is similar <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Microsoft.Maui.Controls.Command&lt;T&gt;</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">AsyncRelayCommand</strong>: An async variant of <strong class="source-inline">ICommand</strong>, <strong class="source-inline">AsyncRelayCommand</strong> returns a <strong class="source-inline">Task</strong>, making it ideal for managing asynchronous operations such as network <span class="No-Break">data fetches.</span></li>
<li><strong class="source-inline">AsyncRelayCommand&lt;T&gt;</strong>: A parameter-supporting version of <strong class="source-inline">AsyncRelayCommand</strong>, this allows you to pass an argument to the asynchronous <strong class="source-inline">Execute</strong> and <strong class="source-inline">CanExecute</strong> methods, providing additional versatility for <span class="No-Break">async operations.</span></li>
</ul>
<p>Let’s see how we can update our command so that it leverages the <strong class="source-inline">RelayCommand</strong> and <span class="No-Break"><strong class="source-inline">RelayCommand&lt;T&gt;</strong></span><span class="No-Break"> classes:</span></p>
<ol>
<li>The following code block shows how we can initialize the commands in the constructor by updating their type from <strong class="source-inline">Microsoft.Maui.Controls.Command</strong> to <strong class="source-inline">CommunityToolkit.Mvvm.Input.RelayCommand</strong> and from <strong class="source-inline">Microsoft.Maui.Controls.Command&lt;T&gt;</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CommunityToolkit.Mvvm.Input.RelayCommand&lt;T&gt;</strong></span><span class="No-Break">:</span><pre class="source-code">
public RecipeDetailViewModel()
{
    AddAsFavoriteCommand =
        <strong class="bold">new RelayCommand(AddAsFavorite,</strong>
<strong class="bold">          CanAddAsFavorite);</strong>
    RemoveAsFavoriteCommand =
        <strong class="bold">new RelayCommand(RemoveAsFavorite,</strong>
          <strong class="bold">CanRemoveAsFavorite);</strong>
    SetFavoriteCommand =
           <strong class="bold">new RelayCommand&lt;bool&gt;(SetFavorite,</strong>
             <strong class="bold">CanSetFavorite);</strong>
}</pre><p class="list-inset">This updated code will instantiate<a id="_idIndexMarker374"/> the three commands<a id="_idIndexMarker375"/> with a new <strong class="source-inline">RelayCommand</strong>, passing in the methods that should be triggered when calling the command’s <strong class="source-inline">Execute</strong> and <span class="No-Break"><strong class="source-inline">CanExecute</strong></span><span class="No-Break"> methods.</span></p></li> <li>While we are at it, we can also go ahead and update the types of the commands in this class. While <strong class="source-inline">RelayCommand</strong> implements the <strong class="source-inline">ICommand</strong> interface, it also implements the <span class="No-Break"><strong class="source-inline">IRelayCommand</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
public <strong class="bold">IRelayCommand</strong> AddAsFavoriteCommand
{
    get;
}
public <strong class="bold">IRelayCommand</strong> RemoveAsFavoriteCommand
{
    get;
}
public <strong class="bold">IRelayCommand</strong> SetFavoriteCommand
{
    get;
}</pre><p class="list-inset">By updating the type of our commands, as shown in the preceding snippet, we can avoid additional castings <span class="No-Break">later on.</span></p></li> <li>The setter of <strong class="source-inline">IsFavorite</strong> can now be<a id="_idIndexMarker376"/> updated<a id="_idIndexMarker377"/> <span class="No-Break">to this:</span><pre class="source-code">
public bool? IsFavorite
{
    get =&gt; _isFavorite;
    private set
    {
        <strong class="bold">if(SetProperty(ref _isFavorite, value))</strong>
        {
            <strong class="bold">AddAsFavoriteCommand</strong>
<strong class="bold">                .NotifyCanExecuteChanged()</strong>;
            <strong class="bold">RemoveAsFavoriteCommand</strong>
<strong class="bold">                .NotifyCanExecuteChanged()</strong>;
            <strong class="bold">SetFavoriteCommand</strong>
<strong class="bold">                .NotifyCanExecuteChanged()</strong>;
        }
    }
}</pre><p class="list-inset">The <strong class="source-inline">SetProperty</strong> method returns <strong class="source-inline">true</strong> if the property was changed. This allows us to do additional things when the property is changed (or not). For example, in this case, we want to re-evaluate the <strong class="source-inline">CanExecute</strong> method of the commands when the <strong class="source-inline">IsFavorite</strong> property changes its value by calling each command’s <span class="No-Break"><strong class="source-inline">NotifyCanExecuteChanged</strong></span><span class="No-Break"> method.</span></p></li> </ol>
<p class="callout-heading">Adhering to the best practices of MVVM</p>
<p class="callout">Because we don’t use <strong class="source-inline">Microsoft.Maui.Control.Command</strong> anymore, we can also remove the MAUI dependency<a id="_idIndexMarker378"/> that we currently have on this project. Click on the <strong class="source-inline">Recipes.Client.Core</strong> project so that the project’s <strong class="source-inline">.csproj</strong> file opens and remove the <strong class="source-inline">&lt;UseMaui&gt;</strong> tag. Now, the ViewModels (and the <strong class="source-inline">Recipes.Client.Core</strong> project) are platform-agnostic again, adhering to the best practices <span class="No-Break">of MVVM.</span></p>
<p>In <a href="B20941_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, it was apparent that applying the MVVM pattern involves a lot more code compared to writing everything in code-behind. Mostly, that’s because of all of the ceremony in the ViewModels. While classes such as <strong class="source-inline">ObservableObject</strong> already abstract away some of the boilerplate<a id="_idIndexMarker379"/> code, we could even go one step further and look at the Source Generators<a id="_idIndexMarker380"/> that are available in the <span class="No-Break">MVVM Toolkit.</span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Source Generators</h2>
<p>Source Generators <a id="_idIndexMarker381"/>are a compiler feature in .NET that allows developers <a id="_idIndexMarker382"/>to generate new code during the compilation process. This has the potential to greatly reduce manual coding and the likelihood <span class="No-Break">of errors.</span></p>
<p>The MVVM Toolkit provides <strong class="source-inline">ObservablePropertyAttribute</strong> and <strong class="source-inline">RelayCommandAttribute</strong>, which are used by the Source Generators to create properties that notify the UI of changes and commands that handle user interactions, respectively. Additionally, other attributes such as <strong class="source-inline">NotifyPropertyChangedForAttribute</strong> and <strong class="source-inline">NotifyCanExecuteChangedForAttribute</strong> can be used in combination with <strong class="source-inline">ObservablePropertyAttribute</strong> to add even more functionality through <span class="No-Break">code generation.</span></p>
<p>Given how Source Generators work, the class on which these attributes are applied must be declared as a partial class. In C#, partial classes allow you to split a class across multiple files using the <strong class="source-inline">partial</strong> keyword. At compile time, the different files are combined into one class. This feature is integral to source generators, which generate additional source code during compilation. Therefore, when you wish to use any of these attributes, remember to declare your ViewModel <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">partial</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
public <strong class="bold">partial</strong> class RecipeDetailViewModel :
  ObservableObject</pre> <p>Now that the ViewModel has been<a id="_idIndexMarker383"/> declared as partial, we can begin to adapt our code<a id="_idIndexMarker384"/> to take advantage of these attributes. Let’s see how this can <span class="No-Break">be done.</span></p>
<h3>Using the ObservableProperty attribute</h3>
<p>Typically, we need<a id="_idIndexMarker385"/> to write some boilerplate <a id="_idIndexMarker386"/>code when implementing a property that triggers the <strong class="source-inline">PropertyChanged</strong> event. By using <strong class="source-inline">ObservablePropertyAttribute</strong>, we can let Source Generators generate this code <span class="No-Break">for us.</span></p>
<p>This attribute can be applied to a field; at build time, a public property will be generated, with the annotated field as the <span class="No-Break">backing field.</span></p>
<p>As an example, we can take a look at <strong class="source-inline">RecipeDetailViewModel</strong>. The <strong class="source-inline">HideExtendedAllergenList</strong> property can be deleted and <strong class="source-inline">ObservablePropertyAttribute</strong> can be added to the <span class="No-Break"><strong class="source-inline">_hideExtendedAllergenList</strong></span><span class="No-Break"> field:</span></p>
<pre class="source-code">
<strong class="bold">[ObservableProperty]</strong>
private bool _hideExtendedAllergenList = true;</pre> <p>With this <strong class="source-inline">ObservableProperty</strong> attribute in place, a full-fledged public property named <strong class="source-inline">HideExtendedAllergenList</strong> will be generated at <span class="No-Break">build time.</span></p>
<p>The generated property’s set method will contain logic that checks whether the value is updated and triggers the <strong class="source-inline">PropertyChanged</strong> event accordingly. The setter will also call a handful of partial methods that are being generated, allowing us to add some custom code<a id="_idIndexMarker387"/> while the property<a id="_idIndexMarker388"/> value is <span class="No-Break">being updated.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">It’s very important to note that the <strong class="source-inline">ObservableProperty</strong> attribute generates a public property for us. When binding this value to the UI, make sure you bind to this generated property (<strong class="source-inline">HideExtendedAllergenList</strong>, in this case) and not try to bind to the field you’ve set the attribute on. Also, when assigning a value, always assign it to the generated property to make sure the <strong class="source-inline">PropertyChanged</strong> event <span class="No-Break">gets triggered!</span></p>
<p>But what about the <strong class="source-inline">IsFavorite</strong> property <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">?</span></p>
<p>In this setter, we call the <strong class="source-inline">NotifyCanExecuteChanged</strong> method of our commands. Can we make this work on a generated property as well? Yes; for those cases, we have the <strong class="source-inline">NotifyCanExecuteChangedFor</strong> attribute, which accepts the name of the command whose <strong class="source-inline">NotifyCanExecuteChanged</strong> method needs to be triggered when the value of the property is updated. This means that the entire <strong class="source-inline">IsFavorite</strong> property could be rewritten <span class="No-Break">like this:</span></p>
<pre class="source-code">
[ObservableProperty]
[NotifyCanExecuteChangedFor(nameof(AddAsFavoriteCommand))]
[NotifyCanExecuteChangedFor(nameof(RemoveAsFavoriteCommand))]
[NotifyCanExecuteChangedFor(nameof(SetFavoriteCommand))]
private bool? _isFavorite = false;</pre> <p>The first attribute, <strong class="source-inline">ObservableProperty</strong>, will generate a property that will trigger the <strong class="source-inline">PropertyChanged</strong> event when its value is being updated. The next three <strong class="source-inline">NotifyCanExecuteChangedFor</strong> attributes will make sure that the <strong class="source-inline">NotifyCanExecuteChanged</strong> method of the three commands of the <strong class="source-inline">IRelayCommand</strong> type will be invoked when the <span class="No-Break">property updates.</span></p>
<p>Speaking of commands, there’s a Source<a id="_idIndexMarker389"/> Generator<a id="_idIndexMarker390"/> for generating a <strong class="source-inline">RelayCommand</strong> as well. Let’s take <span class="No-Break">a look.</span></p>
<h3>Using the RelayCommand attribute</h3>
<p>You can apply the <strong class="source-inline">RelayCommand</strong> attribute to a method<a id="_idIndexMarker391"/> that you intend to use as the execution<a id="_idIndexMarker392"/> action for a command. At build time, this will generate a public <strong class="source-inline">RelayCommand</strong> property with the same name as the method, suffixed with “Command.” When calling the <strong class="source-inline">Execute</strong> method of the generated <strong class="source-inline">RelayCommand</strong>, the method on which the attribute was applied will be invoked. This essentially simplifies the process of declaring a public <strong class="source-inline">IRelayCommand</strong> command, making a method to be invoked, and creating an instance of the command tied to that method, in the following <span class="No-Break">simplified form:</span></p>
<pre class="source-code">
<strong class="bold">[RelayCommand]</strong>
private void RemoveAsFavorite() =&gt; IsFavorite = false;</pre> <p>This will generate a <strong class="source-inline">RemoveAsFavoriteCommand</strong> public property of type <strong class="source-inline">IRelayCommand</strong> that will call the <strong class="source-inline">RemoveAsFavorite</strong> method when the command is <span class="No-Break">being executed.</span></p>
<p>When applying this attribute to a method that accepts one parameter, the resulting command will be a generic <strong class="source-inline">RelayCommand&lt;T&gt;</strong>, where <strong class="source-inline">T</strong> corresponds to the type of <span class="No-Break">the parameter.</span></p>
<p>Alternatively, we can also pass in a string parameter called <strong class="source-inline">CanExecute</strong> that points to a method, which should be invoked when calling the command’s <strong class="source-inline">CanExecute</strong> method. This is essential if we want to update <strong class="source-inline">RecipeDetailViewModel</strong> and let <strong class="source-inline">AddAsFavoriteCommand</strong>, <strong class="source-inline">RemoveAsFavoriteCommand</strong>, and <strong class="source-inline">SetFavoriteCommand</strong> be generated by Source Generators. Let’s see how we can <span class="No-Break">achieve that:</span></p>
<ol>
<li>Delete the public <strong class="source-inline">AddAsFavoriteCommand</strong>, <strong class="source-inline">RemoveAsFavoriteCommand</strong>, and <strong class="source-inline">SetFavoriteCommand</strong> properties of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">IRelayCommand</strong></span><span class="No-Break">.</span></li>
<li>Delete the instantiation of these commands in the constructor <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">.</span></li>
<li>Add the <strong class="source-inline">RelayCommand</strong> attribute to the <strong class="source-inline">AddAsFavorite</strong>, <strong class="source-inline">RemoveAsFavorite</strong>, and <strong class="source-inline">SetFavorite</strong> methods, as <span class="No-Break">shown here:</span><pre class="source-code">
<strong class="bold">[RelayCommand(CanExecute = nameof(CanSetFavorite))]</strong>
private void SetFavorite(bool isFavorite)
    =&gt; IsFavorite = isFavorite;
<strong class="bold">[RelayCommand(CanExecute = nameof(CanAddAsFavorite))]</strong>
private void AddAsFavorite() =&gt; IsFavorite = true;
<strong class="bold">[RelayCommand(CanExecute = nameof</strong>
<strong class="bold">  (CanRemoveAsFavorite))]</strong>
private void RemoveAsFavorite() =&gt; IsFavorite = false;</pre><p class="list-inset">At build time, the public command will be generated thanks to the <strong class="source-inline">RelayCommand</strong> attributes. In this example, all of the attributes also point to a method that gets invoked when calling the generated command’s <span class="No-Break"><strong class="source-inline">CanExecute</strong></span><span class="No-Break"> method.</span></p></li> </ol>
<p>While Source Generators<a id="_idIndexMarker393"/> can greatly simplify code bases and improve<a id="_idIndexMarker394"/> productivity by automating boilerplate code, I choose not to use them for a couple <span class="No-Break">of reasons.</span></p>
<p>Firstly, they can obscure some of the underlying implementation details. This might make it challenging for newcomers or less experienced developers to fully understand the code and its <span class="No-Break">intrinsic patterns.</span></p>
<p>Secondly, employing the MVVM Toolkit’s Source Generators may require adjusting your coding style to match the “prescribed” style inherent to the toolkit. This may not appeal to all developers who prefer more flexibility in their <span class="No-Break">coding approach.</span></p>
<p>However, it’s essential to note that these are personal preferences, and many developers find great value in using Source Generators. They can significantly streamline your ViewModel development process, and if you find them beneficial and conducive to your coding style, I wholeheartedly recommend <span class="No-Break">their usage!</span></p>
<p>At the end of the day, Source Generators are a tool. Like any tool, it’s crucial to consider when and where they add the most value. Balancing the benefits of automation and simplicity with understanding, flexibility, and individual style in your code is always an important consideration in <span class="No-Break">software development.</span></p>
<p>This covers most of the essentials<a id="_idIndexMarker395"/> of the MVVM Toolkit. Now, let’s see how the .NET MAUI Community Toolkit<a id="_idIndexMarker396"/> can make our lives easier when applying the <span class="No-Break">MVVM pattern.</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>The .NET MAUI Community Toolkit</h1>
<p>The .<strong class="bold">NET MAUI Community Toolkit</strong> is a collection of useful components, controls, and utilities designed<a id="_idIndexMarker397"/> to enhance the development experience with .NET MAUI. Although its primary focus is not on enabling or facilitating MVVM, the toolkit does provide features that can greatly assist developers in implementing the MVVM pattern in their .NET <span class="No-Break">MAUI projects:</span></p>
<ul>
<li><strong class="bold">Behaviors</strong>: These are reusable pieces of functionality<a id="_idIndexMarker398"/> that can be attached to certain types of controls. By encapsulating code in behaviors, you can keep your views clean and easy <span class="No-Break">to understand.</span></li>
<li><strong class="bold">Converters</strong>: As we’ve seen before, converters<a id="_idIndexMarker399"/> help transform data from one type into another, making it easier to bind data from your ViewModel to your View. The toolkit has a lot of converters for a huge range of <span class="No-Break">common scenarios.</span></li>
</ul>
<p>There is much more to the .NET MAUI Community Toolkit, but in the context of MVVM, these are the relevant bits. Please note that this is a toolkit that should only be added to MAUI projects and not to the core project that houses your ViewModels, for example. Why? Because the .NET MAUI Community is .NET MAUI-dependent and therefore it should not be referenced to projects that are agnostic of <span class="No-Break">UI frameworks.</span></p>
<p>By offering these additional features and helpers, the .NET MAUI Community Toolkit contributes to a more efficient and streamlined development process when working with MVVM in .<span class="No-Break">NET MAUI.</span></p>
<p>Installing the .NET MAUI Community Toolkit is just like installing any other <span class="No-Break">NuGet package:</span></p>
<ol>
<li>Right-click the <strong class="source-inline">Recipes.Mobile</strong> project<a id="_idIndexMarker400"/> and select <strong class="bold">Manage </strong><span class="No-Break"><strong class="bold">NuGet Packages</strong></span><span class="No-Break">.</span></li>
<li>Search for <strong class="source-inline">Maui Community</strong> and select <strong class="bold">CommunityToolkit.Maui</strong> from the list. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em> shows the NuGet package we <span class="No-Break">should download:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 5.2: CommunityToolkit.Maui NuGet package" height="120" src="image/B20941_05_02.jpg" width="1528"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: CommunityToolkit.Maui NuGet package</p>
<ol>
<li value="3">Hit <strong class="bold">Install</strong> to add the NuGet package to the <span class="No-Break"><strong class="source-inline">Recipes.Mobile</strong></span><span class="No-Break"> project.</span></li>
<li>Once installed, head over to <strong class="source-inline">MauiProgram.cs</strong> and make sure you call <strong class="source-inline">UseMauiCommunityToolkit</strong> <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">MauiAppBuilder</strong></span><span class="No-Break">:</span><pre class="source-code">
builder.UseMauiCommunityToolkit();</pre></li> <li>To use components from the toolkit in XAML, you will need to add the namespace to the XAML pages where you want to use <span class="No-Break">the toolkit:</span><pre class="source-code">
</pre><p class="list-inset">Once all of this is in place, we can start using the .NET MAUI <span class="No-Break">Community Toolkit.</span></p></li> </ol>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Converters</h2>
<p>In <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Data Binding in .NET MAUI</em>, we discussed what value converters<a id="_idIndexMarker401"/> are and how to create them. The .NET MAUI Community Toolkit comes packed with a whole lot of ready-to-use value converters. One such converter is <strong class="source-inline">ListToStringConverter</strong>, which can be very handy for displaying a list of items as a single string. Let’s use it to display the allergen information of <span class="No-Break">the recipe:</span></p>
<ol>
<li>To start, let’s add an array of strings called <strong class="source-inline">Allergens</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
public string[] Allergens { get; }
    = new string[]{ "Milk", "Eggs", "Nuts", "Sesame" };</pre><p class="list-inset">This property holds a list of all allergens that the recipe contains. For now, we’re hardcoding some <span class="No-Break">values here.</span></p></li> <li>On <strong class="source-inline">RecipeDetailPage</strong>, add the <span class="No-Break">toolkit’s namespace:</span><pre class="source-code">
xmlns:toolkit=http://schemas.microsoft.com/dotnet/2022
  /maui/toolkit</pre><p class="list-inset">This will allow us to access the Community Toolkit<a id="_idIndexMarker402"/> library in XAML using the <span class="No-Break"><strong class="source-inline">toolkit</strong></span><span class="No-Break"> prefix.</span></p></li> <li>Add an instance of <strong class="source-inline">ListToStringConverter</strong> to the <span class="No-Break">page’s </span><span class="No-Break"><strong class="source-inline">Resources</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;ContentPage.Resources&gt;
    ...
    &lt;toolkit:ListToStringConverter
      x:Key="listToStringConverter" Separator=", " /&gt;
&lt;/ContentPage.Resources&gt;</pre><p class="list-inset"><strong class="source-inline">ListToStringConverter</strong> has a property called <strong class="source-inline">Separator</strong> that we set <span class="No-Break">to ",".</span></p></li> <li>Finally, we can update the label that should display the <span class="No-Break">allergen information:</span><pre class="source-code">
&lt;Label IsVisible="{Binding HideAllergenInformation,
  Mode=OneWay, Converter={StaticResource
    inverseBoolConverter}}"
   <strong class="bold">Text="{Binding Allergens, Converter={StaticResource</strong>
<strong class="bold">     listToStringConverter}}"</strong> /&gt;</pre><p class="list-inset">By using <strong class="source-inline">ListToStringConverter</strong>, we can bind the <strong class="source-inline">Allergens</strong> property of the ViewModel to the <strong class="source-inline">Text</strong> property of the label. This converter will take the items from the <strong class="source-inline">Allergens</strong> array and concatenate them to show them as one <span class="No-Break">string value.</span></p></li> </ol>
<p>This value converter and some other converters in the toolkit aren’t exactly rocket science. It’s something you could write yourself. However, in my opinion, why reinvent the wheel when someone has already done the hard work for you? Utilizing these ready-made tools can certainly<a id="_idIndexMarker403"/> make your coding <span class="No-Break">life easier!</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Behaviors</h2>
<p>Behaviors allow you to add functionality to <a id="_idIndexMarker404"/>UI controls without the need to build custom controls from scratch. This greatly helps in constructing rich and intuitive user interfaces tailored to your specific requirements. By encapsulating UI-specific actions within the View layer, behaviors help reduce the complexity of ViewModels, adhering to the separation of concerns principle central to MVVM. The .NET MAUI Community Toolkit comes with a variety of ready-to-use behaviors, saving you time and effort in enhancing <span class="No-Break">your UI.</span></p>
<p>One of the behaviors provided by the .NET MAUI Community Toolkit is <strong class="source-inline">EventToCommand</strong>, which allows you to map events to commands. This allows you to further enhance the decoupling of your UI and business logic. This behavior is particularly useful when dealing with events that do not directly support binding <span class="No-Break">to commands.</span></p>
<p>As a very simple example, let’s imagine that we want to collect some user behavior throughout the app. One of the things we might be interested in is whether the user scrolls on a recipe page or not, as that might indicate some level of interest in that particular recipe. <strong class="source-inline">ScrollView</strong> has a <strong class="source-inline">Scrolled</strong> event, but no corresponding command. In such a use case, <strong class="source-inline">EventToCommandBehavior</strong> can be very helpful, as I will show you in the <span class="No-Break">next steps:</span></p>
<ol>
<li>Create a <strong class="source-inline">RelayCommand</strong> on <strong class="source-inline">RecipeDetailViewModel</strong>, which needs to be invoked when the user scrolls on <span class="No-Break">the page:</span><pre class="source-code">
[RelayCommand]
private void UserIsBrowsing()
{
    //Do Logging
}</pre><p class="list-inset">In the preceding snippet, the <strong class="source-inline">RelayCommand</strong> attribute is used to generate <strong class="source-inline">UserIsBrowsingCommand</strong>, but you could <a id="_idIndexMarker405"/>write a <strong class="source-inline">RelayCommand</strong> yourself as well, <span class="No-Break">of course.</span></p></li> <li>Next, we can add <strong class="source-inline">EventToCommandBehavior</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ScrollView</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;ScrollView&gt;
    &lt;ScrollView.Behaviors&gt;
        &lt;toolkit:EventToCommandBehavior
          Command="{Binding UserIsBrowsingCommand}"
            EventName="Scrolled" /&gt;
    &lt;/ScrollView.Behaviors&gt;
    ...
&lt;/ScrollView&gt;</pre><p class="list-inset">The <strong class="source-inline">Command</strong> property of <strong class="source-inline">EventToCommandBehavior</strong> is bound to the <strong class="source-inline">UserIsBrowsingCommand</strong> property that we just created on the ViewModel. By setting the <strong class="source-inline">EventName</strong> property to <strong class="source-inline">"Scrolled"</strong>, we define that we want this command to be invoked on the <strong class="source-inline">Scrolled</strong> event <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ScrollView</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>As a final example to demonstrate<a id="_idIndexMarker406"/> how helpful this toolkit can be by combining behaviors and converters, imagine the following: a heart icon should always be shown on the screen, but only when the user has marked the recipe as a favorite, and it should be red. We can write this without adding a single line of C# code and without working with multiple icons! Let’s see how this <span class="No-Break">is done:</span></p>
<ol>
<li>Until now, in our <em class="italic">Recipes!</em> app, the favorite icon was a little misplaced. Let’s start by placing the favorite icon next to the recipe title. You can accomplish this by replacing the label that displays the recipe’s title with the following <span class="No-Break">XAML code:</span><pre class="source-code">
&lt;Grid ColumnDefinitions="*, Auto"&gt;
    &lt;Label
        FontAttributes="Bold" FontSize="22"
        Text="{Binding Path=Title, Mode=OneTime}"
        VerticalOptions="Center" /&gt;
    &lt;Image
        x:Name="favoriteIcon"
        Grid.Column="1" Margin="5"
        HeightRequest="35" Source="favorite.png"
        VerticalOptions="Center" WidthRequest="35"&gt;
    &lt;/Image&gt;
&lt;/Grid&gt;</pre><p class="list-inset">Now, the favorite icon will permanently appear right next to the <span class="No-Break">recipe’s title.</span></p></li> <li>The .NET MAUI Community Toolkit<a id="_idIndexMarker407"/> offers <strong class="source-inline">IconTintColorBehavior</strong>, which we can apply to change the color of <strong class="source-inline">favoriteIcon</strong>. We can add this behavior to <span class="No-Break">our image:</span><pre class="source-code">
&lt;Image
    x:Name="favoriteIcon"
    ...&gt;
    &lt;Image.Behaviors&gt;
        &lt;toolkit:IconTintColorBehavior
            TintColor="#E9E9E9E9" /&gt;
    &lt;/Image.Behaviors&gt;
&lt;/Image&gt;</pre><p class="list-inset">After adding this behavior, the icon will take on the <span class="No-Break">specified </span><span class="No-Break"><strong class="source-inline">TintColor</strong></span><span class="No-Break">.</span></p></li> <li>Now, we need<a id="_idIndexMarker408"/> to set the <strong class="source-inline">TintColor</strong> value based on the <strong class="source-inline">IsFavorite</strong> property of <strong class="source-inline">RecipeDetailViewModel</strong>. Conveniently, the toolkit provides <strong class="source-inline">BoolToObjectConverter</strong>, which we can utilize to convert a <strong class="source-inline">boolean</strong> value into another value. We can add an instance of it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipeDetailPage</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;toolkit:BoolToObjectConverter
    x:Key="isFavoriteToColorConverter"
    x:TypeArguments="Color"
    FalseObject="#E9E9E9E9"
    TrueObject="#FF0000" /&gt;</pre></li> <li>By setting this instance’s <strong class="source-inline">TypeArguments</strong> to <strong class="source-inline">"Color"</strong>, we specify that we want to convert a <strong class="source-inline">bool</strong> value into a <strong class="source-inline">Color</strong> value. The <strong class="source-inline">FalseObject</strong> and <strong class="source-inline">TrueObject</strong> properties set the values that the converter should return for false and <span class="No-Break">true, respectively.</span></li>
<li>The last step is to update <strong class="source-inline">IconTintColorBehavior</strong> on the image. The challenge is binding the <strong class="source-inline">TintColor</strong> property of the behavior to the <strong class="source-inline">IsFavorite</strong> property of <strong class="source-inline">RecipeDetailViewModel</strong>. Since behaviors do not inherit their <strong class="source-inline">BindingContext</strong> from the controls they’re defined on, we’ll use <strong class="source-inline">ElementBinding</strong> to access <strong class="source-inline">RecipeDetailViewModel</strong> through the <strong class="source-inline">BindingContext</strong> of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">favoriteIcon</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;toolkit:IconTintColorBehavior <strong class="bold">TintColor="{Binding</strong>
<strong class="bold">  Source={x:Reference favoriteIcon},</strong>
<strong class="bold">    Path=BindingContext.IsFavorite,</strong>
<strong class="bold">      Converter={StaticResource</strong>
<strong class="bold">        isFavoriteToColorConverter}}"</strong> /&gt;</pre><p class="list-inset">Now, <strong class="source-inline">TintColor</strong> is effectively bound to the <strong class="source-inline">IsFavorite</strong> property on the ViewModel and <strong class="source-inline">isFavoriteToColorConverter</strong> determines the color <span class="No-Break">to use.</span></p></li> </ol>
<p>The .NET MAUI Community Toolkit is an invaluable resource that streamlines the development process. It offers a wide variety of reusable building blocks, reducing the necessity for duplicative work and allowing you to focus on creating unique application features. With components such as behaviors, converters, and more, the toolkit empowers developers to build rich and interactive user experiences with less effort and complexity. Although the toolkit isn’t focused on MVVM, it helps in implementing the MVVM pattern by offering handy <a id="_idIndexMarker409"/>features such as behaviors, converters, <span class="No-Break">and more.</span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Other popular frameworks</h1>
<p>As mentioned earlier, there are numerous MVVM frameworks available, each with its unique characteristics and advantages. Throughout this chapter, we’ve explored the MVVM Toolkit and .NET MAUI Community Toolkit. These toolkits, being community-driven and highly accessible, offer a variety of useful tools to simplify your <span class="No-Break">MVVM code.</span></p>
<p>However, the landscape of MVVM frameworks is vast, so it might be worth seeing what other frameworks can provide. Here’s a list<a id="_idIndexMarker410"/> of some of the most<a id="_idIndexMarker411"/> popular<a id="_idIndexMarker412"/> third-party<a id="_idIndexMarker413"/> MVVM frameworks<a id="_idIndexMarker414"/> that are compatible with .<span class="No-Break">NET MAUI:</span></p>
<ul>
<li><span class="No-Break">ReactiveUI: </span><a href="https://www.reactiveui.net/"><span class="No-Break">https://www.reactiveui.net/</span></a></li>
<li>Prism <span class="No-Break">Library: </span><a href="https://prismlibrary.com/"><span class="No-Break">https://prismlibrary.com/</span></a></li>
<li><span class="No-Break">TinyMvvm: </span><a href="https://github.com/dhindrik/TinyMvvm"><span class="No-Break">https://github.com/dhindrik/TinyMvvm</span></a></li>
<li><span class="No-Break">FreshMvvm: </span><a href="https://github.com/XAM-Consulting/FreshMvvm.Maui"><span class="No-Break">https://github.com/XAM-Consulting/FreshMvvm.Maui</span></a></li>
</ul>
<p>Whether you are seeking a simple toolkit for the basics or a comprehensive framework with advanced capabilities, you will soon discover a framework that would best suit your specific needs and align with your coding style. However, it’s important to remember that using an MVVM framework is not a prerequisite for effective MVVM. It is entirely possible to implement the MVVM pattern effectively without a dedicated framework. Ultimately, the choice of whether to use a framework – and if so, which one – should depend on your project’s requirements, your team’s familiarity with the framework, and your personal coding preferences.<em class="italic"> Remember, tools are there to assist you, not dictate how </em><span class="No-Break"><em class="italic">you code.</em></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Contributing to the community</h1>
<p>As we wrap up this chapter, it’s important<a id="_idIndexMarker415"/> to recognize that these third-party toolkits and frameworks are, at their core, community contributions. They’re the result of someone else’s hard work, thought, and passion. All this code is accessible to you on platforms such as GitHub, and it’s maintained by community-minded individuals who are always open to suggestions, improvements, and <span class="No-Break">bug reports.</span></p>
<p>Remember, contributing to the community isn’t limited to creating a new project or toolkit of your own. It can be as simple as reporting a bug, suggesting a feature, or even making a small code improvement on an open source project. This open source ethos is one of the key strengths of the .<span class="No-Break">NET ecosystem.</span></p>
<p>So, if you’re using these frameworks and see something that can be improved or a bug that needs fixing, don’t hesitate to contribute. By doing so, you’ll not only improve the tool for yourself but also for other developers who use it. This way, you can give back to the community and maybe learn a thing or two in <span class="No-Break">the process.</span></p>
<p>In conclusion, never forget that these open source MVVM frameworks are not just tools for you to use, but they’re also opportunities<a id="_idIndexMarker416"/> for you to grow as a developer and contribute to the broader .<span class="No-Break">NET community.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Summary</h1>
<p>To summarize, both the MVVM Toolkit and .NET MAUI Community Toolkit offer a comprehensive collection of components that facilitate the implementation of the MVVM pattern in your applications. By using these toolkits, you can avoid the need to build everything from scratch or reinvent existing solutions, ultimately saving time and effort, and allowing you to focus on building <span class="No-Break">your application.</span></p>
<p>Throughout the rest of the code samples in this book, we’ll be using the MVVM Toolkit and make use of classes such as <strong class="source-inline">ObservableObject</strong> and <strong class="source-inline">RelayCommand</strong>. These classes are quite straightforward to understand. Even if you choose not to use this toolkit, you should still find the code samples clear and comprehensible as the underlying concepts are not <span class="No-Break">overly complex.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li>Introduction to the MVVM <span class="No-Break">Toolkit: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/</span></a></li>
<li>.NET MAUI Community Toolkit <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/maui/</span></a></li>
<li>.NET MAUI Community Toolkit <span class="No-Break">converters: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/</span></a></li>
<li>.NET MAUI Community Toolkit <span class="No-Break">behaviors: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/</span></a></li>
<li><span class="No-Break"><strong class="source-inline">ObservablePropertyAttribute</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty</span></a></li>
<li><span class="No-Break"><strong class="source-inline">RelayCommandAttribute</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand</span></a></li>
</ul>
</div>
</div></body></html>