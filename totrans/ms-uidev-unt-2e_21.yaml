- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Unity UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optimization** is the process that we use to make sure that our game runs
    smoothly and the framerate is consistent. Through optimization we first locate
    resources within our game that are reducing our game’s performance and then implement
    solutions that will improve that performance.'
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of things that can cause a game to have poor performance or low
    framerate. This can include things like unoptimized lighting, poorly written scripts,
    large assets, and improper UI construction. Since this is a UI book, we’ll focus
    only on how improving your UI construction can improve your performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Key terms and basic information related to optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the tools provided within unity that can help you determine how
    performant your game is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various optimization strategies for UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you can optimize your UI, you need to learn how to tell if it is performant
    or not. Let’s review some basic terms and principles of graphics rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will only cover performance profiling on a basic level and its
    focus will be more on things you can do to build better UI. If, by the end of
    the chapter, you’d like more information on performance profiling, I suggest the
    following resource: [https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound](https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound)'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I stated earlier, optimization is the process that we use to make sure that
    our application runs smoothly, and the framerate is consistent. We want to optimize
    our game to ensure that all players have the same experience regardless of the
    conditions in which they are playing. So, for example, if we are making a PC game,
    we want to make sure that every player has the same experience regardless of the
    power of their machine. We also want to make sure if a player has many things
    rendering on the screen, the game does not lag compared to when there were less
    things rendering on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We do not want the frame rate to reduce, and we do not want the inputs to lag.
    This is extremely important for things like games. In something like a first-person
    shooter or platform this could a lag in input could mean a player loses a match
    or falls off a cliff.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review some basic terminology that you hear often when discussing optimization.
    First, we’ll start with a common metric for determining an application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: Frame Rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Framerate** is one metric in which we measure our application’s optimization.
    It’s a good metric, because it’s not just something that is happening in the background
    that the user never notices. Users can see and notice changes in framerate, so
    measuring its performance measures how our users experience our games.'
  prefs: []
  type: TYPE_NORMAL
- en: Framerate can be measured in **frames per second** (**fps**) or time in milliseconds.
    The goal is to have a consistent framerate regardless of what is happening in
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: When measuring framerate in frames per second, each individual frame renders
    out in a certain amount of time. Let’s say you have a goal of 60 fps. You would
    need to make sure that all aspects of your application can run at 60 fps. So,
    your goal is to have a consistent number of frames per second. Therefore, when
    we set a fps benchmark, that means we want our application to run at that fps
    consistently across all parts of the application. We don’t want our game to run
    at 60 fps at the beginning and then dip when our UI opens.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to measure framerate is time in milliseconds. Every frame takes
    some amount of time to render. We want that amount of time to be as low as possible
    for each frame. 10 ms per frame is the equivalent of 60 fps and is a good time
    in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed what frame rate is, let’s talk about where resources
    are used on our computer.
  prefs: []
  type: TYPE_NORMAL
- en: GPU and CPU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When trying to optimize your game, you will investigate your game’s resources
    to determine where the most resources are being used. You will want to identify
    whether the issues are on the GPU or CPU. The **Central Processing Unit** (**CPU**)
    is the brain of the computer. The **Graphics Processing Unit** (**GPU**), is what
    renders images. Whether our resources are on the GPU or CPU will determine the
    optimization solution.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of problems on the CPU are too many instructions, meaning too many
    scripts are running or the scripts take too long to run. Problems with the GPU
    tend to mean too many things are being rendered. The CPU does still play a part
    in rendering, however, as the CPU gives out the instructions and tells the GPU
    what to render. Often when discussing GPU and CPU, you’ll hear the term **draw
    calls**. A draw call is when the CPU tells the GPU it needs to draw (or display)
    something on the screen. In general, you want to reduce the number of draw calls
    your game makes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss GPU and CPU and how various choices we make designing our UI are
    affected by GPU and CPU more thoroughly in future sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered some basic concepts of optimization, let’s review some
    tools provided by Unity that help us with optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for determining performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When determining your game’s performance, you may use what is called benchmarking.
    **Benchmarking** allows you to see how well your app is running at various times
    under given conditions. When benchmarking, you collect performance metrics and
    establish a baseline, or benchmark metric. You then compare subsequent results
    to that benchmark to see if the metric has improved or worsened. This lets you
    know if changes you have made have affected your game’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few tools provided by Unity that can help you assess the performance
    of your game by providing you performance metrics. Let’s look at those tools now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware of the environment and what you are benchmarking. It’s recommended
    that you benchmark on your target platform. That way you can determine the minimum
    standard device you plan to run your game on. The performance of your game will
    only get better with a better device.
  prefs: []
  type: TYPE_NORMAL
- en: Statistics window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One simple way to view the performance of your game is through the **Statistics**
    window (or **Stats** windows) of the **Game** view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1: Analyzing the Stats Window](img/B18327_17_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: Analyzing the Stats Window'
  prefs: []
  type: TYPE_NORMAL
- en: If you select the **Stats** button in the top right corner of your **Game**
    view, you’ll see various information about your project. Under the **Graphics**
    section, you’ll see frame rate in both frames per second and time in milliseconds.
    This will continuously change as it is based on each frame. You also see information
    about the CPU main thread and render thread.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using frame rate as your benchmark, you can watch the framerate values
    here and see how they change over time. Remember, the goal is consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the stats window, here: [https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#](https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#)'
  prefs: []
  type: TYPE_NORMAL
- en: The **Stats** window gives some at a glance basic information about your game’s
    performance. However, if you want a more in-depth breakdown of how your game is
    running, you can use the Unity Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Profiler shows you detailed information about your game’s performance. To
    view the Profiler, select **Window** | **Analysis** | **Profiler**. When you play
    the game, you can then see which items are responsible for performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2: Viewing the Unity Profiler](img/B18327_17_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: Viewing the Unity Profiler'
  prefs: []
  type: TYPE_NORMAL
- en: Within the **Profiler**, you can select the UI Modules only to narrow down how
    each of your individual UI elements are affecting your performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3: Enabling only the UI Profiler Modules](img/B18327_17_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Enabling only the UI Profiler Modules'
  prefs: []
  type: TYPE_NORMAL
- en: After doing so, you can see information about each individual Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4: Observing the UI Objects in the Profiler](img/B18327_17_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: Observing the UI Objects in the Profiler'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the Unity Profiler and how to use it here: [https://docs.unity3d.com/Manual/Profiler.xhtml](https://docs.unity3d.com/Manual/Profiler.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in how items in your game are being batched, you can use
    the Unity Frame Debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Frame Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Frame Debugger can help you troubleshoot batching issues with your UI. You
    can access the Frame Debugger via **Window** | **Analysis** | **Frame Debugger**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5: Reviewing the Frame Debugger](img/B18327_17_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Reviewing the Frame Debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Frame Debugger will allow you to see various rendering events.
    Clicking on them will step forward in the Game window, giving you a preview of
    the event. This will show you which items are being combined into batches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the Frame Debugger here: [https://docs.unity3d.com/Manual/frame-debugger-window.xhtml](https://docs.unity3d.com/Manual/frame-debugger-window.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the basics of optimization, we can start talking about
    ways to optimize your UI.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Unity UI Optimization Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, each Canvas has its own Canvas Renderer component. Canvases combine
    all their elements into batches that are rendered together. A Canvas is considered
    **dirty**, if its geometry needs to be rebuilt. One of the main goals of optimizing
    UI is to reduce the number of times a Canvas or its elements are considered dirty,
    to reduce the number of times that the Canvas needs to be rebatched. With that
    in mind, let’s look at some techniques for optimizing Unity UI.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple Canvases and Canvas Hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever an element on a Canvas is modified, the Canvas is considered dirty,
    and a draw call is sent to the GPU. If there are multiple items on the Canvas,
    all the items on the Canvas will need to be reanalyzed to determine how best they
    should be drawn. So, changing one element on the Canvas requires the CPU to rebuild
    every element on the Canvas, potentially causing a sudden surge in CPU usage.
    Due to this, you should put your UI on multiple Canvases.
  prefs: []
  type: TYPE_NORMAL
- en: When determining how to group your Canvases, consider how often the items on
    the Canvas will need to be changed. It is good practice to group all static UI
    element on separate Canvases from items that are dynamic. This will stop the static
    items from having to be redrawn whenever the dynamic items change. Additionally,
    split dynamic elements into Canvases based on when they will update, trying to
    keep ones that update at the same time together.
  prefs: []
  type: TYPE_NORMAL
- en: Other aspects to consider when attempting to reduce draw calls on Canvases are
    the elements z-coordinates, textures, and materials. Grouping UI elements based
    on these properties can also reduce your CPU usage with regards to UI.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the use of Layout Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GetComponent` for each parent object that has a Layout Groups. This makes
    nested Layout Groups very non-performant.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, you could simply not use Layout Groups. Instead, you could use
    Anchors and write your own layout code for dynamically placing items.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding them entirely isn’t necessarily the best solution for everyone, however,
    so if you do choose to use them, try to avoid nested Layout Groups or layout groups
    with very large amounts of children. You can also choose to use layout groups
    for dynamic elements only and avoid them with static elements. You can also disable
    them as soon as dynamic UI has been properly positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding objects appropriately
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to hide elements on a Canvas, it is best to disable the entire Canvas
    component if possible. Remember, the Canvas component is what renders the UI,
    so disabling the Canvas component will cause it to stop rendering. It is recommended
    you disable the Canvas component rather than simply changing the visibility of
    the Canvas, because the Canvas component will continue to make draw calls, even
    if it is not visible. Disabling the component does not cause the Canvas to rebuild.
    This is less expensive than enabling and disabling the Canvas GameObject, as that
    will trigger the `OnEnable` and `OnDisable` methods.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to hide everything in your game with UI, for example you have a
    pause menu that completely covers your screen, you should stop the camera from
    rendering anything in your game other than the UI. For example, if you have a
    menu that completely covers the screen, even though you cannot see the items behind
    the menu, they are still being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Appropriately time object pooling enabling and disabling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Object pooling** is an optimization technique used to reduce the number of
    times repeatable objects are created (or instantiated). When object pooling, you
    place a collection of disabled objects in a pool at the start of the game and
    then, rather that instantiating those objects while the game is playing, you pull
    them from the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling is a great way to improve the performance of your game, because
    it reduces the number of times an object has to be created by creating a collection
    of objects that can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the concept of object pooling, visit the following
    site: [https://learn.unity.com/tutorial/introduction-to-object-pooling](https://learn.unity.com/tutorial/introduction-to-object-pooling)'
  prefs: []
  type: TYPE_NORMAL
- en: Because reparenting UI objects causes a Canvas to be marked as dirty, you want
    to carefully time your disabling, enabling, and reparenting when using an object
    pool. Since dynamic changes to elements within a Canvas cause the Canvas to send
    a draw call to the GPU, inappropriately parenting items before or after disabling
    them, can double up your draw calls unnecessarily. The goal, is to not cause the
    objects in the pool to send any draw calls to the GPU. So, objects in the pool
    should only ever be parented to the pool in a disabled state.
  prefs: []
  type: TYPE_NORMAL
- en: If you are placing an object in an object pool, disable it, then reparent it
    into the pool. By making sure it is disabled before being placed in the pool,
    you will remove the need for the pool to need rebuilding. Conversely, if you want
    to remove an object from the pool, reparent it, then enable it. This too will
    remove the need for the pool to send a draw call.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing Raycast computations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every UI Image component has the property **Raycast Target**. By default, this
    is selected. If you do not wish for your UI element to block raycasts, disable
    this to reduce raycasting checks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6: The Raycast Target property](img/B18327_17_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: The Raycast Target property'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if your UI is not interactable at all, you can remove the Graphic
    Raycaster component to remove the unnecessary calculation it causes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7: The Graphic Raycaster component](img/B18327_17_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: The Graphic Raycaster component'
  prefs: []
  type: TYPE_NORMAL
- en: Using the basic Unity UI optimization strategies covered in this chapter will
    have you well on your way to creating UI that does not inversely affect the performance
    of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the basics of optimizing Unity UI. We reviewed
    some fundamental concepts of optimizing in Unity, looked at the tools that allow
    us to assess our game’s performance, and then discussed strategies for creating
    performant UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focused only on how to improve the performance of your game through
    UI. But remember there are multiple aspects of your game that can cause it to
    have performance issues. For a good resource on improving the performance of all
    aspects of your game, I suggest reviewing the free ebook provided by unity on
    optimization: [https://resources.unity.com/games/performance-optimization-e-book-console-pc](https://resources.unity.com/games/performance-optimization-e-book-console-pc)'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about a new UI system created by unity called
    the new unity UI toolkit. It can be used to create UI not only during runtime
    but also within the editor. Thus, it can be used to help you create tools to improve
    your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on optimizing UI, I recommend the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.unity.com/tutorial/optimizing-unity-ui#](https://learn.unity.com/tutorial/optimizing-unity-ui#)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unity.com/how-to/unity-ui-optimization-tips](https://unity.com/how-to/unity-ui-optimization-tips)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=FPotgj_NHK4](https://www.youtube.com/watch?v=FPotgj_NHK4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
