<html><head></head><body>
		<div><h1 id="_idParaDest-186" class="chapter-number"><a id="_idTextAnchor209"/>9</h1>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor210"/>Enhancing Applications with Community Toolkits</h1>
			<p>The <strong class="bold">Windows Community Toolkit</strong> (<strong class="bold">WCT</strong>) and the <strong class="bold">.NET Community Toolkit</strong> are collections <a id="_idIndexMarker656"/>of open<a id="_idIndexMarker657"/> source <a id="_idIndexMarker658"/>libraries for <a id="_idIndexMarker659"/>Windows<a id="_idIndexMarker660"/> and .NET developers. The toolkits <a id="_idIndexMarker661"/>contain controls and libraries that can be leveraged by the <strong class="bold">Windows UI Library</strong> (<strong class="bold">WinUI</strong>), <strong class="bold">Universal Windows Platform</strong> (<strong class="bold">UWP</strong>), .<strong class="bold">NET Multi-platform App UI</strong> (<strong class="bold">.NET MAUI</strong>), <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>), and <strong class="bold">Windows Forms</strong> (<strong class="bold">WinForms</strong>) applications. In the <strong class="bold">Microsoft Store</strong>, there is a <a id="_idIndexMarker662"/>companion sample application for the <a id="_idIndexMarker663"/>WCT that developers can install to explore the controls and learn how to use them.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Learning about the background and purpose of the toolkits</li>
				<li>Using the toolkit sample application to explore the controls available in the WCT</li>
				<li>Leveraging toolkit controls in a WinUI project</li>
				<li>Exploring the helpers, services, and extensions for Windows developers in the WCT</li>
				<li>Discovering what’s available in the .NET Community Toolkit for WinUI developers</li>
			</ul>
			<p>By the end of this chapter, you will understand the WCT and how it can boost your productivity when building Windows applications. You will also know how to incorporate its controls into your WinUI applic<a id="_idTextAnchor211"/><a id="_idTextAnchor212"/>ations.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor213"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, the following software is required:</p>
			<ul>
				<li>Windows 10 version 1809 (build 17763) or newer</li>
				<li>Visual Studio 2022 or newer with the .NET desktop development workload configured for Windows App SDK development</li>
			</ul>
			<p>The source code for this chapter is available on GitHub at <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter09">https://github.com/Packt Publishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter09</a>.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor214"/>Introducing the WCT</h1>
			<p>The <a id="_idIndexMarker664"/>WCT was cr<a id="_idTextAnchor215"/>eated by Microsoft as an open source collection of controls and other helpers, tools, and services for Windows developers. It is primarily used by UWP developers but also adds value for WinUI, WinForms, and WPF developers. The toolkit is available to developers as a set of NuGet packages. There are over a dozen toolkit packages available on NuGet that can be installed independently, depending on the needs of your project. We will explore some of these packages throughout this chapter. Let’s start by discussing the history of the WCT.</p>
			<p>The<a id="_idIndexMarker665"/> toolkit was open sourced<a id="_idTextAnchor216"/> from the very beginning. It has long been available on GitHub at <a href="https://github.com/CommunityToolkit/WindowsCommunityToolkit">https://github.com/CommunityToolkit/WindowsCommunityToolkit</a>, but the next generation of the toolkit is being hosted at <a href="https://github.com/CommunityToolkit/Windows">https://github.com/CommunityToolkit/Windows</a>. This new iteration of the toolkit is aimed toward helping WinUI 2, WinUI 3, and <strong class="bold">Uno Platform</strong> developers, but this new toolkit doesn’t have any releases available yet. The toolkit is open to community contributions if you’re interested in helping to move the project forward. The documentation for the WCT<a id="_idIndexMarker666"/> is available on <em class="italic">Microsoft Learn</em> at <a href="https://learn.microsoft.com/windows/communitytoolkit/">https://learn.microsoft.com/windows/communitytoolkit/</a>.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor219"/>Origins of the WCT</h2>
			<p>The <a id="_idIndexMarker667"/>WC<a id="_idTextAnchor220"/>T was first introduced as the <strong class="bold">UWP Community Toolkit</strong> in <a id="_idIndexMarker668"/>2016. As the name implies, it was originally a toolkit solely for UWP developers. The toolkit was created to simp<a id="_idTextAnchor221"/>lify UWP app development by providing controls and helpers that Windows developers frequently create for their own common libraries. The idea of creating a toolkit for XAML development is not a new one. There have been several other similar projects for other platforms, including the following:</p>
			<ul>
				<li><strong class="bold">WPF Toolkit</strong> (<a href="https://github.com/dotnetprojects/wpftoolkit">https://github.com/dotnetprojects/wpftoolkit</a>): A set of WPF open source controls and<a id="_idIndexMarker669"/> other components, origina<a id="_idTextAnchor223"/>lly hosted by Microsoft<a id="_idIndexMarker670"/> on <strong class="bold">CodePlex</strong>.</li>
				<li><strong class="bold">Extended WPF Toolkit</strong> (<a href="https://github.com/xceedsoftware/wpftoolkit">https://github.com/xceedsoftware/wpftoolkit</a>): <a id="_idTextAnchor224"/>An open source collection of <a id="_idIndexMarker671"/>controls maintained <a id="_idIndexMarker672"/>by <strong class="bold">Xceed Software</strong>, intended t<a id="_idTextAnchor225"/>o complement the original WPF Toolkit.</li>
				<li><strong class="bold">Xamarin Community </strong><strong class="bold">Toolkit</strong> (<a href="https://github.com/xamarin/XamarinCommunityToolkit">https://github.com/xamarin/Xamarin CommunityToolkit</a>): An<a id="_idIndexMarker673"/> open sou<a id="_idTextAnchor226"/>rce collection <a id="_idIndexMarker674"/>of <strong class="bold">Xamarin</strong> controls, animations, behaviors, and effects for <strong class="bold">Xamarin.Forms</strong>. As <a id="_idIndexMarker675"/>Xamarin developers<a id="_idIndexMarker676"/> move to <strong class="bold">.NET MAUI</strong>, there<a id="_idIndexMarker677"/> is now a <strong class="bold">.NET MAUI Community Toolkit</strong> too (<a href="https://github.com/CommunityToolkit/Maui">https://github.com/CommunityToolkit/Maui</a>).</li>
			</ul>
			<p>Microsoft, with <a id="_idIndexMarker678"/>help from the open source community, released regular updates to the toolkit, adding new and enhanced components and controls multiple times a year. In spring 2018, shortly before the release of v3.0, they announced the toolkit’s new name: <em class="italic">Windows Community Toolkit</em>. This renaming signaled the team’s intent to embrace all Windows developers moving forward.</p>
			<p>WCT<a id="_idTextAnchor227"/> 3.0 included a legacy Microsoft Edge-based <code>WebView</code> control—not to be confused with <code>WebView2</code>, which we will cover later in this chapter—for WPF and WinForms applications. The release also added code samples to Visual Basic, which is still used in many legacy Windows desktop code bases.</p>
			<p>Another purpose of the toolkit was to allow developers to work on new controls with the hope that some would be integrated into the Windows SDK at a later date (or alternatively, the WinUI libraries). This has happened with several controls over the years since the toolkit’s introduction, including<a id="_idIndexMarker679"/> the <code>WebView</code> control.</p>
			<p>Subsequent toolkit releases have continued to add value for both UWP and desktop developers, and these releases have been fueled by c<a id="_idTextAnchor228"/><a id="_idTextAnchor229"/>ommunity contributions.</p>
			<h2 id="_idParaDest-191">Reviewing recent tool<a id="_idTextAnchor230"/>kit releases</h2>
			<p>There have <a id="_idIndexMarker680"/>been several major releases of the WCT since version 3.0. It was WCT version 7.0 that first added WinUI 3 support.</p>
			<p>In August 2018, WCT 4.0 added<a id="_idIndexMarker681"/> a <code>DataGrid</code> control, a feature long desired by UWP developers who were familiar with the <code>DataGrid</code> control available on the Silverlight and WPF platforms. This was quickly followed by a fall 2018 release of version 5. This <a id="_idTextAnchor231"/>release brought two major features to the toolkit, as follows:</p>
			<ul>
				<li><code>Wind<a id="_idTextAnchor232"/>owsXamlHost</code>: This<a id="_idIndexMarker682"/> control enabled a single UWP control to be wrapped and hosted within a WPF or WinForms control. Later, the <code>WindowsXamlHost</code> control would be known as XAML Islands, with the hosting API added to the Windows SDK. Several <em class="italic">wrapped controls</em> were also released, including <code>Ink<a id="_idTextAnchor233"/>Canvas</code>, <code>MapControl</code>, and an update to the legacy <code>WebView</code> control.</li>
				<li><code>TabView</code>: Behind <code>DataGrid</code>, <a id="_idTextAnchor234"/>a rich <code>TabView</code> control<a id="_idIndexMarker683"/> was probably<a id="_idTextAnchor235"/> the most requested control not yet available to UWP developers. The WCT <code>TabView</code> control included support for customizing, closing, and dragging and dropping tabs. <code>TabView</code> has also graduated to the WinUI 2 libraries, becoming available in WinUI 2.2 and later.</li>
			</ul>
			<p>A ye<a id="_idTextAnchor236"/>ar later, in fall 2019, WCT 6.0 brought XAML Islands controls to all WinForms, WPF, and C++ Win32 developers, adding support for .NET Core 3 clients. The other major improvement in this release was adding ARM64 development support. In June 2020, the team announced WCT 6.1, as well as upcoming previews of versions 7 and 8. Several previews of WCT 7.0 were released in 2020, and its final release came out in March 2021. The toolkit’s 7.0 release included major project refactorings plus several major features. The most exciting feature was the first release<a id="_idIndexMarker684"/> of the <code>ViewModel</code> classes.</p>
			<p>WCT 7.1 was released in September 2021. It added some helper classes for Microsoft Graph and the Microsoft Identity platform, as well as some new controls, behaviors, shadows, and styles. In November 2021, version 7.1.2 was released. This was announced as the final release to include updates to .NET libraries in the toolkit, as these are all moving to the .NET Community Toolkit. All subsequent 7.x releases have been UWP-only updates.</p>
			<p>The<a id="_idIndexMarker685"/> newly released WCT 8.0 supports WinUI 3. Previously, creating WinUI 3 apps with .NET supported by WCT was only in preview in the new WCT repository. Trying these packages required building the toolkit libraries from source code as it has no published releases on GitHub. Now that they are available as stable NuGet packages, you can add them to your project as you would with any other package.</p>
			<p>Now that we have covered some background and history of the WCT, we will take a quick look at some of the controls and compone<a id="_idTextAnchor237"/>nts available in the toolkit.</p>
			<h1 id="_idParaDest-192">Exploring the WC<a id="_idTextAnchor238"/>T Gallery app</h1>
			<p>As we mentioned <a id="_idIndexMarker686"/>earlier in this chapter, the <strong class="bold">WCT Gallery app</strong> is available from the Microsoft Store (<a href="https://apps.microsoft.com/store/detail/windows-community-toolkit-gallery/9NBLGGH4TLCQ">https://apps.microsoft.com/store/detail/windows-community-toolkit-gallery/9NBLGGH4TLCQ</a>). It can be installed on Windows 10 version 17763 or later, on Windows 11, or even on your Xbox, Surface Hub, or HoloLens device. As with the <strong class="bold">WinUI 3 Gallery</strong> app we discussed in <a href="B20908_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring WinUI Controls</em>, the toolkit sample app provides us with an easy way to navigate and ex<a id="_idTextAnchor240"/><a id="_idTextAnchor241"/>plore the contents of the WCT.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor242"/>Installing and launching the app</h2>
			<p>Let’s get started<a id="_idTextAnchor243"/>:</p>
			<ol>
				<li>Open the <code>window<a id="_idTextAnchor244"/>s community</code> in the <strong class="bold">Search</strong> box:</li>
			</ol>
			<div><div><img src="img/B20908_09_01.jpg" alt="Figure 9.1 – Finding the app in the Microsoft Store"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Finding the app in the Microsoft Store</p>
			<ol>
				<li value="2">Select <strong class="bold">Windows Community Toolkit Gallery</strong> from the search results and click the <strong class="bold">Install</strong> button on the resulting page. Once the installation completes, the <strong class="bold">Install</strong> button will become an <strong class="bold">Open</strong> button. Open the WCT app from there or<a id="_idTextAnchor245"/> from the Windows<a id="_idIndexMarker688"/> Start menu:</li>
			</ol>
			<div><div><img src="img/B20908_09_02.jpg" alt="Figure 9.2 – The WCT Gallery app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The WCT Gallery app</p>
			<p>The<a id="_idIndexMarker689"/> app opens to an<a id="_idTextAnchor246"/> overview page, where there are several highlighted controls, helpers, and behaviors. The top section also has some useful links to the WCT documentation, GitHub repository, and their Discord community.</p>
			<p>The controls and other components are divided into seven sections on the left: <strong class="bold">Animations</strong>, <strong class="bold">Controls</strong>, <strong class="bold">Extensions</strong>, <strong class="bold">Helpers</strong>, <strong class="bold">Layouts</strong>, <strong class="bold">Xaml</strong>, and the app’s <strong class="bold">Settings</strong>. With so many controls in the toolkit, we will explore just a few of them and leave the rest <a id="_idTextAnchor247"/><a id="_idTextAnchor248"/>for you to explore on your own.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor249"/>Controls</h2>
			<p>Click the <strong class="bold">Controls</strong> nav<a id="_idTextAnchor250"/>igation<a id="_idIndexMarker690"/> item at the left of the app to display a list of controls. This is the largest section of the app, with the controls grouped by category, as follows:</p>
			<ul>
				<li><strong class="bold">Input</strong>: These are custom input controls (for example, <strong class="bold">RadialGuage</strong>)</li>
				<li><strong class="bold">Layout</strong>: Layout panels and related controls (for example, <strong class="bold">HeaderedTreeView</strong>)</li>
				<li><strong class="bold">Media</strong>: Controls for working with media (for example, <strong class="bold">CameraPreview</strong>)</li>
				<li><strong class="bold">Sizers</strong>: These are content sizing controls (for example, <strong class="bold">GridSplitter</strong>)</li>
				<li><strong class="bold">Status and Info</strong>: Controls for updating the user on progress or status. In the current version of the app, the section only contains the <strong class="bold">MetadataControl</strong></li>
				<li><strong class="bold">Text</strong>: These are types of text input controls (for example, <strong class="bold">RichSuggestBox</strong>)</li>
			</ul>
			<p>You can see some of the controls in the expanded navigation pane<a id="_idTextAnchor251"/>l in the following screenshot:</p>
			<div><div><img src="img/B20908_09_03.jpg" alt="Figure 9.3 – The Controls menu expanded in the WCT Gal﻿lery app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The Controls menu expanded in the WCT Gal<a id="_idTextAnchor252"/>lery app</p>
			<p>Selecting one of these controls will open a page that contains several regions. The main panel is an interactive region where you can interact with the selected control. To the right of this panel, there are some drop-down boxes to update the control’s behavior and a button where you can toggle between a <strong class="bold">Light</strong> or <strong class="bold">Dark</strong> theme, which will update the controls running in the panel.</p>
			<p>The right<a id="_idIndexMarker691"/> panel contains several controls to modify the display and behavior of the current controls. The number of controls seen on the right panel will vary depending on the selected control. The <strong class="bold">View Code</strong> button expands a XAML editor with the markup for the code running in the main panel. You can change the markup here, and your changes will be reflected in the code running in the main panel. The <strong class="bold">C#</strong> tab will display the C# code for the control. Below the interactive section of the page, control’s documentation fro<a id="_idTextAnchor253"/>m <em class="italic">Microsoft Learn</em> is displayed:</p>
			<div><div><img src="img/B20908_09_04.jpg" alt="Figure 9.4 – Viewing the ImageCropper control in the WCT Gallery app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Viewing the ImageCropper control in the WCT Gallery app</p>
			<p>Take some time to explore the <strong class="bold">ImageCropper</strong> control and <strong class="bold">MarkdownTextBlock</strong> in the <strong class="bold">Controls</strong> section of the toolkit. Follow these steps:</p>
			<ol>
				<li>Op<a id="_idTextAnchor254"/>en<a id="_idIndexMarker692"/> the <strong class="bold">ImageCropper</strong> control and give it a try. Click the <strong class="bold">Crop Shape</strong> drop-down control, select <strong class="bold">Circular</strong>, and watch the cropped area change to a circle shape.</li>
				<li>Next, select the <strong class="bold">RangeSelector</strong> control in the left panel. This control’s page is similar, but on the main panel, there is a RangeSelector control where two sliders can be moved to select minimum and maximum points for the range. The <strong class="bold">Minimum</strong> and <strong class="bold">Maximum</strong> allowed values can be controlled from the r<a id="_idTextAnchor255"/>ight side of the panel as well:</li>
			</ol>
			<div><div><img src="img/B20908_09_05.jpg" alt="Figure 9.5 – RangeSelector running in the WCT Gallery app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – RangeSelector running in the WCT Gallery app</p>
			<ol>
				<li value="3">Scroll down to see an example use of t<a id="_idTextAnchor256"/>he control.</li>
			</ol>
			<p>There are <a id="_idIndexMarker693"/>many more controls you can explore in this part of the app. You should take some time to find out which might<a id="_idTextAnchor257"/> be useful in your next project.</p>
			<p>Now that we have explored a couple of the controls in the sample app, let’s tr<a id="_idTextAnchor258"/>y using them in a WinUI project.</p>
			<h1 id="_idParaDest-195">Using controls from the tool<a id="_idTextAnchor259"/>kit</h1>
			<p>We explored <a id="_idIndexMarker694"/>a handful of the WCT controls in the sample app in the previous section. Now, it’s time to use them in a WinUI project. To demonstrate some of the controls in action, we are going to create a new <strong class="bold">WinUI 3 in </strong><strong class="bold">Desktop</strong> project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, the WCT controls are not recommended for use in production apps and have some caveats. To learn more about the current limitations, you can read this Microsoft blog post: <a href="https://devblogs.microsoft.com/ifdef-windows/windows-community-toolkit-for-project-reunion-0-5/">https://devblogs.microsoft.com/ifdef-windows/windows-community-toolkit-for-project-reunion-0-5/</a>.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor262"/>Creating the WinUI project</h2>
			<p>T<a id="_idTextAnchor263"/>o start our WCT project, you will <a id="_idIndexMarker695"/>have <a id="_idTextAnchor264"/>to launch Visual Studio and follow these steps:</p>
			<ol>
				<li>Create a new project. Then, on the <code>WinUI in Desktop</code> in the search field.</li>
				<li>Several project types will be displayed, but one of the top results will be <strong class="bold">Blank App, Packaged (WinUI 3 in Desktop)</strong>. Select this project template for the lang<a id="_idTextAnchor265"/>uage of your choice and click <strong class="bold">Next</strong>.</li>
				<li>Name the project <code>HardwareSupplies</code> and click the <code>App.xaml</code> and <code>MainWindow.xaml</code>:</li>
			</ol>
			<div><div><img src="img/B20908_09_06.jpg" alt="Figure 9.6 – The HardwareSupplies project in Visual Studio Solution Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – The HardwareSupplies project in Visual Studio Solution Explorer</p>
			<ol>
				<li value="4">If you <a id="_idIndexMarker696"/>open the <code>MainWindow.xaml</code> file, you will see some simple starter markup. There is a <code>StackPanel</code> control containing a <code>Button</code> control named <code>myButton</code> with <code>Click Me</code> as its content. This is what the code looks like:<pre class="source-code">
&lt;StackPanel Orientation="Horizontal"
            HorizontalAlignment="Center"
            VerticalAlignment="Center"&gt;
    &lt;Button x:Name="myButton"
            Click="myButton_Click"&gt;
        Click Me
    &lt;/Button&gt;
&lt;/StackPanel&gt;</pre></li>				<li><a id="_idTextAnchor268"/>The <code>myButton</code> control’s <code>Click</code> event has a <code>myButton_Click</code> event <a id="_idTextAnchor269"/>handler in <code>MainWindow.xaml.cs</code> that changes the <code>myButton</code> variable’s content to <code>Clicked</code>, as illustrated in the following code snippet:<pre class="source-code">
private void myButton_Click(object sender, RoutedEventArgs e)
{
    myButton.Content = "Clicked";
}</pre></li>				<li>Before we make any changes, run the application and test the button to make sure e<a id="_idTextAnchor270"/>verything is working as expected:</li>
			</ol>
			<div><div><img src="img/B20908_09_07.jpg" alt="Figure 9.7 – Running the HardwareSupplies app﻿ for the first time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Running the HardwareSupplies app<a id="_idTextAnchor271"/> for the first time</p>
			<p>Everything is <a id="_idIndexMarker697"/>working as expected. Ne<a id="_idTextAnchor272"/>xt, we’re going to add WCT <a id="_idTextAnchor273"/><a id="_idTextAnchor274"/>package references to the project.</p>
			<h2 id="_idParaDest-197">Re<a id="_idTextAnchor275"/>ferencing WCT packages</h2>
			<p>The primary control we <a id="_idIndexMarker698"/>need for the app is a <code>DataGrid</code> control that displays a list of hardware items. We will also add a <code>HeaderedContentControl</code> control and a <code>DropShadowPanel</code> control to get an idea of how those controls can be used. Most of the WCT controls are part of the <code>DataGrid</code> is in the <code>communitytoolkit.winui</code>, and add the latest version of <a id="_idTextAnchor276"/>those two packages to the project:</p>
			<div><div><img src="img/B20908_09_08.jpg" alt="Figure 9.8 – Adding the WCT NuGet packages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Adding the WCT NuGet packages</p>
			<p>After <a id="_idIndexMarker699"/>installing these two packages, close the package manager window and compile the project to ensure all the packages are downloaded. Next, we will set up <a id="_idTextAnchor277"/><a id="_idTextAnchor278"/>some data for the <code>DataGrid</code> control.</p>
			<h2 id="_idParaDest-198">Adding data to the DataGrid con<a id="_idTextAnchor279"/>trol</h2>
			<p>The <a id="_idIndexMarker700"/>most important part of an<a id="_idTextAnchor280"/>y <code>DataGrid</code> control is the data being presented to the user. Before we start building the UI, we’re going to build a small inventory of hardware data to display. Proceed as follows:</p>
			<ol>
				<li>Start by adding a new class to the <code>HardwareSupplies</code> project named <code>HardwareItem</code>. The class will have six properties, as shown here:<pre class="source-code">
public class HardwareItem
{
    public long id { get; set; }
    public string name { get; set; }
    public string category { get; set; }
    public int quantity { get; set; }
    public decimal cost { get; set; }
    public decimal price { get; set; }
}</pre></li>				<li>Next, open<a id="_idIndexMarker701"/> the <code>MainWindow.xaml.cs</code> file. Create a public property named <code>HardwareItems</code> and define it as an array of <code>HardwareItem</code>:<pre class="source-code">
public HardwareItem[] HardwareItems { get; set; }</pre></li>				<li>Now, create a<a id="_idTextAnchor281"/> new method named <code>PopulateItems</code>. This method will initialize<a id="_idTextAnchor282"/> the <code>HardwareItems</code> array and populate it with 12 items:<pre class="source-code">
private void PopulateItems()
{
    HardwareItems = new HardwareItem[]
    {
        new HardwareItem { id = 1, name = "Wood Screw", category = "Screws", cost = 0.02M, price = 0.10M, quantity = 504 },
        new HardwareItem { id = 2, name = "Sheet Metal Screw", category = "Screws", cost = 0.03M, price = 0.15M, quantity = 655 },
        new HardwareItem { id = 3, name = "Drywall Screw", category = "Screws", cost = 0.02M, price = 0.11M, quantity = 421 },
        new HardwareItem { id = 4, name = "Galvanized Nail", category = "Nails", cost = 0.04M, price = 0.16M, quantity = 5620 },
        new HardwareItem { id = 5, name = "Framing Nail", category = "Nails", cost = 0.06M, price = 0.20M, quantity = 12000 },
        new HardwareItem { id = 6, name = "Finishing Nail 2 inch", category = "Nails", cost = 0.02M, price = 0.11M, quantity = 1405 },
        new HardwareItem { id = 7, name = "Finishing Nail 1 inch", category = "Nails", cost = 0.01M, price = 0.10M, quantity = 1110 },
        new HardwareItem { id = 8, name = "Light Switch - White", category = "Electrical", cost = 0.25M, price = 1.99M, quantity = 78 },
        new HardwareItem { id = 9, name = "Outlet - White", category = "Electrical", cost = 0.21M, price = 1.99M, quantity = 56 },
        new HardwareItem { id = 10, name = "Outlet - Beige", category = "Electrical", cost = 0.21M, price = 1.99M, quantity = 90 },
        new HardwareItem { id = 11, name = "Wire Ties", category = "Electrical", cost = 0.50M, price = 4.99M, quantity = 125 },
        new HardwareItem { id = 12, name = "Switch Plate - White", category = "Electrical", cost = 0.21M, price = 2.49M, quantity = <a id="_idTextAnchor283"/>200 }
    };
}</pre><p class="list-inset">The app <a id="_idIndexMarker702"/>now has a nice assortment of screws, nails, and electrical items to present in the <code>DataGrid</code> control.</p></li>				<li>Remove the <code>myButton_Click</code> event handler, as it’s no longer need<a id="_idTextAnchor284"/>ed.</li>
				<li>Finally, call <code>PopulateItems</code> at the end of the <code>MainWindow</code> constructor:<pre class="source-code">
public MainWindow()
{
    this.InitializeComponent();
    <strong class="bold">PopulateItems();</strong>
}</pre></li>			</ol>
			<p>The data is <a id="_idIndexMarker703"/>ready to go. Let’s move on and<a id="_idTextAnchor285"/><a id="_idTextAnchor286"/> define the XAML markup for <code>MainWindow</code>.</p>
			<h2 id="_idParaDest-199">Adding controls t<a id="_idTextAnchor287"/>o the MainWindow control</h2>
			<p>The UI<a id="_idIndexMarker704"/> for our app will <a id="_idTextAnchor288"/>be simple. We will display the data in a <code>DataGrid</code> control with a drop shadow beneath some header text.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>DropShadowPanel</code> control will be removed from the toolkit in the future. You can consider using the <code>AttachedDropShadow</code> or <code>AttachedCardShadow</code> control as alternatives. For more information, read<a id="_idIndexMarker705"/> about <strong class="bold">Attached </strong><strong class="bold">Shadows</strong>: <a href="https://learn.microsoft.com/windows/communitytoolkit/helpers/attachedshadows">https://learn.microsoft.com/windows/communitytoolkit/helpers/attachedshadows</a>.</p>
			<p>Proceed as follows:</p>
			<ol>
				<li>Start by placing a <code>HeaderedContentControl</code> control inside a <code>Grid</code> control in <code>MainWindow.xaml</code>. Set the <code>Header</code> attribute to <code>Hardware Inventory</code>. This will display at the top of <code>MainWindow</code> control’s content. Set <code>Margin</code> to <code>6</code> to leave some space around the edges of the control:<pre class="source-code">
&lt;Grid&gt;
    &lt;wct:HeaderedContentControl Header="Hardware Inventory"
                                Margin="6"&gt;
    &lt;/wct:HeaderedContentControl&gt;
&lt;/Grid&gt;</pre></li>				<li>Don’t<a id="_idIndexMarker706"/> forget to add a namespace definition for the WCT controls, as follows:<pre class="source-code">
&lt;Window
    x:Class="HardwareSupplies.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:HardwareSupplies"
    <strong class="bold">xmlns:wct="using:CommunityToolkit.WinUI.UI.Controls"</strong>
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"&gt;</pre></li>				<li>Next, define a <code>DropShadowPanel</code> control as the content of <code>HeaderedContentControl</code>. <code>BlurRadius</code> defines the width of the blurred area of the drop shadow. A <code>ShadowOpacity</code> value o<a id="_idTextAnchor289"/>f <code>1</code> indicates that the darkest part of the shadow will be completely opaque. Most of this will be behind the <code>DataGrid</code> co<a id="_idTextAnchor290"/>ntrol. The <code>OffsetX</code> and <code>OffsetY</code> values will shift the drop shadow over and down by <code>2</code> pixels. The <code>Color</code> attribute sets the color of the shadow. Setting <code>IsMasked</code> to <code>True</code> creates a more precise shadow but degrades performance. In our case, performance will not be a concern. Finally, we’ll set <code>Margin</code> to <code>6</code> to leave some space to see the drop shadow:<pre class="source-code">
&lt;wct:HeaderedContentControl Header="Hardware Inventory"
                            Margin="6" x:Name="headerPanel"&gt;
<strong class="bold">    &lt;wct:DropShadowPanel BlurRadius="8"</strong>
<strong class="bold">                         ShadowOpacity="1"</strong>
<strong class="bold">                         OffsetX="2"</strong>
<strong class="bold">                         OffsetY="2"</strong>
<strong class="bold">                         Color="Gray"</strong>
<strong class="bold">                         IsMasked="True"</strong>
<strong class="bold">                         Margin="6"&gt;</strong>
<strong class="bold">    &lt;/wct:DropShadowPanel&gt;</strong>
&lt;/wct:HeaderedContentControl&gt;</pre></li>				<li>Lastly, add <code>DataGrid</code> as a child of <code>DropShadowPanel</code>. The grid will bind to the <code>HardwareItems</code> property we crea<a id="_idTextAnchor291"/>ted. The <code>AutoGenerateColumns</code> property will <a id="_idIndexMarker707"/>create column headers using the names of the <code>HardwareItem</code> objects’ properties. By setting <code>Background</code> and <code>AlternatingRowBackground</code> to <code>ThemeResource</code> styles, the grid will look<a id="_idTextAnchor292"/> great for Windows users who use either the <code>DataGrid</code> will be transparent, and the gray drop shadow will obscure the contents of the grid:<pre class="source-code">
&lt;wct:DropShadowPanel BlurRadius="8"
                     ShadowOpacity="1"
                     OffsetX="2"
                     OffsetY="2"
                     Color="Gray"
                     IsMasked="True"
                     Margin="6"&gt;
    <strong class="bold">&lt;wct:DataGrid ItemsSource="{x:Bind HardwareItems}"</strong>
<strong class="bold">              AutoGenerateColumns="True"</strong>
<strong class="bold">              AlternatingRowBackground="{ThemeResource SystemControlBackgroundListLowBrush}"</strong>
<strong class="bold">              Background="{ThemeResource SystemControlBackgroundAltHighBrush}"/&gt;</strong>
&lt;/wct:DropShadowPanel&gt;</pre></li>				<li>The app’s <a id="_idIndexMarker708"/>code is complete. It’s time to build a<a id="_idTextAnchor293"/>nd run the app to see how everything looks:</li>
			</ol>
			<div><div><img src="img/B20908_09_09.jpg" alt="Figure 9.9 – The HardwareSupplies app running with data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The HardwareSupplies app running with data</p>
			<p>Here, you <a id="_idIndexMarker709"/>can see that, with a little bit of code, we have a pretty nice-looking app to display some hardware inventory data. The header text, drop shadow, and rich <code>DataGrid</code> control work well together to create our UI.</p>
			<p>Let’s finish up our exploration of the WCT by looking at some of th<a id="_idTextAnchor294"/><a id="_idTextAnchor295"/>e other components available in the toolkit.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor296"/>Exploring the toolkit’s helpers, services, and extensions</h1>
			<p>We have discussed many of the controls in the WCT, but the toolkit contains much more than UI controls. In this section, we will return to the WCT sample app to explore some of the other components available in the to<a id="_idTextAnchor297"/><a id="_idTextAnchor298"/>olkit. We’ll start with some helper<a id="_idTextAnchor299"/> classes.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor300"/>Helpers</h2>
			<p>Next to the <a id="_idIndexMarker710"/>controls in the toolkit, the <strong class="bold">Helpers</strong> section contains the largest number of components. As with the controls, the helpers are divided into categories in the sample app, as follows:</p>
			<ul>
				<li><strong class="bold">Data</strong>: These helpers relate to loading and displaying data. Examples include <strong class="bold">ImageCache</strong>, <strong class="bold">ObservableGroup</strong>, and <strong class="bold">Incremental </strong><strong class="bold">Loading Collection</strong>.</li>
				<li><strong class="bold">Developer</strong>: These are helpers that are useful for developers and include <strong class="bold">DispatcherQueueHelper</strong> for updating the UI from a background thread.</li>
				<li><strong class="bold">Notifications</strong>: These helpers provide customized ways of notifying users with Windows notifications and the Start menu. Included are <strong class="bold">LiveTile</strong>, <strong class="bold">Toast</strong>, and <strong class="bold">WeatherLiveTileAndToast</strong>. However, we already saw in the previous chapter that Windows App SDK now has built-in support for notifications in WinUI 3 apps. These toolkit helpers are useful for UWP developers.</li>
				<li><code>CanvasGeometry</code> class <a id="_idIndexMarker711"/>using <strong class="bold">Win2D</strong>.</li>
				<li><strong class="bold">State Triggers</strong>: There are currently 10 state trigger helpers in the toolkit, including <strong class="bold">IsNullOrEmptyStateTrigger</strong>, <strong class="bold">FullScreenModeStateTrigger</strong>, and <strong class="bold">RegexStateTrigger</strong>.</li>
				<li><strong class="bold">Systems</strong>: The 14 system helpers <a id="_idIndexMarker712"/>currently include <strong class="bold">CameraHelper</strong>, <strong class="bold">NetworkHelper</strong>, <strong class="bold">PrintHelper</strong>, and <strong class="bold">ThemeListener</strong>.</li>
			</ul>
			<p>It’s time to take a closer look at one of the helpers in the toolkit. Let’s see what the <code>SystemInformation</code> helper class<a id="_idTextAnchor301"/> offers. This is a static class that contains a long list of useful information about the running application and the user’s system. These are just a handful of the available properties:</p>
			<ul>
				<li><code>ApplicationName</code>: The application’s name</li>
				<li><code>ApplicationVersion</code>: The application version</li>
				<li><code>AvailableMemory</code>: The available system memory</li>
				<li><code>Culture</code>: The current culture set in Windows</li>
				<li><code>DeviceFamily</code>: The name of the user’s device family</li>
				<li><code>DeviceModel</code>: The model number of the current device</li>
				<li><code>FirstUseTime</code>: The first time the app was launched</li>
				<li><code>IsAppUpdated</code>: Indicates if this is the first time the app has been run after being updated</li>
				<li><code>LaunchCount</code>: The number of times the app has been launched since a system reset</li>
				<li><code>OperatingSystem</code>: The name of the operating system</li>
				<li><code>OperatingSystemVersion</code>: The operating system version</li>
			</ul>
			<p>There are many<a id="_idIndexMarker713"/> other helpers you can explore in the sample app. We’ll finish up by reviewing some of the other too<a id="_idTextAnchor302"/><a id="_idTextAnchor303"/>ls in the <strong class="bold">Extensions</strong> area of the WCT sample a<a id="_idTextAnchor304"/>pp.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor305"/>Extensions</h2>
			<p>The <strong class="bold">Extensions</strong> menu <a id="_idIndexMarker714"/>in the sample app contains several items that add extended properties to WinUI controls and extension methods to other classes. We will review <strong class="bold">FrameworkElementExtensions</strong> (formerly known as the <strong class="bold">Mouse</strong> extensions) and <strong class="bold">StringE<a id="_idTextAnchor306"/>xtensions</strong> here.</p>
			<p><code>FrameworkElement</code> control in order to set the mouse cursor to display when the mouse moves over that element:</p>
			<pre class="source-code">
&lt;Button ui:FrameworkElementExtensions.Cursor="Wait"
        Content="Show Wait Cursor" /&gt;
&lt;Button ui:FrameworkElementExtensions.Cursor="Hand"
        Content="Show Hand Cursor" /&gt;
&lt;Button ui:FrameworkElementExtensions.Cursor="UniversalNo"
        Content="Show Unive<a id="_idTextAnchor307"/>rsalNo Cursor" /&gt;</pre>			<p><strong class="bold">StringExtensions</strong> contains a few extension methods related to string data, as follows:</p>
			<ul>
				<li><code>IsEmail</code>: Determines whether a string is a valid email address format</li>
				<li><code>IsDecimal</code>: Determines whether a string is a decimal value</li>
				<li><code>IsNumeric</code>: Determines whether a string is a numeric value</li>
				<li><code>IsPhoneNumber</code>: Determines whether a string contains a valid phone number format</li>
				<li><code>IsCharacterString</code>: Determines whether a string contains only letters</li>
				<li><code>DecodeHtml</code>: Returns a string with any HTML formatting, tags, comments, scripts, and styles removed</li>
				<li><code>FixHtml</code>: Similar to <code>DecodeHtml</code>, it returns a string with all HTML formatting, comments, scripts, and styles removed</li>
				<li><code>Truncate</code>: Truncates a string to a specified length, opt<a id="_idTextAnchor308"/>ionally adding an ellipsis</li>
			</ul>
			<p>The <code>Truncate</code> extension <a id="_idIndexMarker715"/>includes two overloads. This code will truncate the <code>name</code> string so that it’s no longer than 10 characters. It will truncate the <code>city</code> string to seven characters and add an ellipsis to the end of the string to indicate that it was truncated, as follows:</p>
			<pre class="source-code">
string name = "Bobby Joe Johnson";
string city = "San Francisco";
name.Truncate(10); // name will be "Bobby Joe "
city.Truncate(7, true); // city will be "San Fra..."</pre>			<p>I encourage you to explore these extensions, and all the others in the WCT. The sample app is a great way to visually explore the toolkit and get ideas of how to integrate it into your own projects.</p>
			<p>Before we wrap up, let’s briefly discuss the .NET Community Toolkit.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor309"/>.NET Community Toolkit features</h1>
			<p>The .NET Community Toolkit can be<a id="_idIndexMarker716"/> leveraged by all .NET developers. In <a href="B20908_03.xhtml#_idTextAnchor073"><em class="italic">Chapter 3</em></a>, <em class="italic">MVVM for Maintainability and Testability</em>, we used the MVVM Toolkit, which is part of the .NET Community Toolkit. There are several other features of this toolkit, primarily targeting performance and diagnostics.</p>
			<p>The <code>Guard</code> and <code>ThrowHelper</code>.</p>
			<p><code>Guard</code> APIs are used to validate the arguments passed into your .NET methods. They are created to be fast, with minimal impact on the performance of your applications. Here are a few examples of their use:</p>
			<pre class="source-code">
public void TestData(decimal[] numbers, int size, string data)
{
    Guard.IsNotNull(numbers);
    Guard.IsInRangeFor(size, numbers);
    Guard.IsNotNullOrWhitespace(data);
}</pre>			<p>You can view a complete set of helper methods in the <em class="italic">Microsoft Learn</em> documentation: <a href="https://learn.microsoft.com/dotnet/api/microsoft.toolkit.diagnostics.guard#methods">https://learn.microsoft.com/dotnet/api/microsoft.toolkit.diagnostics.guard#methods</a>.</p>
			<p>The <code>ThrowHelper</code> class <a id="_idIndexMarker717"/>is a performant, efficient method of throwing exceptions. It’s intended to work well with <code>Guard</code> helpers. The syntax is similar to the built-in way of throwing exceptions in .NET. This code could be used to throw an <code>ArgumentException</code> exception from our <code>TestData</code> method shown previously:</p>
			<pre class="source-code">
ThrowHelper.ThrowArgumentException&lt;int&gt;(nameof(size));</pre>			<p>The <strong class="bold">CommunityToolkit.HighPerformance</strong> package includes helpers and extensions for code focused on high performance. Once again, the package is available for .NET and .NET Standard targets.</p>
			<p>The following members are available in the <strong class="bold">HighPerformance</strong> package:</p>
			<ul>
				<li><code>Span2D&lt;T&gt;</code>: This type has the same functionality as a <code>Span&lt;T&gt;</code> type but supports 2D memory.</li>
				<li><code>Memory2D&lt;T&gt;</code>: This type has the same functionality as a <code>Memory&lt;T&gt;</code> type but supports 2D memory locations.</li>
				<li><code>SpanOwner&lt;T&gt;</code>: This type is a stack-only buffer that leverages a shared memory pool to borrow memory only used in synchronous code.</li>
				<li><code>MemoryOwner&lt;T&gt;</code>: This type is another buffer type. It implements <code>IMemoryOwner&lt;T&gt;</code> and is a lightweight wrapper around <code>ArrayPool&lt;T&gt;</code>.</li>
				<li><code>StringPool</code>: This type is a configurable pool of <code>string</code> objects. It can improve performance when creating a large number of strings from buffers or streams.</li>
				<li><code>ParallelHelper</code>: This helper class contains a set of APIs for working with parallel code in .NET. It has multiple overloads of the following helper methods: <code>For</code>, <code>For2D</code>, and <code>ForEach</code>. Each of these helper methods creates an optimized parallel loop.</li>
				<li><code>Ref&lt;T&gt;</code>: This type is a stack-only type that stores a reference to a value. It can be used in place of a <code>ref T</code> value in C# code, as they’re not otherwise supported. There is also a <code>ReadOnlyRef&lt;T&gt;</code> type.</li>
			</ul>
			<p>For an in-depth<a id="_idIndexMarker718"/> description of these types and scenarios for their use, you should check out the documentation on <em class="italic">Microsoft Learn</em>: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/high-performance/introduction">https://learn.microsoft.com/dotnet/communitytoolkit/high-performance/introduction</a>. The source code for the .NET Community Toolkit is available on GitHub: <a href="https://github.com/CommunityToolkit/dotnet">https://github.com/CommunityToolkit/dotnet</a>.</p>
			<p>Now, let’s w<a id="_idTextAnchor310"/>rap up and review what we’ve learned in this chapter.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor311"/>Summary</h1>
			<p>In this chapter, you learned about the controls, helpers, services, and other components available to WinUI developers in the WCT and the .NET Community Toolkit. We also practiced adding some of the WCT controls into a WinUI 3 project, leveraging the powerful <code>DataGrid</code> control. Finally, we installed and used the WCT sample app to discover the controls and components in the toolkit that we can use in our apps. Adding WCT packages to your application will provide controls with rich functionality and extensions that save you time.</p>
			<p>In the next chapter, we will be working with the <strong class="bold">Template Studio for WinUI</strong> extension for Visual Studio to learn how you can quickly create a new <a id="_idTextAnchor312"/><a id="_idTextAnchor313"/>WinUI app with rich controls and components included.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor314"/>Questions</h1>
			<ol>
				<li>What was the original name of the WCT?</li>
				<li>Which WCT legacy browser control can be used in WPF or WinForms apps?</li>
				<li>Which WCT control can render markdown output?</li>
				<li>Which helper in the WCT can manage and group items into an observable collection?</li>
				<li>What is the name of the Visual Studio project template for running WinUI 3 apps?</li>
				<li>Which of these was moved to the .NET Community Toolkit: <code>DataGrid</code> control, MVVM Toolkit, or <code>PrintHelper</code>?</li>
				<li>Which extension class in the WCT contains methods to validate strings, including <code>IsEmail</code> and <code>IsPhoneNumber</code>?</li>
				<li>Which WCT extension can update the Windows cursor at the control level?</li>
			</ol>
		</div>
	</body></html>