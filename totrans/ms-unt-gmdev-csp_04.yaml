- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Clean and Modular C# Code for Unity Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 2*](B22017_02.xhtml#_idTextAnchor028), where we focus on
    the importance of clean and modular C# code for Unity game development. In the
    next pages, you’ll learn practical skills to write clear and efficient code. We’ll
    cover clean code principles, stress the significance of readability, and introduce
    industry best practices. You’ll also explore conventions and code structuring
    for smoother collaboration. Additionally, we’ll delve into refactoring and optimization
    techniques to enhance your C# code’s performance and scalability. By the end of
    this chapter, you’ll have the expertise to write, document, refactor, and optimize
    C# code effectively, laying a solid foundation for successful Unity game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to writing clean code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# code conventions and readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# code refactoring and optimization techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to follow along with me in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity version 2022.3.13**: Download and install Unity version 2022.3.13 or
    any other version. It is recommended to install the 2022 version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primary IDE – Visual Studio 2022**: Ensure Visual Studio 2022 is installed
    for optimal learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub repository for code samples**: Access the code samples and project
    files of this chapter from our GitHub repository: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002).
    Clone or download the repository to have easy access to the code demonstrated
    in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to writing clean code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean code refers to well-organized, readable, and easy-to-understand code.
    It’s like writing a clear story that anyone can follow without getting lost in
    confusing jargon or messy paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In software development, clean code matters a lot. First, it makes the code
    easier for everyone in the team to grasp, helping them work together smoothly.
    Second, it saves time because clean code is simpler to fix when something goes
    wrong. Lastly, it’s like having a clean room – it just feels better and is easier
    to manage in the long run. In this list, we highlight the significance of employing
    clean code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building AAA games**: Have you come across “the power of clean code” on your
    coding journey? Well, it’s like the secret sauce for cooking up high-quality code,
    especially when you’re aiming to create top-notch AAA games. Clean code is the
    key ingredient for building games that stand out in the industry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with others**: In the world of coding, we’re never alone. Whether
    you’re part of a company with high standards or collaborating on a project, the
    clean code mentality is your silent companion. You might not realize you’re using
    it, but with a bit of knowledge, you can rock the industry by making your code
    clear and understandable for everyone on the team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility in applying clean code**: The goal of this chapter isn’t to force
    you to use all these clean code principles every single time. Sometimes you need
    to dive into coding first and then tidy up later. These aren’t strict rules; they’re
    more like tools you can pull out when needed. If a feature is familiar, and you
    know how to implement it with principles such as SOLID, go for it. But if you’re
    unsure, start with the basics and refine your code so you gain a clearer picture
    of what’s needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Every coder’s struggle**: Picture this: you’re tired of the endless coding
    and updates, facing issues as you go. Changing a feature becomes a headache, especially
    when the code turns into a messy puzzle. Dealing with testers feels like a never-ending
    loop of modifications. If this sounds familiar, you’re not alone. This chapter
    is your guide to overcoming the struggles of code maintenance and updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code that tells a story**: Ever written a piece of code and then completely
    forgotten what it was for? It happens to the best of us. This chapter is here
    to teach you how to write code that tells a story – a story that’s clear and easy
    to follow and won’t leave you scratching your head later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity and efficiency tips**: Get ready for some tips and tricks on how
    to make your code modular and efficient. I’ll walk you through general principles
    and show you how to apply them in real-world scenarios. Plus, we’ll dive into
    examples – messy code versus clean code – for each clean code principle, giving
    you a practical understanding of how to implement these ideas in your own projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean code is essential for building better software. By understanding its importance,
    you’ll be better equipped to write code that’s clear, understandable, and effective.
    In the next section, we will understand the principles of writing clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of writing clean code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the world of **object-oriented programming** (**OOP**), clean code thrives
    on a foundation of five key principles known as **SOLID**. These principles act
    as guiding lights, helping us write code that’s not just functional but also the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to read and understand**: Anyone who picks up your code should be able
    to grasp its purpose and logic without too much effort'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainable**: Modifications and updates should be a breeze, even for someone
    unfamiliar with the code’s history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extendable and reusable**: Building on existing code should be straightforward,
    promoting code reuse and reducing redundancy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let me tell you a story. Before I discovered SOLID principles, I often found
    myself struggling to figure out how to build features. Reaching the finish line
    felt like a messy, chaotic journey. Then, SOLID came along and changed everything.
    It was like a map, helping me organize my thoughts and code into a clear, structured
    path.
  prefs: []
  type: TYPE_NORMAL
- en: But SOLID wasn’t just a clean code tool; it empowered me to become a better
    problem solver. It shifted my mindset from a “try hard” approach to a “create
    solutions” approach. I went from someone who wrestled with code to someone who
    crafted elegant solutions.
  prefs: []
  type: TYPE_NORMAL
- en: As software developers, our job is to solve problems. SOLID becomes your secret
    weapon in this battle. It provides the framework to tackle most challenges you’ll
    encounter.
  prefs: []
  type: TYPE_NORMAL
- en: However, simply reading about SOLID isn’t enough. True learning comes from applying
    it yourself. Grab your existing code and dive in! Experiment with incorporating
    SOLID principles and see how they transform your work. Trust me, the hands-on
    experience will solidify your understanding and unlock a whole new level of development
    mastery.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle (SRP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss the **Single Responsibility Principle** (**SRP**) in the context
    of game development. The SRP suggests that a class should have only one reason
    to change, meaning it should only have one responsibility. In the gaming world,
    this translates to ensuring that each component or class is responsible for a
    single aspect of the game, making the code base more modular and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: When we begin coding, it’s common to stuff all the logic into one massive class
    that takes on many jobs. It gets tricky trying to fix one issue without messing
    up other things in that class or introducing new logic that ends up making other
    sections act strangely.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with an example of a player controller script that combines various
    responsibilities and then refactor it to adhere to the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we can see the old `PlayerController` class, which
    has many responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down the big class into smaller classes, each with its own set of
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we can see the `PlayerAnimation` class, which
    is responsible for handling player animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the `PlayerMovement` class, which is
    responsible for handling player movement, and the `PlayerInput` class, which is
    responsible for handling player input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the `PlayerController` class acting
    as the orchestrator, delegating responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this simplified version of the `PlayerController` class, we have separate
    classes for movement, input handling, and animations, making `PlayerController`
    more focused and adhering to the SRP. Each class handles its specific responsibility,
    enhancing code organization and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Open-Closed Principle (OCP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s explore the **Open-Closed Principle** (**OCP**) in the context of game
    development. The OCP promotes the idea that a class should be open for extension
    while remaining closed for modification. In the context of game development, this
    implies the ability to introduce new features or functionalities without making
    changes to the existing code. This principle plays a crucial role in enhancing
    code flexibility and maintainability, allowing for the seamless addition of new
    elements to the game without disrupting the established framework.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the *power-up dilemma* is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a basic power-up system in your game that grants bonus points.
    Using the OCP, you can create a base `PowerUp` class with common functionalities
    such as activation and duration. Then, you can create subclasses for different
    specific power-ups, such as double jump or temporary invincibility.
  prefs: []
  type: TYPE_NORMAL
- en: This way, adding a new power-up involves creating a new subclass without modifying
    the existing code. You’re not stuck with a rigid system – the possibilities are
    endless!
  prefs: []
  type: TYPE_NORMAL
- en: OCP allows you to build games that are flexible, adaptable, and maintainable.
    It’s like having a well-designed construction set, letting you create and expand
    your game world without limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we can see the base `PowerUp` class with common
    functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the subclass for `DoubleJumpPowerUp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the subclass for `TemporaryInvincibilityPowerUp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the `PowerUpManager` class utilizing
    the power-ups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this Unity example, the `PowerUp` class is extended with specific power-ups,
    such as `DoubleJumpPowerUp` and `TemporaryInvincibilityPowerUp`. The `PowerUp`
    **Manager** class demonstrates how to add and remove power-ups, and each power-up
    logs a message upon activation and deactivation. This structure allows for the
    addition of new power-ups without modifying the existing code, following the OCP.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the fun part begins! We can use this system to connect each power-up subclass
    to its own prefab. When the player grabs a power-up, only the specific power-up
    associated with that prefab activates. This means adding new power-ups is a breeze
    – just create a new subclass and its prefab and voilà! You’ve expanded your game’s
    possibilities without touching the core logic. This principle isn’t just for power-ups,
    though. You can use it for enemies, items, abilities – the sky’s the limit! So,
    go forth and build your awesome game with the power of the OCP!
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle (LSP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s explore the **Liskov Substitution Principle** (**LSP**) within the realm
    of game development. The LSP maintains that substituting objects of a superclass
    with objects of a subclass should not disrupt the program’s correctness. In the
    context of game development, this implies that using derived classes (subclasses)
    should seamlessly integrate without compromising the expected functionality of
    the base class. This principle ensures the smooth interchangeability of classes,
    allowing for flexibility and ease of use in game development scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the *sneaky enemy dilemma* is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have a base class called `Enemy` with basic movement and attack
    behaviors. You then create two subclasses: `GroundEnemy` and `FlyingEnemy`. The
    LSP ensures that both subclasses behave as expected enemies, moving and attacking
    in ways that comply with the `Enemy` base class’s definition. This means that
    any code designed to work with enemies, such as collision detection or damage
    calculation, will work seamlessly with both `GroundEnemy` and `FlyingEnemy` instances.
    This consistency simplifies development and allows you to focus on creating unique
    behaviors for each subclass without worrying about breaking core functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we can see the base class for `Enemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the subclass for `GroundEnemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the subclass for `FlyingEnemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the `EnemyManager` class demonstrating
    the LSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this Unity example, the `Enemy` class acts as the base class with basic movement
    and attack methods. The `GroundEnemy` and `FlyingEnemy` subclasses extend the
    base class and provide specific implementations for movement and attack. The `EnemyManager`
    class demonstrates the LSP by treating instances of both subclasses as instances
    of the base class, ensuring that code written to work with enemies functions seamlessly
    with both `GroundEnemy` and `FlyingEnemy` instances.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the LSP and OCP?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In game development, the key difference between the LSP and OCP lies in their
    focus and application.
  prefs: []
  type: TYPE_NORMAL
- en: The LSP ensures that derived classes can be seamlessly substituted for their
    base class without affecting program behavior. In a game, this means different
    types of enemies (e.g., ground and flying enemies) should be interchangeable without
    breaking the expected functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The OCP encourages designing classes that are open for extension but closed
    for modification. In game development, this allows adding new features (e.g.,
    new types of weapons) without altering existing code, promoting flexibility and
    maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: To better illustrate their difference, here’s an example. In a game system,
    consider a base class for weapons. Adhering to the LSP allows substituting specific
    weapon types without disrupting expected behaviors, while following the OCP enables
    extending the system to add new weapons without modifying existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation Principle (ISP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s talk about the **Interface Segregation Principle** (**ISP**) in the
    gaming world. The ISP suggests that a class shouldn’t be required to do things
    it doesn’t need to. Simply put, it encourages creating small, task-specific interfaces
    instead of big, general ones. In the context of game development, this means designing
    interfaces that suit each class’s specific needs. This helps keep things clear,
    makes the code more focused, and allows for easier upkeep and changes in game
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example of the NPC interfaces dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have NPCs in your game, each with various functionalities, such
    as wandering, talking, and trading. Applying the ISP ensures that each NPC only
    needs to implement interfaces relevant to its specific behaviors, avoiding unnecessary
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '*Without the ISP*, in the following code block, we can see the `INPC` interface,
    which has general methods for all NPCs, with the `FriendlyNPC` and `AggressiveNPC`
    classes, which implement `INPC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*With the ISP*, in the following code block, we will separate interfaces based
    on functionality, with the `FriendlyNPC` and `AggressiveNPC` classes, which implement
    relevant interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this adapted example, applying the ISP leads to separate interfaces for distinct
    NPC functionalities. Each NPC type (friendly or aggressive) can now implement
    only the interfaces relevant to its behavior, avoiding the implementation of unnecessary
    methods. This makes the system more modular and adaptable as different NPC types
    can adhere to their specific interfaces without being burdened by irrelevant methods.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle (DIP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss the **Dependency Inversion Principle** (**DIP**) in the context
    of game development. The DIP suggests that high-level modules (e.g., game logic)
    should not depend on low-level modules (e.g., specific implementations), but both
    should depend on abstractions (e.g., interfaces or abstract classes). Additionally,
    it promotes that details should depend on abstractions, not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see an example of the weapon manager dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a game where the `WeaponManager` is responsible for handling different
    types of weapons wielded by the player. Without adhering to the DIP, the `WeaponManager`
    might directly instantiate and manage specific weapon classes, such as pistols
    and rifles. However, applying the DIP transforms the scenario. Now, the `WeaponManager`
    relies on an abstraction, say `IWeapon`, representing the common functionalities
    of all weapons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we can see the high-level module and also the
    low-level modules *without* *the DIP*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*With the DIP*, in the following code block, we can see the high-level module
    and low-level modules implementing the abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, applying the DIP allows `WeaponManager` to depend on the abstraction
    (`IWeapon`), enabling easy extension with new weapon types without modifying the
    high-level module. This flexibility is crucial in game development, where new
    features and components may be added over time without disrupting existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SOLID principles in Unity is instrumental in achieving modular
    C# code, a crucial aspect of effective software design. Modularity, which involves
    breaking down a system into self-contained components, is facilitated by the SOLID
    principles, making the code not only easy to understand, maintain, and test but
    also adherent to the LSP.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity’s significance lies in its ability to enhance code organization.
    Applying the SRP ensures that each module has a single responsibility, fostering
    a focused and modular code base. The OCP supports extending code without changing
    existing modules, allowing the seamless addition of new features. The LSP ensures
    that derived classes can substitute their base classes without affecting program
    behavior, promoting consistency and predictability in Unity code.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity development, effective code organization involves using namespaces
    and classes thoughtfully. The ISP tailors interfaces to specific functionalities,
    promoting a concise and modular design. **Dependency Injection** (**DI**), advocated
    by the DIP, creates loosely coupled modules, enhancing adaptability. In summary,
    the SOLID principles, including the LSP, guide the creation of modular and flexible
    C# code in Unity, ensuring a robust, maintainable, and consistent code base. In
    the following section, we’ll explore design patterns in game development and learn
    how to implement them effectively in our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns in game development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are proven solutions to common problems encountered in software
    development. In game development, they provide valuable tools for building robust,
    maintainable, and efficient games. The following section has an overview of design
    patterns and their types.
  prefs: []
  type: TYPE_NORMAL
- en: There are many design patterns, each applicable to specific situations. Here
    are some common types encountered in game development.
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creational patterns are design patterns that provide structured approaches
    to object creation, ensuring flexibility and reusability while maintaining a clear
    separation between object creation and usage code. Here are some of these patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton**: Ensures only one instance of a class exists throughout the game.
    Useful for global objects such as game managers or audio players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory Method**: Creates objects without specifying the exact class, promoting
    flexibility and code reuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Pool**: Pre-allocates and reuses objects to improve performance, especially
    for frequently created objects such as projectiles or enemies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Structural patterns focus on organizing classes and objects to form larger
    structures, enabling better composition and flexibility in managing complex relationships
    between entities within a system. Here are some of these patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flyweight**: Makes incompatible interfaces work together by translating calls
    between them. Useful for integrating external libraries or custom code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: Adds functionality to an object dynamically without subclassing
    it, promoting flexible object behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Behavioral patterns address communication and interaction between objects in
    a system, focusing on how objects collaborate and distribute responsibilities
    to achieve desired behaviors and functionalities. These patterns help manage algorithms,
    relationships, and responsibilities among objects to promote flexibility and extensibility
    in software design. Here are some of these patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observer**: Allows objects to subscribe to and be notified about changes
    in other objects, facilitating communication and event handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: Defines a family of algorithms and encapsulates them to allow
    switching between them at runtime. Useful for handling different player actions
    or enemy behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: Encapsulates the behavior of an object based on its internal state,
    allowing for state-dependent behavior changes. Useful for handling character states
    such as walking, jumping, or attacking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few sections, we are going to talk about one design pattern from
    each type.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Singleton pattern ensures that a class has only one instance and provides
    a global point of access to that instance throughout the application. *Figure
    2**.1* illustrates the Singleton structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Singleton design pattern structure](img/B22017_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Singleton design pattern structure
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, you can see an implementation example of Singleton
    in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see a usage example for the Singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `GameManager` is a Singleton responsible for managing the game
    state. The `PlayerController` class accesses the single instance to start the
    game. While Singletons offers global access and lazy initialization benefits,
    developers should carefully consider the potential drawbacks, especially in larger
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the pros of using the Singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global access**: Provides a single, globally accessible point to manage and
    control a specific aspect of the game, such as game state or settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy initialization**: The instance is created only when it is first needed,
    saving resources until it’s required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to implement**: The Singleton pattern is straightforward to implement
    and widely recognized, making it easy for developers to understand and use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the cons of using the Singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global state**: Singletons introduce a global state, and excessive use can
    lead to tight coupling and a global state that is challenging to manage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential for misuse**: Developers might overuse Singletons, leading to a
    proliferation of global instances, diminishing the benefits of encapsulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficult to test**: Testing code that depends on Singletons can be challenging,
    as the global state may impact the results of unit tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a principle, though, that exists to solve the singleton problem, and
    it’s called dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: DI is a design pattern that addresses the concerns associated with tight coupling
    and global state by providing objects with their dependencies rather than letting
    them create those dependencies. In Unity, this is often achieved through constructor
    injection or property injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced coupling**: By injecting dependencies, classes become less dependent
    on specific implementations, reducing tight coupling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Classes with injected dependencies are often easier to test
    because you can provide mock or test implementations for those dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Different implementations of a dependency can be injected,
    enabling easy swapping of components without modifying existing code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DI can help mitigate some of the issues associated with the Singleton pattern
    in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced global state**: By injecting dependencies, you can avoid creating
    global singletons, reducing the overall global state in your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier testing**: Code relying on injected dependencies is generally easier
    to test because you can replace real implementations with mock objects or test-specific
    instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved modularity**: DI encourages a modular design where components are
    loosely coupled, making it easier to understand and maintain the code base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton design pattern provides a single, globally accessible instance
    of a class, offering convenience but potentially leading to issues such as tight
    coupling and difficulty in testing. DI addresses these concerns by allowing objects
    to be provided with their dependencies externally, reducing reliance on a global
    state. This promotes loose coupling, enhances testability, and improves code maintainability
    by decoupling components and facilitating the easier management of object life
    cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Flyweight pattern in Unity offers a solution for optimizing memory usage
    by sharing common data across multiple objects. It allows you to efficiently manage
    resources by storing shared data externally and referencing it when needed. *Figure
    2**.2* illustrates Flyweight’s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Flyweight design pattern structure](img/B22017_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Flyweight design pattern structure
  prefs: []
  type: TYPE_NORMAL
- en: In the following code blocks, you’ll see an example scenario where the Flyweight
    pattern can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IWeapon` interface represents the shared properties and behaviors of weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Weapon` class implements the `IWeapon` interface and acts as a concrete
    Flyweight class representing individual weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WeaponFactory` class acts as a Flyweight factory, managing and reusing
    flyweight objects based on specific keys (e.g., weapon types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GameClient` class demonstrates how to use the flyweight objects retrieved
    from the factory, showcasing the reusability and memory efficiency of the Flyweight
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This example simulates a game scenario where different types of weapons are
    represented as flyweight objects, and the factory efficiently manages these shared
    objects to optimize memory usage and improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the pros of using the Flyweight pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory optimization**: By sharing common data, the pattern reduces memory
    consumption, especially for large numbers of similar objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved performance**: Sharing reduces the overhead of creating and managing
    redundant data, leading to better performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified code**: Separating shared and unique data promotes cleaner and
    more maintainable code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the cons of using the Flyweight pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Implementing the Flyweight pattern introduces additional complexity,
    especially when managing shared and unique states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential overhead**: While the pattern improves memory and performance,
    it may introduce overhead due to managing shared resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these considerations, the Flyweight pattern remains a valuable tool
    for efficient resource management in Unity projects, particularly in scenarios
    with many similar objects requiring memory optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Observer design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Observer pattern in Unity promotes loose coupling between objects by allowing
    them to subscribe to events and receive notifications when those events occur.
    This way, objects can react to changes without needing to know the specific details
    of the object raising the event.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.3* illustrates Observer’s structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Observer design pattern structure](img/B22017_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Observer design pattern structure
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a simple example in Unity to demonstrate the implementation of
    a health system using the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we can see the `IHealthObserver` Observer interface
    and the `IHealthSubject` subject interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the `HealthManager` class implementing
    `IHealthSubject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the `UIObserver` class implementing
    `IHealthObserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see the `GameplayObserver` class implementing
    `IHealthObserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we can see a usage example for the Observer pattern
    in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `HealthManager` class represents the subject, and the `UIObserver`
    and `GameplayObserver` classes represent observers. When the character takes damage,
    `HealthManager` triggers the `OnHealthChanged` event, notifying all registered
    observers. Each observer then updates its state based on the received health value,
    demonstrating the Observer pattern in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the pros of using the Observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved decoupling**: Objects are not dependent on each other’s implementation
    details, promoting loose coupling and modularity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced maintainability**: Code becomes easier to understand and modify
    because event handling is centralized and observers are decoupled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased flexibility**: Allows for the dynamic addition and removal of observers,
    making the system more adaptable to changing requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the cons of using the Observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased complexity**: Introduces additional abstraction layers compared
    to direct communication, which can slightly increase code complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance overhead**: Event handling involves method calls and potentially
    data transfer, which can lead to some performance overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the Observer pattern is a powerful tool for facilitating communication
    between objects and managing dynamic changes in Unity. The benefits of loose coupling
    and flexibility outweigh the drawbacks in most situations involving event-driven
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, here are some other applications of the Observer pattern in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing state machines for characters and enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating UI elements based on changes in game state (e.g., score, level, and
    inventory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering animations or sound effects based on specific events in the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, you can find all the examples on GitHub for reference.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not mandatory to use these patterns in all your code. They serve as solutions
    to common problems, but sometimes, implementing patterns might complicate things
    unnecessarily. The key is to focus on solving the problem at hand first and then
    look for the best solution. In the following section, we will delve into coding
    conventions and explore best practices for writing clear code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding conventions and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maintaining consistent and clear code is essential for effective development
    and collaboration. Adhering to recognized conventions and best practices enhances
    code clarity, maintainability, and readability. Here’s a breakdown of key aspects
    of C# coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C# naming conventions**: Understanding and implementing C# naming conventions
    is pivotal for maintaining code consistency and clarity. Let’s delve into best
    practices for naming variables, methods, classes, and namespaces to ensure our
    code is both readable and expressive:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables**: Adopt **camelCase** (e.g., **playerScore**, **enemyHealth**)
    and opt for descriptive names conveying the variable’s purpose (e.g., **currentLevel**,
    **isGameOver**). Avoid abbreviations unless widely understood (e.g., fps for frames
    per second).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods**: Utilize **PascalCase** (e.g., **StartGame**, **MovePlayer**) and
    ensure the method name precisely reflects its functionality. Use verbs for action-oriented
    methods (e.g., **CalculateDamage**, **LoadLevel**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes**: Employ PascalCase for class names (e.g., **Player**, **EnemyController**)
    and avoid generic names such as **MyClass** or **NewClass**. Choose descriptive
    names representing the class’s purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespaces**: Apply PascalCase for namespaces (e.g., **MyGame.Characters**,
    **Utility.Math**) and organize code into meaningful hierarchical namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meaningful and descriptive names**: Crafting meaningful and descriptive names
    is fundamental to writing clear and understandable code. Let’s explore guidelines
    for selecting names that accurately convey the purpose and type of variables,
    avoiding ambiguity and enhancing code readability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose names that accurately reflect the represented entity.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid ambiguous names such as **temp** or **data**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use prefixes and suffixes to clarify variable types (e.g., **isJumping**, **playerPosition**).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code formatting**: Mastering code formatting is a fundamental aspect of writing
    clean and organized code. Let’s explore key elements such as indentation, spacing,
    and comments to enhance readability and structure in your programming endeavors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indentation**: Employ consistent indentation for enhanced readability and
    structure'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spacing**: Introduce appropriate spacing around operators, keywords, and
    parentheses'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comments**: Include comments to elucidate complex logic, clarify algorithms,
    and document code functionality'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling and exception management**: Error handling and exception management
    are critical aspects of software development, ensuring robustness and reliability
    in handling unexpected scenarios. Let’s delve into effective strategies, such
    as using **try-catch** blocks and providing meaningful feedback, to manage errors
    gracefully and enhance user experience:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement robust error handling for graceful management of unexpected situations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **try-catch** blocks to capture exceptions and provide meaningful user feedback
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid ignoring errors to prevent unpredictable behavior
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method and class length**: When it comes to method and class length, maintaining
    a balance between conciseness and clarity is paramount to fostering maintainable
    code bases. Let’s explore strategies for keeping methods and classes concise while
    ensuring they remain focused and easy to understand, promoting code readability
    and maintainability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strive for concise and focused methods and classes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Steer clear of “monolithic classes” handling everything, making them challenging
    to understand and maintain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract complex functionality into separate methods for clarity and reusability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional best practices**: In pursuit of robust and maintainable code,
    embracing additional best practices beyond the fundamentals is essential. Let’s
    delve into strategies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employ meaningful constants instead of magic numbers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the use of global variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid deeply nested code and excessive indentation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Embarking on a journey through essential coding conventions and best practices,
    we explored fundamental aspects such as C# naming conventions, where clarity and
    consistency reign supreme. We discussed the nuances of meaningful and descriptive
    names, mastering the art of code formatting, navigating error handling and exception
    management, and optimizing method and class length, as well as discovered additional
    best practices to refine your code base for robustness and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore some refactoring techniques with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refactoring techniques involve breaking down long and complex methods into smaller,
    focused functions and eliminating duplicated code to adhere to principles such
    as **Don’t Repeat Yourself** (**DRY**) and **Keep It Simple, Stupid** (**KISS**),
    ultimately resulting in cleaner and more maintainable Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a couple of examples of code smells in Unity projects that may
    indicate a need for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Long and complex method'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following code block, we can see that the `PlayerController` class has
    a long method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code smell here is the `HandlePlayerInput` method is lengthy and handles
    multiple tasks, making it hard to maintain. Refactor it into smaller, dedicated
    functions for specific player actions, such as movement, shooting, and jumping.
  prefs: []
  type: TYPE_NORMAL
- en: '*After refactoring*, in the following code block, we can see the `PlayerController`
    class has methods for each piece of logic instead of a large method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 2: Duplicated code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following code block, we can see the `EnemyAI` class has duplicated
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code smell here is that duplicated code for attacking the player, ally,
    and boss poses maintenance hurdles. Refactor by crafting a single method for attacking
    and invoking it with distinct parameters to eliminate redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: '*After refactoring*, in the following code block, we can see `EnemyAI` has
    common code for attacking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These refactoring examples adhere to the DRY and KISS principles, resulting
    in cleaner and more maintainable Unity code. In the next couple of bullet points,
    we will take a look at the definitions of DRY and KISS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DRY principle**: The DRY principle is a software development concept advocating
    for the avoidance of code duplication. It emphasizes that each piece of knowledge
    or logic within a system should have a single, unambiguous representation to reduce
    redundancy. By following DRY, developers aim to enhance maintainability, reduce
    the chance of errors, and improve code readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KISS principle**: The KISS principle suggests that simplicity should be a
    key goal in design and decision-making. It encourages developers to favor straightforward,
    uncomplicated solutions over complex ones. KISS asserts that simplicity often
    leads to better understandability, maintainability, and reduced chances of errors.
    The principle is a reminder to avoid unnecessary complexity when solving problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By identifying and addressing code smells in Unity projects, we ensure cleaner,
    more maintainable code. Through examples such as breaking down long methods and
    eliminating duplicated code, we adhere to principles such as DRY and KISS, resulting
    in improved code quality and readability.
  prefs: []
  type: TYPE_NORMAL
- en: Time to demonstrate your knowledge! Give these questions and challenges a try.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the primary goal of writing clean code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a singleton pattern for managing game settings such as sound volume,
    music volume, and screen resolution. Ensure that there is only one instance of
    the settings manager throughout the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a singleton score manager that tracks the player’s score across multiple
    game levels or scenes. Ensure that the score manager instance persists between
    scene changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a flyweight pattern using object pooling for bullets in a shooting
    game. The flyweight should efficiently manage the creation and reuse of bullet
    objects to minimize memory overhead during gameplay.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a flyweight pattern for rendering a tile-based map in a 2D game. Optimize
    the rendering process by reusing flyweight tile objects for similar tile types,
    such as grass, water, and rocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop an observer pattern-based event system for handling in-game events such
    as player deaths, power-up pickups, and level completions. Implement observers
    for different event types and ensure efficient event broadcasting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an observer pattern implementation to update UI elements dynamically
    based on game events. For example, update health bars, score displays, and inventory
    icons using observers for player health changes, score increments, and item pickups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine singleton, flyweight, and observer patterns to design a player character
    system. Use the singleton pattern for player input handling, flyweight for managing
    player animations efficiently, and observers for handling player state changes
    (e.g., health, inventory).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a game system (e.g., inventory management, quest tracking) and choose
    the most suitable design patterns (singleton, flyweight, observer, etc.) to implement
    various aspects of the system. Justify your design decisions based on SOLID principles
    and scalability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To wrap up this chapter, remember that writing neat and well-organized C# code
    is key for successful Unity game development. The skills you’ve gained, such as
    naming things sensibly and arranging code logically, will make your game creation
    journey smoother. Keeping things simple and avoiding repeated code make your work
    easier to grasp and maintain. Applying these ideas will lead to games with code
    that just makes sense, making you a more efficient and effective game developer.
    It’s important to note that the journey toward clean code and best practices is
    ongoing. You don’t have to apply all the principles in every project, but consistently
    incorporating them into your coding mindset will enhance your skills over time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, gear up for the next chapter, where you’ll explore Unity plugins. You will
    discover how to identify and evaluate various types of plugins, seamlessly integrating
    them into your projects. This knowledge will empower you to enhance game features,
    save development time, and implement new mechanics using C#. So, get ready for
    [*Chapter 3*](B22017_03.xhtml#_idTextAnchor049), where you’ll broaden your Unity
    toolkit and elevate your game development skills.
  prefs: []
  type: TYPE_NORMAL
