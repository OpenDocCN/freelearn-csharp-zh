<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer092">
<h1 id="_idParaDest-195"><a id="_idTextAnchor194"/>Assessments</h1>
<p>This section contains answers to questions from all chapters.</p>
<h1 id="_idParaDest-196"><em class="italic"><a id="_idTextAnchor195"/></em><a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, Managed Threading Concepts </h1>
<ol>
<li>A managed thread is a thread that is created in .NET-managed code with the<span class="superscript"> </span><strong class="source-inline">System.Threading.Thread</strong> object. </li>
<li>Set the <strong class="source-inline">Thread.IsBackground</strong> property to <strong class="source-inline">true</strong> before calling <strong class="source-inline">Thread.Start()</strong>. </li>
<li>.NET will throw a <strong class="source-inline">ThreadStateException</strong> exception. </li>
<li>.NET prioritizes managed threads mostly based on their <strong class="source-inline">Thread.Priority</strong> value. </li>
<li><strong class="source-inline">ThreadPriority.Highest</strong>.</li>
<li><strong class="source-inline">Thread.Abort()</strong> is not supported by .NET 6. The code will not compile. </li>
<li>Add an object parameter to the method to be started by the new thread, and pass the data when calling <strong class="source-inline">Thread.Start(data)</strong>. </li>
<li>Pass the delegate to the cancellation token’s <strong class="source-inline">Register</strong> method. </li>
</ol>
<h1 id="_idParaDest-197"><em class="italic"><a id="_idTextAnchor196"/></em><a href="B18552_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, Evolution of Multithreaded Programming 
in .NET </h1>
<ol>
<li value="1"><strong class="source-inline">ThreadPool </strong></li>
<li>C# 5.0 </li>
<li>.NET Framework 4.5 </li>
<li>.NET Core 3.0 </li>
<li><strong class="source-inline">Task</strong>, <strong class="source-inline">Task&lt;T&gt;</strong>, <strong class="source-inline">ValueTask</strong>, or <strong class="source-inline">ValueTask&lt;T&gt;</strong> </li>
<li><strong class="source-inline">ConcurrentDictionary&lt;TKey, TValue&gt;</strong> </li>
<li><strong class="source-inline">BlockingCollection&lt;T&gt;</strong> </li>
<li><strong class="bold">Parallel LINQ</strong> (<strong class="bold">PLINQ</strong>) </li>
</ol>
<h1 id="_idParaDest-198"><em class="italic"><a id="_idTextAnchor197"/></em><a href="B18552_03_ePub.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, Best Practices for Managed Threading </h1>
<ol>
<li value="1">Singleton.</li>
<li><strong class="source-inline">ThreadStatic</strong>. </li>
<li>A deadlock occurs when multiple threads are all waiting to access a locked resource and cannot proceed. </li>
<li><strong class="source-inline">Monitor.TryEnter</strong>.</li>
<li><strong class="source-inline">Interlocked</strong>.</li>
<li><strong class="source-inline">Interlocked.Add</strong>.</li>
<li><strong class="source-inline">MaxDegreeOfParallelism</strong>.</li>
<li>Use the <strong class="source-inline">WithDegreeOfParallelism</strong> extension method.</li>
<li><strong class="source-inline">ThreadPool.GetMinThreads()</strong>.</li>
</ol>
<h1 id="_idParaDest-199"><em class="italic"><a id="_idTextAnchor198"/></em><a href="B18552_04_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, User Interface Responsiveness and Threading </h1>
<ol>
<li value="1"><strong class="source-inline">Task</strong> or <strong class="source-inline">Task&lt;T&gt;</strong>.</li>
<li><strong class="source-inline">Task.WhenAll</strong>.</li>
<li><strong class="source-inline">Task.Factory.StartNew</strong>.</li>
<li>A background thread on <strong class="source-inline">ThreadPool</strong>.</li>
<li><strong class="source-inline">Application.Current.Dispatcher.Invoke</strong>.</li>
<li><strong class="source-inline">this.BeginInvoke</strong>.</li>
<li>Check the <strong class="source-inline">this.InvokeRequired</strong> property.</li>
</ol>
<h1 id="_idParaDest-200"><em class="italic"><a id="_idTextAnchor199"/></em><a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>, Asynchronous Programming with C# </h1>
<ol>
<li value="1"><strong class="source-inline">Task.Result</strong>.</li>
<li><strong class="source-inline">Task.WhenAll()</strong>.</li>
<li><strong class="source-inline">Task.WaitAll()</strong>.</li>
<li><strong class="source-inline">Task</strong>, <strong class="source-inline">Task&lt;TResult&gt;</strong>, <strong class="source-inline">ValueTask</strong>, or <strong class="source-inline">ValueTask&lt;TResult&gt;</strong>.</li>
<li>I/O-bound operations such as a file or network access are best suited for async methods. </li>
<li>False. It is a best practice to always suffix async methods with <strong class="source-inline">Async</strong>. </li>
<li><strong class="source-inline">Task.Run</strong>.</li>
</ol>
<h1 id="_idParaDest-201"><em class="italic"><a id="_idTextAnchor200"/></em><a href="B18552_06_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, Parallel Programming Concepts </h1>
<ol>
<li value="1"><strong class="source-inline">Parallel.For</strong>.</li>
<li><strong class="source-inline">Parallel.ForEachAsync</strong>. </li>
<li><strong class="source-inline">Parallel.Invoke</strong>. </li>
<li><strong class="source-inline">TaskCreationOptions.AttachToParent</strong>. </li>
<li><strong class="source-inline">TaskCreationOptions.DenyAttach</strong>. </li>
<li><strong class="source-inline">Task.Run</strong> will always deny child tasks from attaching. Also, <strong class="source-inline">Task.Run</strong> has no overloaded methods to provide <strong class="source-inline">TaskCreationOptions</strong>. </li>
<li>No, regular <strong class="source-inline">for</strong> and <strong class="source-inline">foreach</strong> loops can be faster if each loop iteration is fast-running and/or there are only a few iterations of the loop.</li>
</ol>
<h1 id="_idParaDest-202"><em class="italic"><a id="_idTextAnchor201"/></em><a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, Task Parallel Library (TPL) and Dataflow</h1>
<p>The following are the answers to this chapter’s questions:</p>
<ol>
<li value="1"><strong class="source-inline">JoinBlock</strong>.</li>
<li><strong class="source-inline">BufferBlock</strong> is a propagator block.</li>
<li><strong class="source-inline">BufferBlock</strong>.</li>
<li><strong class="source-inline">JoinTo()</strong>.</li>
<li><strong class="source-inline">Complete()</strong>.</li>
<li><strong class="source-inline">SendAsync()</strong>.</li>
<li><strong class="source-inline">ReceiveAsync()</strong>.</li>
</ol>
<h1 id="_idParaDest-203"><em class="italic"><a id="_idTextAnchor202"/></em><a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, Parallel Data Structures and Parallel LINQ </h1>
<ol>
<li value="1"><strong class="source-inline">AsParallel()</strong>. </li>
<li><strong class="source-inline">AsSequential()</strong>. </li>
<li><strong class="source-inline">AsOrdered()</strong>. </li>
<li><strong class="source-inline">ForAll()</strong>.</li>
<li><strong class="source-inline">AsOrdered()</strong> can significantly decrease performance for a query. </li>
<li><strong class="source-inline">OrderBy</strong> and <strong class="source-inline">OrderByDescending</strong>. They will default to <strong class="source-inline">ParallelMergeOptions.FullyBuffered</strong>. </li>
<li>No. PLINQ has additional overhead that can cause queries on smaller datasets or simple queries to be slower. </li>
<li><strong class="source-inline">ParallelMergeOptions.NotBuffered</strong>.</li>
</ol>
<h1 id="_idParaDest-204"><em class="italic"><a id="_idTextAnchor203"/></em><a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, Working with Concurrent Collections in .NET</h1>
<ol>
<li value="1"><strong class="source-inline">BlockingCollection&lt;T&gt;</strong>. </li>
<li><strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong>. </li>
<li><strong class="source-inline">BlockingCollection&lt;T&gt;</strong>. </li>
<li><strong class="source-inline">ConcurrentDictionary&lt;TKey, TValue&gt;</strong>. </li>
<li><strong class="source-inline">Enqueue()</strong>. </li>
<li><strong class="source-inline">TryAdd()</strong> and <strong class="source-inline">TryGetValue()</strong>. </li>
<li>No. Always add your own synchronization mechanisms when using extension methods with concurrent collections, including standard LINQ operators. </li>
</ol>
<h1 id="_idParaDest-205"><em class="italic"><a id="_idTextAnchor204"/></em><a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a>, Debugging Multithreaded Applications with Visual Studio </h1>
<ol>
<li value="1">Use the <strong class="bold">Attach to Process</strong> window or set multiple startup projects in the solution file. </li>
<li>They are grouped by process. </li>
<li>Right-click in the window and select <strong class="bold">Columns</strong>. </li>
<li>The <strong class="bold">Parallel Stacks</strong> window. </li>
<li><strong class="source-inline">.PNG</strong> files. </li>
<li>Four. </li>
<li>The <strong class="bold">Debug Location</strong> toolbar. </li>
<li>Click the <strong class="bold">Flag Just My Code</strong> button. </li>
</ol>
<h1 id="_idParaDest-206"><em class="italic"><a id="_idTextAnchor205"/></em><a href="B18552_11_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>, Canceling Asynchronous Work </h1>
<ol>
<li value="1"><strong class="source-inline">CancellationToken.IsCancellationRequested</strong> </li>
<li><strong class="source-inline">CancellationTokenSource</strong> </li>
<li><strong class="source-inline">OperationCanceledException</strong> </li>
<li>Register callback </li>
<li><strong class="source-inline">ManualResetEventSlim</strong> </li>
<li><strong class="source-inline">ManualResetEventSlim.Reset</strong> </li>
<li><strong class="source-inline">CancellationTokenSource.CreateLinkedTokenSource</strong> </li>
</ol>
<h1 id="_idParaDest-207"><em class="italic"><a id="_idTextAnchor206"/></em><a href="B18552_12_ePub.xhtml#_idTextAnchor186"><em class="italic">Chapter 12</em></a>, Unit Testing Async, Concurrent, and Parallel Code</h1>
<ol>
<li value="1"><strong class="source-inline">Fact</strong> </li>
<li><strong class="source-inline">SpinLock.WaitUntil</strong> </li>
<li><strong class="source-inline">AggregateException</strong> </li>
<li><strong class="source-inline">Exception</strong> </li>
<li><strong class="source-inline">Assert.NotNull</strong> </li>
<li><strong class="bold">Test Explorer </strong></li>
<li>MSTest, NUnit, and xUnit .NET </li>
<li>ReSharper, Rider, and the dotMemory Unit standalone console runner </li>
</ol>
</div>
</div>
</body></html>