<html><head></head><body>
		<div id="_idContainer178">
			<h1 id="_idParaDest-234"><em class="italic"><a id="_idTextAnchor239"/>Chapter 13</em>: Distributed Systems</h1>
			<p>In this chapter, you will learn about distributed applications and how you can improve their performance. You will understand how to build performant applications using the <strong class="bold">Command Query Responsibility Separation</strong> (<strong class="bold">CQRS</strong>) software design pattern, event sourcing, and microservices. You will learn how to use cloud providers such as Microsoft Azure to build scalable distributed solutions using Cosmos DB, Azure Functions, and the open source Pulumi infrastructure tool.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li><strong class="bold">Implementing the CQRS design pattern</strong>: In this section, we will implement the CQRS design pattern with a sample project that demonstrates the separation of commands and queries.</li>
				<li><strong class="bold">Implementing event sourcing</strong>: Many resources always show event sourcing with CQRS. But in this section, we will write a sample project that demonstrates pure event sourcing without CQRS. By doing this, you will know how to implement CQRS and event sourcing individually and be able to combine them to work together.</li>
				<li><strong class="bold">Using Microsoft Azure for distributed systems</strong>: In this section, we will provide a high-level overview of Azure Functions – specifically Durable Azure Functions – for providing robust, secure, and scalable serverless code that performs well in a distributed environment. We will also look at the difference between containers and serverless, and when to use one over the other.</li>
				<li><strong class="bold">Managing your cloud infrastructure with Pulumi</strong>: Managing Azure resources can become unwieldy, especially when the number of microservices you deploy increases. So, in this section, we will look at how Pulumi allows you to manage your cloud infrastructure and resources using pure C# that you can include in your build, test, and deploy pipelines.</li>
			</ul>
			<p>By completing this chapter, you will gain the following skills:</p>
			<ul>
				<li>You will be able to separate commands and queries into different services.</li>
				<li>You will be able to persist state changes as sequences of state-changing events.</li>
				<li>You will be able to understand the difference between containers and serverless, and you will be able to know when to use one over the other.</li>
				<li>You will understand the different types of Durable Azure Function types and design patterns so that you can use them to build serverless functions.</li>
				<li>You will be able to manage your cloud using Pulumi.</li>
			</ul>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor240"/>Technical requirements</h1>
			<p>You’ll need the following components to follow along with this chapter and perform the necessary programming tasks:</p>
			<ul>
				<li>Visual Studio 2022 or later</li>
				<li>This book’s source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13</a></li>
				<li>Optional: A Microsoft Azure account</li>
				<li>Optional: A Pulumi subscription</li>
			</ul>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor241"/>Implementing the CQRS design pattern</h1>
			<p>In this section, we will look at the <strong class="bold">Command Query Responsibility Separation</strong> (<strong class="bold">CQRS</strong>) design pattern. In simple terms, a command<a id="_idIndexMarker1344"/> is a method that performs an action, while a query is a method that returns data. Commands do not perform queries, and queries do not perform commands. Commands can have separate models for queries. Now, let’s write a simple console application that demonstrates how easy it is to implement this pattern, which is used extensively in microservice development:</p>
			<ol>
				<li>Start a new console application called <strong class="source-inline">CH13_CQRSPattern</strong>.</li>
				<li>Add a new class called <strong class="source-inline">CQRSBasedClass</strong>.</li>
				<li>Add the <strong class="source-inline">SleepCommand</strong> method:<p class="source-code">public void SleepCommand(int milliseconds)</p><p class="source-code">{</p><p class="source-code">    Thread.Sleep(milliseconds);</p><p class="source-code">}</p></li>
			</ol>
			<p>Our <strong class="source-inline">SleepCommand</strong> method<a id="_idIndexMarker1345"/> is an example of a command. It takes in a parameter that is several milliseconds in length. A command is then executed that causes the current thread to sleep for the number of milliseconds specified by the caller. This particular command does not return a value.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">DateTimeQuery</strong> method:<p class="source-code">public DateTime DateTimeQuery()</p><p class="source-code">{</p><p class="source-code">    return DateTime.Now;</p><p class="source-code">}</p></li>
			</ol>
			<p>Our <strong class="source-inline">DateTimeQuery</strong> method is an example of a query. It is a parameterless query, although queries can have parameters. The query does not perform any commands. It simply returns the current date and time to the caller.</p>
			<ol>
				<li value="5">In the <strong class="source-inline">Program</strong> class, add the <strong class="source-inline">ExecuteCommand</strong> method:<p class="source-code">private static void ExecuteCommand()</p><p class="source-code">{</p><p class="source-code">    new CQRSBasedClass().SleepCommand(1000);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ExecuteCommand</strong> method executes <strong class="source-inline">SleepCommand</strong> in our <strong class="source-inline">CQRSBasedClass</strong>, which causes the current thread to sleep for 1 second.</p>
			<ol>
				<li value="6">Add the <strong class="source-inline">ExecuteQuery</strong> method:<p class="source-code">private static DateTime ExecuteQuery()</p><p class="source-code">{</p><p class="source-code">    return new CQRSBasedClass().DateTimeQuery();</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ExecuteQuery</strong> method executes <strong class="source-inline">DateTimeQuery</strong> in our <strong class="source-inline">CQRSBasedClass</strong>, which queries<a id="_idIndexMarker1346"/> the current date and time and returns the value.</p>
			<ol>
				<li value="7">Update the <strong class="source-inline">Program.cs</strong> file, as follows:<p class="source-code">    Console.WriteLine("Hello, World! This is the most </p><p class="source-code">        simple example of CQRS in action.");</p><p class="source-code">    ExecuteCommand();</p><p class="source-code">    Console.WriteLine($"The current date and time is: </p><p class="source-code">      {ExecuteQuery()}.");</p></li>
			</ol>
			<p>We start our program by writing a message to the console. Then, we call <strong class="source-inline">ExecuteCommand</strong>. Finally, we write a message to the console that includes the current date and time that is returned by the call to <strong class="source-inline">ExecuteQuery</strong>.</p>
			<p>As you can see, in its most basic form, the CQRS pattern is really simple. A command performs an action and nothing else, while a query performs a query and nothing else. We can shift commands into their own command class so that the only purpose of the class is to execute commands. We can do the same with queries by placing them in their own query class so that all the query class does is returns queries.</p>
			<p>If you study this book’s source code, you will see that we have done this. We have a <strong class="source-inline">CommandClass</strong> with a command called <strong class="source-inline">Sleep</strong>. We also have a <strong class="source-inline">QueryClass</strong> with a query called <strong class="source-inline">Now</strong>. CQRS is the enabling pattern that’s used in microservice development. It is often used in conjunction with message brokers, message buses, message sending and receiving, domain modeling, domain<a id="_idIndexMarker1347"/> events, event sourcing, eventual consistency, separate read and write models, and <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>). This is where people tend to become lost. But even though the CQRS pattern is used alongside all these, the pattern itself is very simple, and it enables these other patterns and technologies to gel nicely together.</p>
			<p>In terms of database operations, you can think of the <strong class="source-inline">add</strong>, <strong class="source-inline">edit</strong>, <strong class="source-inline">delete</strong>, and <strong class="source-inline">update</strong> operations as commands, and you can think of <strong class="source-inline">select</strong> operations as queries.</p>
			<p>Now that we have a simple<a id="_idIndexMarker1348"/> understanding of the CQRS pattern, in the next section, we will turn our attention to understanding and implementing event sourcing.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor242"/>Implementing event sourcing</h1>
			<p>When you consider documents<a id="_idIndexMarker1349"/> in a document store and records in a database, these are normally a business’s point of truth. Their state is the source of truth. </p>
			<p>Event sourcing record events become your source of truth rather than the state of data in tables, or the state of documents in document stores.</p>
			<p>So, instead of using the state as a point of truth, we can use recorded events as a source of truth.</p>
			<p>In the old days<a id="_idIndexMarker1350"/> of programming, this was known as an audit trail. I remember working on a database several years ago. It had an audit table. In that table, there was a record of all the actions that were carried out on the database and by whom. We could tell when data operations took place, what those data operations were, and who or what process was carried out those data operations. Then, if anything went wrong with the database, we could analyze that table and know which operation caused the resulting problems. To store this information, we would use database triggers that fired on every <strong class="source-inline">add</strong>, <strong class="source-inline">update</strong>, <strong class="source-inline">delete</strong>, and <strong class="source-inline">read</strong> operation. These triggers were events that fired upon a data operation that recorded what data modifications had taken place, who made those modifications, why they made the changes, and at what date and time those modifications took place.</p>
			<p>In this section, we will look at event sourcing, which records events that become your source of truth. Events allow you to understand how you arrived at a particular state at a particular point in time.</p>
			<p>An easy way to understand the benefits of event sourcing is to have a look at your bank statement. When you receive your bank statement, you start with the balance that was carried over from the previous month. Then, you see a list of transactions that took place during the period covered by the statement, which consists of money entering your account and money leaving<a id="_idIndexMarker1351"/> your account. Each of these transactions is an event. These events can be money transfer in, money transfer out, direct debit payment, interest payment, standing order payment, bank charge payment, payment of goods, salary/wages being paid in, and so forth.</p>
			<p>When you consider this scenario, your bank statement shows how you came to have the money come in and leave your account. But from a database point of view, just by looking at the data, this is not so easy. When you look at the data, you usually have to write a query that joins multiple tables in a relational database together to reveal the facts of how the state of your account changed. But you don’t necessarily know the context that led to those changes being made.</p>
			<p>However, in the same scenario, when you store events, you are storing facts. These facts are based on true events that happened in the past, and that is why they can be trusted.</p>
			<p>As for transactional logs, they inform you of what state changes took place. However, they don’t necessarily tell you why those state changes were made. On the other hand, when you store events, they inform you of what state changes were made, and the reason why those state changes were made.</p>
			<p>Events are stored as aggregates in an append-only form. An aggregate is a consistency guard. You can see the state changes and the context that led to those changes. This means that you can revert the state to the last known consistent state at a particular point in time by replaying events forward or backward. You can use the event log to provide an audit trail. Information such as why and when can be very useful to various business functions, such as senior management, marketing, finance, and resource planning, since event logs are full of very valuable business information.</p>
			<p>Going back to our example scenario, an event represents a fact that took place in our banking domain. Each event in our banking system is a source of truth from which our bank account’s current state is derived. Such facts are immutable business facts.</p>
			<p>Our banking events will follow the normal methodology of providing state information, metadata that provides contextual information, the date and time when it happened, and other information that is necessary and appropriate.</p>
			<p>Let’s look at an example of how we can aggregate events so that they arrive at a specific state for our bank account:</p>
			<ul>
				<li>Events:<ul><li>A dividend of £39 was issued <a id="_idIndexMarker1352"/>by the investment firm to the customer at 12:43 A.M. on June 12, 2021.</li><li>A dividend of £39 was paid into the customer’s bank account by the investment firm at 12:45 A.M. on June 12, 2021.</li></ul></li>
				<li>Events<ul><li>A salary of £2,300 paid was into the customer’s bank account by the employer at 12:00 A.M. on July 25, 2021, using BACS.</li><li>A standing order of £230 was transferred from the customer’s bank account into their savings account to build up an emergency stash at 09:11 A.M. on July 26, 2021.</li><li>A direct debit of £432 was paid to the local authority for rent from the customer’s bank account at 07:00 P.M. on July 25, 2021, using the relevant Android banking app.</li><li>A direct debit of £103 was paid to the local authority for council tax at 08:29 P.M. on July 26, 2021, using online banking.</li><li>£23.79 was paid for groceries to the merchant by the customer using contactless payment at 09:35 P.M. on July 27, 2021.</li></ul></li>
			</ul>
			<p>As you can see from our banking scenario, when we use events as our fact-based points of truth, we see the full context of where the money is coming from, where the money is going, and by which method, what the amount is, and the precise date and time when it takes place.</p>
			<p>These events ensure the data is in a consistent state, that there is an audit trail, and that valuable information is provided that allows business decisions to be made based on trustworthy facts.</p>
			<p>Continuing with our banking scenario, each bank account would have a stream and unique identifier. All events that occur against that bank account will be recorded via its stream. So, we end up with one stream per aggregate. In our banking scenario, our aggregate is the group of events that take place against a specific bank account.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor243"/>Event sourcing example project</h2>
			<p>In this section, we will write<a id="_idIndexMarker1353"/> a simple event sourcing application that also provides examples of usage. To implement the project, follow these steps:</p>
			<ol>
				<li value="1">Start a new .NET 6.0 console application and call it <strong class="source-inline">CH13_EventSourcing</strong>.</li>
				<li>Add a public interface called <strong class="source-inline">IEvent</strong> with an empty method body. This is a convenient interface for marking any object an event.</li>
				<li>Add a new public interface called <strong class="source-inline">IRegisterable</strong> and add the following method:<p class="source-code">void RegisterWithEventAggregator(IEventAggregator </p><p class="source-code">    eventAggregator);</p></li>
			</ol>
			<p>This method allows registerable objects to register themselves with an event aggregator.</p>
			<ol>
				<li value="4">Add a new public interface called <strong class="source-inline">IEventAggregator</strong> and add the following methods:<p class="source-code">void Register(IRegisterable registerable);</p><p class="source-code">void Register&lt;T&gt;(EventHandler&lt;T&gt; eventhandler) where</p><p class="source-code">     T : IEvent;</p><p class="source-code">void RaiseEvent(IEvent evt);</p></li>
			</ol>
			<p>The <strong class="source-inline">Register</strong> method is used for registering objects of the <strong class="source-inline">IRegisterable</strong> type with the event aggregator. The <strong class="source-inline">Register&lt;T&gt;</strong> method registers an event handler of the <strong class="source-inline">T</strong> type for the specified object type. Finally, the <strong class="source-inline">RaiseEvent</strong> executes the event that was passed in as a parameter.</p>
			<ol>
				<li value="5">Add a new class called <strong class="source-inline">EventHandler</strong> and replace its contents with the following code:<p class="source-code">namespace CH13_EventSourcing;</p><p class="source-code">public delegate void EventHandler&lt;T&gt;(T evt) where T : </p><p class="source-code">    IEvent;</p></li>
			</ol>
			<p>This delegate defines our event handler, which is of the <strong class="source-inline">T</strong> type, for events of the <strong class="source-inline">IEvent</strong> type.</p>
			<ol>
				<li value="6">Add a new class called <strong class="source-inline">SingleThreadedEventAggregator</strong> that implements the <strong class="source-inline">IEventAggregator</strong> interface.</li>
				<li>Add the following dictionary<a id="_idIndexMarker1354"/> field to hold our event handlers:<p class="source-code">IDictionary&lt;Type, IList&lt;EventHandler&lt;IEvent&gt;&gt;&gt; </p><p class="source-code">    _eventHandlers; </p></li>
			</ol>
			<p>This dictionary defines a list of event handlers of the <strong class="source-inline">IEvent</strong> type for objects of a specified type.</p>
			<ol>
				<li value="8">Add the following constructor:<p class="source-code">public SingleThreadedEventAggregator()</p><p class="source-code">{</p><p class="source-code">     _eventHandlers = new Dictionary&lt;Type, </p><p class="source-code">         IList&lt;EventHandler&lt;IEvent&gt;&gt;&gt;();</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we instantiate our dictionary of event handlers.</p>
			<ol>
				<li value="9">Update the <strong class="source-inline">Register</strong> method, as shown here:<p class="source-code">public void Register(IRegisterable registerable)</p><p class="source-code">{</p><p class="source-code">     registerable.RegisterWithEventAggregator(this);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method registers our event aggregator with the registerable type that was passed in.</p>
			<ol>
				<li value="10">Update the <strong class="source-inline">Register&lt;T&gt;</strong> method, as<a id="_idIndexMarker1355"/> shown here:<p class="source-code">public void Register&lt;T&gt;(EventHandler&lt;T&gt; eventHandler) </p><p class="source-code">    where T : IEvent</p><p class="source-code">{</p><p class="source-code">     if (!_eventHandlers.ContainsKey(typeof(T)))</p><p class="source-code">     {</p><p class="source-code">          _eventHandlers[typeof(T)] = new </p><p class="source-code">             List&lt;EventHandler&lt;IEvent&gt;&gt;();</p><p class="source-code">     }</p><p class="source-code">     var eventHandlerList = _eventHandlers[typeof(T)];</p><p class="source-code">     eventHandlerList.Add(evt =&gt; eventHandler</p><p class="source-code">          ((T)evt));</p><p class="source-code">}</p></li>
			</ol>
			<p>This method checks our dictionary to see if it contains a key of the specified type; if it doesn’t, it adds one. Then, it creates a new event handler list of the specified type and adds the event handler.</p>
			<ol>
				<li value="11">Update the <strong class="source-inline">RaiseEvent</strong> method:<p class="source-code">public void RaiseEvent(IEvent evt)</p><p class="source-code">{</p><p class="source-code">     IList&lt;EventHandler&lt;IEvent&gt;&gt; eventHandlerList;</p><p class="source-code">     if (_eventHandlers.TryGetValue(evt.GetType(), </p><p class="source-code">         out eventHandlerList))</p><p class="source-code">     {</p><p class="source-code">         foreach (EventHandler&lt;IEvent&gt; eventHandler in </p><p class="source-code">             eventHandlerList)</p><p class="source-code">         {</p><p class="source-code">               eventHandler.Invoke(evt);</p><p class="source-code">           }</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method gets a list of event<a id="_idIndexMarker1356"/> handlers for the event that was passed in and loops through them, invoking them.</p>
			<ol>
				<li value="12">Add a new class called <strong class="source-inline">MultiThreadedEventAggregator</strong> that implements the <strong class="source-inline">IEventAggregator</strong> interface.</li>
				<li>Add the following dictionary to the class:<p class="source-code">IDictionary&lt;Type, IList&lt;EventHandler&lt;IEvent&gt;&gt;&gt; </p><p class="source-code">    _eventHandlers;</p></li>
			</ol>
			<p>This dictionary will hold a list of event handlers and their events.</p>
			<ol>
				<li value="14">Add the following constructor:<p class="source-code">public MultiThreadedEventAggregator()</p><p class="source-code">{</p><p class="source-code">     _eventHandlers = new ConcurrentDictionary&lt;Type, </p><p class="source-code">         IList&lt;EventHandler&lt;IEvent&gt;&gt;&gt;();</p><p class="source-code">}</p></li>
			</ol>
			<p>Our constructor initializes our list of event handlers. Notice that we are using a concurrent dictionary to handle multi-threaded scenarios.</p>
			<ol>
				<li value="15">Add the following method:<p class="source-code">public void Register(IRegisterable registerable)</p><p class="source-code">{              </p><p class="source-code">     registerable.RegisterWithEventAggregator(this);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method registers the event handlers<a id="_idIndexMarker1357"/> of the registerable object with the multi-threaded event aggregator.</p>
			<ol>
				<li value="16">Add the following <strong class="source-inline">Register</strong> method:<p class="source-code">public void Register&lt;T&gt;(EventHandler&lt;T&gt; eventHandler) </p><p class="source-code">    where T : IEvent</p><p class="source-code">{</p><p class="source-code">     if (!_eventHandlers.ContainsKey(typeof(T)))</p><p class="source-code">     {</p><p class="source-code">         _eventHandlers[typeof(T)] = new </p><p class="source-code">             List&lt;EventHandler&lt;IEvent&gt;&gt;();</p><p class="source-code">     }</p><p class="source-code">     var eventHandlerList = _eventHandlers[typeof(T)];</p><p class="source-code">     eventHandlerList.Add(evt =&gt; eventHandler((T)evt));</p><p class="source-code">}</p></li>
			</ol>
			<p>This method checks our dictionary to see if it contains a key of the specified type; if it doesn’t, it adds one. Then, it creates a new event handler list of the specified type and adds the event handler.</p>
			<ol>
				<li value="17">Add the <strong class="source-inline">RaiseEvent</strong> method:<p class="source-code">public void RaiseEvent(IEvent evt)</p><p class="source-code">{</p><p class="source-code">     IList&lt;EventHandler&lt;IEvent&gt;&gt; eventHandlerList;</p><p class="source-code">     if (_eventHandlers.TryGetValue(evt.GetType(), out </p><p class="source-code">        eventHandlerList))</p><p class="source-code">      {</p><p class="source-code">          Parallel.ForEach(eventHandlerList, </p><p class="source-code">              eventHandler =&gt;</p><p class="source-code">               {</p><p class="source-code">                   eventHandler.Invoke(evt);</p><p class="source-code">               });</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method loops through<a id="_idIndexMarker1358"/> all our event handlers stored in the event handler list and invokes them for the specified event that was passed in as an argument.</p>
			<p>This is the completed base project. Now, let’s look at an example of using our event sourcing code. </p>
			<ol>
				<li value="18">Add a folder called <strong class="source-inline">BankApp</strong>.</li>
				<li>Add the following <strong class="source-inline">DividendPayment</strong> class to the <strong class="source-inline">BankApp</strong> folder:<p class="source-code">internal class DividendPayment : IEvent</p><p class="source-code">{</p><p class="source-code">     public string From { get; set; }</p><p class="source-code">     public string To { get; set; }</p><p class="source-code">     public DateTime PaymentDate { get; set; }</p><p class="source-code">     public Decimal Amount { get; set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class defines our dividend payment event. This event provides information on a dividend payment regarding<a id="_idIndexMarker1359"/> who sent the payment, to whom the payment was made, the date of the payment, and the amount of the payment.</p>
			<ol>
				<li value="20">Add the <strong class="source-inline">InvalidDateException</strong> class to the <strong class="source-inline">BankApp</strong> folder:<p class="source-code">internal sealed class InvalidDateException : Exception</p><p class="source-code">{</p><p class="source-code">     public InvalidDateException() : base()</p><p class="source-code">     {</p><p class="source-code">     }</p><p class="source-code">     public InvalidDateException(string? message) </p><p class="source-code">         : base(message)</p><p class="source-code">     {</p><p class="source-code">     }</p><p class="source-code">      public InvalidDateException(string? message, </p><p class="source-code">          Exception? innerException) : base(message, </p><p class="source-code">              innerException)</p><p class="source-code">     {</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class implements the <strong class="source-inline">System.Exception</strong> class and will be used to inform others that an exception occurred due to an incorrect date.</p>
			<ol>
				<li value="21">Add the <strong class="source-inline">StandingOrderPayment</strong> class to the <strong class="source-inline">BankApp</strong> folder:<p class="source-code">internal class StandingOrderPayment : IEvent</p><p class="source-code">{</p><p class="source-code">     public string From { get; set; }</p><p class="source-code">     public string To { get; set; }</p><p class="source-code">     public DateOnly StartDate { get; set; }</p><p class="source-code">     public decimal Amount { get; set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class defines our standing<a id="_idIndexMarker1360"/> order payment event, which informs us of who pays the standing order and to whom, the start date of the standing order, and the amount to be paid.</p>
			<ol>
				<li value="22">Add the <strong class="source-inline">EventHandlers</strong> class to the <strong class="source-inline">BankApp</strong> folder, and update it as follows:<p class="source-code">internal class EventHandlers : IRegisterable</p><p class="source-code">{</p><p class="source-code">}</p></li>
			</ol>
			<p>Our class implements the <strong class="source-inline">IRegisterable</strong> interface and will be used to register our events with the event aggregator that was used for those events.</p>
			<ol>
				<li value="23">Add the following property and constructor:<p class="source-code">public string Name { get; }</p><p class="source-code">public EventHandlers(string name)</p><p class="source-code">{</p><p class="source-code">     Name = name;</p><p class="source-code">}</p></li>
			</ol>
			<p>This property is set in the constructor to label the <strong class="source-inline">EventHandlers</strong> class for easy human reference.</p>
			<ol>
				<li value="24">Add the following registration code:<p class="source-code">public void RegisterWithEventAggregator</p><p class="source-code">     (IEventAggregator eventAggregator)</p><p class="source-code">{   </p><p class="source-code">    eventAggregator.Register&lt;DividendPayment&gt;</p><p class="source-code">         (OnDividendPayment);  </p><p class="source-code">    eventAggregator.Register&lt;StandingOrderPayment&gt;</p><p class="source-code">         (OnStandingOrderPayment);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method registers the events and the event handlers for the dividend payments and standing orders with the event aggregator.</p>
			<ol>
				<li value="25">Add the following handler<a id="_idIndexMarker1361"/> method for dividend payments:<p class="source-code">private void OnDividendPayment(DividendPayment evt)</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Dividend paid by {evt.From} to </p><p class="source-code">        {evt.To} on {evt.PaymentDate} of </p><p class="source-code">            £{evt.Amount}.");</p><p class="source-code">}</p></li>
			</ol>
			<p>Every time a dividend payment is made, this event handler is called, and the properties of the dividend payment event are logged to the console window.</p>
			<ol>
				<li value="26">Add the following handler method for standing order payments:<p class="source-code">private void OnStandingOrderPayment</p><p class="source-code">    (StandingOrderPayment evt)</p><p class="source-code">{</p><p class="source-code">     try</p><p class="source-code">     {</p><p class="source-code">          Console.WriteLine($"Standing order paid by </p><p class="source-code">          {evt.From} to {evt.To} on {GetStanding</p><p class="source-code">          OrderDate(evt.StartDate)} of </p><p class="source-code">          £{evt.Amount}.");</p><p class="source-code">     }</p><p class="source-code">     catch (InvalidDateException idex)</p><p class="source-code">     {</p><p class="source-code">          Console.WriteLine(idex.Message);</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>Every time a standing order<a id="_idIndexMarker1362"/> payment is paid, this event handler is called. The properties of the standing order payment event are written out on the console. During this process, the payment date is checked to see if it is valid; if it’s not, then an <strong class="source-inline">InvalidDateException</strong> is raised.</p>
			<ol>
				<li value="27">Add the <strong class="source-inline">GetStandingOrderDate</strong> method:<p class="source-code">private static DateTime GetStandingOrderDate(DateOnly </p><p class="source-code">    startDate)</p><p class="source-code">{</p><p class="source-code">     if (DateTime.UtcNow.Ticks &lt; startDate.ToDateTime</p><p class="source-code">         (TimeOnly.FromTimeSpan(TimeSpan.Zero)).Ticks)</p><p class="source-code">          throw new InvalidDateException("Invalid </p><p class="source-code">            Date: Payment date cannot be before </p><p class="source-code">              standing order start date!");</p><p class="source-code">     if (DateTime.Now.Day &lt; startDate.Day)</p><p class="source-code">          throw new InvalidDateException("InvalidDate: </p><p class="source-code">            Payment cannot be made before the standing </p><p class="source-code">              order month pay day.");</p><p class="source-code">     return DateTime.Now;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes the start date<a id="_idIndexMarker1363"/> of the standing order and checks the date against the current date. An exception is thrown if the date is before the standing order start date or is not on or after the payment date for the month. Otherwise, the current date and time are returned.</p>
			<ol>
				<li value="28">Replace the text in the <strong class="source-inline">Program.cs</strong> class with the following:<p class="source-code">using CH13_EventSourcing;</p><p class="source-code">using CH13_EventSourcing.BankApp;</p><p class="source-code">using EventHandlers = CH13_EventSourcing.BankApp</p><p class="source-code">    .EventHandlers;</p><p class="source-code">SingleThreadedEventAggregator eventAggregator = new();</p><p class="source-code">EventHandlers eventHandlers = new("Payment Event </p><p class="source-code">    Handlers");</p><p class="source-code">DividendPayment dividendPayment = new DividendPayment </p><p class="source-code">    { From = "Company Name", To = "Customer Name", </p><p class="source-code">        PaymentDate = DateTime.Now, Amount = 23.45M };</p><p class="source-code">StandingOrderPayment standingOrderPayment = new </p><p class="source-code">    StandingOrderPayment { From = "Customer Name", To </p><p class="source-code">        = "Company One", StartDate = DateOnly.Parse</p><p class="source-code">            ("25/02/2022") };</p><p class="source-code">eventAggregator.Register(eventHandlers);</p><p class="source-code">eventAggregator.RaiseEvent(dividendPayment);</p><p class="source-code">eventAggregator.RaiseEvent(standingOrderPayment);</p></li>
			</ol>
			<p>This is our application entry point. We create an event aggregator that is single-threaded. Then, we create an instance of the <strong class="source-inline">EventHandlers</strong> class and pass it in the text that shows these event handlers are used to handle payment events. Next, we create two events – one for dividend payments and the other being for standing order payments. The instance of the <strong class="source-inline">EventHandlers</strong> class is then passed into the event aggregator so that the event handlers can be registered. Finally, the events for the dividend payment and standing order are raised.</p>
			<ol>
				<li value="29">Run the program. You should see something similar to the following output:</li>
			</ol>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B16617_Figure_13.1.jpg" alt="Figure 13.1 – The output of our event source application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – The output of our event source application</p>
			<p>With that, you have coded and run an event sourcing application. Before that, you did the same with a CQRS application. By writing<a id="_idIndexMarker1364"/> these two applications, you have seen pure CQRS and pure event sourcing at work. With this knowledge, you can now write applications that use these patterns individually or that combine them so that they work together. In the next section, we will provide a high-level overview of Microsoft Azure in terms of writing distributed systems.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor244"/>Using Microsoft Azure for distributed systems</h1>
			<p>In this section, we will learn how to use Azure<a id="_idIndexMarker1365"/> to implement durable<a id="_idIndexMarker1366"/> microservices using serverless features, namely Azure Functions.</p>
			<p>What is Azure? As I am sure you are aware by now, Microsoft Azure is Microsoft’s cloud offering for hosting your databases, APIs, and data resources. It also has many other forms of cloud offerings. Microsoft Azure<a id="_idIndexMarker1367"/> consists of paid services, free for 1-year <a id="_idIndexMarker1368"/>services, and always free services. You are advised to review their different cloud services and compare them with other providers to suit your needs. Pay particular attention to which services are free, along with their usage limits, and which services you will have to pay for.</p>
			<p>Let's name some good reasons to host your applications and databases in the cloud instead of on-premises. Well, you don’t have to pay for hardware or electricity costs for a start. Then, there is the aspect of scaling up and scaling out when your existing infrastructure meets the maximum capacity. Hardware can become obsolete very quickly as the complexity of the needs of software and its users grows. So, there are many reasons to use the cloud that you will need to carefully consider, and with those reasons, there will be both pros and cons. Therefore, when deciding to use the cloud, make sure you research, document, and price everything so that you start on the right footing. This will make system management, maintenance, and business growth much easier in the long run. If you get things right from the start of your endeavors, then you will save yourself potential headaches further down the line!</p>
			<p>A microservice is normally a simple web service that receives a request and sends a response. Many kinds of microservices exist, such as film and music streaming services and document upload and retrieval services. In the DDD of microservices, the microservice will normally have a data source. On Azure, this could be a file held in blob storage, data stored in an Azure SQL Server relational database, or even data stored in an Azure Cosmos DB NoSQL database.</p>
			<p>Modern microservice implementations are relying less on containerization that uses tools such as Docker and Kubernetes and more on pure serverless options such as Azure Functions. The beauty of an Azure Function is that it is only active for the period of the call. Once the function has done what it is required to do, it simply goes to sleep. An Azure Function also uses fewer computing resources and power compared to containerized solutions. The only downside is that you must manage many Azure Functions. And so, just like with containerization, you will need some way to orchestrate all your Azure Functions in an easy-to-maintain, extended, and useful way.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor245"/>Azure Functions</h2>
			<p>An Azure Function<a id="_idIndexMarker1369"/> is a unit of work. When you implement Azure Functions, you do not have to concern yourself with provisioning and managing infrastructure, since Azure Functions is one of Microsoft’s serverless computing offerings.</p>
			<p>Serverless computing is managed by the serverless provider. This means that the serverless computing provider is responsible for investing heavily into provisioning and managing the infrastructure that hosts your serverless computing services, such as Azure Functions. This means you get to save money on hardware and electricity costs, and can fully concentrate your efforts on developing, testing, deploying, and maintaining your serverless projects.</p>
			<p>Microsoft’s investment into serverless computing provides your Azure Functions with networking, service discovery, routing, and events to facilitate high-performance communication between your functions and other aspects of your software system architecture.</p>
			<p>An Azure Function normally consists of one or more inputs that you can bind and trigger, and outputs that you can bind to, with your custom code sitting between the inputs and outputs, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B16617_Figure_13.2.jpg" alt="Figure 13.2 – High-level Microsoft Azure Functions concept diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – High-level Microsoft Azure Functions concept diagram</p>
			<p>Azure Functions are excellent tools to use when developing distributed systems. But the complexity of using Azure Functions begins to materialize when the number of Azure Functions in your projects starts to grow. Managing large numbers of Azure Functions requires a form of orchestration. Orchestration makes managing many Azure Functions more straightforward for the infrastructure team. The orchestration to employ for Azure Functions is Durable Azure Function.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor246"/>Durable Azure Functions</h2>
			<p>You can execute Azure Functions with stateful orchestration using durable functions. Azure Functions<a id="_idIndexMarker1370"/> provide an extension known as Durable Functions. Durable function applications consist of multiple Azure Functions. Each function in a durable function orchestration can perform a different role and/or function. The different types of durable functions are activity, orchestrator, entity, and client. Let’s take a brief look at each type of durable function.</p>
			<h3>Durable function type – activity</h3>
			<p>A basic unit of work is defined as an activity function<a id="_idIndexMarker1371"/> within the orchestration of a durable function. This means that when an orchestrated function performs multiple tasks, such as data validation, reading data, and updating data, each of these tasks will be executed by a durable activity function. Once a durable activity function has been completed, it may return data to the function that orchestrated the activity.</p>
			<p>Activity functions are defined by activity triggers. <strong class="source-inline">DurableActivityContext</strong> is passed in as a parameter. Event triggers can be bound to JSON-serializable objects that can be used to pass input data into functions. Since an activity function can only have single values passed to them, you can overcome this limitation by using arrays, complex types, and tuples.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Activity functions can only be triggered from an orchestrator function and are only guaranteed to run at least once by the Durable Task Framework. Because we don’t know how many times an activity might be called, Microsoft recommends that you make durable activity functions idempotent whenever possible.</p>
			<h3>Durable function type – orchestrator</h3>
			<p>Use the orchestrator<a id="_idIndexMarker1372"/> function type when you need to control what actions are executed, and the order that you need to execute them.</p>
			<h3>Durable function type – entity</h3>
			<p>A durable entity can be invoked by client<a id="_idIndexMarker1373"/> and orchestrator functions and is triggered by an entity trigger. A durable entity function is used to read and update an object’s state.</p>
			<h3>Durable function type – client</h3>
			<p>A durable client<a id="_idIndexMarker1374"/> function is defined using a durable client output binding. Client functions are used to start orchestrator and entity functions since, on the Azure portal, these functions cannot be triggered by button clicks. </p>
			<h3>Durable function patterns</h3>
			<p>There are several patterns <a id="_idIndexMarker1375"/>that you can use to manage your durable functions. These include the following:</p>
			<ul>
				<li>Aggregator (stateful entities)</li>
				<li>Async HTTP APIs</li>
				<li>Fan-out/fan-in</li>
				<li>Function chaining</li>
				<li>Human interaction</li>
				<li>Monitoring</li>
			</ul>
			<h4>The aggregator (stateful entities) pattern</h4>
			<p>In this pattern, a single addressable<a id="_idIndexMarker1376"/> entity is used to aggregate event data that takes place over a certain period. The data that’s passed into an aggregator can come from multiple sources. Data may be spread over time and can be delivered in batches. You can process data upon arrival and make the aggregated data available for querying by external clients.</p>
			<p>In the aggregator pattern, the aggregator function should be run in a single process or VM. The main reason is due to the complexity of concurrency control when it’s used with normal functions that are stateless.</p>
			<h4>Async HTTP APIs</h4>
			<p>Factors that affect<a id="_idIndexMarker1377"/> the time it takes for an API call to complete include volume and latency, as well as other factors beyond your control. Durable functions have a built-in mechanism for working with the execution of long-running functions, and the durable function’s runtime is also responsible for managing the state.</p>
			<h4>Fan-out/fan-in</h4>
			<p>Durable functions allow<a id="_idIndexMarker1378"/> you to execute functions in parallel and on the results of tasks.</p>
			<h4>Function chaining</h4>
			<p>When using ordinary<a id="_idIndexMarker1379"/> functions with service bus queues, you have more complexity when it comes to error handling, and it can be hard to visualize the relationship between a function and a queue.</p>
			<p>However, when you use a durable function, you have one location where you can set the order of your functions, storage queues are automatically managed by the durable function, and if errors occur in any of the activities, they get propagated back to the orchestration function.</p>
			<h4>Human interaction</h4>
			<p>Durable functions can be used to escalate processes<a id="_idIndexMarker1380"/> that have not received human interaction within an agreed timeline.</p>
			<h4>Monitoring (actors)</h4>
			<p>When you need to perform<a id="_idIndexMarker1381"/> a recurring task, such as releasing system resources, durable functions provide a flexible way for you to manage recurrence intervals, use a single orchestration to manage multiple monitor processes, and manage the lifetime of a task.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor247"/>Containers and serverless</h2>
			<p>Container and serverless technologies all have a valid place in the microservice ecosystem. The primary thought process is to know their strengths and weaknesses to help you choose the best option for your needs.</p>
			<h3>Containers</h3>
			<p>Containers are a good option<a id="_idIndexMarker1382"/> for you if you have legacy code that you want to migrate to a more modern platform and code base. You do not have to rewrite your legacy code base, such as web services and batch processes, immediately. You can place them within a container and deploy them to the cloud. Then, when time, money, and resources become available, you can plan for and implement the rewriting of your legacy projects.</p>
			<p>When you rely on third-party dependencies, cost and PaaS availability can be an issue. Sites such as Docker Hub provide access to many readily available containers for various third-party dependencies that you can pull and deploy.</p>
			<p>Local development of multiple microservices can be simplified with Docker Compose files. You can add as many services as you need to a Docker Compose file and start them all up when they are required.</p>
			<p>Using Kubernetes clusters, an ingress controller is used to expose only those services you want to be exposed to. This allows you to provide secure code with a limited footprint that makes life hard for hackers.</p>
			<p>Some downsides to containers are that they can encourage the use of older development techniques that are more heavyweight and require more computing power. This can lead to an increase in computing costs. Containers also need a core number of cluster nodes that are always running, adding to your costs.</p>
			<h3>Serverless</h3>
			<p>External services can be integrated with serverless technology<a id="_idIndexMarker1383"/> such as Azure Functions. Rapid application development is promoted by the simplified programming model of serverless computing.</p>
			<p>When programming serverless code, you are encouraged to use an event-driven approach to your functions. Such code is easily scalable and can be easily rewritten or discarded as your business evolves.</p>
			<p>Serverless code supports <em class="italic">scale to zero</em> as functions only ever run when they are needed and do not run when they are not needed. This helps reduce running costs as resource consumption is very minimal compared to services such as cluster nodes, which are always running.</p>
			<p>Rapid scale-out of serverless code is another advantage of such technologies, as you only ever pay for the running time of the function.</p>
			<p>Serverless functions can pose a security risk, so you must take steps to ensure your functions are safe and secure.</p>
			<p>Now that you know about the strengths<a id="_idIndexMarker1384"/> and weaknesses of containers and serverless functions, and you have reviewed the various types of durable functions available in Microsoft Azure, as well as some durable function patterns, let’s look at managing our cloud infrastructures in C# with Pulumi.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor248"/>Managing your cloud infrastructure with Pulumi</h1>
			<p>In this section, you will learn<a id="_idIndexMarker1385"/> how to manage your cloud infrastructure<a id="_idIndexMarker1386"/> using Pulumi. With cloud infrastructure, it is important to be consistent. One way to achieve this is to remove the human element, which is prone to error, and automate as much as you can. An important aspect of the cloud that can be readily automated is infrastructure provisioning tasks. And that’s where Pulumi comes in.</p>
			<p>With Pulumi, you can code <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) solutions. Code and configuration files are used to manage<a id="_idIndexMarker1387"/> and provision the infrastructure that your software will run on.</p>
			<p>Pulumi projects can be written in various programming languages such as Python, VB.NET, F#, and C#. We are interested in using C# for our Pulumi projects. You can use Pulumi to do the following:</p>
			<ul>
				<li>Specify your infrastructure.</li>
				<li>Automate how cloud resources are created, updated, and deleted.</li>
				<li>Use IDEs and code editors such as Visual Studio and Visual Studio Code.</li>
				<li>Catch mistakes during compilation.</li>
				<li>Enforce security, compliance, and best practices.</li>
				<li>Use existing NuGet libraries as well as code your own libraries.</li>
				<li>Use Kubernetes, Docker containers, Azure Functions, and Cosmos DB to build applications that are easy to scale.<p class="callout-heading">Note</p><p class="callout">To follow along, you will need to have Chocolatey installed since it will be used as the package manager for installing Pulumi. You will also need to have a Microsoft Azure account to deploy your IaC. On Windows, when using the command line, make sure you are using PowerShell and that you are running it as an Administrator.</p></li>
			</ul>
			<p>Now, let’s look at a very<a id="_idIndexMarker1388"/> simple example of provisioning blob <a id="_idIndexMarker1389"/>storage, adding files to blob storage, and destroying our provisioned resources. The following steps will provision, use, and delete Azure blob storage:</p>
			<ol>
				<li value="1">Install Pulumi with the following command:<p class="source-code"><strong class="bold">&gt; choco install pulumi</strong></p></li>
				<li>Ensure that you have .NET 6 SDK or higher installed.</li>
				<li>Configure Pulumi’s access to your Microsoft Azure account by typing the following command:<p class="source-code"><strong class="bold">az login</strong></p><p class="callout-heading">Note</p><p class="callout">Your credentials will never be sent to pulumi.com, and they will only be used by Pulumi for authentication purposes when managing and provisioning resources.</p></li>
				<li>At this point, you are ready to start using Pulumi. If the <strong class="source-inline">az</strong> term is not recognized, try the following command:<p class="source-code"><strong class="bold">Invoke-WebRequest -Uri https://aka.ms/</strong></p><p class="source-code"><strong class="bold">installazurecliwindows -OutFile .\AzureCLI.msi; Start-</strong></p><p class="source-code"><strong class="bold">Process msiexec.exe -Wait -ArgumentList '/I </strong></p><p class="source-code"><strong class="bold">AzureCLI.msi /quiet'; rm .\AzureCLI.msi</strong></p></li>
				<li>Create a new project using the following commands:<p class="source-code"><strong class="bold">&gt; Mkdir CH13_Pulumi</strong></p><p class="source-code"><strong class="bold">&gt; cd CH13_Pulumi</strong></p><p class="source-code"><strong class="bold">&gt; pulumi new azure-csharp</strong></p></li>
			</ol>
			<p>You will be asked to enter your token, or you can simply press <em class="italic">Enter</em> to log into Pulumi and have Pulumi obtain<a id="_idIndexMarker1390"/> your token for you. If you don’t have<a id="_idIndexMarker1391"/> one, you can create one quite easily at this stage. Once you are logged in, you will be asked a series of questions in PowerShell. You can simply accept all the defaults.</p>
			<ol>
				<li value="6">Open the project in Visual Studio. Let’s review the project files:<ol><li><strong class="source-inline">Pulumi.yaml</strong> is used to define the project.</li><li><strong class="source-inline">Pulumi.dev.yaml</strong> is used to store configuration values for your stack.</li><li><strong class="source-inline">Program.cs</strong> is the entry point for your project.</li><li><strong class="source-inline">MyStack.cs</strong> is used to define your stack resources.</li></ol></li>
			</ol>
			<p>This class creates an Azure resource group and a storage account. The primary key for the storage account is then exported. You will find the location for the resource group in the <strong class="source-inline">Pulumi.dev.yaml</strong> file with the <strong class="source-inline">azure-native:location</strong> property name.</p>
			<ol>
				<li value="7">Now, deploy your stack with the following command:<p class="source-code"><strong class="bold">Pulumi up</strong></p></li>
			</ol>
			<p>When prompted, select <strong class="bold">Yes</strong> to deploy your stack to Azure.</p>
			<ol>
				<li value="8">At this stage, you should be able to log into your Azure account and see the newly created resource, and that it is a storage account.</li>
				<li>Add an HTML file<a id="_idIndexMarker1392"/> to your project called <strong class="source-inline">index.html</strong> and edit<a id="_idIndexMarker1393"/> the file by adding some HTML content and saving it. Here is some sample content:<p class="source-code">&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample </p><p class="source-code">  HTML&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;</p><p class="source-code">&lt;hr /&gt;&lt;p&gt;This is a sample paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</p></li>
				<li>Add the following code to the <strong class="source-inline">MyStack.cs</strong> class immediately after the code block that creates the Azure storage account resource:<p class="source-code">// Enable static website support</p><p class="source-code">var staticWebsite = new StorageAccountStaticWebsite(</p><p class="source-code">     "staticWebsite",</p><p class="source-code">     new StorageAccountStaticWebsiteArgs</p><p class="source-code">{</p><p class="source-code">     AccountName = storageAccount.Name,</p><p class="source-code">     ResourceGroupName = resourceGroup.Name,</p><p class="source-code">     IndexDocument = "index.html",</p><p class="source-code">});</p></li>
			</ol>
			<p>With that, we have created a new static website resource that utilizes the storage account we’ve just created.</p>
			<ol>
				<li value="11">Next, add the following code after the code shown in <em class="italic">Step 10</em>:<p class="source-code">// Upload the file</p><p class="source-code">var index_html = new Blob("index.html", new BlobArgs</p><p class="source-code">{</p><p class="source-code">ResourceGroupName = resourceGroup.Name,</p><p class="source-code">AccountName = storageAccount.Name,</p><p class="source-code">ContainerName = staticWebsite.ContainerName,</p><p class="source-code">Source = new FileAsset("index.html"),</p><p class="source-code">ContentType = "text/html",</p><p class="source-code">});</p></li>
			</ol>
			<p>Here, we used our cloud resources and a local <strong class="source-inline">FileAsset</strong> to upload our <strong class="source-inline">index.html</strong> file to blob storage.</p>
			<ol>
				<li value="12">At the end<a id="_idIndexMarker1394"/> of the constructor, add<a id="_idIndexMarker1395"/> the following code:<p class="source-code">// Web endpoint to the website</p><p class="source-code">this.StaticEndpoint = storageAccount</p><p class="source-code">     .PrimaryEndpoints.Apply(</p><p class="source-code">         primaryEndpoints =&gt; primaryEndpoints.Web</p><p class="source-code">     );</p></li>
			</ol>
			<p>This code configures the web endpoint to our static website.</p>
			<ol>
				<li value="13">Add the following property just above the constructor:<p class="source-code">[Output]</p><p class="source-code">public Output&lt;string&gt; StaticEndpoint { get; set; }</p></li>
			</ol>
			<p>This property provides our static website endpoint.</p>
			<ol>
				<li value="14">Now, it’s time to deploy our changes by typing the following command:<p class="source-code"><strong class="bold">pulumi up</strong></p></li>
			</ol>
			<p>This will upload the <strong class="source-inline">index.html</strong> file to blob storage and make our static website available to the public. You should see a URL that you can use to view the web page that you created and uploaded. The file should be visible in your blob storage, which you can view via the Azure portal or Azure Storage Explorer.</p>
			<ol>
				<li value="15">Once you are satisfied that the preceding code has worked for you, it is time to destroy the resources. Type the following command:<p class="source-code"><strong class="bold">pulumi destroy</strong></p></li>
			</ol>
			<p>If you want to destroy the entire stack, type the following command:</p>
			<p class="source-code"><strong class="bold">pulumi stack rm dev</strong></p>
			<p>With that, the stack has been completely removed from Pulumi.</p>
			<p>In this section, you learned<a id="_idIndexMarker1396"/> how to manage your Azure stack with Pulumi. By using<a id="_idIndexMarker1397"/> Visual Studio and the PowerShell command line, you created an Azure resource account and assigned blob storage to it. Then, you created a static website resource and used the cloud resources and local <strong class="source-inline">FileAsset</strong> to upload the static website, which consisted of a single file called <strong class="source-inline">index.html</strong>. You were able to view the file in blob storage and view the web page in your browser.</p>
			<p>In the next section, we will look at some performance considerations for distributed systems.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor249"/>Performance considerations for distributed computing</h1>
			<p>We now know how to develop distributed <a id="_idIndexMarker1398"/>systems. But what about their performance? What kinds of things should we be aware of in terms of the performance of distributed systems?</p>
			<p>The first consideration is the network connection between clients and servers. TCP collisions can result in lost packets of information. This can corrupt communication between multiple devices and cause connections to time out. The most common reason for TCP collisions is when two or more computers share the same IP address.</p>
			<p>No computer on the same network should have the same address as another computer on the same network. This results in unpredictable network behavior that is detrimental to the performance and stability of a networked application. If you experience this situation, simply change the IP address of one of the computers to a different IP address.</p>
			<p>Another problem that can result in slow network communication is <strong class="bold">Domain Name Resolution</strong> (<strong class="bold">DNS</strong>). If DNS is not correctly set, then accessing<a id="_idIndexMarker1399"/> a network resource such as a web page or web service may take longer than expected and cause a connection or request to time out. It is worth<a id="_idIndexMarker1400"/> noting that there is usually more than one DNS on a distributed network. You have the DNS server of the external network and your router, which has a DNS for your local network. Either of these could be responsible for slow DNS resolution. Some steps you can take to resolve DNS issues are as follows:</p>
			<ol>
				<li value="1">Check your network connectivity.</li>
				<li>Check that your DNS addresses are correct and in the right order.</li>
				<li>Ping the computer name, IP address, or base URL, such as google.co.uk, that you are trying to access to see if it responds or times out.</li>
				<li>Identify the nameservers in use using <strong class="source-inline">nslookup</strong>.</li>
				<li>Check the DNS suffix.</li>
				<li>Check that the DNS settings have been configured to pull the DNS IP address from the DHCP server.</li>
				<li>Use <strong class="source-inline">ipconfig</strong> to release and renew the DHCP address and DNS information.</li>
				<li>Check the DNS server to see if any services need to be restarted or if the server needs to be rebooted.</li>
				<li>Sometimes, the information on the router becomes stale, so a quick solution is to reboot the router.</li>
				<li>Every so often, an ISP will run into problems of their own that affect you. In these cases, you will need to communicate with them to understand the problem and get some indication of when things will be back to normal.</li>
			</ol>
			<p>Distributed firewalls may be employed to protect business networks. Misconfiguration of firewalls can result in resource access being denied or invisible. If machines are unable to access distributed resources, then the distributed firewall is a good place to start. If the distributed firewall is configured correctly, then check client and server firewalls to see if they are enabled or disabled and whether they are correctly configured or not.</p>
			<p>For example, I have dealt<a id="_idIndexMarker1401"/> with a lot of SQL Server problems. Some have been DNS and DHCP issues, but the most common issues are SQL Server configuration and firewall configurations. SQL Server uses dynamic ports. But sometimes, these can clash, as can fixed ports. Also, I have found that for SQL Server to work on many networks, the Named Pipes and TCP protocols must be enabled. Once these protocols have been changed within SQL Server Configuration Manager, you need to restart the instance of SQL Server they apply to, followed by the SQL Server Browser service. If you have firewalls in place, then the SQL Server executable for the instance will need to be added to the firewall as an application exception. If you need to use specific ports, then you would need to add port exceptions. Standard port exceptions for SQL Server are <strong class="source-inline">1433</strong> for TCP and <strong class="source-inline">1434</strong> for UDP.</p>
			<p>Sometimes, even after the aforementioned SQL Server troubleshooting has been completed, networked applications can still not see the SQL Server instance. When this happens, a workaround is to recreate the database connection string with the following format: <strong class="source-inline">IP_ADDRESS,PORT_NUMBER\INSTANCE_NAME</strong>.</p>
			<p>Another problem that can affect SQL Server connectivity in a distributed setting is the SQL Server driver that is installed and used. If you use specific versions of a SQL Server native client, then you will need to ensure that that particular version of the native client is installed on all computers for them to be able to connect to SQL Server. The way around this is to realize that the SQL Server driver is installed by default on all Windows computers, both server and client. If you use this driver, then you do not have to worry about rolling out SQL Server Native Clients to various computers that are part of your distributed system. </p>
			<p>Another area of performance is the database querying aspect. The same query to obtain a set of results can be written in so many different ways to obtain the required results. This is especially true with larger result sets that have more joins. Dynamic SQL can also perform slowly. Therefore, speeding up queries can improve a database-driven distributed application significantly. You can use SQL Server Profile and review SQL Server Execution Plans to identify bottlenecks and rewrite SQL so that it’s more performant. You can also add missing indexes, correct incorrect indexing, and use pre-compiled stored procedures for performance enhancement purposes.</p>
			<p>SQL Server can become corrupt<a id="_idIndexMarker1402"/> and fail for many reasons, so it must be regularly updated with security patches. Here, you can use Always-On and failover clusters to keep connections alive and switch between SQL Servers when a server is down or needs to be taken offline for maintenance.</p>
			<p>The number of connections to a resource can also overload a distributed system to the point that clients cannot connect. To overcome this, you can employ load balancing so that when a resource server reaches a certain peak, clients are sent to an alternative server for those resources.</p>
			<p>Another common oversight when sharing networked resources is network permissions. Sometimes, a folder may not be shared that should be shared. A really nasty problem can be that of a permissions hierarchy that is enforced via group policy that overrides even a network domain administrator’s ability to do their job.</p>
			<p>It is important to fully document your group policy and permissions structure for current and future staff. With a clear document that diagrammatically shows the permission groups and hierarchies, as well as provides a list of resources and their permission sets, if someone or an app is having trouble accessing resources, such documents can ease the pain of troubleshooting such problems.</p>
			<p>It is also worth noting that sometimes, System and TrustedInstaller take control of certain resources and prevent you from being able to access resources locally and across a network. This can result in you having to override the ownership of that network or local location and file resource.</p>
			<p>Computer security software can also significantly slow down network traffic and even stop programs from working. The usual culprits are the firewall, as we mentioned previously, and antivirus software. If your software is not code-signed with an authority-approved code signing certificate, then DLLs and executables can be quarantined and identified as harmful software. This is what is known as being identified as a false positive. You can either sign your<a id="_idIndexMarker1403"/> software, add your software as an application or folder exception, or pass your software to security firms to assess your software and update their software to prevent this from happening in the future.</p>
			<p>Antivirus software can also slow applications down when all network traffic and even local files are real-time scanned. An example of this is educational software that pulls audio files across the network<a id="_idIndexMarker1404"/> during assessments. A characteristic that identifies this being the case is when the audio files are backed up and fired together. To overcome this problem, you can update the antivirus software by adding the application, its folders, and its resources as folder and or application/file exceptions.</p>
			<p>The size of resources also affects network performance. The larger the size, the longer the time to request and receive a resource. Here, you can reduce the size of resources such as images, video, and audio files using various compression techniques. You can also zip resources up and transmit them before they need to be accessed, such as at application startup. You can store resources in the local cache once they have been requested and received.</p>
			<p>When the workload increases to the point that your current system cannot handle it, you have two options: scale up vertically or scale out horizontally. Scaling up involves increasing the physical computing capacity to cope with the increased workload. Scaling out is when you add more servers to cope with the increased workload. At the time of writing, the way forward for many companies is to use server VMs and containers and have containers running in container management software such as Docker and Kubernetes on cloud platforms such as Azure, AWS, Google Cloud, and others.</p>
			<p>Large libraries and executables can be made smaller by moving code into microservices such as Azure Functions. Azure Functions is an event-driven, compute-on-demand experience that extends the existing Azure application platform with capabilities to implement code triggered by events occurring in Azure or third-party services, as well as on-premises systems. These online services can then scale up and down and run only when they are required to do so. This has the added advantage of providing cost savings, such as electricity and equipment costs.</p>
			<p>You can also use tools such as the browser developer tools and Postman to monitor application and network performance.</p>
			<p>Now, let’s summarize what we have learned.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor250"/>Summary</h1>
			<p>In this chapter, we started by looking at the implementation of the CQRS design pattern. Then, we looked at an implementation of event sourcing. You can use both these patterns by themselves, though they can also be combined to provide very powerful and functional microservices.</p>
			<p>Then, we took a high-level look at using Microsoft Azure for writing distributed systems. The benefits and negative aspects of containers and serverless functions were covered to help you understand when to use each technology.</p>
			<p>In terms of Microsoft Azure, we focused mainly on Azure Functions. Specifically, we looked at Durable Azure Functions. We identified the various types of durable functions and various durable function patterns.</p>
			<p>Now, take some time to answer this chapter’s questions to see how much you have retained from this chapter. Please review the <em class="italic">Further reading</em> section to build upon what you have learned in this chapter.</p>
			<p>In the next chapter, we will be looking at multithreaded programming in C#.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor251"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">What does CQRS stand for?</li>
				<li>Why do we use the CQRS pattern when developing microservices?</li>
				<li>What is event sourcing?</li>
				<li>Why do we use event sourcing?</li>
				<li>What are containers?</li>
				<li>Why would we use containers?</li>
				<li>What are serverless functions?</li>
				<li>Why should we use serverless functions?</li>
				<li>What are durable functions?</li>
				<li>What are the different types of durable functions?</li>
				<li>What types of durable function patterns are there?</li>
				<li>What is Pulumi?</li>
				<li>Why would we use Pulumi?</li>
			</ol>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor252"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li><em class="italic">Getting started with Pulumi on Azure</em>: <a href="https://www.pulumi.com/docs/get-started/azure/">https://www.pulumi.com/docs/get-started/azure/</a></li>
				<li><em class="italic">Building Modern Cloud Applications using Pulumi and .NET Core</em>: <a href="https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/">https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/</a></li>
				<li><em class="italic">Orchestration Using Durable Azure Functions</em>: <a href="https://blog.kiprosh.com/orchestration-using-durable-azure-function/">https://blog.kiprosh.com/orchestration-using-durable-azure-function/</a></li>
				<li><em class="italic">Durable Functions Orchestrations</em>: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp">https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp</a></li>
				<li><em class="italic">Best Practices for Durable Functions Patterns</em>: <a href="https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices">https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices</a></li>
				<li><em class="italic">Chapters 9</em> and <em class="italic">10</em> of <em class="italic">Clean Code in C#</em> by Jason Alls: <a href="https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S">https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S</a></li>
				<li><em class="italic">10 Ways to Troubleshoot DNS Resolution Issues</em>: <a href="https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/">https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/</a></li>
			</ul>
		</div>
	</body></html>