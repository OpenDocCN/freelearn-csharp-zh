- en: Microservices with .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET Core的微服务
- en: 'Over the last few years, a paradigm shift has happened in the way applications
    are designed, in the form of suites of smaller and independently deployable services,
    also known as **microservice architecture** or just **microservices**. The intent
    is to develop simpler and independent services, to release them quickly, and to
    release them often and ensure that if one service is down then other services
    are not impacted, making the app more robust, reliable, and highly scalable. In
    the spirit of this new philosophy, and keeping up with the latest and greatest
    in the technology space, we will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，应用程序的设计方式发生了范式转变，表现为一系列更小且可独立部署的服务，也被称为**微服务架构**或简称**微服务**。其目的是开发更简单、独立的服务，快速发布它们，并频繁发布以确保如果一个服务出现故障，其他服务不会受到影响，从而使应用程序更加健壮、可靠且高度可扩展。在这种新哲学的精神下，并紧跟技术领域的最新发展，我们将在本章中涵盖以下主题：
- en: Introduction to microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务简介
- en: Handy things to know
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要了解的便捷事物
- en: Blazor—a new experiment from the ASP.NET team
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor——来自ASP.NET团队的新实验
- en: What's coming in .NET Core 2.1
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 2.1即将推出
- en: We have a lot to cover, so let's start with microservices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多内容要介绍，所以让我们从微服务开始。
- en: Introduction to microservices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: To better understand and appreciate the microservice architecture, we first
    need to see what a service is and how the traditional service monolithic architecture
    has limitations that can be overcome by microservices. Once we have this context
    set up, we will define microservices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解和欣赏微服务架构，我们首先需要了解什么是服务以及传统的单体服务架构有哪些局限性，这些局限性可以通过微服务来克服。一旦我们建立了这个背景，我们将定义微服务。
- en: A traditional service
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的服务
- en: When we create any server-side enterprise app, it must support a variety of
    different clients, including desktop and mobile browsers, mobile apps, and so
    on. We may also expose APIs, so that third parties can consume them and integrate
    with our system. Like third parties, we may also need to integrate our application
    with other applications through APIs. The app would handle the requests by executing
    business logic, then performing read-write operations by accessing a database
    and/or other data providers and systems, and return an HTML/JSON/XML response.
    What I have described here is a typical enterprise application. We have different
    logical modules in the application to fulfill the business requirements. These
    modules are what we can refer to as services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建任何服务器端企业应用时，它必须支持各种不同的客户端，包括桌面和移动浏览器、移动应用等。我们可能还需要公开API，以便第三方可以消费它们并与我们的系统集成。就像第三方一样，我们可能还需要通过API将我们的应用程序与其他应用程序集成。应用程序将通过执行业务逻辑来处理请求，然后通过访问数据库和其他数据提供者及系统执行读写操作，并返回HTML/JSON/XML响应。我这里描述的是典型的企业应用。我们在应用程序中有不同的逻辑模块来满足业务需求。这些模块就是我们所说的服务。
- en: In essence, a service is just a software component that provides functionality
    to other pieces of software within your system. A service should be well defined,
    self contained, and should not depend on the context or state of other services.
    The other pieces of software could be anything—a website, a web app, a mobile
    app, a desktop app, or even another service. If I were to give an example, take
    any e-commerce website of your choice. The website displays the products and the
    deals. To display products and deals, it talks to a service. The service is actually
    responsible for the creation,update, deletion, and retrieval of data from the
    database, so the service provides functionality to the website.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，服务只是一个软件组件，它为系统内的其他软件组件提供功能。服务应该定义良好、自包含，并且不应依赖于其他服务的上下文或状态。其他软件组件可以是任何东西——一个网站、一个Web应用、一个移动应用、一个桌面应用，甚至是另一个服务。如果我要举一个例子，可以拿任何你选择的电子商务网站。该网站显示产品和服务。为了显示产品和服务，它需要与一个服务进行通信。实际上，服务负责从数据库创建、更新、删除和检索数据，因此服务为网站提供功能。
- en: 'The communication between the different software components and the service
    normally happens over a network using some kind of communication protocol. For
    example, your Facebook mobile app communicates to a service through the internet.
    A system which uses a service or multiple services in this fashion has what''s
    called a **service-oriented architecture**, abbreviated as **SOA**. The idea behind
    SOA is to use a thick server rather than a thick client. This way, many clients
    can have the same functionality. In future, we can have newer or different types
    of clients connecting to the same service, reusing this functionality. As a software
    architecture, SOA has been very successful. A few of the benefits and features
    of SOA are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不同软件组件与服务之间的通信通常通过网络使用某种通信协议进行。例如，您的Facebook移动应用通过互联网与一个服务进行通信。使用服务或多个服务以这种方式工作的系统被称为**面向服务的架构**，简称**SOA**。SOA背后的理念是使用厚服务器而不是厚客户端。这样，许多客户端可以拥有相同的功能。在未来，我们可以有新的或不同类型的客户端连接到同一服务，重用这些功能。作为一个软件架构，SOA已经非常成功。SOA的一些好处和特性包括：
- en: It allows the application to scale up when demand increases, by enabling us
    to have a copy of the service on multiple servers. When the burst of traffic comes
    in, a load balancer will redirect requests to a specific instance of the service.
    We can have multiple instances of a service.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许应用程序在需求增加时进行扩展，通过使我们能够在多个服务器上拥有服务的副本。当流量激增时，负载均衡器将请求重定向到服务的特定实例。我们可以拥有多个服务实例。
- en: It allows reusability of functionality. For instance, in a shopping web app,
    the function to create an order could be the same functionality, which is triggered
    by a mobile app on our service. So, it's the same code creating an order for both
    the website and the mobile app.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许功能的可重用性。例如，在一个购物网页应用中，创建订单的功能可能是相同的，这个功能是由我们的服务上的移动应用触发的。因此，创建订单的代码对网站和移动应用都是相同的。
- en: It allows standardized contracts or interface-based development. When a client
    application calls a service, it actually invokes a method in the service. The
    signature of the method typically doesn't change when the service implementation
    changes, so we can upgrade our service without having to upgrade our clients,
    as long as the contract and the signature of the method doesn't change. This way,
    we do not have to upgrade the clients when the service is upgraded.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许标准化合同或基于接口的开发。当客户端应用程序调用服务时，它实际上是在调用服务中的一个方法。当服务实现发生变化时，方法的签名通常不会改变，因此我们可以升级我们的服务，而无需升级我们的客户端，只要合同和方法签名不改变。这样，当服务升级时，我们不需要升级客户端。
- en: It is stateless. When a request comes from a client to a service, that instance
    of the service does not have to remember the previous request from that specific
    client. It has all the information from the request that it needs in order to
    retrieve all the data associated with the previous request within the service,
    so a service does not have to remember the previous call the client has made to
    that particular instance of the service and no context needs to be maintained.
    It's stateless, therefore any instance of the service can honor any income request
    from a client, because it does not have to remember any previous interaction with
    any other instance of a service.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是无状态的。当一个客户端向服务发送请求时，该服务实例不需要记住来自该特定客户端的先前请求。它拥有从请求中获取的所有必要信息，以便在服务内部检索与先前请求相关的所有数据，因此服务不需要记住客户端对该特定服务实例的先前调用，也不需要维护任何上下文。由于它是无状态的，因此服务的任何实例都可以响应来自客户端的任何请求，因为它不需要记住与任何其他服务实例的任何先前交互。
- en: It is simple to develop, deploy, and scale the application.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发、部署和扩展应用程序很简单。
- en: 'We should now have a fair idea of the SOA that we may have been using without
    knowing what it is for years. Traditional services, which may be using SOA, have
    typically been deployed as a monolith. Monolith consists of two words, mono and
    lith. Mono means single and lith means stone. However, in a software dictionary,
    monolithic architecture refers to applications that are deployed as a single unit.
    An important consideration when developing an application is how easy it is to
    learn and modify, and how quickly new developers can become productive on the
    application. These desired features give rise to an architecture that is simple
    and easily understandable. Another desired aspect is that it should be easy to
    deploy. Keeping all these things in mind, the architecture would be a layered
    application that has a user interface layer which communicates to a service layer,
    which does the data manipulation on the data provider. A typical layered application
    architecture would look as shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该对可能已经使用多年而不知其所以然的服务导向架构（SOA）有一个公平的了解。可能使用SOA的传统服务通常被部署为一个单一的整体。单一由两个词组成，mono和lith。Mono意味着单一，lith意味着石头。然而，在软件词典中，单一架构指的是作为单一单元部署的应用。在开发应用时，一个重要的考虑因素是学习修改的难易程度，以及新开发者快速成为应用生产力所需的时间。这些期望的特性产生了一种简单且易于理解的架构。另一个期望的方面是它应该易于部署。考虑到所有这些因素，架构将是一个分层应用，它有一个用户界面层，该层与服务层通信，服务层在数据提供者上执行数据操作。一个典型的分层应用架构看起来如下所示：
- en: '![](img/10cb449a-f43b-4443-b69c-de7fb2542d1e.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10cb449a-f43b-4443-b69c-de7fb2542d1e.png)'
- en: The application is deployed as a single monolithic application and we can run
    multiple instances of the application behind a load balancer in order to scale
    and improve availability.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用被部署为一个单一的单一应用，我们可以在负载均衡器后面运行多个应用实例以进行扩展和改进可用性。
- en: Over time, as the number of users of the application grows and new enhancements
    are added to the application, the code base grows at a rapid pace and it becomes
    difficult to understand and modify the code. So, the developers become less productive,
    especially the new ones. Since it is complex to understand and modify the code
    base, the bug count in the application increases, which degrades the quality of
    the application. As the code base grows, the IDE (such as Visual Studio) becomes
    overloaded and hence slower, making developers less productive. A large monolithic
    application is also an obstacle to continuous deployment. In order to update/deploy
    one component, the entire application needs to be deployed, which results in down
    time. A monolithic application is also an obstacle to scaling development. Once
    the application gets to a certain size, it's useful to divide up the engineering
    organization into teams that focus on specific functional areas. The trouble with
    a monolithic application is that it prevents the teams from working independently,
    as the code and functionality is coupled in a single monolith. Monolithic architecture
    forces us to be married to a technology stack. So if we have used a Java stack,
    we need to be with Java as long as the application lasts, even if there are better
    tools and technology innovations in other stacks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间推移，应用的用户数量增加，以及应用中新增的功能增强，代码库以极快的速度增长，这使得理解和修改代码变得困难。因此，开发者的生产力下降，尤其是新开发者。由于理解和修改代码库复杂，应用中的错误数量增加，从而降低了应用的质量。随着代码库的增长，集成开发环境（如Visual
    Studio）变得过载，因此运行速度变慢，导致开发者生产力下降。一个大的单一应用也是持续部署的障碍。为了更新/部署一个组件，整个应用都需要部署，这导致停机时间。单一应用也是扩展开发的障碍。一旦应用达到一定规模，将工程组织划分为专注于特定功能区域的团队是有用的。单一应用的麻烦在于它阻碍了团队独立工作，因为代码和功能耦合在一个单一的整体中。单一架构迫使我们与一个技术栈绑定。所以如果我们使用了Java栈，那么在应用的生命周期内，即使其他栈有更好的工具和技术创新，我们也需要与Java绑定。
- en: 'The monolithic architecture of an e-commerce website is shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 电子商务网站的单一架构在此展示：
- en: '![](img/ecd1e776-88ea-44a5-8495-27a9d4114e7e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecd1e776-88ea-44a5-8495-27a9d4114e7e.png)'
- en: Due to these limitations, monolithic architecture, which has been around for
    a quite a while, has started to lose popularity over the years. Data speaks for
    itself. So, if we look at the Google trend report for SOA over the last five years,
    it is a graph of losing interest over time. It can be seen at [https://trends.google.com/trends/explore?date=today%205-y&q=SOA](https://trends.google.com/trends/explore?date=today%205-y&q=SOA):[](https://trends.google.com/trends/explore?date=today%205-y&q=SOA)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，存在已久的单体架构在近年来开始失去人气。数据会说话。因此，如果我们查看过去五年SOA的Google趋势报告，它是一个随着时间的推移逐渐失去兴趣的图表。它可以在[https://trends.google.com/trends/explore?date=today%205-y&q=SOA](https://trends.google.com/trends/explore?date=today%205-y&q=SOA)看到。
- en: '![](img/e91d2568-a095-4273-8065-f03c8339a105.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e91d2568-a095-4273-8065-f03c8339a105.png)'
- en: 'Unfortunate but true, as it happens everywhere else, a loss for one is a gain
    for another. The decline of SOA has seen the rise of microservices. If we look
    at the Google trend report for microservices over the same period of the last
    five years, we see a graph of increasing interest over time, as shown here. This
    can be seen at [https://trends.google.com/trends/explore?date=today%205-y&q=Microservice](https://trends.google.com/trends/explore?date=today%205-y&q=Microservice):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸但真实的是，正如在其他地方发生的那样，一个的损失对另一个来说就是收益。SOA的衰落看到了微服务的兴起。如果我们查看过去五年同一时期的微服务Google趋势报告，我们会看到随着时间的推移兴趣逐渐增加，如图所示。这可以在[https://trends.google.com/trends/explore?date=today%205-y&q=Microservice](https://trends.google.com/trends/explore?date=today%205-y&q=Microservice)看到。
- en: '![](img/b1cf0db8-5840-4717-87eb-4f82eacc7f76.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1cf0db8-5840-4717-87eb-4f82eacc7f76.png)'
- en: This is not just because it is trending, but because major large enterprises
    such as Netflix, Amazon, eBay, and so on have talked about the way they scaled
    and eased out the continuous delivery of their services using microservice architecture,
    so microservice architecture design doesn't seems to be a buzz to ignore. This
    architectural framework is one of the core selling points for emerging start-ups,
    such as Docker, which at the time of writing is valued at about $1 billion while
    still in funding.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是因为它正流行，还因为像Netflix、Amazon、eBay等主要大型企业都谈论了他们如何使用微服务架构来扩展和简化服务的持续交付方式，因此微服务架构设计似乎不是一个可以忽视的炒作。这种架构框架是新兴初创公司，如Docker的核心卖点之一，而Docker在撰写本文时估值约为10亿美元，尽管仍在融资阶段。
- en: Let's have a look at microservices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看微服务。
- en: Microservices
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: '**Microservices,** also known as the **microservice architecture**, is an architectural
    style that structures an application as a collection of loosely coupled independent
    services that implement business capabilities. The microservice architecture enables
    the continuous delivery and deployment of large, complex applications. It also
    enables an organization to evolve its technology stack. The microservice architecture
    is basically an improved version of SOA, and therefore it shares all the key characteristics
    of SOA, such as scalability, re-usability, standardized contracts in interfaces
    for backwards compatibility, and the idea of having a stateless service that we
    discussed previously. Microservice capabilities are expressed formally with business-oriented
    APIs. In short, the microservice architectural style defines a setup where application
    components are standalone applications of their own. These independent application
    components talk to each other either using **Remote Method Invocation** (**RMI**),
    RESTful web services or push messaging. Each microservice owns its related domain
    data model and domain logic, based on different data storage technologies and
    different programming languages.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**，也称为**微服务架构**，是一种将应用程序构建为一系列松散耦合的独立服务集合的架构风格，这些服务实现了业务能力。微服务架构使得大型、复杂应用程序的持续交付和部署成为可能。它还使组织能够演进其技术堆栈。微服务架构基本上是SOA的改进版本，因此它共享SOA的所有关键特性，如可伸缩性、可重用性、接口标准化合约以实现向后兼容性，以及我们之前讨论的无状态服务理念。微服务能力通过面向业务的API形式化表达。简而言之，微服务架构风格定义了一种设置，其中应用程序组件是它们自己的独立应用程序。这些独立的应用程序组件通过**远程方法调用**（**RMI**）、RESTful
    Web服务或推送消息相互通信。每个微服务都拥有其相关的领域数据模型和领域逻辑，基于不同的数据存储技术和不同的编程语言。'
- en: Because of the name, you may ask what the size of a microservice should be.
    When developing microservices, size is not a critical factor to consider. The
    imperative point is to make loosely coupled services, so that we have autonomy
    of development, and deployment and scaling for each service. Obviously, we should
    strive to make them as small as possible, as long as we don't have an excessive
    number of direct dependencies upon other microservices.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名称，你可能想知道微服务的大小应该是多少。在开发微服务时，大小不是需要考虑的关键因素。关键是要创建松散耦合的服务，以便我们拥有开发、部署和每个服务的扩展的自主权。显然，我们应该努力使它们尽可能小，只要我们不依赖于其他微服务的直接依赖过多。
- en: 'The following image shows a typical microservice architecture of an e-commerce
    website:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了一个电子商务网站典型的微服务架构：
- en: '![](img/29a01e66-81bc-4472-990d-dda58543f138.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29a01e66-81bc-4472-990d-dda58543f138.png)'
- en: We can see that, compared to the monolithic architecture, this has a lot more
    modularity and autonomy and the services communicate with other microservices.
    Think of a situation where, due to some unavoidable issue, **Payment Services**
    goes down, maybe due to bad code being checked in. The users of the site would
    still be able to view and update the cart. Only the payment functionality would
    be down and the rest of the services would keep serving the users. Now, think
    about a monolithic architecture where there is no independence of module and this
    sort of bad code issue happens. The chances of failure in such cases would be
    higher in monolithic architecture and we may even have a situation where a number
    of features stop working due to dependency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，与单体架构相比，这具有更多的模块化和自主性，并且服务与其他微服务进行通信。想象一下，由于某些不可避免的问题，**支付服务**出现故障，可能是由于检查了糟糕的代码。网站的访客仍然可以查看和更新购物车。只有支付功能会中断，其余的服务将继续为用户服务。现在，考虑一下没有模块独立性的单体架构，并且这种糟糕的代码问题发生了。在这种情况下，失败的几率会更高，我们甚至可能遇到由于依赖关系而导致许多功能停止工作的情况。
- en: 'The following image presents a good comparison between monolithic and microservice
    architectures:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了单体架构和微服务架构之间良好的比较：
- en: '![](img/41472c96-127f-4c77-989f-ca4257bc8c54.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41472c96-127f-4c77-989f-ca4257bc8c54.png)'
- en: Microsoft has provided a sample reference app and architecture guidance for
    microservices with ASP.NET Core. The sample is available on GitHub at [https://github.com/dotnet-architecture/eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers).[](https://trends.google.com/trends/explore?date=today%205-y&q=SOA)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为使用 ASP.NET Core 的微服务提供了示例参考应用和架构指导。该示例可在 GitHub 上找到，链接为 [https://github.com/dotnet-architecture/eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers)。
- en: 'To get a reasonable understanding and hands-on experience in the development
    of microservices, it is recommended that the reader has a good look at the repository.
    What we have discussed is the tip of the iceberg and just an introduction to microservices.
    We will conclude this discussion with the reference links to microservices, so
    that enthusiastic readers can gain more insights into this new paradigm:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对微服务开发有一个合理的理解和实践经验，建议读者仔细查看仓库。我们讨论的只是冰山一角，只是微服务的一个简介。我们将通过以下微服务的参考链接来结束这次讨论，以便热心的读者可以更深入地了解这一新范式：
- en: '**.NET application architecture**: [https://www.microsoft.com/net/learn/architecture](https://www.microsoft.com/net/learn/architecture)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 应用架构**：[https://www.microsoft.com/net/learn/architecture](https://www.microsoft.com/net/learn/architecture)'
- en: '**News on .NET architecture**: [https://github.com/dotnet-architecture/News](https://github.com/dotnet-architecture/News)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 架构新闻**：[https://github.com/dotnet-architecture/News](https://github.com/dotnet-architecture/News)'
- en: '**Martin Fowler on microservices**: [http://martinfowler.com/articles/microservices.html](http://martinfowler.com/articles/microservices.html)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**马丁·福勒关于微服务的观点**：[http://martinfowler.com/articles/microservices.html](http://martinfowler.com/articles/microservices.html)'
- en: '**Microservice architecture pattern**: [http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构模式**：[http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html)'
- en: In the next section, we will be discussing tips and tricks that I found really
    helpful while doing development, debugging, and monitoring the ASP.NET Core 2.0
    web apps.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论我在开发、调试和监控 ASP.NET Core 2.0 网络应用时发现的一些非常有用的技巧和窍门。
- en: Handy things to know
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的知识
- en: 'It''s important for us to understand that there are fundamental architecture
    differences between ASP.NET and ASP.NET Core. A few of the important ones are
    listed here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解，ASP.NET 和 ASP.NET Core 之间存在根本的架构差异。以下列出了一些重要的差异：
- en: An important difference between ASP.NET and ASP.NET Core is that ASP.NET Core
    doesn't have a request queue, unlike ASP.NET. The `RequestQueue` class which resides
    in the `System.Web` namespace is designed to prevent thread pool starvation in
    ASP.NET. This no longer exists in ASP.NET Core, so as you can rightly guess, there
    can be thread pool starvation if we do not write proper code. Just so that we
    are on the same page, starvation describes a situation where a thread is unable
    to gain regular access to shared resources and is unable to make progress. This
    happens when shared resources are made unavailable for long periods by greedy
    long running threads. For example, suppose an object provides a synchronized method
    that often takes a long time to return. If one thread invokes this method frequently,
    other threads that also need frequent synchronized access to the same object will
    often be blocked.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET 和 ASP.NET Core 之间的重要差异之一是，与 ASP.NET 不同，ASP.NET Core 没有请求队列。位于 `System.Web`
    命名空间中的 `RequestQueue` 类旨在防止 ASP.NET 中的线程池饥饿。在 ASP.NET Core 中，这种情况不再存在，因此正如你可以正确猜到的，如果我们不编写适当的代码，就可能出现线程池饥饿。为了确保我们处于同一页面上，饥饿描述的是线程无法获得对共享资源的常规访问，并且无法取得进展的情况。这通常发生在贪婪的长运行线程长时间使共享资源不可用的情况下。例如，假设一个对象提供了一个通常需要很长时间才能返回的同步方法。如果一个线程频繁调用此方法，其他也需要频繁同步访问同一对象的线程通常会受阻。
- en: '`AppDomain` is another area where ASP.NET Core is different to ASP.NET. Running
    many instances of `AppDomain` require runtime support and are generally quite
    expensive. ASP.NET Core doesn''t use `AppDomain`. There is a single process and
    a single `AppDomain`, if that makes things easier to comprehend.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDomain` 是 ASP.NET Core 与 ASP.NET 在另一个不同之处。运行许多 `AppDomain` 实例需要运行时支持，并且通常相当昂贵。ASP.NET
    Core 不使用 `AppDomain`。有一个单一的过程和一个单一的 `AppDomain`，如果这有助于理解的话。'
- en: 'ASP.NET Core doesn''t have `SyncronizationContext`. If you don''t know `SyncronizationContext`,
    don''t worry. We are discussing it right now. C# 5 came with two new keywords,
    `async` and `await`, which provide a new and easier asynchronous programming experience.
    The approach to use is simple. Have the `async` keyword in the method definition.
    Change the return type of the method from `T` to `Task<T>` or `Task`, if it doesn''t
    return anything (I would not recommend using `void`, unless it''s an event handler
    method). It is also a good practice to use the `async` suffix in the method name,
    so that it is easy to identify that the method is asynchronous. You would also
    need to use at least one `await` statement in the method. Under the hood, the
    compiler translates the `async` method into a state machine and virtually converts
    it into a method that is invoked multiple times, once at the actual method invocation
    that proceeds till the statement containing the `await` keyword and then returns.
    When the statement containing the `await` keyword is executed, the method is invoked
    again from there and executes the remainder of the statements, in the same fashion.
    The following code lists a sample `async` method leveraging the `async` and `await`
    keywords:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 没有使用 `SyncronizationContext`。如果你不知道 `SyncronizationContext`，不要担心。我们正在讨论它。C#
    5 带来了两个新的关键字，`async` 和 `await`，它们提供了一种新的、更简单的异步编程体验。使用方法是简单的。在方法定义中包含 `async`
    关键字。如果方法不返回任何内容（我不建议使用 `void`，除非它是一个事件处理程序方法），则将方法的返回类型从 `T` 更改为 `Task<T>` 或 `Task`。在方法名称中使用
    `async` 后缀也是一个好习惯，这样就可以很容易地识别出方法是异步的。你还需要在方法中使用至少一个 `await` 语句。在底层，编译器将 `async`
    方法转换为状态机，并将其虚拟地转换为在方法调用时被多次调用的方法，一次是在包含 `await` 关键字的语句中，然后返回。当执行包含 `await` 关键字的语句时，方法再次从那里被调用，并按相同的方式执行剩余的语句。以下代码列出了一个利用
    `async` 和 `await` 关键字的示例 `async` 方法：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An important feature of the `async` and `await` keywords is support for `SyncronizationContext`.
    `SyncronizationContext` has been inside the framework since .NET 2.0 and is not
    something newly added to the framework. As discussed previously, when we `await`
    on an `async` method, the compiler hooks up the continuation, if there is any,
    and the resulting code is aware of the context. So, if the `SyncronizationContext`
    is available, the `await` expression will capture it and use it to invoke the
    continuation, very similar to the `ContinueWith` method offered in the **Task
    Parallel Library** (**TPL**). `SyncronizationContext` should be used with utmost
    care and if we consume the method in blocking fashion, it may lead to deadlock.
    For example, in a non-ASP.NET Core environment, if we wait on a `Task` using the
    `Wait` method or using the `Result` property, we block the main thread. When eventually
    the task completes inside that method in the thread pool, it will invoke the continuation
    to post back to the main thread. But since we have blocked the main thread and
    the task is waiting for the main thread, we will have deadlock. As a precaution,
    library writers are advised to use `ConfigureAwait(false)` while invoking `async`
    APIs, to avoid deadlock. Now that we know `SyncronizationContext`, remember that
    ASP.NET Core doesn't have it! So `ConfigureAwait(false)` doesn't do anything in
    ASP.NET Core. But that doesn't mean threads can't get blocked in ASP.NET Core.
    Bad code can still do wonders.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 关键字的一个重要特性是对 `SyncronizationContext` 的支持。`SyncronizationContext`
    自 .NET 2.0 以来就存在于框架中，并不是新添加到框架中的东西。正如之前讨论的，当我们在一个 `async` 方法上 `await` 时，编译器会连接到后续操作，如果有的话，并且生成的代码会意识到上下文。所以，如果
    `SyncronizationContext` 可用，`await` 表达式会捕获它并使用它来调用后续操作，这与在 **任务并行库**（**TPL**）中提供的
    `ContinueWith` 方法非常相似。`SyncronizationContext` 应该非常小心地使用，如果我们以阻塞的方式使用该方法，可能会导致死锁。例如，在一个非
    ASP.NET Core 环境中，如果我们使用 `Wait` 方法或使用 `Result` 属性等待一个 `Task`，我们会阻塞主线程。当任务在那个方法中的线程池内最终完成时，它将调用后续操作以将回帖发送到主线程。但由于我们已经阻塞了主线程，而任务正在等待主线程，我们将遇到死锁。作为预防措施，建议库编写者在调用
    `async` API 时使用 `ConfigureAwait(false)`，以避免死锁。现在我们知道了 `SyncronizationContext`，请记住
    ASP.NET Core 没有它！所以 `ConfigureAwait(false)` 在 ASP.NET Core 中不起作用。但这并不意味着线程不能在
    ASP.NET Core 中阻塞。糟糕的代码仍然可以造成奇迹。'
- en: 'While ASP.NET works on top of `System.Web`, has a rather tight integration
    with **Internet Information Server** (**IIS**), and runs inside the IIS process
    (`w3wp.exe`), ASP.NET Core runs outside of the IIS process. The **ASP.NET Core
    Module** (**ANCM**) enables the ASP.NET Core apps to run behind IIS in a reverse
    proxy configuration, which we saw in an earlier chapter. Just to refresh our memories,
    the work of the proxy or forward proxy is to send a request to the server on behalf
    of a client, while that of the reverse proxy is to receive the request on behalf
    of a server. The following image is the high-level architecture of ASP.NET Core.
    Notice that the center box containing ANCM is the only module that runs inside
    of `w3wp.exe`. The **Kestrel** server and the **App Code** runs inside `dotnet.exe`.
    Contrast it with traditional ASP.NET, which runs inside `w3wp.exe`:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 ASP.NET 在 `System.Web` 之上运行，与 **Internet Information Server**（**IIS**）有相当紧密的集成，并在
    IIS 进程（`w3wp.exe`）内运行，但 ASP.NET Core 在 IIS 进程之外运行。**ASP.NET Core 模块**（**ANCM**）使得
    ASP.NET Core 应用可以在反向代理配置下在 IIS 后运行，这在前面章节中已经提到。为了刷新我们的记忆，代理或正向代理的工作是代表客户端向服务器发送请求，而反向代理的工作是代表服务器接收请求。以下图像是
    ASP.NET Core 的高级架构。请注意，包含 ANCM 的中心框是唯一在 `w3wp.exe` 内运行的模块。**Kestrel** 服务器和 **应用代码**在
    `dotnet.exe` 内运行。与传统 ASP.NET 相比，后者在 `w3wp.exe` 内运行：
- en: '![](img/3c4df845-3c71-4052-82dc-21e1bd7fb594.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c4df845-3c71-4052-82dc-21e1bd7fb594.png)'
- en: General tips
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用技巧
- en: 'Now that we know the differences, let''s move on to some tips and tricks that
    are based on top of these architectural differences and more:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这些差异，让我们继续探讨一些基于这些架构差异以及更多内容的技巧和窍门：
- en: 'Recently, I was working on the performance optimization of the ASP.NET Core
    app. We had used in-memory caching with a cache get timeout of five seconds. You
    would expect that any data from in-memory caching would be retrieved in a matter
    of milliseconds as it is an in-process cache and this was generally true. However,
    under load we figured out that data was not getting picked up from the cache.
    Once we added logging, we figured out that the `Get` operation in cache was timing
    out. Yes, even with a five-second value, we had a timeout while fetching data
    from the cache. On investigation, we figured out that we had thread starvation
    in the app. As discussed previously, there is no `RequestQueue` class in ASP.NET
    Core for avoiding this, so here are some tips to avoid thread starvation:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近，我正在优化ASP.NET Core应用程序的性能。我们使用了内存缓存，缓存获取超时设置为五秒。你可能会预期从内存缓存中检索数据只需毫秒级，因为这是一个进程内缓存，这通常是正确的。然而，在负载下，我们发现数据没有被从缓存中检索出来。一旦我们添加了日志记录，我们就发现缓存的`Get`操作超时了。是的，即使有五秒的值，我们在从缓存中获取数据时也遇到了超时。经过调查，我们发现应用程序中存在线程饥饿问题。如前所述，ASP.NET
    Core中没有`RequestQueue`类来避免这种情况，因此以下是一些避免线程饥饿的建议：
- en: Always prefer to use `async` all the way, that is, all the APIs must be `async`.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是优先使用全程`async`，即所有API都必须是`async`。
- en: 'Avoid blocking APIs in your ASP.NET Core application as much as possible. So,
    **DON''T USE**:'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能避免在ASP.NET Core应用程序中使用阻塞API。所以，**不要使用**：
- en: '`Task.Wait()`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Wait()`'
- en: '`Task.Result`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Result`'
- en: '`Thread.Sleep`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.Sleep`'
- en: '`GetAwaiter().GetResult()`.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAwaiter().GetResult()`.'
- en: Avoid `sync` over `async` as they are essentially blocking `async` methods.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在`async`中使用`sync`，因为它们本质上会阻塞`async`方法。
- en: Avoid `async` over `sync` as they have scalability issues.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在`sync`中使用`async`，因为它们存在可扩展性问题。
- en: 'Log thread pool stats in the application code. This helps identify thread starvation.
    Here is the sample code that can be used for logging thread stats. It gives stats
    for both `iopc` and `worker` threads:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序代码中记录线程池统计信息。这有助于识别线程饥饿。以下是可以用于记录线程统计信息的示例代码。它为`iopc`和`worker`线程提供了统计信息：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use tools such as [https://github.com/benaadams/Ben.BlockingDetector](https://github.com/benaadams/Ben.BlockingDetector)
    to diagnose blocking.
  id: totrans-67
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用诸如[https://github.com/benaadams/Ben.BlockingDetector](https://github.com/benaadams/Ben.BlockingDetector)之类的工具来诊断阻塞。
- en: Set minimum threads using `ThreadPool.SetMinThreads` to keep you safe from starvation.
    The number of minimum threads depends on what your app does and you may have to
    fine-tune it based on your testing. Note that `ThreadPool` can quickly (read instantly)
    span the threads up to the minimum number of thread pool threads specified. After
    that, if more threads are needed, they are throttled by 500 ms and this can cause
    delays or timeouts in service, which are hard to comprehend in production environments.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ThreadPool.SetMinThreads`设置最小线程数，以防止你遭受饥饿。最小线程数取决于你的应用程序做什么，你可能需要根据你的测试结果进行微调。请注意，`ThreadPool`可以快速（即瞬间）扩展到指定的最小线程池线程数。之后，如果需要更多线程，它们将被限制在500毫秒内，这可能导致服务中的延迟或超时，这在生产环境中很难理解。
- en: 'You may also want to read about this issue here: [https://github.com/aspnet/KestrelHttpServer/issues/2104](https://github.com/aspnet/KestrelHttpServer/issues/2104).'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在这里了解这个问题：[https://github.com/aspnet/KestrelHttpServer/issues/2104](https://github.com/aspnet/KestrelHttpServer/issues/2104).
- en: The concept of `AppDomain` no longer exists in ASP.NET Core, so for code isolation,
    Microsoft recommends processes and/or containers. For dynamic loading of assemblies,
    the recommendation is to use the `AssemblyLoadContext` class.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDomain`的概念在ASP.NET Core中不再存在，因此为了代码隔离，Microsoft建议使用进程和/或容器。对于动态加载程序集，建议使用`AssemblyLoadContext`类。'
- en: Since there is no `SyncronizationContext` in ASP.NET Core, thankfully there
    shouldn't be any deadlocks in ASP.NET Core if you block a task through `Task.Wait`
    or `Task.Result`. However, this should not be taken as a license to use blocking.
    We must always strive for `async` all the way.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于ASP.NET Core中没有`SyncronizationContext`，幸运的是，如果你通过`Task.Wait`或`Task.Result`阻塞任务，ASP.NET
    Core中不应该有任何死锁。然而，这不应被视为使用阻塞的许可证。我们必须始终努力实现全程`async`。
- en: 'As discussed previously, `ConfigureAwait (false)` has no effect in ASP.NET
    Core, so the following two code snippets work the same way:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，`ConfigureAwait (false)`在ASP.NET Core中没有效果，因此以下两个代码片段以相同的方式工作：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Task continuations in ASP.NET Core are queued to `ThreadPool` and hence can
    run in parallel. Don't be surprised if your `task.ContinueWith(x=>SomeFunction())`
    stops working in ASP.NET Core.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，任务延续被排队到 `ThreadPool`，因此可以并行运行。如果在 ASP.NET Core 中您的 `task.ContinueWith(x=>SomeFunction())`
    停止工作，请不要感到惊讶。
- en: '`HttpContext` is not thread safe. Accessing it in parallel may lead to unreliable
    data and issues.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpContext` 不是线程安全的。并行访问它可能会导致不可靠的数据和问题。'
- en: 'Use Swagger for API testing and documentation. Swagger makes it incredibly
    easy to document and test your APIs. I highly recommend you make use of Swagger
    for the documentation of APIs. There are other tools such as Postman and Fiddler
    that can be used for testing the APIs but Swagger does a great job at it as well.
    Performing a basic API test is as simple as reading this link: [https://swagger.io/blog/how-to-perform-a-basic-api-test/](https://swagger.io/blog/how-to-perform-a-basic-api-test/).
    Read the steps for using Swagger to generate documentation at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio).[](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Swagger 进行 API 测试和文档。Swagger 使得记录和测试您的 API 变得非常简单。我强烈建议您使用 Swagger 来记录 API
    的文档。还有其他工具，如 Postman 和 Fiddler，也可以用于测试 API，但 Swagger 在此方面也做得很好。执行基本的 API 测试就像阅读这个链接一样简单：[https://swagger.io/blog/how-to-perform-a-basic-api-test/](https://swagger.io/blog/how-to-perform-a-basic-api-test/)。阅读使用
    Swagger 生成文档的步骤，请参阅[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio)。
- en: 'The `InMemory` provider of Ef Core is very useful when you want to test components
    using something that approximates connecting to the real database, without the
    overhead of actual database operation. Please see this link for the step-by-step
    approach: [https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory).[](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ef Core 的 `InMemory` 提供者当您想要使用近似连接到真实数据库的方式来测试组件时非常有用，而不需要实际数据库操作的开销。请参阅此链接以获取逐步方法：[https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory)。
- en: ANCM is designed in such a way that if your first request takes a lot of time,
    it will disconnect the client and close the process.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ANCM 被设计成这样的方式，如果您的第一个请求花费了很长时间，它将会断开客户端并关闭进程。
- en: Security is one of the most important but often overlooked aspects in the development
    of web apps. Security is such a vast topic to cover that it is beyond the scope
    of this book, but I would highly recommend developers thoroughly go through the
    security documentation of ASP.NET Core at [https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)
    and inculcate their learning in day-to-day development activities.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性是开发 Web 应用程序中最重要但经常被忽视的方面之一。安全性是一个涵盖范围很广的话题，超出了本书的范围，但我强烈建议开发者们彻底阅读 ASP.NET
    Core 的安全文档[https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)，并将所学知识融入日常开发活动中。
- en: 'At times, we may have an issue even while starting the app, due to an incorrect
    code. Though the console logger logs the output in the console window that appears
    briefly at the startup, as soon as the console vanishes (which happens pretty
    quickly), we have no means to know what happened or what prevented the app from
    being started. In such situations, generally the ASP.NET Core module configuration
    can help us unearth the root cause of the issue. The configuration is done in
    the `aspNetCore` section of the `system.webserver` node present in the `web.config`
    file, which is located at the root of the web app. We can enable the output logging
    and specify the log file path. So, in such cases, the detailed error message will
    be logged, and we will be able to identify the cause of the issue. The following
    entry from `web.config` illustrates this:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，即使是在启动应用程序时，也可能因为代码错误而出现问题。尽管控制台日志记录器会在启动时短暂出现在控制台窗口中记录输出，但一旦控制台消失（这发生得相当快），我们就无法知道发生了什么，或者是什么阻止了应用程序的启动。在这种情况下，通常ASP.NET
    Core模块配置可以帮助我们找到问题的根本原因。配置是在`web.config`文件中`system.webserver`节点下的`aspNetCore`部分完成的，该文件位于Web应用程序的根目录。我们可以启用输出日志并指定日志文件路径。因此，在这种情况下，详细的错误消息将被记录，我们将能够确定问题的原因。以下是从`web.config`中摘录的示例：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the app is deployed in Azure, the `stdoutLogFile` path is modified to direct
    the app to the `LogFiles` folder of the app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序部署到Azure时，`stdoutLogFile`路径被修改，以将应用程序指向应用程序的`LogFiles`文件夹。
- en: In this section, we discussed a few points relating to the usage of ASP.NET
    Core. In the next section, we will discuss a few tips on performance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了一些与ASP.NET Core使用相关的问题。在下一节中，我们将讨论一些关于性能的技巧。
- en: Performance tips
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能技巧
- en: 'ASP.NET Core is one of the fastest platforms on the fundamentals of web request
    routing, as per benchmarks. Read the complete story at [https://www.techempower.com/blog/2016/11/16/framework-benchmarks-round-13/](https://www.techempower.com/blog/2016/11/16/framework-benchmarks-round-13/).
    In this section, we will discuss the points we can use to achieve better performance
    in our ASP.NET Core apps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基准测试，ASP.NET Core是建立在Web请求路由基础上的最快平台之一。请阅读完整的故事[https://www.techempower.com/blog/2016/11/16/framework-benchmarks-round-13/](https://www.techempower.com/blog/2016/11/16/framework-benchmarks-round-13/)。在本节中，我们将讨论我们可以用来在我们的ASP.NET
    Core应用程序中实现更好性能的要点：
- en: It might sound repetitive, but please use `async` all the way. This is key to
    the performance of an ASP.NET Core app.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然可能听起来有些重复，但请始终使用`async`。这是ASP.NET Core应用程序性能的关键。
- en: 'Test, test, and test! Perform load testing of your app early and often to find
    the issues early in development. Our team, in fact, came up with a radical idea
    to identify performance bottlenecks. The idea is to write middleware, that calculates
    the response time of the API, and if the response time is higher than the threshold,
    throw an exception, so the developer has to fix it. I would not recommend going
    this drastic but the intent is to identify the performance issues early in the
    game. If your app is deployed in Azure, you can do the performance testing in
    the Azure portal itself, using the following simple steps (here I am assuming
    there is no authentication header needed, otherwise we can write Visual Studio
    performance tests as well):'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，测试，再测试！尽早并经常对您的应用程序进行负载测试，以在开发早期发现问题。实际上，我们的团队提出了一种激进的想法来识别性能瓶颈。这个想法是编写中间件，计算API的响应时间，如果响应时间高于阈值，则抛出异常，这样开发者就必须修复它。我不建议采取这种极端的做法，但目的是在早期阶段识别性能问题。如果您的应用程序部署在Azure上，您可以在Azure门户本身中进行性能测试，按照以下简单步骤（这里我假设不需要认证头，否则我们也可以编写Visual
    Studio性能测试）：
- en: In the Azure portal, navigate to the App Service that we wish to performance
    test.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Azure门户中，导航到我们想要进行性能测试的应用程序服务。
- en: On the left panel of the App Service, there is an item called Performance test.
    Click on it. It will open the Performance test blade.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序服务的左侧面板中，有一个名为性能测试的项目。点击它。它将打开性能测试面板。
- en: Enter the required fields for user load and duration. Each of the fields has
    a help tool tip so it should be easy to identify the purpose of each field.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入用户负载和持续时间的所需字段。每个字段都有一个帮助工具提示，因此应该很容易识别每个字段的用途。
- en: Configure the test to use either a manual URL or a Visual Studio web test. If
    you select manual test, you will need to specify the URL that needs to be load
    tested. If of a Visual Studio web test, you will need to upload the Visual Studio
    web test file.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置测试以使用手动URL或Visual Studio Web测试。如果你选择手动测试，你需要指定需要负载测试的URL。如果是Visual Studio
    Web测试，你需要上传Visual Studio Web测试文件。
- en: Click **Done** and then click **Run test**.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**，然后点击**运行测试**。
- en: The performance test will run and display the run stats, such as successful
    requests, failed requests with errors, memory and CPU usage, and so on:![](img/51840ec0-f83a-473d-b6b3-686ce738248a.png)
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能测试将运行并显示运行统计信息，例如成功请求、失败请求的错误、内存和CPU使用情况等等：![图片](img/51840ec0-f83a-473d-b6b3-686ce738248a.png)
- en: Use caching to store static, less frequently changing and frequently accessed
    data. If you are building an enterprise application, consider leveraging the Azure
    Redis cache for fast data access.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存来存储静态的、变化频率较低且频繁访问的数据。如果你正在构建企业应用程序，考虑利用Azure Redis缓存以实现快速数据访问。
- en: 'Use the garbage collector in server garbage collection mode. This will ensure
    that your memory footprint doesn''t increase over time. This can be done by the
    following configuration in the `web.config` file, or add an `app.config` file
    with the following code:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器垃圾回收模式中的垃圾回收器。这将确保你的内存占用不会随着时间的推移而增加。这可以通过以下`web.config`文件中的配置来完成，或者添加一个包含以下代码的`app.config`文件：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can read more about the `gcServer` element at [https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element)上了解更多关于`gcServer`元素的信息。
- en: If you make use of web APIs in your application, use `HttpClient` to make the
    API calls. Remember to create the `HttpClient` instance only once and reuse it
    multiple times, that is, create a singleton instance of `HttpClient` and don't
    create it every time. In terms of Dependency Injection, use it as singleton and
    not as transient or scoped.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在应用程序中使用Web API，请使用`HttpClient`来执行API调用。请记住只创建一次`HttpClient`实例并多次重用它，也就是说，创建一个`HttpClient`的单例实例，而不是每次都创建它。在依赖注入方面，将其用作单例而不是瞬态或作用域。
- en: 'While developing the API, follow these rules:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发API时，遵循以下规则：
- en: '**Bring only the data that you need**: For the purpose of code re-usability,
    I have seen teams using a single API that returns a plethora of data, even though
    only a part of it is needed. For a small number of users, it may not perform badly,
    but as the user load increases, this will start causing performance bottlenecks,
    so be very miserly with the data that your service returns.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只携带你需要的数据**：为了代码的可重用性，我见过一些团队使用一个返回大量数据的单个API，尽管只需要其中的一部分。对于少量用户，这可能表现不佳，但随着用户负载的增加，这将会开始造成性能瓶颈，所以对你的服务返回的数据要非常节俭。'
- en: '**Choice of serializer**: A considerable amount of time is spent by a service
    API in serializing the data and then sending it as a response. The client then
    gets the response and deserializes it back which again takes time. It is worth
    investing in a serializer that does the job faster, to provide better response
    time performance. There are a number of serializers at the developer''s disposal
    such as JSON, BSON, MessagePack, Protocol Buffers, and so on. We recently changed
    JSON to MessagePack and found massive performance gains, as a MessagePack payload
    is about 66% of JSON and about three times as fast.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化器选择**：服务API在序列化数据并发送响应的过程中花费了相当多的时间。客户端随后接收到响应并反序列化它，这同样需要时间。投资于一个能更快完成工作的序列化器，以提供更好的响应时间性能是值得的。开发者有多个序列化器可供选择，例如JSON、BSON、MessagePack、Protocol
    Buffers等等。我们最近将JSON改为MessagePack，并发现了巨大的性能提升，因为MessagePack的有效负载大约是JSON的66%，并且大约快三倍。'
- en: '**Compression:** Think of compressing the data sent from the service API to
    the client. This will be beneficial to mobile users, as well as to whoever may
    be using your app on a flaky and low bandwidth network, so less data to load would
    make apps faster. Also, by compressing the payload, we make our application scalable
    as the bandwidth available to us is limited. There are numerous ways of doing
    it. Of course, `HttpClient` has support for `GZip` compression so we can leverage
    it. Equally important is the fact that we can choose what properties to serialize.
    So, if your entity has ten properties and you need only two properties, then it
    makes perfect sense to serialize only those two properties and ignore the remaining
    eight properties, to reduce the payload. This is well supported in JSON and we
    made extensive use of it, and in a few cases came down from 32 MB data to less
    than 1 MB data. Imagine if this API is called by hundreds of users!'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩**：考虑压缩从服务 API 发送到客户端的数据。这对移动用户以及可能在使用您应用的波动和低带宽网络上的人来说都是有益的，因为减少要加载的数据量会使应用运行得更快。此外，通过压缩有效载荷，我们使我们的应用程序可扩展，因为我们可用的带宽是有限的。有许多方法可以实现这一点。当然，`HttpClient`
    支持 `GZip` 压缩，因此我们可以利用它。同样重要的是，我们可以选择要序列化的属性。所以，如果您的实体有十个属性，而您只需要两个属性，那么只序列化这两个属性并忽略剩余的八个属性是完全合理的，以减少有效载荷。这在
    JSON 中得到了很好的支持，我们广泛地使用了它，并且在少数情况下将数据从 32 MB 减少到不到 1 MB。想象一下，如果这个 API 被数百个用户调用！'
- en: Make good use of bundling and minification, as discussed in an earlier chapter.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请充分利用捆绑和最小化，正如前面章节中讨论的那样。
- en: Response caching reduces the number of requests a client or proxy makes to a
    web server. Response caching also reduces the amount of work the web server performs
    to generate a response, hence improving the performance. Please make a note that
    response caching is not supported for ASP.NET Core Razor pages, but support is
    expected to come in ASP.NET Core 2.1.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应缓存减少了客户端或代理对 Web 服务器的请求数量。响应缓存还减少了 Web 服务器生成响应所需的工作量，从而提高了性能。请注意，响应缓存不支持 ASP.NET
    Core Razor 页面，但预计将在 ASP.NET Core 2.1 中提供支持。
- en: While using parallelism or multiple threads to write data, make use of concurrent
    collections. In fact, if you think you may have multiple threads modifying a collection,
    it's always safe to use concurrent collections, with little overhead.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用并行或多个线程写入数据时，请使用并发集合。实际上，如果您认为可能有多个线程修改一个集合，使用并发集合总是安全的，而且开销很小。
- en: Avoid API or database calls inside a loop. In the case of APIs, try to create
    an API that takes the collection as input and processes that to return a consolidated
    but trimmed set of required data. In the case of a database, create a stored procedure
    that accepts a user-defined table as a parameter and returns the data in one go.
    This will make the application less chatty.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在循环内部进行 API 或数据库调用。对于 API，尝试创建一个接受集合作为输入并处理以返回所需数据的精简集合的 API。对于数据库，创建一个存储过程，该存储过程接受用户定义的表作为参数，并一次性返回数据。这将使应用程序的交互更少。
- en: Do not perform string concatenation inside loops. Use `StringBuilder` if you
    need to concatenate strings inside loops.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在循环内部执行字符串连接操作。如果您需要在循环内部连接字符串，请使用 `StringBuilder`。
- en: 'Visual Studio has great support for profiling your application to identify
    high CPU issues, so do make good use of the Visual Studio profiler while in the
    development phase. It''s very simple to use, as illustrated in these steps:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 对应用程序的剖析支持非常好，可以帮助您识别高CPU问题，因此在开发阶段请务必充分利用 Visual Studio 的剖析器。使用起来非常简单，如下步骤所示：
- en: Ensure that the app that you wish to profile is up and running in the machine.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您希望剖析的应用程序在机器上运行并处于活动状态。
- en: Open Visual Studio and in the quick launch, search for Performance Explorer.
    Alternatively, you can navigate through Debug | Profiler | Performance Explorer
    | Attach/Detach, as shown here:![](img/f4952a2a-0817-435e-9dc3-47fd3956883c.png)
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio，在快速启动中搜索“性能资源管理器”。或者，您可以通过 Debug | Profiler | Performance Explorer
    | Attach/Detach 导航，如下所示：![图片](img/f4952a2a-0817-435e-9dc3-47fd3956883c.png)
- en: It will open a dialog, displaying the list of running processes. Select the
    process that you wish to profile and click Attach.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将打开一个对话框，显示正在运行的进程列表。选择您希望剖析的进程，然后点击“附加”。
- en: The profiling will start. Now is the time to reproduce your high CPU issue and
    once it is reproduced, stop the profiling. It will generate a detailed profiling
    report. We will see what the profile report looks like a little later when we
    discuss profiling in Azure.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析将开始。现在是重现您的 CPU 高负载问题的时机，一旦重现，请停止分析。它将生成一个详细的分析报告。我们将在稍后讨论 Azure 中的分析时，看看分析报告的样子。
- en: Profile your memory to identify whether there is a memory leak. Always remember,
    that if your memory percentage remains constant or keeps increasing over a period
    of time, there may be a memory leak. Memory leak can be described as a situation
    where a program holds on to the memory even if that memory is discarded and no
    longer needed. Due to bad coding, the developer code can prevent the **Garbage
    Collector** (**GC**) from reclaiming the memory, and hence, used memory keeps
    increasing over a period of time, resulting in performance issues or failures.
    Apart from Visual Studio, there are many good profiling tools that can be used
    such as dotTrace, MemProfiler, ANTS Memory Profiler, PerfView, to name a few.
    One of the common causes of memory leak in the ASP.NET Core applications that
    I have encountered is wrong Dependency Injection. So, if an object needs to be
    scoped or transient and you register it as a singleton, we may be injecting memory
    leak if it's not meant to be a singleton. Static objects and dictionaries are
    another common cause of memory leak, so please think multiple times before marking
    an object as static.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析您的内存以确定是否存在内存泄漏。请始终记住，如果您的内存百分比保持恒定或在一段时间内持续增加，那么可能存在内存泄漏。内存泄漏可以描述为程序即使该内存被丢弃且不再需要时仍然保留内存的情况。由于不良的编码，开发者的代码可能阻止
    **垃圾回收器** (**GC**) 回收内存，因此，使用的内存会随着时间的推移而不断增加，导致性能问题或失败。除了 Visual Studio 之外，还有许多优秀的分析工具可以使用，例如
    dotTrace、MemProfiler、ANTS Memory Profiler、PerfView 等。我在遇到的 ASP.NET Core 应用程序中，内存泄漏的一个常见原因是错误的依赖注入。因此，如果一个对象需要作用域或瞬态，而你将其注册为单例，那么如果它不是单例，我们可能会注入内存泄漏。静态对象和字典也是内存泄漏的另一个常见原因，所以在将对象标记为静态之前请三思。
- en: ASP.NET Core has support for analyzers. Code analysis, as the name suggests,
    is the analysis of the code to identify potential code issues, such as improper
    coding, noncompliance to standards, security violations, and design problems.
    Code analysis can be static or dynamic. In static, the analysis is done without
    actually running the code. StyleCop, FxCop are few of the most well-known and
    frequently used code analyzers. Make use of analyzers to identify code issues
    early. A few of the great ones are `Microsoft.CodeAnalysis`, `SonarAnalyzer.Csharp`,
    `FxCop analyzer`, `Roslynator.Analyzers`, and `Stylecop analyzer`, to name a few.
    These are also simple to use—right-click on the project and select Nuget Package
    Manager. Search for the analyzer of your choice and install it. Build your project
    and observe the warnings and errors in the error window. This will help you nail
    a variety of issues, such as possible performance bottlenecks, security vulnerabilities,
    as well as not following best practices.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 支持分析器。正如其名，代码分析是对代码的分析，以识别潜在的代码问题，例如不当编码、不符合标准、安全违规和设计问题。代码分析可以是静态的或动态的。在静态分析中，分析是在不实际运行代码的情况下进行的。StyleCop、FxCop
    是最知名且最常使用的代码分析器之一。利用分析器来尽早识别代码问题。其中一些优秀的分析器包括 `Microsoft.CodeAnalysis`、`SonarAnalyzer.Csharp`、`FxCop
    analyzer`、`Roslynator.Analyzers` 和 `Stylecop analyzer` 等。这些分析器使用起来也很简单——在项目上右键单击并选择
    Nuget 包管理器。搜索您选择的分析器并安装它。构建您的项目并观察错误窗口中的警告和错误。这将帮助您解决各种问题，例如可能的性能瓶颈、安全漏洞以及不遵循最佳实践。
- en: 'Read this excellent MSDN blog post on performance improvements in ASP.NET Core:
    [https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/](https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这篇关于 ASP.NET Core 性能改进的优秀 MSDN 博客文章：[https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/](https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/).
- en: Also, read the official performance documentation of ASP.NET Core at [https://docs.microsoft.com/en-us/aspnet/core/performance/](https://docs.microsoft.com/en-us/aspnet/core/performance/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还请阅读 ASP.NET Core 的官方性能文档：[https://docs.microsoft.com/en-us/aspnet/core/performance/](https://docs.microsoft.com/en-us/aspnet/core/performance/).
- en: Next, we will look at a few of the cool and handy features of Azure that can
    help us be more productive.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些 Azure 的酷炫且实用的功能，这些功能可以帮助我们提高生产力。
- en: Azure tips
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure 小贴士
- en: 'Azure has a plethora of features and most of them remain unexplored or unused
    by a number of developers, though they are extremely useful and provide value.
    A few of the important ones I came across are listed here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Azure拥有众多功能，尽管它们非常实用且具有价值，但许多开发者却未探索或使用它们。我在这里列出了一些重要的功能：
- en: '**Azure in your pocket**: We will start with a cheesy one. Yes, Azure in your
    pocket. Now Azure is available as a mobile app, and you can virtually carry your
    Azure subscription wherever you go. You can keep track of your Azure resources
    on the go and stay connected—anytime, anywhere. The following image shows a glimpse
    of the Azure mobile app:![](img/d12f8f80-285f-47f6-8381-552aadc944ac.png)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**口袋里的Azure**：我们将从一个俗套的话题开始。是的，口袋里的Azure。现在Azure已经作为移动应用提供，您可以随时随地携带您的Azure订阅。您可以在路上跟踪您的Azure资源，并保持连接——随时随地。以下图片展示了Azure移动应用的一瞥
    ![图片](img/d12f8f80-285f-47f6-8381-552aadc944ac.png)'
- en: '**Advisor**: In the left panel of the Azure portal, there is an item called
    Advisor. Although it''s free, it''s a relatively lesser-used and talked about
    feature of Azure. It''s completely free and it provides real-time advisory services
    on your Azure resources, based on how they are used. Just click on the Advisor
    and it will give security, performance, cost, and availability recommendations.
    The recommendations can also be downloaded in CSV or PDF format. Here is the teaser
    of Azure Advisor:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顾问**：在Azure门户的左侧面板中，有一个名为“顾问”的项目。尽管它是免费的，但它是Azure相对较少使用和讨论的功能之一。它是完全免费的，并且根据资源的实际使用情况提供实时咨询服务。只需点击顾问，它就会提供安全、性能、成本和可用性建议。建议也可以下载为CSV或PDF格式。以下是Azure顾问的预告片：'
- en: '![](img/502b6376-7da3-4313-a53b-291a50aedd71.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/502b6376-7da3-4313-a53b-291a50aedd71.png)'
- en: '**Security Center**: Just like Advisor, there is a Security Center option in
    the left panel. This is a great and free feature of Azure. It does threat detection
    all the Azure resources in your subscription and gives pointed recommendations.
    It also lets you know of any security incidents that occurred with your resources
    and threat assessment reports. There is a paid plan which has advanced threat
    detection but the free option is a good starting point. The following image shows
    the Security Center:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全中心**：与顾问类似，在左侧面板中还有一个安全中心选项。这是Azure的一个非常棒且免费的特性。它检测您订阅中所有Azure资源的威胁，并提供针对性的建议。它还会通知您资源发生的任何安全事件和威胁评估报告。有一个付费计划提供了高级威胁检测，但免费选项是一个很好的起点。以下图片显示了安全中心：'
- en: '![](img/52cad30f-da83-436a-b310-8a831c0997d4.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52cad30f-da83-436a-b310-8a831c0997d4.png)'
- en: '**Activity logs**: When I have worked in a team that is working on Azure, there
    have been instances where I am working on the web app and some other team member
    accidentally changes the configuration, or maybe restarts or deletes a resource,
    and I have no clue what happened. I have myself been the culprit, modifying the
    configuration while the performance test was running, which restarted the web
    app. Azure has a solution for these kinds of situations as well. Every action
    that a user does is logged in the activity log of the resource you are working
    with. So, next time you encounter something like this, just go and see the activity
    log, as shown here. In the Azure portal, go to the resource you wish to see the
    activity log of. On the left panel of the resource, click on Activity Log. You
    can also apply filters and choose the time duration for which you wish to see
    the activity log:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动日志**：当我在一个正在开发Azure的团队工作时，曾经遇到过这样的情况：我在处理Web应用时，某个团队成员不小心更改了配置，或者可能是重启或删除了资源，而我对此一无所知。我自己也曾是罪魁祸首，在性能测试运行时修改了配置，导致Web应用重启。Azure也有针对这类情况的解决方案。用户所做的每一个动作都会记录在您正在操作的资源活动日志中。所以，下次您遇到类似情况时，只需查看活动日志，如图所示。在Azure门户中，转到您想查看活动日志的资源。在资源的左侧面板中，点击活动日志。您还可以应用过滤器并选择您想查看活动日志的时间范围：'
- en: '![](img/1a49b25f-8382-4241-8193-8e2af8b8d833.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a49b25f-8382-4241-8193-8e2af8b8d833.png)'
- en: '**Diagnostic logging**: If you are running into issues in the app deployed
    in Azure and do not know what''s going on, enable logging and Application Insights
    in your app. We looked at Application Insights earlier. Logging can give us details
    such as failed request tracing and detailed error logs. You will see two options
    for Application Logging—Blob and Filesystem. As the name suggests, logs are stored
    in blob and filesystem. Filesystem logging is enabled only for 12 hours, as there
    is a risk of logs eating up memory. The following image shows the diagnostic logging
    configuration:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断日志**：如果你在Azure中部署的应用遇到问题，而不知道发生了什么，请在你的应用中启用日志记录和Application Insights。我们之前已经讨论了Application
    Insights。日志记录可以提供诸如失败的请求跟踪和详细的错误日志等详细信息。你将看到两个应用程序日志选项——Blob和文件系统。正如其名所示，日志存储在Blob和文件系统中。文件系统日志仅启用12小时，因为存在日志消耗内存的风险。以下图片显示了诊断日志配置：'
- en: '![](img/779e4da9-2644-4bf0-8ade-71cb02493c79.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/779e4da9-2644-4bf0-8ade-71cb02493c79.png)'
- en: '**Diagnosing and solving issues**: This is another cool feature in Azure. If
    you run into issues or suspect something is going wrong in your App Service, Azure
    provides very good diagnoses and a fix for the issues. It is able to clearly identify
    whether the issue is due to a platform or application code issue. It diagnoses
    a variety of problem categories such as web app down, slow web app, high CPU usage,
    high memory usage, web app restarted, TCP connections. It has a chat interface
    making it easier to use. Just click on one of the problem categories and it will
    do the analysis on the app for the last 24 hours and share the graph and findings,
    which makes it extremely easy to identify the issue. It will also give recommendations
    if you need to scale out your app. Also, you can do a health checkup of the resource
    on demand, which gives a single view for application errors, performance, CPU,
    and memory usage. This is definitely a very handy tool to use for diagnosis. Here
    is the screenshot for diagnosing and solving issues:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断和解决问题**：这是Azure中另一个酷炫的功能。如果你遇到问题或者怀疑你的App Service中出了问题，Azure提供了非常好的诊断和问题修复功能。它能够清楚地识别问题是由平台或应用代码问题引起的。它可以诊断各种问题类别，如网站应用宕机、慢速网站应用、高CPU使用率、高内存使用率、网站应用重启、TCP连接等。它有一个聊天界面，使得使用更加方便。只需点击一个问题类别，它就会对过去24小时内的应用进行分析，并分享图表和发现，这使得识别问题变得极其简单。如果需要扩展你的应用，它还会给出建议。此外，你可以按需对资源进行健康检查，这提供了一个单一视图来查看应用错误、性能、CPU和内存使用情况。这绝对是一个用于诊断的非常实用的工具。以下是诊断和解决问题的截图：'
- en: '![](img/d9b7e223-36d8-44ba-a9c2-03eebc20cf50.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9b7e223-36d8-44ba-a9c2-03eebc20cf50.png)'
- en: '**Diagnostics as a Service (DaaS)**: Yet another great troubleshooting tool
    for developers is DaaS. When you open the diagnose and solve issues blade for
    your App Service, there is a panel on the right displaying a number of links:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断即服务（DaaS）**：对于开发者来说，DaaS是另一个出色的故障排除工具。当你打开App Service的诊断和解决问题选项卡时，右侧会显示一个面板，展示多个链接：'
- en: '![](img/3c7d2aaf-ca58-46d3-90bb-d89655987fcf.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c7d2aaf-ca58-46d3-90bb-d89655987fcf.png)'
- en: 'Each of them is a great diagnostic and support tool in itself, but we will
    focus on DaaS. I would highly recommend you explore each of these links. Coming
    back to DaaS, this is what it looks like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都是本身就是一个出色的诊断和支持工具，但我们将重点关注DaaS。我强烈建议你探索每个链接。回到DaaS，它看起来是这样的：
- en: '![](img/f2267c33-46bf-41f3-b576-d994519f3125.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2267c33-46bf-41f3-b576-d994519f3125.png)'
- en: It has support for ASP.NET, PHP, and Java applications. We will select ASP.NET
    as our application type and when we do that, we will see ASP.NET-specific diagnosers
    such as CLR Profiler, Event Viewer Logs, Memory Dump, and HTTP Logs. Based on
    the diagnosis that we need to do, we can select appropriate options. I generally
    check everything whenever I am doing diagnosis. Memory Dump analysis can be great
    to identify memory leaks, but the dump needs to be taken when you observe constant
    high or increasing memory usage. Now, how to do it. Well, it's simple, you can
    see the memory and CPU usage of your App Service in the Overview blade of your
    App Service in the portal. Note that you would need at least two memory dumps
    to confirm a memory leak. Likewise, CLR Profiler can be used to find out what
    section of your code is doing the most work at the time of profiling, so it's
    important to profile when the time issue is occurring in your App Service. After
    selecting the options, click Run.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持 ASP.NET、PHP 和 Java 应用程序。我们将选择 ASP.NET 作为我们的应用程序类型，当我们这样做时，我们将看到 ASP.NET
    特定的诊断器，例如 CLR 性能分析器、事件查看器日志、内存转储和 HTTP 日志。根据我们需要进行的诊断，我们可以选择合适的选项。我通常在诊断时检查所有内容。内存转储分析可以很好地识别内存泄漏，但需要在您观察到内存使用量持续高或增加时进行转储。那么，如何进行呢？嗯，很简单，您可以在门户中
    App Service 的概览选项卡中查看您的 App Service 的内存和 CPU 使用情况。请注意，您至少需要两个内存转储来确认内存泄漏。同样，CLR
    性能分析器可以用来找出在性能分析期间您的代码的哪个部分正在做最多工作，因此当您的 App Service 中出现时间问题时进行性能分析很重要。选择选项后，点击运行。
- en: 'Azure will capture the data and then perform the analysis, and share the analysis
    report which you download and act upon, as shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 将捕获数据，然后进行分析，并分享分析报告，您下载并据此采取行动，如下面的截图所示：
- en: '![](img/1b183337-c5f3-41ca-9cea-d2b460ca50a6.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b183337-c5f3-41ca-9cea-d2b460ca50a6.png)'
- en: The CLR Profiler `.diagsession` file can be downloaded by clicking on the `.diagsession`
    file shown in the image under the Collection Status column, and opened in Visual
    Studio. It will give you the hot path as well as the code block and methods doing
    the most work during the profiling session. The Memory Dump can also be downloaded
    and you can do a memory dump analysis locally using Windbg or DebugDiag, as needed.
    Azure provides a DebugDiag analysis report which can be directly downloaded.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击收集状态列下显示的 `.diagsession` 文件来下载 CLR 性能分析器 `.diagsession` 文件，并在 Visual Studio
    中打开。它将给出热点路径以及性能分析会话期间执行最多工作的代码块和方法。内存转储也可以下载，您可以使用 Windbg 或 DebugDiag 在本地进行内存转储分析，根据需要。Azure
    提供了 DebugDiag 分析报告，可以直接下载。
- en: '**Azure Service Profiler**: Use Azure Service Profiler to identify high CPU
    issues. This has great support for ASP.NET Core 2.0\. The setup details and value
    it provides can be seen at [https://www.azureserviceprofiler.com/](https://www.azureserviceprofiler.com/).
    On installing this Profiler for your web app, it will run as a web job and diagnose
    the issue by identifying the hot paths. It also summarizes performance data to
    find long-tail performance problems.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 服务性能分析器**：使用 Azure 服务性能分析器来识别高 CPU 问题。它对 ASP.NET Core 2.0 提供了很好的支持。设置细节和它提供的价值可以在
    [https://www.azureserviceprofiler.com/](https://www.azureserviceprofiler.com/)
    上查看。在您的 Web 应用程序上安装此分析器后，它将以 Web 作业的形式运行，并通过识别热点路径来诊断问题。它还总结性能数据以查找长尾性能问题。'
- en: '**Profiling the app for high CPU**: With the detailed metrics on CPU and memory
    provided by Azure, we can easily identify whether the App Service is using high
    CPU. If it is, how do we figure out what is causing the app to use high CPU? Yes,
    profiling. Profiling is easy to do in Visual Studio and even in Azure. Even though
    DaaS does the profiling, I always see `w3wp.exe` getting profiled and not the
    actual application `.exe` that we have built. To profile our application code,
    we can do the following simple steps:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析应用以检测高 CPU 使用情况**：借助 Azure 提供的 CPU 和内存详细指标，我们可以轻松地识别 App Service 是否正在使用高
    CPU。如果是的话，我们如何找出导致应用使用高 CPU 的原因呢？是的，进行性能分析。在 Visual Studio 和 Azure 中进行性能分析都很简单。尽管
    DaaS 进行了性能分析，但我总是看到 `w3wp.exe` 被分析，而不是我们实际构建的应用程序 `.exe`。为了分析我们的应用程序代码，我们可以执行以下简单的步骤：'
- en: In the Azure portal, select the App Service that you wish to profile (search
    for the App Service and click it).
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 门户中，选择您希望分析性能的 App Service（搜索 App Service 并点击它）。
- en: In the left panel of the App Service, click on Advanced Tools. This will open
    the Advanced Tools blade. Click on the Go button in this blade. This will take
    you to the Kudu site of your App Service. There is a shortcut to reach here. If
    your App Service URL is [http://myappservice.azurewebsites.net](http://myappservice.azurewebsites.net),
    then the corresponding Kudu site would be [http://myappservice.**scm**.azurewebsites.net](http://myappservice.scm.azurewebsites.net).
    Notice `scm` between `myappservice` and `azurewebsites.net`. You must have required
    access to the Kudu site, so not everyone can go to the Kudu site of any website:![](img/7b91ffaa-1eb3-4da3-b782-54895d5c72bb.png)
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用服务的左侧面板中，点击“高级工具”。这将打开高级工具面板。在此面板中点击“转到”按钮。这将带您到您的应用服务的Kudu站点。这里有一个快捷方式可以到达这里。如果您的应用服务URL是[http://myappservice.azurewebsites.net](http://myappservice.azurewebsites.net)，那么相应的Kudu站点将是[http://myappservice.**scm**.azurewebsites.net](http://myappservice.scm.azurewebsites.net)。注意`scm`位于`myappservice`和`azurewebsites.net`之间。您必须有权访问Kudu站点，因此并非每个人都可以访问任何网站的Kudu站点：![](img/7b91ffaa-1eb3-4da3-b782-54895d5c72bb.png)
- en: In the top bar, select Process explorer. This will open the Process Explorer
    as shown here:![](img/7d5bdf46-c149-4041-9db8-3cdf4207e597.png)
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部栏中，选择进程资源管理器。这将打开进程资源管理器，如图所示：![](img/7d5bdf46-c149-4041-9db8-3cdf4207e597.png)
- en: Click on the Start Profiling button of your application `.exe`, when you observe
    high CPU in the app. It will take a while to start profiling. Once the profiling
    is done, click on Stop Profiling. This will start generating the diagnostics and
    generate the `.diagsession` file, which you will be prompted to download.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您观察到应用中的CPU使用率较高时，点击您的应用程序`.exe`的“开始分析”按钮。开始分析需要一段时间。一旦分析完成，点击“停止分析”。这将开始生成诊断信息并生成`.diagsession`文件，您将被提示下载该文件。
- en: Upon downloading the file, open it with Visual Studio. It will show the CPU
    graph. There will be a button called Create detailed report. Click on it and it
    will open a nice-looking report with hot paths, a summary, and will lead you to
    the code causing the high CPU, as shown here:![](img/79c138b4-1f4b-465b-ab47-545726067c37.png)
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载文件后，使用Visual Studio打开它。它将显示CPU图表。将有一个名为“创建详细报告”的按钮。点击它，它将打开一个包含热点路径、摘要并引导您到导致高CPU使用的代码的漂亮报告，如图所示：![](img/79c138b4-1f4b-465b-ab47-545726067c37.png)
- en: '**Support**: Now that we know the Kudu site, another diagnostic tool that may
    be useful is Azure App Service Support, which can be browsed by appending `/support`
    in the Kudu site URL. For the preceding example, the support site would be [http://myappservice.scm.azurewebsites.net/support](http://myappservice.scm.azurewebsites.net/support).
    As of writing this chapter, it is in a preview state. We can Observe, Analyze,
    and Mitigate the issues from here, as shown in the following screenshot. The Observe
    section can be used to view stats such as requests/second and errors/sec. The
    Analyze section can be used to view FREB (**F**ailed **R**equest **E**rror **B**uffering)
    Logs, Event Viewer logs, and running Diagnostics to figure out CPU and memory
    issues. The Mitigate section has a switch to autoheal the app. Most memory and
    CPU issues are resolved upon restart and that is where the autoheal feature comes
    into the picture. If you have a scenario where you need to recycle the application
    automatically, after it has served, say, *X* number of requests in *Y* amount
    of time, you can consider autoheal as an option—*X* and *Y* can be configured
    by means of a rule:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：既然我们已经知道了Kudu站点，另一个可能有用的诊断工具是Azure应用服务支持，这可以通过在Kudu站点URL中附加`/support`来浏览。对于前面的示例，支持站点将是[http://myappservice.scm.azurewebsites.net/support](http://myappservice.scm.azurewebsites.net/support)。截至撰写本章时，它处于预览状态。我们可以从这里观察、分析和缓解问题，如图下所示。观察部分可以用来查看每秒请求数和每秒错误数等统计数据。分析部分可以用来查看FREB（**F**ailed
    **R**equest **E**rror **B**uffering）日志、事件查看器日志和运行诊断以确定CPU和内存问题。缓解部分有一个自动修复应用的开关。大多数内存和CPU问题在重启后都会得到解决，这就是自动修复功能发挥作用的地方。如果您有一个需要在应用服务后自动回收的场景，比如在*Y*时间内处理了*X*数量的请求，您可以考虑将自动修复作为一个选项——*X*和*Y*可以通过以下规则进行配置：'
- en: '![](img/98dd093c-23ed-4a30-bd6c-259228453019.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98dd093c-23ed-4a30-bd6c-259228453019.png)'
- en: '**New support request**: If none of these options seem to have helped you identify
    the issue, which shouldn''t happen often if done well, you can leverage the expertise
    of Azure support to help you with an issue, by creating a New support request
    in the left panel of your App Service, as shown here:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新建支持请求**：如果这些选项似乎都没有帮助您识别问题，这在操作得当的情况下不应该经常发生，您可以通过在您的应用服务左侧面板中创建一个新的支持请求来利用Azure支持的专业知识来帮助您解决问题，如图所示：'
- en: '![](img/91bb1d5d-6ef3-4a0e-9f3a-e19c0becbe55.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91bb1d5d-6ef3-4a0e-9f3a-e19c0becbe55.png)'
- en: Next, let's have a quick look at a new experimental project of the ASP.NET team
    called Blazor.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们快速了解一下 ASP.NET 团队的一个新实验性项目，名为 Blazor。
- en: Introducing Blazor
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Blazor
- en: Blazor is a new experiment by the ASP.NET team. Blazor got its name from two
    words, Browser and Razor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 是 ASP.NET 团队的一个新实验。Blazor 的名字来源于两个词，Browser 和 Razor。
- en: Blazor is an experimental web UI framework using C#, Razor, and HTML, running
    in the browser through WebAssembly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 是一个使用 C#、Razor 和 HTML 的实验性 Web UI 框架，通过 WebAssembly 在浏览器中运行。
- en: What is WebAssembly? **WebAssembly** or **wasm** is an open, new-age format
    standard, with an initial version that has reportedly reached cross-browser consensus.
    It is described as *a new portable, size-and load-time-efficient format suitable
    for compilation to the Web.* WebAssembly is a new type of code that can be run
    in modern web browsers. It is a low-level assembly-like language with a compact
    binary format that runs with near-native performance and provides languages, such
    as C/C++, with a compilation target so that they can run on the web. It is also
    designed to run alongside JavaScript, allowing both to work together. It is a
    browser improvement. Since it is a binary format, we'll be able to compile binary
    bundles that compress to a smaller size than the text JavaScript. Smaller payloads
    means faster delivery and so it may run faster than JavaScript.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 WebAssembly？**WebAssembly** 或 **wasm** 是一种开放的新时代格式标准，其初始版本据报道已达到跨浏览器的共识。它被描述为**一种新的便携式、大小和加载时间高效的格式，适合编译到
    Web 中**。WebAssembly 是一种可以在现代网络浏览器中运行的新类型代码。它是一种类似于汇编的低级语言，具有紧凑的二进制格式，以接近原生的性能运行，并为
    C/C++ 等语言提供编译目标，以便它们可以在 Web 上运行。它还设计为与 JavaScript 一起运行，允许两者协同工作。它是一种浏览器改进。由于它是一种二进制格式，我们将能够编译比文本
    JavaScript 更小的二进制包。更小的负载意味着更快的交付，因此它可能比 JavaScript 运行得更快。
- en: Blazor runs .NET code in the browser via a small, portable .NET runtime called
    **DotNetAnywhere** (**DNA**) compiled to WebAssembly. Essentially, Blazor makes
    life easier and happier for developers like me who are not great at JavaScript
    and want to write less of it. You can code your entire app in C#, Razor, and HTML,
    which runs inside the browser, without having to write a single line of JavaScript
    and it works just like any **Single-Page Application** (**SPA**). It gives all
    the benefits of a rich and modern platform while letting us use .NET end to end.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 通过一个名为 **DotNetAnywhere** （**DNA**）的小型、便携式 .NET 运行时在浏览器中运行 .NET 代码，该运行时被编译为
    WebAssembly。本质上，Blazor 让像我这样的开发者（不擅长 JavaScript）的生活变得更简单、更快乐。您可以使用 C#、Razor 和
    HTML 编写整个应用程序，它将在浏览器内部运行，无需编写任何 JavaScript 代码，并且它的工作方式就像任何 **单页应用程序** （**SPA**）
    一样。它提供了丰富和现代平台的所有好处，同时让我们能够端到端地使用 .NET。
- en: Blazor is developed as a personal project by Steve Sanderson, who is part of
    the ASP.NET team and works out of the UK. He has a detailed blog which talks about
    it and how it works. It can be read at [http://blog.stevensanderson.com/2018/02/06/blazor-intro/](http://blog.stevensanderson.com/2018/02/06/blazor-intro/).[](http://blog.stevensanderson.com/2018/02/06/blazor-intro/)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 是由 ASP.NET 团队的 Steve Sanderson 开发的个人项目，他是 ASP.NET 团队的一员，在英国工作。他有一个详细的博客，其中讨论了它的工作原理。可以在
    [http://blog.stevensanderson.com/2018/02/06/blazor-intro/](http://blog.stevensanderson.com/2018/02/06/blazor-intro/)
    上阅读。[http://blog.stevensanderson.com/2018/02/06/blazor-intro/](http://blog.stevensanderson.com/2018/02/06/blazor-intro/)
- en: Other blogs providing great insights into Blazor can be read at [https://visualstudiomagazine.com](https://visualstudiomagazine.com/articles/2017/08/09/blazor.aspx).[/articles/2017/08/09/blazor.aspx](https://visualstudiomagazine.com/articles/2017/08/09/blazor.aspx)
    and [https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/](https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/).[](https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其他提供关于 Blazor 深刻见解的博客可以在 [https://visualstudiomagazine.com](https://visualstudiomagazine.com/articles/2017/08/09/blazor.aspx)
    和 [https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/](https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/)
    上阅读。[https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/](https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/)
- en: The demo of Blazor can be seen at [https://blazor-demo.github.io/](https://blazor-demo.github.io/).[](https://blazor-demo.github.io/)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 的演示可以在 [https://blazor-demo.github.io/](https://blazor-demo.github.io/)
    上看到。[https://blazor-demo.github.io/](https://blazor-demo.github.io/)
- en: If this sounds exciting, there is even more exciting stuff in the upcoming 2.1
    release of ASP.NET Core. Let's have a sneak peek at it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很令人兴奋，那么在即将到来的 ASP.NET Core 2.1 版本中还有更多令人兴奋的内容。让我们先睹为快。
- en: What's coming in .NET Core 2.1
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 2.1即将推出
- en: The preview version of .NET Core 2.1 is launched on February 27th 2018\. We
    can start developing a .NET Core 2.1 application using Visual Studio 2017 15.6
    Preview 6 or later, and also using Visual Studio Code. Let's see what is newly
    added to .NET Core 2.1.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.1的预览版本于2018年2月27日发布。我们可以开始使用Visual Studio 2017 15.6 Preview 6或更高版本以及Visual
    Studio Code来开发.NET Core 2.1应用程序。让我们看看.NET Core 2.1中新增了哪些内容。
- en: '**Build performance:** In .NET Core 2.1, build time performance has improved.
    CLI tools and MSBuild have improved and are much faster than before.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建性能**：在.NET Core 2.1中，构建时间性能得到了提升。CLI工具和MSBuild得到了改进，比之前快得多。'
- en: '**Minor version roll forward:** We can run the .NET Core X.x application on
    later minor versions with the same major version range, such as .NET Core 2.1
    applications on .NET Core 2.6\. This roll forward feature is applicable to minor
    versions only, so 2.1 can''t be automatically rolled forward to .NET Core 3.0,
    or any other major version. Roll forward behavior is only relevant when the expected
    .NET Core version is not present in the given environment. We can disable this
    feature using:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要版本滚动前进**：我们可以将.NET Core X.x应用程序运行在相同主版本范围内的后续次要版本上，例如.NET Core 2.1应用程序在.NET
    Core 2.6上。此滚动前进功能仅适用于次要版本，因此2.1不能自动滚动到.NET Core 3.0或任何其他主版本。滚动前进行为仅在预期的.NET Core版本不在给定环境中时才相关。我们可以使用以下方式禁用此功能：'
- en: '**Environment variable**: `DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX=0`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：`DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX=0`'
- en: '**runtimeconfig.json**: `rollForwardOnNoCandidateFx=0`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runtimeconfig.json**：`rollForwardOnNoCandidateFx=0`'
- en: '**CLI**: `roll-forward-on-no-candidate-fx=0`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLI**：`roll-forward-on-no-candidate-fx=0`'
- en: '**Sockets performance and HTTP managed handler:** As part of the new version,
    socket performance has increased. Sockets are the basis of outgoing and incoming
    network communication. In .NET Core 2.0 ASP.NET, the Kestrel web server and `HttpClient`
    use native `Socket` not the .NET `Socket` class. There will be three significant
    performance improvements for sockets. It supports `Span<T>` and `Memory<T>` in
    `Socket` and `NetworkStream`. `SocketHttpHandler` performance has improved. A
    few benefits are:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字性能和HTTP管理处理程序：** 作为新版本的一部分，套接字性能得到了提升。套接字是出站和入站网络通信的基础。在.NET Core 2.0
    ASP.NET中，Kestrel网络服务器和`HttpClient`使用原生`Socket`而不是.NET的`Socket`类。套接字将有三项重要的性能改进。它支持`Span<T>`和`Memory<T>`在`Socket`和`NetworkStream`中。`SocketHttpHandler`性能得到了提升。一些好处包括：'
- en: Platform dependencies have been eliminated on libcurl (linux) and WinHTTP (Windows)—this
    simplifies both development, deployment, and servicing
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台依赖性已在libcurl（linux）和WinHTTP（Windows）上消除——这简化了开发、部署和服务
- en: Consistent behavior across all platforms and platform/dependency versions
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有平台和平台/依赖版本之间的一致行为
- en: 'We can opt in to using the `SocketHTTPHandler` in one of the following ways
    with Preview 1:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式之一在Preview 1中启用使用`SocketHTTPHandler`：
- en: '**Environment variable**: `COMPlus_UseManagedHttpClientHandler=true`'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：`COMPlus_UseManagedHttpClientHandler=true`'
- en: '**AppContext**: `System.Net.Http.UseManagedHttpClientHandler=true`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AppContext**：`System.Net.Http.UseManagedHttpClientHandler=true`'
- en: '**Span<T>**, **Memory<T>:** New types are introduced for using arrays and for
    other types of memory, which is efficient and increases performance. Using `Span`,
    we can pass a subset of an array, for example 5 elements of a 100 element array,
    we can create a `Span<T>` which provides a virtual of that array, without time
    or space cost. Now, no need to make a copy of those five arrays. This is also
    `struct`, so no allocation cost. With slicing capabilities, it obviates the need
    for expensive copying and allocation in many cases, such as string manipulation
    buffer management and so on. Here is an example of creating `Span<T>` from an
    array:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Span<T>**，**Memory<T>**：引入了新的类型来使用数组和其他类型的内存，这既高效又提高了性能。使用`Span`，我们可以传递数组的子集，例如一个100元素数组中的5个元素，我们可以创建一个`Span<T>`，它提供了该数组的虚拟表示，而不需要时间和空间成本。现在，不需要复制这五个数组。这也是`struct`，所以没有分配成本。通过切片功能，它消除了在许多情况下进行昂贵复制和分配的需要，例如字符串操作缓冲区管理等等。以下是从数组创建`Span<T>`的示例：'
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From there, we can easily and efficiently create a `Span` to represent/point
    to just a subset of this array, utilizing an overload of the span’s `Slice` method.
    From there, you can index into the resulting span to write and read data in the
    relevant portion of the original array:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以轻松高效地创建一个`Span`来表示/指向这个数组的子集，利用span的`Slice`方法的重载。从那里，你可以索引到结果span，在原始数组的相应部分写入和读取数据：
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Windows Compatibility Pack:** When we port existing code from the .NET Framework
    to .NET Core, we can use the [new Windows Compatibility Pack](https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack-for-net-core/).
    It provides access additional 20,000 APIs, compared to what is available in .NET
    Core. This includes `System.Drawing`, EventLog, WMI, Performance Counters, and
    Windows Services. The following example illustrates accessing the Window registry
    with APIs provided by the Windows Compatibility Pack. The sample fetches the value
    of `TechnicalEditor` of book `NetCore2ByExample` from `CurrentUser` registry hive:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 兼容包**：当我们从 .NET Framework 将现有代码移植到 .NET Core 时，我们可以使用 [新的 Windows
    兼容包](https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack-for-net-core/)。它提供了额外的
    20,000 个 API，比 .NET Core 中可用的 API 更多。这包括 `System.Drawing`、EventLog、WMI、性能计数器和
    Windows 服务。以下示例展示了如何使用 Windows 兼容包提供的 API 访问窗口注册表。该示例从 `CurrentUser` 注册表分页中获取书籍
    `NetCore2ByExample` 的 `TechnicalEditor` 的值：'
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To learn more about .NET Core 2.1 features, please visit the following resources:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于 .NET Core 2.1 特性的信息，请访问以下资源：
- en: '[https://blogs.msdn.microsoft.com/webdev/2018/02/02/asp-net-core-2-1-roadmap/](https://blogs.msdn.microsoft.com/webdev/2018/02/02/asp-net-core-2-1-roadmap/)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/webdev/2018/02/02/asp-net-core-2-1-roadmap/](https://blogs.msdn.microsoft.com/webdev/2018/02/02/asp-net-core-2-1-roadmap/)'
- en: '[https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md)'
- en: With this, we conclude the chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们结束了本章的内容。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got an overview of microservice architecture how it is an
    extension of SOA and overcomes the limitations of traditional monolithic apps.
    We also learned the important architectural differences between ASP.NET and ASP.NET
    Core. We discussed a few tips to keep in mind while developing ASP.NET Core 2.0
    applications, due to the architectural differences. We then discussed a few handy
    tips to improve the performance of ASP.NET Core apps. We discussed a few tips
    on Azure as well and then moved our discussion to the new experimental project
    of the ASP.NET Core team, called Blazor. We concluded the chapter with a discussion
    on the features that are coming in ASP.NET Core 2.1\. In the next and final chapter
    of the book, we will discuss functional programming with F#.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了微服务架构，它如何是 SOA 的扩展并克服了传统单体应用的局限性。我们还学习了 ASP.NET 和 ASP.NET Core 之间的重要架构差异。由于架构差异，我们讨论了一些在开发
    ASP.NET Core 2.0 应用时需要记住的技巧。然后我们讨论了一些提高 ASP.NET Core 应用性能的实用技巧。我们还讨论了关于 Azure
    的几个技巧，然后转向 ASP.NET Core 团队的新实验性项目，称为 Blazor。我们通过讨论即将在 ASP.NET Core 2.1 中出现的功能来结束本章。在本书的下一章和最后一章中，我们将讨论使用
    F# 的函数式编程。
