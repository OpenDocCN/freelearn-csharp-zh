- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration with the Data Access Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about some basic ways to add a data access layer
    to the minimal APIs in .NET 6.0\. We will see how we can use some topics covered
    previously in the book to access data with **Entity Framework** (**EF**) and then
    with Dapper. These are two ways to access a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Entity Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Dapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use EF from scratch in a minimal
    API project, and use Dapper for the same goal. You will also be able to tell when
    one approach is better than the other in a project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need to create an ASP.NET Core
    6.0 Web API application. You can use either of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **New Project** option in the **File** menu of Visual Studio 2022,
    then choose the **ASP.NET Core Web API** template, select a name and the working
    directory in the wizard, and be sure to uncheck the **Use controllers** option
    in the next step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open your console, shell, or Bash terminal, and change to your working directory.
    Use the following command to create a new Web API application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the project in Visual Studio by double-clicking on the project file
    or, in Visual Studio Code, type the following command in the already open console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can safely remove all the code related to the `WeatherForecast`
    sample, as we don’t need it for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter07](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Using Entity Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can absolutely say that if we are building an API, it is very likely that
    we will interact with data.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this data most probably needs to be persisted after the application
    restarts or after other events, such as a new deployment of the application. There
    are many options for persisting data in .NET applications, but EF is the most
    user-friendly and common solution for a lot of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity Framework Core** (**EF Core**) is an extensible, open source, and
    cross-platform data access library for .NET applications. It enables developers
    to work with the database by using .NET objects directly and removes, in most
    cases, the need to know how to write the data access code directly in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, EF Core supports a lot of databases, including SQLite, MySQL,
    Oracle, Microsoft SQL Server, and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it supports an in-memory database that helps to write tests for
    our applications or to make the development cycle easier because you don’t need
    a real database up and running.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to set up a project for using EF and its
    main features.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the project root, create an `Icecream.cs` class and give it the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Icecream` class is an object that represents an ice cream in our project.
    This class should be called a data model, and we will use this object in the next
    sections of this chapter to map it to a database table.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to add the EF Core NuGet reference to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, you can use one of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new terminal window, enter the following code to add the EF Core `InMemory`
    package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you would like to use Visual Studio 2022 to add the reference, right-click
    on `Microsoft.EntityFrameworkCore.InMemory` and install the package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will be adding EF Core to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding EF Core to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to store the ice cream objects in the database, we need to set up EF
    Core in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up an in-memory database, add the following code to the bottom of the
    `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`DbContext` object represents a connection to the database, and it’s used to
    save and query instances of entities in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: The `DbSet` represents the instances of the entities, and they will be converted
    into a real table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will have just one table in the database, called `Icecreams`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, after the builder initialization, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to add some API endpoints to start interacting with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding endpoints to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add the code to create a new item in the `icecreams` list. In `Program.cs`,
    add the following code before the `app.Run()` line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the `MapPost` function is the DbContext. By default,
    the minimal API architecture uses dependency injection to share the instances
    of the DbContext.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know more about dependency injection, go to [*Chapter 4*](B17902_04.xhtml#_idTextAnchor061)*,
    Dependency Injection in a Minimal API Project*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to save an item into the database, we use the `AddSync` method directly
    from the entity that represents the object.
  prefs: []
  type: TYPE_NORMAL
- en: To persist the new item in the database, we need to call the `SaveChangesAsync()`
    method, which is responsible for saving all the changes that happen to the database
    before the last call to `SaveChangesAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: In a very similar way, we can add the endpoint to retrieve all the items in
    the `icecreams` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the code to add an ice cream, we can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Also, in this case, the DbContext is available as a parameter and we can retrieve
    all the items in the database directly from the entities in the DbContext.
  prefs: []
  type: TYPE_NORMAL
- en: With the `ToListAsync()` method, the application loads all the entities in the
    database and sends them back as the endpoint result.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have saved all your changes in the project and run the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new browser window will open, and you can navigate to the `/swagger` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Swagger browser window ](img/Figure_7.01_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Swagger browser window
  prefs: []
  type: TYPE_NORMAL
- en: Select the **POST/icecreams** button, followed by **Try it out**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the request body content with the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on **Execute**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Swagger response ](img/Figure_7.02_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Swagger response
  prefs: []
  type: TYPE_NORMAL
- en: Now we have at least one item in the database, and we can try the other endpoint
    to retrieve all the items in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll down the page a little bit and select **GET/icecreams**, followed by
    **Try it out** and then **Execute**.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the list with one item under **Response Body**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to finalize this first demo by adding the other CRUD operations
    to our endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an item by ID, add the following code under the `app.MapGet` route you
    created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To check this out, you can launch the application again and use the Swagger
    UI as before.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add an item in the database by performing a post call (as in the previous
    section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **GET/icecreams/{id)** followed by **Try it out**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the value `1` in the `id` parameter field and then click on **Execute**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see the item in the **Response Body** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is an example of a response from the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what the response looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Response result ](img/Figure_7.03_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Response result
  prefs: []
  type: TYPE_NORMAL
- en: 'To update an item by ID, we can create a new `MapPut` endpoint with two parameters:
    the item with the entity values and the ID of the old entity in the database that
    we want to update.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code should be like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Just to be clear, first of all, we need to find the item in the database with
    the ID from the parameters. If we don’t find an item in the database, it’s a good
    practice to return a `Not Found` HTTP status to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: If we find the entity in the database, we update the entity with the new values
    and we save all the changes in the database before sending back the HTTP status
    `No Content`.
  prefs: []
  type: TYPE_NORMAL
- en: The last CRUD operation we need to perform is to delete an item from the database.
  prefs: []
  type: TYPE_NORMAL
- en: This operation is very similar to the update operation because, first of all,
    we need to find the item in the database and then we can try to perform the delete
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to implement a delete operation with the
    right HTTP verb of the minimal API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have learned how to use EF in a minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to add the NuGet packages to start working with EF, and how to implement
    the entire set of CRUD operations in a minimal API .NET 6 project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to implement the same project with the
    same logic but using Dapper as the primary library to access data.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dapper is an `IDbConnection` object and provides a lot of methods to query the
    database. This means we have to write queries that are compatible with the database
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'It supports synchronous and asynchronous method executions. This is a list
    of the methods that Dapper adds to the `IDbConnection` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Execute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Query`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryFirst`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryFirstOrDefault`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuerySingle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuerySingleOrDefault`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryMultiple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned, it provides an async version for all these methods. You can
    find the right methods by adding the `Async` keyword at the end of the method
    name.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to set up a project for using Dapper with
    a SQL Server LocalDB.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we are going to do is to create a new database. You can use
    your SQL Server LocalDB instance installed with Visual Studio by default or another
    SQL Server instance in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute the following script in your database to create one table and
    populate it with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the database, we can install these NuGet packages with the following
    command in the Visual Studio terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we can continue to add the code to interact with the database. In this example,
    we are going to use a repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to create a simple repository pattern, but we
    will try to make it as simple as possible so we can understand the main features
    of Dapper:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add a simple class that represents our entity in
    the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, modify the `appsettings.json` file by adding the connection string
    at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using LocalDB, the connection string should be the right one for
    your environment as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class in the root of the project called `DapperContext` and give
    it the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We injected with dependency injection the `IConfiguration` interface to retrieve
    the connection string from the settings file.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to create the interface and the implementation of our repository.
    In order to do that, add the following code to the `Program.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next sections, we will be adding some code to the interface and to the
    implementation of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can register the context, the interface, and its implementation
    as a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put the following code after the builder initialization in the `Program.cs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we are ready to implement the first query.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dapper to query the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let’s modify the `IIcecreamsRepository` interface by adding a
    new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s implement this method in the `IcecreamsRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try to understand all the steps in this method. We created a string called
    `query`, where we store the SQL query to fetch all the entities from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside the `using` statement, we used `DapperContext` to create the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Once the connection was created, we used it to call the `QueryAsync` method
    and passed the query as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper, when the results return from the database, converted them into `IEnumerable<T>`
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the final code of the interface and our first implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will see how to add a new entity to the database and
    how to use the `ExecuteAsync` method to run a query.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new entity in the database with Dapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we are going to manage adding a new entity to the database for future implementations
    of the API post request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the interface by adding a new method called `CreateIcecream` with
    an input parameter of the `Icecream` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we must implement this method in the repository class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create the query and a dynamic parameters object to pass all the values
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: We populate the parameters with the values from the `Icecream` object in the
    method parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We create the connection with the Dapper context and then we use the `ExecuteAsync`
    method to execute the `INSERT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: This method returns an integer value as a result, representing the number of
    affected rows in the database. In this case, we don’t use this information, but
    you can return this value as the result of the method if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository in the endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the final touch to our minimal API, we need to implement the two endpoints
    to manage all the methods in our repository pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In both map methods, we pass the repository as a parameter because, as usual
    in the minimal API, the services are passed as parameters in the map methods.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the repository is always available in all parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MapGet` endpoint, we use the repository to load all the entities from
    the implementation of the repository and we use the result as the result of the
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MapPost` endpoint, in addition to the repository parameter, we accept
    also the `Icecream` entity from the body of the request and we use the same entity
    as a parameter to the `CreateIcecream` method of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to interact with a data access layer in a minimal
    API project with the two most common tools in a real-world scenario: EF and Dapper.'
  prefs: []
  type: TYPE_NORMAL
- en: For EF, we covered some basic features, such as setting up a project to use
    this ORM and how to perform some basic operations to implement a full CRUD API
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We did basically the same thing with Dapper as well, starting from an empty
    project, adding Dapper, setting up the project for working with a SQL Server LocalDB,
    and implementing some basic interactions with the entities of the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll focus on authentication and authorization in a minimal
    API project. It’s important, first of all, to protect your data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Development and Microservices Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this advanced section of the book, we want to show more scenarios that are
    typical in backend development. We will also go over the performance of this new
    framework and understand the scenarios in which it is really useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following chapters in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17902_08.xhtml#_idTextAnchor109), *Adding Authentication and
    Authorization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B17902_09.xhtml#_idTextAnchor125), *Leveraging Globalization
    and Localization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B17902_10.xhtml#_idTextAnchor140), *Evaluating and Benchmarking
    the Performance of Minimal APIs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
