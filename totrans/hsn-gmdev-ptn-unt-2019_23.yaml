- en: Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: I was introduced to the **Dependency Injection** (**DI**) pattern when I was
    working as a web developer, and I've been using it for years. However, I have
    noticed that DI is not well-known in the gaming industry. I suspect this is because
    it's a pattern that was developed to resolve design issues in business-oriented
    applications, and not for high-performance software such as video games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我作为一名网页开发者工作时，我第一次接触到了 **依赖注入**（**DI**）模式，并且我已经使用了多年。然而，我注意到 DI 在游戏行业中并不为人所知。我怀疑这是因为这是一个为了解决面向业务应用程序的设计问题而开发的模式，而不是用于高性能软件，如视频游戏。
- en: As its names implies, DI is about injecting dependencies; it might sound abstract
    at first, but it's a quite simple concept. Classes often need instances of other
    classes to complete specific functions. So instead of having a class initialize
    its own dependencies, we inject them through its constructor or a parameter in
    one of its functions. This approach decouples the explicit relationships between
    classes, and it makes it easier to test our code, because we can easily inject
    mock objects that execute unit tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所暗示的，DI 是关于注入依赖项的；一开始可能听起来有些抽象，但它是一个相当简单的概念。类通常需要其他类的实例来完成特定的功能。因此，而不是让类自己初始化其依赖项，我们通过其构造函数或其函数中的一个参数来注入它们。这种方法解耦了类之间的显式关系，并使得测试我们的代码变得更容易，因为我们可以轻松地注入模拟对象来执行单元测试。
- en: As you will see in this book, DI has its limitations, and it is not necessarily
    compatible with Unity's programming environment. This will become especially clear
    when you start to introduce more advanced versions of DI, in the form of** Inversion
    of Control** (**IoC**) containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书中将会看到的，DI 有其局限性，并且它不一定与 Unity 的编程环境兼容。当你开始引入更高级的 DI 版本，即 **控制反转**（**IoC**）容器时，这一点将变得特别明显。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: We will review the fundamentals of the DI pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾 DI 模式的 fundamentals
- en: We will explore the core concepts behind IoC containers and how they relate
    to DI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨 IoC 容器背后的核心概念以及它们与 DI 的关系
- en: We will resolve a dependency issue prompted by the implementation of a feature
    that permits customizing the initial configurations of a superbike for a racing
    game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将解决由允许自定义赛车游戏中的超级摩托车初始配置的功能实现引起的依赖项问题
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following chapter is hands-on; you will need to have a basic understanding
    of Unity and C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是实践性的；你需要对 Unity 和 C# 有基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的 Unity 引擎和 C# 语言概念：
- en: Interfaces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Constructors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: If you are unfamiliar with these concepts, please review them before moving
    forward.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请在继续之前先复习它们。
- en: 'The code files from this chapter can be found on GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[http://bit.ly/2Oww7WM](http://bit.ly/2Oww7WM)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Oww7WM](http://bit.ly/2Oww7WM)'
- en: An overview of Dependency Injection
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入概述
- en: 'As its name implies, the DI pattern''s core purpose is to inject dependencies
    into the classes that need them. There are three ways to achieving this with DI,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所暗示的，DI 模式的核心目的是将依赖项注入需要它们的类中。使用 DI 实现这一点有三种方法，如下所示：
- en: '**Constructor injection**: We inject dependencies through a class''s constructor.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数注入**：我们通过类的构造函数注入依赖项。'
- en: '**Setter injection**: We inject dependencies through a class''s function parameters.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器注入**：我们通过类的函数参数注入依赖项。'
- en: '**Interface injection**: The dependency''s interface offers an injector method
    to pass a dependency to a client.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口注入**：依赖项的接口提供了一个注入方法，将依赖项传递给客户端。'
- en: In this chapter, we will only review the constructor and setter techniques,
    because they are the most common.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只将回顾构造函数和设置器技术，因为它们是最常见的。
- en: Dependencies are usually classes that offer a particular service that other
    classes can utilize to complete specific functions. A classic example is a manager
    class that is responsible for establishing a connection to a database to execute
    queries. To fulfill this responsibility, the database manager is dependent on
    vendor-specific classes that act as interfaces to certain types of databases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖通常是提供特定服务的类，其他类可以利用这些服务来完成特定功能。一个经典的例子是负责建立数据库连接以执行查询的管理器类。为了履行这一职责，数据库管理器依赖于特定数据库类型的接口类。
- en: To avoid having the database manager retrieve and initialize a specific dependency
    every time it needs to connect to a particular type of database, we could provide
    them by injecting them when needed. In other words, we are decoupling the relationship
    between the dependent and its dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据库管理器每次需要连接到特定类型的数据库时都检索和初始化特定的依赖项，我们可以在需要时提供它们。换句话说，我们正在解耦依赖与其依赖项之间的关系。
- en: 'A UML diagram is not the best tool to describe the purposes of a DI pattern,
    but let''s review a simplified diagram that outlines what we are going to implement
    as our use case:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: UML 图并不是描述 DI 模式目的的最佳工具，但让我们回顾一个简化的图，概述我们将要实现作为用例的内容：
- en: '![](img/a8371126-f7a1-436c-a544-971e5cbe2c5a.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8371126-f7a1-436c-a544-971e5cbe2c5a.png)'
- en: The case presented in the preceding diagram is similar to the database manager
    example that we just examined. We have a class named `Bike` that needs an engine
    to run correctly. Instead of having the `Bike` class initialize a specific type
    of engine depending on a particular condition, we made it accept a parameter of
    the `IEngine` type in its constructor. With this approach, we can have `Bike`
    receive any concrete class that implements `IEngine`, like in this example, with `JetEngine`
    and `NitroEngine`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个图中展示的案例与我们所讨论的数据库管理器示例类似。我们有一个名为 `Bike` 的类，它需要一个引擎才能正常运行。我们不是让 `Bike` 类根据特定条件初始化特定类型的引擎，而是在其构造函数中接受
    `IEngine` 类型的参数。采用这种方法，`Bike` 可以接收任何实现了 `IEngine` 的具体类，例如在这个例子中，是 `JetEngine`
    和 `NitroEngine`。
- en: This arrangement provides us with a lot of extensibility; we could write dozens
    of different types of engines, each with their particular features, and the `Bike`
    would be able to accept them without any modification to its current structure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排为我们提供了大量的可扩展性；我们可以编写几十种不同类型的引擎，每种都有其特定的功能，而 `Bike` 能够接受它们，而无需对其当前结构进行任何修改。
- en: But of course, DI is not without its drawbacks, as you are going to see in the
    next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，DI 并非没有缺点，你将在下一节中看到。
- en: DI follows the core principals of IoC, which is about inverting the flow control
    of a system. In the case of DI, it's about inverting the process of dependency
    management. Another pattern that follows IoC principals is the service locator,
    which you can review in [Chapter 16](56a2aeed-924d-4d95-b44b-b10ac7595d4a.xhtml),
    *Service Locator*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: DI 遵循 IoC 的核心原则，即反转系统的控制流。在 DI 的情况下，这是关于反转依赖管理的过程。遵循 IoC 原则的另一个模式是服务定位器，你可以在第
    16 章[服务定位器](56a2aeed-924d-4d95-b44b-b10ac7595d4a.xhtml)中查阅。
- en: Benefits and drawbacks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: Like the Singleton pattern, the DI pattern is somewhat controversial, and its
    actual benefits and drawbacks are often contested. I suspect this is because its
    design is straightforward and programmers tend to be cautious of anything that
    looks too simple, because it's usually too good to be true.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与单例模式一样，DI 模式也有些争议，其实际的优缺点经常受到争议。我怀疑这是因为其设计简单，程序员往往对看起来过于简单的东西持谨慎态度，因为通常太好了而不可能是真的。
- en: 'The benefits are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: '**Loose coupling**: Having classes receive instances to dependencies instead
    of explicitly initializing them can reduce tight coupling in a code base.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松散耦合**：让类接收依赖实例而不是显式初始化它们，可以减少代码库中的紧密耦合。'
- en: '**Testable code**: DI makes it easier to run tests by making it possible to
    inject mock objects that can run specific scenarios.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试的代码**：DI 通过允许注入模拟对象来运行特定场景，使得运行测试变得更加容易。'
- en: '**Concurrent development**: DI offers a way to decouple objects and enforce
    communication through interfaces. This approach makes it easier for a team of
    programmers to write classes that utilize each other.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发开发**：DI 提供了一种解耦对象并强制通过接口进行通信的方法。这种方法使得程序员团队编写相互利用的类变得更加容易。'
- en: 'The drawbacks are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: '**Disputes**: DI is a type of pattern that causes a lot of debates in a team,
    because the best approach is not always clear, especially when a more advanced
    form of DI is considered, such as the use of IoC injection containers.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**争议**：DI是一种在团队中引起很多争论的模式，因为最佳方法并不总是清晰的，尤其是在考虑更高级的DI形式，如IoC注入容器时。'
- en: '**Framework dependency**: The basic form of DI is very limited; once a certain
    degree of complexity is achieved, it becomes necessary to implement a third-party
    IoC framework to manage the injection of dependencies in a configurable manner.
    As a consequence, the code base often becomes dependent on the framework and cannot
    be easily removed.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架依赖**：DI的基本形式非常有限；一旦达到一定程度的复杂性，就必需实现第三方IoC框架以可配置的方式管理依赖注入。因此，代码库通常变得依赖于框架，并且难以轻易移除。'
- en: '**Ravioli code**: Overzealous use of DI and related best practices can result
    in a code base that''s overly encapsulated and broken up into too many individual
    classes, making it difficult to understand.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意大利面代码**：过度使用依赖注入（DI）和相关最佳实践可能导致代码库过度封装，并拆分成过多的单个类，这使得理解起来变得困难。'
- en: To test a candidate's ability to debate technical subject matters, interviewers
    often ask a candidate to give an opinion on a controversial pattern, such as DI
    and Singleton. It's a good practice, as an interviewee, to showcase a balanced
    view on any issue by taking into account the benefits and drawbacks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应聘者对技术主题的辩论能力，面试官通常会要求应聘者对一个有争议的模式，如DI和Singleton，提出自己的看法。作为一个面试者，展示对任何问题的平衡观点，考虑到其优点和缺点，是一种良好的做法。
- en: Use case example
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: 'Let''s suppose that we are working on a racing game set in the future, with
    superbikes. We have to implement a feature quickly, in which a player can customize
    their bike by choosing an engine and driver from a list of available options before
    starting a race. In other words, our bike object has two specific dependencies:
    an engine and a driver. Using the DI pattern, we are going to manage these dependencies
    without adding unnecessary complexity to our code base.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个设定在未来的赛车游戏，其中有超级摩托车。我们必须快速实现一个功能，玩家可以在比赛开始前从可用选项中选择引擎和驾驶员来自定义他们的自行车。换句话说，我们的自行车对象有两个特定的依赖项：一个引擎和一个驾驶员。使用DI模式，我们将管理这些依赖项，而不会给我们的代码库增加不必要的复杂性。
- en: First, we are going to look at the incorrect way to manage dependencies in a
    class so that you can understand the benefits of DI in contrast to the opposite
    approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看在类中管理依赖关系的错误方法，以便您能够理解与相反方法相比DI的优点。
- en: The wrong way, without DI
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有DI的错误方法
- en: 'Before going into the implementation phase of our use case, let''s first review
    an example of a class that uses an ill-considered way of initializing and managing
    its dependencies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入我们用例的实现阶段之前，让我们首先回顾一个使用考虑不周的初始化和管理依赖关系的类的示例：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At first glance, this might seem like a reasonable approach, but let's imagine
    that we are working in a team of game programmers and each is implementing new
    types of engine behaviors. If we want our `Bike` class to support them, we will
    need to modify the `EngineType` enum and also update the `switch` case inside
    the body of the `SetEgnine()` method. This approach can become very bothersome
    over time if multiple programmers are working on the class at the same time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这似乎是一种合理的做法，但让我们想象一下，我们正在一个游戏程序员团队中工作，每个人都在实现新的引擎行为类型。如果我们想让`Bike`类支持这些行为，我们需要修改`EngineType`枚举，并更新`SetEngine()`方法体内的`switch`案例。如果多个程序员同时在这个类上工作，这种方法可能会随着时间的推移变得非常麻烦。
- en: We are having the same issue with the `SetDriver()` function; with this arrangement,
    adding new types of drivers will become a choir and will probably be prone to
    errors. So let's implement the same class in a step-by-step approach by using
    DI as our foundation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SetDriver()`函数上也遇到了同样的问题；在这种安排下，添加新的驾驶员类型将变得很麻烦，并且可能会容易出错。所以，让我们通过逐步使用DI作为基础来实现相同的类。
- en: The right way with DI
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DI的正确方法
- en: 'The implementation of DI is quite straightforward, and that''s probably its
    main benefit. So, this section should be painless:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: DI的实现相当直接，这也是它的主要优点。因此，本节应该不会令人痛苦：
- en: 'Let''s start by writing our `Bike` class; we could say that it''s the actual
    client in this DI pattern example, mainly because it''s the class that''s dependent
    on receiving dependencies during the injection process:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编写我们的 `Bike` 类开始；我们可以说它是这个依赖注入（DI）模式示例中的实际客户端，主要是因为它是那个在注入过程中依赖接收依赖项的类：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `SetEngine()` and `SetDriver()` functions are not aware
    of what specific engine or driver they are receiving—only that they expect a generic
    type of them. In other words, the `Bike` class is no longer responsible for the
    initialization process of its dependencies. This approach is very flexible; we
    could write an infinite number of engine classes, each with their own specific
    behaviors, and if we stayed consistent with the implementation contract of the
    `IEngine` interface, we wouldn't need to modify the `Bike` class directly for
    it to be suitable to use new engines.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`SetEngine()` 和 `SetDriver()` 函数并不知道它们接收到的具体是哪种引擎或驱动器——它们只知道它们期望的是它们的通用类型。换句话说，`Bike`
    类不再负责其依赖项的初始化过程。这种方法非常灵活；我们可以编写无限数量的引擎类，每个类都有其特定的行为，如果我们保持与 `IEngine` 接口实现合同的兼容性，我们就不需要直接修改
    `Bike` 类以使其适合使用新的引擎。
- en: You will also notice that this approach is likewise valid for the `driver` dependency.
    The `Bike` doesn't need to know who the driver is; it just needs to know that
    the entity that's taking control implemented the `IDriver` interface so that they
    could communicate with each other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到这种方法同样适用于 `driver` 依赖项。`Bike` 不需要知道是谁在驾驶；它只需要知道控制该实体的实体实现了 `IDriver` 接口，这样它们就可以相互通信。
- en: For testing purposes, this flexibility is helpful; we could easily inject mock
    `engine` or `driver` objects at runtime and run some automated unit tests on the
    `Bike` implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，这种灵活性很有帮助；我们可以在运行时轻松注入模拟的 `engine` 或 `driver` 对象，并在 `Bike` 实现上运行一些自动化的单元测试。
- en: 'Now, let''s write the interfaces for our two primary types of dependencies:
    engines and drivers:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们两种主要依赖类型的接口：引擎和驱动器：
- en: 'The `IEngine` interface is as follows:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEngine` 接口如下所示：'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `IDriver` interface is as follows:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDriver` 接口如下所示：'
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the following step, we are going to write all of our concrete classes for
    each primary type of component that our bike needs to function correctly:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将为我们的自行车需要正确运行的每种主要类型的组件编写所有具体的类：
- en: 'The `JetEngine` class is as follows:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JetEngine` 类如下所示：'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `NitroEngine` class is as follows:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NitroEngine` 类如下所示：'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's important to note that each engine encapsulates its internal mechanism
    while staying consistent with the implementation of the `IEngine` interface. It's
    this consistent approach that permits DI.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，每个引擎都封装了其内部机制，同时保持与 `IEngine` 接口实现的兼容性。正是这种一致的方法允许了依赖注入（DI）。
- en: 'The `HumanDriver` class is as follows:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HumanDriver` 类如下所示：'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `AndroidDriver` class is as follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidDriver` 类如下所示：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `HumanDriver` class is intended to give control of the `Bike` to a player,
    which we will do in the upcoming `Client` class. The `AndroidDriver` class is
    meant to support an AI entity that could drive the `Bike` and act as a rival to
    the player during a race.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`HumanDriver` 类旨在将 `Bike` 的控制权交给玩家，我们将在即将到来的 `Client` 类中实现这一点。`AndroidDriver`
    类旨在支持一个能够驾驶 `Bike` 并在比赛中作为玩家对手的 AI 实体。'
- en: 'Finally, our `Client` class, which we will use to test our system, is as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的 `Client` 类，我们将用它来测试我们的系统，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our `Client` class is quite straightforward; in the `Awake()` function, we
    inject the dependencies into two instances of a `Bike` class: `m_PlayerBike` and
    `m_AndroidBike`. In the `Update()` function, we listen for a player''s input that
    permits them to control the `m_PlayerBike` instance.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Client` 类相当简单；在 `Awake()` 函数中，我们将依赖项注入到两个 `Bike` 类的实例中：`m_PlayerBike` 和
    `m_AndroidBike`。在 `Update()` 函数中，我们监听玩家的输入，允许他们控制 `m_PlayerBike` 实例。
- en: This might look very straightforward and too simple to be true, but this pattern
    offers a lot of extensibility and flexibility, with little complexity, if used
    in moderation. In the next section, we are going to review a more advanced form
    of DI, which uses IoC containers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常直接且过于简单，但如果我们适度使用，这种模式提供了很多可扩展性和灵活性，同时复杂性很小。在下一节中，我们将回顾依赖注入（DI）的更高级形式，它使用
    IoC 容器。
- en: You may have noticed that we didn't use constructor injection in our code example;
    it's because we were working with a `MonoBehaviour` class, and we don't have access
    to its constructor. Some Unity developers do use the `Awake()` function to inject
    dependencies during the initialization process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有在我们的代码示例中使用构造函数注入；这是因为我们正在使用一个 `MonoBehaviour` 类，我们没有访问其构造函数的权限。一些
    Unity 开发者确实使用 `Awake()` 函数在初始化过程中注入依赖项。
- en: DI with IoC containers
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IoC 容器进行 DI
- en: IoC containers usually come in the form of frameworks; their primary responsibilities
    are to automate the DI process and manage the life space of dependencies. Before
    we start, it's important to note that most IoC containers are not designed to
    be compatible with Unity's coding model, and I don't recommend using them. On
    the other hand, it's important to be aware that they exist.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: IoC 容器通常以框架的形式出现；它们的主要职责是自动化 DI 流程和管理依赖项的生命周期。在我们开始之前，重要的是要注意，大多数 IoC 容器并不是为了与
    Unity 的编码模型兼容而设计的，我不建议使用它们。另一方面，了解它们的存在也很重要。
- en: As we mentioned at the beginning of this chapter, DI is a handy and straightforward
    pattern, but it has its limitations. In the code example that we just implemented,
    we managed the injection of two dependencies at once, but imagine if we had dozens
    of them spread out over multiple classes. In that type of context, DI can become
    a choke point in your architecture. That is when IoC containers become useful,
    because they can automate the process of managing all of those injections.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章开头所述，依赖注入（DI）是一种便捷且直接的模式，但它有其局限性。在我们刚刚实现的代码示例中，我们同时管理了两个依赖项的注入，但想象一下，如果我们有数十个依赖项分布在多个类中会怎样。在这种类型的背景下，DI
    可能会成为你架构中的瓶颈。这时，IoC 容器就变得很有用，因为它们可以自动化管理所有这些注入的过程。
- en: 'The following is a quick summary of the functions that most IoC containers
    offer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对大多数 IoC 容器提供的功能的简要总结：
- en: '**Registration**: The container offers a way to register dependencies and map
    them to the dependents correctly.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册**：容器提供了一种注册依赖项并将它们正确映射到依赖项的方法。'
- en: '**Resolving**: The container takes the responsibility of resolving the dependencies
    by initializing and injecting them.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析**：容器负责通过初始化和注入来解析依赖项。'
- en: '**Disposing**: The container will manage the lifespan of objects, including
    disposing them once they are not needed anymore.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放资源**：容器将管理对象的生命周期，包括在它们不再需要时释放它们。'
- en: The goal of this quick review of the IoC containers is not to debate whether
    they are necessary, but to become aware that the simple version of the DI pattern
    has its limitations. Once we have reached a certain degree of complexity and density
    with regard to the dependencies to inject, we need to consider implement or integrating
    an IoC container framework to manage the process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这份对 IoC 容器的快速回顾的目的不是争论它们是否必要，而是让我们意识到简单的 DI 模式有其局限性。一旦我们在注入的依赖项的复杂性和密度达到一定程度，我们就需要考虑实现或集成一个
    IoC 容器框架来管理这个过程。
- en: Always be cautious about making your code base dependent on third-party frameworks;
    you might find yourself falling into the vendor lock-in anti-pattern, which I
    will describe in more detail in the final chapter of this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总是小心不要让你的代码库依赖于第三方框架；你可能会发现自己陷入了供应商锁定反模式，我将在本书的最后一章中更详细地描述它。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we reviewed the DI pattern, a simple pattern that has grown
    in popularity over the years. Its fame is explainable by the fact that it resolves
    a common challenge that every programmer faces daily, which is the management
    of dependencies between classes. In other words, it's a powerful tool to have
    in your toolkit, as long as you don't abuse it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 DI 模式，这是一个随着时间的推移而越来越受欢迎的简单模式。它的名声可以通过这样一个事实来解释，即它解决了每个程序员每天都会面临的常见挑战，即管理类之间的依赖关系。换句话说，只要你不过度使用，它就是你的工具箱中的一个强大工具。
- en: In the next chapter, we will explore the object pool pattern, another handy
    tool that is very popular with mobile game programmers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨对象池模式，这是移动游戏程序员非常喜欢的另一个实用工具。
- en: Practical exercise
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践练习
- en: As a practical exercise, I recommend writing an application in C# using a popular
    IoC container framework. Because most of them are incompatible with the Unity
    engine, I suggest going native and coding a simple Windows application in Visual
    Studio.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项实际练习，我建议使用一个流行的IoC容器框架编写一个C#应用程序。因为大多数框架与Unity引擎不兼容，我建议使用原生方式，在Visual Studio中编写一个简单的Windows应用程序。
- en: In the *Further reading* section, I have added a list of popular IoC container
    frameworks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *进一步阅读* 部分，我添加了一个流行的IoC容器框架列表。
- en: Further reading
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Some books that may be used as reference are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能用作参考的书籍：
- en: '*Dependency Injection in .NET* by Mark Seemann: [https://www.manning.com/books/dependency-injection-in-dot-net](https://www.manning.com/books/dependency-injection-in-dot-net)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《.NET中的依赖注入》* by Mark Seemann: [https://www.manning.com/books/dependency-injection-in-dot-net](https://www.manning.com/books/dependency-injection-in-dot-net)'
- en: '*Dependency Injection Principles, Practices, and Patterns* by Steven van Deursen
    and Mark Seemann: [https://www.manning.com/books/dependency-injection-principles-practices-patterns](https://www.manning.com/books/dependency-injection-principles-practices-patterns)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《依赖注入原理、实践和模式》* by Steven van Deursen 和 Mark Seemann: [https://www.manning.com/books/dependency-injection-principles-practices-patterns](https://www.manning.com/books/dependency-injection-principles-practices-patterns)'
- en: 'Some IoC frameworks to consider are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以考虑的IoC框架：
- en: Ninject:[http://www.ninject.org](http://www.ninject.org)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ninject:[http://www.ninject.org](http://www.ninject.org)
- en: Castle Windsor:[https://github.com/castleproject/Windsor](https://github.com/castleproject/Windsor)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Castle Windsor:[https://github.com/castleproject/Windsor](https://github.com/castleproject/Windsor)
