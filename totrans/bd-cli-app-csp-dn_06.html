<html><head></head><body>
		<div id="_idContainer089">
			<h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor084"/>6</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor085"/>Error Handling and Logging</h1>
			<p>Logging<a id="_idIndexMarker160"/> and error handling<a id="_idIndexMarker161"/> are two important concepts to consider (and implement) when building any application, and CLI applications are <span class="No-Break">no exceptions.</span></p>
			<p>While error handling ensures graceful behavior of the application in the face of unexpected events, logging provides crucial insights into the applicationâ€™s runtime behavior and facilitates troubleshooting <span class="No-Break">and debugging.</span></p>
			<p>Thatâ€™s why, in this chapter, we will cover these two concepts, starting with <span class="No-Break">error handling.</span></p>
			<p>Specifically, weâ€™ll cover the following main topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Error handling in <span class="No-Break">CLI applications</span></li>
				<li>Logging in <span class="No-Break">CLI applications</span></li>
			</ul>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor087"/>Handling errors in CLI applications</h1>
			<p>Error <a id="_idIndexMarker162"/>handling may take<a id="_idIndexMarker163"/> <span class="No-Break">two forms:</span></p>
			<ul>
				<li>An exception is raised, due to an <a id="_idIndexMarker164"/>unexpected event (such as an invalid input or an <span class="No-Break">inaccessible dependency)</span></li>
				<li>The program is terminated, and we want to prevent it crashing by allowing it to gracefully <span class="No-Break">shut down</span></li>
			</ul>
			<p>In this section, we will cover both topics. Letâ€™s start with <span class="No-Break">exception handling.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor088"/>Handling exceptions</h2>
			<p>There is <a id="_idIndexMarker165"/>nothing special about handling exceptions in a CLI application compared to other kinds of applications, as it follows the same guidelines and best practices. Thatâ€™s why, in this section, you might find that you already know all the concepts that we are going to talk about, and thatâ€™s perfectly normal because youâ€™d likely have implemented them in other applications, whether web, APIs, or <span class="No-Break">desktop applications.</span></p>
			<p>However, it is important to note that a robust error-handling strategy will have a significant impact on the quality, reliability, and resilience of your application. This is why it is worth taking the time to design a good <span class="No-Break">error-handling strategy.</span></p>
			<p>As you certainly know, every error-handling<a id="_idIndexMarker166"/> strategy relies on a <strong class="source-inline">try-catch-finally</strong> block. But not always! Not every method needs to implement a <strong class="source-inline">try-catch-finally</strong> block. In fact, best practices of error handling state that only the <em class="italic">caller</em> method (usually the top-level method) should handle exceptions, while the <em class="italic">callee</em> method should let the exceptions bubble up to be caught, and handled, by the <em class="italic">caller</em> method. This results in leaner, cleaner, and more <span class="No-Break">focused methods.</span></p>
			<p>Another best practice is to never swallow exceptions unless it is absolutely necessary. Why? Because swallowing exceptions hides errors, making code appear functional while it fails. This obscures valuable error information, allowing unpredictable behavior and data corruption. It complicates debugging and violates the principle of failing fast. In other words, it leads to silent failures that are hard to detect and fix, making it a <span class="No-Break">poor practice.</span></p>
			<p>The <strong class="source-inline">finally</strong> block<a id="_idIndexMarker167"/> is important, although I see it often forgotten. It is important to remember that this block is used to ensure that resources are freed, even if an <span class="No-Break">exception occurs.</span></p>
			<p>When catching exceptions, use<a id="_idIndexMarker168"/> multiple <strong class="source-inline">catch</strong> blocks, catching exceptions from the most specific to the most generic. This will ensure far better error handling than catching all exceptions as a generic exception and applying the same error-handling processing to all of them. An example of that is when working with files: we donâ€™t want to handle the situation where the file is not found the same way as handling the situation where the file cannot be written to, because of a lack of permissions. By distinguishing each of these situations, we can apply a specific error-handling process and, ultimately, provide the user with appropriate details of what happened rather than having generic processing and telling the user that we couldnâ€™t write to <span class="No-Break">the file.</span></p>
			<p>We can also create our own exceptions. I do this often because it helps improve code readability. It is easy to understand what happens when the <strong class="source-inline">CreateNewUser</strong> method throws an instance of the <strong class="source-inline">UserAlreadyExistsException</strong> exception, <span class="No-Break">isnâ€™t it?</span></p>
			<p>Hereâ€™s how this custom<a id="_idIndexMarker169"/> exception <span class="No-Break">would look:</span></p>
			<pre class="source-code">
public class UserAlreadyExistsException : Exception
{
Â Â Â Â public string UserId { get; }
Â Â Â Â public UserAlreadyExistsException(string userId)
Â Â Â Â Â Â Â Â : base($"User with ID '{userId}' already exists.")
Â Â Â Â {
Â Â Â Â Â Â Â Â UserId = userId;
Â Â Â Â }
Â Â Â Â public UserAlreadyExistsException(string userId, Exception 
Â Â Â Â innerException)
Â Â Â Â Â Â Â Â : base($"User with ID '{userId}' already exists.", 
Â Â Â Â Â Â Â Â innerException)
Â Â Â Â {
Â Â Â Â Â Â Â Â UserId = userId;
Â Â Â Â }
}</pre>			<p class="callout-heading">To catch or not to catch exceptions?</p>
			<p class="callout">Thereâ€™s a movement nowadays that is going against throwing exceptions because of the performance cost this may have, and I totally understand this. One great video about this topic is the one by Nick Chapsas, titled <em class="italic">Donâ€™t throw exceptions in C#. Do this instead</em>, which you can find on YouTube. I encourage you to go and watch it and make up your <span class="No-Break">own mind.</span></p>
			<p class="callout">However, whether you choose to throw the exception or handle it without throwing it, you will likely be dealing with exceptions. Also, keep in mind that both the .NET framework and some other libraries that you might be using are probably throwing exceptions, and you will need to catch these to handle them. Because of that, the principles described here are still valid and <span class="No-Break">worth knowing.</span></p>
			<p>When catching<a id="_idIndexMarker170"/> exceptions, you can also filter them. This is because some exceptions may require a different handling mechanism depending on the reason they <span class="No-Break">were thrown.</span></p>
			<p>A good example of this is the <strong class="source-inline">HttpResponseException</strong> exception type, as <span class="No-Break">illustrated here:</span></p>
			<pre class="source-code">
try
{
Â Â Â Â using var client = new HttpClient();
Â Â Â Â var response = await client.GetAsync("https://api.packtpub.com/
Â Â Â Â data");
Â Â Â Â response.EnsureSuccessStatusCode();
}
catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
{
Â Â Â Â Console.WriteLine("Resource not found (404)");
}
catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.Unauthorized)
{
Â Â Â Â Console.WriteLine("Server error (401)");
}</pre>			<p>As you can <a id="_idIndexMarker171"/>see here, we are catching the same exception (<strong class="source-inline">HttpResponseException</strong>) twice, but in each <strong class="source-inline">catch</strong> block, we focus on a very specific situation: in the first one, we are handling the situation where the resource was not found, whereas, in the second one, we are handling the situation where the user accessing the resource was <span class="No-Break">not authenticated.</span></p>
			<p>One final best practice when handling exceptions is to avoid losing the stack trace of the exception when <span class="No-Break">throwing it.</span></p>
			<p>To illustrate this principle, letâ€™s consider <span class="No-Break">this example:</span></p>
			<pre class="source-code">
try
{
Â Â Â Â Â Â // Attempt to read from a file
Â Â Â Â Â Â string content = File.ReadAllText(fileName);
Â Â Â Â Â Â Console.WriteLine($Â»File content: {content}Â»);
}
catch (FileNotFoundException ex)
{
Â Â Â Â Â Â // Handle the specific exception
Â Â Â Â Â Â Console.WriteLine($"File not found: {fileName}");
Â Â Â Â Â Â Console.WriteLine($"Exception details: {ex.Message}");
Â Â Â Â Â Â // Rethrow the exception
Â Â Â Â Â Â throw ex;
}</pre>			<p>If we <a id="_idIndexMarker172"/>throw the exception using the <strong class="source-inline">throw ex;</strong> statement, we lose the stack trace containing the details of what happened up to this point. The proper way to do this is to simply use <strong class="source-inline">throw</strong> to ensure the stack trace <span class="No-Break">is preserved.</span></p>
			<p>However, in some cases, we may need to catch the exception, handle it, and rethrow it by encapsulating it into another exception type, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
// Rethrow the exception by encapsulating it while preserving the 
// stack trace
throw new IOException($"File process error{fileName}", ex);</pre>			<p>In this case, the stack trace <span class="No-Break">is preserved.</span></p>
			<p>Now, letâ€™s apply these principles to <em class="italic">Bookmarkr</em>, and more specifically, to the ability to export bookmarks out <span class="No-Break">of </span><span class="No-Break"><em class="italic">Bookmarkr</em></span><span class="No-Break">.</span></p>
			<p>If you recall from the previous chapter, the export handler method (<strong class="source-inline">OnHandleExportCommand</strong>) looked <span class="No-Break">like this:</span></p>
			<pre class="source-code">
static void OnExportCommand(FileInfo outputfile)
{
Â Â Â Â var bookmarks = service.GetAll();
Â Â Â Â string json = JsonSerializer.Serialize(bookmarks, new 
Â Â Â Â JsonSerializerOptions { WriteIndented = true });
Â Â Â Â File.WriteAllText(outputfile.FullName, json);
}</pre>			<p>However, note that the <strong class="source-inline">WriteAllText</strong> method may throw many exceptions, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">UnauthorizedAccessException</strong> will be thrown in the case of insufficient permissions to access <span class="No-Break">the file</span></li>
				<li><strong class="source-inline">DirectoryNotFoundException</strong> will be thrown if the path <span class="No-Break">is invalid</span></li>
				<li><strong class="source-inline">PathTooLongException</strong> will be thrown if the path exceeds the system-defined <span class="No-Break">maximum length</span></li>
			</ul>
			<p>So, letâ€™s<a id="_idIndexMarker173"/> handle these exceptions. The code would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
static void OnExportCommand(FileInfo outputfile)
{
Â Â Â Â try
Â Â Â Â {
Â Â Â Â Â Â Â Â Â var bookmarks = service.GetAll();
Â Â Â Â Â Â Â Â Â string json = JsonSerializer.Serialize(bookmarks, new 
Â Â Â Â Â Â Â Â Â JsonSerializerOptions { WriteIndented = true });
Â Â Â Â Â Â Â Â Â File.WriteAllText(outputfile.FullName, json);
Â Â Â Â }
Â Â Â Â catch(JsonException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"Failed to serialize bookmarks to 
Â Â Â Â Â Â Â Â JSON.",
Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â }
Â Â Â Â catch (UnauthorizedAccessException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"Insufficient permissions to access
Â Â Â Â Â Â Â Â Â the file {outputfile.FullName}",
Â Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â }
Â Â Â Â catch (DirectoryNotFoundException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"The file {outputfile.FullName} 
Â Â Â Â Â Â Â Â Â cannot be found due to an invalid path",
Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â }
Â Â Â Â catch (PathTooLongException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"The provided path is exceeding the 
Â Â Â Â Â Â Â Â Â maximum length.",
Â Â Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â Â }
Â Â Â Â Â catch (Exception ex)
Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"An unknown exception occurred.",
Â Â Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â Â }
}</pre>			<p>In the preceding example, we are handling the most common exceptions, and we are also handling the general exception in case of an unexpected exception (yes, exceptions are exceptional situations but are nonetheless expected to happen, at least most of <span class="No-Break">the time).</span></p>
			<p>Note that we <a id="_idIndexMarker174"/>handled exceptions for both the serialization process and the <span class="No-Break">file-writing process.</span></p>
			<p>If you want to learn <a id="_idIndexMarker175"/>more about best practices for handling exceptions, I recommend that you visit this <span class="No-Break">page: </span><a href="https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor089"/>Handling errors doesnâ€™t necessarily mean handling exceptions</h2>
			<p>As surprising as it may seem, this is true, and exceptions might be avoided (at least most of the time) by applying defensive <span class="No-Break">programming techniques.</span></p>
			<p>By validating inputs, enforcing preconditions, and proactively identifying potential failure scenarios, we can significantly reduce error occurrences and enhance the overall resilience of <span class="No-Break">our application.</span></p>
			<p>Letâ€™s see what we can do here in<a id="_idIndexMarker176"/> terms of <span class="No-Break">defensive programming:</span></p>
			<ul>
				<li><strong class="bold">Validate inputs</strong>: We could ensure that the input file exists, hence avoiding an exception being raised if the file <span class="No-Break">doesnâ€™t exist.</span></li>
				<li><strong class="bold">Enforce preconditions</strong>: We can ensure that the <strong class="source-inline">bookmarks</strong> list is not null. Otherwise, <strong class="source-inline">JsonSerializer</strong> will throw a <strong class="source-inline">NullReferenceException</strong>. We can also ensure that the list is not empty because, if it is empty, although the serialization will return an empty JSON array, we may not want to write this to a file, especially if this means overwriting the <span class="No-Break">existing file.</span></li>
				<li><strong class="bold">Identify potential failure scenarios</strong>: We have already done this by catching the most common exceptions and <span class="No-Break">handling them.</span></li>
			</ul>
			<p>Okay. So, at this point, we know how to handle exceptions in our CLI applications, and we implemented this <span class="No-Break">in </span><span class="No-Break"><em class="italic">Bookmarkr</em></span><span class="No-Break">.</span></p>
			<p>However, there exists one other kind of unexpected event that represents, in fact, normal behavior. Iâ€™m talking about <span class="No-Break"><strong class="bold">program termination</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor090"/>Handling program termination</h2>
			<p>A program might be<a id="_idIndexMarker177"/> terminated at any moment by pressing a specific keyboard combination (usually <em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em>). When this happens, the operating system sends a signal to the program, instructing it to immediately stop its execution. This signal, often referred to as an interrupt or a termination signal, allows the program to perform any necessary cleanup operations, such as closing files, releasing resources, or saving state, before it exits. If the program has a signal handler for this specific signal, it can execute custom code to handle the termination gracefully. Otherwise, the program will terminate abruptly, and any unsaved data or incomplete operations may <span class="No-Break">be lost.</span></p>
			<p>Program termination allows one to gracefully stop a program that is taking too long to execute or that has <span class="No-Break">become unresponsive.</span></p>
			<p><strong class="source-inline">System.CommandLine</strong> provides a mechanism to handle program termination and execute custom code, allowing our CLI application to <span class="No-Break">gracefully terminate.</span></p>
			<p>Letâ€™s implement it to handle the situation where the user terminates the program while the export operation <span class="No-Break">is ongoing.</span></p>
			<p>In order to handle program<a id="_idIndexMarker178"/> termination, we will need to modify the delegate of the <strong class="source-inline">SetHandler</strong> method to retrieve the cancellation token and pass it to the handler <span class="No-Break">method itself:</span></p>
			<pre class="source-code">
exportCommand.SetHandler(async (context) =&gt;
{
Â Â Â Â FileInfo? outputfileOptionValue = context.ParseResult.
Â Â Â Â GetValueForOption(outputfileOption);
Â Â Â Â var token = context.GetCancellationToken();
Â Â Â Â await OnExportCommand(outputfileOptionValue!, token);
});</pre>			<p>Now, we can modify the handler method so it handles the program termination (i.e., catching the <span class="No-Break"><strong class="source-inline">OperationCanceledException</strong></span><span class="No-Break"> exception):</span></p>
			<pre class="source-code">
static async Task OnExportCommand(FileInfo outputfile, CancellationToken token)
{
Â Â Â Â Â try
Â Â Â Â Â {
Â Â Â Â Â Â Â Â var bookmarks = service.GetAll();
Â Â Â Â Â Â Â Â string json = JsonSerializer.Serialize(bookmarks, new 
Â Â Â Â Â Â Â Â JsonSerializerOptions { WriteIndented = true });
Â Â Â Â Â Â Â Â await File.WriteAllTextAsync(outputfile.FullName, json, 
Â Â Â Â Â Â Â Â token);
Â Â Â Â Â }
Â Â Â Â Â catch(OperationCanceledException ex)
Â Â Â Â Â {
Â Â Â Â Â Â Â Â var requested = ex.CancellationToken.IsCancellationRequested ? 
Â Â Â Â Â Â Â Â "Cancellation was requested by you.": "Cancellation was NOT 
Â Â Â Â Â Â Â Â requested by you.";
Â Â Â Â Â Â Â Â Helper.ShowWarningMessage(["Operation was cancelled.", 
Â Â Â Â Â Â Â Â requested, $"Cancellation reason: {ex.Message}"]);
Â Â Â Â Â }
Â Â Â Â Â catch(JsonException ex)
// The rest of the method has been removed for brevity.</pre>			<p>If we run the program now <a id="_idIndexMarker179"/>and then terminate it by pressing the  <em class="italic">Ctrl</em> + <em class="italic">C</em> keyboard combination, we get the following <span class="No-Break">console output:</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B22400_06_01.jpg" alt="Figure 6.1 â€“ Handling program termination"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 â€“ Handling program termination</p>
			<p>One thing worth mentioning<a id="_idIndexMarker180"/> here is that we need to use the asynchronous version of the <strong class="source-inline">WriteAllText</strong> method (aka <strong class="source-inline">WriteAllTextAsync</strong>) in order to be able to pass the cancellation token we received as a parameter, and for that reason, we needed to declare the <strong class="source-inline">OnExportCommand</strong> method <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">.</span></p>
			<p>Note that by handling program termination, we can gracefully handle the situation where the user abruptly stops the program. This results in a graceful shutdown of the program and release of the used resources, hence avoiding a crash and an <span class="No-Break">error message.</span></p>
			<p class="callout-heading">Why are we passing the cancellation token as a parameter to the handler method and not using it?</p>
			<p class="callout">This is an excellent question! As you have noticed, even though we receive the <strong class="source-inline">CancellationToken</strong> object as a parameter to the <strong class="source-inline">OnExportCommand</strong> method, we seem not to be using it. Then, why did we pass it in the <span class="No-Break">first place?</span></p>
			<p class="callout">This is related to how cancellation tokens work in .NET. Let <span class="No-Break">me explain!</span></p>
			<p class="callout">When <strong class="source-inline">OperationCanceledException</strong> is created in response to a cancellation request, it typically includes information about the <strong class="source-inline">CancellationToken</strong> object that triggered <span class="No-Break">the cancellation.</span></p>
			<p class="callout">For that matter, the <strong class="source-inline">OperationCanceledException</strong> exception class has a constructor that takes a <strong class="source-inline">CancellationToken</strong> object as <span class="No-Break">a parameter.</span></p>
			<p class="callout">When .NET framework asynchronous methods create this exception, they usually use this constructor and pass the cancellation token that triggered the <span class="No-Break">cancellation request.</span></p>
			<p class="callout">The <strong class="source-inline">OperationCanceledException</strong> class has a <strong class="source-inline">CancellationToken </strong>property that can be then accessed to get the token associated with the <span class="No-Break">cancellation request.</span></p>
			<p class="callout">In our case, we are accessing it to check whether the cancellation was requested by the user <span class="No-Break">or not.</span></p>
			<p class="callout">Having established a robust framework for error handling, it is equally important to ensure that these errors are recorded and monitored. Thatâ€™s where logging comes <span class="No-Break">into play!</span></p>
			<p>Effective logging not only helps in<a id="_idIndexMarker181"/> diagnosing and resolving issues but also provides valuable insights into the applicationâ€™s behavior, performance, and usage. In the upcoming section, we will dive into the best practices and strategies for implementing comprehensive logging mechanisms that complement our <span class="No-Break">error-handling strategy.</span></p>
			<p>At this point, we have covered a lot of information on error handling. However, error handling works together with logging to improve application reliability and maintainability. So, letâ€™s shift our focus to logging, and explore how to capture and preserve valuable information not only about errors but also about other significant events that will happen during <span class="No-Break">program execution.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor091"/>Logging in CLI applications</h1>
			<p>While error<a id="_idIndexMarker182"/> handling is more of a â€œjust-in-timeâ€ compensation <a id="_idIndexMarker183"/>mechanism when an unexpected event or error occurs, we may want to keep track of what happened so we can reproduce the issue, analyze it, understand why it happened in the first place, and <span class="No-Break">fix it.</span></p>
			<p>By â€œkeeping track of what happened,â€ we either mean the sequence of events that led to that unexpected behavior or error and/or the call stack of the exception raised when the <span class="No-Break">error occurred.</span></p>
			<p>Selecting a logging format is important. We want to find a balance between the amount of data we are logging (and storing) and the usage we intend to do with it. Logging unnecessary information will complexify log analysis, increase storage (and retention) costs, and may also slow down the logging process. We will also need to ensure that we are not logging sensitive information (such as credit card data), and if we do, that we are doing it in a safe manner. Some of the popular log formats include XML, JSON, CSV, <span class="No-Break">and syslog.</span></p>
			<p>Choosing the logging destination is equally important. We need to understand that there are no good or bad options, only appropriate and inappropriate options depending on our context and needs. If our intent is to analyze the logs, we may want to store these logs in a solution that provides log analysis mechanisms out of the box, so we donâ€™t need to write code for that. Examples of such solutions are Azure Log Analytics, Splunk, Datadog, Dynatrace, Serilog, <span class="No-Break">and Elasticsearch.</span></p>
			<p>However, note that by relying on cloud solutions (such as Azure Log Analytics), our application needs either to be running in the cloud or to have a constant connection to the internet. Sure, we can also build our application to follow the <strong class="bold">occasionally connected application</strong> (<strong class="bold">OCA</strong>) pattern<a id="_idIndexMarker184"/> so it keeps logs locally when it is running offline and sends them to Azure Log Analytics when it goes back online, but the idea here is that we should select a logging solution that is coherent with the usage pattern of our application. So, for an application that is intended to run locally, we will favor a logging mechanism that runs locally <span class="No-Break">as well.</span></p>
			<p>Finally, it is also important to define the log retention period. This can either be enforced by the organizationâ€™s compliance rules or by the relevance of the logged data: do you still need to analyze data from a bug or customer behavior that occurred three years ago? If not, you donâ€™t need to keep <span class="No-Break">this data.</span></p>
			<p>Either way, it is important to separate the logging format from the solution you use to store and analyze <span class="No-Break">these logs.</span></p>
			<p>Since our application is intended to run locally, we will select JSON as a logging format and Serilog as a <span class="No-Break">logging mechanism.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor092"/>Why JSON?</h2>
			<p>JSON-structured logs<a id="_idIndexMarker185"/> are easy to read and can easily be parsed by machines. Many modern log management solutions can ingest logs in JSON format, making it a good choice for <span class="No-Break">structured logging.</span></p>
			<p>In addition, JSON<a id="_idIndexMarker186"/> is less verbose than XML, which results in files that are lightweight in size, which, in turn, reduces the amount of storage we need to <span class="No-Break">store them.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor093"/>Why Serilog?</h2>
			<p>Serilog is a <a id="_idIndexMarker187"/>diagnostic logging library for .NET. It is built with powerful structured event data in mind and supports various â€œsinks,â€ which are the destinations where log events can be written to. Examples of such sinks include files, the console, databases or log management tools (such as Elasticsearch, Application Insights, Datadog, and Splunk). Itâ€™s easy to set up, has a clean API, and <span class="No-Break">is portable.</span></p>
			<p>One of the key features of Serilog is its ability to log structured data, which allows for more meaningful and queryable logs. It uses message templates, a simple DSL extending .NET format strings, which can capture properties along with the <span class="No-Break">log event.</span></p>
			<p>I do like the way the NuGet packages for Serilog are structured. First, there is the base package, which provides Serilogâ€™s functionalities in our code. Then, there are â€œsinkâ€ packages, one for each sink, and there are tons of them. We can even create our very own sink should we need it. I havenâ€™t found a usage for that as there are already sinks for almost everything you can <span class="No-Break">think ofâ€¦</span></p>
			<p>Oh! And, by the way, the Serilog NuGet package has been downloaded (to this day) more than 1.24 billion times! That should mean something, <span class="No-Break">right? </span><span class="No-Break">ğŸ˜‰</span></p>
			<p>Before we add Serilog to our CLI application, we need to modify our code to expose the <strong class="source-inline">IServiceCollection</strong> property so we can configure <span class="No-Break">our services.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor094"/>Accessing IServiceCollection</h2>
			<p>The first step we need<a id="_idIndexMarker188"/> to take is to add the <strong class="source-inline">System.CommandLine.Hosting</strong> NuGet package to our project. From the Visual Studio Code terminal, we can do so by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet add package System.CommandLine.Hosting --prerelease</pre>			<p>Then, we need to update our instantiation of the <strong class="source-inline">CommandLineBuilder</strong> class <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using System.CommandLine.Hosting;
using Microsoft.Extensions.Hosting;
var parser = new CommandLineBuilder(rootCommand)
Â Â Â Â Â Â Â Â Â Â Â Â .UseHost(_ =&gt; Host.CreateDefaultBuilder(),
Â Â Â Â Â Â Â Â Â Â Â Â host =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â host.ConfigureServices(services =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â .UseDefaults()
Â Â Â Â Â Â Â Â Â Â Â Â .Build();
return await parser.InvokeAsync(args);</pre>			<p>We now have access to <strong class="source-inline">IServiceCollection</strong> and can thus add services to this collection and configure <span class="No-Break">their behavior.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor095"/>Adding Serilog to IServiceCollection</h2>
			<p>Adding Serilog to <a id="_idIndexMarker189"/>this <a id="_idIndexMarker190"/>collection will require the <strong class="source-inline">Serilog.Extensions.Hosting</strong> NuGet package. So, letâ€™s <span class="No-Break">add it!</span></p>
			<pre class="console">
dotnet add package Serilog.Extensions.Hosting</pre>			<p>This allows us to add Serilog to <strong class="source-inline">IServiceCollection</strong> by adding this line of code to the preceding <span class="No-Break">code sample:</span></p>
			<pre class="source-code">
services.AddSerilog();</pre>			<h2 id="_idParaDest-93"><a id="_idTextAnchor096"/>Adding (and configuring) the required Serilog sinks</h2>
			<p>As mentioned earlier, there are tons of sinks<a id="_idIndexMarker191"/> available with Serilog. However, since we are building a CLI application, we will only use two sinks: <strong class="source-inline">Console</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">File</strong></span><span class="No-Break">.</span></p>
			<p>We also mentioned that Serilog is structured in such a way that each sink has its own NuGet package. We will then need to add the appropriate NuGet packages using <span class="No-Break">these commands:</span></p>
			<pre class="console">
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File</pre>			<p>We can start using Serilog at this point by configuring the sinks in the code. The updated code for the instantiation of the <strong class="source-inline">CommandLineBuilder</strong> class would then be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using Serilog;
using System.CommandLine.Hosting;
using Microsoft.Extensions.Hosting;
var parser = new CommandLineBuilder(rootCommand)
Â Â Â Â Â Â Â Â Â Â Â Â .UseHost(_ =&gt; Host.CreateDefaultBuilder(),
Â Â Â Â Â Â Â Â Â Â Â Â host =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â host.ConfigureServices(services =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â services.AddSerilog((config) =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.MinimumLevel.Information();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.WriteTo.Console();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.WriteTo.File("logs/bookmarkr-.txt", 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â rollingInterval:RollingInterval.Day,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restrictedToMinimumLevel:Serilog.Events.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â LogEventLevel.Error);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.CreateLogger();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â .UseDefaults()
Â Â Â Â Â Â Â Â Â Â Â Â .Build();
return await parser.InvokeAsync(args);</pre>			<p>Letâ€™s take a closer look at the<a id="_idIndexMarker192"/> part of the code where Serilog is configured (i.e., the delegate function within the <span class="No-Break"><strong class="source-inline">AddSerilog</strong></span><span class="No-Break"> method):</span></p>
			<ol>
				<li>This code acts on an instance of the <strong class="source-inline">LoggerConfiguration</strong> class that is used to configure the behavior of Serilog and <span class="No-Break">its sinks.</span></li>
				<li>We define the minimum log level as <strong class="source-inline">Information</strong>. This means that every event that is informational or above (such as warnings and errors) will be logged unless overridden by a <span class="No-Break">specific sink.</span></li>
				<li>We notice that the <strong class="source-inline">File</strong> sink has overridden the log level in a way that only errors or higher severity events (such as <strong class="source-inline">Fatal</strong>) <span class="No-Break">are logged.</span></li>
				<li>We can also notice that the <strong class="source-inline">File</strong> sink has defined the location of the files (the <strong class="source-inline">logs</strong> folder) and the naming convention for the log files (<strong class="source-inline">bookmark-.txt</strong>). The dash symbol in the filename is not a misspelling but rather intentional! It is there because Serilog will append a unique identifier to that filename. Since we defined our rolling interval to be on a daily basis, Serilog will create a new log file every day. Hence, our log folder will contain files that will be named <strong class="source-inline">bookmark-20240705.txt</strong>, <strong class="source-inline">bookmark-20240706.txt</strong>, and <span class="No-Break">so on.</span></li>
				<li>We notice that we are also explicitly telling Serilog to log to the console. This is because even though we added a reference to the <strong class="source-inline">Serilog.Sinks.Console</strong> NuGet package, we still need to tell Serilog to actually use <span class="No-Break">this sink.</span></li>
				<li>Finally, we call the <strong class="source-inline">CreateLogger</strong> method so<a id="_idIndexMarker193"/> that all this configuration is taken <span class="No-Break">into account.</span></li>
			</ol>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>Configuring sinks in appsettings.json</h2>
			<p>Although<a id="_idIndexMarker194"/> configuring the behavior of Serilog and its sinks directly in the code works perfectly fine, it is <span class="No-Break">less flexible.</span></p>
			<p>What if we want to add a new sink or update the configuration of an existing one? Well, you guessed it, we need to update and redeploy <span class="No-Break">the code.</span></p>
			<p>Moving this configuration into a configuration file (such as <strong class="source-inline">appsettings.json</strong>) brings more flexibility to <span class="No-Break">our application.</span></p>
			<p>Letâ€™s see how we can <span class="No-Break">do this!</span></p>
			<p>We first need to add the <strong class="source-inline">Serilog.Settings.Configuration</strong> NuGet package to our application by typing this command into the Visual Studio <span class="No-Break">Code terminal:</span></p>
			<pre class="console">
dotnet add package Serilog.Settings.Configuration</pre>			<p>We then need to add an <strong class="source-inline">appsettings.json</strong> file to our application. This can easily be done by adding a new file to the project in Visual Studio Code or in your favorite <span class="No-Break">code editor.</span></p>
			<p>For the <strong class="source-inline">appsettings.json</strong> file to be deployed with our application, we need to ensure that its latest version is always copied to the output directory. This can be done in the <strong class="source-inline">bookmarkr.csproj</strong> file by <a id="_idIndexMarker195"/>adding this snippet just before the closing <strong class="source-inline">&lt;/</strong><span class="No-Break"><strong class="source-inline">Project&gt;</strong></span><span class="No-Break"> element:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
Â Â Â Â &lt;None Update="appsettings.json"&gt;
Â Â Â Â Â Â Â Â Â Â &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
Â Â Â Â &lt;/None&gt;
&lt;/ItemGroup&gt;</pre>			<p>Now, letâ€™s move the configuration of Serilog and its sinks from the code to the <strong class="source-inline">appsettings.json</strong> configuration file. The content of this file will then be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{
Â Â "Serilog": {
Â Â Â Â "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
Â Â Â Â "MinimumLevel": {
Â Â Â Â Â Â "Default": "Information",
Â Â Â Â Â Â "Override": {
Â Â Â Â Â Â Â Â "Microsoft": "Warning",
Â Â Â Â Â Â Â Â "System": "Warning"
Â Â Â Â Â Â }
Â Â Â Â },
Â Â Â Â "WriteTo": [
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â "Name": "Console",
Â Â Â Â Â Â Â Â "Args": {
Â Â Â Â Â Â Â Â Â Â "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] 
Â Â Â Â Â Â Â Â Â Â {Message:lj}{NewLine}{Exception}"
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â },
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â "Name": "File",
Â Â Â Â Â Â Â Â "Args": {
Â Â Â Â Â Â Â Â Â Â "path": "logs/log-.txt",
Â Â Â Â Â Â Â Â Â Â "rollingInterval": "Day",
Â Â Â Â Â Â Â Â Â Â "outputTemplate": "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} 
Â Â Â Â Â Â Â Â Â Â {Level:u3}] {Message:lj}{NewLine}{Exception}"
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â ],
Â Â Â Â "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
Â Â }
}</pre>			<p>This <a id="_idIndexMarker196"/>file is easy to read and pretty self-explanatory. It describes the sinks to be used and their configuration and defines the minimum log level. There is one thing to pay attention to here, however! Notice that we have overridden the minimum log level for libraries of the <strong class="source-inline">Microsoft</strong> and <strong class="source-inline">System</strong> namespaces. This is because these libraries tend to be chatty, which may result in a large amount of log data that is not very useful. By setting their minimum log level to <strong class="source-inline">Warning</strong>, we can ensure to only capture relevant events such as warnings <span class="No-Break">or errors.</span></p>
			<p>The <strong class="source-inline">Enrich</strong> section is a new one, however. As the name suggests, it is there to enrich the log data with extra information such as the machine name and the thread ID. If your CLI application is intended to be executed on multiple computers within your organization, knowing on which machine you got the error helps you narrow the search area. If that application is intended to run in multiple instances on the same machine, the thread ID will let you know which instance logged that information. This can be helpful in a concurrent <span class="No-Break">execution scenario.</span></p>
			<p>Are <span class="No-Break">we done?</span></p>
			<p>Not exactlyâ€¦ We still need to update the code inside the <span class="No-Break"><strong class="source-inline">ConfigureServices</strong></span><span class="No-Break"> method.</span></p>
			<p>Since all the configuration has been moved to the <strong class="source-inline">appsettings.json</strong> file, the code becomes simpler, as you can <span class="No-Break">see here:</span></p>
			<pre class="source-code">
using Microsoft.Extensions.Configuration;
// Only the body of the ConfigureServices is shown here for clarity.
// To see the full version of the code, please refer to the GitHub 
// repo of the book.
services.AddSerilog((config) =&gt;
{
Â Â Â Â Â Â var configuration = new ConfigurationBuilder()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â .SetBasePath(Directory.GetCurrentDirectory())
Â Â Â Â Â Â Â Â Â Â Â Â Â Â .AddJsonFile("appsettings.json")
Â Â Â Â Â Â Â Â Â Â Â Â Â Â .Build();
Â Â Â Â Â Â config.ReadFrom.Configuration(configuration);
});</pre>			<p class="callout-heading">Configuration in code or in a file?</p>
			<p class="callout">You may be wondering whether to configure your logger in the code or in a configuration file. That is a <span class="No-Break">great question!</span></p>
			<p class="callout">I personally rely on both: I configure my sinks in the code and the log level in the <strong class="source-inline">appsettings.json</strong> file. This way, I can ensure that my â€œbase sinksâ€ are always in use even though more may be <span class="No-Break">added later.</span></p>
			<p class="callout">This is a personal choice, however. You are, of course, welcome to use whatever works best <span class="No-Break">for you.</span></p>
			<p class="callout">Keep in mind that configuration in the code takes precedence over configuration in the <span class="No-Break">configuration file.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor098"/>Letâ€™s log something!</h2>
			<p>Finally! Up to this point, all we did was configure our logger and its sinks. Letâ€™s now see how <span class="No-Break">this works!</span></p>
			<p>Once everything is in place and well<a id="_idIndexMarker197"/> configured, logging information using Serilog is <span class="No-Break">quite straightforward.</span></p>
			<p>To illustrate this, letâ€™s take <span class="No-Break">an example.</span></p>
			<p>When we implemented the <strong class="source-inline">import</strong> command back in <a href="B22400_05.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, if an existing bookmark was to be updated (because a bookmark with the same URL but a different name already existed in the list of bookmarks held by the application), we had no way to track the name of that conflicting bookmark before <span class="No-Break">the update.</span></p>
			<p>If this was a piece of critical information (for compliance reasons, for example), logging would come <span class="No-Break">in handy.</span></p>
			<p>We will revisit this functionality and implement logging to keep track of the name before and after the update, along with its URL and the date and time of <span class="No-Break">the update.</span></p>
			<p>The log format would then be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;date and time&gt; | Bookmark updated | name changed from '&lt;old name&gt;' to '&lt;new name&gt;' for URL '&lt;Url&gt;'</pre>			<p>The first thing we will do is to<a id="_idIndexMarker198"/> create a new version of the <strong class="source-inline">import</strong> method for the <strong class="source-inline">BookmarkService</strong> class. This new version will take a bookmark as a parameter and check whether a bookmark with the same URL but with a different name already exists in the list of bookmarks held by the application. If this is actually the case, it replaces the existing bookmark with the new name and then returns an instance of the <strong class="source-inline">BookmarkConflictModel</strong> type, which contains the original and updated name and the URL. If no conflict is detected, the method simply adds the bookmark and <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<p>Here is the code for <span class="No-Break">this method:</span></p>
			<pre class="source-code">
public BookmarkConflictModel? Import(Bookmark bookmark)
{
Â Â Â Â var conflict = _bookmarks.FirstOrDefault(b =&gt; b.Url == bookmark.
Â Â Â Â Url &amp;&amp; b.Name != bookmark.Name);
Â Â Â Â if(conflict is not null)
Â Â Â Â {
Â Â Â Â Â Â Â Â var conflictModel = new BookmarkConflictModel { OldName = 
Â Â Â Â Â Â Â Â conflict.Name, NewName = bookmark.Name, Url = bookmark.Url };
Â Â Â Â Â Â Â Â conflict.Name = bookmark.Name; // this updates the name of the 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // bookmark.
Â Â Â Â Â Â Â Â Â return conflictModel;
Â Â Â Â }
Â Â Â Â else
Â Â Â Â {
Â Â Â Â Â Â Â Â _bookmarks.Add(bookmark);
Â Â Â Â Â Â Â Â return null;
Â Â Â Â }
}</pre>			<p>The code of the <strong class="source-inline">BookmarkConflictModel</strong> class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public class BookmarkConflictModel
{
Â Â Â Â public string? OldName { get; set; }
Â Â Â Â public string? NewName { get; set; }
Â Â Â Â public string? Url { get; set; }
}</pre>			<p>Finally, the code of the handler<a id="_idIndexMarker199"/> method of the <strong class="source-inline">Import</strong> command is updated to process each bookmark read from the file such that if a conflict is detected, Serilog is used to keep track <span class="No-Break">of it.</span></p>
			<p>Here is the <span class="No-Break">updated code:</span></p>
			<pre class="source-code">
static void OnImportCommand(FileInfo inputfile)
{
Â Â Â Â string json = File.ReadAllText(inputfile.FullName);
Â Â Â Â List&lt;Bookmark&gt; bookmarks = JsonSerializer.
Â Â Â Â Deserialize&lt;List&lt;Bookmark&gt;&gt;(json) ?? new List&lt;Bookmark&gt;();
Â Â Â Â foreach(var bookmark in bookmarks)
Â Â Â Â {
Â Â Â Â Â Â Â Â var conflict = service.Import(bookmark);
Â Â Â Â Â Â Â Â if (conflict is not null)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Log.Information($"{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")} | Bookmark updated | name changed from '{conflict.OldName}' to '{conflict.NewName}' for URL '{conflict.Url}'");
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre>			<p>Now, if we run this<a id="_idIndexMarker200"/> program, we can see that was logged in case of <span class="No-Break">a conflict:</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B22400_06_02.jpg" alt="Figure 6.2 â€“ Logging in case of a conflict"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 â€“ Logging in case of a conflict</p>
			<p>As we can see, this information was both logged to the console and to <span class="No-Break">the file.</span></p>
			<p>We are now able to use Serilog to log important information. But what happens if the application is closed or is terminated? In such a situation, we can rely on the <span class="No-Break"><strong class="source-inline">CloseAndFlush</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor099"/>Closing and gracefully disposing of Serilog</h2>
			<p>When using Serilog, the <strong class="source-inline">Log.CloseAndFlush</strong> method is called to ensure that all pending log event messages <a id="_idIndexMarker201"/>are flushed out to the sinks and that the logging system is properly shut down. This is particularly important in applications that have a definite end to their life cycle, such as console applications or batch jobs, to make sure that no log entries are missed due to the application closing before the logs are fully <span class="No-Break">written out.</span></p>
			<p>When calling this method, two <span class="No-Break">things happen:</span></p>
			<ul>
				<li><strong class="bold">Close</strong>: This sends a signal to the logging subsystem to stop accepting new log events. This is important to prevent any new logs from being generated after we have decided to shut down the <span class="No-Break">logging system.</span></li>
				<li><strong class="bold">Flush</strong>: This ensures that all log events that have been captured and are currently buffered are written out to their respective sinks. Serilog may buffer events in memory for efficiency, and flushing ensures that these buffered events are <span class="No-Break">not lost.</span></li>
			</ul>
			<p>I recommend calling <a id="_idIndexMarker202"/>this method when exiting the application, either by shutting it down or by <span class="No-Break">terminating it.</span></p>
			<p>For that matter, I always create a method (which I call <strong class="source-inline">FreeSerilogLoggerOnShutdown</strong>) that will subscribe to <span class="No-Break">two events:</span></p>
			<ul>
				<li><strong class="source-inline">AppDomain.CurrentDomain.ProcessExit</strong>: This event is raised when the process is about to exit, allowing us to perform cleanup tasks or <span class="No-Break">save data.</span></li>
				<li><strong class="source-inline">Console.CancelKeyPress</strong>: This event is triggered when the user presses <em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em>, terminating the currently <span class="No-Break">running application.</span></li>
			</ul>
			<p>In both cases, these subscription calls the same delegate method (which I call <strong class="source-inline">ExecuteShutdownTasks</strong>) that will call the <strong class="source-inline">CloseAndFlush</strong> method <span class="No-Break">from Serilog.</span></p>
			<p>Here is the code for these <span class="No-Break">two methods:</span></p>
			<pre class="source-code">
static void FreeSerilogLoggerOnShutdown()
{
Â Â Â Â // This event is raised when the process is about to exit, 
Â Â Â Â // allowing you to perform cleanup tasks or save data.
Â Â Â Â AppDomain.CurrentDomain.ProcessExit += (s, e) =&gt; 
Â Â Â Â ExecuteShutdownTasks();
Â Â Â Â // This event is triggered when the user presses Ctrl+C or 
Â Â Â Â // Ctrl+Break. While it doesn't cover all shutdown scenarios, it's 
Â Â Â Â // useful for handling user-initiated terminations.
Â Â Â Â Console.CancelKeyPress += (s, e) =&gt; ExecuteShutdownTasks();
}
// Code to execute before shutdown
static void ExecuteShutdownTasks()
{
Â Â Â Â Console.WriteLine("Performing shutdown tasks...");
Â Â Â Â // Perform cleanup tasks, save data, etc.
Â Â Â Â Log.CloseAndFlush();
}</pre>			<p>The call to the <strong class="source-inline">FreeSerilogLoggerOnShutDown</strong> method is the first instruction of the <strong class="source-inline">Main</strong> method of the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class.</span></p>
			<p>While this is not a book about Serilog (which, in my opinion, deserves a book on its own), in this section, we covered the basics, which is enough for the purpose of the book. If you want to find more information about Serilog, <span class="No-Break">visit </span><a href="https://serilog.net/"><span class="No-Break">https://serilog.net/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we improved our CLI application, <em class="italic">Bookmarkr</em>, by adding error handling and logging into <span class="No-Break">the application.</span></p>
			<p>With error handling, we implemented graceful degradation into our CLI application. This means that our application is now more fault-tolerant and will not crash abruptly should an unexpected <span class="No-Break">event occur.</span></p>
			<p>With logging, we can record application activities, errors, and exceptions so that they can be analyzed at a later point in time in order to understand the sequence of events that led up to that error or unexpected behavior. But logging also enables the monitoring of application health and performance <span class="No-Break">over time.</span></p>
			<p>In the upcoming chapter, we will see how to make our CLI application more interactive <span class="No-Break">and user-friendly.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor101"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the <em class="italic">Bookmarkr</em> application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor102"/>Task #1 â€“ Handling errors for the Import command</h2>
			<p>If the input file cannot be accessed, or if its content cannot be deserialized, it is likely that the code will throw exceptions. Your mission is to identify what exceptions are likely to be thrown and handle <span class="No-Break">them accordingly.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor103"/>Task #2 â€“ Logging errors to a file</h2>
			<p>In the previous task, the goal was to handle the exceptions. However, it might be useful to log the details of these exceptions to a file so we can review them later and use this information to improve the robustness of <span class="No-Break">our application.</span></p>
			<p>Your mission here is to use Serilog to log exception data on a daily rolling interval and store these log files in the <span class="No-Break"><strong class="source-inline">logs/errors</strong></span><span class="No-Break"> folder.</span></p>
			<p>You are also asked to customize the output template so that logs contain the <span class="No-Break">following information:</span></p>
			<ul>
				<li>Date and time of <span class="No-Break">the event</span></li>
				<li>The name of the machine on which the <span class="No-Break">event happened</span></li>
				<li>The type of event (warning, error, and <span class="No-Break">so on)</span></li>
				<li>The exceptionâ€™s details, including its <span class="No-Break">stack trace</span></li>
			</ul>
		</div>
	

		<div id="_idContainer090" class="Content">
			<h1 id="_idParaDest-101" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor104"/>Part 3: Advanced Topics in CLI Application Development</h1>
			<p>In this part, you will explore the world of interactive command-line applications, learning how to create engaging user experiences using libraries like <strong class="source-inline">Spectre.Console</strong>. You'll discover techniques for implementing rich prompts, colorful output, and interactive menus that enhance user interaction. Next, you'll delve into building modular and extensible CLI applications, focusing on architectural patterns that promote maintainability and scalability. This includes structuring your code and organizing your project into logical components. Finally, you'll learn about integrating external APIs and services into your CLI applications. By the end of this part, you'll have the skills to develop sophisticated CLI tools that can consume various external services <span class="No-Break">and APIs.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B22400_07.xhtml#_idTextAnchor105"><em class="italic">Chapter 7</em></a><em class="italic">, Interactive CLI Applications</em></li>
				<li><a href="B22400_08.xhtml#_idTextAnchor120"><em class="italic">Chapter 8</em></a><em class="italic">, Building Modular and Extensible CLI Applications</em></li>
				<li><a href="B22400_09.xhtml#_idTextAnchor136"><em class="italic">Chapter 9</em></a><em class="italic">, Working with External APIs and Services</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer091">
			</div>
		</div>
		<div>
			<div id="_idContainer092">
			</div>
		</div>
		<div>
			<div id="_idContainer093">
			</div>
		</div>
		<div>
			<div id="_idContainer094">
			</div>
		</div>
		<div>
			<div id="_idContainer095">
			</div>
		</div>
		<div>
			<div id="_idContainer096" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer097" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer098">
			</div>
		</div>
		<div>
			<div id="_idContainer099">
			</div>
		</div>
		<div>
			<div id="_idContainer100" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>