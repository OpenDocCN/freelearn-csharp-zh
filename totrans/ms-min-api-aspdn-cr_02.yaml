- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Minimal APIs and Their Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter of the book, we will introduce some of the basic themes related
    to minimal APIs in .NET 6.0, showing how they differ from the controller-based
    web APIs that we have written in the previous version of .NET. We will also try
    to underline both the pros and the cons of this new approach of writing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting a minimal API project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core 6.0 Web API application. You can either use one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**: Click on the **New** | **Project** command in the **File** menu
    of Visual Studio 2022 – then, choose the **ASP.NET Core Web API** template. Select
    a name and the working directory in the wizard and be sure to uncheck the **Use
    controllers (uncheck to use minimal APIs)** option in the next step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option 2**: Open your console, shell, or Bash terminal, and change to your
    working directory. Use the following command to create a new Web API application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the project in Visual Studio by double-clicking the project file,
    or in Visual Studio Code, by typing the following command in the already open
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can safely remove all the code related to the `WeatherForecast`
    sample, as we don’t need it for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the official Microsoft documentation available at [https://docs.microsoft.com/aspnet/core/fundamentals/routing](https://docs.microsoft.com/aspnet/core/fundamentals/routing),
    the following definition is given for routing:'
  prefs: []
  type: TYPE_NORMAL
- en: Routing is responsible for matching incoming HTTP requests and dispatching those
    requests to the app’s executable endpoints. Endpoints are the app’s units of executable
    request-handling code. Endpoints are defined in the app and configured when the
    app starts. The endpoint matching process can extract values from the request’s
    URL and provide those values for request processing. Using endpoint information
    from the app, routing is also able to generate URLs that map to endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In controller-based web APIs, routing is defined via the `UseEndpoints()` method
    in `Startup.cs` or using data annotations such as `Route`, `HttpGet`, `HttpPost`,
    `HttpPut`, `HttpPatch`, and `HttpDelete` right over the action methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [*Chapter 1*](B17902_01.xhtml#_idTextAnchor014)*, Introduction
    to Minimal APIs* in minimal APIs, we define the route patterns using the `Map*`
    methods of the `WebApplication` object. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have defined four endpoints, each with a different routing
    and method. Of course, we can use the same route pattern with different HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we add an endpoint to our application (for example, using `MapGet()`),
    `UseRouting()` is automatically added at the start of the middleware pipeline
    and `UseEndpoints()` at the end of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown here, ASP.NET Core 6.0 provides `Map*` methods for the most common
    HTTP verbs. If we need to use other verbs, we can use the generic `MapMethods`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we will show in detail how routing works effectively
    and how we can control its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Route handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods that execute when a route URL matches (according to parameters and
    constraints, as described in the following sections) are called **route handlers**.
    Route handlers can be a lambda expression, a local function, an instance method,
    or a static method, whether synchronous or asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a lambda expression (inline or using a variable):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s an example of a local function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is an example of an instance method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see an example of a static method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Route parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the previous versions of .NET, we can create route patterns with parameters
    that will be automatically captured by the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A route can contain an arbitrary number of parameters. When a request is made
    to this route, the parameters will be captured, parsed, and passed as arguments
    to the corresponding handler. In this way, the handler will always receive typed
    arguments (in the preceding sample, we are sure that the username is `string`
    and the product ID is `int`).
  prefs: []
  type: TYPE_NORMAL
- en: If the route values cannot be casted to the specified types, then an exception
    of the `BadHttpRequestException` type will be thrown, and the API will respond
    with a `400 Bad Request` message.
  prefs: []
  type: TYPE_NORMAL
- en: Route constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Route constraints are used to restrict valid types for route parameters. Typical
    constraints allow us to specify that a parameter must be a number, a string, or
    a GUID. To specify a route constraint, we simply need to add a colon after the
    parameter name, then specify the constraint name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Minimal APIs support all the route constraints that were already available
    in the previous versions of ASP.NET Core. You can find the full list of route
    constraints at the following link: [https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference](https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, according to the constraints, no route matches the specified path, we don’t
    get an exception. Instead we obtain a `404 Not Found` message, because, in fact,
    if the constraints do not fit, the route itself isn’t reachable. So, for example,
    in the following cases we get 404 responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Examples of an invalid path according to the route constraints
    ](img/Table_2.01_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Examples of an invalid path according to the route constraints
  prefs: []
  type: TYPE_NORMAL
- en: 'Every other argument in the handler that is not declared as a route constraint
    is expected, by default, in the query string. For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, *Parameter binding*, we’ll go deeper into how to use binding
    to further customize routing by specifying, for example, where to search for routing
    arguments, how to change their names, and how to have optional route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Parameter binding** is the process that converts request data (i.e., URL
    paths, query strings, or the body) into strongly typed parameters that can be
    consumed by route handlers. ASP.NET Core minimal APIs support the following binding
    sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Route values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body (as JSON, the only format supported by default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service provider (dependency injection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll talk in detail about dependency injection in [*Chapter 4*](B17902_04.xhtml#_idTextAnchor061),
    *Implementing Dependency Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll see later in this chapter, if necessary, we can customize the way in
    which binding is performed for a particular input. Unfortunately, in the current
    version, binding from `Form` is not natively supported in minimal APIs. This means
    that, for example, `IFormFile` is not supported either.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how parameter binding works, let’s take a look at the
    following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters that are passed to the handler are resolved in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.2 – Parameter binding sources ](img/Table_2.02_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.2 – Parameter binding sources
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, ASP.NET Core is able to automatically understand where to search
    for parameters for binding, based on the route pattern and the types of the parameters
    themselves. For example, a complex type such as the `Person` class is expected
    in the request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'If needed, as in the previous versions of ASP.NET Core, we can use attributes
    to explicitly specify where parameters are bound from and, optionally, use different
    names for them. See the following endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The API can be invoked with `/search?q=text`. However, using `q` as the name
    of the argument isn’t a good idea, because its meaning is not self-explanatory.
    So, we can modify the handler using `FromQueryAttribute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the API still expects a query string parameter named `q`, but in
    the handler its value is now bound to the `searchText` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: According to the standard, the `GET`, `DELETE`, `HEAD`, and `OPTIONS` HTTP options
    should never have a body. If, nevertheless, you want to use it, you need to explicitly
    add the `[FromBody]` attribute to the handler argument; otherwise, you’ll get
    an `InvalidOperationException` error. However, keep in mind that this is a bad
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all the parameters in route handlers are required. So, if, according
    to routing, ASP.NET Core finds a valid route, but not all the required parameters
    are provided, we will get an error. For example, let’s look at the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we call the endpoint without the `pageIndex` or `itemsPerPage` query string
    values, we will obtain a `BadHttpRequestException` error, and the response will
    be `400 Bad Request`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the parameters optional, we just need to declare them as nullable or
    provide a default value. The latter case is the most common. However, if we adopt
    this solution, we cannot use a lambda expression for the handler. We need another
    approach, for example, a local function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are dealing with a query string, but the same rules apply to
    all the binding sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that if we use `null`, we need to declare it as `BadHttpRequestException`
    error again. The following example correctly defines the `orderBy` query string
    parameter as optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Special bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In controller-based web APIs, a controller that inherits from `Microsoft.AspNetCore.Mvc.ControllerBase`
    has access to some properties that allows it to get the context of the request
    and response: `HttpContext`, `Request`, `Response`, and `User`. In minimal APIs,
    we don’t have a base class, but we can still access this information because it
    is treated as a special binding that is always available to any handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We can also access all these objects using the `IHttpContextAccessor` interface,
    as we did in the previous ASP.NET Core versions.
  prefs: []
  type: TYPE_NORMAL
- en: Custom binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, the default way in which parameter binding works isn’t enough
    for our purpose. In minimal APIs, we don’t have support for the `IModelBinderProvider`
    and `IModelBinder` interfaces, but we have two alternatives to implement custom
    model binding.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IModelBinderProvider` and `IModelBinder` interfaces in controller-based
    projects allow us to define the mapping between the request data and the application
    model. The default model binder provided by ASP.NET Core supports most of the
    common data types, but, if necessary, we can extend the system by creating our
    own providers. We can find more information at the following link: [https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding](https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to bind a parameter that comes from a route, query string, or header
    to a custom type, we can add a static `TryParse` method to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `TryParse` method, we can try to split the input parameter and check
    whether it contains two decimal values: in this case, we parse the numbers to
    build the `Location` object and we return `true`. Otherwise, we return `false`
    because the `Location` object cannot be initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When the minimal API finds that a type contains a static `TryParse` method,
    even if it is a complex type, it assumes that it is passed in the route or the
    query string, based on the routing template. We can use the `[FromHeader]` attributes
    to change the binding source. In any case, `TryParse` will never be invoked for
    the body of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to completely control how binding is performed, we can implement
    a static `BindAsync` method on the type. This isn’t a very common solution, but
    in some cases, it can be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `BindAsync` method takes the whole `HttpContext` as an argument,
    so we can read all the information we need to create the actual `Location` object
    that is passed to the route handler. In this example, we read two query string
    parameters (`lat` and `lon`), but (in the case of `POST`, `PUT`, or `PATCH` methods)
    we can also read the entire body of the request and manually parse its content.
    This can be useful, for instance, if we need to handle requests that have a format
    other than JSON (which, as said before, is the only one supported by default).
  prefs: []
  type: TYPE_NORMAL
- en: If the `BindAsync` method returns `null`, while the corresponding route handler
    parameter cannot assume this value (as in the previous example), we will get an
    `HttpBadRequestException` error, which. as usual, will be wrapped in a `400 Bad
    Request` response.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn’t define both the `TryParse` and `BindAsync` methods using a type;
    if both are present, `BindAsync` always has precedence (that is, `TryParse` will
    never be invoked).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at parameter binding and understood how to use it and
    customize its behavior, let’s see how to work with responses in minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with controller-based projects, with route handlers of minimal APIs as well,
    we can directly return a string or a class (either synchronously or asynchronously):'
  prefs: []
  type: TYPE_NORMAL
- en: If we return a string (as in the examples of the previous section), the framework
    writes the string directly to the response, setting its content type to `text/plain`
    and the status code to `200 OK`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use a class, the object is serialized into the JSON format and sent to
    the response with the `application/json` content type and a `200 OK` status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, in a real application, we typically need to control the response type
    and the status code. In this case, we can use the static `Results` class, which
    allows us to return an instance of the `IResult` interface, which in minimal APIs
    acts how `IActionResult` does for controllers. For instance, we can use it to
    return a `201 Created` response rather than a `400 Bad Request` or a`404 Not Found`
    message. L et’s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each method of the `Results` class is responsible for setting the response type
    and status code that correspond to the meaning of the method itself (e.g., the
    `Results.NotFound()` method returns a `404 Not Found` response). Note that even
    if we typically need to return an object in the case of a `200 OK` response (with
    `Results.Ok()`), it isn’t the only method that allows this. Many other methods
    allow us to include a custom response; in all these cases, the response type will
    be set to `application/json` and the object will automatically be JSON-serialized.
  prefs: []
  type: TYPE_NORMAL
- en: The current version of minimal APIs does not support content negotiation. We
    only have a few methods that allow us to explicitly set the content type, when
    getting a file with `Results.Bytes()`, `Results.Stream()`, and `Results.File()`,
    or when using `Results.Text()` and `Results.Content()`. In all other cases, when
    we’re dealing with complex objects, the response will be in JSON format. This
    is a precise design choice since most developers rarely need to support other
    media types. By supporting only JSON without performing content negotiation, minimal
    APIs can be very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach isn’t enough in all scenarios. In some cases, we may
    need to create a custom response type, for example, if we want to return an HTML
    or XML response instead of the standard JSON. We can manually use the `Results.Content()`
    method (which allows us to specify the content as a simple string with a particular
    content type), but, if we have this requirement, it is better to implement a custom
    `IResult` type, so that the solution can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s suppose that we want to serialize objects in XML instead
    of JSON. We can then define an `XmlResult` class that implements the `IResult`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `IResult` interface requires us to implement the `ExecuteAsync` method,
    which receives the current `HttpContext` as an argument. We serialize the value
    using the `XmlSerializer` class and then write it to the response, specifying
    the correct response type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can directly use the new `XmlResult` type in our route handlers. However,
    best practices suggest that we create an extension method for the `IResultExtensions`
    interface, as with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we have a new `Xml` method available on the `Results.Extensions`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of this approach is that we can reuse it everywhere we need to deal
    with XML without having to manually handle the serialization and the response
    type (as we should have done using the `Result.Content()` method instead).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If we want to perform content validation, we need to manually check the `Accept`
    header of the `HttpRequest` object, which we can pass to our handlers, and then
    create the correct response accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: After analyzing how to properly handle responses in minimal APIs, we’ll see
    how to control the way our data is serialized and deserialized in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described in the previous sections, minimal APIs only provide built-in support
    for the JSON format. In particular, the framework uses `System.Text.Json` for
    serialization and deserialization. In controller-based APIs, we can change this
    default and use JSON.NET instead. This is not possible when working with minimal
    APIs: we can’t replace the serializer at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in serializer uses the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Case-insensitive property names during serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel case property naming policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for quoted numbers (JSON strings for number properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find more information about the `System.Text.Json` namespace and all
    the APIs it provides at the following link: [https://docs.microsoft.com/dotnet/api/system.text.json](https://docs.microsoft.com/dotnet/api/system.text.json).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In controller-based APIs, we can customize these settings by calling `AddJsonOptions()`
    fluently after `AddControllers()`. In minimal APIs, we can’t use this approach
    since we don’t have controllers at all, so we need to explicitly call the `Configure`
    method for `JsonOptions`. So, let’s consider this handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the default JSON options, we get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s configure `JsonOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the `/product` endpoint again, we’ll now get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `Description` property hasn’t been serialized because it is
    `null`, as well as `TotalPrice`, which isn’t included in the response because
    it is read-only.
  prefs: []
  type: TYPE_NORMAL
- en: Another typical use case for `JsonOptions` is when we want to add converters
    that will be automatically applied for each serialization or deserialization,
    for example, `JsonStrinEnumConverter` to convert enumeration values into or from
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the `JsonOptions` class used by minimal APIs is the one available
    in the `Microsoft.AspNetCore.Http.Json` namespace. Do not confuse it with the
    one that is defined in the `Microsoft.AspNetCore.Mvc` namespace; the name of the
    object is the same, but the latter is valid only for controllers, so it has no
    effect if set in a minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the JSON-only support, if we do not explicitly add support for other
    formats, as described in the previous sections (using, for example, the `BindAsync`
    method on a custom type), minimal APIs will automatically perform some validations
    on the body binding source and handle the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.3 – The response status codes for body binding problems ](img/Table_2.03_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.3 – The response status codes for body binding problems
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, because body validation fails, our route handlers will never
    be invoked, and we will get the response status codes shown in the preceding table
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have covered all the pillars that we need to start developing minimal
    APIs. However, there is another important thing to talk about: the correct way
    to design a real project to avoid common mistakes within the architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Architecting a minimal API project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to now, we have written route handlers directly in the `Program.cs` file.
    This is a perfectly supported scenario: with minimal APIs, we can write all our
    code inside this single file. In fact, almost all the samples show this solution.
    However, while this is allowed, we can easily imagine how this approach can lead
    to unstructured and therefore unmaintainable projects. If we have fewer endpoints,
    it is fine – otherwise, it is better to organize our handlers in separate files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following code right in the `Program.cs` file
    because we have to handle CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s easy to imagine that, if we have all the implementation here (even if
    we’re using `PeopleService` to extract the business logic), this file can easily
    explode. So, in real scenarios, the inline lambda approach isn’t the best practice.
    We should use the other methods that we have covered in the *Routing* section
    to define the handlers instead. So, it is a good idea to create an external class
    to hold all the route handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have grouped all the endpoint definitions inside the `PeopleHandler.MapEndpoints`
    static method, which takes the `IEndpointRouteBuilder` interface as an argument,
    which in turn is implemented by the `WebApplication` class. Then, instead of using
    lambda expressions, we have created separate methods for each handler, so that
    the code is much cleaner. In this way, to register all these handlers in our minimal
    API, we just need the following code in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Going forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach just shown allows us to better organize a minimal API project,
    but still requires that we explicitly add a line to `Program.cs` for every handler
    we want to define. Using an interface and a bit of **reflection**, we can create
    a straightforward and reusable solution to simplify our work with minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start by defining the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name implies, we need to make all our handlers (as with `PeopleHandler`
    previously) implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `MapEndpoints` method isn’t static anymore, because now it is the implementation
    of the `IEndpointRouteHandler` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a new extension method that, using reflection, scans an assembly
    for all the classes that implement this interface and automatically calls their
    `MapEndpoints` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to go into further detail about reflection and how it works in
    .NET, you can start by browsing the following page: [https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With all these pieces in place, the last thing to do is to call the extension
    method in the `Program.cs` file, before the `Run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this way, when we add new handlers, we should only need to create a new class
    that implements the `IEndpointRouteHandler` interface. No other changes will be
    required in `Program.cs` to add the new endpoints to the routing engine.
  prefs: []
  type: TYPE_NORMAL
- en: Writing route handlers in external files and thinking about a way to automate
    endpoint registrations so that `Program.cs` won’t grow for each feature addition
    is the right way to architect a minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core minimal APIs represent a new way of writing HTTP APIs in the .NET
    world. In this chapter, we covered all the pillars that we need to start developing
    minimal APIs, how to effectively approach them, and the best practices to take
    into consideration when deciding to follow this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll focus on some advanced concepts such as documenting
    APIs with Swagger, defining a correct error handling system, and integrating a
    minimal API with a single-page application.
  prefs: []
  type: TYPE_NORMAL
