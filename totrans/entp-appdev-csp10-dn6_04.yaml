- en: '*Chapter 3*: Introducing C# 10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is an elegant and type-safe object-oriented programming language that allows
    developers to build a wide range of secure and robust applications that run in
    the .NET ecosystem and is in the top 5 of the popular programming languages list
    published by GitHub.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: C# was initially developed by Anders Hejlsberg at Microsoft as part of the .NET
    initiative. Since its first release in January 2002, there have been new features
    added consistently to the language to improve performance and productivity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 10 released with .NET 6 comes with some cool new language features along
    with enhancements to the features released in earlier versions, which improve
    developer productivity. In this chapter, we will explore some of the new C# language
    features:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Simplification of the using directives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record structs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements to the Lambda expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancements to interpolated strings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended property patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additions to the caller argument attributes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By end of this chapter, you'll be familiar with the major new additions to C#
    10\. Also, this chapter will help us to upskill ourselves to build our next enterprise
    application in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to understand the concepts of this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 Community Edition with the .NET 6.0 runtime
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of Microsoft .NET
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Simplification of the using directives
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A top-level statement is a new feature introduced in C# 9.0, which makes it
    easy for developers to remove the ceremony code. The project templates that come
    with Visual Studio 2022 embrace the language changes introduced in C# such as
    top-level statements. For example, if you create a `Console` application, you
    will see the `Program.cs` file contains the code shown in the following snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code came with a `console` application template that did not have
    the ceremony code such as class definition and the `main` method. This simplified
    the number of lines we could write by removing the redundant code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The concepts of the `implicit` using directives and `global` using directives
    introduced in C# 10 reduce the repetition of the `using` statements in each CS
    file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The global using directives
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `global` `using` directives, we do not repeat the namespace `using`
    statements in all the `.cs` files. The `global` keyword is used to mark a `global`
    `using` directive as shown in the following code snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we marked `System.Threading` as `global`. Now, we can
    reference the types under `System.Threading` by having the `using` directive at
    the start of the `.cs` file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create `global` aliases to the namespaces to resolve the namespace
    conflicts, as shown in the following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By defining this, we can refer to all the classes defined under `System.Runtime.Serialization`
    using the alias name, `SRS`. We can also define a `global using static` directive
    as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this, we can use all the `static` functions defined in the `System.Console`
    class directly without referring to the class name. For example, to write a line
    to the console, we can just call the `WriteLine` method without referring to the
    `Console` class name, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can specify `global` `using` directives in any `.cs` file of the project.
    The only constraint is they should appear before any regular file-scoped using
    directives. The common practice seen among the developers is to create a `.cs`
    with the name `GlobalUsings.cs` and add the `global` `using` directive in that
    file. This will help to restrict the change to a single file when we need to add
    or remove a `global` `using` directive. The scope of the `global` `using` directives
    is the complication unit that is the current project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The implicit using directives
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C#, we find a few framework namespaces, such as `System` and `System.Linq`,
    are present in almost all the classes. With C# 10, these commonly-used namespaces
    are implicitly added as `global` using directives. The namespaces added implicitly
    are based on the project target SDK and are documented here: https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these, if we wish to include any other namespace to be part
    of these implicit directives or remove any of the predefined namespaces, we can
    do so by adding `ItemGroup` to the `.csproj` file, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous snippet, we are including `System.Threading` and removing `System.IO`
    from the `implicit` `using` directives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'To completely remove the `implicit` `using` directives, we can uncheck the
    `ImplicitUsings` flag in the `.csproj` file as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The simplification of `using` directives is another step toward removing the
    redundant ceremony code and making the content in the `.cs` files concise.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the `record` structs introduced with C#
    10.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The record structs
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *record types* introduced in C# 9 provide type declaration to create immutable
    reference types with synthesized methods for equality check and `ToString`. C#
    10 brings us the *record structs*. In this section, we will see what `record struct`
    is and how it is different from `record class`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `record` keyword to declare `record class`, and we use the same
    `record` keyword to declare `record struct`, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In C# 9, to declare a `record` class, we don''t explicitly use the `class`
    keyword. We simply specify `record` to declare it as shown here: `public` record
    `Shape(string Name);`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Simply using the `record` keyword will continue to work in C# 10 to declare
    a `record` class, but it is recommended to specify `class` or `struct` explicitly
    for better readability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`record struct` offers similar benefits to what `record class` offers, such
    as the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Simplified declaration syntax
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value equality
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference semantics
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deconstruction
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meaningful `ToString` output
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand these by creating a sample `Console` application and defining
    an `EmployeeRecord` record struct. Add the following code to the `Program.cs`
    file, which is using the `EmployeeRecord` record struct defined in the previous
    code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we are creating two instances of the `EmployeeRecord`
    record struct with name field values using the simplified declaration syntax,
    then printing the hash code of the instance objects, and then checking the equality.
    Here, we are also deconstructing the fields from the `employee` object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the code, we see the output as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Output of record struct example'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B18507.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Output of record struct example
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the output, we observe that `ToString` is overridden to include
    the contents of the instance. As expected, the hash code of both instances is
    the same, as the field values are the same. In a regular struct, the hash code
    of the object is generated based on the first non-nullable field. In the `record`
    struct, the `GetHashCode` method is also overridden to include all the fields
    to generate the hash code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The `record` struct synthesizes the implementation of the `IEquatable<T>` interface.
    It also implements the `==` and `!=` operators. The regular struct does not have
    these operators implemented by default. The regular struct has the `Equals` method
    inherited from `ValueType`, which uses reflection to do the equality check. So,
    the synthesized equality check in the `record` struct is more performant. The
    `record` struct also synthesizes the `Deconstruct` method to populate the fields
    out of the object. If you take a closer look at the deconstruction code, you will
    notice the mixed declaration of the variables. We have `lastName` being declared
    during deconstruction, whereas `firstName` was declared in the preceding statement.
    This mixed declaration of variables is only possible in C#10 and above.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'When we disassemble the code in a disassembler tool such as ILSpy or Reflector,
    we see the generated code as shown in the following figure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Generated code of the Employee class'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B18507.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Generated code of the Employee class
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: You can install ILSpy from [https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy](https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look closely at the `Employee` type definition, we can see all the plumbing
    synthesized by the C# compiler for the `record struct` type. From this, we can
    understand that the `record` struct is basically a struct that implements the
    `IEquatable` interface and overrides the `GetHashCode` and `ToString` methods.
    You can overwrite the `ToString` method to create your own string representation
    for the record type. Beginning with C# 10, you can also mark the `ToString` override
    as sealed, which prevents the compiler from synthesizing a `ToString` method or
    derived types from overriding it. Sealing the `ToString` method in the base record
    type ensures that the string representation is consistent across all derived types.
    The compiler also provides the `Deconstruct` method, which is used to deconstruct
    the `record` struct into its component properties. Unlike `record` classes, the
    `record` structs are mutable. To make a `record` struct immutable, we can add
    a `readonly` modifier to the declaration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To change the fields of the `readonly record` struct, we can use the operator
    as shown here like with the `record` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this section, we have learned about the `record` struct introduced in C#
    10 and how it compares with the `record` class and regular struct. In the next
    section, let's learn about improvements to Lambda expressions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Improvements to Lambda expressions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Lambda expression is a way to represent an anonymous method. It allows us
    to define the method implementation inline.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: A delegate type may be created from any Lambda expression. The types of a Lambda
    expression's parameters and return value determine the delegate type to which
    it can be transformed. A Lambda expression can be changed to an `Action` delegate
    type if it doesn't return a value; otherwise, it can be converted to one of the
    `Func` delegate types. In this section, we will learn about the improvements C#
    10 brings to Lambda expressions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Inferring the expression type
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# language compiler will now infer the expression type if the parameter''s
    types are explicit and the return type can be inferred. For example, consider
    the following code snippet where we defined a Lambda expression to find the square
    of the given integer:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, the parameter `x` type is specified as `int` and the
    return type is inferred as `int` from the expression. If we mouse-hover on `var`
    in Visual Studio, we can see the inferred type of the `Square` Lambda expression,
    as shown in the next screenshot, which uses the `Func` delegate:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Inferred type of Square expression'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B18507.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Inferred type of Square expression
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code shown here, the compiler will use the `Action` delegate, as the
    expression return type is `void`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The inferred type will use `Func` or `Action` delegates if it is suitable.
    Otherwise, the compiler will synthesize a delegate type, for example, if the Lambda
    expression is taking a `ref` type, as shown in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The synthesized type for the previous expression will be an `anonymous` delegate
    type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will try to infer the return type based on the expression. Sometimes,
    it may not be possible to infer the type. We will get a compilation error if it
    is unable to infer the type information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Return types for Lambda expressions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In situations where it is not possible for the compiler to infer the return
    type, we can specify explicitly in C# 10\. Consider the following code snippet,
    where we have `record` classes of `Employee` and `Manager` inherited from a `Person`
    record class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `createExpression` term in the preceding code snippet creates an instance
    of an `Employee` or `Manager` type based on the condition passed in. In this situation,
    the compiler cannot infer the return type, which will result in a compilation
    error. With C#10, we can now explicitly specify the return type for a Lambda expression
    as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The expression type inferred for the preceding code is `Func<bool, Person>`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Adding attributes to Lambda expressions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from C# 10, we can add attributes to the Lambda expressions and their
    parameters and return types. The following code snippet defines a Lambda expression
    to retrieve employees for the given ID:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `GetEmployeeeById` expression has the `[Authorize]` attribute and the `id`
    parameter is attributed with `[FromRoute]`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Attributes on Lambda expressions don't have any effect when they are invoked,
    as the invocation is via the underlying delegate type. The attributes defined
    on Lambda expressions can be discovered via reflection.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The minimal API introduced with ASP.NET 6.0 is one of the driving factors behind
    these improvements. We will see the usage of this in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the improvements to the Lambda expressions;
    in the next section, we will see improvements to interpolated strings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements to interpolated strings
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost every application will have some sort of text processing. In .NET, there
    are many ways available for string manipulation, such as the `string` primitive
    type, `StringBuilder`, `ToString` overrides on types, String concatenation, and
    `string.Format`, which provides functionality to build a string from a composite
    format string. `String.Format` takes a format string and format items as input
    and generates the formatted string as depicted in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the previous code, the positions `{0}` and `{1}` in the format string will
    be filled with the `Greeting` and `Message` format items respectively passed in
    as arguments. To make it more friendly and readable, C# 6 added a new language
    syntax called **interpolated strings**, as shown in the following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When interpolated strings syntax is used, the .NET compiler generates the code
    that is best suited for the interpolated string to produce the same result.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a disassembler such as ILSpy or SharpLab to look at the generated code
    for the previous code snippet; it will look something like the following code
    snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[https://sharplab.io/](https://sharplab.io/) is a .NET code playground that
    shows the intermediate results of code compilation.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: For the `message` interpolated string, the code was generated using concatenation.
    For the second string, `messageWithVersion`, where a non-string literal is involved,
    the generated code uses `string.Format`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler did what was intended, but it had a few issues where the code
    was generated using `string.Format`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The compiler parsed the interpolated string to generate code with `string.Format`.
    The same string must be parsed by the .NET runtime also to find the literal positions.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The argument type of the literals in the `string.Format` method is `Object`.
    So, any value type used in `string.Format` involves boxing.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overload of `string.Format` takes a maximum of three arguments. Beyond three
    is served by the overload that takes `params object[]`. So, more than three arguments
    require the instantiation of an array.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `string.Format` accepts only the `Object` type, we cannot use `ref struct`
    types such as `Span<T>` and `ReadOnlySpan<char>`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `ToString` is called on the captured expression, multiple transient strings
    will be created.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the shortcomings mentioned here will be addressed with C# 10 by generating
    code with a series of appends to the string builder. For the same code that we
    discussed, if you look at the generated code in C# 10, it uses `DefaultInterpolatedStringHandler`
    as shown in the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For interpolated strings, instead of using `string.Format`, C# 10 compiler now
    uses `DefaultInterpolatedStringHandler`. In the previously-generated code, `DefaultInterpolatedStringHandler`
    is constructed by passing in the two arguments, the number of characters in the
    literal portion of the interpolated string, and the number of positions in the
    string to be filled. `AppendLiteral` or `AppendFormatted` are called to append
    the literal or to append the formatted string, respectively. With the introduction
    of interpolated string handlers, the concerns discussed previously were addressed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: For the same interpolated string code written in earlier versions of C#, there
    will be an improvement in the performance in C# 10\. We can also build our custom
    interpolated string handlers, which may be useful in situations when the data
    isn't going to be used as a string, or where conditional execution would be a
    logical fit for the target method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the improvements to the interpolated
    string, which gives us better performance over earlier versions. In the next section,
    let's learn about the extended property patterns.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Extended property patterns
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is a way to check an object's value or the value of a property
    having a full or partial match to a sequence. This is supported in C# in the form
    of `if…else` and `switch…case` statements. In modern languages, especially in
    functional programming languages such as F#, there is advanced support for pattern
    matching. With C# 7.0, new pattern matching concepts were introduced. Pattern
    matching provides a different way to express conditions to have more human-readable
    code. Pattern matching is being extended with every major release of C# since
    its introduction in C# 7.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let's learn about the extended property pattern introduced
    in C# 10.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In this code snippet, we have an object of the `Product` type, which contains
    the location of the product origin. Prior to C# 10, if we wanted to check whether
    the country of origin of this product was the USA, we would do something similar
    to the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With C# 10, we can access the extended properties to make it more readable,
    as shown in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, we are validating the `Country` property of `Location`
    using an extended property pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about extended property patterns. Let's learn
    about the new addition to `caller` argument attributes in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Addition to the caller argument attributes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# 5 first introduced `caller` argument attributes. They are `CallerMemberName`,
    `CallerFilePath`, and `CallerLineNumber`. These attributes make the compiler populate
    the method arguments in the generated code. They are used in various scenarios
    such as populating more data in the debug traces while firing an `OnNotifyPropertyChanged`
    event in the MVVM pattern. For example, consider the following code snippet, which
    defines a `Gift` model:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In the preceding `Gift` class definition, the `OnPropertyChanged` method is
    called every time the setter of the `Description` property is called. In the `OnProperyChanged`
    method implementation, we have the `propertyName` argument attributed with `CallerMemberName`.
    This will make the compiler generate a setter as shown in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this generated code, the argument to `OnProperyChanged` is auto-populated
    with the property name, `Description`, by the compiler. This is a handy feature
    for the developer that helps to write error-free code. The other two `caller`
    argument attributes, `CallerFilePath` and `CallerLineNumber`, populate the file
    path of the `caller` method and line number respectively.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '`CallerArgumentExpression` is a new addition to these in C# 10\. As the name
    suggests, the attribute makes the compiler auto-populate the argument expression.
    Let''s build a simple argument validation helper class that does the `null` check
    for the parameters passed. Consider the following implementation of an `ArgumentValidation`
    class, which implements a helper method that throws `ArgumentException` if the
    argument value is `null`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In the `ThrowIfNull` method, we are performing the `null` check and throwing
    `ArgumentException` with the details including the parameter name, which is picked
    from `CallerArgumentExpression`. We can use the preceding helper class to perform
    the `null` check on the arguments passed to a method. For example, consider the
    following method, which adds the passed-in product to the cart:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In this method, we use the `ArgumentValidation` helper class to check the `null`
    condition of the `product` argument. The generated code for the call to the `ThrowIfNull`
    helper method will be `ArgumentValidation.ThrowIfNull(product, "product");`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The compiler auto-populated the parameter name in the string argument. Caller
    arguments will be useful where we want to add more details to the traces, which
    will help in troubleshooting the issue.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the major additions to the C# language
    features in version 10\. We have seen how C# 10 simplifies the code written with
    `implicit` and `global` using directives. We have learned about `record` structs
    and how they compare with the `record` class introduced in C# 9\. We have also
    learned about the improvements to Lambda expressions, expression type inference,
    and explicitly specifying the return type for the expression. We have also seen
    performance improvements in interpolated strings. We have also learned how to
    build throw helpers using the `CallerArgumentExpression` attribute.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'With this chapter, we have gained the skills to leverage these new features
    of C# 10 features in the enterprise e-commerce application that we are going to
    build in the coming chapters. In addition to these, there are a few more small
    enhancements. You can refer to the C# language documentation to learn more here:
    [https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10).
    We will be highlighting the new features of C# 10 and .NET 6 throughout this book
    while implementing different features of our e-commerce application.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming part, we will learn about the cross-cutting concerns that form
    the building blocks of our e-commerce application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习构成我们电子商务应用程序构建块的一些横切关注点。
- en: Questions
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'After reading the chapter, you should be able to answer the following questions:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你应该能够回答以下问题：
- en: 'True or false? Record structs are mutable:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误？记录结构体是可变的：
- en: a. True
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: a**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: Which keyword should you use to make a record struct immutable?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用哪个关键字来使记录结构体不可变？
- en: a. A record struct is immutable by default.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: a. 记录结构体默认是不可变的。
- en: b. `readonly`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: b. `readonly`.
- en: c. `finally`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: c. `finally`.
- en: d. `sealed`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: d. `sealed`.
- en: '**Answer: b**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: 'True or false? A compiler will infer the type expressions in all the scenarios:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误？编译器将在所有场景中推断类型表达式：
- en: a. True
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: b**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: In which version of C# were caller argument attributes first introduced?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪个版本的 C# 中首次引入了调用者参数属性？
- en: a. C# 9
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: a. C# 9
- en: b. C# 8
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: b. C# 8
- en: c. C# 5
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: c. C# 5
- en: d. C# 7
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: d. C# 7
- en: '**Answer: c**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
