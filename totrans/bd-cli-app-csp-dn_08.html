<html><head></head><body>
		<div id="_idContainer116">
			<h1 id="_idParaDest-117" class="chapter-number"><a id="_idTextAnchor120"/>8</h1>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor121"/>Building Modular and Extensible CLI Applications</h1>
			<p>Throughout the pages of this book, we have added more and more functionalities to <strong class="bold">Bookmarkr</strong>, our beloved <span class="No-Break">CLI application.</span></p>
			<p>The problem is that we have also added more and more lines of code to the <strong class="source-inline">Program.cs</strong> file. The length of this file has grown from 191 lines of code by the end of <a href="B22400_03.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> to 479 lines of code by the end of <a href="B22400_07.xhtml#_idTextAnchor105"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
			<p>In this chapter, we will take a step back and refactor our code to make it more modular. This will make it easier to extend, test, <span class="No-Break">and maintain.</span></p>
			<p>Refactoring is an essential part of the development life cycle. It should happen periodically in order to ensure that the quality of code is up to <span class="No-Break">the standards.</span></p>
			<p>By taking this necessary step, we will greatly simplify adding more features, enhance the readability and stability of our application, and even introduce testability <span class="No-Break">into it.</span></p>
			<p>More specifically, in this chapter, weâ€™ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Building the code map of the <span class="No-Break">current application</span></li>
				<li>Deciding where to <span class="No-Break">start refactoring</span></li>
				<li>Designing the project structure to <span class="No-Break">support refactoring</span></li>
				<li>Refactoring <span class="No-Break">a command</span></li>
				<li>Applying the dependency <span class="No-Break">inversion principle</span></li>
				<li>Refactoring the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class</span></li>
				<li>Running the program to validate that the refactoring didnâ€™t <span class="No-Break">break anything</span></li>
				<li>Pushing our refactoring to <span class="No-Break">new boundaries</span></li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor122"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor123"/>Step 1 â€“ building a code map of the application</h1>
			<p>The first <a id="_idIndexMarker247"/>thing when you refactor an application is to get to know what you are about to refactor. This means having a high-level view of the application and its dependencies. This helps you visualize all the moving parts involved and better plan your refactoring activities by identifying where <span class="No-Break">to start.</span></p>
			<p>If you have Visual Studio Enterprise edition, you can use its great architecture capabilities (such as code maps and dependency graphs) to visualize your code and its dependencies. However, since we are using Visual Studio Code (or if you donâ€™t have the Enterprise edition of Visual Studio), we can do <span class="No-Break">something elseâ€¦</span></p>
			<p>Sure, we can run through the code and identify every moving part of it, but since this is a CLI application, letâ€™s do something <span class="No-Break">smarter. </span><span class="No-Break">ğŸ˜‰</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor124"/>Using the Help menu to build the code map</h2>
			<p>The <strong class="bold">Help</strong> menu that <a id="_idIndexMarker248"/>comes out of the box with <strong class="source-inline">System.CommandLine</strong> is certainly great for learning how to use the application, but it is also great for figuring out the code map of <span class="No-Break">the application.</span></p>
			<p>Letâ€™s start by displaying the help menu at the root command by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet run -- -h</pre>			<p>We will get <span class="No-Break">this result:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B22400_08_01.jpg" alt="Figure 8.1 â€“ The help menu of the root command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 â€“ The help menu of the root command</p>
			<p>Next, we will <a id="_idIndexMarker249"/>repeat this operation (aka displaying the help menu) for each of the subcommands of the root command, then for each subcommand of every subcommand, then forâ€¦ Okay, you get the <span class="No-Break">idea! </span><span class="No-Break">ğŸ˜‰</span></p>
			<p>Here is an example of the <span class="No-Break"><strong class="source-inline">link</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B22400_08_02.jpg" alt="Figure 8.2 â€“ The help menu of the link command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 â€“ The help menu of the link command</p>
			<p>When should we stop? Well, when the current command has no more subcommands. Here is an example with the <strong class="source-inline">link </strong><span class="No-Break"><strong class="source-inline">add</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B22400_08_03.jpg" alt="Figure 8.3 â€“ The help menu of the link add command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 â€“ The help menu of the link add command</p>
			<p>After<a id="_idIndexMarker250"/> completing this exercise, we will get the following <span class="No-Break">code map:</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B22400_08_04.jpg" alt="Figure 8.4 â€“ The code map of the Bookmarkr application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 â€“ The code map of the Bookmarkr application</p>
			<p>Okay, now that we have a clearer view of the moving parts in our application, what should we <span class="No-Break">do next?</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor125"/>Step 2 â€“ deciding where to start</h1>
			<p>Itâ€™s now time to decide what to <span class="No-Break">refactor first.</span></p>
			<p>I would recommend not to start with the root command first, but rather with the subcommands of that <span class="No-Break">root command.</span></p>
			<p>There is no right or wrong decision from there. You can pick up any subcommand you would like to start with. We will take the <strong class="source-inline">export</strong> command as an example in the remainder of <span class="No-Break">this chapter.</span></p>
			<p>Although the <strong class="source-inline">export</strong> command does not have a subcommand, it will still help us lay out the foundation of the refactored version of <em class="italic">Bookmarkr</em>. More specifically, it will help us do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Define the project structure to support <span class="No-Break">our refactoring</span></li>
				<li>Refactor it and hide its â€œcomplexityâ€ (aka moving parts to the <span class="No-Break">root command)</span></li>
				<li>Refactor the <strong class="source-inline">Program</strong> class and make it leaner, cleaner, and <span class="No-Break">more concise</span></li>
				<li>Set up dependency injection for interacting between commands and external services (such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">BookmarkService</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Letâ€™s start with designing the project structure that will support our <span class="No-Break">refactoring activities.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor126"/>Step 3 â€“ designing the project structure</h1>
			<p>Although<a id="_idIndexMarker251"/> one can design their project structure according to their tastes, I design mine in a way that makes it easy for whoever looks at my project to understand what it does and where each moving part <span class="No-Break">is located.</span></p>
			<p>Following this principle, all commands will be grouped in a folder named <strong class="source-inline">Commands</strong>. This folder will be created at the root of the <span class="No-Break">project structure.</span></p>
			<p>Since we will be refactoring the <strong class="source-inline">export</strong> command, letâ€™s create a subfolder named <strong class="source-inline">Export</strong> where all the code artifacts involved in the <strong class="source-inline">export</strong> command will <span class="No-Break">be located.</span></p>
			<p>Once we start refactoring another command, we will create a specific folder <span class="No-Break">for it.</span></p>
			<p class="callout-heading">What about subcommands of a command?</p>
			<p class="callout">Following the principle<a id="_idIndexMarker252"/> of <strong class="bold">encapsulation</strong> in object-oriented programming, and since a subcommand can only be invoked through its parent command, I recommend locating subcommands in the same folder as their <span class="No-Break">parent command.</span></p>
			<p class="callout">An example of that is the <strong class="source-inline">link add</strong> command. The <strong class="source-inline">add</strong> subcommand can only be called through its parent (<strong class="source-inline">link</strong>) command. Hence, their life cycles are closely related to <span class="No-Break">each other.</span></p>
			<p class="callout">For that matter, the code artifact of the <strong class="source-inline">add</strong> command will be located close to the code artifact of its parent command (<strong class="source-inline">link</strong>), within the <span class="No-Break"><strong class="source-inline">Link</strong></span><span class="No-Break"> folder.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor127"/>Step 4 â€“ refactoring the export command</h1>
			<p>Within<a id="_idIndexMarker253"/> the <strong class="source-inline">Export</strong> folder, letâ€™s create a new C# file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">ExportCommand.cs</strong></span><span class="No-Break">.</span></p>
			<p>Every command class (including <strong class="source-inline">RootCommand</strong>) derives from the <strong class="source-inline">Command</strong> base class. Furthermore, that base class provides an <strong class="source-inline">AddCommand</strong> method that takes a parameter of the <strong class="source-inline">Command</strong> type, which also means any class that derives from the <span class="No-Break"><strong class="source-inline">Command</strong></span><span class="No-Break"> class.</span></p>
			<p>Armed with this, we can start refactoring the <strong class="source-inline">export</strong> command by making the <strong class="source-inline">ExportCommand</strong> class derive <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Command</strong></span><span class="No-Break">.</span></p>
			<p>After importing the required <strong class="source-inline">using</strong> statement, specifying the <strong class="source-inline">namespace</strong> name, and adding the required class constructor, the first iteration of our class looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using System.CommandLine;
namespace bookmarkr.Commands;
public class ExportCommand : Command
{
Â Â Â Â #region Constructor
Â Â Â Â public ExportCommand(string name, string? description = null)
Â Â Â Â Â Â Â Â : base(name, description)
Â Â Â Â {
Â Â Â Â }
Â Â Â Â #endregion
}</pre>			<p>The first <a id="_idIndexMarker254"/>things to move into this class are the options. The <strong class="source-inline">export</strong> command has only one <span class="No-Break">option, </span><span class="No-Break"><strong class="source-inline">outputfileOption</strong></span><span class="No-Break">.</span></p>
			<p>I like the fact that every component of my class is well-segmented. Thatâ€™s why I am a fan of regions. For that reason, letâ€™s add a region dedicated to options and move the code for the <strong class="source-inline">outputfileOption</strong> option within <span class="No-Break">this region.</span></p>
			<p>The code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
#region Options
private Option&lt;FileInfo&gt; outputfileOption = new Option&lt;FileInfo&gt;(
Â Â Â Â ["--file", "-f"],
Â Â Â Â "The output file that will store the bookmarks"
)
{
Â Â Â Â IsRequired = true
}.LegalFileNamesOnly();
#endregion</pre>			<p>We then need to associate this option with the command. We will do this by calling the <strong class="source-inline">AddOption</strong> method from within the constructor body, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
#region Constructor
public ExportCommand(string name, string? description = null)
Â Â Â Â : base(name, description)
{
Â Â Â Â AddOption(outputfileOption);
}
#endregion</pre>			<p>The next<a id="_idIndexMarker255"/> thing to move is the call to the <strong class="source-inline">SetHandler</strong> method, which connects the command to its handler method. So, the updated version of the constructor looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
#region Constructor
public ExportCommand(string name, string? description = null)
Â Â Â Â : base(name, description)
{
Â Â Â Â AddOption(outputfileOption);
Â Â Â Â this.SetHandler(async (context) =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â FileInfo? outputfileOptionValue = context.ParseResult.
Â Â Â Â Â Â Â Â GetValueForOption(outputfileOption);
Â Â Â Â Â Â Â Â var token = context.GetCancellationToken();
Â Â Â Â Â Â Â Â await OnExportCommand(outputfileOptionValue!, token);
Â Â Â Â });
}
#endregion</pre>			<p>Finally, the <a id="_idIndexMarker256"/>last piece of code to move into the new class is the command handler method. Once again, we will create a new region for that and move that final piece of code. We will also change the <strong class="source-inline">static</strong> modifier to <strong class="source-inline">private</strong>. The reason is that the class is not static (hence the removal of the <strong class="source-inline">static</strong> keyword) and the command handler method is private to that class (hence the use of the <span class="No-Break"><strong class="source-inline">private</strong></span><span class="No-Break"> keyword):</span></p>
			<pre class="source-code">
#region Handler method
private async Task OnExportCommand(FileInfo outputfile,
Â Â Â Â CancellationToken token)
{
Â Â Â Â // method body removed for brevity.
Â Â Â Â // It is exactly similar to the one from the previous chapters.
}
#endregion</pre>			<p>If you are typing (or copying and pasting ğŸ˜‰) the code along the way, you can see at this point that the code does not compile because of <span class="No-Break">two errors.</span></p>
			<p>The first one is straightforward to solve. It suffices to add the following statement at the top of the <span class="No-Break">C# file:</span></p>
			<pre class="source-code">
using System.Text.Json;</pre>			<p>The second one is less obvious to solve. It indicates that the class canâ€™t find an instance of the <span class="No-Break"><strong class="source-inline">BookmarkService</strong></span><span class="No-Break"> class.</span></p>
			<p>Of course, we could simply create an instance of that service within the current class. However, since <strong class="source-inline">BookmarkService</strong> is an external dependency to the <strong class="source-inline">ExportCommand</strong> class, doing so will break the principle of <strong class="bold">dependency inversion</strong> advocated by <span class="No-Break">object-oriented programming.</span></p>
			<p>As a reminder, the<a id="_idIndexMarker257"/> principle of dependency inversion is one of the five SOLID principles of object-oriented programming and design. It states that high-level modules should not depend on low-level modules; both should depend on abstractions. Additionally, abstractions should not depend on details; details should depend on abstractions. This principle helps to decouple software modules, making the system more modular, flexible, and easier <span class="No-Break">to maintain.</span></p>
			<p>What does that practically mean? It means that we should inject an instance of <strong class="source-inline">BookmarkService</strong> into the <span class="No-Break"><strong class="source-inline">ExportCommand</strong></span><span class="No-Break"> class.</span></p>
			<p>Letâ€™s <span class="No-Break">do this!</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor128"/>Step 5 â€“ applying the dependency inversion principle</h1>
			<p>If you are<a id="_idIndexMarker258"/> familiar with the dependency inversion principle, you will certainly have already noticed that the <strong class="source-inline">BookmarkService</strong> class does not implement <span class="No-Break">any interface.</span></p>
			<p>Letâ€™s start by <span class="No-Break">fixing this.</span></p>
			<p class="callout-heading">I am not familiar with the dependency inversion principle!</p>
			<p class="callout">If you are not, there are plenty of great resources to explore this principle. It is not a complicated principle to understand, and quite frankly, after you learn about it, it will seem so obvious to you that you will be wondering why you did not know about <span class="No-Break">it earlier.</span></p>
			<p class="callout">A great explanation of that principle can be found <span class="No-Break">at </span><a href="https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/"><span class="No-Break">https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/</span></a><span class="No-Break">.</span></p>
			<p class="callout">I highly encourage you to go and review the implementation of the <strong class="source-inline">BookmarkService</strong> service before and after applying the dependency inversion principle in order to have a clear understanding of <span class="No-Break">the benefits.</span></p>
			<p>Back to our project structure discussion, we will start by creating a new folder called <strong class="source-inline">Services</strong> that will group all our services classes. Within that folder, letâ€™s create a specific folder for every service. In our case, we only have one service, so letâ€™s create the <strong class="source-inline">BookmarkService</strong> folder. This <a id="_idIndexMarker259"/>folder will contain both the interface and the concrete implementation of <span class="No-Break">our service.</span></p>
			<p>The folder structure for our service will then look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B22400_08_05.jpg" alt="Figure 8.5 â€“ The folder structure for the BookmarkService service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 â€“ The folder structure for the BookmarkService service</p>
			<p>Next, letâ€™s extract the <strong class="source-inline">IBookmarkService</strong> interface out of the <strong class="source-inline">BookmarkService</strong> class. The code for that interface looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
namespace bookmarkr.Services;
public interface IBookmarkService
{
Â Â Â Â void AddLink(string name, string url, string category);
Â Â Â Â void AddLinks(string[] names, string[] urls, string[] categories);
Â Â Â Â void ListAll();
Â Â Â Â List&lt;Bookmark&gt; GetAll();
Â Â Â Â void Import(List&lt;Bookmark&gt; bookmarks);
Â Â Â Â BookmarkConflictModel? Import(Bookmark bookmark);
Â Â Â Â List&lt;Bookmark&gt; GetBookmarksByCategory(string category);
}</pre>			<p>Now, letâ€™s <a id="_idIndexMarker260"/>make the <strong class="source-inline">BookmarkService</strong> class implement the <span class="No-Break"><strong class="source-inline">IBookmarkService</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
namespace bookmarkr.Services;
public class BookmarkService : IBookmarkService
{
Â Â Â Â // method body removed for brevity.
Â Â Â Â // It is exactly similar to the one from the previous chapters.
}</pre>			<p>Notice that we changed the namespace name for these artifacts in order to better convey <span class="No-Break">their intention.</span></p>
			<p>All that is left to do now is to inject that service into the <strong class="source-inline">ExportCommand</strong> class. This means <span class="No-Break">two things:</span></p>
			<ol>
				<li>We will add a <strong class="source-inline">private</strong> property of the <strong class="source-inline">IBookmarkService</strong> type in the <strong class="source-inline">ExportCommand</strong> class that will allow us to invoke the methods of that service from within the command class (more specifically, from within the <span class="No-Break"><strong class="source-inline">OnExportCommand</strong></span><span class="No-Break"> method).</span></li>
				<li>We will inject an instance of that service through a <span class="No-Break">constructor parameter.</span></li>
			</ol>
			<p>The updated code of the <strong class="source-inline">ExportCommand</strong> class looks like <span class="No-Break">this now:</span></p>
			<pre class="source-code">
using System.CommandLine;
using System.Text.Json;
using bookmarkr.Services;
namespace bookmarkr.Commands;
public class ExportCommand : Command
{
Â Â Â Â #region Properties
Â Â Â Â private IBookmarkService _service;
Â Â Â Â #endregion
Â Â Â Â #region Constructor
Â Â Â Â public ExportCommand(IBookmarkService service, string name, 
Â Â Â Â string? description = null)
Â Â Â Â Â Â Â Â : base(name, description)
Â Â Â Â {
Â Â Â Â Â Â Â Â _service = service;
Â Â Â Â Â Â Â Â AddOption(outputfileOption);
Â Â Â Â Â Â Â Â this.SetHandler(async (context) =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â FileInfo? outputfileOptionValue = context.ParseResult.
Â Â Â Â Â Â Â Â Â Â Â Â GetValueForOption(outputfileOption);
Â Â Â Â Â Â Â Â Â Â Â Â var token = context.GetCancellationToken();
Â Â Â Â Â Â Â Â Â Â Â Â await OnExportCommand(outputfileOptionValue!, token);
Â Â Â Â Â Â Â Â });
Â Â Â Â }
Â Â Â Â #endregion
Â Â // The "Options" region hasn't changed and removed for brevity.
#region Handler method
Â Â Â Â private async Task OnExportCommand(FileInfo outputfile, 
Â Â Â Â CancellationToken token)
Â Â Â Â {
Â Â Â Â // â€¦
Â Â Â Â var bookmarks = _service.GetAll();
Â Â Â Â // â€¦
Â Â Â Â }
Â Â Â Â #endregion
}</pre>			<p>This code <a id="_idIndexMarker261"/>is very straightforward to understand and does not require any <span class="No-Break">particular explanation.</span></p>
			<p class="callout-heading">The dependency inversion principle may introduce complexity!</p>
			<p class="callout">Dependency injection can introduce some overhead in simple applications by requiring additional setup and configuration, such as adding extra interfaces, classes, and indirection, which can be unnecessary for straightforward projects with <span class="No-Break">few dependencies.</span></p>
			<p class="callout">Therefore, it is important to find a balance between applying this principle without adding too much complexity to the <span class="No-Break">code base.</span></p>
			<p>That is <a id="_idIndexMarker262"/>wonderful. We have come a long way since we started our <span class="No-Break">refactoring journey!</span></p>
			<p>There is one last piece of code we havenâ€™t refactored yet. It is the one for which we started this journey in the first place: the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class.</span></p>
			<p>Letâ€™s turn our attention to this <span class="No-Break">class nowâ€¦</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor129"/>Step 6 â€“ refactoring the Program class</h1>
			<p>By<a id="_idIndexMarker263"/> refactoring the commands into their dedicated classes, the code to create and handle these commands will be removed from the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class.</span></p>
			<p>Hence, the <strong class="source-inline">Program</strong> class will now only be used to compose our application. More specifically, the <strong class="source-inline">Program</strong> class will do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Instantiate the root command and register <span class="No-Break">its subcommands.</span></li>
				<li>Instantiate and configure the <strong class="source-inline">CommandLineBuilder</strong> class and start <span class="No-Break">the program.</span></li>
				<li><span class="No-Break">Configure logging.</span></li>
				<li>Configure dependency injection of the <span class="No-Break"><strong class="source-inline">BookmarkService</strong></span><span class="No-Break"> service.</span></li>
			</ol>
			<p>Here is the refactored code for the <strong class="source-inline">Program</strong> class (note that some parts of the code, including <strong class="source-inline">using</strong> statements, are not listed here for brevity <span class="No-Break">and clarity):</span></p>
			<pre class="source-code">
using Microsoft.Extensions.DependencyInjection;
class Program
{
Â Â Â Â static async Task&lt;int&gt; Main(string[] args)
Â Â Â Â {
Â Â Â Â Â Â Â Â FreeSerilogLoggerOnShutdown();
Â Â Â Â Â Â Â Â /** DECLARE A VARIABLE FOR THE IBookmarkService **/
Â Â Â Â Â Â Â Â IBookmarkService _service;
Â Â Â Â Â Â Â Â /** INSTANTIATE THE ROOT COMMAND **/
Â Â Â Â Â Â Â Â var rootCommand = new RootCommand(
Â Â Â Â Â Â Â Â Â Â Â Â "Bookmarkr is a bookmark manager provided as a CLI 
Â Â Â Â Â Â Â Â Â Â Â Â application.")
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â rootCommand.SetHandler(OnHandleRootCommand);
Â Â Â Â Â Â Â Â /** CONFIGURE DEPENDENCY INJECTION FOR THE IBookmarkService 
Â Â Â Â Â Â Â Â **/
Â Â Â Â Â Â Â Â var host = Host.CreateDefaultBuilder(args)
Â Â Â Â Â Â Â Â Â Â Â Â .ConfigureServices((hostContext, services) =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Register your services here
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â services.AddSingleton&lt;IBookmarkService, 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â BookmarkService&gt;();
Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â .Build();
Â Â Â Â Â Â Â Â _service = host.Services.GetRequiredService&lt;IBookmarkService&gt;();
Â Â Â Â Â Â Â Â /** REGISTER SUBCOMMANDS OF THE ROOT COMMAND **/
Â Â Â Â Â Â Â Â rootCommand.AddCommand(new ExportCommand(_service, "export", 
Â Â Â Â Â Â Â Â "Exports all bookmarks to a file"));
Â Â Â Â Â Â Â Â /** THE BUILDER PATTERN **/
Â Â Â Â Â Â Â Â // code removed for brevity.
Â Â Â Â }
Â Â Â Â /** HANDLER OF THE ROOT COMMAND **/
Â Â Â Â static void OnHandleRootCommand()
Â Â Â Â {
Â Â Â Â Â Â Â Â Console.WriteLine("Hello from the root command!");
Â Â Â Â }
Â Â Â Â static void FreeSerilogLoggerOnShutdown()
Â Â Â Â {
Â Â Â Â Â Â Â Â // code removed for brevity.
Â Â Â Â }
Â Â Â Â static void ExecuteShutdownTasks()
Â Â Â Â {
Â Â Â Â Â Â Â Â // code removed for brevity.
Â Â Â Â }
}</pre>			<p>This code is mostly straightforward <span class="No-Break">to understand.</span></p>
			<p>The <a id="_idIndexMarker264"/>only part that is worth an explanation is how we perform dependency injection of services (here, <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">BookmarkService</strong></span><span class="No-Break">):</span></p>
			<ul>
				<li>We declare a variable of the <strong class="source-inline">IBookmarkService</strong> type that will be used to retrieve an instance of the <span class="No-Break">injected service.</span></li>
				<li>We configure the dependency injection by leveraging the <strong class="source-inline">HostBuilder</strong> class provided by .NET and registering services to the <span class="No-Break"><strong class="source-inline">IServiceCollection</strong></span><span class="No-Break"> collection.</span></li>
				<li>We retrieve the instance of the registered services by calling <strong class="source-inline">GetRequiredService</strong> on the <strong class="source-inline">IServiceCollection</strong> collection and store a reference to the retrieved service into the variable we <span class="No-Break">declared earlier.</span></li>
				<li>When creating an instance of a new command, we pass that variable as a parameter to the commandâ€™s constructor so that the new command receives an instance of <span class="No-Break">the service.</span></li>
			</ul>
			<p>And voila! The service is automatically instantiated and injected into the various commands that <span class="No-Break">require it.</span></p>
			<p>Whatâ€™s great about this approach is that if we need to change the service implementation, all we need to do is modify the service registration to <strong class="source-inline">IServiceCollection</strong> and the rest will be magically taken <span class="No-Break">care of.</span></p>
			<p>Note how the <strong class="source-inline">Program.cs</strong> file has shrunk from 479 lines of code to 115 lines <span class="No-Break">of code!</span></p>
			<p>And the best part? Registering a new command to the root command is a matter of one extra line of code (aka, calling <strong class="source-inline">AddCommand</strong> on the root command and passing an instance of the new command to be registered), while injecting a new service is a matter of two lines of code: one for adding the service into the services collection and the other for getting a reference to that service in order to pass it to classes that <span class="No-Break">require it.</span></p>
			<p class="callout-heading">Beware of the pitfalls!</p>
			<p class="callout">Common pitfalls in dependency injection include circular dependencies, where classes depend on each other, and unintended singleton behavior, which can arise from improper service lifetimes. Over-injection of dependencies can violate the Single-Responsibility Principle, while excessive reliance on service locators complicates testing. To avoid these issues, itâ€™s crucial to manage service lifetimes carefully and follow <span class="No-Break">best practices.</span></p>
			<p class="callout">I highly recommend that you check out the reading recommendations in <a href="B22400_14.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 14</em></span></a> in order to explore this topic more deeply <span class="No-Break">when necessary.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Step 7 â€“ running the program</h1>
			<p>Perfect! We <a id="_idIndexMarker265"/>have completed the refactoring of the <strong class="source-inline">export</strong> command. Letâ€™s run the code to ensure that it still works <span class="No-Break">as expected.</span></p>
			<p>The syntax to invoke the <strong class="source-inline">export</strong> command hasnâ€™t changed. So, letâ€™s invoke it the same way as before by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet run export --file 'bookmarks33.json'</pre>			<p>We will get the <span class="No-Break">following results:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B22400_08_06.jpg" alt="Figure 8.6 â€“ Invoking the export command after refactoring"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 â€“ Invoking the export command after refactoring</p>
			<p>Wonderful! The application still works <span class="No-Break">as expected.</span></p>
			<p>We have done a lot of refactoring to our application so far. But is that all? Or can we take it to <span class="No-Break">another level?</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor131"/>Taking refactoring to new heights</h1>
			<p>You may have been wondering why we didnâ€™t extract options and handler methods into their own code artifacts (such <span class="No-Break">as classes).</span></p>
			<p>The reason is that options and handler methods (and also arguments) are usually unique to a specific command. For this reason, they are defined in the <span class="No-Break">command class.</span></p>
			<p>However, in situations where they would need to be used by more than one command, we would have extracted them into their own code artifact. This reasoning is important to keep in mind in order to avoid over-complexifying our design by <span class="No-Break">over-abstracting it.</span></p>
			<p>In the case of an option, we <a id="_idIndexMarker266"/>would have created a dedicated class. Hereâ€™s an example of <strong class="source-inline">outputfileOption</strong> we used in our <span class="No-Break"><strong class="source-inline">ExportCommand</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
using System.CommandLine;
namespace bookmarkr.Options;
public class FileInfoOption : Option&lt;FileInfo&gt;
{
Â Â Â Â public FileInfoOption(string[] aliases, string? description = 
Â Â Â Â null, bool onlyAllowLegalFileNames = true, bool isRequired = true)
Â Â Â Â Â Â Â Â : base(aliases, description)
Â Â Â Â {
Â Â Â Â Â Â Â Â if(onlyAllowLegalFileNames == true)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â this.LegalFileNamesOnly();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â this.IsRequired = isRequired;
Â Â Â Â }
}</pre>			<p>We could then use this option in any command by creating an instance of it, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var outputfileOption = new FileInfoOption(["--file", "-f"], "The output file path");</pre>			<p>Here is how it <a id="_idIndexMarker267"/>would have looked <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">ExportCommand</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class ExportCommand : Command
{
Â Â Â Â #region Constructor
Â Â Â Â public ExportCommand(IBookmarkService service, string name, 
Â Â Â Â string? description = null)
Â Â Â Â Â Â Â Â : base(name, description)
Â Â Â Â {
Â Â Â Â Â Â Â Â _service = service;
Â Â Â Â Â Â Â Â outputfileOption = new FileInfoOption(["--file", "-f"], "The 
Â Â Â Â Â Â Â Â output file path");
Â Â Â Â Â Â Â Â AddOption(outputfileOption);
Â Â Â Â Â Â Â Â // remaining of the code removed for brevity.
Â Â Â Â }
Â Â Â Â #endregion
Â Â Â Â #region Options
Â Â Â Â private FileInfoOption outputfileOption;
Â Â Â Â #endregion
Â Â Â Â // remaining of the code removed for brevity.
}</pre>			<p>Pay special <a id="_idIndexMarker268"/>attention to how the <strong class="source-inline">outputfileOption</strong> property is declared (in the <strong class="source-inline">Options</strong> region) and how it is instantiated and initialized in the constructor. Its usage is no different <span class="No-Break">from before.</span></p>
			<p>In the case of a handler method, we would have created a base class that derives from <strong class="source-inline">Command</strong> (letâ€™s call it <strong class="source-inline">CommandWithBaseHandler</strong>), add the handler method to it (allowing it to be overridden), and make our command classes derive from that <strong class="source-inline">CommandWithBaseHandler</strong> class rather than from the <span class="No-Break"><strong class="source-inline">Command</strong></span><span class="No-Break"> class.</span></p>
			<p>The <strong class="source-inline">CommandWithBaseHandler</strong> class could have looked <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using System.CommandLine;
namespace bookmarkr.Commands.Base;
public class CommandWithBaseHandler : Command
{
Â Â Â Â public CommandWithBaseHandler(string name, string? description = 
Â Â Â Â null)
Â Â Â Â Â Â Â Â : base(name, description)
Â Â Â Â {
Â Â Â Â }
Â Â Â Â public virtual async Task OnExportCommand(FileInfo outputfile, 
Â Â Â Â CancellationToken token)
Â Â Â Â {
Â Â Â Â Â Â Â Â // method body removed for brevity.
Â Â Â Â }
}</pre>			<p>Notice that <a id="_idIndexMarker269"/>the <strong class="source-inline">OnExportCommand</strong> method has been marked as <strong class="source-inline">virtual</strong>. This means that it provides a default implementation in the <strong class="source-inline">CommandWithBaseHandler</strong> class but allows that implementation to be overridden <span class="No-Break">if needed.</span></p>
			<p>We could then have modified the <strong class="source-inline">ExportCommand</strong> class <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using System.CommandLine;
using System.Text.Json;
using bookmarkr.Services;
using bookmarkr.Options;
using bookmarkr.Commands.Base;
namespace bookmarkr.Commands;
public class ExportCommand : CommandWithBaseHandler
{
Â Â Â Â // the remaining code is not shown for brevity.
Â Â Â Â // the OnExportCommand method is removed from this class since it 
Â Â Â Â // has been moved to the CommandWithBaseHandler base class.
}</pre>			<p>Perfect! But <a id="_idIndexMarker270"/>where would these new code artifacts fit into our project structure? <span class="No-Break">Great question!</span></p>
			<p>Letâ€™s update our project structure to accommodate these <span class="No-Break">new artifacts.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor132"/>Updating the project structure</h2>
			<p>Following <a id="_idIndexMarker271"/>the same principle regarding project structure that we applied so far, I suggest <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B22400_08_07.jpg" alt="Figure 8.7 â€“ The project structure for commands"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 â€“ The project structure for commands</p>
			<p>Awesome! We now have an application that is more modular and easily extensible. Everything has its own place so itâ€™s easier to read and navigate the <span class="No-Break">applicationâ€™s code.</span></p>
			<p class="callout-heading">Wait, extensible?!</p>
			<p class="callout">You may not have noticed, but the refactoring exercise we have done throughout this chapter not only enhanced our application from a modularity standpoint but also from an <span class="No-Break">extensibility standpoint.</span></p>
			<p class="callout">Think about it: we can now easily involve other teammates in the development of our application, making delivering new features to our users <span class="No-Break">even faster.</span></p>
			<p class="callout">Every team member can focus on their very own command, impacting only a small subset of code artifacts and, in most cases, they wonâ€™t modify the same files, reducing the number of merge conflicts that may occur when pushing their code into the <span class="No-Break">source control.</span></p>
			<p>This<a id="_idIndexMarker272"/> refactoring also allows to speed up the onboarding process of new team members. Since every code artifact has its proper place, the code is easier to understand and to own. If you are looking for contributors to your application, this is a very important point to keep <span class="No-Break">in mind!</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor133"/>Summary</h1>
			<p>In this chapter, we refactored <em class="italic">Bookmarkr</em> to make it more modular. Each command is now described in its own <span class="No-Break">code file.</span></p>
			<p>By taking the time to refactor our CLI application, we have greatly enhanced its readability, maintainability, testability, and extensibility. It is now easier to add new capabilities, such as new commands (of course) as well as new features to <span class="No-Break">existing commands.</span></p>
			<p>Speaking about that, in the next chapter, we will see how to call external services and APIs to extend the capabilities of <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor134"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the <em class="italic">Bookmarkr</em> application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor135"/>Task #1 â€“ refactor the remaining commands</h2>
			<p>Even though this chapter proposes only one challenge, it will require effort on <span class="No-Break">your side!</span></p>
			<p>Throughout the pages of this chapter, we have refactored the <strong class="source-inline">export</strong> command. You are now tasked with refactoring the other commands of the <span class="No-Break"><em class="italic">Bookmarkr</em></span><span class="No-Break"> application.</span></p>
			<p>For that matter, you can follow the same strategy and steps we used in our previous refactoring activity. By practicing it again and again, you will gain mastery of <span class="No-Break">this process.</span></p>
			<p>You will find the version of the code that hasnâ€™t been refactored in the <span class="No-Break"><strong class="source-inline">Program.Unrefactored.cs</strong></span><span class="No-Break"> file.</span></p>
			<p>Letâ€™s <span class="No-Break">do this!</span></p>
		</div>
	</body></html>