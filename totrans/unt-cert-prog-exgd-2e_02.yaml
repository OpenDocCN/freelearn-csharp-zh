- en: '*Chapter 2*: Adding and Manipulating Objects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the importance of the Official Unity Programmer
    exam and what benefits it can produce for any developer who is looking to reassure
    either themselves or others in understanding programming in Unity. We also discussed
    the building blocks of being a programmer in general and our game's design brief.
  prefs: []
  type: TYPE_NORMAL
- en: As we are programmers working on a game engine, it is likely you will be working
    for a range of industries. In many of these industries, you will be issued with
    a technical brief/documentation (well, you should be!) for building an application.
    With this project, we are making a game, and the game design brief is effectively
    the blueprint for making this game. In this chapter, we will be applying the majority
    of our code, game objects, prefabs, and more based on the guidance of the brief
    and the game framework. We will be reminding ourselves of the brief and game framework
    during this chapter and will transfer specific information into our code.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to our code, we will be covering the importance of interfaces and
    scriptable objects to help structure and uniform our code, preventing it from
    bloating unnecessarily, which we covered in [*Chapter 1*](B18381_01_Epub.xhtml#_idTextAnchor016),
    *Setting Up and Structuring Our Project*, with SOLID principles. We will also
    be getting used to the Unity Editor and becoming familiar with game objects, prefabs,
    and importing three-dimensional models to animate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Unity project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing our interface (`IActorTemplate`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing our `ScriptableObject` (`SOActorModel`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our `Player`, `PlayerSpawner`, and `PlayerBullet` scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning and creating our enemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our `EnemySpawner` and enemy script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section will outline the exam objectives covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Core exam skills covered in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Programming core interactions*:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement and configure game object behavior and physics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and configure input and controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and configure camera views and movement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working in the art pipeline*:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand lighting and write scripts that interact with Unity's lighting API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand two- and three-dimensional animation and write scripts that interact
    with Unity's animation API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Programming for scene and environment design*:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify methods for implementing game object instantiation, destruction, and
    management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate knowledge of developer testing and its impact on the software development
    process, including Unity Profiler and traditional debugging and testing techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize techniques for structuring scripts for modularity, readability, and
    re-usability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the entire chapter project files at [https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: All content for this chapter is held in the relevant `unitypackage` file, including
    a `Complete` folder that contains all of the work we'll carry out in the chapter,
    so if at any point you need some reference material or extra guidance, be sure
    to check it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3yfWyt5](https://bit.ly/3yfWyt5).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Unity project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things can get messy quickly in a project if we don't manage our files correctly
    by placing them in the allocated folders. If you want to structure your folders
    your own way, or during the book, you decide to stray away from how I'm doing
    it, that's also fine. Just try and be conscious of your future self or other people
    working on this project when it comes to finding and organizing files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project up if you haven''t already and create the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Model` contains 3D models (the player ship, enemies, bullets, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Prefab` holds instances of game objects (these are created within Unity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scene` stores our first-level scene as well as other levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Script` contains all of our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Material` stores our game object materials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources` stores assets and objects to load into our game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScriptableObject` are data containers that are capable of storing large amounts
    of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should know what a prefab is, as it''s one of the main parts of what makes
    Unity so quick and easy to use. However, if you don''t: it''s typically your game
    object with its settings and components stored in an instance. You can store your
    game objects in your **Project** window as prefabs by dragging the game object
    from the **Hierarchy** window. A blue box icon will be generated following the
    game object''s name, and if you select the prefab in the **Project** window, its
    **Inspector** window details will show all its stored values. If you would like
    to know more about prefabs, you can check out the documentation at [https://docs.unity3d.com/Manual/Prefabs.html](https://docs.unity3d.com/Manual/Prefabs.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows you how to create these folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Creating a folder in the Unity editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Creating a folder in the Unity Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create subfolders; we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our `Prefab` folder, create another two folders, `Enemies` and `Player`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Folders created in the Unity editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Folders created in the Unity Editor
  prefs: []
  type: TYPE_NORMAL
- en: '`Resources` is a special folder that Unity recognizes. It will allow us to
    load assets while the game is running. For more information about the `Resources`
    folder, check the documentation at [https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Further Information
  prefs: []
  type: TYPE_NORMAL
- en: It's worth mentioning the `StreamingAssets` folder at this point. Even though
    we aren't using it in this project, it relates well to how similar (and how different)
    it is to the `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `Resources` folder imports assets and converts them into internal formats
    that will be compatible with the target platform. So, for example, a PNG file
    will get converted and compressed when the project is being built.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StreamingAssets` folder will hold the PNG file, not convert or compress
    it. For more information on Streaming Assets, check out the following link: [https://docs.unity3d.com/Manual/StreamingAssets.html](https://docs.unity3d.com/Manual/StreamingAssets.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided in the *Technical requirements* section is the download link for the
    GitHub repository of this chapter. Once downloaded, double-click the `Chapter2.unitypackage`
    file, and we will be given a list of assets to import into our Unity project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Player_ship.fbx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enemy_wave.fbx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Import** window of the assets we are about
    to bring into our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Importing assets into your project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Importing assets into your project
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all assets are ticked and click the **Import** button at the bottom-right
    corner of the window. We can now move on to organizing our files and folders in
    the **Project** window in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating prefabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to create three prefabs: the player, the player''s
    bullet, and the enemy. These prefabs will hold components, settings, and other
    property values for our game that we can instantiate throughout our game.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by making our `player_ship.fbx` file into a prefab instance by doing
    the following.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, when importing any three-dimensional file, it may contain extra data
    that we might not need. For example, our `player_ship` model comes with its own
    material and animation properties. We don't require any of these, so let's remove
    these properties before continuing to import our models fully into our Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the `player_ship` model, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Model` and select the `player_ship` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, select the **Materials** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the **Material Creation Mode** is set to **None** from the drop-down
    list, and then click the **Apply** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click the **Animation** button next to the **Materials** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Untick the **Import Animation** checkbox, followed by clicking the **Apply**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Rig** button next to the **Animation** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the current value in the **Animation Type** drop-down menu and select
    **None**, followed by the **Apply** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all of the `player_ship` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Throughout the book, whenever we select a three-dimensional model, make sure
    to run through the same process, as we will not require imported extras such as
    the ones we just removed. This means I would like you now to repeat the process
    we have just gone through with the `enemy_wave.fbx` model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s continue preparing our `player_ship` model for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Click and drag `player_ship` from `Assets/Model` into the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `player_ship` in the `player_ship`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` apart from `1` on all axes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `player_ship` values in the **Inspector**
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The player_ship values in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – The player_ship values in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: Click and drag the `player_ship` from the `Assets/Prefab/Player` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When creating a prefab, sometimes you might be asked if this is an **Original**
    or **Variant**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.05_B18381.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The Create Prefab Dialog
  prefs: []
  type: TYPE_NORMAL
- en: A variant prefab will be a copy of an original prefab but will also carry any
    changes made from the prefab it originates from. So, for example, if the original
    prefab was a car with 4 wheels, the variant will have the same. If the original
    prefab changes it's numbers from 4 to 3, the variant will copy the original prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `player_ship` in the **Hierarchy** window has turned blue, which means
    it has become a prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `player_ship` from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to use a similar process to create our `enemy_wave` prefab, but
    we will also need to create its own name tag because there isn't an **Enemy**
    tag... yet.
  prefs: []
  type: TYPE_NORMAL
- en: An Enemy prefab and custom tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to create an `enemy_wave` prefab along with a
    custom tag. The tag will be used to identify and categorize all related enemies
    under one tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an `enemy_wave` prefab and custom name tag, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `enemy_wave.fbx` file from `Assets/Model` into the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `enemy_wave` file selected in the `enemy_wave`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` apart from `1` on all axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_2.06_B18381.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The enemy_wave values in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new tag for the `enemy_wave` game object by doing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the **Untagged** parameter in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Tag** drop-down menu, select **Add Tag...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Inspector** window will now show the **Tags & Layers** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **+** to add a new tag, as circled in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `Enemy` in the pop-up window, as shown in the following screenshot, and
    then click the **Save** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_2.07_B18381.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Add a tag to the Tags & Layers list
  prefs: []
  type: TYPE_NORMAL
- en: Back in the `enemy_wave` game object to bring back our **Inspector** window
    details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Untagged** parameter again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now see **Enemy** in our drop-down list, so select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `enemy_wave` game object from the `Assets/Prefab/Enemies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete `enemy_wave` from the **Hierarchy** window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now move on to our third prefab creation – the player's bullet. But this
    time, we won't import a three-dimensional model – we are going to create one in
    the Unity Editor, and then create a prefab from it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the player's bullet prefab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we are going to create the visuals for the player's bullet in the Unity
    Editor. We will make a blue sphere and give it a surrounding light source. Let's
    start by creating a three-dimensional sphere game object.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, right-click, and from the drop-down list, select
    **3D Object** | **Sphere**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the newly created `Sphere` in the **Hierarchy** window still selected,
    make the following changes to the **Inspector** window:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the game object name from `Sphere` to `player_bullet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **Tag** from **Untagged** to **Player**. The tag name makes it easier
    to identify later on in the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `0`, apart from the `2` on all axes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows all three changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The player_bullet values in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – The player_bullet values in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will give the `player_bullet` game object a new blue material.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and applying a material to the player's bullet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we will be creating a simple unlit material that will not
    take up much of the device''s performance, thanks to the simplicity of the material.
    To create a basic material and apply it to the `player_bullet` object, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Material` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Material` folder, make a new folder (the same way we did in the
    *Setting up our Unity project* section) and name the folder `Player`. That way,
    any material related to the player can be stored inside.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double click the newly created `Player` folder and right-click in the **Project**
    window (in the open space in the right section of the window) again, and from
    the drop-down list, select **Create** | **Material**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new material file will be made. Rename it `player_bullet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `player_bullet` material, and in the **Inspector** window, change
    the material from a **Standard** shader to **Unlit** | **Color** by following
    the three steps in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Creating an Unlit Color Material'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Creating an Unlit Color Material
  prefs: []
  type: TYPE_NORMAL
- en: The **Inspector** window will remove the majority of the properties and strip
    the material back to something simpler and easier to perform on any device.
  prefs: []
  type: TYPE_NORMAL
- en: Still in the `0`, `190`, `255`, and `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have created and calibrated our player''s bullet, so now, we can apply the
    material to the `player_bullet` prefab by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `player_bullet` prefab in the following location of the `Assets/Prefab/Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `player_bullet` in the drop-down list until you see the material, and
    then select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `player_bullet` prefab''s **Mesh Renderer**
    component updated to our new unlit material:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – player_bullet now has a player_bulletMat material'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – player_bullet now has a player_bulletMat material
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation,
    and Particles*, we will return to materials and art in general, which will be
    of note if you found this interesting. We will also play around with particle
    systems to create a fleet of stars rushing past the player's ship.
  prefs: []
  type: TYPE_NORMAL
- en: The last component we will add to our player's bullet is a surrounding light
    to give our bullet an energy glow.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a light to the player's bullet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we will be adding a light component to the player's bullet
    to hide the impression that all that we are doing is firing spheres. It will also
    introduce us to Unity's point light, which acts as a glowing ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add and customize a ball of light to the player''s bullet, we need to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Prefab/Player` folder, select the `player_bullet` prefab, and
    drag it into the **Hierarchy** window (if it isn't in the Hierarchy window already).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** at the bottom of the components listed, click the **Add
    Component** button and select **Light** from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `player_bullet` prefab will now have a **Light** component attached to it.
    We just need to change three property values to make the light suit the game object
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Change the following property values in the `player_bullet` file's `50`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0`, `190`, `255`, and `255`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`20`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Light** component after the values have
    been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The Light component values in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – The Light component values in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: Before moving onto the next section, because we have taken an existing prefab
    and added a material and a light component, we need to click the **Override**
    button to confirm the new changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `player_bullet` prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Updating the player_bullet prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Updating the player_bullet prefab
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on `player_bullet` from the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will continue to update our three prefabs by applying
    Unity's own physics system, the **Rigidbody** component, to help detect collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Rigidbody components and fixing game objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because this game involves collisions with game objects, we need to apply collision
    detection to the player, the player's bullets, and the enemy. Unity offers a range
    of different shapes to wrap around a game object that functions as an invisible
    shield; we can set our code to react to contact being made with the shield.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add colliders to the player and enemy game objects (the **Sphere**
    game object automatically comes with a collider), we need to add a Unity component
    called **Rigidbody**. If a game object is going to collide with at least one other
    game object, it requires a **Rigidbody** component, which can affect a game object's
    mass, gravity, drag, constraints, and more. If you would like to know more about
    **Rigidbody** components, check out the documentation at [https://docs.unity3d.com/Manual/class-Rigidbody.html](https://docs.unity3d.com/Manual/class-Rigidbody.html).
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbody Joints
  prefs: []
  type: TYPE_NORMAL
- en: Unity has other physics types apart from the collider. **Joints** also require
    the **Rigidbody** system, and they come in different forms, such as **Hinge**,
    **Spring**, and others.
  prefs: []
  type: TYPE_NORMAL
- en: These **Joints** will simulate at a fixed point; for example, the **Hinge**
    **Joint** would be good at making a door swing back and forth around a door hinge's
    pivot point.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to know more about Joints, check the documentation at [https://docs.unity3d.com/Manual/Joints.html](https://docs.unity3d.com/Manual/Joints.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `player_ship` and `player_bullet` prefabs in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** window, navigate to **Prefab | Player**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold *Ctrl* (*command* on a Mac) and click on the `player_ship` and `player_bullet`
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, click the **Add Component** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down menu, type `Rigidbody`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Rigidbody** (not **Rigidbody 2D**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Rigidbody** component has now been assigned to our two game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the two game objects still selected in the **Inspector** window, under
    **Rigidbody**, make sure that the **Gravity** checkbox isn't ticked. If it was,
    our game objects would begin to sink into the scene while the game is being played.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can add colliders to our `player_ship` and `enemy_wave` game objects
    (our `player_bullet` already has a **SphereCollider**). We will be adding a **SphereCollider**
    to our game objects because it''s the cheapest collider to use, relative to performance
    costs:'
  prefs: []
  type: TYPE_NORMAL
- en: Click and drag the `player_ship` prefab from the `Assets/Prefab/Player` into
    the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `player_ship` still selected in the `Sphere Collider` in the drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as you see `player_ship` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice a green wireframe around the `player_ship` in the `player_ship`
    still selected in the `player_ship` collider that will be used to detect hits.
    It may be too big for the purpose of a hitbox, so let's reduce its size.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `player_ship` prefab still selected in the `0.3` in the **Inspector**
    window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13 – The triggered sphere collider added to the player_ship prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – The triggered sphere collider added to the player_ship prefab
  prefs: []
  type: TYPE_NORMAL
- en: Also, while we still have the `player_ship` prefab selected, check the `player_ship`
    prefab look for another collider without causing any form of potential physics
    collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Override** at the top-right corner followed by **Apply All** in the
    **Inspector** window to update the modifications we've made to our prefab with
    its **Rigidbody** and **SphereCollider** components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now select the `player_ship` prefab in the **Hierarchy** window and press
    *Delete* on our keyboard, as we no longer need it in our **Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to apply the same methodology to the `player_bullet`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `player_bullet` prefab from `Assets /Prefab/Player` into the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Is Trigger** box and adjust the **Radius** in the **SphereCollider**
    component in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `player_bullet` changes, and delete the `player_bullet` prefab from the
    **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last game object we need to update is the `enemy_wave` prefab. We have
    already covered the steps with the `player_ship` and `player_bullet` prefabs,
    so it''s not ideal to repeat the instructions in full; however, we need to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Briefly, I want you to drag and drop the `enemy_wave` prefab from its location
    at `Assets/Prefab/Enemies` in the **Project** window into the **Hierarchy** window..
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `enemy_wave` prefab in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the `enemy_wave` prefab with the correct proportions, as we did with
    `player_ship`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `enemy_wave` prefab doesn't require a **Rigidbody** component, as it will
    be colliding with relevant game objects that hold one themselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `enemy_wave` prefab from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following screenshot as a reference for the preceding mini-brief, and
    if you get stuck, use the previous steps that we discussed in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, that went well for you. If you get stuck at any point, refer to the
    [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage)
    folder containing all the completed files to check them out and compare.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, note that if a game object is pink, such as our `enemy_wave`
    object in the previous screenshot, it simply means that it doesn't have a material
    attached. In other cases, it can also mean there is something wrong with the shader
    attached to the material.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this pink issue by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Prefab/Enemies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop enemy_wave into the Hierarchy window. Expand the drop down next
    to `enemy_wave` in the Hierarchy window..
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first game object, titled `enemy_wave_core`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector** window, select the small **remote** circle next to the
    **Element 0** parameter in the **Mesh Renderer** component (denoted by **1** in
    the following screenshot), and then select **Default-Material** (denoted by **2**)
    from the drop-down list, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject
  prefs: []
  type: TYPE_NORMAL
- en: Follow the same steps for its sibling game object, `enemy_wave_ring`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `enemy_wave` object will now have a default material applied.If any changes
    were made to the prefab be sure to click **Override, Apply All**.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'If a game object requires a component such as `Rigidbody`, we can place, above
    the class name, what is effectively a reminder to the script that the game object
    needs it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[RequireComponent(typeof(Rigidbody))]`'
  prefs: []
  type: TYPE_NORMAL
- en: If the game object doesn't have the component, the script will create one, and
    if we try to remove the `Rigidbody` component, we will receive a message in the
    Unity Editor that it is a required component.
  prefs: []
  type: TYPE_NORMAL
- en: This code isn't a requirement as such, more of a good practice with components
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to know more about the `RequireComponent` attribute, check
    the documentation at [https://docs.unity3d.com/ScriptReference/RequireComponent.html](https://docs.unity3d.com/ScriptReference/RequireComponent.html).
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have our colliders and **Rigidbody** components applied to our game
    objects. This gives us the ability to create a reaction when colliders come into
    contact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are starting to build up our project, let's quickly discuss saving
    our scenes, projects, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and publishing our work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's easy to get stuck into our project, but as a brief reminder, save your
    work as often as possible. That way, if anything bad happens, you can always revert
    back.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have created and saved our `testLevel` scene from the previous chapter,
    we can also add this scene to the **Build Settings** window. The reason for this
    is so that Unity is aware of what scenes we want to include in our project. It
    is also a requirement when it comes to packaging up our game as a build for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our scene to **Build Settings**, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, click **File | Build Settings**. The **Build
    Settings** window will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `testLevel` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `testLevel` scene. When we add more scenes
    later, each scene will be numbered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Adding the testLevel scene to the Scenes In Build list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.16_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Adding the testLevel scene to the Scenes In Build list
  prefs: []
  type: TYPE_NORMAL
- en: Close the **Build Settings** window. We will come back to this when we have
    more scenes to add in the next chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's a good habit to save the project by clicking **File | Save Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now continue with setting up our scene camera in the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Editor Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our side-scrolling shooter game *Killer Wave*, we need control over a camera
    to display the aspect ratio and visible depth of the scene, and to make sure we
    show the correct amount of our game's environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and decide on the screen ratio of our game. We'll create our
    own resolution, which will be fairly common across most platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the **Game** window''s screen ratio to a custom aspect, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the current aspect ratio under the **Game** window tab and select the
    **+** symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the custom aspect ratio values shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `1080` resolution we have just made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Setting a custom Game window resolution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – Setting a custom Game window resolution
  prefs: []
  type: TYPE_NORMAL
- en: It is good to be aware of the need to make our game's artwork support (or to
    give it the scope to extend to) as many screen ratios as possible, especially
    if we ever wanted to make a game for portable devices such as tablets or mobile
    phones. This is because nearly every major brand of phone and tablet comes in
    different ratio sizes, and we don't want to start squashing and squeezing our
    content, as it won't look right. It's also possible that our small mobile games
    will become successful and could later be ported to a console or PC. If that's
    the case, we need to make the game screen support these ratios too. The main point
    to take from all of this is that we are targeting our game to cover all possible
    common screen ratios. The more platforms (consoles, portable devices, and so on)
    we can cover with flexible screen ratios, the easier it will be to extend our
    game out to those devices without requiring extra work. We explain more about
    screen size ratios in [*Chapter 8*](B18381_08_Epub.xhtml#_idTextAnchor150), *Adding
    Custom Fonts and UI*, and [*Chapter 9*](B18381_09_Epub.xhtml#_idTextAnchor161),
    *Creating a 2D Shop Interface and In-Game HUD*, where we discuss UI display settings.
    Additionally, in [*Chapter 13*](B18381_13_Epub.xhtml#_idTextAnchor219), *Effects,
    Testing, Performance, and Alt Controls*, we will explain how to display our game
    screen on a raw image component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue any further with our project, it''s probably a good time
    to confirm our understanding of Unity''s own UI layout. The following screenshot
    shows the Unity Editor, where I have outlined and labeled the relevant windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – The Unity editor window layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – The Unity Editor window layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the Unity Editor window is made up of five main windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene**: This is our two-/three-dimensional workspace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game**: This window is what the end user will see. By default, the **Game**
    tab shares the same space as the **Scene** window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchy**: All game objects in our scene will be listed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inspector**: When an object is selected, information about it will be displayed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project**: This is our Unity project folder. Consider it a structure of files
    and folders that we can use in our game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To drag each window around individually, left-click and drag the name of the
    tab, and it will then snap into different locations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My **Game** window is set to **1080**, and because I don't have the luxury of
    a second screen, I've clicked its name tab (**Game**) and pulled it down in the
    bottom-right corner. The window is small, but as you can see at the top of the
    **Game** window, the scale is set to 1x, which means I have a full picture; nothing
    is hidden or cut out of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that we have the main camera''s `0`. We can also reset the **Transform**
    option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the main camera selected in the **Hierarchy** window, click the three
    dots at the top-right corner of the **Transform** panel in the **Inspector** window,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.20 – The Transform settings cog location'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.20_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – The Transform settings cog location
  prefs: []
  type: TYPE_NORMAL
- en: When the dropdown appears, click **Reset**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continuing with setting up our main camera, let''s get rid of the landscape
    background in our **Scene**/**Game** window by changing its **Background** setting:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Main Camera** in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, we have the **Camera** component with a property
    called **Clear Flags**. Click the **Skybox** value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A dropdown will appear. Click **Solid Color**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Changing Background to a Solid Color'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.21_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.20 – Changing Background to a Solid Color
  prefs: []
  type: TYPE_NORMAL
- en: We will now be presented with a blue background, which is less distracting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don''t like blue, you can change it to any color in the `0`, `0`, `0`,
    and `255`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Setting Background color values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.22_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.21 – Setting Background color values
  prefs: []
  type: TYPE_NORMAL
- en: Great, now let's move on to coding these properties for our main camera.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our camera properties via a script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have our main camera's behavior set in our **Scene**. Next, we need to
    code this into a script so that whenever a scene is loaded, Unity will read the
    script and understand how the main camera should be set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observing our framework again, let''s see where the camera script should be
    placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Killer Wave UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.23_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.22 – Killer Wave UML
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the diagram, there is no reference to the camera, so should
    we make a script to support this? Arguably, the only reason to make a script based
    on the camera would be if the camera had a complex purpose filled with multiple
    properties and functions. The camera in our game, however, is put in place when
    the game starts. Later on, on the third level, the camera will move from left
    to right with a simple component script, but it doesn't hold any other complexity.
    It would, therefore, be more ideal to use the `GameManager`, as it only takes
    up a small role. If the game became bigger and the camera took on more of a role,
    then this might justify the camera having a class of its own. Others might disagree
    based on personal preference, but this is the approach we'll take.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the `GameManager` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script in the same way that we created a folder. Right-click the open
    space area in the **Project** window, and a dropdown will appear. Click **Create
    | C# Script**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Creating a C# script in the Unity editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.24_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.23– Creating a C# script in the Unity Editor
  prefs: []
  type: TYPE_NORMAL
- en: The script appears with the title `NewBehaviourScript`. We don't want to call
    it that, so type (in camel case) `GameManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's camel casing?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Camel casing is a way to avoid spacing between words. This is fairly common
    with programming, as spaces are typically not welcomed for various reasons. Each
    new word starts with a capital letter, so in this case, the M in `GameManager`
    is the hump of the camel. However, variables typically start with lowercase, as
    you will see shortly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now have our `GameManager` script. Notice how Unity is trying to be helpful
    by changing the icon to a silver cog because what we are doing is a recognized
    method with Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – The GameManager icon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.25_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.24 – The GameManager icon
  prefs: []
  type: TYPE_NORMAL
- en: As we did when placing our three-dimensional models into the `GameManager` into
    the `Script` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Good. Now, before we open our script to code in it, we need to attach it to
    a game object in our scene so that when the scene runs, the script attached to
    the game object also runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our `GameManager` game object, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in an open space in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down menu, select **Create Empty**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the newly created game object and select **Rename** from the drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename this game object `GameManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, with the `GameManager` game object still selected, click the **Add
    Component** button in the far-right **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `GameManager` from the drop-down menu until you see the `GameManager` script
    and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever we make an empty game object, we must be sure that all of its **Transform**
    property values are reset to their default values unless we are specifically changing
    them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To reset a game object's **Transform** value, make sure that the game object
    we are resetting is selected. Click the metal cog at the top-right corner of the
    **Inspector** window, and then select **Reset**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Double-click the `GameManager` script to open it up in your IDE (Visual Studio
    or whatever IDE you use), and then proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `GameManager` script, we will be faced with the `UnityEngine` library
    being imported into our script to add extra functionality to Unity''s own components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also in the preceding code, we have the name of our script along with `MonoBehaviour`
    being inherited yet again to add more functionality to our script. `MonoBehaviour`
    is also required if the game object that attaches to this script needs to be used
    in the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start adding some of our own code into our `GameManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty method, `CameraSetup`, and then run this method in the `Start`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `CameraSetup` method, add a reference to the camera and set the
    position and angle of the camera to zero apart from its *z* axis. We''ll set `Z`
    to `-300`, which will move the camera back and ensure all game objects are in
    the shot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will change the properties of the camera within our `CameraSetup`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removes the sky background and replaces it with a solid color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes the solid color from the default blue to black
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – The current code layout for the GameManager script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.26_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.25– The current code layout for the GameManager script
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to change other settings relating to the camera, you can find
    out about them at [https://docs.unity3d.com/ScriptReference/Camera.html](https://docs.unity3d.com/ScriptReference/Camera.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the **Play** button in the upper middle of the editor window, or by using
    the shortcut *Ctrl* + *P* (*Command* + *P* on the Mac). The following screenshot
    shows where the **Play** button is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.27_B18381.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – The Play, Pause, and Step button locations
  prefs: []
  type: TYPE_NORMAL
- en: 'With the scene in play mode, we can now check out the **Main Camera** game
    object''s properties by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select **Main Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the **Inspector** window in the next screenshot to see the following
    changes our script has made.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Transform** component of the **Inspector** window, we can see that
    the **Position** and **Rotation** properties are set to the same values set in
    our script (denoted by **1** in the following screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Camera** component of the **Inspector** window, we can see that the
    **Clear Flags** and **Background** values are also set to the same values set
    in our script (denoted by **2i** and **2ii**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Main Camera** component properties being
    updated in Play mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Main Camera values changing with our script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.28_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.27 – Main Camera values changing with our script
  prefs: []
  type: TYPE_NORMAL
- en: Now, hopefully, our properties should be the same as what we have scripted (with
    no errors). If not, you will likely have an error message in the **Console** window.
    If there is an error, it will likely tell you what line the error is on. You can
    also double-click the error, and it will take you to the line the error is on.
  prefs: []
  type: TYPE_NORMAL
- en: To double-check everything has worked, change the **Position** and **Rotation**
    of the camera in the editor, and then press the **Play** button. The properties
    for the camera should now be set to our script's **Position** and **Rotation**
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, while the editor is still playing, we can also make a prefab
    of the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click and drag the **Camera** from the **Hierarchy** window down into the **Project**
    window, and we will generate a blue cube with the camera''s name or an empty icon.
    Depending on the scale of our icons, the size of the icon can be altered by moving
    the slider shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.29 – The slider in the bottom right of the Project window zooms
    in and out of thumbnails'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.29_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.28 – The slider in the bottom right of the Project window zooms in
    and out of thumbnails
  prefs: []
  type: TYPE_NORMAL
- en: Move this camera prefab into the `Prefab` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might be thinking, *why didn''t we just make a prefab of the camera in
    the first place instead of fiddling with its property settings in code?* However,
    two key things are important here: firstly, we are studying for an exam that is
    likely to cover such properties; and secondly, you now know how to change these
    settings dynamically through code.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit to scripting Unity's components is that we can sometimes be
    offered more functionality than what is displayed in the Editor. For example,
    the `Camera` component has a `layerCullDistances` property that is only accessible
    via scripting. This can offer functionality such as skipping the rendering of
    smaller game objects in the far distance to increase a game's performance.
  prefs: []
  type: TYPE_NORMAL
- en: To read more about `layerCullDistances`, check the documentation at [https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html](https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings this section to a close. So far, we have covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a ratio for our game camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our Unity Editor with individual windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the properties of our **Camera** component in the Unity Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating the changes we made to our camera in the `GameManager` script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding our `GameManager` script to our scene as a game object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a programmer, the importance of being able to understand and change the settings
    in the Unity Editor (but also being able to do the same in code) can be expanded
    to other components that are in the editor. This is what we will do next, with
    a focus on directional light.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our light
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a default setup, each scene comes with a directional light, and currently,
    this is all we need to get going; ideally, we want the scene to be well lit.
  prefs: []
  type: TYPE_NORMAL
- en: With the directional light already present in the scene as the default light,
    select it in the `50`, `-30`, and `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we put our player ship into the scene, this will light it up well, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30 – The player ship lit up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.30_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.29 – The player ship lit up
  prefs: []
  type: TYPE_NORMAL
- en: Different Lights
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides three different types of real-time lights. As well as the **directional**
    light we mentioned, it also provides a **point** light, which is like a 360° glow
    that we will cover in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087), *Applying
    Art, Animation, and Particles*. The third type of light is a spotlight or, as
    Unity refers to it, a **spot**. The **spot** can also have masks applied, so it
    can project images known as cookies.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the three types of lights, check out [https://docs.unity3d.com/Manual/Lighting.html](https://docs.unity3d.com/Manual/Lighting.html).
  prefs: []
  type: TYPE_NORMAL
- en: We can now make sure these settings stay in place by adding them to the `GameManager`
    script. We can also alter the light's color.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our light properties via a script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `GameManager`, we will set the **Transform** **Rotation** values and
    change the color tint from a light yellow to a cold blue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `GameManager` script and enter the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add `LightSetup();` in the scope of the `Start` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `LightSetup` method does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: It grabs the light from the scene and stores it as a reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets the rotation of the light with `EulerAngles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it changes the light's color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: EulerAngles
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`eulerAngles` allows us to give `Vector3` coordinates instead of `Quaternion`
    values. `eulerAngles` makes rotations less complicated to work with. More information
    about `eulerAngles` can be found at [https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html](https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That's all we need to do with our light. As with the camera, we can access the
    light and change its properties via a script.
  prefs: []
  type: TYPE_NORMAL
- en: We have become familiar with our light by changing its settings in the Unity
    Editor and the `GameManager` script. Next, we will set up our interface for the
    majority of our game objects.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our interface – IActorTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `IActorTemplate` interface is what we are using to prompt damage control,
    death, and scriptable object assets. The reason for using an interface such as
    this is that it ties general uses together between classes that inherit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A total of six classes will be using the `IActorTemplate` interface, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Player`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerBullet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerSpawner`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enemy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnemyBullet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnemySpawner`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the `IActorTemplate` interface with a partial overview
    of our game framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31 – IActorTemplate UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.31_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.30 – IActorTemplate UML
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our interface and explain its content along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a script in the `Assets/Scripts` folder with the filename `IActorTemplate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code we just entered looks like we have declared a class, but it acts fundamentally
    differently. Instead of using the `class` keyword, we enter `interface` followed
    by the name of the interface, `IActorTemplate`. It's not a requirement to start
    any interface name with an `I`, but it makes the script easily identifiable.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `interface`, we make a list of methods that act like contracts to
    whichever class implements them. For example, the `Player` script that we'll create
    later on in the chapter inherits the `IActorTemplate` interface. The `Player`
    script must declare the function names from `IActorTemplate` or the `Player` script
    will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the scope of the `interface`, we declare methods without accessors (it
    doesn't require `private` or `public` at the beginning of each method). Methods
    also don't require any content in them (that is, they are empty bodies).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about interfaces, check out [https://learn.unity.com/tutorial/interfaces](https://learn.unity.com/tutorial/interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: The last method in our `interface` is `ActorStats`, which takes a `SOActorModel`
    type. `SOActorModel` is a scriptable object that we are going to explain and create
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our ScriptableObject – SOActorModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to cover scriptable objects and their benefits.
    Similar to our `interface`, scriptable objects cover the same six classes. The
    reason for this is that our `interface` uses the `SOActorModel` and, therefore,
    creates an attachment with the other variables.
  prefs: []
  type: TYPE_NORMAL
- en: It is also good to remind ourselves of the **Game Design Document** (**GDD**)
    and how it is incorporated into the overview of the creation of our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our game has three series of game objects that will hold similar properties:
    `EnemyWave`, `EnemyFlee`, and `Player`. These properties will include health,
    speed, score value, and more. The difference between each of these as described
    in the game design brief is the way they act and also how they are instantiated
    in our game.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Player` will be instantiated at every level, `EnemyWave` will be spawned from
    `EnemySpawner`, and `EnemyFlee` will be placed in particular areas of the third
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: All of the aforementioned game objects will relate to the `SOActorModel` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is also a partial view of our game framework, showing
    the scriptable object and the six classes that inherit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32 – SOActorModel UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.32_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.31 – SOActorModel UML
  prefs: []
  type: TYPE_NORMAL
- en: Similar to what was mentioned with the `interface` script is that the name of
    the scriptable object name starts with `SO`, which isn't a standard way of naming
    the script, but it's easier to identify as a `ScriptableObject`.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this scriptable object is to hold general values for each of
    the game objects it's being given to. For example, all game objects have a name,
    so within our `SOActorModel` is a `string` named `actorName`. This `actorName`
    will be used to name the type of enemy, spawner, or bullet it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a scriptable object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Scripts` folder with the filename `SOActorModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `SOActorModel`, we will be naming most, if not all, of these variables
    in the `Player` script. Similar to how an `interface` signs a contract with a
    class, the `SOActorModel` does the same because it's being inherited, but isn't
    as strict as an `interface` by throwing an error if the content from the scriptable
    object isn't applied.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an overview of the `SOActorModel` code we just entered.
  prefs: []
  type: TYPE_NORMAL
- en: We named our scriptable object `SOActorModel` as a generic term to try and cover
    as many game objects as will likely use the scriptable object. This way of working
    also supports the SOLID principles we covered in the first chapter by encouraging
    us to try and keep our code concise and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main categories we''ll cover for this script are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SOActorModel` script is `using UnityEngine`; no other libraries are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateAssetMenu` attribute creates an extra selection from the drop-down list
    in the **Project** window in the Unity Editor when we right-click and select **Create**,
    as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.33 – Creating an Actor in the Unity editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.33_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.32 – Creating an Actor in the Unity Editor
  prefs: []
  type: TYPE_NORMAL
- en: '`MonoBehaviour` but `ScriptableObject` instead, as it''s a requirement when
    it comes to creating an asset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables**: Finally, these are the variables that will be sent to our selected
    classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we are going to create assets from the scriptable
    object script to give our scripts different values.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PlayerSpawner ScriptableObject asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our `SOActorModel` `ScriptableObject` made, we can now create an asset
    that will act as a template that can be used not just by programmers but also
    by designers who want to tweak game properties/settings without needing to know
    how to code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an `Actor Model` asset, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Unity Editor, in the **Project** window, right-click and choose
    **Create | Create Actor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the newly created asset file in the `Player_Default` and store the file
    in the `Assets/Resources` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the new asset, and in the **Inspector** window, you'll see the content
    of the asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `Actor Model` asset''s fields, where I have
    entered my own values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.34 – Player values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.34_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.33 – Player values
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down each of the values that have been added to our newly created
    asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Player`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ship Type**: Choose which category this game object belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: Designer/internal notes that don''t affect the game but can
    be helpful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health**: How many times the player can get hit before dying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: The movement speed of the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hit Power**: Determines how much damage the player will cause if they collide
    with the enemy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`player_ship` prefab here (`Assets/Prefab/Player`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`player_bullet` prefab here (`Assets/Prefab /Player/`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will add this asset to our `PlayerSpawner` script once it's built later on
    in the chapter. Let's move on to the next scriptable object asset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EnemySpawner ScriptableObject asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to make our enemy asset attach to `EnemySpawner`
    for later on in the chapter. For the sake of keeping our work fresh and complete,
    let's continue with that before moving on to the `EnemySpawner` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an enemy asset, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Editor, in the **Project** window, right-click and choose **Create
    | Create Actor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new file to refer to what it's being attached to (`BasicWave Enemy`)
    and store the file in the `Assets/ScriptableObject` location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the new script, and our **Inspector** window will show the content
    of our script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the `BasicWave Enemy` asset is going to
    look like once we''ve finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.35 – The Basic Wave Enemy values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.35_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.34 – The Basic Wave Enemy values
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly go through each of the values for our enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enemy_wave`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wave`. This explains what type of enemy it is and how it attacks the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Typically in groups`. As mentioned before, it''s more of a guideline than
    a rule to comment on anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`, which means it takes 1 hit to die.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-50`, because our enemy is moving from right to left, so we give it a minus
    figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`, which means that if this enemy collides with the player, it will cause
    1 hit point of damage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enemy_wave` prefab here (`Assets/Prefab/Enemies`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actors Bullets**: This enemy doesn''t fire bullets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, you can see how useful scriptable objects are. Imagine continuing
    to develop this game with `50` enemies, where all we need to do is create an asset
    and customize it.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to move on to the final scriptable object asset for this chapter
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PlayerBullet ScriptableObject Asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to create an asset for the player's bullet for
    when they fire. As with the last two sections, create an asset, name it `PlayerBullet`,
    and store it in the same folder as the other assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the final results for the `PlayerBullet` asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.36 – The Player Bullet values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.36_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.35 – The Player Bullet values
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly go through each variable''s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`player_bullet`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ship Type**: Bullet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: It is optional to enter any details about the asset here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`700`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` sends a hit point of 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`player_bullet` prefab here (`Assets/Prefab/Player`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actors Bullets**: **None (Game Object)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a later chapter, when we build a shop for our game, we will be able to buy
    power-ups for our player's ship. One of the power-ups will be similar to the one
    that we just made, but the **Actor Name** will be different, and the **Hit Power**
    will have a higher number.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can move on to the next section and create the player's scripts and
    attach these assets to them.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Player, PlayerSpawner, and PlayerBullet scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following series of sections, we are going to create three of the scripts
    that will cover the following: spawning the player, the player''s controls, and
    the player''s bullet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The scripts we will be creating and including are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerSpawner`: Creates and calibrates the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Player`: Player controls and general functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerBullet`: Bullet movement and general functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IActorTemplate`: A template of the expected rules assigned to a given object
    (already made)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOActorModel`: A set of values that can be altered by non-programmers (already
    made)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover all of these scripts thoroughly and break down each of their purposes,
    as well as how they depend on and communicate with one another. We will start
    with the `PlayerSpawner`, which will create the player's ship and issue its values.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our PlayerSpawner script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the `PlayerSpawner` script is to be attached to a game object,
    resulting in the player appearing at its position in the game. The `PlayerSpawner`
    script will also set the player's values when it is created. For example, if our
    player had a particular speed value, or if they had received an upgrade from the
    shop, the `PlayerSpawner` script would grab these values and apply them to the
    `Player` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a partial view of the `PlayerSpawner` class in
    the game''s framework and its relationship with the other classes around it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.37 – PlayerSpawner UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.37_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.36 – PlayerSpawner UML
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the `PlayerSpawner` script is connected to four other scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Player`: `PlayerSpawner` is connected to `Player` because it creates the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOActorModel`: This is a `ScriptableObject` that gives the `PlayerSpawner`
    its values, which are then passed on to the `Player`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IActorTemplate`: This is the `interface` that generalizes the script with
    other common functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameManager`: This will send and receive general game information from and
    to the `PlayerSpawner` script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we create our `PlayerSpawner` script, it would be good housekeeping to
    create an empty game object to store anything to do with our player, their bullets,
    and whatever else the player might create in our `testLevel` scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make and name the game object by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the **Hierarchy** window in its open space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A drop-down list will appear. From the list, select **Create Empty**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the game object `_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s all that we need to do. Now, let''s make a start with the `PlayerSpawner`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Scripts` folder with the filename `PlayerSpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and make sure that we have the following library entered at
    the top of our script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We only require `using UnityEngine`, as it covers all of the objects we need
    in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by making sure our class is labeled as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is common in Unity to inherit `MonoBehaviour` to give the script more functionality
    within Unity. Its common purpose is so the script can be attached to a game object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by entering the script''s variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `PlayerSpawner` class, we add two global variables: the first variable
    is the `actorModel`, which holds a scriptable object asset that will contain values
    for the player ship, and the second variable will hold our player ship once it''s
    been created from our `CreatePlayer` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by entering the script''s `Start` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the global variables, we add a `Start` function that will run automatically
    as soon as the game object holding the `PlayerSpawner` script is active at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the scope of the `Start` function is a method that we are going to create
    called `CreatePlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by entering the `CreatePlayer` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I have split the `CreatePlayer` method into two commented-out parts (`//CREATE
    PLAYER` and `//SET PLAYER UP`) due to its size.
  prefs: []
  type: TYPE_NORMAL
- en: This first part of the `CreatePlayer` method will `instantiate` the player ship's
    `ScriptableObject` asset and store it in the `actorModel` variable. We then `instantiate`
    a game object that refers to our `ScriptableObject` that holds the game object
    called `actor` in our game object variable named `playerShip`. Finally, we apply
    our `ScriptableObject` asset to the `playerShip` method called `ActorStats` that
    exists in the `Player` component script (which we will create later on in this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue on inside the `CreatePlayer` method to add the second half:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the second half of the `CreatePlayer` method, we add more code at the same
    point where we have commented `//SET PLAYER UP`.
  prefs: []
  type: TYPE_NORMAL
- en: The code from `//SET PLAYER UP` onward is dedicated to setting up the player's
    ship in the correct position at the start of the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the rotation of the player's ship to face the right way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the scale of the player ship to `60` on all axes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we `instantiate` any game object, Unity will add `(Clone)` to the end of
    the game object's name. We can rename it `Player`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We make the `playerShip` game object a child of the `_Player` game object in
    the **Hierarchy** window so that we can easily find it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we reset the player ship's position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is our `PlayerSpawner` script coded. Now, in the next section, we need
    to create and attach this script to a game object and name it. Make sure to save
    the script before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PlayerSpawner game object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will create a game object that will hold our newly created
    `PlayerSpawner` script, and then we will position the `PlayerSpawner` game object
    in the `testLevel` scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and set up our `PlayerSpawner` game object, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PlayerSpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `PlayerSpawner` game object onto the `_Player` (remember that
    `_Player` is the empty game object in our scene) game object to make the `PlayerSpawner`
    its child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because our `PlayerSpawner` game object doesn't have anything visually applied
    to it, we can give it an icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `PlayerSpawner` game object still selected in the **Inspector** window,
    click the multi-colored box to the left of its name. A selection of colors will
    be offered, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.38 – Selecting an icon for the PlayerSpawner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.38_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.37 – Selecting an icon for the PlayerSpawner
  prefs: []
  type: TYPE_NORMAL
- en: Pick a color. Now, the `PlayerSpawner` game object will be given a label to
    show us where it is in the scene. This will now appear in the **Scene** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you still can't see the icon in the **Scene** window, make sure **3D icons**
    are turned off. You can check by clicking the **Gizmos** button in the top right
    of the **Scene** window and unchecking the **3D Icons** box.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the `PlayerSpawner` game object sitting inside the `_Player` game object
    in the `PlayerSpawner` game object the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `PlayerSpawner` game object still selected, in the **Inspector** window,
    give it the following **Transform** values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.39 – PlayerSpawner Transform values in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.39_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.38 – PlayerSpawner Transform values in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: While still in the `PlayerSpawner` until you see the script appear in the drop-down
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `PlayerSpawner` script to add this to the `PlayerSpawner` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't move the ship yet, nor can we fire because we haven't coded this in
    yet. In the following section, we will go through the player's controls, then
    we will move on to coding our player and its bullet to travel across the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Input Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that this is a side-scrolling shooter game, so the controls will be
    two-dimensional even though our visuals are three-dimensional. Our focus now is
    to get the `Players` controls set up. To do this, we need to access the **Input
    Manager**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Edit**, followed by **Project Settings**, and then select **Input
    Manager** from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.40 – Selecting the Input Manager in the Unity editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.40_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.39 – Selecting the Input Manager in the Unity Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Input Manager** will offer a list of all available controls for our game.
    We will first check what the controls are set to by default. There are a lot of
    options here, but as mentioned, we only need to browse through the properties
    that matter to us, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal**: Moves the player''s ship along its x-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertical**: Moves the player''s ship along its y-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fire1**: Makes our player shoot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check these three properties, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **Axes** dropdown by clicking the arrow next to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expand **Horizontal**, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.41 – The Input Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.41_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.40 – The Input Manager
  prefs: []
  type: TYPE_NORMAL
- en: '`-1`), and the right button configures it positively (`+1`). Alternative key
    presses to this effect are *A* for left and *D* for right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we had analog controls such as a joystick or a steering wheel, we would likely
    need to be concerned about the influence of gravity when the player releases the
    controls and it returns to its center. Dead refers to the center of the analog
    controls. Sometimes, controllers can be unbalanced and naturally lean to one side,
    so by increasing the dead zone, we can eliminate false feedback from the player
    that could be detected as a movement.
  prefs: []
  type: TYPE_NORMAL
- en: '`-1`) and the positive button is up (`+1`). Alternative buttons are *S* for
    down and *W* for up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouse 0` (that is, the left mouse button). For now, remove `mouse 0` from
    the alternative button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find out more about the **Input Manager** window, click the little blue book
    at the top-right corner of the **Input Manager** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Our controls are now set in the `Player` script to take advantage of these controls.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Player script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Player` script will be attached to the player ship game object, from which
    the player will be able to move and shoot, as well as inflict and receive damage.
    We will also make the player ship not go outside of the screenplay area. Before
    we continue, let''s remind ourselves where the `Player` script lies in our game
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.42 – Player UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.42_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.41 – Player UML
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Player` script will be in contact with the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerBullet`: The `Player` script will create bullets to fire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerSpawner`: The `Player` script is created from the `PlayerSpawner`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IActorTemplate`: Contains damage control and the properties for `Player`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameManager`: Extra information such as the number of lives, the score, the
    level, and whatever upgrades the player ship has accumulated will be stored in
    `GameManager`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOActorModel`: Holds `ScriptableObject` properties for `Player`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we are familiar with the `Player` script''s relation to the other
    scripts, we can start coding it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Scripts` folder with the filename `Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and add the `IActorTemplate` interface to the existing default
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The script will by default import a `UnityEngine` library (including some others),
    the name of the class, and `MonoBehaviour`. All of these are essential to make
    the script work in the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the `Player` script, enter the following global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have entered a mixture of integers, floats, and game objects in our global
    variables; starting from the top, the first six variables will be updated from
    the player's `SOActorModel` script. `travelSpeed` is the speed of the player's
    ship, `health` is how many hits the player can take before dying, `hitPower` is
    the damage the ship will cause when colliding into something that can receive
    damage (the enemy), `actor` is the three-dimensional model used to represent the
    player, and finally, the `fire` variable is the three-dimensional model from which
    the player fires. If that seemed a little rushed, go back to the *Introducing
    our ScriptableObject – SOActorModel* section, where we went into more detail about
    these variables.
  prefs: []
  type: TYPE_NORMAL
- en: The two public properties of `Health` and `Fire` are there to give access to
    our two `private health` and `fire` variables from other classes that require
    access.
  prefs: []
  type: TYPE_NORMAL
- en: The `_Player` variable will be used as a reference to the `_Player` game object
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The last two variables of `width` and `height` will be used to store the measured
    results of the world space dimensions of the screen that the game is played in.
    We will discuss these two more in the next block of code.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin the following `Start` function code block, you may question
    why we would pick `Start` over `Awake` when it comes to running a function's code
    content. Both functions run once at runtime; the only noticeable difference is
    that `Awake` runs when the object is created. `Start` is executed when it's enabled,
    as can be seen in the documentation at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity in our Unity project, we will vary between which of the two functions
    to use. This is so we avoid conflicts between several `Awake` functions running
    at the same time. As an example, one script may try to update its Text UI, but
    the variable updating the text may still be null at runtime because the script
    with the variable is still waiting for its content to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to avoid conflicts between several `Awake` functions being called
    by several scripts at runtime, by going to Unity's **Script Execution Order**
    in **Edit** | **Project Settings** | **Script Execution Order**.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to know more about the **Script Execution Order**, check the
    documentation at [https://docs.unity3d.com/Manual/class-MonoManager.html](https://docs.unity3d.com/Manual/class-MonoManager.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with entering code into the `Player` script, next up, we will type
    out the `Start` function along with its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As previously mentioned, the `height` and `width` variables will store our world
    space measurements. These are required so that we can clamp the player's ship
    inside the screen. Both the height and width lines of code use similar methods;
    the only difference is with the axis we are reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Camera.main` component refers to the camera in our scene, and the function
    it uses, `WorldToViewportPoint`, is to take the results from the game''s three-dimensional
    world space and convert the results into viewport space. If you aren''t sure what
    viewport space is, it''s similar to what we know as a screen resolution, except
    its measurements are in points and not pixels, and these points are measured from
    `0` to `1`. The following diagram shows the comparison between screen and viewport
    measurements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.43 – Screen versus viewport measurements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.43_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.42 – Screen versus viewport measurements
  prefs: []
  type: TYPE_NORMAL
- en: So, with viewports, no matter what the screen's resolution is, the full height
    and width are `1` and everything between that is a fraction. So, for the height,
    we feed `Vector3` to `WorldToViewportPoint`, where `Vector3` represents a world
    space value, followed by `-0.5f`, which sets its offset back to `0`. Then, we
    divide `1` (which is our full-screen size) by the result of our formula. This
    will give us our current world space height of the screen. We then apply the same
    principles for the width and use `x` instead of `y` and store the result.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last line of code takes the reference of the `_Player` game object
    in the scene and stores it into our variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the `Player` script, we have our `Update` function that is
    called on every frame. Enter the function along with the following two methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Update` function runs the `Movement` method and `Attack` method on every
    frame. We will go into depth about these two methods later on in the chapter,
    for now we will comment ("//") these two methods out to avoid the script not being
    able to run.
  prefs: []
  type: TYPE_NORMAL
- en: The next method we are going to put into our `Player` script is the `ActorStats`
    method. This method is a requirement, as we declare it in the interface we are
    inheriting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the scope of our `Update` function, enter the following piece of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code we have just entered assigns values from the player's `SOActorModel`
    `ScriptableObject` asset that we made earlier on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This method doesn't get run in our script but gets accessed by other classes,
    the reason being that these variables hold values regarding our player and don't
    need to be anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Save the `Player` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we test what we have so far, we need to attach our `Player` script to
    our `player_ship` in the **Project** window.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Prefab` and select the `player_ship` prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Player` until the script appears and then select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our `_Player`, `PlayerSpawner`, and the `GameManager` game objects, it's
    time to test out the game. We can see the player ship get created in our **Game**
    window by pressing **Play** in the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our game in `PlayerSpawner` game object as the
    parent of the `Player` game object; also note the `PlayerSpawner` icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.44 – The current Player setup in our game'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.44_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.43 – The current Player setup in our game
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next section, create a prefab of the `PlayerSpawner`
    game object by dragging and dropping it into the `Assets/Player`. That way, if
    you lose the scene for whatever reason along with its **Hierarchy** content, you
    can drag and drop your prefab back in. This should be a rule with any common active
    game object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section where we'll continue to work on the `Player`
    script, but this time, we will look at what happens when our player's game object
    comes into contact with an enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Colliding with an enemy – OnTriggerEnter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a function to our `Player` script that
    will check to see what has collided with our player''s game object during runtime.
    Currently, the only thing that can collide with our player is an enemy, but we
    can still demonstrate the use of Unity''s own `OnTriggerEnter` function, which
    handles most of the work for us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing after the scope of our last method (`ActorStats`) in the `Player`
    script, we are going to add the following code that detects our enemy colliding
    with the player''s ship:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s explain some of the code we have just entered into the `Player` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTriggerEnter(Collider other)` is a function that Unity recognizes to check
    what has entered into the player''s trigger collider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use an `if` statement to check whether the `tag` to the collider is called
    `Enemy`. Note when we create our enemy, we will give them an `Enemy` `tag` so
    they are easily identified. If the `tag` is equal to `Enemy`, we drop it into
    that `if` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next `if` statement checks to see whether our player's `health` is equal
    to or more than `1`. If it is, that means the player can take a hit and continue
    without dying and also means we can go into its `if` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We approach the third `if` statement that checks to see whether the collider
    has a game object named `energy +1(Clone)`. The name of this object is the name
    of the shield the player can purchase in the game shop, which we will add in [*Chapter
    6*](B18381_06_Epub.xhtml#_idTextAnchor120), *Purchasing In-Game Items and Advertisements*.
    If the player has this `energy +1(Clone)` object, we can `Destroy` it with Unity's
    premade function. We also deduct the player's extra health from the enemies' `SendDamage`
    function. We will discuss `SendDamage` later on in the chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the third `if` statement is an `else` condition where, in the event
    that the player doesn't have an `energy +1(Clone)` game object, they get their
    health deducted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the player's `health` is at a value of zero or under, we run the
    `Die` method, which we will cover later in the chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't forget to keep saving your work as we continue to add more code to the
    project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's continue with our `Player` script and add the functionality so that the
    player can receive and send damage from and to the enemy respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next method, we are going to add two methods. The first method (`TakeDamage`)
    will take an integer called `incomingDamage` and use whatever the value is to
    deduct from our player's `health` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second method (`SendDamage`) will `return` an integer of our `hitPower`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just below and outside of the scope of our `ActorStats` method, now add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's continue with another method for the `Player` script and make it possible
    for the player to control the player ship around the **Game** window.
  prefs: []
  type: TYPE_NORMAL
- en: The Movement method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will code the `Movement` method, which will take input from
    the player's joypad/keyboard and also make use of the `height` and `width` floats
    to keep the player's ship within the scree:.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the `Player` script, make a start with the following method using
    the following content to check for the player''s input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Movement` method will consist of detecting movement in four directions
    being made from the player; we'll start with when the player presses right on
    the controller/keyboard. We run an `if` statement that checks whether the Input
    Manager has detected any movement from the `Horizontal` property. If the `GetAxisRaw`
    detects a value higher than zero, we fall into the `if` statement's condition.
    Note that `GetAxisRaw` has no smoothing, so the player's ship will instantly move
    unless extra code is added.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have another `if` statement; this checks whether the player has exceeded
    past the `width` (that is, of the screen's world space that we calculated earlier
    on in the chapter). We've also added an extra partial `width` to avoid the geometry
    of the player's ship leaving the screen. If the player's position is still under
    the `width` (and its buffer) value, we run the content inside the `if` statement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The player's position is updated with a `Vector3` struct, which holds the value
    of the `Horizontal` direction, multiplied by time per frame and by the `travelSpeed`
    we set from our `ScriptableObject`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s continue in the `Movement` method and add a similar `if` statement for
    moving the player ship to the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, the code is close to the previous block; the only difference
    is that our first `if` statement checks whether we are moving left; the second
    `if` statement checks whether the player's position is greater than the width
    and a slightly different buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from that, the `if` statement and its content serve the same position,
    just in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with our `Movement` method and add the `if` statement code
    for moving the player''s ship down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Yet again, we follow the same rule from the previous two `if` statements, but
    this time, instead of `Horizontal`, we add the `Vertical` `string` property. In
    the second `if` statement, we check whether the player's y-axis is higher than
    a negative `height/3`. The reason why we divide by this value is that later on
    in the book ([*Chapter 9*](B18381_09_Epub.xhtml#_idTextAnchor161)*, Creating a
    2D Shop Interface and In-Game HUD*), we will be adding graphics at the bottom
    of the screen that will restrict the player's view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the last `if` statement in the `Movement` method, moving
    up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As before, this `if` statement carries a similar role, but this time, it's checking
    whether the player's position is under the `height/2.5f` value. A buffer is applied
    to stop the three-dimensional geometry from leaving the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When making a game, sometimes it occurs that when the player moves diagonally,
    their speed increases. This is because the player is effectively pressing two
    directions at the same time instead of just one.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure a direction has just the magnitude of `1`, we can use Unity's pre-made
    `Normalize` function.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about this function, check the documentation at [https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html](https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html).
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will continue with the `Player` script by adding the `Die` method.
  prefs: []
  type: TYPE_NORMAL
- en: The Die method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding the `Die` method to the `Player` script will make it possible for our
    player to be destroyed. Currently, inside the `Die` method is a Unity function
    called `Destroy`; this function will delete whatever game object is within its
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following method in the `Player` script to destroy the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's move on to the last method in the `Player` script, which is to attack.
  prefs: []
  type: TYPE_NORMAL
- en: The Attack method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will add content to the `Attack` method in the `Player`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this `Attack` method is to receive input from the player, create
    a bullet, point the bullet in the correct direction, and make the bullet a child
    of the `Player` game object to keep our **Hierarchy** window tidy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following `Attack` method into the `Player` script to allow the player
    to fire bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `Attack` method, we call an `if` statement that checks whether the
    player has pressed the `Fire1` button (*Left Ctrl* on Windows; *command* if you
    are using a Mac). If the player has pressed the `Fire1` button, we will drop into
    the `if` statement's scope.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When a developer refers to the scope of a function, `if` statement, class,
    and so on, they are referring to what is happening between the opening and closing
    of the curly braces. For example, if the following code has a higher value in
    its `money` variable, the following `if` statement will run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (money > costOfPizza)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`//Whatever happens between the top and bottom of the two curly braces is within
    the if statements scope.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: Within the `if` statement, we make another `if` statement to make sure that
    when clicking the mouse, we are clicking on the screen and not anything UI-related.
    This will become more relevant when we look at adding a Pause button in [*Chapter
    10*](B18381_10_Epub.xhtml#_idTextAnchor173), *Pausing the Game, Altering Sound,
    and a Mock Test*. If we do click on something UI-related, we call `return`, which
    means we exit the `if` statement so that we don't fire a shot.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have entered the movement and attack function content we can scroll
    back up to the `Update` function and remove the comments we added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Update` function will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we `Instantiate` our `PlayerBullet` game object from its instance name,
    `fire`. We also face the `fire` game object to the right, relative to the screen,
    and move it toward oncoming enemies. We store the results of creating and orienting
    our game object in a variable named `bullet`.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the size of the bullet to be seven times larger than its original
    size, which makes it look bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, within the `if` statement, we make our `bullet` game object sit within
    a single game object with the variable name `_Player`.
  prefs: []
  type: TYPE_NORMAL
- en: That is all of the code required for the `Player` script! Make sure to save
    the script before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to move on to a different player script that
    controls what happens when the player fires their bullet.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our PlayerBullet script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be creating a bullet that will travel across the screen
    from the player's ship.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice how similar the `PlayerBullet` script is to the `Player` script
    because it carries the `IActorTemplate` and `SOActorModel` scripts, which are
    already coded into the `Player` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `PlayerBullet` script:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Scripts` folder with the filename `PlayerBullet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and check/enter the following code at the top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, we require the `UnityEngine` library, as previously mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by checking the correct class name and entering the following
    inheritance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We declare the `public` class and by default inherit `MonoBehaviour`. We also
    inherit the `IActorTemplate` interface to give our game object-related methods
    from the other game object scripts, such as `SendDamage` and `TakeDamage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following global variables into the `PlayerBullet` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the variables we add are `private`. The last variable has a `SerializeField`
    attribute added. `SerializeField` makes it possible for this variable to be visible
    in the `private`, we can still drag and drop assets into its field (which we will
    do shortly). More information on the `SerializeField` attributes can be found
    at [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll move on and enter the `Awake` function along with its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our `Awake` function is the `ActorStats` method, which is a requirement because
    we are inheriting an `interface` that declares it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by entering the `SendDamage` and `TakeDamage` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As mentioned already in this chapter, we require these methods to send and receive
    damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we enter the `Die` method along with its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another method to include from our `interface` is the `Die` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter the `ActorStats` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last method that we inherit from our `interface` is the `ActorStats` method,
    which will hold our `ScriptableObject` asset. This asset will then be assigned
    to our `PlayerBullet` script's global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function is the `OnTriggerEnter`, along with its `if` statement condition
    checks, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding block of code, we run a check to see whether our bullet has
    collided with an `"Enemy"` tagged collider. If the collider is tagged as `"Enemy"`
    to the player, we then check to see whether the collider holds an `IActorTemplate`
    interface. If it doesn't, then it's likely the `"Enemy"` collider is an obstacle.
    Otherwise, we deduct `health` from the `Enemy` game object and check to see whether
    it's dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s enter Unity''s `Update` function for the bullet''s movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Update` function adds to its x-axis each frame based on its `travelSpeed`
    value multiplied by `Time.deltaTime` (`Time.deltaTime` is the time in seconds
    from the last frame).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to know more about `Time.deltaTime`, check the documentation
    at [https://docs.unity3d.com/ScriptReference/Time-deltaTime.html](https://docs.unity3d.com/ScriptReference/Time-deltaTime.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter Unity''s `OnBecameInvisible` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This last function will remove any unnecessary bullets that have left the screen.
    This will help the performance of our game and keep it tidy. Make sure you have
    saved the script before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to apply the `PlayerBullet` script to our `player_bullet` prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `Assets/Prefab/Player` and select `player_bullet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `Player_Bullet` selected, click the `PlayerBullet` until you see the `PlayerBullet`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the script and add the `PlayerBullet` asset to it from the **Bullet Model**
    field (drag the asset into the field or click the remote button to the right of
    its field).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our `player_bullet` with its script and asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.45 – The player_bullet components in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.45_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.44 – The player_bullet components in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next section about making enemies for the player to
    attack!
  prefs: []
  type: TYPE_NORMAL
- en: Planning and creating our enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a player that moves, shoots, and takes damage; we can now start looking
    into creating an enemy that shares these attributes.
  prefs: []
  type: TYPE_NORMAL
- en: To remind ourselves of the genre we are making, our game carries the same traits
    as classic arcade shooters such as Konami's *Gradius*, Capcom's *UN Squadron*,
    and Irem's *R-Type* ([https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png](https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png)).
    Typically, with these types of games, the player is swarmed by enemies coming
    from the right of the screen and exiting to the left.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be repeating similar aspects of the `PlayerSpawner`
    and `Player` scripts. The `EnemySpawner` script needs to be tweaked so that it
    will instantiate a given number of enemy ships at a certain rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Enemy` game objects will be moving on their own, so there needs to be
    some extra code applied to their behavior. Before we go into creating our first
    enemy script, let''s look at a part of our game framework and note that the layout
    is basically the same as the player''s side of the game framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.46 – EnemySpawner and Enemy UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.46_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.45 – EnemySpawner and Enemy UML
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into the `EnemySpawner` script, let''s do the same housekeeping
    we did for our player game objects, namely creating an empty game object and storing
    all game objects relating to it in that one game object. The reason we did this
    is to remove the clutter in the **Hierarchy** window, so let''s do the same for
    our enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window's open space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A drop-down list will appear; select **Create Empty**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the game object `_Enemies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's move on to our enemy scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our EnemySpawner and Enemy scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to make a start on our `EnemySpawner` script
    and game object. The purpose of the `EnemySpawner` script is to have a game object
    spawn an enemy game object a series of times at a set rate. As soon as our `testLevel`
    scene begins, our enemy spawners will start releasing enemies. It will then be
    up to the enemies to move to the left of the screen. This is fairly simple, and
    as mentioned briefly in the previous section, the `EnemySpawner` uses the same
    `interface` and scriptable object as the `PlayerSpawner` to `instantiate` enemies.
    Let''s start by creating our `EnemySpawner` script:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Scripts` folder with the filename `EnemySpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As usual, we are using the default `UnityEngine` library.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to be using another library, called `System.Collections`.
    This is required when we come to use `Coroutines`, which will be explained later
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will check/enter the class name and its inheritance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the class is named `EnemySpawner` and that it also inherits `MonoBehaviour`
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, add four global variables to the `EnemySpawner` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All variables entered in the previous code have an accessibility level of `private`,
    and all of the variables apart from the `enemies` variable have a `SerializeField`
    and a `Range` attribute of between `0` to `10` applied. The reason for this is
    so that we or other designers can easily change the spawn rate and quantity of
    enemies from our `EnemySpawner` in the **Inspector** window, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.47 – Enemy spawn rate slider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.47_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.46 – Enemy spawn rate slider
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s enter Unity''s `Awake` function along with some content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `Awake` function, we make an instance from the empty `_Enemies` game
    object divider and store it in the `enemies` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code inside our `Awake` function is a `StartCoroutine`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Information
  prefs: []
  type: TYPE_NORMAL
- en: '`StartCoroutine()` and `IEnumerator` go hand in hand with each other. They
    act similarly to a method, taking parameters and running the code inside it. The
    main difference with coroutines is that they can be delayed by frame updates or
    time. You can consider them a more advanced version of Unity''s own `Invoke` function.'
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about coroutines and how to implement them in `IEnumerator`
    instances, check Unity's documentation at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html).
  prefs: []
  type: TYPE_NORMAL
- en: This will be used to run our method of creating an enemy, but as you may also
    notice, it takes two parameters. The first is the `quantity` of enemies it holds
    and the second is the `spawnRate`, which delays each spawned enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in our `EnemySpawner` script, we have the `FireEnemy`, which will be used
    to run a cycle of creating and positioning each enemy, before waiting to repeat
    the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, below and outside of the `Awake` function, we can add our `IEnumerator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `FireEnemy` `IEnumerator`, we start a `for` loop that will iterate
    over its `qty` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `for` loop, the following is added:'
  prefs: []
  type: TYPE_NORMAL
- en: A method that we haven't covered yet, called `CreateEnemy`. The result of `CreateEnemy`
    will be turned into a game object instance called `enemyUnit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `enemyUnit` is the enemy flying out of the `EnemySpawner` game object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `EnemySpawner` position is issued to our `enemyUnit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then wait however many seconds the `spwnRte` value is set to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the process is repeated up until the `for` loop has reached its total.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, below and outside of the `FireEnemy` `IEnumerator`, add the following
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we mentioned, there is a method called `CreateEnemy`. Apart from the obvious,
    this method will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Instantiate` the `enemy` game object from its `ScriptableObject` asset.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply values to our enemy from its `ScriptableObject` asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the enemy game object from its `ScriptableObject` asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't forget to save the script.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next section where we will create and prepare the
    `EnemySpawner` with its game object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our script to the EnemySpawner game object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we need to attach our `EnemySpawner` script to an empty game object
    so that we can use it in our `testLevel` scene. To set up the `EnemySpawner` game
    object, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty game object and name it `EnemySpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did with the `_Player` and `PlayerSpawner`, we need to move the `EnemySpawner`
    game object inside the `_Enemies` game object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After moving the `EnemySpawner` game object into the `_Enemies` game object,
    we now need to update the `EnemySpawner` game object''s **Transform** property
    values in the **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.48 – The EnemySpawner Transform values in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.48_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.47 – The EnemySpawner Transform values in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: Still in the `EnemySpawner` until you see it in the list, and then click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, for a visual aid in the `EnemySpawner` game object, as we did with our
    `PlayerSpawner` game object in the *Creating the PlayerSpawner game object* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the icon I gave to my `EnemySpawner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.49 – The EnemySpawner icon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.49_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.48 – The EnemySpawner icon
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add an enemy to our `EnemySpawner` game object with its script in
    the **Inspector** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.50 – The EnemySpawner component holding the BasicWave Enemy actor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.50_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.49 – The EnemySpawner component holding the BasicWave Enemy actor
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to creating our enemy script in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our enemy script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with our player ship being created from the `PlayerSpawner`, our first enemy
    will be created from its `EnemySpawner`. The enemy script will hold similar variables
    and functions, but it will also have its own movement, similar to the `PlayerBullet`
    moving along its *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start and create our enemy script:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Scripts` folder with the filename `EnemyWave`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and check/enter the following required library code at the
    top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like the majority of our classes, we require the `UnityEngine` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check and enter the class name and its inheritance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have a `public class` named `EnemyWave` that inherits `MonoBehaviour` by
    default but also adds our `IActorTemplate` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `EnemyWave` class, enter the following global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The global variables for the `EnemyWave` class are the top four variables updated
    with values from its `ScriptableObject` asset. The other variables are specific
    to the enemy, and we have given two of these variables `SerializeField` attributes
    for debugging purposes in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add Unity''s `Update` function along with its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the global variables, we add an `Update` function containing an `Attack`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add our `ScriptableObject` method, `ActorStats`, and its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have our `ActorStats` method that takes in a `ScriptableObject` `SOActorModel`.
    This `ScriptableObject` then applies the variable values it holds and applies
    them to the `EnemyWave` script's variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the `EnemyWave` script, add the `Die` method along with its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another familiar method if you have been following along is the `Die` method,
    which is called when the enemy has been destroyed by the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add Unity''s `OnTriggerEnter` function to the `EnemyWave` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unity's own `OnTriggerEnter` function will check to see whether they have collided
    with the player and, if so, will send damage, and the enemy will destroy themselves
    with the `Die` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue and enter the `TakeDamage` and `SendDamage` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another common set of methods from the `IActorTemplate` interface is to send
    and receive damage from the `EnemyWave` script.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `Attack` method, which controls the movement/attack of the enemy.
    This method is called in the `Update` function on every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this attack, we will make the enemy move from right to left in a wavy
    animation (like a snake) instead of just going straight right to left. The following
    image shows our enemies moving from right to left in a wavy line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.51 – The enemies'' wave attack pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.51_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.50 – The enemies' wave attack pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following `Attack` method code into the `EnemyWave` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Attack` method starts with `Time.deltaTime` being collected in a `float`
    variable labeled `time`.
  prefs: []
  type: TYPE_NORMAL
- en: We then use a premade function from Unity that returns a sine ([https://docs.unity3d.com/ScriptReference/Mathf.Sin.html](https://docs.unity3d.com/ScriptReference/Mathf.Sin.html))
    using our `time` variable, multiplied by a set speed from the `verticalSpeed`
    variable, followed by the result being multiplied by `verticalAmplitude`.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is stored in the `Vector3` *y* axis. What this basically does
    is make our enemy ship move up and down. The `verticalSpeed` parameter sets its
    speed and `verticalAmplitude` alters how far it goes up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we do a similar task to what we did with the `PlayerBullet` to make the
    enemy ship move along the *x* axis, and we also add a sine calculation to its
    `Y` position for it to move up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the script before we wind down this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we summarize, click **Play** in the Editor, and hopefully, if all is
    well, you will have a player ship that you will be able to fly around within the
    boundaries of the **Game** window''s aspect ratio; enemies will come floating
    into the screen and move from right to left; you will be able to destroy these
    enemies with your bullets. These enemies will also be able to destroy you if they
    make contact with you. Finally, our **Hierarchy** window is all neat and well-structured
    both before and after playing our game. The following screenshot shows what I
    have just explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.52 – The Game window with the current gameplay and the Hierarchy
    game object structured'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.52_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.51 – The Game window with the current gameplay and the Hierarchy game
    object structured
  prefs: []
  type: TYPE_NORMAL
- en: You have done so much already! The good news is that you've just conquered one
    of the biggest chapters in the book – quite sneaky of me, I know. But we already
    have the backbone of our game, and most importantly, we've covered a good chunk
    of the Unity Programmer exam.
  prefs: []
  type: TYPE_NORMAL
- en: Understandably, you may have come across some possible issues on the way, and
    you may feel stuck. Don't worry if this is the case – check the `Complete` folder
    for this chapter to load up the Unity project and compare the code in that folder
    with your own to double-check. Make sure you have the right game objects in your
    scene, check that the right game objects are tagged, check the radius size of
    your **Sphere** colliders, and if you have any errors or warnings appear in the
    **Console** window, double-click them, and they will take you to the code that's
    causing the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let's wrap up this chapter and talk about our game so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have reached the end of this chapter, and we have conquered the majority
    of our game framework, as we can see in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.53 – Killer Wave UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.53_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.52 – Killer Wave UML
  prefs: []
  type: TYPE_NORMAL
- en: We have created a game framework that would need only a few changes whether
    we added 1 or 1,000 more enemies to our game. Some of the benefits of this use
    of reusable code and `ScriptableObject` is that it will benefit non-programmers,
    save time, and prevent collaborators from being bogged down in the code.
  prefs: []
  type: TYPE_NORMAL
- en: We have also made it possible that if and when we want to add more `EnemySpawner`
    points, we can drag and drop more prefabs into our scene and update its `ScriptableObject`
    to change the enemy without coding in exact `Vector3` locations.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered other common Unity features, including instantiating game objects
    such as enemies and player bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be covering the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ScoreManager`: When an enemy is destroyed, the player will receive a score.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScenesManager`: If the player dies, one life will be deducted; if the player
    loses all of their lives, the level will reset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sounds`: Our ships and bullets will also have added sounds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will be updating the overall structure of our code.
  prefs: []
  type: TYPE_NORMAL
