<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Introduction to .NET MAUI</h1>
<p>This chapter is all about getting to know <strong class="bold">.NET Multi-platform App UI</strong> (<strong class="bold">.NET MAUI</strong>) and what to expect from it. .NET MAUI enables you to build native cross-platform mobile and desktop apps for Android, iOS, macOS, and Windows using .NET and C#. This is the only chapter that is purely theoretical; all the others cover hands-on projects. You are not expected to write any code at this point, but instead, simply read through this chapter to develop a high-level understanding of what .NET MAUI is, how .NET MAUI relates to .NET, and how to set up a development machine.</p>
<p>We will start by defining what a native app is and what .NET as a technology brings to the table. After that, we will look at how .NET MAUI fits into the bigger picture and learn when it is appropriate to use the traditional .NET mobile and .NET MAUI apps. We often use the term <strong class="bold">traditional .NET mobile app</strong> to describe apps that don’t use .NET MAUI, even though .NET MAUI apps are bootstrapped through a traditional .NET mobile app.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Defining native applications</li>
<li>.NET mobile</li>
<li>Exploring the .NET MAUI framework</li>
<li>Setting up our development machine</li>
<li>.NET mobile productivity tooling</li>
</ul>
<p>Let’s get started!</p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><a id="_idTextAnchor018"/><a id="_idTextAnchor019"/>Defining native applications</h1>
<p>The term <strong class="bold">native application</strong> means different things to different people. For some people, it refers to an app that is developed using the tools specified by the creator of the platform, such as an app developed for iOS with Objective-C or Swift, an <a id="_idIndexMarker000"/><a id="_idIndexMarker001"/>Android app developed with Java or Kotlin, or a Windows app developed with C/C++ or the .NET Framework. Others use the term native application to refer to apps that are compiled into machine code that is native to the platform architecture, for example, x86, x64, or ARM. In this book, we will define a native application as one that has a native UI, performance, and API access. The following list explains these three concepts in greater detail:</p>
<ul>
<li><strong class="bold">Native UI</strong>: Apps built with .NET MAUI use the<a id="_idIndexMarker002"/><a id="_idIndexMarker003"/> standard controls for each platform. This means, for example, that an iOS app built with .NET MAUI will look and behave as an iOS user would expect and an Android app built with .NET MAUI will look and behave as an Android user would expect.</li>
<li><strong class="bold">Native performance</strong>: Apps built with .NET MAUI are <a id="_idIndexMarker004"/><a id="_idIndexMarker005"/>compiled for native performance, meaning that they execute at nearly the same levels as apps built with the tools designed for the platform, that is, Java or Swift, and can use platform-specific hardware acceleration.</li>
<li><strong class="bold">Native API access</strong>: Native API access means that <a id="_idIndexMarker006"/><a id="_idIndexMarker007"/>apps built with .NET MAUI can <a id="_idTextAnchor020"/>use everything that the target platforms and devices offer to developers. For example, .NET MAUI applications can use hardware-specific features such as the camera or maps.</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor021"/>.NET mobile</h1>
<p>.NET mobile (formerly known as Xamarin) is a <a id="_idIndexMarker008"/><a id="_idIndexMarker009"/>set of extensions to .NET that is used to develop native applications <a id="_idIndexMarker010"/><a id="_idIndexMarker011"/>for iOS (<strong class="bold">.NET for iOS/tvOS/Mac Catalyst</strong>), Android (<strong class="bold">.NET for Android</strong>), and macOS (<strong class="bold">.NET for macOS</strong>). .NET is the evolution of the .NET Framework, designed<a id="_idIndexMarker012"/><a id="_idIndexMarker013"/> for cross-platform development. .NET mobile was introduced in .NET Core 5 as optional workloads. It is technically a binding layer on top of these platforms. Using bindings to platform APIs enables .NET developers to use C# (and F#) to develop native applications with the full capacity of each platform.</p>
<p>The C# APIs we use when we develop apps with .NET mobile match the platform APIs, but they are modified to adhere to conventions used in .NET Core. For example, APIs are often customized to follow .NET naming conventions, and the Android <code>set</code> and <code>get</code> methods are often replaced by properties. This makes using the APIs easier and more familiar for .NET developers.</p>
<p><strong class="bold">Mono</strong> (<a href="https://www.mono-project.com">https://www.mono-project.com</a>) is an open source implementation <a id="_idIndexMarker014"/><a id="_idIndexMarker015"/>of the Microsoft .NET Framework, which is based on the <strong class="bold">European Computer Manufacturers Association</strong> (<strong class="bold">ECMA</strong>) standards for C# and<a id="_idIndexMarker016"/><a id="_idIndexMarker017"/> the <strong class="bold">Common Language Runtime</strong> (<strong class="bold">CLR</strong>). Mono was created to bring the .NET Framework to platforms other than Windows. It is part of the .NET Foundation (<a href="http://www.dotnetfoundation.org">http://www.dotnetfoundation.org</a>), an independent organization that supports open development and collaboration involving the .NET ecosystem. Since .NET 5, Mono is now a supported runtime for applications built on .NET. No separate installer is needed to use Mono with .NET; it is included in the installer for .NET. The Mono runtime is used for iOS, tvOS, Mac Catalyst, and Android applications, while the .NET Core CLR is used for all other supported platforms<a id="_idTextAnchor022"/>.</p>
<p>With a combination of the .NET mobile platforms, .NET, and Mono, we can use both the platform-specific APIs and the platform-independent parts of .NET, including namespaces such as <code>System</code>, <code>System.Linq</code>, <code>System.IO</code>, <code>System.Net</code>, and <code>System.Threading.Tasks</code>.</p>
<p>There are several reasons for using .NET <a id="_idIndexMarker018"/><a id="_idIndexMarker019"/>mobile for mobile app development, which we will cover in the following sections.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor023"/>Code sharing</h2>
<p>If we use one common programming<a id="_idIndexMarker020"/><a id="_idIndexMarker021"/> language for multiple mobile platforms (and even server platforms), then we can share a lot of code between our target platforms, as illustrated in the following diagram. All code that isn’t related to the target platform can be shared with other .NET platforms. Code that is typically shared in this way includes business logic, network calls, and data models:</p>
<div><div><img alt="Figure 1.1 – .NET MAUI code sharing" src="img/Figure_1.1_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – .NET MAUI code sharing</p>
<p>There is also a large community based around the .NET platforms, providing a different form of code sharing. There is a wide range of third-party libraries and components that can be downloaded from NuGet (<a href="https://nuget.org">https://nuget.org</a>) that can provide you with additional features or capabilities that work across all supported .NET MAUI platforms. For example, you can find NuGet packages that provide databases, graphs, or barcode reading to include in your apps.</p>
<p>Code sharing across platforms leads to shorter development times. It also produces apps of a higher quality because, for example, we only need to write the code for business logic once. There is a lower risk of bugs, and it is also able to guarantee that a calculation returns the same result, regardless of what platform our users use.</p>
<h2 id="_idParaDest-20">U<a id="_idTextAnchor024"/><a id="_idTextAnchor025"/><a id="_idTextAnchor026"/>se of existing knowledge</h2>
<p>For .NET developers who want to start<a id="_idIndexMarker022"/><a id="_idIndexMarker023"/> building native mobile apps, it is easier to just learn the APIs for the new platforms than it is to learn programming languages and APIs for both old and new platforms.</p>
<p>Similarly, organizations that want to build native mobile apps can use existing developers with their knowledge of .NET to develop apps. Because there are more .NET developers than Objective-C and Swift developers, it’s easier to find new developers for mobile <a id="_idTextAnchor027"/>app development projects.</p>
<h2 id="_idParaDest-21">.<a id="_idTextAnchor028"/>NET mobile platforms</h2>
<p>The different .NET mobile platforms <a id="_idIndexMarker024"/><a id="_idIndexMarker025"/>available are .NET for iOS/tvOS/Mac Catalyst, .NET for Android, and .<a id="_idTextAnchor029"/>NET for macOS. In this section, we will take a look at each of them.</p>
<h3>.NET for iOS/tvOS/Mac Catalyst</h3>
<p>.NET for iOS/tvOS/Mac Catalyst is used <a id="_idIndexMarker026"/><a id="_idIndexMarker027"/>to build apps for iOS, tvOS, or Mac Catalyst, respectively, with .NET and contains the bindings to the iOS APIs mentioned previously. .NET for iOS/tvOS/Mac Catalyst uses <code>System.Linq</code> or <code>System.Net</code>, is executed by the Mono runtime, while code that uses iOS-specific namespaces is executed by the Objective-C runtime. Both the Mono runtime and the Objective-C runtime run on<a id="_idIndexMarker032"/><a id="_idIndexMarker033"/> top of the <strong class="bold">X is Not Unix</strong> (<strong class="bold">XNU</strong>) Unix-like kernel (<a href="https://github.com/apple/darwin-xnu">https://github.com/apple/darwin-xnu</a>), which was developed by Apple. The following diagram shows an overview of the iOS architecture:</p>
<div><div><img alt="Figure 1.2 – .NET for iOS" src="img/Figure_1.2_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – .NET for iOS</p>
<h3>.NET for macOS</h3>
<p>.NET for macOS is used to build apps<a id="_idIndexMarker034"/><a id="_idIndexMarker035"/> for macOS with .NET and contains the bindings to the macOS APIs. .NET for macOS has the same architecture as .NET for iOS—the only difference is, .NET for macOS apps are <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>)-compiled, unlike .NET for iOS apps, which are AOT-compiled. This is shown in the following diagram:</p>
<div><div><img alt="Figure 1.3 – .NET for macOS" src="img/Figure_1.3._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – .NET for macOS</p>
<h3>.NET for Android</h3>
<p>.NET for Android is used to build apps<a id="_idIndexMarker036"/><a id="_idIndexMarker037"/> for Android with .NET and contains bindings to the Android APIs. The Mono runtime and the <strong class="bold">Android Runtime</strong> (<strong class="bold">ART</strong>) run side by side on<a id="_idIndexMarker038"/><a id="_idIndexMarker039"/> top of a Linux kernel. .NET for Android apps could either be JIT-compiled or AOT-compiled, but to AOT-compile them, we need to use Visual Studio Enterprise.</p>
<p>Communication between the Mono runtime and <a id="_idIndexMarker040"/><a id="_idIndexMarker041"/>ART occurs via a <strong class="bold">Java Native Interface</strong> (<strong class="bold">JNI</strong>) bridge. There are two types of JNI bridges—<strong class="bold">Manage Callable Wrapper</strong> (<strong class="bold">MCW</strong>) and <strong class="bold">Android Callable Wrapper</strong> (<strong class="bold">ACW</strong>). An MCW is used when <a id="_idIndexMarker042"/><a id="_idIndexMarker043"/>code needs to run in ART and an ACW is used when ART needs to run code in the Mono runtime, as shown:</p>
<div><div><img alt="Figure 1.4 – .NET for Android" src="img/Figure_1.4._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – .NET for Android</p>
<p class="callout-heading">.NET for Tizen</p>
<p class="callout">.NET MAUI has additional support for the Tizen platform from Samsung. Samsung provides the binding layer and runtime to allow .NET MAUI to run on the Tizen platform. To learn more about how to install and develop for the Tizen platform, visit <a href="https://github.com/Samsung/Tizen.NET">https://github.com/Samsung/Tizen.NET</a> in your browser.</p>
<p>Now that we understand what .NET mobile <a id="_idIndexMarker044"/><a id="_idIndexMarker045"/>is and how each platform works, we can explore .NET MAUI in detail.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor030"/>Exploring the .NET MAUI framework</h1>
<p>.NET MAUI is a cross-platform framework that is built on top of .NET mobile (for iOS and Android) and the <strong class="bold">Windows UI</strong> (<strong class="bold">WinUI</strong>) library. .NET MAUI allows <a id="_idIndexMarker046"/><a id="_idIndexMarker047"/>developers to create a UI for iOS, Android, and WinUI in XAML. .NET MAUI improves on Xamarin.Forms by placing all platform-specific functionality in the same project as cross-platform functionality, making it <a id="_idIndexMarker048"/><a id="_idIndexMarker049"/>easier to find and edit your code. .NET MAUI also includes all of what used to be in Xamarin.Essentials, which provides cross-platform capabilities, such as permissions, location, photos and camera, contacts, and maps, and leverages that cross-platform functionality with one shared code base, as illustrated in the following diagram:</p>
<div><div><img alt="Figure 1.5 – .NET MAUI architecture" src="img/Figure_1.5_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – .NET MAUI architecture</p>
<p>If we build an app with .NET MAUI, we can use XAML, C#, or a combination of both to create the UI.</p>
<h2 id="_idParaDest-23">The a<a id="_idTextAnchor031"/><a id="_idTextAnchor032"/><a id="_idTextAnchor033"/>rchitecture of .NET MAUI</h2>
<p>.NET MAUI is an abstraction layer on top of each platform. .NET MAUI has a shared layer that is used by all platforms, as well as a platform-specific layer. The platform-specific layer<a id="_idIndexMarker050"/><a id="_idIndexMarker051"/> contains <strong class="bold">handlers</strong>. A handler is a class that maps a .NET MAUI <a id="_idIndexMarker052"/><a id="_idIndexMarker053"/>control to a platform-specific native control. Each .NET MAUI control has a platform-specific handler.</p>
<p>The following diagram illustrates how the entry control in .NET MAUI is mapped to the correct native control for each platform. The entry control is mapped to a <code>UITextField</code> control from the <code>UIKit</code> namespace when the shared .NET MAUI code is used in an iOS app. On Android, the entry control is mapped to an <code>EditText</code> control from the <code>AndroidX.AppCompat.Widget</code> namespace. Finally, for Windows, .NET MAUI <code>Entry</code> handlers map to <code>TextBox</code> from the <code>Microsoft.UI.Xaml.Controls</code> namespace.</p>
<div><div><img alt="Figure 1.6 – .NET MAUI control architecture" src="img/Figure_1.6_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – .NET MAUI control architecture</p>
<p>With a firm grasp of .NET MAUI <a id="_idIndexMarker054"/><a id="_idIndexMarker055"/>architecture and .NET mobile platforms, it is time to explore how to create UIs in .NET MAUI.</p>
<h2 id="_idParaDest-24">Defin<a id="_idTextAnchor034"/><a id="_idTextAnchor035"/><a id="_idTextAnchor036"/>ing a UI using XAML</h2>
<p>The most common way to declare our UI in .NET MAUI is by defining it in a XAML document. It is also possible to create the GUI in C#, since XAML is<a id="_idIndexMarker056"/><a id="_idIndexMarker057"/> a markup language for instantiating objects. We could, in theory, use XAML to create any type of object, provided it has a parameterless constructor. A XAML document is an <strong class="bold">Ex<a id="_idTextAnchor037"/>tensible Markup Language</strong> (<strong class="bold">XML</strong>) document with a specific schema.</p>
<p>Over the next few sections, we are going to learn about a few controls in .NET MAUI to get us started. Then, we will compare different ways that you can construct the UI using .NET MAUI.</p>
<h3>Defini<a id="_idTextAnchor038"/>ng a Label control</h3>
<p>As a simple example, let’s<a id="_idIndexMarker058"/><a id="_idIndexMarker059"/> look at the following snippet of a XAML document:</p>
<pre class="source-code">
&lt;Label Text="Hello World!" /&gt;</pre> <p>When the XAML parser encounters this snippet, it creates an instance of a <code>Label</code> object and then sets the properties of the object that correspond to the attributes in the XAML. This means that if we set a <code>Text</code> property in XAML, it sets the <code>Text</code> property on the instance of the <code>Label</code> object that is created. The XAML in the preceding <a id="_idIndexMarker060"/><a id="_idIndexMarker061"/>example has the same effect as the following:</p>
<pre class="source-code">
var obj = new Label()
{
    Text = "Hello World!"
};</pre> <p>XAML exists to make it easier to view the object hierarchy that we need to create in order to make a GUI. An object model for a GUI is also hierarchical by design, so XAML supports adding child objects. We can simply add them as child nodes, as follows:</p>
<pre class="source-code">
&lt;StackLayout&gt;
    &lt;Label Text="Hello World" /&gt;
    &lt;Entry Text="Ducks are us" /&gt;
&lt;/StackLayout&gt;</pre> <p><code>StackLayout</code> is a container control that organizes the children vertically or horizontally within a container. Vertical organization is the default value and is used unless we specify otherwise. There are other containers, such as <code>Grid</code> and <code>FlexLayout</code>.</p>
<p>These will be used in many of the projects in the following chapters.</p>
<h3>Creati<a id="_idTextAnchor039"/><a id="_idTextAnchor040"/><a id="_idTextAnchor041"/>ng a page in XAML</h3>
<p>A single control is no use unless it has a <a id="_idIndexMarker062"/><a id="_idIndexMarker063"/>container that hosts it. Let’s see what an entire page would look like. A fully valid <code>ContentPage</code> object defined in XAML is <a id="_idIndexMarker064"/>an XML document. This means that we must start with an XML declaration. After that, we must have one—and only one—root node, as shown:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ContentPage  
 x:Class="MyApp.
MainPage"&gt;
    &lt;StackLayout&gt;
        &lt;Label Text="Hello world!" /&gt;
    &lt;/StackLayout&gt;
&lt;/ContentPage&gt;</pre> <p>In the preceding example, we defined a <code>ContentPage</code> object that translates into a single view on each platform. In order to make it valid XAML, we need to specify a default namespace (<code>http://schemas.microsoft.com/dotnet/2021/maui"&gt;http://schemas.microsoft.com/dotnet/2021/maui<strong class="source-inline">"</code>) and then add the <code>x</code> namespace (<code>http://schemas.microsoft.com/winfx/2009/xaml"&gt;http://schemas.microsoft.com/winfx/2009/xaml<strong class="source-inline">"</code>).</strong></strong></p>
<p>The default namespace lets us create objects without prefixing them, such as the <code>StackLayout</code> object. The <code>x</code> namespace lets us access properties such as <code>x:Class</code>, which tells the XAML parser which class to instantiate to control the page when the <code>ContentPage</code> object is created.</p>
<p>A <code>ContentPage</code> object can have only one child. In this case, it’s a <code>StackLayout</code> control. Unless we specify otherwise, the default layout orientation is vertical. A <code>StackLayout</code> object can, therefore, have multiple children. Later in the <a id="_idIndexMarker065"/><a id="_idIndexMarker066"/>book, we will touch on more advanced layout controls, such as the <code>Grid</code> and <code>FlexLayout</code> controls.</p>
<p>As the first child of <code>StackLayout</code>, we will create a <code>Label</code> control.</p>
<h3>Creati<a id="_idTextAnchor042"/><a id="_idTextAnchor043"/><a id="_idTextAnchor044"/>ng a page in C#</h3>
<p>For clarity, the following code shows you how<a id="_idIndexMarker067"/><a id="_idIndexMarker068"/> the previous example would look in C#:</p>
<pre class="source-code">
public class MainPage : ContentPage
{
}</pre> <p><code>MainPage</code> is a class that inherits from .NET MAUI’s <code>ContentPage</code>. This class is automatically generated for us if we create a XAML page, but if we just use code, we will need to define it ourselves.</p>
<p>Let’s create the same control hierarchy as the XAML page we defined earlier using the following code:</p>
<pre class="source-code">
var page = new MainPage();
var stacklayout = new StackLayout();
stacklayout.Children.Add(
    new Label()
    {
        Text = "Welcome to .NET MAUI"
    });
page.Content = stacklayout;</pre> <p>The first statement creates a <code>page</code> object. We could, in theory, create a new <code>ContentPage</code> page directly, but this would prohibit us from writing any code behind it. For this reason, it’s good practice to subclass each page that we plan to create.</p>
<p>The block following this first statement creates the <code>StackLayout</code> control, which contains the <code>Label</code> control that is added to the <code>Children</code> collection.</p>
<p>Finally, we need to assign <code>StackLayout</code> to the <code>Content</code> property of the page.</p>
<p>Since XAML is a markup language that mainly instantiates objects for us, we can see how easy it is to replicate that in C#. Next, we will take a look at some extensions that make developing your UI in C# a little better.</p>
<h3>Using the .NET MAUI Markup Community Toolkit</h3>
<p>The Community Toolkit organization on GitHub has a<a id="_idIndexMarker069"/><a id="_idIndexMarker070"/> project to add <strong class="bold">Fluent</strong> extensions to MAUI for creating the UI in C#. The project <strong class="bold">.NET MAUI Markup Community Toolkit</strong> (<a href="https://github.com/CommunityToolkit/Maui.Markup">https://github.com/CommunityToolkit/Maui.Markup</a>), or <strong class="bold">MAUI.Markup</strong> for short, is <a id="_idIndexMarker071"/><a id="_idIndexMarker072"/>described on the website as follows:</p>
<p class="author-quote">The .NET MAUI Markup Community Toolkit is a collection of Fluent C# Extension Methods that allows developers to continue architecting their apps using MVVM, Bindings, Resource Dictionaries, etc., without the need for XAML<em class="italic">.</em></p>
<p>Using <a id="_idTextAnchor045"/><a id="_idTextAnchor046"/>MAUI Markup to create the same page we did in the previous two sections would look something like the following:</p>
<pre class="source-code">
public class MainPage: ContentPage
{
    public MainPage()
    {
        Build();
    }
    public void Build() {
        Content = new StackLayout()
        {
            Children =
            {
                new Label()
                {
                    Text = "Welcome to .NET MAUI"
                }
            }
        };
    }
}</pre> <p>For more information on how to use MAUI Markup in your applications, visit <a href="https://github.com/CommunityToolkit/Maui.Markup">https://github.com/CommunityToolkit/Maui.Markup</a> using your favorite web browser.</p>
<p>So, what is better for creating our UI, XAML or C#?</p>
<h3>XAML or C#?</h3>
<p>Generally, using XAML provides a much better overview, since the page is a hierarchical structure of objects, and XAML is a very nice way of defining that structure. In code, the structure is flipped around as we need to define the innermost object first, making it harder to read the structure of our page. This was demonstrated in the <em class="italic">Creating a page in XAML</em> section of this chapter. Having said that, it is generally a matter of preference as to how we decide to define the GUI. This book will use XAML rather than C# in the projects to come.</p>
<p>Now th<a id="_idTextAnchor047"/><a id="_idTextAnchor048"/><a id="_idTextAnchor049"/>at we’ve explored how to create our pages using .NET MAUI, it is time to review how .NET MAUI and .NET mobile compare.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor050"/>.NET MAUI versus traditional .NET mobile</h2>
<p>While this book is about .NET MAUI, we will also highlight the differences between using traditional .NET mobile and .NET MAUI. Traditional .NET mobile <a id="_idIndexMarker073"/><a id="_idIndexMarker074"/>is used when developing UIs that use the iOS or Android <strong class="bold">software development kit</strong> (<strong class="bold">SDK</strong>) without any means of abstraction. For example, we can create an iOS app that defines its UI in a storyboard or in the <a id="_idIndexMarker075"/>code directly. This code would not be reusable for other platforms, such as Android. Apps built using this approach can still share non-platform-specific code by simply referencing a .NET standard library. This relationship is shown in the following diagram: </p>
<div><div><img alt="Figure 1.7 – Traditional .NET UI" src="img/Figure_1.7_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Traditional .NET UI</p>
<p>.NET MAUI, on the other hand, is an abstraction of the GUI, which allows us to define UIs in a <a id="_idIndexMarker076"/>platform-agnostic <a id="_idIndexMarker077"/>way. It still builds on top of .NET for iOS, .NET for Android, and all the other supported platforms. The .NET MAUI app is created as a .NET standard library where the shared source files and platform-specific source files are all built within the same project for the platform we are currently building for. This relationship is shown in the following diagram:<a id="_idTextAnchor051"/></p>
<div><div><img alt="Figure 1.8 – .NET MAUI UI with a single project" src="img/Figure_1.8_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – .NET MAUI UI with a single project</p>
<p>Having said that, .NET MAUI cannot exist without traditional .NET mobile since it’s bootstrapped through an app for each platform. This gives us the ability to extend .NET MAUI on each platform using custom renderers and platform-specific code that can be exposed to our <a id="_idIndexMarker078"/>shared <a id="_idIndexMarker079"/>code base through interfaces. We’ll look at these concepts <a id="_idTextAnchor052"/>in more detail later in this chapte<a id="_idTextAnchor053"/>r.</p>
<h3>When to use .NET MAUI</h3>
<p>We can use .NET MAUI in <a id="_idIndexMarker080"/>most cases and for most types of apps. If we need to use controls that are not available in .NET MAUI, we can always use the platform-specific APIs. There are, however, cases where .NET MAUI is not useful. The most common situation where we might want to avoid using .NET MAUI is if we build an app t<a id="_idTextAnchor054"/>hat should look very different across our different target platfor<a id="_idTextAnchor055"/>ms.</p>
<p>Enough theory for<a id="_idIndexMarker081"/> now; let’s get our development machines ready to develop using .NET MAUI.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor056"/>Setting up our development machine</h1>
<p>Developing an app for multiple platforms imposes higher demands on our development machine. One reason<a id="_idIndexMarker082"/> for this is that we often want to run one or multiple simulators or emulators on our development machine. Different platforms also have different requirements for what is needed to begin development. Regardless of whether we use macOS or Windows, Visual Studio will be our <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>). There <a id="_idIndexMarker083"/>are several versions of Visual Studio, including the free community edition. Go to <a href="https://visualstudio.microsoft.com/">https://visualstudio.microsoft.com/</a> to compare the available versions, and select the version that is right for you; .NET MAUI is included in all versions of Visual Studio for Windows and macOS. The following list is a summary of what we need to begin development for each platform:</p>
<ul>
<li><strong class="bold">iOS</strong>: To develop an<a id="_idIndexMarker084"/> app for iOS, we <a id="_idIndexMarker085"/>need a <strong class="bold">Macintosh</strong> (<strong class="bold">Mac</strong>) device. This could either be the machine that we are developing on or a machine on our network, if we are using one. The reason we need to connect to a Mac is we need Xcode to build the app package. Xcode also provides various simulators to run and debug your app. It is possible to do some iOS development on Windows without a connected Mac; you can read more about this in the <em class="italic">Xamarin Hot Restart</em> section of this chapter.</li>
<li><strong class="bold">Android</strong>: Android apps can be developed on either macOS or Windows. Everything we need, including SDKs and simulators, is installed with Visual Studio.</li>
<li><strong class="bold">WinUI</strong>: WinUI apps can only be developed in Visual Studio on a Windows machine.</li>
</ul>
<p>We’ll start with setting up a Mac first, and then later cover Windows. If you do not own a Mac, you can skip this<a id="_idIndexMarker086"/> section and head straight to the <em class="italic">Setting up a Windows </em><em class="italic">machine<a id="_idTextAnchor057"/><a id="_idTextAnchor058"/><a id="_idTextAnchor059"/></em> section.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor060"/>Setting up a Mac</h2>
<p>There are two main<a id="_idIndexMarker087"/> tools that are required to <a id="_idIndexMarker088"/>develop apps for iOS and Android with .NET mobile on a Mac. These are Visual Studio for Mac (if we are only developing Android apps, this is the only tool we need) and Xcode. In the following sections, w<a id="_idTextAnchor061"/>e will look at how to set up a Mac for app d<a id="_idTextAnchor062"/>evelopment.</p>
<h3>Installing Xcode</h3>
<p>Before we install Visual <a id="_idIndexMarker089"/>Studio, we need to download and install Xcode. Xcode<a id="_idIndexMarker090"/> is the official development IDE from Apple and contains all the tools available for iOS development, including SDKs for iOS, macOS, Mac Catalyst, and tvOS.</p>
<p>We can download Xcode from the Apple developer portal (<a href="https://developer.apple.com">https://developer.apple.com</a>) or the Apple App Store. I recommend that you download it from the App Store because this guarantees you have the latest stable version. The only reason to download Xcode from the developer portal is if you want to use a prerelease version of Xcode to develop it for a prerelease of iOS.</p>
<p>When using prerelease versions of macOS and its accompanying version of Xcode, it is possible that .NET for iOS/tvOS/Mac Catalyst/macOS has not been updated to work with the latest Xcode changes. It is recommended to check the compatibility before installing the latest Xcode to ensure a working environment.</p>
<p>After the first installation, and after each update of Xcode, it is important that you open it. Xcode often needs to install additional components after an installation or <a id="_idTextAnchor063"/>an update. We also need to open Xcode to accept the license agreemen<a id="_idTextAnchor064"/>t with Apple.</p>
<h3>Installing Visual Studio</h3>
<p>To install <a id="_idIndexMarker091"/>Visual<a id="_idIndexMarker092"/> Studio, we first need to download it from <a href="https://visualstudio.microsoft.com">https://visualstudio.microsoft.com</a>.</p>
<p class="callout-heading">Visual Studio for Mac deprecation</p>
<p class="callout">On August 31, 2023, Microsoft announced the deprecation of Visual Studio for Mac in accordance with their Modern Lifecycle Policy, which will mean the end of support on August 31, 2024. Visual Studio for Mac will remain supported until that date. If you have a Visual Studio subscription, you can always download the latest version of Visual Studio for Mac from <a href="http://my.visualstudio.com">my.visualstudio.com</a>. Microsoft has released the C# Dev Kit and .NET MAUI Dev Kit extensions for Visual Studio Code. The extensions work on Windows, macOS, and Linux. You can use Visual Studio Code and these extensions to complete the projects in this book, although the instructions pertaining to the UI for Visual Studio for Mac will not match Visual Studio Code. To learn more, visit <a href="https://learn.microsoft.com/en-us/visualstudio/mac/what-happened-to-vs-for-mac?view=vsmac-2022">https://learn.microsoft.com/en-us/visualstudio/mac/what-happened-to-vs-for-mac?view=vsmac-2022</a>.</p>
<p>When we start the <a id="_idIndexMarker093"/>Visual Studio installer via the file we downloaded, it <a id="_idIndexMarker094"/>will start to check what we already have installed on our machine. When the check is finished, we can select which platforms and tools we would<a id="_idTextAnchor065"/> like to install.</p>
<p>Once we have selected the platforms that we want to install, Visual Studio downloads and installs everything that we need to get started with app development using .NET mobile, as shown:</p>
<div><div><img alt="Figure 1.9 – Visual Studio f﻿﻿or Mac installer" src="img/Figure_1.9_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Visual Studio f<a id="_idTextAnchor066"/><a id="_idTextAnchor067"/>or Mac installer</p>
<h3>Configuring the Android Emulator</h3>
<p>Visual Studio <a id="_idIndexMarker095"/>uses the Android emulators provided<a id="_idIndexMarker096"/> by Google. They are installed and configured through SDK Manager.</p>
<p class="callout-heading">Special note for Intel-based Mac device</p>
<p class="callout">If we want our emulator to be fast, then we need to ensure that it is hardware-accelerated. To hardware-accelerate the Android emulator, we need to install the<a id="_idIndexMarker097"/> Intel<strong class="bold"> Hardware Accelerated Execution Manager</strong> (<strong class="bold">HAXM</strong>), which can be downloaded from <a href="https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm">https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm</a>.</p>
<p>The next step is to create the Android emulator. First, we need to ensure that the Android emulator and the Android OS images are installed. To do this, take the following steps:</p>
<ol>
<li>Go to<a id="_idIndexMarker098"/> the <strong class="bold">Tools</strong> tab to install the Android emulator:</li>
</ol>
<div><div><img alt="Figure 1.10 – Install﻿ing Android Emulator in Vi﻿sual Studio for Mac" src="img/Figure_1.10_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Installing Android Emulator in Vi<a id="_idTextAnchor069"/>sual Studio for Mac</p>
<ol>
<li value="2">We also need to<a id="_idIndexMarker099"/> install one or multiple images to use with the emulator. We can install multiple images if, for example, we want to run our app on different versions of Android. We can select emulators with Google Play (as in the following screenshot) so that we can use Google Play services in our app, even when we are running it in an emulator. This is required if, for example, we want to use Goo<a id="_idTextAnchor070"/>gle Maps in our app:</li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 1.11 – Install﻿ing emulator images in Visual Studio for Mac" src="img/Figure_1.11_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Installing emulator images in Visual Studio for Mac</p>
<p class="callout-heading">Intel versus Apple M1</p>
<p class="callout">If you have an Apple Mac that uses the M1 chipset, then you should use emulator images that have <strong class="bold">ARM 64</strong> in the name; otherwise, if you are using older Mac devices with the Intel chipset, then use images with <strong class="bold">Intel x86</strong> in the name.</p>
<ol>
<li value="3">Then, to<a id="_idIndexMarker100"/> create <a id="_idIndexMarker101"/>and configure an emulator, go to <strong class="bold">Device Manager</strong> in the <strong class="bold">Tools</strong> menu in Visual Studio. From <strong class="bold">Android Device Manager</strong>, we can start an emulator if we already have one created, or we can create new emulators, as shown:</li>
</ol>
<div><div><img alt="Figure 1.12 – Android Device Manager in Visual Studio for Mac" src="img/Figure_1.12_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Android Device Manager in Visual Studio for Mac</p>
<ol>
<li value="4">If we click on the <strong class="bold">New Device</strong> button, we can create a new emulator with the specifications<a id="_idIndexMarker102"/> that we need. The easiest way to<a id="_idIndexMarker103"/> create a new emulator here is to select a base device that matches our needs. These base devices are preconfigured, which is often enough. However, it is also possible to edit the properties of the device so that we have an emulator that matc<a id="_idTextAnchor071"/>hes our specific needs.<p class="list-inset">The processor dropdown will be preselected with the correct architecture of your device. If you change this, for example, from ARM to x86 or x86 to ARM, then the emulator will be slower; always try to use the architecture that matches your device.</p></li>
</ol>
<div><div><img alt="Figure 1.13 – Creat﻿ing a new Android device" src="img/Figure_1.13_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Creating a new Android device</p>
<p>If you only have a Mac, then you are done and can skip to the <em class="italic">.NET mobile productivity tooling</em> section. If<a id="_idIndexMarker104"/> you have a Windows device, then<a id="_idIndexMarker105"/> the next section, <em class="italic">Setting up a Windo<a id="_idTextAnchor072"/><a id="_idTextAnchor073"/>ws machine</em>, is for you.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor074"/>Setting up a Windows machine</h2>
<p>We can use <a id="_idIndexMarker106"/>either a virtual or physical <a id="_idIndexMarker107"/>Windows machine for development with .NET mobile. We can, for example, run a virtual Windows machine on our M<a id="_idTextAnchor075"/>ac. The only tool we need for app development on our Windows <a id="_idTextAnchor076"/>machine is Visual Studio.</p>
<h3>Installing .NET mobile for Visual Studio 2022 or later</h3>
<p>If we already have <a id="_idIndexMarker108"/>Visual <a id="_idIndexMarker109"/>Studio 2022 or later installed, we first need to open <strong class="bold">Visual Studio Installer</strong>; otherwise, we<a id="_idIndexMarker110"/> need<a id="_idIndexMarker111"/> to go to <a href="https://visualstudio.microsoft.com">https://visualstudio.microsoft.com</a> to download the installation files. Under the banner in the <strong class="bold">Meet the Visual Studio Family</strong> section, you can find the links to download Visual Studio 2022 for Windows o<a id="_idTextAnchor077"/>r Visual Studio 2022 for Mac.</p>
<p>Before the installation starts, we need to select which workloads we want to install.</p>
<p>For .NET MAUI development, we need to install <strong class="bold">.NET Multi-platform App UI development</strong>. Select the <strong class="bold">ASP.NET and web development</strong> workload to be able to develop MAUI/Blazor hybrid apps.</p>
<div><div><img alt="Figure 1.14 – Visual Studio 2022 installer" src="img/Figure_1.14_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – Visual Studio 2022 installer</p>
<p>Hyper-V is<a id="_idIndexMarker112"/> the <a id="_idIndexMarker113"/>default hardware acceleration method when using .NET MAUI. If you want to use Intel HAXM, you will need to check the checkbox for Intel HAXM in the <strong class="bold">Individual components</strong> tab, as in the following screenshot:</p>
<div><div><img alt="Figure 1.15 – Add﻿ing Intel HAXM" src="img/Figure_1.15_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – Adding Intel HAXM</p>
<p>When we first start Visual Studio, we will be asked whether we want to sign in. It is not necessary for us to sign in unless we want to use Visual Studio Professional or Enterprise, in which case we will need to sign in so tha<a id="_idTextAnchor078"/><a id="_idTextAnchor079"/><a id="_idTextAnchor080"/>t our license can be verified.</p>
<p>Now that Visual <a id="_idIndexMarker114"/>Studio is<a id="_idIndexMarker115"/> installed, we can finish the configuration needed to run and debug apps for iOS and Android.</p>
<h3>Pairing Visual Studio with a Mac</h3>
<p>If we want to<a id="_idIndexMarker116"/> run, debug, and compile <a id="_idIndexMarker117"/>our iOS <a id="_idIndexMarker118"/>app from a Windows development machine, then we need to connect it to a Mac. We can set up our Mac manually, as described earlier in this chapter, or we can use <strong class="bold">Automatic Mac Provisioning</strong> from<a id="_idIndexMarker119"/> within Visual Studio. This installs Mono and .NET for iOS on the Mac that we are connecting to. It will not install the Visual Studio IDE, but this isn’t necessary if we just want to use it as a build machine. We do, however, need to install Xcode manually.</p>
<p>To connect to the Mac from Visual Studio, use the <strong class="bold">Pair to Mac</strong> button in the toolbar (as in the following screenshot), or, in the top menu, go to <strong class="bold">Tools</strong> | <a id="_idTextAnchor081"/><strong class="bold">iOS</strong> | <strong class="bold">Pair </strong><strong class="bold">to Mac</strong>:</p>
<div><div><img alt="Figure 1.16 – Pair to Mac button" src="img/Figure_1.16_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Pair to Mac button</p>
<p>If this is the first time you have attempted to pair to a Mac, Visual Studio will open a wizard that will guide you through the steps you need to take on your Mac to enable Visual<a id="_idIndexMarker120"/> Studio<a id="_idIndexMarker121"/> to<a id="_idIndexMarker122"/> connect.</p>
<div><div><img alt="Figure 1.17 – Pair to Mac wizard" src="img/Figure_1.17_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17 – Pair to Mac wizard</p>
<p>To be able to connect to a Mac—either manually or using <strong class="bold">Automatic Mac Provisioning</strong>—we need to be able to access the Mac via our network, and we need to enable <strong class="bold">Remote Login</strong> on the Mac.</p>
<p>To do this, go to <strong class="bold">Settings</strong> | <strong class="bold">Sharing</strong> and select the checkbox for <strong class="bold">Remote Login</strong>. To the left of the window, we can select which users are allowed to connect with <strong class="bold">Remote Login</strong>, as shown:</p>
<div><div><img alt="Figure 1.18 – Enabl﻿ing Remote Login on macOS" src="img/Figure_1.18_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18 – Enabling Remote Login on macOS</p>
<p>A dialog<a id="_idIndexMarker123"/> box <a id="_idIndexMarker124"/>will <a id="_idIndexMarker125"/>appear showing all the Macs that can be found on the network. If your Mac doesn’t appear in the list of available Macs, you can use the <strong class="bold">Add Mac...</strong> button in the bottom-left corner of the window to enter an IP address, as shown:</p>
<div><div><img alt="Figure 1.19 – Pair to ﻿Mac" src="img/Figure_1.19_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19 – Pair to Mac</p>
<p>If everything that we need is installed on the Mac, then Visual Studio will connect, and we can start building and debugging our iOS app. If Mono is missing on the Mac, a warning will appear. This warning will also give us the option to install it, as shown:</p>
<div><div><img alt="Figure 1.20 – Missing Mono installation dialog" src="img/Figure_1.20_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20 – Missing Mono installation dialog</p>
<p>Now that we<a id="_idIndexMarker126"/> have our Mac paired, we <a id="_idIndexMarker127"/>can<a id="_idIndexMarker128"/> get the Android emulator configured.</p>
<h3>Configuring an Android emulator and hardware acceleration</h3>
<p>If we want a<a id="_idIndexMarker129"/> fast<a id="_idIndexMarker130"/> Android<a id="_idIndexMarker131"/> emulator<a id="_idIndexMarker132"/> that works smoothly, we need to enable hardware acceleration. This can be done using either Intel HAXM or Hyper-V. The disadvantage of Intel HAXM is that it can’t be used on machines with <a id="_idIndexMarker133"/>an <strong class="bold">Advanced Micro Devices</strong> (<strong class="bold">AMD</strong>) processor; we must use a machine with an Intel processor. We can’t use Intel HAXM in parallel with Hyper-V.</p>
<p>Because of this, Hyper-V is the preferred way to hardware-accelerate an Android emulator on a Windows machine. To use Hyper-V with our Android emulator, we need to have Windows 11 or Windows 10 with the April 2018 update (or later), and Visual Studio 2017 version 15.8 (or later) installed.</p>
<p class="callout-heading">Find your version of Visual Studio</p>
<p class="callout">To determine the version of Visual Studio you are using, when Visual Studio is open, use the <strong class="bold">Help</strong> | <strong class="bold">About Visual Studio</strong> menu, and you should be presented with a dialog similar to the following:</p>
<div><div><img alt="" role="presentation" src="img/Figure_1.21._B19214.jpg"/>
</div>
</div>
<p class="callout">Figure 1.21 – Help | About</p>
<p>To<a id="_idIndexMarker134"/> enable<a id="_idIndexMarker135"/> Hyper-V, we <a id="_idIndexMarker136"/>need to<a id="_idIndexMarker137"/> take the following steps:</p>
<ol>
<li>Open the search menu and type in <code>Turn Windows features on or off</code>. Click the option that<a id="_idTextAnchor082"/> appears to open it, as shown:</li>
</ol>
<div><div><img alt="Figure 1.22 – Turn Windows feature﻿s on or off" src="img/Figure_1.22._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.22 – Turn Windows features on or off</p>
<ol>
<li value="2">To<a id="_idIndexMarker138"/> enable <a id="_idIndexMarker139"/>Hyper-V, select the <strong class="bold">Hyper-V</strong> checkbox. Also, expand<a id="_idIndexMarker140"/> the <strong class="bold">Hyper-V</strong> option<a id="_idIndexMarker141"/> and check the <strong class="bold">Hyper-V Platform</strong> checkbox. We also need to select the <strong class="bold">Windows Hypervisor Platform</strong> checkbox, as shown:</li>
</ol>
<div><div><img alt="Figure 1.23 – Enabl﻿ing Hyper-V in Windows Features" src="img/Figure_1.23._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.23 – Enabling Hyper-V in Windows Features</p>
<ol>
<li value="3">Restart <a id="_idIndexMarker142"/>the<a id="_idIndexMarker143"/> machine<a id="_idIndexMarker144"/> when <a id="_idIndexMarker145"/>Windows prompts you to do so.</li>
<li>Because we didn’t install an Android emulator during the installation of Visual Studio, we need to install it now. Go to the <strong class="bold">Tools</strong> menu in Visual Studio<a id="_idTextAnchor083"/>, then click on <strong class="bold">Android</strong> and then <strong class="bold">Android </strong><strong class="bold">SDK Manager</strong>.</li>
<li>Under <strong class="bold">Tools</strong> in <strong class="bold">Android SDK Manager</strong>, we can install the emulator by selecting <strong class="bold">Android Emulator</strong>, as in the following screenshot. Also, we should ensure that<a id="_idIndexMarker146"/> the<a id="_idIndexMarker147"/> latest version of <strong class="bold">Android SDK Build Tools</strong> is installed:</li>
</ol>
<div><div><img alt="Figure 1.24 – Install﻿ing Android Emulator in Android SDK Manager" src="img/Figure_1.24._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.24 – Installing Android Emulator in Android SDK Manager</p>
<ol>
<li value="6">The Android SDK allows multiple emulator images to be installed simultaneously. We can install multiple images if, for example, we want to run our app on different versions of Android. Select emulators with <strong class="bold">Google Play</strong> (as in the following screenshot) so that we can use Google Play services in our app, even when we are running it in an emulator.<p class="list-inset">This is required if, for example, we want to use Google Maps in our app:</p></li>
</ol>
<div><div><img alt="Figure 1.25 – I﻿nstall﻿ing Android Emulator images in Android SDK Manager" src="img/Figure_1.25._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.25 – I<a id="_idTextAnchor084"/>nstalling Android Emulator images in Android SDK Manager</p>
<ol>
<li value="7">Be sure <a id="_idIndexMarker148"/>to <a id="_idIndexMarker149"/>click the <strong class="bold">Apply Changes</strong> button to install any components you selected <a id="_idIndexMarker150"/>before <a id="_idIndexMarker151"/>closing the window.</li>
<li>The next step is to create a virtual device to use the emulator image. To create and configure an emulator, go to <strong class="bold">Android Device Manager</strong>, which we can open from the <strong class="bold">Tools</strong> tab in Visual Studio. From the device manager, we can either start an emulator—if we already hav<a id="_idTextAnchor085"/>e one created—or we can create new emulators, as shown:</li>
</ol>
<div><div><img alt="Figure 1.26 – Android Device Manager" src="img/Figure_1.26._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.26 – Android Device Manager</p>
<p>If we click on the <strong class="bold">New</strong> button, we can create a new emulator with the specifications that we need. The easiest way to create a new emulator here is to select a base device that matches our needs. These<a id="_idIndexMarker152"/> base devices are <a id="_idIndexMarker153"/>preconfigured, which<a id="_idIndexMarker154"/> is often enough. However, it is possible to edit <a id="_idIndexMarker155"/>the properties of the device so that we have an emulator that matches our specific needs.</p>
<p>We must select the correct processor for the emulator to match the processor in our Windows development machine. If it doesn’t match, then the emulator will be slower than it needs to be. Select the <strong class="bold">x86_64</strong> processor (as in the following screenshot) if you are using Intel or AMD x86-based hardwar<a id="_idTextAnchor086"/><a id="_idTextAnchor087"/><a id="_idTextAnchor088"/>e, or <strong class="bold">arm64-v*</strong> if you have an ARM device running Windows.</p>
<div><div><img alt="Figure 1.27 – Creat﻿ing a new device in Android Device Manager" src="img/Figure_1.27._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.27 – Creating a new device in Android Device Manager</p>
<h3>Configuring Developer Mode</h3>
<p>If we want to <a id="_idIndexMarker156"/>develop desktop apps for<a id="_idIndexMarker157"/> Windows, we need to activate Developer Mode on our development machine. To do this, go to <strong class="bold">Settings</strong> | <strong class="bold">Privacy &amp; security</strong> | <strong class="bold">For developers</strong>. Then, select <strong class="bold">Developer Mode</strong>, as in the following screenshot. This makes it possible for us to sideload and debug apps via Visual Studio:</p>
<div><div><img alt="Figure 1.28 – Enabl﻿ing Developer Mode" src="img/Figure_1.28._B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.28 – Enabling Developer Mode</p>
<p>At this point, our Windows machine is ready for development. Before we dive into creating our first <a id="_idIndexMarker158"/>project, there are a few more <a id="_idIndexMarker159"/>optional features that we should review. Th<a id="_idTextAnchor089"/><a id="_idTextAnchor090"/><a id="_idTextAnchor091"/>ese will help your development process as you build your apps.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor092"/>.NET mobile productivity tooling</h1>
<p><strong class="bold">Xamarin Hot Resta<a id="_idTextAnchor093"/>rt</strong> and <strong class="bold">Hot Reload</strong> are<a id="_idIndexMarker160"/> two<a id="_idIndexMarker161"/> tools that<a id="_idIndexMarker162"/> increase productivity for .NET MAUI developers. To get even better performance from your Androi<a id="_idTextAnchor094"/>d emulators, you can use<a id="_idIndexMarker163"/> the <strong class="bold">Windows Subsystem for </strong><strong class="bold">Android</strong> (<strong class="bold">WSA</strong>).</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor095"/>Xamarin Hot Restart</h2>
<p>Hot Restart is a <a id="_idIndexMarker164"/>Visual Studio feature to<a id="_idIndexMarker165"/> make developers more productive. It also gives us a way of running and debugging iOS apps on an iPhone without having to use a Mac connected to Visual Studio. Microsoft describes Hot Restart as follows:</p>
<p class="author-quote">Xamarin Hot Restart enables you to quickly test changes to your app during development, including multi-file code edits, resources, and references. It pushes the new changes to the existing app bundle on the debug target which results in a much faster build and deploy cycle.</p>
<p>To use Hot Restart, you need the following:</p>
<ul>
<li>Visual Studio 2019 version 16.5</li>
<li>iTunes (Microsoft Store or 64-bit versions)</li>
<li>An Apple Developer account and paid Apple Developer Program (<a href="https://developer.apple.com/programs/">https://developer.apple.com/programs/</a>) enrollment</li>
</ul>
<p>Hot Restart can currently only be used with .NET for iOS apps.</p>
<p>Read more about the current state of Hot Restart at <a href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/deploy-test/hot-restart">https://docs.microsoft.com/en-us/xamarin/xamarin-forms/deploy-test/hot-restart</a>.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor097"/>Hot Reload</h2>
<p>Hot Reload is a <a id="_idIndexMarker166"/>runtime technology that allows us to <a id="_idIndexMarker167"/>update our running app with the changes we are making in the IDE. There are two major flavors of Hot <a id="_idIndexMarker168"/>Reload<a id="_idIndexMarker169"/> today: <strong class="bold">XAML Hot Reload</strong> and <strong class="bold">C# </strong><strong class="bold">Hot Reload</strong>.</p>
<p>XAML Hot Reload allows us to make changes to our XAML without having to redeploy our app. When we have carried out changes to the XAML, we just save the file, and it updates the page on the simulator/emulator or on a device. XAML Hot Reload is currently supported by all .NET MAUI platforms.</p>
<p>C# Hot Reload allows us to make changes to our code without having to redeploy our app. C# Hot Reload is like <em class="italic">Edit &amp; Continue</em>; however, you do not have to be in break mode in order to apply the changes to the app. Once you have made changes to your code, you can click the <strong class="bold">Hot Reload</strong> button in the toolbar of Visual Studio and Hot Reload will update the running app. If, for some reason, the changes cannot be applied, Hot Reload will display a dialog either asking you to fix any<a id="_idTextAnchor098"/> compilation errors or, in some cases, requiring you to restart the app.</p>
<p>To enable XAML Hot Reload for Visual Studio on Windows, go to <strong class="bold">Tools</strong> | <strong class="bold">Options</strong> | <strong class="bold">Xamarin</strong> | <strong class="bold">Hot Reload</strong>.</p>
<p>To enable XAML Hot Reload for Visual Studio on Mac, go to <strong class="bold">Visual Studio</strong> | <strong class="bold">Preferences</strong> | <strong class="bold">Tools for Xamarin</strong> | <strong class="bold">XAML </strong><strong class="bold">Hot Reload</strong>.</p>
<p>C# Hot Reload is <a id="_idIndexMarker170"/>only available in Visual Studio for Windows; to <a id="_idIndexMarker171"/>enable it, go to <strong class="bold">Tools</strong> | <strong class="bold">Options</strong> | <strong class="bold">Debugger</strong> | <strong class="bold">.NET / C++ </strong><strong class="bold">Hot Reload</strong>.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor099"/>Windows Subsystem for Android</h2>
<p>If you are using <a id="_idIndexMarker172"/>Windows 11 in <a id="_idIndexMarker173"/>a supported region, you can use WSA as<a id="_idIndexMarker174"/> your debugging target instead of the Android emulators. To learn more about WSA and how to set up your machine to use it, visit <a href="https://learn.microsoft.com/en-us/windows/android/wsa/">https://learn.microsoft.com/en-us/windows/android/wsa/</a>.</p>
<p>If you want to use WSA to debug your .NET MAUI apps, it will help if you install the WSA Barista Visual Studio extension (<a href="https://marketplace.visualstudio.com/items?itemName=Redth.WindowsSubsystemForAndroidVisualStudioExtension">https://marketplace.visualstudio.com/items?itemName=Redth.WindowsSubsystemForAndroidVisualStudioExtension</a>). This will add the <strong class="bold">Windows Subsystem for Android</strong> menu item under <strong class="bold">Tools</strong>, which will prompt you to install WSA from the Windows Store, and then automatically configure WSA and set up Visual Studio to use WSA as a device.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor100"/>Summary</h1>
<p>You should now feel a bit more comfortable with what .NET mobile is and how .NET MAUI relates to .NET mobile.</p>
<p>In this chapter, we established a definition of what a native app is and saw how it has a native UI, performance, and API access. We talked about how .NET mobile uses Mono, which is an open source implementation of the .NET Framework, and discussed how, at its core, .NET mobile is a set of bindings to platform-specific APIs. We then looked at how .NET for iOS and .NET for Android work under the hood.</p>
<p>After that, we began to touch on the core topic of this book, which is .NET MAUI. We started with an overview of how platform-agnostic controls are rendered to platform-specific controls and how to use XAML to define a hierarchy of controls to assemble a page. We then spent some time looking at the difference between a .NET MAUI app and a traditional .NET mobile app.</p>
<p>A traditional .NET mobile app uses platform-specific APIs directly, without any abstraction, other than what .NET adds as a platform. .NET MAUI is an API that is built on top of the traditional .NET APIs and allows us to define platform-agnostic GUIs in XAML or in code that is rendered to platform-specific controls. There’s more to .NET MAUI than this, but this is what it does at its core.</p>
<p>In the last part of this chapter, we discussed how to set up a development machine on Windows or macOS. Finally, we looked at three optional features that you can use to help improve your<a id="_idIndexMarker175"/> development cycle: Hot Restart, Hot Reload, and WSA.</p>
<p>Now, it’s time to put our newly acquired knowledge to use! We will start by creating a <em class="italic">to-do</em> app from the ground up in the next chapter. We will look at concepts such as <strong class="bold">Model–View–ViewModel</strong> (<strong class="bold">MVVM</strong>) for a clean separation between business logic and the UI and SQLite.NET to persist data to a local database on our device. We will do this for three platforms at the same time—so, read on!</p>
</div>
</body></html>