- en: 4\. Data Structures and LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the main collections and their primary
    usage in C#. You will then see how Language-Integrated Query (LINQ) can be used
    to query collections in memory using code that is efficient and succinct. By the
    end of this chapter, you will be well versed in using LINQ for operations such
    as sorting, filtering, and aggregating data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the previous chapters, you have used variables that refer to a single
    value, such as the `string` and `double` system types, system `class` instances,
    and your own class instances. .NET has a variety of data structures that can be
    used to store multiple values. These structures are generally referred to as collections.
    This chapter builds on this concept by introducing collection types from the `System.Collections.Generic`
    namespace.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: You can create variables that can store multiple object references using collection
    types. Such collections include lists that resize to accommodate the number of
    elements and dictionaries that offer access to the elements using a unique key
    as an identifier. For example, you may need to store a list of international dialing
    codes using the codes as unique identifiers. In this case, you need to be certain
    that the same dialing code is not added to the collection twice.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: These collections are instantiated like any other classes and are used extensively
    in most applications. Choosing the correct type of collection depends primarily
    on how you intend to add items and the way you would like to access such items
    once they are in a collection. The commonly used collection types include `List`,
    `Set`, and `HashSet`, which you will cover in detail shortly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: LINQ is a technology that offers an expressive and concise syntax for querying
    objects. Much of the complexities around filtering, sorting, and grouping objects
    can be removed using the SQL-like language, or if you prefer, a set of extension
    methods that can be chained together to produce collections that can be enumerated
    with ease.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET provides various types of in-built data structures, such as the `Array`,
    `List`, and `Dictionary` types. At the heart of all data structures are the `IEnumerable`
    and `ICollection` interfaces. Classes that implement these interfaces offer a
    way to enumerate through the individual elements and to manipulate their items.
    There is rarely a need to create your own classes that derive directly from these
    interfaces, as all the required functionality is covered by the built-in collection
    types, but it is worth knowing the key properties as they are heavily used throughout
    .NET.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The generic version of each collection type requires a single type parameter,
    which defines the type of elements that can be added to a collection, using the
    standard `<T>` syntax of the generic types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The `IEnumerable` interface has a single property, that is, `IEnumerator<T>
    GetEnumerator()`. This property returns a type that provides methods that allow
    the caller to iterate through the elements in the collection. You do not need
    to call the `GetEnumerator()` method directly, as the compiler will call it whenever
    you use a `foreach` statement, such as `foreach(var book in books)`. You will
    learn more about using this in the upcoming sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ICollection` interface has the following properties:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '`int Count { get; }`: Returns the number of items in the collection.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool IsReadOnly { get; }`: Indicates if the collection is read-only. Certain
    collections can be marked as read-only to prevent callers from adding, deleting,
    or moving elements in the collection. C# will not prevent you from amending the
    properties of individual items in a read-only collection.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Add(T item)`: Adds an item of type `<T>` to the collection.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Clear()`: Removes all items from the collection.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Contains(T item)`: Returns `true` if the collection contains a certain value.
    Depending on the type of item in the collection, this can be value-equality, where
    an object is similarly based on its members, or reference-equality, where the
    object points to the same memory location.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void CopyTo(T[] array, int arrayIndex)`: Copies each element from the collection
    into the target array, starting with the first element at a specified index position.
    This can be useful if you need to skip a specific number of elements from the
    beginning of the collection.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Remove(T item)`: Removes the specified item from the collection. If there
    are multiple occurrences of the instance, then only the first instance is removed.
    This returns `true` if an item was successfully removed.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IEnumerable` and `ICollection` are interfaces that all collections implement:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: ICollection and IEnumerable class diagram ](img/B16835_04_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: ICollection and IEnumerable class diagram'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: There are further interfaces that some collections implement, depending on how
    elements are accessed within a collection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The `IList` interface is used for collections that can be accessed by index
    position, starting from zero. So, for a list that contains two items, `Red` and
    `Blue`, the element at index zero is `Red` and the element at index one is `Blue`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: IList class diagram ](img/B16835_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: IList class diagram'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IList` interface has the following properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`T this[int index] { get; set; }`: Gets or sets the element at the specified
    index position.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int Add(T item)`: Adds the specified item and returns the index position of
    that item in the list.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Clear()`: Removes all items from the list.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Contains(T item)`: Returns `true` if the list contains the specified item.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int IndexOf(T item)`: Returns the index position of the item, or `-1` if not found.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Insert(int index, T item)`: Inserts the item at the index position specified.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Remove(T item)`: Removes the item if it exists within the list.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void RemoveAt(int index)`: Removes the item at the specified index position.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have now seen the primary interfaces common to collections. So, now you
    will now take a look at the main collection types that are available and how they
    are used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `List<T>` type is one of the most extensively used collections in C#. It
    is used where you have a collection of items and want to control the order of
    items using their index position. It implements the `IList` interface, which allows
    items to be inserted, accessed, or removed using an index position:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: List class diagram ](img/B16835_04_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: List class diagram'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists have the following behavior:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Items can be inserted at any position within the collection. Any trailing items
    will have their index position incremented.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be removed, either by index or value. This will also cause trailing
    items to have their index position updated.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be set using their index value.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be added to the end of the collection.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be duplicated within the collection.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of items can be sorted using the various `Sort` methods.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One example of a list might be the tabs in a web browser application. Typically,
    a user may want to drag a browser tab amongst other tabs, open new tabs at the
    end, or close tabs anywhere in a list of tabs. The code to control these actions
    can be implemented using `List`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `List` maintains an array to store its objects. This can be efficient
    when adding items to the end, but it may be inefficient when inserting items,
    particularly near the beginning of the list, as the index position of items will
    need to be recalculated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how the generic `List` class is used. The code uses
    the `List<string>` type parameter, which allows `string` types to be added to
    the list. Attempts to add any other type will result in a compiler error. This
    will show the various commonly used methods of the `List` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Chapter04` in your source code folder.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change to the `Chapter04` folder and create a new console app, called `Chapter04`,
    using the following .NET command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Delete the `Class1.cs` file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Examples`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file called `ListExamples.cs`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `System.Collections.Generic` namespace to access the `List<T>` class
    and declare a new variable called `colors`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code declares the new `colors` variable, which can store multiple color
    names as `strings`. Here, the collection initialization syntax is used so that
    `red` and `green` are added as part of the initialization of the variable. The
    `Add` method is called, adding `orange` to the list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `AddRange` adds `yellow` and `pink` to the end of the list:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, there are five colors in the list, with `red` at index position
    `0` and `green` at position `1`. You can verify this using the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the code produces the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using `Insert`, `blue` can be inserted at the beginning of the list, that is,
    at index `0`, as shown in the following code. Note that this moves `red` from
    index `0` to `1` and all other colors will have their index incremented by one:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output on running this code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using `foreach` you can iterate through the strings in the list, writing each
    string to the console, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should get the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, add the following code to reverse the array. Here, each `color` string
    is converted into an array of `char` type using `ToCharArray`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This does not affect any of the values in the `colors` List, as `characters`
    refers to a different object. Note that `foreach` iterates through each string,
    whereas `ForEach` defines an Action delegate to be invoked using each string (recall
    that in *Chapter 3*, *Delegates, Events, and Lambdas*, you saw how lambda statements
    can be used to create `Action` delegates).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code leads to this output:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the next snippet, the `List` constructor accepts a source collection. This
    creates a new list containing a copy of the `colors` strings in this case, which
    is sorted using the default `Sort` implementation:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The string type uses value-type semantics, which means that the `backupColors`
    list is populated with a **copy** of each source string value. Updating a string
    in one list will **not** affect the other list. Conversely, classes are defined
    as reference-types so passing a list of class instances to the constructor will
    still create a new list, with independent element indexes, but each element will
    point to the same shared reference in memory rather than an independent copy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, prior to removing all colors (using `colors.Clear`),
    each value is written to the console (the list will be repopulated shortly):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the code produces this output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, `AddRange` is used again, to add the full list of colors back to the
    `colors` list, using the sorted `backupColors` items as a source:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ConvertAll` method is passed a delegate that can be used to return a new
    list of any type:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, a new `List<string>` is returned with each item being formatted using
    its value and the item''s index in the list. As expected, running the code produces
    this output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the next snippet, two `Contains()` methods are used to show string value-equality
    in action:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the uppercase `RED` is `red` will be. Running the code produces this
    output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, add the following snippet:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the `Exists` method is passed a Predicate delegate, which returns `True`
    or `False` if the test condition is met. Predicate is an inbuilt delegate, which
    returns a boolean value. In this case, `True` will be returned if any item exists
    where the string value ends with the letters `ink` (`pink`, for example).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You know there is already a `red` color, but it will be interesting to see
    what happens if you insert `red` again, twice, at the very beginning of the list:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will get the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This shows that it is possible to insert the same item more than once into a
    list.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The next snippet shows you how to use the `FindAll` method. `FindAll` is similar
    to the `Exists` method, in that it is passed a `Predicate` condition. All items
    that match that rule will be returned. Add the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should get an output as follows. As expected, there are three `red` items returned:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finishing the example, the `Remove` method is used to remove the first `red`
    from the list. There are still two `FindLastIndex` to get the index of the last
    `red` item:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running the code produces this output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/dLbK6](https://packt.link/dLbK6).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of how the generic `List` class is used, it is time for you
    to work on an exercise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.01: Maintaining Order within a List'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of the chapter, web browser tabs were described as an ideal
    example of lists. In this exercise, you will put this idea into action, and create
    a class that controls the navigation of the tabs within an app that mimics a web
    browser.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you will create a `Tab` class and a `TabController` app that allows
    new tabs to be opened and existing tabs to be closed or moved. The following steps
    will help you complete this exercise:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In VSCode, select your `Chapter04` project.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Exercises`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Exercises` folder, add a folder called `Exercise01` and add a file
    called `Exercise01.cs`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Exercise01.cs` and define a `Tab` class with a string URL constructor
    parameter as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the `ToString` method has been overridden to return the current URL to
    help when logging details to the console.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `TabController` class as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `TabController` class contains a List of tabs. Notice how the class inherits
    from the `IEnumerable` interface. This interface is used so that the class provides
    a way to iterate through its items, using a `foreach` statement. You will provide
    methods to open, move, and close tabs, which will directly control the order of
    items in the `_tabs` list, in the next steps. Note that you could have exposed
    the `_tabs` list directly to callers, but it would be preferable to limit access
    to the tabs through your own methods. Hence, it is defined as a `readonly` list.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define the `OpenNew` method, which adds a new tab to the end of the list:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define another method, `Close`, which removes the tab from the list if it exists.
    Add the following code for this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To move a tab to the start of the list, add the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `MoveToStart` will try to remove the tab and then insert it at index `0`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, add the following code to move a tab to the end:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, calling `MoveToEnd` removes the tab first, and then adds it to the end,
    logging the new index position to the console.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `IEnumerable` interface requires that you implement two methods,
    `IEnumerator<Tab> GetEnumerator()` and `IEnumerable.GetEnumerator()`. These allow
    the caller to iterate through a collection using either a generic of type `Tab`
    or using the second method to iterate via an object-based type. The second method
    is a throwback to earlier versions of C# but is needed for compatibility.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'For the actual results for both methods, you can use the `GetEnumerator` method
    of the `_tab` list, as that contains the tabs in list form. Add the following
    code to do so:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can now create a console app that tests the controller''s behavior. Start
    by opening three new tabs and logging the tab details via `LogTabs` (this will
    be defined shortly):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, move `amazon` to the start and `packt` to the end, and log the tab details:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Close the `msoft` tab and log details once more:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, add an extension method that helps log the URL of each tab in `TabController`.
    Define this as an extension method for `IEnumerable<Tab>`, rather than `TabController`,
    as you simply need an iterator to iterate through the tabs using a `foreach` loop.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `PadRight` to left-align each URL, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running the code produces the following output:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes Visual Studio might report a non-nullable property error the first
    time you execute the program. This is a helpful reminder that you are attempting
    to use a string value that may have a null value at runtime.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The three tabs are opened. `amazon.com` and `packtpub.com` are then moved before
    `microsoft.com` is finally closed and removed from the tab list.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/iUcIs](https://packt.link/iUcIs).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have seen how lists can be used to store multiple items
    of the same type while maintaining the order of items. The next section covers
    the `Queue` and `Stack` classes, which allow items to be added and removed in
    a predefined sequence.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Queue class provides a first-in, first-out mechanism. Items are added to
    the end of the queue using the `Enqueue` method and are removed from the front
    of the queue using the `Dequeue` method. Items in the queue cannot be accessed
    via an index element.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Queues are typically used when you need a workflow that ensures items are processed
    in the order in which they are added to the queue. A typical example might be
    a busy online ticketing system selling a limited number of concert tickets to
    customers. To ensure fairness, customers are added to a queuing system as soon
    as they log on. The system would then dequeue each customer and process each order,
    in full, either until all tickets have been sold or the customer queue is empty.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The following example creates a queue containing five `CustomerOrder` records.
    When it is time to process the orders, each order is dequeued using the `TryDequeue`
    method, which will return `true` until all orders have been processed. The customer
    orders are processed in the order that they were added. If the number of tickets
    requested is more than or equal to the tickets remaining, then the customer is
    shown a success message. An apology message is shown if the number of tickets
    remaining is less than the requested amount.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The Queue''s Enqueue() and Dequeue() workflow ](img/B16835_04_04.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The Queue''s Enqueue() and Dequeue() workflow'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Examples` folder of your `Chapter04` source folder, add a new class
    called `QueueExamples.cs` and edit it as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add five orders to the queue using the `Enqueue` method as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, use a `while` loop that repeats until `TryDequeue` returns `false`, meaning
    all current orders have been processed:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the example code produces the following output:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first time you run this program, Visual Studio might show a non-nullable
    type error. This error is a reminder that you are using a variable that could
    be a null value.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The output shows that `Dave` requested two tickets. As there are two or more
    tickets available, he was successful. Both `Siva` and `Julien` were also successful,
    but by the time `Kane` placed his order of two tickets, there was only one ticket
    available, so he was shown the apology message. Finally, `Ann` requested one ticket
    and was successful in her order.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/Zb524](https://packt.link/Zb524).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Stack` class provides the opposite mechanism to the `Queue` class; items
    are processed in last-in, first-out order. As with the `Queue` class, you cannot
    access elements via their index position. Items are added to the stack using the
    `Push` method and removed using the `Pop` method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: An application's `Undo` menu can be implemented using a stack. For example,
    in a word processor, as the user edits a document, an `Action` delegate is created,
    which can reverse the most recent change whenever the user presses `Ctrl` + `Z`.
    The most recent action is popped off the stack and the change is undone. This
    allows multiple steps to be undone.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The Stack''s Push() and Pop() workflow ](img/B16835_04_05.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The Stack''s Push() and Pop() workflow'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows this in practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You will start by creating an `UndoStack` class that supports multiple undo
    operations. The caller decides what action should run each time the `Undo` request
    is called.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical undoable operation would be storing a copy of text prior to the user
    adding a word. Another undoable operation would be storing a copy of the current
    font prior to a new font being applied. You can start by adding the following
    code, where you are creating the `UndoStack` class and defining a `readonly Stack
    of Action` delegates, named `_undoStack`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new class called `StackExamples.cs`
    and edit it as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When the user has done something, the same action can be undone. So push an
    `Action` to the front of `_undoStack`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Undo` method checks to see if there are any items to undo, then calls
    `Pop` to remove the most recent `Action` and invoke it, thus undoing the change
    that was just applied. The code for this can be added as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you can create a `TextEditor` class that allows edits to be added to `UndoStack`.
    This constructor is passed `UndoStack` as there could be multiple editors that
    need to add various `Action` delegates to the stack:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, add the `EditText` command, which takes a copy of the `previousText`
    value and creates an `Action` delegate that can revert the text to its previous
    value, if invoked:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, the `newText` value should be appended to the `Text` property, using the
    `+=` operator. The details for this are logged to the console, using `PadRight`
    to improve the format:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, it is time to create a console app that tests `TextEditor` and `UndoStack`.
    Four edits are initially made, followed by two **undo operations**, and finally
    two more text edits:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running the console app produces the following output:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Visual Studio may show non-nullable property error the first time the code is
    executed. This is because Visual Studio notices that the `Text` property can be
    a null value at runtime so offers a suggestion to improve the code.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The left-hand output shows the text edits and undoes operations as they are
    applied and the resulting `Text` value on the right-hand side. The two `Undo`
    calls result in `near by` and `city` being removed from the `Text` value, before
    `land` and `far far away` are finally added to the `Text` value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/tLVyf](https://packt.link/tLVyf).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: HashSets
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HashSet` class provides mathematical set operations with collections of
    objects in an efficient and highly performant manner. `HashSet` does not allow
    duplicate elements and items are not stored in any particular order. Using the
    `HashSet` class is ideal for high-performance operations, such as needing to quickly
    find where two collections of objects overlap.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, `HashSet` is used with the following operations:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '`public void UnionWith(IEnumerable<T> other)`: Produces a set union. This modifies
    `HashSet` to include the items present in the current `HashSet` instance, the
    other collection, or both.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void IntersectWith(IEnumerable<T> other)`: Produces a set intersect.
    This modifies `HashSet` to include items present in the current `HashSet` instance
    and the other collection.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void ExceptWith(IEnumerable<T> other)`: Produces a set subtraction.
    This removes items from the `HashSet` that are present in the current `HashSet`
    instance and the other collection.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HashSet` is useful when you need to include or exclude certain elements from
    **collections**. As an example, consider that an agent manages various celebrities
    and has been asked to find three sets of stars:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Those that can act **or** sing.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those that can act **and** sing.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those that can act **only** (no singers allowed).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following snippet, a list of actors'' and singers'' names is created:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new class called `HashSetExamples.cs`
    and edit it as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, create a new `HashSet` instance that initially contains singers only and
    then use `UnionWith` to modify the set to contain a distinct set of those that
    can act **or** sing:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For those that can act `HashSet` instance of singers, and modify the `HashSet`
    instance using `IntersectWith` to contain a distinct list of those that are in
    both collections:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, for those that can `ExceptWith` to remove those from the `HashSet`
    instance that can also sing:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running the console app produces the following output:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the output, you can see that out of the given list of actors and singers,
    only `Will Smith` can act and sing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/ZdNbS](https://packt.link/ZdNbS).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another commonly used collection type is the generic `Dictionary<TK, TV>`. This allows
    multiple items to be added, but a unique **key** is needed to identify an item instance.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are commonly used to look up values using known keys. The key and
    value type parameters can be of any type. A value can exist in a `Dictionary`
    more than once, provided that its key is **unique**. Attempting to add a key that
    already exists will result in a runtime exception being thrown.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: A common example of a `Dictionary` might be a registry of known countries that
    are keyed by their ISO country code. A customer service application may load customer
    details from a database and then use the ISO code to look up the customer's country
    from the country list, rather than having the extra overhead of creating a new
    country instance for each customer.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on standard ISO country codes at [https://www.iso.org/iso-3166-country-codes.xhtml](https://www.iso.org/iso-3166-country-codes.xhtml).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The main methods used in the `Dictionary` class are as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '`public TValue this[TKey key] {get; set;}`: Gets or sets a value associated
    with the key. An exception is thrown if the key does not exist.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>.KeyCollection Keys { get; }`: Returns a `KeyCollection`
    dictionary instance that contains all keys.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>.ValueCollection Values { get; }`: Returns a `ValueCollection`
    dictionary instance that contains all values.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int Count { get; }`: Returns the number of elements in the `Dictionary`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Add(TKey key, TValue value)`: Adds the key and associated value. If the
    key already exists, an exception is thrown.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Clear()`: Clears all keys and values from the `Dictionary`.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool ContainsKey(TKey key)`: Returns `true` if the specified key exists.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool ContainsValue(TValue value)`: Returns `true` if the specified value exists.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Remove(TKey key)`: Removes a value with the associated key.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool TryAdd(TKey key, TValue value)`: Attempts to add the key and value. If
    the key already exists, an exception is "not" thrown. Returns `true` if the value
    was added.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool TryGetValue(TKey key, out TValue value)`: Gets the value associated with
    the key, if it is available. Returns `true` if it was found.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how a `Dictionary` can be used to add and navigate
    `Country` records:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Examples` folder, add a new class called `DictionaryExamples.cs`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by defining a `Country` record, which is passed a `Name` parameter:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use the `Dictionary` initialization syntax to create a `Dictionary` with five
    countries, as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the next code snippet, `Dictionary` implements the `IEnumerable` interface,
    which allows you to retrieve a key-value pair representing the key and value items
    in the `Dictionary`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running the example code produces the following output. By iterating through
    each item in `countries`, you can see the five country codes and their names:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There is an entry with the `AFG` key, so using the `set indexer` passing in
    `AFG` as a key allows a new `Country` record to be set that replaces the previous
    item with the `AGF` key. You can add the following code for this:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When you run the code, adding a key for `AFG` allows you to get a value using
    that key:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Key comparisons are case-sensitive with string keys, so `AGO` is present but
    `and` is not as the corresponding country (`Andorra`) is defined with the uppercase
    `AND` key. You can add the following code to check this:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using `Add` to add a new entry will throw an exception if the key already exists.
    This can be seen by adding the following code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Conversely, `TryAdd` does `AIA` key, so using `TryAdd` simply returns a `false`
    value rather than throwing an exception:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As the following output shows, adding `Anguilla` once using the `AIA` key is
    valid but attempting to add it again using the `AIA` key results in an exception
    being caught:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`TryGetValue`, as the name suggests, allows you to try to get a value by key.
    You pass in a key that may be missing from the `Dictionary`. Requesting an object
    whose key is missing from the `Dictionary` will ensure that an exception is not
    thrown. This is useful if you are unsure whether a value has been added for the
    specified key:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You should see the following output upon running this code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Visual Studio might report the following warning: `Warning CS8600: Converting
    null literal or possible null value to non-nullable type`. This is a reminder
    from Visual Studio that a variable may have a null value at runtime.'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have seen how the `Dictionary` class is used to ensure that only unique
    identities are associated with values. Even if you do not know which keys are
    in the `Dictionary` until runtime, you can use the `TryGetValue` and `TryAdd`
    methods to prevent runtime exceptions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/vzHUb](https://packt.link/vzHUb).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a string key was used for the `Dictionary`. However, any type
    can be used as a key. You will often find that an integer value is used as a key
    when source data is retrieved from relational databases, as integers can often
    be more efficient in memory than strings. Now it is time to use this feature through
    an exercise.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.02: Using a Dictionary to Count the Words in a Sentence'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been asked to create a console app that asks the user to enter a sentence.
    The console should then split the input into individual words (using a space character
    as a word delimiter) and count the number of times that each word occurs. If possible,
    simple forms of punctuation should be removed from the output, and you are to
    ignore capitalized words so that, for example, `Apple` and `apple` both appear
    as a single word.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This is an ideal use of a `Dictionary`. The `Dictionary` will use a string as
    the key (a unique entry for each word) with an `int` value to count the words.
    You will use `string.Split()` to split a sentence into words, and `char.IsPunctuation`
    to remove any trailing punctuation marks.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Exercises` folder, create a new folder called `Exercise02`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Exercise02` folder, add a new class called `Program.cs`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by defining a new class called `WordCounter`. This can be marked as `static`
    so that it can be used without needing to create an instance:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Define a `static` method called `Process`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is passed a phrase and returns `IEnumerable<KeyValuePair>`, which allows
    the caller to enumerate through a `Dictionary` of results. After this definition,
    the `Dictionary` of `wordCounts` is keyed using a `string` (each word found) and
    an `int` (the number of times that a word occurs).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: You are to ignore the case of words with capital letters, so convert the string
    into its lowercase equivalent before using the `string.Split` method to split
    the phrase.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then you can use the `RemoveEmptyEntries` option to remove any empty string
    values. Add the following code for this:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use a simple `foreach` loop to iterate through the individual words found in
    the phrase:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `char.IsPunctuation` method is used to remove punctuation marks from the
    end of the word.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `TryGetValue` method to check if there is a `Dictionary` entry with
    the current word. If so, update the `count` by one:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If the word does not exist, add a new word key with a starting value of `1`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the words in the phrase have been processed, return the `wordCounts Dictionary`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, write the console app that allows the user to enter a phrase:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `do` loop will end once the user enters an empty string; you will add the
    code for this in an upcoming step.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Call the `WordCounter.Process` method to return a key-value pair that can be
    enumerated through.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each `key` and `value`, write the word and its count, padding each word
    to the right:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A new line is started after every third word (using `i % 3 = 0`) for improved
    output formatting.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish off the `do-while` loop:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Running the console using the opening text from *The Gettysburg Address* of
    1863 produces this output:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can search online for The Gettysburg Address or visit [https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm](https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm).
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the results, you can see that each word is displayed only once and that
    certain words, such as `and` and `that`, appear more than once in the speech.
    The words are listed in the order they appear in the text, but this is not always
    the case with the `Dictionary` class. It should be assumed that the order will
    **not** remain fixed this way; dictionaries' values should be accessed using a
    key.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/Dnw4a](https://packt.link/Dnw4a).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have learned about the main collections commonly used in .NET. It
    is now time to look at LINQ, which makes extensive use of collections based on
    the `IEnumerable` interface.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: LINQ
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LINQ (pronounced **link**) is short for Language Integrated Query. LINQ is a
    general-purpose language that can be used to query objects in memory by using
    a syntax that is similar to Structured Query Language (SQL), that is, it is used
    to query databases. It is an enhancement of the C# language that makes it easier
    to interact with objects in memory using SQL-like Query Expressions or Query Operators
    (implemented through a series of extension methods).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft''s original idea for LINQ was to bridge the gap between .NET code
    and data sources, such as relational databases and XML, using LINQ providers.
    LINQ providers form a set of building blocks that can be used to query various
    sources of data, using a similar set of Query Operators, without the caller needing
    to know the intricacies of how each data source works. The following is a list
    of providers and how they are used:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'LINQ to Objects: Queries applied to objects in memory, such as those defined
    in a list.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LINQ to SQL: Queries applied to relational databases such as SQL Server, Sybase,
    or Oracle.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LINQ to XML: Queries applied to XML documents.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will cover LINQ to Objects. This is, by far, the most common use
    of LINQ providers and offers a flexible way to query collections in memory. In
    fact, when talking about LINQ, most people refer to LINQ to Objects, mainly due
    to its ubiquitous use throughout C# applications.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of LINQ is the way that collections can be converted, filtered,
    and aggregated into new forms using a concise and easy-to-use syntax. LINQ can
    be used in two interchangeable styles:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Query Operators
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query Expressions
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each style offers a different syntax to achieve the same result, and which one
    you use often comes down to personal preference. Each style can be interwoven
    in code easily.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Query Operators
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are based on a series of core extension methods. The results from one
    method can be chained together into a programming style, which can often be easier
    to grasp than their expression-based counterparts.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The extension methods typically take an `IEnumerable<T>` or `IQueryable<T>`
    input source, such as a list, and allow a `Func<T>` predicate to be applied to
    that source. The source is generic-based, so Query Operators work with all types.
    It is just as easy to work with `List<string>` as it is with `List<Customer>`,
    for example.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, `.Where`, `.OrderBy`, and `.Select` are the extension
    methods being called:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, you are taking the results from a `.Where` extension method to find all
    books with a unit price greater than `10`, which is then sorted using the `.OrderBy`
    extension method. Finally, the name of each book is extracted using the `.Select`
    method. These methods could have been declared as single lines of code, but chaining
    in this way provides a more intuitive syntax. This will be covered in more detail
    in the upcoming sections.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Query Expressions
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query Expressions are an enhancement of the C# language and resemble SQL syntax.
    The C# compiler compiles Query Expressions into a sequence of Query Operator extension
    method calls. Note that not all Query Operators are available with an equivalent
    Query Expression implementation.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Query Expressions have the following rules:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: They start with a `from` clause.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can contain at least one or more optional `where`, `orderby`, `join`, `let`,
    and additional `from` clauses.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They end with either a `select` or a `group` clause.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet is functionally equivalent to the Query Operator style
    defined in the previous section:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You will take a more in-depth look at both styles as you learn about the standard
    Query Operators shortly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Deferred Execution
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you choose to use Query Operators, Query Expressions, or a mixture of
    the two, it is important to remember that for many operators, the query that you
    define is not executed when it is defined, but only when it is enumerated over.
    This means that it is not until a `foreach` statement or a `ToList`, `ToArray`,
    `ToDictionary`, `ToLookup`, or `ToHashSet` method is called that the actual query
    is executed.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: This allows queries to be constructed elsewhere in code with additional criteria
    included, and then used or even reused with a different collection of data. Recall
    that in *Chapter 3*, *Delegates, Lambdas, and Events*, you saw similar behavior
    with delegates. Delegates are not executed where they are defined, but only when
    they are invoked.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following short Query Operator example, the output will be `abz` even
    though `z` is added **after** the query is defined but **before** it is enumerated
    through. This demonstrates that LINQ queries are evaluated on demand, rather than
    at the point where they are declared:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Standard Query Operators
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINQ is driven by a core set of extension methods, referred to as standard Query
    Operators. These are grouped into operations based on their functionality. There
    are many standard Query Operators available, so for this introduction, you will
    explore all the main operators that you are likely to use regularly.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Projection Operations
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Projection operations allow you to convert an object into a new structure using
    only the properties that you need. You can create a new type, apply mathematical
    operations, or return the original object:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '`Select`: Projects each item in the source into a new form.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectMany`: Projects all items in the source, flattens the result, and optionally
    projects them to a new form. There is no Query Expression equivalent for `SelectMany`.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the following snippet, which iterates through a `List<string>` containing
    the values `Mon`, `Tues`, and `Wednes`, outputting each with the word day appended.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSelectExamples.cs`
    and edit it as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Looking at the Query Operator syntax first, you can see that `query1` uses
    the `Select` extension method and defines a `Func<T>` like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When executed, the variable `d` is passed to the lambda statement, which appends
    the word `day` to each string in the `days` list: `"Mon"`, `"Tues"`, `"Wednes"`.
    This returns a new `IEnumerable<string>` instance, with the original values inside
    the source variable, `days`, remaining unchanged.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now enumerate through the new `IEnumerable` instance using `foreach`,
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Note that the `Select` method has another overload that allows the index position
    in the source and value to be accessed, rather than just the value itself. Here,
    `d` (the string value) and `i` (its index) are passed, using the `( d , i ) =>`
    syntax and joined into a new string. The output will be displayed as `0 : Monday`,
    `1 : Tuesday`, and so on.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Types
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you continue looking at `Select` projections, it is worth noting that
    C# does not limit you to just creating new strings from existing strings. You
    can project into any type.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create anonymous types, which are types created by the compiler
    from the properties that you name and specify. For example, consider the following
    example, which results in a new type being created that represents the results
    of the `Select` method:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, `query3` results in a new type that has an Index and `UpperCaseName` property;
    the values are assigned using `Index = i` and `UpperCaseName = $"{d.ToUpper()}DAY"`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: These types are scoped to be available within your local method and can then
    be used in any local statements, such as in the previous `foreach` block. This
    saves you from having to create classes to temporarily store values from a `Select`
    method.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code produces output in this format:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As an alternative, consider how the equivalent Query Expression looks. In the
    following example, you start with the from `day in days` expression. This assigns
    the name `day` to the string values in the `days` list. You then use `select`
    to project that to a new string, appending `"day"` to each.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'This is functionally equivalent to the example in `query1`. The only difference
    is the code readability:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following example snippet mixes a Query Operator and Query Expressions.
    The `select` Query Expression cannot be used to select a value and index, so the
    `Select` extension method is used to create an anonymous type with a `Name` and
    `Index` property:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Running the full example produces this output:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Again, it largely comes down to personal choice as to which you prefer using.
    As queries become longer, one form may require less code than the other.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/wKye0](https://packt.link/wKye0).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: SelectMany
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have seen how `Select` can be used to project values from each item in a
    source collection. In the case of a source that has enumerable properties, the
    `SelectMany` extension method can extract the multiple items into a single list,
    which can then be optionally projected into a new form.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates two `City` records, each with multiple `Station`
    names, and uses `SelectMany` to extract all stations from both cities:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSelectManyExamples.cs`
    and edit it as follows:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `Func` parameter, which is passed to `SelectMany`, requires you to specify
    an enumerable property, in this case, the `City` class's `Stations` property,
    which contains a list of string names (see the highlighted code).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Notice how a shortcut is used here, by directly integrating the query into a
    `foreach` statement. You are not altering or reusing the query variable, so there is
    no benefit in defining it separately, as done earlier.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '`SelectMany` extracts all the station names from all of the items in the `List<City>`
    variable. Starting with the `City` class at element `0`, which has the name `London`,
    it will extract the three station names `("Kings Cross KGX"`, `"Liverpool Street
    LVS"`, and `"Euston EUS"`). It will then move on to the second `City` element,
    named `Birmingham`, and extract the single station, named `"New Street NST"`.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the example produces the following output:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'As an alternative, consider the following snippet. Here, you revert to using
    a query variable, `stations`, to make the code easier to follow:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Rather than just returning each `Station` string, this example uses a nested
    `Select` method and a `Range` operator to extract the last three characters from
    the station name using `s[^3..]`, where `s` is a string for each station name
    and `^3` indicates that the `Range` operator should extract a string that starts
    at the last three characters in the string.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the example produces the following output:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can see the last three characters of each station name are shown in the output.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/g8dXZ](https://packt.link/g8dXZ).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In the next section you will read about the filtering operations that filter
    a result as per a condition.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Operations
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filtering operations allow you to filter a result to return only those items
    that match a condition. For example, consider the following snippet, which contains
    a list of orders:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqWhereExample.cs`
    and edit it as follows:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, some order items are defined for various stationery products. Suppose
    you want to output all orders that have a quantity greater than five (this should
    output the `Ruler` and `USB Memory Stick` orders from the source).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you can add the following code:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, suppose you extend the criteria to find all products where the product
    is `Pen` or `Pencil`. You can chain that result into a `Select` method, which
    will return each order''s total value; remember that `Select` can return anything
    from a source, even a simple extra calculation like this:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next, the Query Expression in the following snippet uses a `where` clause to
    find the orders with a price less than or equal to `3.99`. This projects them
    into an anonymous type that has `Name` and `Value` properties, which you enumerate
    through using a `foreach` statement:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Running the full example produces this result:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Now you have seen Query Operators in action, it is worth returning to deferred
    execution to see how this affects a query that is enumerated multiple times over.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, you have a collection of journeys made by a vehicle,
    which are populated via a `TravelLog` record. The `TravelLog` class contains an
    `AverageSpeed` method that logs a console message each time it is executed, and,
    as the name suggests, returns the average speed of the vehicle during that journey:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Chapter04\Examples folder, add a new file called `LinqMultipleEnumerationExample.cs`
    and edit it as follows:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, define the console app''s `Main` method, which populates a `travelLogs`
    list with four `TravelLog` records. You will add the following code for this:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You will now create a `fastestJourneys` query variable, which includes a `Where`
    clause. This `Where` clause will call each journey's `AverageSpeed` method when
    enumerated.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, using a `foreach` loop, you enumerate through the items in `fastestJourneys`
    and write the name and distance to the console (note that you do `AverageSpeed`
    method inside the `foreach` loop):'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Running the code block will produce the following output, the `Name` and `Distance`
    for each journey:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can see that `AverageSpeed` was called `Where` condition. This is as expected
    so far, but now, you can reuse the same query to output the `Name` and, alternatively,
    the `Duration`:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Running this block produces the same `AverageSpeed` method:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This shows that whenever a query is enumerated, the full query is `AverageSpeed`,
    but what if a method needs to access a database to extract some data? That would
    result in multiple database calls and, possibly, a very slow application.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use methods such as `ToList`, `ToArray`, `ToDictionary`, `ToLookup`,
    or `ToHashSet` to ensure that a query that could be enumerated many times is `Where`
    clause but includes an extra `ToList` call to immediately execute the query and
    ensure it is not re-evaluated:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Running the block produces the following output. Notice how `AverageSpeed`
    is called `Fastest Duration Multiple loop iteration` messages:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Notice that from the collection of journeys made by a vehicle, the code returns
    the average speed of the vehicle during the journeys.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/CIZJE](https://packt.link/CIZJE).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Operations
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five operations to sort items in a source. Items are primarily sorted
    and that can be followed by an optional secondary sort, which sorts the items
    within their primary group. For example, you can use a primary sort to sort a
    list of people firstly by the `City` property and then use a secondary sort to
    further sort them by the `Surname` property:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderBy`: Sorts values into ascending order.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderByDescending`: Sorts values into descending order.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThenBy`: Sorts values that have been primarily sorted into a secondary ascending
    order.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThenByDescending`: Sorts values that have been primarily sorted into a secondary
    descending order.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reverse`: Simply returns a collection where the order of elements in the source
    is reversed. There is no expression equivalent.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OrderBy and OrderByDescending
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, you will use the `System.IO` namespace to query files in the
    host machine's `temp` folder, rather than creating small objects from lists.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'The static `Directory` class offers methods that can query the filesystem.
    `FileInfo` retrieves details about a specific file, such as its size or creation
    date. The `Path.GetTempPath` method returns the system''s `temp` folder. To illustrate
    the point, in the Windows operating system, this can typically be found at `C:\Users\username\AppData\Local\Temp`,
    where `username` is a specific Windows login name. This will be different for
    other users and other systems:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqOrderByExamples.cs`
    and edit it as follows:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Use the `Directory.EnumerateFiles` method to find all filenames with the `.tmp`
    extension in the `temp` folder:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, each filename is projected into a `FileInfo` instance and chained into
    a populated collection using `ToList`, which allows you to further query the resulting
    `fileInfos` details.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `OrderBy` method is used to sort the earliest files by comparing
    the `CreationTime` property of the file:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To find the largest files, re-query `fileInfos` and sort each file by its `Length`
    property using `OrderByDescending`:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Finally, use `where` and `orderby` descending expressions to find the largest
    files that are less than `1,000` bytes in length:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Depending on the files in your `temp` folder, you should see an output like
    this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: With this example, you have queried files in the host machine's `temp` folder,
    rather than creating small objects from lists.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/mWeVC](https://packt.link/mWeVC).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: ThenBy and ThenByDescending
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following example sorts popular quotes, based on the number of words found
    in each.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqThenByExamples.cs`
    and edit it as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You start by declaring a string array of quotes as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In the next snippet, each of these string quotes is projected into a new anonymous
    type based on the number of words in the quote (found using `String.Split()`).
    The items are first sorted in descending order to show those with the most words
    and then sorted in alphabetical order:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Running the code lists the quotes in word count order as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Note how the quotes with six words are shown alphabetically.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'The following (highlighted code) is the equivalent Query Expression with `orderby
    quote.Words descending` followed by the `quote.Words` ascending clause:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/YWJRz](https://packt.link/YWJRz).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Now you have sorted popular quotes based on the number of words found in each.
    It is time to apply the skills learnt in the next exercise.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.03: Filtering a List of Countries by Continent and Sorting by Area'
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding examples, you have looked at code that can select, filter,
    and sort a collection source. You will now combine these into an exercise that
    filters a small list of countries for two continents (South America and Africa)
    and sorts the results by geographical size.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Exercises` folder, create a new `Exercise03` folder.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `Program.cs` in the `Exercise03` folder.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by adding a `Country` record that will be passed the `Name` of a country,
    the `Continent` to which it belongs, and its `Area` in square miles:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now create a small subset of country data defined in an array, as follows:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The array contains the name of a country, the continent it belongs to, and its
    geographical size in square miles.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'Your search criteria must include `South America` or `Africa`. So define them
    in an array rather than hardcoding the `where` clause with two specific strings:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This offers extra code flexibility should you need to alter it.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'Build up a query by filtering and sorting by continent, sorting by area, and
    using the `.Select` extension method, which returns the `Index` and `item` value:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You finally project each into a new anonymous type to be written to the console.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code block produces the following result:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Notice that `Algeria` has the largest area in `Africa`, and `Brazil` has the
    largest area in `South America` (based on this small subset of data). Notice how
    you add `1` to each `Index` for readability (since starting at zero is less user-friendly).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/Djddw](https://packt.link/Djddw).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how LINQ extension methods can be used to access items in a data
    source. Now, you will learn about partitioning data, which can be used to extract
    subsets of items.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning Operations
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have looked at filtering the items in a data source that match a
    defined condition. Partitioning is used when you need to divide a data source
    into two distinct sections and return either of those two sections for subsequent
    processing.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider that you have a list of vehicles sorted by value and want
    to process the five least expensive vehicles using some method. If the list is
    sorted in ascending order, then you could partition the data using the `Take(5)`
    method (defined in the following paragraphs), which will extract the first five
    items and discard the remaining.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six partitioning operations that are used to split a source, with
    either of the two sections being returned. There are no partitioning Query Expressions:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '`Skip`: Returns a collection that skips items up to a specified numeric position
    in the source sequence. Used when you need to skip the first N items in a source collection.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipLast`: Returns a collection that skips the last N items in the source sequence.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipWhile`: Returns a collection that skips items in the source sequence that
    match a specified condition.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Take`: Returns a collection that contains the first N items in the sequence.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeLast`: Returns a collection that contains the last N items in the sequence.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeWhile`: Returns a collection that contains only those items that match
    the condition specified.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following example demonstrates various `Skip` and `Take` operations on an
    unsorted list of exam grades. Here, you use `Skip(1)` to ignore the highest grade
    in a sorted list.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSkipTakeExamples.cs`
    and edit it as follows:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Next, the relational `is` operator is used to exclude those less than `25`
    or greater than `75`:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'By using `SkipLast`, you can show the bottom half of the results. Add the code
    for this as follows:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Finally, `Take(2)` is used here to show the two highest grades:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Running the example produces this output, which is as expected:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This example demonstrated the various `Skip` and `Take` operations on an unsorted
    list of exam grades.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/TsDFk](https://packt.link/TsDFk).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Grouping Operations
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GroupBy` groups elements that share the same attribute. It is often used to
    group data or provide a count of items grouped by a common attribute. The result
    is an enumerable `IGrouping<K, V>` type collection, where `K` is the key type
    and `V` is the value type specified. `IGrouping` itself is enumerable as it contains
    all items that match the specified key.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the next snippet, which groups a `List` of customer orders
    by name. In your `Chapter04\Examples` folder, add a new file called `LinqGroupByExamples.cs`
    and edit it as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In this example, you have a list of `CustomerOrder` objects and want to group
    them by the `Name` property. For this, the `GroupBy` method is passed a `Func`
    delegate, which selects the `Name` property from each `CustomerOrder` instance.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'Each item in the `GroupBy` result contains a `Key` (in this case, the customer''s
    `Name`). You can then sort the grouping item to show the `CustomerOrders` items
    sorted by `Quantity`, as follows:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Running the code produces the following output:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You can see the data is first grouped by customer `Name` and then ordered by
    order `Quantity` within each customer grouping. The equivalent Query Expression
    is written like this:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You have now seen some of the commonly used LINQ operators. You will now bring
    them together in an exercise.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.04: Finding the Most Commonly Used Words in a Book'
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Delegates, Events, and Lambdas*, you used the `WebClient` class
    to download data from a website. In this exercise, you will use data downloaded
    from *Project Gutenberg*.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Project Gutenberg is a library of 60,000 free eBooks. You can search online
    for Project Gutenberg or visit [https://www.gutenberg.org/](https://www.gutenberg.org/).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: You will create a console app that allows the user to enter a URL. Then, you
    will download the book's text from the Project Gutenberg URL and use various LINQ
    statements to find the most frequent words in the book's text.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you want to exclude some common stop-words; these are words such
    as `and`, `or`, and `the` that appear regularly in English, but add little to
    the meaning of a sentence. You will use the `Regex.Split` method to help split
    words more accurately than a simple space delimiter. Perform the following steps
    to do so:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on Regex can be found at [https://packt.link/v4hGN](https://packt.link/v4hGN).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Exercises` folder, create a new `Exercise04` folder.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `Program.cs` in the `Exercise04` folder.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, define the `TextCounter` class. This will be passed the path to a file,
    which you will add shortly. This should contain common English stop-words:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Using `File.ReadAllLines`, add each word into the `_stopWords` `HashSet`.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: You have used a `HashSet`, as each stop-word is unique.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `Process` method is passed a string that contains the book's text
    and the maximum number of words to show.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the result as a `Tuple<string, int>` collection, which saves you from
    having to create a class or record to hold the results:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Now perform the query part. Use `Regex.Split` with the pattern `@"\s+"` to split
    all the words.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its simplest form, this pattern splits a string into a list of words, typically
    using a space or punctuation marks to identify word boundaries. For example, the
    string `Hello Goodbye` would be split into an array that contains two elements,
    `Hello` and `Goodbye`. The returned string items are filtered via `where` to ensure
    all stop-words are ignored using the `Contains` method. The words are then grouped
    by value, `GroupBy(t=>t)`, projected to a `Tuple` using the word as a `Key`, and
    the number of times it occurs using `grp.Count`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you sort by `Item2`, which for this `Tuple` is the word count, and
    then take only the required number of words:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Now start creating the main console app:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Include a text file called `StopWords.txt` in the `Chapter04` source folder:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Note
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find `StopWords.txt` on GitHub at [https://packt.link/Vi8JH](https://packt.link/Vi8JH),
    or you can download any standard stop-word file, such as NLTK's [https://packt.link/ZF1Tf](https://packt.link/ZF1Tf).
    This file should be saved in the `Chapter04\Exercises` folder.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once `TextCounter` has been created, prompt the user for a URL:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Enter a valid address and create a new `WebClient` instance and download the
    data file into a temporary file.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform extra processing to the text file before passing its contents to `TextCounter`:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The Gutenberg text files contain extra details such as the author and title.
    These can be read by reading each line in the file. The actual text of the book
    doesn''t begin until finding a line that starts `*** START OF THE PROJECT GUTENBERG
    EBOOK`, so you need to read each line looking for this start message too:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Next, append each line read into a `StringBuilder` instance, which is efficient
    for such string operations:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Now parse each line inside `tempFile`, looking for the `Author`, `Title`, or
    the `StartIndicator`:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'If the book text is found, provide a summary of lines and characters read before
    calling the `counter.Process` method. Here, you want the top `50` words:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Once you have the results, use a `foreach` loop to output the word count details,
    adding a blank line to the output after every third word:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Running the console app, using `https://www.gutenberg.org/files/64333/64333-0.txt`
    as an example URL produces the following output:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Note
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Visual Studio might show the following when the code is run for the first time:
    `warning SYSLIB0014: ''WebClient.WebClient()'' is obsolete: ''WebRequest, HttpWebRequest,
    ServicePoint, and WebClient are obsolete. Use HttpClient instead.`'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is a recommendation to use the newer `HttpClient` class instead of the
    `WebClient` class. Both are, however, functionally equivalent.
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The output shows a list of words found amongst the `4,063` lines of text downloaded.
    The counter shows that `one`, `new`, and `project` are the most popular words.
    Notice how `mr.`, `gutenberg-tm`, `it.`, and `_the` appear as words. This shows
    that the Regex expression used is not completely accurate when splitting words.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/Q7Pf8](https://packt.link/Q7Pf8).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: An interesting enhancement to this exercise would be to sort the words by count,
    include a count of the stop words found, or find the average word length.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation Operations
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aggregation operations are used to compute a single value from a collection
    of values in a data source. An example could be the maximum, minimum, and average
    rainfall from data collected over a month:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '`Average`: Calculates the average value in a collection.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: Counts the items that match a predicate.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max`: Calculates the maximum value.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min`: Calculates the minimum value.'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sum`: Calculates the sum of values.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example uses the `Process.GetProcess` method from the `System.Diagnostics`
    namespace to retrieve a list of processes currently running on the system:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqAggregationExamples.cs`
    and edit it as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'First, `Process.GetProcesses().ToList()` is called to retrieve a list of the
    active processes running on the system:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Then, the `Count` extension method obtains a count of the items returned. Count
    has an additional overload, which accepts a `Func` delegate used to filter each
    of the items to be counted. The `Process` class has a `PrivateMemorySize64` property,
    which returns the number of bytes of memory the process is currently consuming,
    so you can use that to count the `1,000,000` bytes of memory:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Next, the `Average` extension method returns the overall average of a specific
    value for all items in the `processes` list. In this case, you use it to calculate
    the average memory consumption, using the `PrivateMemorySize64` property again:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The `PrivateMemorySize64` property is also used to calculate the maximum and
    minimum memory used for all processes, along with the total memory, as follows:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Once you have calculated the statistics, each value is written to the console:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In the preceding snippet, the `Count` method returns the number of all processes
    and, using the `Predicate` overload, you `Count` those where the memory is less
    than 1,000,000 bytes (by examining the `process.PrivateMemorySize64` property).
    You can also see that `Average`, `Max`, `Min`, and `Sum` are used to calculate
    statistics for process memory usage on the system.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: The aggregate operators will throw `InvalidOperationException` with the error
    `Sequence contains no elements` if you attempt to calculate using a source collection
    that contains no elements. You should check the `Count` or `Any` methods prior
    to calling any aggregate operators.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `FormatBytes` formats the amounts of memory into their megabyte equivalents:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Running the example produces results similar to this:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: From the output you will observe how the program retrieves a list of processes
    currently running on the system.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/HI2eV](https://packt.link/HI2eV).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Quantifier Operations
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantifier operations return a `bool` that indicates whether `Predicate` condition.
    This is often used to verify any elements in a collection match some criteria,
    rather than relying on `Count`, which enumerates **all** items in the collection,
    even if you need just one result.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantifier operations are accessed using the following extension methods:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '`All`: Returns `true` if **all** elements in the source sequence match a condition.'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Any`: Returns `true` if **any** element in the source sequence matches a condition.'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contains`: Returns `true` if the source sequence contains the specified item.'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following card-dealing example selects three cards at random and returns
    a summary of those selected. The summary uses the `All` and `Any` extension methods
    to determine whether any of the cards were clubs or red and whether all cards
    were diamonds or an even number:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Examples` folder, add a new file called `LinqAllAnyExamples.cs`.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by declaring an `enum` that represents each of the four suits in a pack
    of playing cards and a `record` class that defines a playing card:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'It is common practice to override the `ToString` method to provide a user-friendly
    way to describe an object''s state at runtime. Here, the card''s number and suit
    are returned as a string:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now create a class to represent a deck of cards (for ease, only create cards
    numbered one to 10). The deck''s constructor will populate the `_cards` collection
    with `10` cards for each of the suits:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Next, the `Draw` method randomly selects a card from the `_cards` List, which
    it removes before returning to the caller:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The console app selects three cards using the deck''s `Draw` method. Add the
    code for this as follows:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To show a summary, use the `OrderByDescending` and `Select` operations to extract
    the user-friendly `ToString` description for each `PlayingCard`. This is then
    joined into a single delimited string as follows:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Using `All` or `Any`, you can provide an overview of the cards and their score
    using the `Sum` of the card numbers. By using `Any`, you determine whether `PlayingCardSuit.Clubs`):'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Similarly, `Any` is used to see if `Hearts` or `Diamonds` suits, and therefore,
    are `Red`:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'In the next snippet, the `All` extension looks at every item in the collection
    and returns `true`, in this case, if `Diamonds`:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'All is used again to see if all card numbers can be divided by two without
    a remainder, that is, whether they are even:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Conclude by using the `Sum` aggregation method to calculate the value of the
    cards in the hand:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Running the console app produces output like this:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The cards are randomly selected so you will have different hands each time you
    run the program. In this example, the score was `21`, which is often a winning
    hand in card games.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/xPuTc](https://packt.link/xPuTc).
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Join Operations
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Join operations are used to join two sources based on the association of objects
    in one data source with those that share a common attribute in a second data source.
    If you are familiar with database design, this can be thought of as a primary
    and foreign key relationship between tables.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: A common example of a join is one where you have a one-way relationship, such
    as `Orders`, which has a property of type `Products`, but the `Products` class
    does not have a collection property that represents a backward relationship to
    a collection of `Orders`. By using a `Join` operator, you can create a backward
    relationship to show `Orders` for `Products`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'The two join extension methods are the following:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '`Join`: Joins two sequences using a key selector to extract pairs of values.'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupJoin`: Joins two sequences using a key selector and groups the resulting items.'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example contains three `Manufacturer` records, each with a unique
    `ManufacturerId`. These numeric IDs are used to define various `Car` records,
    but to save memory, you will not have a direct memory reference from `Manufacturer`
    back to `Car`. You will use the `Join` method to create an association between
    the `Manufacturer` and `Car` instances:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Examples` folder, add a new file called `LinqJoinExamples.cs`.
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, declare the `Manufacturer` and `Car` records as follows:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Inside the `Main` entry point, create two lists, one for the manufacturers
    and the other to represent the `cars`:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'At this point, there is no direct reference, but as you know, you can use `ManufacturerId`
    to link the two together using the `int` IDs. You can add the following code for
    this:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: In the preceding snippet, the `Join` operation has various parameters. You pass
    in the `cars` list and define which properties in the `manufacturer` and `car`
    classes should be used to create the join. In this case, `manufacturer.ManufacturerId
    = car.ManufacturerId` determines the correct join.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `manufacturer` and `car` arguments return a new anonymous type
    that contains the `manufacturer.Name` and `car.Name` properties.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the console app produces the following output:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: As you can see, each of the `Car` and `Manufacturer` instances has been joined
    correctly using `ManufacturerId`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent Query Expression would be as follows (note that in this case,
    it is a more concise format than the Query Operator syntax):'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Note
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the code used for this example at [http://packt.link/Wh8jK](http://packt.link/Wh8jK).
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before you finish exploring LINQ, there is one more area related to LINQ Query
    Expressions—the `let` clause.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Using a let Clause in Query Expressions
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In earlier Query Expressions, you are often required to repeat similar-looking
    code in various clauses. Using a `let` clause, you can introduce new variables
    inside an Expression Query and reuse the variable''s value throughout the rest
    of the query. For example, consider the following query:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Here, you are searching for a station with the `LVS` or `EUS` code or a name
    ending in `CROSS`. To do this, you must extract the last three characters using
    a range, `station[^3..]`, but you have duplicated that in two `where` clauses
    and the final projection.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'The station code and station names could both be converted into local variables
    using the `let` clause:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Here, you have defined `code` and `name` using a `let` clause and reused them
    throughout the query. This code looks much neater and is also easier to follow
    and maintain.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code produces the following output:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Note
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/b2KiG](https://packt.link/b2KiG).
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: By now you have seen the main parts of LINQ. Now you will now bring these together
    into an activity that filters a set of flight records based on a user's criteria
    and provides various statistics on the subset of flights found.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.01: Treasury Flight Data Analysis'
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been asked to create a console app that allows the user to download
    publicly available flight data files and apply statistical analysis to the files.
    This analysis should be used to calculate a count of the total records found,
    along with the average, minimum, and maximum fare paid within that subset.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: The user should be able to enter a number of commands and each command should
    add a specific filter based on the flight's class, origin, or destination properties.
    Once the user has entered the required criteria, the `go` command must be entered,
    and the console should run a query and output the results.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'The data file you will use for this activity contains details of flights made
    by the UK''s HM Treasury department between January 1 to December 31, 2011 (there
    are 714 records.) You will need to use `WebClient.DownloadFile` to download the
    data from the following URL: [https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv](https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv)'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: The website might open differently for Internet Explorer or Google Chrome. This
    depends on how IE or Chrome are configured on your machine. Using `WebClient.DownloadFile`,
    you can download the data as suggested.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the program should download data once and then reread it from the local
    filesystem each time it is started.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Preview of HM Treasury traffic data in Excel ](img/B16835_04_06.jpg)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Preview of HM Treasury traffic data in Excel'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'Once downloaded, the data should then be read into a suitable record structure
    before being added to a collection, which allows various queries to be applied.
    The output should show the following aggregate values for all rows that match
    the user''s criteria:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Record count
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average fare
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum fare
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum fare
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user should be able to enter the following console commands:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '`Class c`: Adds a class filter, where `c` is a flight class to search for,
    such as `economy` or `Business class`.'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Origin o`: Adds an `origin` filter, where o is the flight origin, such as
    `dublin`, `london`, or `basel`.'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destination d`: Adds a destination filter, where `d` is the flight destination,
    such as `delhi`.'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`: Clears all filters.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go`: Applies the current filters.'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user enters multiple filters of the same type, then these should be treated
    as an `OR` filter.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'An `enum` can be used to identify the filter criteria type entered, as shown
    in the following line of code:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Similarly, a record can be used to store each filter type and comparison operand,
    as follows:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Each filter specified should be added to a `List<FilterCriteria>` instance.
    For example, if the user enters two origin filters, one for `dublin` and another
    for `london`, then the list should contain two objects, each representing an origin
    type filter.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user enters the `go` command, a query should be built that performs
    the following steps:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: Extracts all `class` filter values into a list of strings (`List<string>`).
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracts all `origin` filter values into `List<string>`.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracts all `destination` filter values into `List<string>`.
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses a `where` extension method to filter the fight records for each criteria
    type specified using the `List<string>`. It contains a method to perform a case-insensitive
    search.
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Activities` in the `Chapter04` folder.
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Activity01` to that new folder.
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file called `Flight.cs`. This will be a `Record` class with
    fields that match those in the flight data. A `Record` class should be used as
    it offers a simple type purely to hold data rather than any form of behavior.
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class file called `FlightLoader.cs`. This class will be used for
    downloading or importing data. `FlightLoader` should include a list of the field
    index positions within the data file, to be used when reading each line of data
    and splitting the contents into a string array, for example:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Now for the `FlightLoader` implementation, use a `static` class to define the
    index of known field positions in the data file. This will make it easier to handle
    any future changes in the layout of the data.
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, a `Download` method should be passed a URL and destination file. Use `WebClient.DownloadFile`
    to download the data file and then defer to `Import` to process the downloaded
    file.
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Import` method is to be added. This is passed the name of the local file
    to import (downloaded using the `Import` method) and will return a list of `Flight` records.
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class file called `FilterCriteria.cs`. This should contain a `FilterCriteriaType`
    `enum` definition. You will offer filters based on the flight's class, origin,
    and destination properties, so `FilterCriteriaType` should represent each of these.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, for the main filtering class, add a new class file called `FlightQuery.cs`.
    The constructor will be passed a `FlightLoader` instance. Within it, create a
    list named `_flights` to contain the data imported via `FlightLoader`. Create
    a `List<FilterCriteria>` instance named `_filters` that represent each of the
    criteria items that are added, each time the user specifies a new filter condition.
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Import` and `Download` methods of `FlightLoader` should be called by the
    console at startup, allowing previously downloaded data to be processed, via the
    `_loader` instance.
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Count` variable that returns the number of flight records that have
    been imported.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user specifies a filter to add, the console will call `AddFilter`,
    passing an `enum` to define the criteria type and the string value being filtered
    for.
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RunQuery` is the main method that returns those flights that match the user''s
    criteria. You need to use the built-in `StringComparer.InvariantCultureIgnoreCase`
    comparer to ensure string comparison ignores any case differences. You define
    a query variable that calls `Select` on the flights; at the moment, this would
    result in a filtered result set.'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of the types of filter available is string-based, so you need to extract
    all the string items. If there are any items to filter, you add an extra `Where`
    call to the query for each type (`Class`, `Destination`, or `Origin`). Each `Where`
    clause uses a `Contains` predicate, which examines the associated property.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the two helper methods used by `RunQuery`. `GetFiltersByType` is passed
    each of the `FilterCriteriaType` enums that represent a known type of criteria
    type and finds any of these in the list of filters using the `.Where` method.
    For example, if the user added two `Destination` criteria such as India and Germany,
    this would result in the two strings `India` and `Germany` being returned.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FormatFilters` simply joins a list of `filterValues` strings into a user-friendly
    string with the word `OR` between each item, such as `London OR Dublin`.'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create the main console app. Add a new class called `Program.cs`, which
    will allow the user to input requests and process their commands.
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hardcode the download URL and destination filename.
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the main `FlightQuery` class, passing in a `FlightLoader` instance. If
    the app has been run before, you can `Import` the local flight data, or use `Download`
    if not.
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a summary of the records imported and the available commands.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user enters a command, there might also be an argument, such as `destination
    united kingdom`, where `destination` is the command and `united kingdom` is the
    argument. To determine this, use the `IndexOf` method to find the location of
    the first space character in the input, if any.
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `go` command, call `RunQuery` and use various aggregation operators
    on the results returned.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the remaining commands, clear or add filters as requested. If the `Clear`
    command is specified, call the query's `ClearFilters` method, which will clear
    the list of criteria items.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a `class` filter command is specified, call `AddFilter` specifying the `FilterCriteriaType.Class
    enum` and the string `Argument`.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same pattern should be used for `Origin` and `Destination` commands. Call
    `AddFilter`, passing in the required `enum` value and the argument.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The console output should be similar to the following, here listing the commands
    available to the user:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The user should be able to add two class filters, for `economy` or `Business
    Class` (all string comparisons should be case-insensitive), as shown in the following
    snippet:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Similarly, the user should be able to add an origin filter as follows (this
    example is for `london`):'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Adding the destination filter should look like this (this example is for `zurich`):'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Entering `go` should show a summary of all filters specified, followed by the
    results for flights that match the filters:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Note
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how the `IEnumerable` and `ICollection` interfaces
    form the basis of .NET data structures, and how they can be used to store multiple
    items. You created different types of collections depending on how each collection
    is meant to be used. You learned that the `List` collection is most extensively
    used to store collections of items, particularly if the number of elements is
    not known at compile time. You saw that the `Stack` and `Queue` types allow the
    order of items to be handled in a controlled manner, and how the `HashSet` offers
    set-based processing, while the `Dictionary` stores unique values using a key
    identifier.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了`IEnumerable`和`ICollection`接口构成了.NET数据结构的基础，以及它们如何用于存储多个项目。您根据每个集合的用途创建了不同类型的集合。您了解到`List`集合最广泛地用于存储项目集合，尤其是当元素数量在编译时未知时。您还看到`Stack`和`Queue`类型允许以受控的方式处理项目顺序，而`HashSet`提供基于集合的处理，而`Dictionary`则使用键标识符存储唯一值。
- en: You then further explored data structures by using LINQ Query Expressions and
    Query Operators to apply queries to data, showing how queries can be altered at
    runtime depending on filtering requirements. You sorted and partitioned data and
    saw how similar operations can be achieved using both Query Operators and Query
    Expressions, each offering a preference and flexibility based on context.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 您随后通过使用LINQ查询表达式和查询运算符进一步探索了数据结构，展示了如何将查询应用于数据，并说明查询可以根据过滤需求在运行时进行更改。您对数据进行排序和分区，并看到如何使用查询运算符和查询表达式实现类似操作，每个都根据上下文提供偏好和灵活性。
- en: In the next chapter, you will see how parallel and asynchronous code can be
    used to run complex or long-running operations together.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到如何使用并行和异步代码一起运行复杂或长时间运行的操作。
