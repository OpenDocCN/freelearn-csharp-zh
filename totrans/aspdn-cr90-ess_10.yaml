- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Deploying and Hosting Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和托管应用程序
- en: After following a good development process, implementing good practices, and
    covering all the functionalities required for an application, it’s necessary to
    publish it in an environment. For this to be done successfully, it’s important
    to understand various concepts, practices, and application packaging models that
    go beyond the source material. In this chapter, we’ll discuss different approaches
    to hosting and deploying applications, as well as understand concepts related
    to **continuous integration and continuous deployment** ( **CI/CD** ) and containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循良好的开发流程、实施良好实践并覆盖应用程序所需的所有功能之后，将其发布到环境中是必要的。为了成功完成此操作，了解超越源材料的各种概念、实践和应用打包模型非常重要。在本章中，我们将讨论不同的应用程序托管和部署方法，以及理解与**持续集成和持续部署**（**CI/CD**）和容器相关的概念。
- en: ASP.NET Core 9 provides a robust configuration system that allows developers
    to manage configurations and behaviors effectively. This chapter will explore
    the importance of application configurations, how to manage them using the configuration
    system, and how to make your applications adaptive at runtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 提供了一个强大的配置系统，允许开发者有效地管理配置和行为。本章将探讨应用程序配置的重要性，如何使用配置系统来管理它们，以及如何在运行时使您的应用程序具有适应性。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing to publish your application and host locally
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备发布您的应用程序并本地托管
- en: Publishing the solution in a cloud environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云环境中发布解决方案
- en: Understanding the Docker principles and how to pack the application in a container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker 原则以及如何将应用程序打包到容器中
- en: Understanding the DevOps approach with CI/CD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DevOps 方法与 CI/CD
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, the following tools must be present in your development
    environment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，以下工具必须存在于您的开发环境中：
- en: '**An Azure subscription** : In this chapter, we’ll be creating resources in
    Microsoft Azure. To do this, if you haven’t already, you will need to have an
    Azure subscription so that you can access the platform. You can sign up for a
    subscription with limited credits to learn about the concepts presented in this
    chapter at [https://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free)
    .'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 订阅**：在本章中，我们将创建 Microsoft Azure 中的资源。为此，如果您还没有，您将需要一个 Azure 订阅，以便您能够访问该平台。您可以在[https://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free)注册一个带有有限信用额的订阅，以了解本章中介绍的概念。'
- en: '**A Docker Hub account** : You will need to create an account on the Docker
    Hub website at [https://hub.docker.com](https://hub.docker.com) .'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub 账户**：您需要在 Docker Hub 网站上创建一个账户，网址为[https://hub.docker.com](https://hub.docker.com)。'
- en: '**The Azure Tools extension** : You will need to install the Azure Tools extension
    for Visual Studio Code from [https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack)
    . Once it’s been installed, log in with your Azure credentials.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 工具扩展**：您需要从[https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack)安装
    Visual Studio Code 的 Azure Tools 扩展。安装完成后，使用您的 Azure 凭据登录。'
- en: 'The code examples for this chapter can be found in this book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10)
    .'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10)。
- en: Preparing to publish your application and host locally
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备发布您的应用程序并本地托管
- en: Publishing an application is a natural process in the software development life
    cycle. After development and testing, the next step is to make the application
    available to users. This involves creating a deployable version of the application
    and configuring it in an environment where it can be accessed and used.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 发布应用程序是软件开发生命周期中的一个自然过程。在开发和测试之后，下一步是将应用程序提供给用户。这涉及到创建可部署的应用程序版本，并在可以访问和使用的环境中对其进行配置。
- en: Let’s understand the details of publishing applications while following various
    strategies, from manual to automated ones, using CI/CD. But before we do this,
    let’s understand some of the fundamentals, such as the importance of the publishing
    process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解在遵循各种策略的同时发布应用程序的细节，从手动到自动化的 CI/CD。但在我们这样做之前，让我们了解一些基本概念，例如发布过程的重要性。
- en: The importance of the publishing process
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布过程的重要性
- en: The publishing process transforms your application from source code into a deployable
    format. This process ensures that all dependencies, configurations, and compiled
    code are packaged together, making it easier to deploy and run the application
    in different environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 发布过程将您的应用程序从源代码转换为可部署的格式。此过程确保所有依赖项、配置和编译的代码打包在一起，使得在不同环境中部署和运行应用程序更加容易。
- en: 'The publishing process in ASP.NET Core 9 involves three steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 中的发布过程涉及三个步骤：
- en: Restoring the package.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复包。
- en: Compiling the application.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译应用程序。
- en: Generating a publishable package.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成可发布的包。
- en: 'The publication package that’s generated may vary, depending on the type of
    application that’s developed. It may contain different files, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的发布包可能因开发的应用程序类型而异。它可能包含不同的文件，例如以下内容：
- en: The application’s DLL files
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的 DLL 文件
- en: Third-party dependencies and libraries
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方依赖项和库
- en: Static files (for example, JavaScript, CSS, and images)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态文件（例如，JavaScript、CSS 和图片）
- en: Configuration files (for example, **appsettings.json** )
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件（例如，**appsettings.json**）
- en: Executables for standalone deployments
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立部署的可执行文件
- en: To understand how this process works, follow the instructions provided in the
    *Technical requirements* section to download the example application from this
    book’s GitHub repository. This will be used as the basis for this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解此过程的工作原理，请按照 *技术要求* 部分提供的说明从本书的 GitHub 仓库下载示例应用程序。这将是本章的基础。
- en: Now, let’s understand how to generate publishing packages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何生成发布包。
- en: Generating a publishing package
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成发布包
- en: We’ve been working with the .NET platform CLI tool extensively throughout this
    book to create and run applications. The CLI tool also has a specific command
    for generating publishing packages for ASP.NET Core 9 projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中广泛使用 .NET 平台 CLI 工具来创建和运行应用程序。CLI 工具还有一个特定命令用于为 ASP.NET Core 9 项目生成发布包。
- en: 'The **publish** command provides various options that allow us to configure
    the publication package’s output, as listed in *Table 10.1* :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**publish** 命令提供了各种选项，允许我们配置发布包的输出，如 *表 10.1* 中所示：'
- en: '| **Option** | **Description** | **Example** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **<** **PROJECT>** | Specifies the project file to operate on. Defaults to
    the current directory if not specified. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **<** **项目文件** > | 指定要操作的项目文件。如果未指定，则默认为当前目录。 |'
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **-** **c** , **--configuration** | Defines the build configuration ( **Debug**
    or **Release** ). Defaults to **Debug** . |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **-c**，**--configuration** | 定义构建配置（**Debug** 或 **Release**）。默认为 **Debug**。
    |'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **-** **f** ,**--** **framework** | Specifies the target framework – for
    example, **net8.0** . |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **-f**，**--framework** | 指定目标框架 – 例如，**net8.0**。 |'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **--** **runtime** | Publishes the application for a specific runtime (for
    example, **win-x64** , **linux-x64** , or **osx-x64** ). |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **--runtime** | 为特定运行时发布应用程序（例如，**win-x64**、**linux-x64** 或 **osx-x64**）。
    |'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **-** **o** , **--output** | Specifies the output directory for the published
    files. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **-o**，**--output** | 指定发布文件的输出目录。 |'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **--** **self-contained** | Publishes the application as a self-contained
    deployment, including the . NET runtime. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **--self-contained** | 将应用程序作为自包含部署发布，包括 .NET 运行时。 |'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **--** **no-restore** | Disables the ability to restore project dependencies
    during the publish operation. Assumes restoration has already been done. It’s
    useful during CI/CD pipelines. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **--no-restore** | 在发布操作期间禁用恢复项目依赖项的能力。假设恢复已经完成。这在 CI/CD 管道中很有用。 |'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **--** **manifest** | Specifies one or more target manifests to calculate
    the set of packages to include in the published output. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **--manifest** | 指定一个或多个目标清单，以计算包含在发布输出中的包集。 |'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **--** **version-suffix** | Sets the **$(VersionSuffix)** property value
    to use when building the project. Useful for prerelease versions. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **--** **version-suffix** | 设置在构建项目时使用的 **$(VersionSuffix)** 属性值。对于预发布版本很有用。|'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 10.1 – dotnet publish CLI tool options
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 – dotnet publish CLI 工具选项
- en: The use of each option will depend on each scenario. In our context, we’ll use
    the **<PROJECT>** , **-c** , **-o** , and, when necessary, **--** **no-restore**
    options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项的使用将取决于每个场景。在我们的上下文中，我们将使用 **<PROJECT>** 、 **-c** 、 **-o** 和必要时 **--** **no-restore**
    选项。
- en: 'Now, let’s generate a publishing package for the **UrlShortener** application.
    To do this, open your terminal or bash, access the previously downloaded application
    directory, and execute the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为 **UrlShortener** 应用程序生成一个发布包。为此，打开您的终端或 bash，访问之前下载的应用程序目录，并执行以下命令：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding command will generate the **publish** package in the **published**
    folder. However, it’s important to understand the **-c** parameter in more detail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将在**发布**文件夹中生成**发布**包。然而，了解**-c**参数的详细信息非常重要：
- en: 'The **-c** option specifies the build configuration, and there are typically
    two main configurations: **Debug** and **Release** :'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-c** 选项指定构建配置，通常有两种主要配置：**调试**和**发布**：'
- en: The **Debug** configuration includes additional debug information and is optimized
    for debugging. When running the project locally with the **dotnet run** command,
    the default configuration is **Debug** , which allows the debugging process to
    be carried out.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**配置包含额外的调试信息，并针对调试进行了优化。当使用 **dotnet run** 命令在本地运行项目时，默认配置是**调试**，这允许执行调试过程。'
- en: The **Release** configuration is optimized for performance and does not include
    debug information. It’s typically used to deploy the application to production
    environments.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**配置针对性能进行了优化，不包含调试信息。通常用于将应用程序部署到生产环境。'
- en: 'When accessing the **published** folder, we have to simulate the directory/file
    structure:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问**发布**文件夹时，我们必须模拟目录/文件结构：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, there are several **.dll** files, which are the dependencies
    that the application uses, in addition to static files such as **wwwroot** and
    configuration files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有几个 **.dll** 文件，这些是应用程序使用的依赖项，除了静态文件如 **wwwroot** 和配置文件。
- en: The contents of this folder are exactly what should be published in an environment,
    be it locally or via a cloud provider.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件夹的内容正是应该在一个环境中发布的，无论是本地还是通过云提供商。
- en: 'By accessing the **published** directory through the terminal and executing
    the following command, it’s possible to run the application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中访问**发布**目录并执行以下命令，可以运行应用程序：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **UrlShorterner.dll** file is the executable for an ASP.NET Core 9 application.
    It’s possible to run the application through the **.dll** file on your development
    machine since the .NET SDK is installed. The SDK must not be installed on servers
    that will run the applications. For this, you only need to install **.** **NET
    Runtime** .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**UrlShorterner.dll** 文件是一个 ASP.NET Core 9 应用程序的可执行文件。由于您的开发机器上已安装 .NET SDK，因此可以通过
    **.dll** 文件在您的开发机器上运行应用程序。SDK 不应安装在将运行应用程序的服务器上。为此，您只需安装 **.NET 运行时** 。'
- en: .NET Runtime
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 运行时
- en: .NET Runtime is a software framework developed by Microsoft that provides a
    managed execution environment for running .NET applications. It includes the components
    needed to run .NET programs, manage memory, handle exceptions, and collect garbage.
    .NET Runtime is typically installed on servers and machines that run specific
    .NET applications. Unlike the .NET SDK, .NET Runtime has features for running
    applications rather than building and developing them. To learn more about .NET
    Runtime, go to [https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)
    .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 运行时是由微软开发的一个软件框架，它为运行 .NET 应用程序提供了一个托管执行环境。它包括运行 .NET 程序、管理内存、处理异常和收集垃圾所需的组件。.NET
    运行时通常安装在运行特定 .NET 应用程序的服务器和机器上。与 .NET SDK 不同，.NET 运行时具有运行应用程序的功能，而不是构建和开发它们。要了解更多关于
    .NET 运行时的信息，请访问 [https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)
    。
- en: 'The .NET platform and ASP.NET Core 9 are portable, which means they can be
    run on different operating systems that have the SDK or .NET Runtime installed.
    *Table 10.2* shows the application servers that can be used in each of the most
    important operating systems:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: .NET平台和ASP.NET Core 9是可移植的，这意味着它们可以在安装了SDK或.NET运行时的不同操作系统上运行。*表10.2*显示了在最重要的每个操作系统上可以使用的应用程序服务器：
- en: '| **Operating System** | **Prerequisites** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **先决条件** |'
- en: '| Linux |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| Linux |'
- en: .NET SDK/Runtime, Kestrel
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK/Runtime, Kestrel
- en: 'Optional: Nginx/Apache, Hosting bundle'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：Nginx/Apache，托管套餐
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| macOS |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| macOS |'
- en: .NET SDK/Runtime, Kestrel
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK/Runtime, Kestrel
- en: 'Optional: Nginx/Apache'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：Nginx/Apache
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Windows |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Windows |'
- en: .NET SDK/Runtime, Kestrel
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK/Runtime, Kestrel
- en: 'Optional: IIS, NGINX, HTTP.sys, ASP.NET Core Hosting bundle'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：IIS、NGINX、HTTP.sys、ASP.NET Core托管套餐
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 10.2 – Web server options for ASP.NET Core 9 applications
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表10.2 – ASP.NET Core 9应用程序的Web服务器选项'
- en: Generating publication packages using the CLI tool is straightforward. We’ll
    follow this process while automating via CI/CD, something we’ll cover in the *Understanding
    the DevOps approach with* *CI/CD* section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CLI工具生成发布包的过程很简单。我们将遵循此过程，并通过CI/CD自动化，我们将在*理解CI/CD的DevOps方法*部分进行介绍。
- en: Now that we’ve learned how to generate publishing packages, it’s time to learn
    how to publish them in a cloud environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何生成发布包，是时候学习如何在云环境中发布它们了。
- en: Publishing the solution in a cloud environment
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云环境中发布解决方案
- en: The advantage of developing modern applications with ASP.NET Core 9 goes beyond
    the ability to use implementation best practices – it also encompasses the need
    to deliver high-quality solutions to application users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core 9开发现代应用程序的优势不仅在于能够使用实现最佳实践的能力，还在于需要向应用程序用户提供高质量解决方案。
- en: So far, we’ve learned about the importance of using various features of the
    .NET platform, such as using the .NET CLI to compile applications and install
    support tools such as Entity Framework Core. We’ve also learned about the process
    of generating publishable packages that can be run both locally and in any other
    environment that uses . NET Runtime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了使用.NET平台各种功能的重要性，例如使用.NET CLI编译应用程序和安装支持工具，如Entity Framework Core。我们还了解了生成可在本地和任何使用.NET运行时的环境中运行的发布包的过程。
- en: At the time of writing, it’s impossible not to work in a cloud environment.
    This offers us benefits such as elasticity, availability, security, and many other
    features that simplify the process of deploying, maintaining, and evolving applications
    through the continuous process of delivering value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，不工作在云环境中是不可能的。这为我们提供了诸如弹性、可用性、安全性以及许多其他简化通过持续交付价值的过程来部署、维护和演进应用程序的好处。
- en: To learn how to publish the solution in a cloud environment, we’ll use Azure
    as our cloud provider.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在云环境中发布解决方案，我们将使用Azure作为我们的云提供商。
- en: Moving an ASP.NET Core 9 application to Azure allows developers to benefit from
    the dynamic capabilities provided by such a cloud provider while focusing on the
    application context and business objectives. Azure, through its diverse resources
    and services, allows applications to handle varied workloads, remain accessible
    to users, and stay protected against security threats.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将ASP.NET Core 9应用程序迁移到Azure允许开发者利用这种云提供商提供的动态功能，同时关注应用程序上下文和业务目标。Azure通过其多样化的资源和服务，允许应用程序处理各种工作负载，保持对用户的可用性，并保护免受安全威胁。
- en: Based on the **UrlShortener** application that we worked on previously and in
    conjunction with the process of generating publishable packages, we’ll implement
    the benefits of Azure and publish this application in a cloud environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们之前工作的**UrlShortener**应用程序以及生成可发布包的过程，我们将实现Azure的好处并将此应用程序发布在云环境中。
- en: Creating Azure app services and database resources
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Azure应用程序服务和数据库资源
- en: The Azure environment provides different types of resources for publishing applications,
    at different service levels and with varying publishing approaches.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Azure环境为发布应用程序提供了不同类型的资源，这些资源在不同的服务级别和不同的发布方法中有所不同。
- en: For this application, we’ll use a resource called **App Service** , a **Platform-as-a-Service**
    ( **PaaS** ) offering provided by Azure that allows us to focus on our applications.
    App Service provides a great application server while also supplying us with a
    URL to access the published application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将使用一个名为 **App Service** 的资源，这是 Azure 提供的 **平台即服务** ( **PaaS** ) 产品，它允许我们专注于我们的应用程序。App
    Service 提供了一个出色的应用程序服务器，同时为我们提供了访问已发布应用程序的 URL。
- en: You must have prepared your environment based on the information provided in
    the *Technical* *requirements* section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须根据 *技术要求* 部分提供的信息准备您的环境。
- en: Application services and PaaS
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务和 PaaS
- en: 'Azure App Service is a fully managed PaaS that allows developers to build,
    deploy, and scale web applications, mobile backends, and RESTful APIs in the programming
    language of their choice, without the need for infrastructure management. App
    Service provides a prepared server, providing the runtime needed to run your applications.
    The PaaS approach is a cloud computing model that provides a complete development
    and deployment environment in the cloud, freeing developers from the need to deal
    with infrastructure. For more details, see the Azure App Service documentation:
    [https://docs.microsoft.com/en-us/azure/app-service/](https://docs.microsoft.com/en-us/azure/app-service/)
    .'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Azure App Service 是一个完全管理的 PaaS，允许开发者在他们选择的编程语言中构建、部署和扩展 Web 应用程序、移动后端和 RESTful
    API，而无需进行基础设施管理。App Service 提供了一个准备好的服务器，提供运行您的应用程序所需的运行时。PaaS 方法是一种云计算模型，它提供了一个完整的开发部署环境在云中，使开发者从处理基础设施的需求中解放出来。有关更多详细信息，请参阅
    Azure App Service 文档：[https://docs.microsoft.com/en-us/azure/app-service/](https://docs.microsoft.com/en-us/azure/app-service/)。
- en: Our goal will not be to exhaust all resource options available in the Azure
    environment since a separate book dedicated to this subject would be needed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标不会是耗尽 Azure 环境中所有可用的资源选项，因为需要一本专门介绍这个主题的书。
- en: Instead, we’ll focus on publishing the **UrlShortener** application while using
    Azure App Service as the web host.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将专注于使用 Azure App Service 作为 Web 服务器发布 **UrlShortener** 应用程序。
- en: 'Follow these steps to publish the application:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤发布应用程序：
- en: Access the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Azure 门户 ([https://portal.azure.com](https://portal.azure.com) )。
- en: 'On the main screen, click on the **Create a resource** button, as shown in
    *Figure 10* *.1* :'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主屏幕上，点击 **创建资源** 按钮，如图 *图 10.1* 所示：
- en: '![Figure 10.1 – Creating a new Azure resource](img/B21788_10_01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 创建新的 Azure 资源](img/B21788_10_01.jpg)'
- en: Figure 10.1 – Creating a new Azure resource
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 创建新的 Azure 资源
- en: 'Then, select **Create** under the **Web App** resource, as shown in *Figure
    10* *.2* :'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **Web App** 资源下选择 **创建**，如图 *图 10.2* 所示：
- en: '![Figure 10.2 – Creating a new Web App resource](img/B21788_10_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 创建新的 Web App 资源](img/B21788_10_02.jpg)'
- en: Figure 10.2 – Creating a new Web App resource
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 创建新的 Web App 资源
- en: 'On the **Basics creation** screen of the new **Web App** resource, fill in
    the information provided in *Table 10.3* :'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 **Web App** 资源的 **基本创建** 屏幕上，填写 *表 10.3* 中提供的信息：
- en: '| **Parameter** | **Value** | **Description** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **值** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Subscription** | Select your subscription. | A subscription is necessary
    to onboard the resources and related costs. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **订阅** | 选择您的订阅。 | 订阅是上线资源和相关成本所必需的。|'
- en: '| **Resource Group** | Here, the value is **rg-aspnetcore8** . If this resource
    group doesn’t exist, click on **Create new link** below the **Resource Group**
    field and create it. | The resource is a logical group of resources in Azure.
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **资源组** | 在这里，值是 **rg-aspnetcore8**。如果此资源组不存在，请点击 **资源组** 字段下方的 **创建新链接**
    并创建它。 | 资源是 Azure 中资源的逻辑组。|'
- en: '| **Name** | **urlshortener.<your** **last name>** . | This parameter will
    be the URL of your application. Please keep it unique. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **urlshortener.<您的** **姓氏>** | 此参数将是您应用程序的 URL。请保持其唯一性。|'
- en: '| **Publish** | **Code** . | App Service has different ways to host and publish
    applications. In this case, we’re using the **Code** option because we’ll publish
    the generated package. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **发布** | **代码** | App Service 有不同的方式来托管和发布应用程序。在这种情况下，我们使用 **代码** 选项，因为我们将会发布生成的包。|'
- en: '| **Runtime stack** | **.NET** **9 (LTS)** . | This parameter defines the type
    of application that will be hosted on App Service. It supports .NET, Node.js,
    Java, PHP, and Python. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **运行时堆栈** | **.NET** **9 (LTS)** | 此参数定义将在 App Service 上托管的应用程序类型。它支持 .NET、Node.js、Java、PHP
    和 Python。|'
- en: '| **Operational System** | Linux. | Linux is a good option for many use cases.
    However, for this exercise, you can select Windows as well. The definition of
    the operating system depends on the requirements of the application. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | Linux. | Linux 是许多用例的良好选择。然而，对于这个练习，你也可以选择 Windows。操作系统的定义取决于应用程序的需求。|'
- en: '| **Region** | **EastUS 2** | The region where App Service will be hosted.
    We’re using **East US 2** because the database we’ll be creating is not available
    in the East US region. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **区域** | **EastUS 2** | App Service 将托管的应用程序所在的区域。我们使用 **East US 2** 是因为我们将创建的数据库在
    East US 区域不可用。|'
- en: '| **Linux Pan** | Leave as-is. | We’ll be creating a new service plan to host
    the application. The service plan is an important component of App Service. Depending
    on the pricing plan, the service plan can host more than one application. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **Linux 平台** | 保持原样。 | 我们将创建一个新的服务计划来托管应用程序。服务计划是应用服务的一个重要组成部分。根据定价计划，服务计划可以托管多个应用程序。|'
- en: '| **Pricing plan** | **Basic B1** . | The **Basic B1** option is enough for
    this example. Keep in mind that if you select a different Pricing plan, you can
    be charged higher costs. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **定价计划** | **基本 B1** . | **基本 B1** 选项对于这个例子来说已经足够了。请记住，如果你选择不同的定价计划，可能会产生更高的费用。|'
- en: '| **Zone redundancy** | Disabled. | This parameter is used in production environments
    where applications require a high-availability configuration. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **区域冗余** | 禁用。 | 此参数用于需要高可用性配置的生产环境中的应用程序。|'
- en: Table 10.3 – Basic parameters of the new Web App resource
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3 – 新 Web 应用资源的基本参数
- en: '5. Click on the **Next: Database >** button.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 点击 **下一步：数据库 >** 按钮。
- en: '6. Select the **Create a database** option and fill in the parameters as per
    *Figure 10* *.3* :'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 选择 **创建数据库** 选项，并按照 *图 10* *.3* 中的说明填写参数：
- en: '![Figure 10.3 – Database server configuration](img/B21788_10_03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 数据库服务器配置](img/B21788_10_03.jpg)'
- en: Figure 10.3 – Database server configuration
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 数据库服务器配置
- en: At this stage, we’re configuring a database, which is necessary for the **URLShortener**
    application. We’ll use the Azure SQL Server resource since it provides a server
    where you can host different databases. For this example, we’re using just one
    database. However, if desired, other databases can be added later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们正在配置数据库，这对于 **URLShortener** 应用程序是必要的。我们将使用 Azure SQL Server 资源，因为它提供了一个可以托管不同数据库的服务器。在这个例子中，我们只使用一个数据库。但是，如果需要，以后可以添加其他数据库。
- en: 7. Now, click on the **Monitor + Secure** tab and set the **Enable Application
    Insights** option to **No** .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 现在，点击 **监控 + 安全** 选项卡，并将 **启用 Application Insights** 选项设置为 **否** 。
- en: This option aims to create a monitoring resource for the application. This is
    a best practice, especially for production resources. Therefore, at this stage,
    the objective is to publish the application; there’s no need for monitoring, something
    that can be added later.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项旨在为应用程序创建一个监控资源。这是一个最佳实践，特别是对于生产资源。因此，在这个阶段，目标是发布应用程序；目前不需要监控，这可以在以后添加。
- en: 8. Next, click **Review and Create** . Then, click **Create** and wait for the
    resource to be created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 接下来，点击 **审查和创建** 。然后，点击 **创建** 并等待资源创建完成。
- en: '9. On the review screen, in the **Database** section, you’ll see username and
    password information, as shown in *Figure 10* *.4* . Copy those details and keep
    them handy; we’ll need the password later to configure the database:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 9. 在审查屏幕上，在 **数据库** 部分中，你会看到用户名和密码信息，如图 *图 10* *.4* 所示。复制这些详细信息并妥善保管；我们稍后会需要密码来配置数据库：
- en: '![Figure 10.4 – Database credentials](img/B21788_10_04.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 数据库凭据](img/B21788_10_04.jpg)'
- en: Figure 10.4 – Database credentials
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 数据库凭据
- en: 10. Finally, click **Create** and wait for the resource to be created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 最后，点击 **创建** 并等待资源创建完成。
- en: '11. Once the resource has been created, click the **Go to resource** button,
    as shown in *Figure 10* *.5* :'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 一旦资源创建完成，点击如图 *图 10* *.5* 所示的 **转到资源** 按钮：
- en: '![Figure 10.5: Resource created screen](img/B21788_10_05.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5：资源创建屏幕](img/B21788_10_05.jpg)'
- en: 'Figure 10.5: Resource created screen'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：资源创建屏幕
- en: You will be redirected to the previously created **App Service** settings summary
    screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被重定向到之前创建的 **应用服务** 设置摘要屏幕。
- en: 'As shown in *Figure 10* *.6* , you’ll be able to see the **Default domain**
    URL that’s been made available so that you can access the application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10* *.6* 所示，你将能够看到可用的 **默认域名** URL，以便你可以访问应用程序：
- en: '![Figure 10.6 – Default domain URL of the created application services](img/B21788_10_06.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 创建的应用程序服务的默认域名URL](img/B21788_10_06.jpg)'
- en: Figure 10.6 – Default domain URL of the created application services
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 创建的应用程序服务的默认域名URL
- en: 'The **Default domain** URL is automatically created by Azure, according to
    the parameters defined when creating the application services and can be customized
    with a custom domain. We’ll keep the URL available and in operation. Upon clicking
    on the URL, you’ll be redirected to a page containing information similar to what’s
    shown in *Figure 10* *.7* :'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认域名**URL是Azure根据创建应用程序服务时定义的参数自动创建的，可以使用自定义域名进行自定义。我们将保持URL可用并运行。点击URL后，您将被重定向到一个包含类似*图10.7*所示信息的页面：'
- en: '![Figure 10.7 – Default website content of the new application services](img/B21788_10_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 新应用程序服务的默认网站内容](img/B21788_10_07.jpg)'
- en: Figure 10.7 – Default website content of the new application services
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 新应用程序服务的默认网站内容
- en: At this point, the server is up and running, but we must publish the application
    on Azure. However, before publishing the application, let’s configure the database.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，服务器已启动并运行，但我们必须在Azure上发布应用程序。然而，在发布应用程序之前，让我们先配置数据库。
- en: Configuring Azure SQL Server
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Azure SQL服务器
- en: While creating our application services, other resources were created, such
    as the database server and the database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的应用程序服务时，还创建了其他资源，例如数据库服务器和数据库。
- en: We need to configure the database so that we have the table we used in the application
    to persist the URLs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置数据库，以便我们能够持久化应用程序中使用的URL表。
- en: We’ll use the Entity Framework Core tool to update the database in the same
    way we did it locally. However, the database service that’s automatically created
    by Azure is publicly inaccessible for security reasons.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Entity Framework Core工具以与本地相同的方式更新数据库。然而，由于安全原因，Azure自动创建的数据库服务是公开不可访问的。
- en: 'To do this, we must make some configuration changes in advance so that we can
    manipulate the database. Follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须提前进行一些配置更改，以便我们可以操作数据库。按照以下步骤操作：
- en: Go to the previously created resource group – that is, **rg-aspnetcore8** .
    You will be able to see a list of created resources.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往之前创建的资源组 – 即**rg-aspnetcore8**。您将能够看到创建的资源列表。
- en: Search for the **UrlshortenerDB** resource and access it.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索**UrlshortenerDB**资源并访问它。
- en: Then, in the **Settings** menu group, click **Connection Strings** .
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**设置**菜单组中，单击**连接字符串**。
- en: 'The connection string should look like this:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接字符串应如下所示：
- en: '[PRE12]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the **Password={your_password}** parameter. Replace this parameter with
    the password that you copied when you were creating your application services.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意**Password={your_password}**参数。在创建应用程序服务时，将此参数替换为您复制的密码。
- en: Copy the connection string from the **ADO.NET (SQL** **Authentication)** field.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**ADO.NET (SQL** **Authentication)**字段复制连接字符串。
- en: 'Now, open the **appsettings.json** file of the **URLShortener** application
    and change the **DefaultConnection** property to the connection string you copied
    previously. The result will look like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开**URLShortener**应用程序的**appsettings.json**文件，将**DefaultConnection**属性更改为您之前复制的连接字符串。结果将如下所示：
- en: '[PRE13]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save the **appsettings.json** file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存**appsettings.json**文件。
- en: Now, let’s configure access to the database server. To do this, go back to the
    **rg-aspnetcore8** resource group and click on the **urlshortener-db-server<your
    last** **name>** resource.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们配置对数据库服务器的访问。为此，返回到**rg-aspnetcore8**资源组，并单击**urlshortener-db-server<your
    last** **name>**资源。
- en: 'From the main menu, go to **Security** | **Networking** and click on the **Add
    your client IPv4 address** option, as shown in *Figure 10* *.8* :'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单转到**安全** | **网络**，然后单击**添加您的客户端IPv4地址**选项，如图*图10.8*所示：
- en: '![Figure 10.8 – Adding a firewall rule to access the private database of an
    IPv4 address](img/B21788_10_08.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 添加防火墙规则以访问IPv4地址的私有数据库](img/B21788_10_08.jpg)'
- en: Figure 10.8 – Adding a firewall rule to access the private database of an IPv4
    address
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 添加防火墙规则以访问IPv4地址的私有数据库
- en: This configuration will create a rule so that the database is only accessible
    via its current IP. Keep in mind that if your IP changes, you will have to perform
    these steps again to add the new IP.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将创建一个规则，使得数据库只能通过其当前IP地址访问。请注意，如果您的IP地址更改，您将必须再次执行这些步骤以添加新的IP地址。
- en: Finally, click **Save** .
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，单击**保存**。
- en: With this, we’ve configured the application for the connection string of the
    database hosted in Azure and added a firewall rule so that the database can be
    accessed through our current IP.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经为托管在 Azure 上的数据库连接字符串配置了应用程序，并添加了防火墙规则，以便可以通过我们当前的 IP 地址访问数据库。
- en: 'Now, we need to update the database. To do this, access your operating system’s
    terminal and navigate to the **URLShortener** project directory. Then, run the
    following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新数据库。为此，访问您的操作系统终端并导航到 **URLShortener** 项目目录。然后，运行以下命令：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Wait for the process to complete. To check whether the table was created correctly,
    in the Azure portal ( [https://portal.azure.com](https://portal.azure.com) ),
    access the **rg-aspnetcore9** resource group, then access the **UrlShortenerDB**
    resource. Click on the **Query Editor** menu and access the database with the
    credentials that were provided when you were creating the application service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 等待过程完成。要检查表是否正确创建，请在 Azure 门户（[https://portal.azure.com](https://portal.azure.com)）中访问
    **rg-aspnetcore9** 资源组，然后访问 **UrlShortenerDB** 资源。点击 **查询编辑器** 菜单并使用创建应用程序服务时提供的凭据访问数据库。
- en: 'As shown in *Figure 10* *.9* , the new table has been created:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.9* 所示，新表已创建：
- en: '![Figure 10.9 – The database tables that were created using Entity Framework
    Core migrations](img/B21788_10_09.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 使用 Entity Framework Core 迁移创建的数据库表](img/B21788_10_09.jpg)'
- en: Figure 10.9 – The database tables that were created using Entity Framework Core
    migrations
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 使用 Entity Framework Core 迁移创建的数据库表
- en: This is one of the benefits of using migrations through Entity Framework Core.
    By doing this, it’s possible to apply changes to a local database or server and
    maintain compliance with the application code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 Entity Framework Core 迁移的好处之一。通过这样做，可以应用到本地数据库或服务器上的更改，并保持与应用程序代码的一致性。
- en: Now that the database has been configured, it’s time to publish the application.
    We’ll do this through Visual Studio Code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库已配置，是时候发布应用程序了。我们将通过 Visual Studio Code 来完成这项操作。
- en: Publishing an application with Visual Studio Code
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 发布应用程序
- en: With all the prerequisites for hosting the application in Azure configured,
    it’s time to publish the application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了在 Azure 上托管应用程序的所有先决条件后，现在是时候发布应用程序了。
- en: The process of publishing via Visual Studio Code or even with Visual Studio
    is quite straightforward.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Visual Studio Code 或甚至 Visual Studio 发布的过程相当简单。
- en: In the *Technical requirements* section, it was suggested that you install and
    configure the Azure Tools extension [(https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack)
    ). This extension makes the manual publishing process easier.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *技术要求* 部分，建议您安装和配置 Azure Tools 扩展 [(https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack)
    )。此扩展使手动发布过程更加容易。
- en: 'Follow these steps to publish the application version in the application services
    we created previously:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤发布我们在之前创建的应用服务中的应用程序版本：
- en: 'Access the **UrlShortener** application directory and run the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 **UrlShortener** 应用程序目录并运行以下命令：
- en: '[PRE15]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, click on the Azure Tools extension icon in Visual Studio Code, as shown
    in *Figure 10* *.10* :'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 Visual Studio Code 中的 Azure Tools 扩展图标，如图 *图 10.10* 所示：
- en: '![Figure 10.10 – Azure Tools in Visual Studio Code](img/B21788_10_10.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – Visual Studio Code 中的 Azure Tools](img/B21788_10_10.jpg)'
- en: Figure 10.10 – Azure Tools in Visual Studio Code
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – Visual Studio Code 中的 Azure Tools
- en: A list of subscriptions that are available to your user will be displayed. By
    expanding the subscription, we’ll be able to see the App Service resource and
    the resource that’s been created for the **UrlShortener** application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示您用户可用的订阅列表。通过展开订阅，我们将能够看到为 **UrlShortener** 应用程序创建的应用服务资源以及资源。
- en: 'Now, right-click on the **urlshortener-<your last name>** application and select
    the **Deploy to Web App…** option, as shown in *Figure 10* *.11* :'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击 **urlshortener-<你的姓氏>** 应用程序，并选择 **部署到 Web 应用…** 选项，如图 *图 10.11* 所示：
- en: '![Figure 10.11 – Deploying a web app using the Azure Tools extensions in Visual
    Studio Code](img/B21788_10_11.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 使用 Visual Studio Code 中的 Azure Tools 扩展部署 Web 应用](img/B21788_10_11.jpg)'
- en: Figure 10.11 – Deploying a web app using the Azure Tools extensions in Visual
    Studio Code
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 使用 Visual Studio Code 中的 Azure Tools 扩展部署 Web 应用
- en: You’ll be asked for some configuration details so that you can deploy. Just
    confirm the options that are provided and wait for the deployment process to complete.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将需要提供一些配置细节，以便您可以部署。只需确认提供的选项，然后等待部署过程完成。
- en: 'After the publication process is complete, a notification similar to the one
    shown in *Figure 10* *.12* will be displayed:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布过程完成后，将显示类似于*图10* *.12* 中所示的通知：
- en: '![Figure 10.12 – A notification stating that application deployment has been
    completed](img/B21788_10_12.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 表示应用程序部署已完成的通知](img/B21788_10_12.jpg)'
- en: Figure 10.12 – A notification stating that application deployment has been completed
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 表示应用程序部署已完成的通知
- en: 'You can navigate to the published website by clicking the **Browse Website**
    button. You’ll see a result similar to the one shown in *Figure 10* *.13* :'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过点击**浏览网站**按钮导航到已发布的网站。您将看到类似于*图10.13* *.*13* 中所示的结果：
- en: '![Figure 10.13 – The URL Shortener application running on Azure](img/B21788_10_13.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 在Azure上运行的URL缩短器应用程序](img/B21788_10_13.jpg)'
- en: Figure 10.13 – The URL Shortener application running on Azure
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 在Azure上运行的URL缩短器应用程序
- en: Now, you can use the application that contains the short URL functionality directly
    in your Azure environment publicly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以直接在您的Azure环境中公开使用包含短网址功能的应用程序。
- en: 'The Azure Tools extension automates the process of publishing new application
    versions by running the following processes in the background:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Azure工具扩展通过在后台运行以下过程来自动化发布新应用程序版本的过程：
- en: Restoring packages
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复包
- en: Compiling the application
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译应用程序
- en: Generating a publishing package
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成发布包
- en: Compressing the publishing package in **.** **zip** format
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将发布包压缩成**.** **zip**格式
- en: Connecting to the Azure environment
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到Azure环境
- en: Deploying the ZIP file containing the publication package
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署包含发布包的ZIP文件
- en: Extracting the ZIP file
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压ZIP文件
- en: These steps are performed every time you choose to deploy using the Azure Tools
    extension. We’ll learn about another way to publish packages in a C/ICD model
    in the *Understanding DevOps approach with CI/CD* section of this chapter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在您每次选择使用Azure工具扩展部署时都会执行。我们将在本章的*理解DevOps方法中的CI/CD*部分了解另一种在C/ICD模型中发布包的方法。
- en: Hosting solutions in cloud environments is a necessary activity today and several
    resources can help us with this task.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中托管解决方案是当今的一项必要活动，并且有几种资源可以帮助我们完成这项任务。
- en: The definition of each hosting resource and service layer will depend on the
    application requirements, as well as the team’s level of knowledge. There are
    cases where we can use strategies that allow us to host our applications in different
    environments, in a way that’s agnostic to the specific resources of cloud providers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个托管资源和服务层的定义将取决于应用程序需求以及团队的知识水平。有些情况下，我们可以使用允许我们在不同环境中托管应用程序的策略，这种方式对云提供商的具体资源是无关紧要的。
- en: To achieve this, a strategy that’s often used in cloud-native applications is
    the containers strategy. We’ll learn about this in the next section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，云原生应用程序中常用的一种策略是容器策略。我们将在下一节中了解这一点。
- en: Understanding the Docker principles and how to package the application in a
    container
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Docker原则以及如何在容器中打包应用程序
- en: Nowadays, using a container strategy has become essential, especially for cloud-native
    applications. Containers provide a consistent environment for development, testing,
    and deployment, ensuring applications run smoothly regardless of where they’re
    deployed. When using containers, we practically have everything needed for the
    application to run in a given environment, with no need to install additional
    packages or runtimes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用容器策略已经成为一项基本要求，特别是对于云原生应用程序。容器为开发、测试和部署提供了一个一致的环境，确保应用程序无论部署在哪里都能顺利运行。使用容器时，我们实际上拥有在给定环境中运行应用程序所需的一切，无需安装额外的包或运行时。
- en: With this, we have consistency, which is crucial for cloud environments such
    as Azure or any other cloud provider as they offer robust services to manage and
    scale containerized applications. As an analogy, the container strategy helps
    combat the behavior that generates the statement “ *It works on* *my machine.*
    ”
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了一致性，这对于像Azure或其他任何云提供商这样的云环境至关重要，因为它们提供强大的服务来管理和扩展容器化应用程序。作为一个类比，容器策略有助于对抗产生“*在我的机器上*”这种说法的行为
- en: This phrase is true since the development environment has everything necessary
    to run an application. However, being agile in delivering value and having no
    dependencies for running applications, regardless of the environment, is one of
    the great advantages of containers. Before we create a container, let’s understand
    what they are.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个说法是正确的，因为开发环境拥有运行应用程序所需的一切。然而，无论在何种环境中运行应用程序都能敏捷地交付价值，并且没有运行应用程序的依赖性，这是容器的一个巨大优势。在我们创建容器之前，让我们先了解它们是什么。
- en: Understanding what a container is
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解什么是容器
- en: A container is a self-contained executable software package that includes everything
    needed to run a piece of software. Containers are isolated from each other and
    the host system, providing a consistent runtime environment. This isolation ensures
    that the application behaves the same regardless of the environment in which it
    runs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个包含运行软件所需一切的自包含可执行软件包。容器彼此之间以及与主机系统隔离，提供一致的运行时环境。这种隔离确保了应用程序的行为在它运行的任何环境中都是相同的。
- en: Containers provide a type of virtualization that’s different from what’s provided
    by traditional **virtual** **machines** ( **VMs** ).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了一种与传统**虚拟**（**VMs**）提供的虚拟化类型不同的虚拟化。
- en: VMs
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机
- en: VMs are software emulations of physical computers. Each VM runs a complete operating
    system, including its own kernel, and simulates all the hardware that the operating
    system requires. VMs run on a hypervisor, which manages multiple VMs on a single
    physical host.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是物理计算机的软件模拟。每个虚拟机运行一个完整的操作系统，包括其自己的内核，并模拟操作系统所需的全部硬件。虚拟机在虚拟机管理程序上运行，该管理程序管理单个物理主机上的多个虚拟机。
- en: '*Figure 10* *.14* shows some of the differences between containers and VMs:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10* *.14* 展示了容器和虚拟机之间的一些差异：'
- en: '![Figure 10.14 – Differences between containers and VMs](img/B21788_10_14.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 容器和虚拟机之间的差异](img/B21788_10_14.jpg)'
- en: Figure 10.14 – Differences between containers and VMs
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 容器和虚拟机之间的差异
- en: As we can see, containers don’t depend on a complete operating system for their
    execution, only on a runtime that shares a machine’s resources, such as networking
    and processing. However, they are executed independently and in isolation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，容器在执行时并不依赖于完整的操作系统，而仅依赖于共享机器资源的运行时，例如网络和处理。然而，它们是独立且隔离地执行的。
- en: 'Containers offer several benefits:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了几个好处：
- en: '**Portability** : Containers encapsulate all dependencies, making it easy to
    move applications between different environments without compatibility issues
    occurring.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性**：容器封装了所有依赖项，使得在不同环境中移动应用程序变得容易，而不会出现兼容性问题。'
- en: '**Consistency** : They ensure that applications run consistently across development,
    testing, and production environments.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：它们确保应用程序在开发、测试和生产环境中运行的一致性。'
- en: '**Scalability** : They can easily be scaled up or down to handle varying loads,
    making them ideal for cloud environments.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：它们可以轻松地扩展或缩减以处理不同的负载，这使得它们非常适合云环境。'
- en: '**Efficiency** : Containers share the kernel and host system resources efficiently,
    resulting in lower overhead compared to traditional VMs.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：容器有效地共享内核和主机系统资源，与传统的虚拟机相比，具有更低的开销。'
- en: To be able to run a container, it’s necessary to use a runtime to manage it,
    as is the case with ASP.NET Core 9 applications. The most famous container runtime
    is **Docker** . We’ll understand its fundamentals in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，需要使用运行时来管理它，就像ASP.NET Core 9应用程序一样。最著名的容器运行时是**Docker**。我们将在下一节中了解其基础知识。
- en: Understanding Docker fundamentals
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Docker基础知识
- en: Docker is an open source platform that automates the process of deploying, scaling,
    and managing containerized applications, providing a simple and powerful way to
    build, ship, and operate containers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个开源平台，它自动化了部署、扩展和管理容器化应用程序的过程，提供了一种简单而强大的方式来构建、运输和操作容器。
- en: 'Docker provides three components for managing containers:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了三个组件来管理容器：
- en: '**Docker Engine** : The runtime that manages containers'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Engine**：管理容器的运行时'
- en: '**Docker CLI** : The command-line interface used to interact with Docker'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker CLI**：用于与Docker交互的命令行界面'
- en: '**Docker Hub** : A cloud-based registry service for sharing and storing Docker
    images, similar to how we have GitHub for managing source code repositories'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：一个基于云的注册服务，用于共享和存储Docker镜像，类似于我们如何使用GitHub来管理源代码存储库'
- en: 'Through these tools, Docker provides mechanisms that allow us to manipulate
    the components that involve the container development strategy. In this case,
    containers have the following components:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些工具，Docker提供了允许我们操作涉及容器开发策略的组件的机制。在这种情况下，容器具有以下组件：
- en: '**Images** : An image can be compared to a photo of a current version of your
    application, including everything needed to run your application. Images are the
    basis of containers and are created using a **Dockerfile** , which contains a
    set of instructions for building the image.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：镜像可以比作您应用程序当前版本的快照，包括运行应用程序所需的一切。镜像是容器的基础，并使用**Dockerfile**创建，其中包含构建镜像的指令集。'
- en: '**Containers** : A container is a running instance of an image. We can relate
    an image to a class and a container to an instance of this class. Containers are
    created from images and run on Docker Engine. Each container is isolated from
    the others and has its own filesystem, CPU, memory, and process space.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：容器是镜像的运行实例。我们可以将镜像比作一个类，将容器比作这个类的实例。容器由镜像创建并在Docker Engine上运行。每个容器与其他容器隔离，并拥有自己的文件系统、CPU、内存和进程空间。'
- en: '**Dockerfile** : A Dockerfile is a text document that contains a series of
    instructions on how to build a Docker image. It specifies the base image to use,
    the application code, dependencies, and any commands required to configure the
    environment.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：Dockerfile是一个包含一系列构建Docker镜像指令的文本文件。它指定了要使用的基镜像、应用程序代码、依赖项以及配置环境所需的任何命令。'
- en: '**Container registry** : The container registry is a repository for storing
    and distributing images. Docker Hub is a popular public registry, though there
    are private registries such as Azure Container Registry available.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器注册库**：容器注册库是用于存储和分发镜像的仓库。Docker Hub是一个流行的公共注册库，尽管还有像Azure Container Registry这样的私有注册库可用。'
- en: 'The relationship between Docker components and their container structure is
    shown in *Figure 10* *.15* :'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Docker组件及其容器结构之间的关系在*图10.15*中显示：
- en: '![Figure 10.15 – The relationship between Docker and its container components](img/B21788_10_15.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – Docker及其容器组件之间的关系](img/B21788_10_15.jpg)'
- en: Figure 10.15 – The relationship between Docker and its container components
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – Docker及其容器组件之间的关系
- en: As mentioned previously, Docker is the most used container solution, but there
    are other types of runtimes available that implement the same concepts presented
    here.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker是最常用的容器解决方案，但还有其他类型的运行时可用，它们实现了这里介绍的概念。
- en: '*Table 10.4* explains some of the container runtimes that are available on
    the market:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*表10.4* 解释了市场上可用的某些容器运行时：'
- en: '| **Runtime** | **Description** | **Website** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **运行时** | **描述** | **网站** |'
- en: '| **containerd** | The core runtime used by Docker and Kubernetes. It focuses
    on simplicity and portability. | [https://containerd.io/](https://containerd.io/)
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **containerd** | Docker和Kubernetes使用的核心运行时。它侧重于简单性和可移植性。 | [https://containerd.io/](https://containerd.io/)
    |'
- en: '| **CRI-O** | A lightweight runtime for Kubernetes that implements the Kubernetes
    **Container Runtime** **Interface** ( **CRI** ). | [https://cri-o.io/](https://cri-o.io/)
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **CRI-O** | 一种轻量级运行时，用于Kubernetes，实现了Kubernetes **容器运行时** **接口**（**CRI**）。
    | [https://cri-o.io/](https://cri-o.io/) |'
- en: '| **runc** | A CLI tool for spawning and running containers according to the
    OCI specification. | [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **runc** | 根据OCI规范启动和运行容器的CLI工具。 | [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)
    |'
- en: '| **Podman** | A daemonless container engine that’s compatible with Docker.
    | [https://podman.io/](https://podman.io/) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **Podman** | 一种无守护进程的容器引擎，与Docker兼容。 | [https://podman.io/](https://podman.io/)
    |'
- en: '| **LXC** | A traditional container runtime that provides a VM-like experience.
    | [https://linuxcontainers.org/](https://linuxcontainers.org/) |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **LXC** | 一种传统的容器运行时，提供类似虚拟机的体验。 | [https://linuxcontainers.org/](https://linuxcontainers.org/)
    |'
- en: '| **Kata** **Containers** | This runtime combines the security of VMs with
    the speed of containers by running lightweight VMs. | [https://katacontainers.io/](https://katacontainers.io/)
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **Kata Containers** | 此运行时通过运行轻量级虚拟机，结合了虚拟机的安全性和容器的速度。 | [https://katacontainers.io/](https://katacontainers.io/)
    |'
- en: '| **Rancher** | Rancher Desktop provides container and Kubernetes management.
    | [https://rancherdesktop.io/](https://rancherdesktop.io/) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **Rancher** | Rancher Desktop提供容器和Kubernetes管理。 | [https://rancherdesktop.io/](https://rancherdesktop.io/)
    |'
- en: Table 10.4 – Container runtime options
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.4 – 容器运行时选项
- en: As we can see, there are several options for running containers in environments
    and the use of each solution will depend on the requirements of each application
    and organization. However, it’s worth remembering that containers include images,
    other containers, a Dockerfile, and a container registry, all of which are used
    by runtimes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在环境中运行容器有多种选择，每种解决方案的使用将取决于每个应用程序和组织的需求。然而，值得记住的是，容器包括镜像、其他容器、Dockerfile
    和容器注册表，所有这些都被运行时使用。
- en: At this point, we can package the **UrlShortener** application in a container.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以将 **UrlShortener** 应用程序打包到容器中。
- en: Packing the UrlShortener application
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包 UrlShortener 应用程序
- en: Docker Engine provides us with different types of resources and commands to
    manage containers. We’ll focus on the packaging process for the **UrlShortener**
    application and use the main features of a container, which include images, containers,
    and a container registry.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎为我们提供了不同类型的资源和命令来管理容器。我们将关注 **UrlShortener** 应用程序的打包过程，并使用容器的主要功能，包括镜像、容器和容器注册表。
- en: Before proceeding, make sure you’ve installed Docker Engine, as per the *Technical*
    *requirements* section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已按照 *技术要求* 部分安装了 Docker 引擎。
- en: 'Our packaging process will take place through the following flow:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的打包过程将通过以下流程进行：
- en: '![Figure 10.16 – Container creation flow](img/B21788_10_16.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 容器创建流程](img/B21788_10_16.jpg)'
- en: Figure 10.16 – Container creation flow
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 容器创建流程
- en: 'In Visual Studio Code, be sure to open the **UrlShortener** application and
    perform the following steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，务必打开 **UrlShortener** 应用程序并执行以下步骤：
- en: In the root of the directory, create a file called **Dockerfile** . This file
    has no extension.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目录的根目录下，创建一个名为 **Dockerfile** 的文件。此文件没有扩展名。
- en: 'Add the following content to the file:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到文件中：
- en: '[PRE16]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the file.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'The preceding code is a bit long and seems complicated, so let’s understand
    each line of our **Dockerfile** :'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码有点长，看起来有些复杂，所以让我们理解一下我们的 **Dockerfile** 中的每一行：
- en: '**Base image and initial configuration** : At this stage, we’re configuring
    a base image that contains the default configurations for running an ASP.NET Core
    9 application.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础镜像和初始配置**：在这个阶段，我们正在配置一个基础镜像，其中包含运行 ASP.NET Core 9 应用程序默认配置。'
- en: '**FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base** : This line specifies
    the base image of the final container, which uses the ASP.NET Core version 8.0
    runtime image from the **Microsoft Container Registry** ( **MCR** ). All Docker
    images start with a reference to a base image. The **AS base** tag names this
    stage **base** .'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base**：此行指定最终容器的基镜像，它使用来自 **Microsoft
    Container Registry**（**MCR**）的 ASP.NET Core 8.0 运行时镜像。所有 Docker 镜像都以对基镜像的引用开始。**AS
    base** 标签将此阶段命名为 **base**。'
- en: '**WORKDIR /app** : This line sets the working directory within the container
    to **/app** . All subsequent commands will be executed in this directory.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WORKDIR /app**：此行将容器内部的工作目录设置为 **/app**。所有后续命令都将在此目录中执行。'
- en: '**EXPOSE 8080** : This line tells Docker that the container will listen on
    port **8080** at runtime. This is used for documentation purposes, as well as
    for configuring port mapping when running the container.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXPOSE 8080**：此行告诉 Docker 容器在运行时将监听端口 **8080**。这用于文档目的，以及在运行容器时配置端口映射。'
- en: '**Build stage** : The build stage will be an image that’s responsible for compiling
    the application. It will use an image that already has the .NET SDK installed
    as a base.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建阶段**：构建阶段将是一个负责编译应用程序的镜像。它将使用已经安装了 .NET SDK 的镜像作为基础。'
- en: '**FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build** : This line uses the .NET
    SDK image version 8.0 from MCR to build the application. The **AS build** tag
    names this stage **build** .'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build**：此行使用来自 MCR 的 .NET SDK 8.0
    镜像版本来构建应用程序。**AS build** 标签将此阶段命名为 **build**。'
- en: '**WORKDIR /src** : Sets the working directory to **/src** .'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WORKDIR /src**：将工作目录设置为 **/src**。'
- en: '**COPY ["UrlShortener.csproj", "MyApp/"]** : Copies the **UrlShortener.csproj**
    project file to the **MyApp/** directory in the container.'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COPY ["UrlShortener.csproj", "MyApp/"]**：将 **UrlShortener.csproj** 项目文件复制到容器中的
    **MyApp/** 目录。'
- en: '**RUN dotnet restore "MyApp/UrlShortener.csproj"** : Restores the project dependencies
    specified in the **UrlShortener.csproj** file.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN dotnet restore "MyApp/UrlShortener.csproj"**：恢复 **UrlShortener.csproj**
    文件中指定的项目依赖项。'
- en: '**COPY . ./MyApp** : Copies all the files from the current directory on the
    host to the **MyApp** directory in the container.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COPY . ./MyApp** : 将主机当前目录中的所有文件复制到容器中的 **MyApp** 目录。'
- en: '**WORKDIR "/src/MyApp"** : Sets the working directory to **/src/MyApp** .'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WORKDIR "/src/MyApp"** : 将工作目录设置为 **/src/MyApp**。'
- en: '**RUN dotnet build "UrlShortener.csproj" -c Release -o /app/build** : Builds
    the project in **Release** configuration and outputs the build results to the
    **/** **app/build** directory.'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN dotnet build "UrlShortener.csproj" -c Release -o /app/build** : 在 **Release**
    配置下构建项目，并将构建结果输出到 **/app/build** 目录。'
- en: '**Publish stage** : At this stage, the publication package is generated.'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布阶段** : 在此阶段，生成发布包。'
- en: '**FROM build AS publish** : This line uses the build stage as the base for
    the publish stage.'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM build AS publish** : 这行使用构建阶段作为发布阶段的基础。'
- en: '**RUN dotnet publish "UrlShortener.csproj" -c Release -o /app/publish** : This
    line publishes the project, which means it compiles the application, copies all
    the necessary files, and produces a deployable version of the application in the
    **/** **app/publish** directory.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN dotnet publish "UrlShortener.csproj" -c Release -o /app/publish** : 这行发布项目，意味着它编译应用程序，复制所有必要的文件，并在
    **/app/publish** 目录中生成可部署的应用程序版本。'
- en: '**Final stage** : The final stage takes the package that was generated by the
    previous configuration and runs it on an image containing the settings from the
    base image.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终阶段** : 最终阶段将之前配置生成的包在包含基础镜像设置的镜像上运行。'
- en: '**FROM base AS final** : Uses the base stage as the base for the final image.'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM base AS final** : 使用基础阶段作为最终镜像的基础。'
- en: '**WORKDIR /app** : Sets the working directory to **/app** .'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WORKDIR /app** : 将工作目录设置为 **/app**。'
- en: '**COPY --from=publish /app/publish .** : Copies the contents of the **/app/publish**
    directory from the publish stage to the current directory ( **/app** ) in the
    final stage.'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COPY --from=publish /app/publish .** : 将发布阶段的 **/app/publish** 目录内容复制到最终阶段的当前目录（**/app**）。'
- en: '**ENTRYPOINT ["dotnet", "UrlShortener.dll"]** : Sets the entry point for the
    container so that it can run the **dotnet UrlShortener.dll** command, which starts
    the ASP.NET Core application.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENTRYPOINT ["dotnet", "UrlShortener.dll"]** : 设置容器的入口点，以便可以运行 **dotnet UrlShortener.dll**
    命令，该命令启动ASP.NET Core应用程序。'
- en: As explained previously, the code available in the **Dockerfile** file uses
    various stages to generate an image of the application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**Dockerfile** 文件中可用的代码使用多个阶段来生成应用程序的镜像。
- en: The Docker build stage is a phase of the Docker multi-stage build process where
    the application is compiled, dependencies are restored, and all the required files
    are prepared for deployment. In a multi-stage build, each stage can use a different
    base image and environment to perform specific tasks.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Docker构建阶段是Docker多阶段构建过程中的一个阶段，其中应用程序被编译，依赖项被还原，所有必需的文件都准备就绪以供部署。在多阶段构建中，每个阶段可以使用不同的基础镜像和环境来执行特定任务。
- en: The build stage typically uses a development image or SDK to compile and build
    the application, producing output artifacts that can be used in subsequent stages.
    This approach helps you create a clean, optimized final image that only contains
    the runtime dependencies and the application itself, without build tools or intermediate
    files.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段通常使用开发镜像或SDK来编译和构建应用程序，生成后续阶段可用的输出工件。这种方法有助于您创建一个干净、优化的最终镜像，该镜像仅包含运行时依赖项和应用程序本身，不包含构建工具或中间文件。
- en: Docker multi-stage build
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Docker多阶段构建
- en: Docker’s multi-stage build process allows you to generate optimized images and
    uses container technology to compile and generate publishable applications. To
    learn more about this, go to [https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/)
    .
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的多阶段构建过程允许您生成优化后的镜像，并使用容器技术来编译和生成可发布的应用程序。要了解更多信息，请访问[https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/)。
- en: 'When observing the flow of the multi-stage approach, we can automate the process
    of generating a Docker image by going through the package creation steps that
    we learned about previously. It’s possible to generate a Docker image without
    using the multi-stage process. In this case, it’s necessary to compile and generate
    the application package manually and, later, just copy the generated package into
    the image. This results in a **Dockerfile** file that looks similar to the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察多阶段方法的流程时，我们可以通过执行我们之前了解的包创建步骤来自动化生成Docker图像的过程。在没有使用多阶段过程的情况下也可以生成Docker图像。在这种情况下，需要手动编译和生成应用程序包，然后稍后只需将生成的包复制到图像中。这会导致一个类似于以下内容的**Dockerfile**文件：
- en: '[PRE17]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By doing this, the **Dockerfile** file will certainly be simpler. However, before
    generating the image, it’s necessary to execute the **docker build** and **docker
    publish** commands so that we can generate the application package that will be
    copied to the image.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，**Dockerfile**文件将肯定更简单。然而，在生成图像之前，必须执行**docker build**和**docker publish**命令，以便我们可以生成将要复制到图像中的应用程序包。
- en: Now that we understand the principles of generating a **Dockerfile** file, it’s
    time to generate an image.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了生成**Dockerfile**文件的原则，是时候生成一个图像了。
- en: Generating a container image
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成容器图像
- en: To generate a Docker image, you need to run the **docker build** command. This
    command will execute the code described in the **Dockerfile** file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成Docker图像，需要运行**docker build**命令。此命令将执行**Dockerfile**文件中描述的代码。
- en: 'To do this, open your terminal and, in the **UrlShortener** application directory,
    execute the following command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请打开您的终端，在**UrlShortener**应用程序目录中，执行以下命令：
- en: '[PRE18]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding command compiles the image, which will be tagged, using the **-t**
    parameter, with the name **urlshortener:1.0** . The image tag works as the name
    of the image to be generated as is in **<** **name_lower_case>[:<version>]** form.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令使用**-t**参数编译图像，并将其标记为**urlshortener:1.0**。图像标签作为要生成的图像的名称，其形式为**<name_lower_case>[:<version>]**。
- en: The version is optional. If it isn’t entered, Docker will use the latest version.
    However, it’s good practice to define a version for the image.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 版本是可选的。如果没有输入，Docker将使用最新版本。然而，为图像定义一个版本是良好的实践。
- en: After defining the image tag, the context where the compilation process will
    be executed is informed of this. The context is defined by the **.** parameter,
    which indicates the local directory that contains the **Dockerfile** file. It’s
    important to keep in mind that the **build** command needs to know where the **Dockerfile**
    file is located so that it can be executed correctly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 定义图像标签后，编译过程将要执行的环境被告知这一点。环境由**.**参数定义，该参数指示包含**Dockerfile**文件的本地目录。重要的是要记住，**build**命令需要知道**Dockerfile**文件的位置，以便正确执行。
- en: 'Once the image generation process has run, run the following command to see
    the list of images on your computer:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像生成过程运行完毕，运行以下命令以查看您计算机上的图像列表：
- en: '[PRE19]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After executing the preceding command, you’ll be able to view the list of images
    in your local container registry, as shown in *Figure 10* *.17* :'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前一个命令后，您将能够查看本地容器注册库中的图像列表，如图*图10.17*所示：
- en: '![Figure 10.17 – List of Docker images in the local container registry](img/B21788_10_17.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 本地容器注册库中的Docker图像列表](img/B21788_10_17.jpg)'
- en: Figure 10.17 – List of Docker images in the local container registry
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 本地容器注册库中的Docker图像列表
- en: 'In this example, there are three images:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，有三个图像：
- en: '**localhost/urlshortener:1.0** : This is the previously generated image that
    contains the application. The **localhost/** prefix before the image’s name represents
    the owner of the image – in this case, the local registry.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**localhost/urlshortener:1.0**：这是之前生成的包含应用程序的图像。图像名称前的**localhost/**前缀表示图像的所有者——在本例中是本地注册库。'
- en: '**mcr.microsoft.com/dotnet/sdk:8.0** and **mcr.microsoft.com/dotnet/aspnet:8.0**
    : These images represent the .NET SDK and .NET Runtime for compiling and running
    the application in a container, respectively. These images are automatically downloaded
    from Docker Hub. Note the **mcr.microsoft.com/dotnet** prefix, which refers to
    the owner of the images.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mcr.microsoft.com/dotnet/sdk:8.0**和**mcr.microsoft.com/dotnet/aspnet:8.0**：这些图像分别代表用于在容器中编译和运行应用程序的.NET
    SDK和.NET运行时。这些图像自动从Docker Hub下载。注意**mcr.microsoft.com/dotnet**前缀，它指的是图像的所有者。'
- en: Additionally, *Figure 10* *.17* shows the size of the images in MB. The application
    image is smaller than the other two. Containers must be optimized as they could
    affect the performance and startup of the application.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*图 10.17* 还显示了图像的大小（以 MB 为单位）。应用程序镜像比其他两个都要小。容器必须进行优化，因为它们可能会影响应用程序的性能和启动。
- en: Container images should be considered immutable – that is, each version is unique.
    This means that if there’s any change in the application, we must generate a new
    image with a different tag. It’s a best practice to follow this convention as
    it allows you to have control over the containers running on a server.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像应被视为不可变的——也就是说，每个版本都是唯一的。这意味着如果应用程序有任何更改，我们必须使用不同的标签生成一个新的镜像。遵循此约定是一种最佳实践，因为它允许您控制服务器上运行的容器。
- en: With the image generated, it’s time to run a container and test its operation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 生成图像后，是时候运行一个容器并测试其操作了。
- en: Running a Docker container
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Docker 容器
- en: 'To run the Docker container from the previously generated image, run the following
    command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要从先前生成的图像运行 Docker 容器，请运行以下命令：
- en: '[PRE20]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s take a closer look at this command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个命令：
- en: It runs a new container from the **localhost/urlshortener:1.0** image.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从 **localhost/urlshortener:1.0** 镜像运行一个新的容器。
- en: It runs the container in detached mode ( **-d** ), allowing it to run in the
    background.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以分离模式（**-d**）运行容器，允许它在后台运行。
- en: It maps port **8899** on the host to port **8080** inside the container ( **-p
    8899:8080** ). This makes the application run on port **8080** inside the container
    that’s accessible via port **8899** on the host machine.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将主机上的端口 **8899** 映射到容器内的端口 **8080**（**-p 8899:8080**）。这使得应用程序在容器内运行在端口 **8080**
    上，可以通过主机上的端口 **8899** 访问。
- en: 'The output of the successfully executed command will be a key that represents
    the container’s ID. To check whether the container is running, run the following
    command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行命令的输出将是一个代表容器 ID 的密钥。要检查容器是否正在运行，请运行以下命令：
- en: '[PRE21]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An output similar to the one shown in *Figure 10* *.18* will be displayed:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 将会显示类似于 *图 10.18* 的输出：
- en: '![Figure 10.18 – Running containers](img/B21788_10_18.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 运行中的容器](img/B21788_10_18.jpg)'
- en: Figure 10.18 – Running containers
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 运行中的容器
- en: Now, open a browser of your choice and go to [**http://localhost:8899**](http://localhost:8899)
    .
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您选择的浏览器并访问 [**http://localhost:8899**](http://localhost:8899) 。
- en: Connection string
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'If the application’s connection string has been configured for the database
    in Azure and you get a connection error when you access the application through
    the container, make sure you add your IP address, as presented in the *Configuring
    Azure SQL Server* section. You can also change the connection string by using
    environment variables in conjunction with the **docker run** command, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序的连接字符串已配置为 Azure 中的数据库，并且您通过容器访问应用程序时遇到连接错误，请确保您添加了您的 IP 地址，如 *配置 Azure
    SQL Server* 部分所示。您还可以通过使用与 **docker run** 命令结合的环境变量来更改连接字符串，如下所示：
- en: '**docker run -d -p 8899:8080 -e ConnectionStrings__DefaultConnection="Server=.;Database=UrlShortenerDB;user
    id=sa;** **password=P4sword123;Encrypt=False;" localhost/urlshortener:1.0**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker run -d -p 8899:8080 -e ConnectionStrings__DefaultConnection="Server=.;Database=UrlShortenerDB;user
    id=sa;** **password=P4sword123;Encrypt=False;" localhost/urlshortener:1.0**'
- en: The preceding command contains the **-e <** **EnvironmentVariable>=<value>**
    parameter.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令包含 **-e <** **环境变量>=<值>** 参数。
- en: 'We can run the **docker run** command several times for the same image while
    changing the host port on which the container will run. For example, the following
    commands will run two new containers of the same application on ports **9900**
    and **9910** :'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为相同的镜像多次运行 **docker run** 命令，同时更改容器将在其上运行的宿主端口。例如，以下命令将在端口 **9900** 和 **9910**
    上运行相同应用程序的两个新容器：
- en: '[PRE22]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Currently, three different containers contain the same application running in
    your local environment.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在您的本地环境中，有三个不同的容器运行着相同的应用程序。
- en: 'To finish running the containers, execute the following command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成运行容器，请执行以下命令：
- en: '[PRE23]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can obtain the container ID from the list of running containers by running
    the **docker** **ps** command.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 **docker ps** 命令从正在运行的容器列表中获取容器 ID。
- en: Understanding Docker principles and how to package your ASP.NET Core 9 application
    in a container is very important for the modern software development model. Containers
    offer consistency, portability, and efficiency, making them ideal for cloud-native
    applications.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Docker原理以及如何将你的ASP.NET Core 9应用程序打包到容器中对于现代软件开发模型非常重要。容器提供了一致性、可移植性和效率，使它们非常适合云原生应用程序。
- en: As we’ve learned, the use of containers is related to components such as images,
    which are generated according to the runtime and the published application. Later,
    the image that’s been used is made available through a public or private container
    registry. Finally, we can run different instances of an application that’s been
    published in a container registry through the use of an image, thus generating
    an executed application called a container.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，容器使用与图像等组件有关，这些图像是根据运行时和发布的应用程序生成的。后来，所使用的图像通过公共或私有容器注册库提供。最后，我们可以通过使用图像来运行已发布在容器注册库中的应用程序的不同实例，从而生成一个称为容器的执行应用程序。
- en: Next, we’ll learn how to automate the process of publishing applications in
    a cloud environment.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何自动化在云环境中发布应用程序的过程。
- en: Understanding the DevOps approach with CI/CD
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CI/CD的DevOps方法
- en: It’s common to talk about the DevOps culture in depth. Despite the term being
    a combination of two specific areas – that is, **development** ( **Dev** ) and
    **operations** ( **Ops** ) – this approach goes far beyond these two teams.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 深入讨论DevOps文化是很常见的。尽管这个术语是两个特定领域的组合——即**开发**（**Dev**）和**运维**（**Ops**）——但这种方法远远超出了这两个团队。
- en: 'The DevOps culture connects processes, people, and tools, all of which work
    together to generate value and provide continuous learning in the face of constant
    market needs:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps文化将流程、人员和工具连接起来，所有这些共同工作以生成价值，并在面对不断的市场需求时提供持续学习：
- en: '![Figure 10.19 – The DevOps culture cycle](img/B21788_10_19.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19 – DevOps文化周期](img/B21788_10_19.jpg)'
- en: Figure 10.19 – The DevOps culture cycle
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 – DevOps文化周期
- en: '*Figure 10* *.19* represents this continuous flow of collaboration in different
    aspects involving the DevOps culture.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.19* 表示了涉及DevOps文化的不同方面的这种持续协作流程。'
- en: Among the practices suggested in the DevOps culture, we have the CI/CD process,
    making development teams agile, eliminating dependencies, minimizing errors, and
    enabling continuous evolution and learning in teams.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps文化中建议的实践中，我们有CI/CD流程，使开发团队变得敏捷，消除依赖，最小化错误，并使团队能够持续进化和学习。
- en: CI and CD processes are commonly called pipelines because they represent a set
    of sequential instructions that allow new pipes or tasks to be added and reorganized
    in this flow.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: CI和CD流程通常被称为管道，因为它们代表了一系列顺序指令，允许在这个流程中添加和重新组织新的管道或任务。
- en: Before we look at the pipeline development model, let’s understand the fundamentals
    of CI and CD.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看管道开发模型之前，让我们了解CI和CD的基本原理。
- en: CI
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI
- en: CI is a development practice where developers regularly merge their code changes
    into a central repository, after which there are automated builds and testing.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: CI是一种开发实践，开发人员定期将他们的代码更改合并到一个中央存储库中，之后会有自动构建和测试。
- en: Development teams are distributed remotely and require a central repository,
    usually based on Git. When new code is developed and changed, it’s synchronized
    or integrated into the local repository.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队是远程分布的，需要一个中央存储库，通常基于Git。当开发新的代码并更改时，它会同步或集成到本地存储库中。
- en: This process occurs asynchronously – that is, each developer synchronizes their
    code version at a different time to other developers. Then, the CI pipeline is
    executed, where the main objective is to detect integration problems in advance
    and then frequently integrate code changes and check them through automated tests.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程是异步的——也就是说，每个开发人员在不同时间将他们的代码版本与其他开发人员同步。然后，执行CI管道，其主要目标是提前检测集成问题，然后频繁地集成代码更改并通过自动化测试进行检查。
- en: '*Figure 10* *.20* shows a basic CI pipeline scenario:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.20* 展示了一个基本的CI管道场景：'
- en: '![Figure 10.20 – The CI pipeline flow](img/B21788_10_20.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – CI管道流程](img/B21788_10_20.jpg)'
- en: Figure 10.20 – The CI pipeline flow
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – CI管道流程
- en: 'As we can see, *Figure 10* *.20* presents a flow that we’re already used to
    executing manually. Automating these processes brings several benefits:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，*图10.20* 展示了我们已经习惯手动执行的流程。自动化这些过程带来了许多好处：
- en: '**Early error detection** : By integrating code changes frequently, CI helps
    us identify and resolve errors and integration issues early in the development
    process.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期错误检测**：通过频繁集成代码更改，CI帮助我们尽早识别和解决错误和集成问题。'
- en: '**Improved code quality** : Automated tests are run on each integration, ensuring
    that code changes don’t break existing functionality and maintain code quality.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码质量**：在每次集成时运行自动化测试，确保代码更改不会破坏现有功能并保持代码质量。'
- en: '**Faster feedback cycle** : Developers receive immediate feedback on their
    code changes, allowing them to fix issues immediately and iterate quickly.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的反馈周期**：开发者可以立即收到关于他们代码更改的反馈，使他们能够立即修复问题并快速迭代。'
- en: '**Improved collaboration** : CI promotes collaboration between team members
    by integrating code changes from different developers into a shared repository,
    ensuring everyone is working with the latest code base.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的协作**：CI通过将不同开发者的代码更改集成到共享仓库中，促进了团队成员之间的协作，确保每个人都在使用最新的代码库。'
- en: Another great benefit of the CI process is the practice of performing a code
    review, which allows team members to analyze the code to be integrated and carry
    out reviews of good practices and whether unit tests have been written, for example.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）过程的另一个巨大好处是执行代码审查的实践，这允许团队成员分析要集成的代码，并执行良好实践的审查以及是否编写了单元测试，例如。
- en: The code review approach generates constant learning. However, despite being
    done manually, it’s extremely powerful for the evolution of teams and has support
    from CI so that no revisions are made to code that presents compilation errors
    or test failures. It’s a constant flow of learning, allowing teams to be proactive
    before they publish any version of an application to production environments.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查方法不断产生学习机会。然而，尽管它是手动完成的，但对于团队的演变来说却极为强大，并且得到了持续集成（CI）的支持，以确保不会对出现编译错误或测试失败的代码进行任何修订。这是一个持续的学习流程，使团队能够在将任何应用程序版本发布到生产环境之前采取主动。
- en: Code review
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查
- en: 'A code review is a human review process in which one or more developers review
    code written by another developer. To learn more about this approach, take a look
    at the following GitHub article: [https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews](https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews)
    .'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查是一个人工审查过程，其中一个或多个开发者审查另一个开发者编写的代码。要了解更多关于这种方法的信息，请查看以下GitHub文章：[https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews](https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews)。
- en: The CI pipeline is of great importance in the development flow as its main objective
    is to prepare an application package that follows the quality requirements defined
    by the development and business teams. As output, it delivers this package to
    the CD process, which executes the procedures for implementing this in one or
    more environments.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: CI流水线在开发流程中非常重要，因为其主要目标是准备一个符合开发和业务团队定义的质量要求的应用程序包。作为输出，它将此包交付给CD过程，该过程执行在一个或多个环境中实施此包的程序。
- en: CD
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD
- en: CD is the next step after CI and automates the process of deploying applications
    to production environments.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: CD是CI之后的下一步，它自动化了将应用程序部署到生产环境的过程。
- en: The CD pipeline simulates what happens in CI, making it possible to add automated
    tests, among other processes, before the automatic deployment procedures are executed
    for new versions of applications in different environments, such as development,
    testing, and production.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: CD流水线模拟了CI中发生的情况，使得在为不同环境（如开发、测试和生产）的新版本应用程序执行自动部署程序之前，可以添加自动化测试等流程。
- en: '*Figure 10* *.21* shows the CD pipeline. It’s very similar to the one for CI,
    but it consists of different tasks and processes:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10* *.21* 显示了CD流水线。它与CI的流水线非常相似，但它由不同的任务和流程组成：'
- en: '![Figure 10.21 – The CD pipeline flow](img/B21788_10_21.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图10.21 – CD流水线流程](img/B21788_10_21.jpg)'
- en: Figure 10.21 – The CD pipeline flow
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 – CD流水线流程
- en: While the CI pipeline generates a valid package based on the quality flow of
    the development process, the CD pipeline’s main objective is to obtain the package
    that’s been generated through the CI pipeline and distribute it in an on-premises
    or cloud environment.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CI流水线基于开发过程的质量流程生成有效的包，但CD流水线的主要目标是获取通过CI流水线生成的包，并在本地或云环境中进行分发。
- en: 'The CD pipeline brings the following benefits:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: CD流水线带来了以下好处：
- en: '**Accelerated delivery** : CD enables faster delivery of new features and bug
    fixes, reducing time to market and improving customer satisfaction.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速交付**：CD能够加快新功能和错误修复的交付速度，缩短上市时间并提高客户满意度。'
- en: '**Reduced deployment risk** : By deploying small, incremental changes, CD minimizes
    the risk associated with large, infrequent deployments.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低部署风险**：通过部署小的、增量更改，CD最小化了与大型、不频繁部署相关的风险。'
- en: '**Consistent deployments** : Automated deployment processes ensure deployments
    are consistent and repeatable, reducing human error.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的部署**：自动化部署过程确保部署是一致和可重复的，减少了人为错误。'
- en: '**Improved reliability** : Continuous monitoring and automated rollback mechanisms
    increase the reliability of the deployment process.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可靠性**：持续监控和自动回滚机制提高了部署过程的可靠性。'
- en: Although the CD pipeline is an automated process, which means it’s capable of
    publishing new versions of an application in different environments automatically,
    it’s possible to establish approval flows where those responsible for each environment
    can choose whether they approve a deployment. The act of approval triggers the
    automatic deployment flow or cancels it, depending on the need.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CD管道是一个自动化流程，这意味着它能够自动在不同环境中发布应用程序的新版本，但可以建立审批流程，让每个环境的负责人可以选择是否批准部署。审批行为会根据需要触发自动部署流程或取消它。
- en: The approvals gate approach brings compliance benefits and allows teams to have
    full control of the deployment flow in certain environments.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 批准门控方法带来了合规性好处，并允许团队在特定环境中完全控制部署流程。
- en: Review deployments
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 审查部署
- en: Depending on the delivery flow of each organization, there’s a need to review
    deployments, especially in production environments. This approach generates an
    automated communication process between the CD pipeline and reviewers. Tools such
    as GitHub, Azure DevOps, and GitLab, among others, have mechanisms that allow
    you to configure this approval flow. You can learn more about the deployment review
    process through GitHub Actions at [https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments)
    .
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 根据每个组织的交付流程，需要审查部署，尤其是在生产环境中。这种方法在CD管道和审查者之间生成一个自动的通信过程。GitHub、Azure DevOps、GitLab等工具都有允许你配置此审批流程的机制。你可以在GitHub
    Actions中了解更多关于部署审查过程的信息，请参阅[https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments)。
- en: CI and CD are great approaches to automating processes so that our applications
    can be delivered to different environments constantly and with quality in mind.
    This is something that allows us to deliver new versions of applications several
    times on the same day, at the same time, and it helps us quickly provide corrections
    and rollbacks in those environments, if necessary.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: CI和CD是自动化流程的绝佳方法，以确保我们的应用程序可以持续且高质量地交付到不同的环境。这是允许我们在同一天多次交付应用程序版本的事情，同时它还帮助我们快速在这些环境中提供纠正和回滚，如果需要的话。
- en: In the next section, we’ll implement a CI/CD flow using GitHub Actions and learn
    how to automatically publish a Docker image in a container registry.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用GitHub Actions实现CI/CD流程，并学习如何自动在容器注册库中发布Docker镜像。
- en: Automating with GitHub Actions
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GitHub Actions进行自动化
- en: To demonstrate CI/CD in action, we’ll use GitHub Actions to automate the process
    of generating and publishing a Docker image from the **UrlShortener** application.
    Make sure you’ve installed everything mentioned in the *Technical requirements*
    section so that you can take advantage of the steps described here.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示CI/CD的实际应用，我们将使用GitHub Actions来自动化从**UrlShortener**应用程序生成和发布Docker镜像的过程。确保你已经安装了*技术要求*部分中提到的所有内容，以便你可以利用这里描述的步骤。
- en: 'To automate the process of including CI/CD, we’ll have to do the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化包含CI/CD的过程，我们需要做以下几步：
- en: Configure secrets in the GitHub repository.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub仓库中配置密钥。
- en: Create GitHub Actions.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建GitHub Actions。
- en: Activate GitHub Actions with each push event that’s sent to the repository.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次向仓库发送的推送事件都激活GitHub Actions。
- en: Build a Docker image.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Docker镜像。
- en: Publish the created image to Docker Hub.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的镜像发布到Docker Hub。
- en: Run the previously created Docker image on the local machine.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地机器上运行之前创建的Docker镜像。
- en: Before you start automating, you must understand the basics of GitHub Actions.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始自动化之前，你必须了解GitHub Actions的基本知识。
- en: Understanding the fundamentals of GitHub Actions
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 GitHub Actions 的基础知识
- en: GitHub Actions is an automation tool that’s built into GitHub that lets you
    create, manage, and run workflows directly in your repository.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是一个内置在 GitHub 中的自动化工具，它允许你直接在你的仓库中创建、管理和运行工作流程。
- en: Actions, as it’s commonly known, can be triggered by various events, such as
    code submission, pull request creation, or time triggers.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如同通常所知，动作可以通过各种事件触发，例如代码提交、拉取请求创建或时间触发器。
- en: 'GitHub Actions can be created using the **YML/YAML** file structure located
    in the **.github/workflows** directory of this book’s GitHub repository. The basic
    structure of a workflow is represented at a high level in *Figure 10* *.22* :'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用位于本书 GitHub 仓库 **.github/workflows** 目录中的 **YML/YAML** 文件结构创建 GitHub Actions。工作流程的基本结构在
    *图 10.22* 中以高层次表示：
- en: '![Figure 10.22 – The basic structure of GitHub Actions](img/B21788_10_22.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – GitHub Actions 的基本结构](img/B21788_10_22.jpg)'
- en: Figure 10.22 – The basic structure of GitHub Actions
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – GitHub Actions 的基本结构
- en: YAML files
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件
- en: A **YAML Ain’t Markup Language** ( **YAML** ) file is a human-readable data
    standard that’s commonly used for configuration files and exchanging data between
    programming languages with different data structures. YAML files use indentation
    to denote structure, making them easy to read and write. It’s often used in scenarios
    where configuration needs to be human-readable and easily parsed by machines,
    such as in CI/CD pipelines, cloud provisioning files, and application configuration
    settings. In the context of GitHub Actions, YAML files define workflows that automate
    processes such as building, testing, and deploying applications. To learn more,
    visit [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)
    .
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **YAML Ain’t Markup Language** ( **YAML** ) 文件是一种人类可读的数据标准，通常用于配置文件和在不同数据结构之间交换编程语言的数据。YAML
    文件使用缩进来表示结构，这使得它们易于阅读和编写。它通常用于需要人类可读性和易于机器解析的场景，例如在 CI/CD 管道、云配置文件和应用程序配置设置中。在
    GitHub Actions 的上下文中，YAML 文件定义了自动化构建、测试和部署应用程序等流程的工作流程。要了解更多信息，请访问 [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)。
- en: '*Figure 10* *.22* shows the main components that are part of the structure
    of GitHub Actions. Let’s take a closer look:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.22* 显示了 GitHub Actions 结构中的一部分主要组件。让我们更仔细地看看：'
- en: '**workflow.yml** : A YAML file that defines the workflow.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**workflow.yml**：一个定义工作流程的 YAML 文件。'
- en: '**on** : This specifies the events that trigger the workflow. Examples include
    **push** , **pull_request** , and **schedule** .'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**on**：这指定了触发工作流程的事件。例如包括 **push**、**pull_request** 和 **schedule**。'
- en: '**jobs** : Defines a set of jobs to be executed within the workflow.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：定义了在工作流程中要执行的一组作业。'
- en: '**build job** : A job named **build** running on **ubuntu-latest** . Here,
    **ubuntu-latest** is a type of agent or machine that will execute all the steps
    of a job. This machine is made available by GitHub itself.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建作业**：一个名为 **build** 的作业，在 **ubuntu-latest** 上运行。在这里，**ubuntu-latest** 是一种代理或机器，它将执行作业的所有步骤。这台机器由
    GitHub 本身提供。'
- en: 'This flow contains a series of steps:'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此流程包含一系列步骤：
- en: '**Checkout code** : Uses the **actions/checkout@v2** action.'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检出代码**：使用 **actions/checkout@v2** 动作。'
- en: '**Set up .NET Core** : Uses the **actions/setup-dotnet@v2** action with .NET
    version **''8.0.x''** .'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置 .NET Core**：使用 **actions/setup-dotnet@v2** 动作，.NET 版本为 **''8.0.x''**。'
- en: '**Build project** : Runs the **dotnet** **build** command.'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建项目**：运行 **dotnet build** 命令。'
- en: '**Run tests** : Runs the **dotnet** **test** command.'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行测试**：运行 **dotnet test** 命令。'
- en: GitHub-hosted runners
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 主机运行器
- en: On GitHub, agents are called runners and are available for Windows, Linux, and
    macOS.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上，代理被称为运行器，并且适用于 Windows、Linux 和 macOS。
- en: Runners are a fundamental component for running GitHub Actions and are provisioned
    during a CI or CD pipeline.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器是运行 GitHub Actions 的基本组件，并在 CI 或 CD 管道中配置。
- en: To learn more about runners, visit [https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners)
    .
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于运行器的信息，请访问 [https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners)。
- en: With GitHub Actions, we have a multitude of possibilities for automating processes
    that aren’t restricted to CI/CD contexts.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitHub Actions，我们有多种自动化流程的可能性，这些流程不仅限于CI/CD上下文。
- en: Now that we know how GitHub Actions works, let’s start by configuring our repository
    and creating our first actions.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GitHub Actions的工作原理，让我们首先配置我们的仓库并创建我们的第一个操作。
- en: Preparing a GitHub repository
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备GitHub仓库
- en: 'To automate the process of creating and publishing a Docker image through GitHub
    Actions, it’s important to understand how the pipeline we’ll create works, as
    shown in *Figure 10* *.23* :'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过GitHub Actions自动化创建和发布Docker镜像的过程，了解我们将创建的管道如何工作是很重要的，如图10.23所示：
- en: '![Figure 10.23 – Example of the GitHub Actions flow integrated with Docker
    Hub](img/B21788_10_23.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![图10.23 – GitHub Actions与Docker Hub集成的示例](img/B21788_10_23.jpg)'
- en: Figure 10.23 – Example of the GitHub Actions flow integrated with Docker Hub
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23 – GitHub Actions与Docker Hub集成的示例
- en: Previously, we learned about the fundamentals of the container strategy when
    using Docker and used Docker’s build multi-stage approach to implement it.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，我们学习了使用Docker时的容器策略基础，并使用Docker的构建多阶段方法来实现它。
- en: This multi-stage approach has all the necessary steps to generate an application
    package and, in the end, generate an image that’s ready to be used.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多阶段方法包含了生成应用程序包所需的所有步骤，最终生成一个可以使用的镜像。
- en: As shown in *Figure 10* *.23* , during the pipeline flow, some calls to Docker
    Hub are necessary. This is the public container registry that we used when we
    packaged the **URLShortener** application. However, we can generate a local image
    without the need to communicate with Docker Hub.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如图10.23所示，在管道流程中，需要调用Docker Hub进行一些操作。这是我们打包**URLShortener**应用程序时使用的公共容器注册库。然而，我们可以在不需要与Docker
    Hub通信的情况下生成本地镜像。
- en: To be able to publish a Docker image to a public or private container registry,
    authentication must be performed.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够将Docker镜像发布到公共或私有容器注册库，必须执行身份验证。
- en: In the case of Docker Hub, this authentication takes place using a username
    and password. Since this information is sensitive, we shouldn’t add it directly
    to a GitHub Actions YAML file, especially if the repository is public.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Hub的情况下，这种身份验证是通过用户名和密码进行的。由于这些信息是敏感的，我们不应将其直接添加到GitHub Actions YAML文件中，尤其是如果仓库是公开的。
- en: 'The best practice is to manage these credentials securely using Secrets. So,
    follow these steps to add the necessary secrets:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用秘密安全地管理这些凭证。因此，按照以下步骤添加必要的秘密：
- en: Access your **ASP.NET-8.0-Core-Essentials** repository via your GitHub user.
    This should have been prepared as per the *Technical* *requirements* section.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过您的GitHub用户访问您的**ASP.NET-8.0-Core-Essentials**仓库。这应该按照**技术****要求**部分准备。
- en: Then, access the **Settings** tab.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，访问**设置**标签页。
- en: From the side menu, access **Secrets and variables** | **Actions** .
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从侧边菜单，访问**秘密和变量**|**操作**。
- en: In the center of the screen, click the **New repository** **secret** button.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕中央，点击**新建仓库****秘密**按钮。
- en: Set the **Name** field to **DOCKER_HUB_USERNAME** .
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**名称**字段设置为**DOCKER_HUB_USERNAME**。
- en: In the **Secret** field, add your Docker Hub user.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**秘密**字段中，添加您的Docker Hub用户。
- en: Click on the **Add** **Secret** button.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加****秘密**按钮。
- en: Again, click on the **New repository** **secret** button.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，点击**新建仓库****秘密**按钮。
- en: Set the **Name** field to **DOCKER_HUB_PASSWORD** .
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**名称**字段设置为**DOCKER_HUB_PASSWORD**。
- en: Set the **Secret** field with your password.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**秘密**字段设置为您的密码。
- en: Click on the **Add** **Secret** button.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加****秘密**按钮。
- en: Secrets will be accessed securely while we’re running GitHub Actions. Now, let’s
    create the CI/CD pipeline.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行GitHub Actions时，秘密将被安全访问。现在，让我们创建CI/CD管道。
- en: Creating the CI/CD pipeline
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建CI/CD管道
- en: So far, we’ve learned how to manage Docker Hub credentials securely, something
    we’ll need to do so that we can authenticate through the pipeline and submit the
    newly generated image.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何安全地管理Docker Hub凭证，这是我们将在管道中进行身份验证并提交新生成的镜像所必需的。
- en: 'Still in the GitHub repository, access the **Actions** tab. As shown in *Figure
    10* *.24* , there are several readymade pipeline templates that suit different
    types of applications and are a great starting point for creating a pipeline:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在GitHub仓库中，访问**操作**标签页。如图10.24所示，有几个现成的管道模板适用于不同类型的应用程序，是创建管道的一个很好的起点：
- en: '![Figure 10.24 – GitHub Actions templates screen](img/B21788_10_24.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![图10.24 – GitHub Actions模板屏幕](img/B21788_10_24.jpg)'
- en: Figure 10.24 – GitHub Actions templates screen
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24 – GitHub Actions模板屏幕
- en: For this example, we’ll click on the **set up a workflow yourself** link, as
    highlighted in *Figure 10* *.24* .
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将点击*图10.24*中突出显示的**设置自己的工作流程**链接。
- en: 'You’ll see an editor and a list of **Featured Actions** , as well as the file’s
    name, as shown in *Figure 10* *.25* :'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个编辑器、一个**特色动作**列表以及文件名，如*图10.25*所示：
- en: "![Figure 10.2\uFEFF5 – GitHub Actions editor](img/B21788_10_25.jpg)"
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2.5 – GitHub Actions编辑器](img/B21788_10_25.jpg)'
- en: Figure 10.25 – GitHub Actions editor
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25 – GitHub Actions编辑器
- en: '*Figure 10* *.25* shows three important areas of the GitHub Actions editor:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.25*显示了GitHub Actions编辑器的三个重要区域：'
- en: '**A** : This is where you can define the filename. Note the suggested directory
    structure. We’ll set the filename to **cicd-pipeline.yml** .'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**：这是您可以定义文件名的地方。注意建议的目录结构。我们将文件名设置为**cicd-pipeline.yml**。'
- en: '**B** : This is where we’ll add the pipeline code.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B**：这是我们添加管道代码的地方。'
- en: '**C** : The pipeline consists of tasks, called actions. These actions are abstractions
    for executing tasks related to a certain technology. The technical community shares
    different types of custom actions that we can use.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**：管道由称为动作的任务组成。这些动作是执行与特定技术相关的任务的抽象。技术社区共享不同类型的自定义动作，我们可以使用。'
- en: 'Add the following code to the pipeline editor:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到管道编辑器中：
- en: '[PRE24]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The hierarchical structure of YAML files is created using spaces. Therefore,
    nested elements define the hierarchy. If these spaces aren’t respected, the file
    won’t be valid. Let’s consider using two spaces for each item in the hierarchy,
    as shown in the following example:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件的层次结构是通过空格创建的。因此，嵌套元素定义了层次结构。如果不尊重这些空格，文件将无效。以下示例显示了在层次结构中的每个项目使用两个空格：
- en: '[PRE25]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s take a closer look at this pipeline code:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个管道代码：
- en: '**on** : This defines how the action will be executed. In this case, every
    time there is an update or push in the main branch, this action will be triggered,
    executing the CI pipeline.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**on**：这定义了动作的执行方式。在这种情况下，每当主分支有更新或推送时，此动作将被触发，执行CI管道。'
- en: '**Jobs** : Jobs are processes that are executed sequentially. There might be
    jobs for **build** , **test** , **generate-package** , and more. Using **Jobs**
    allows us to have well-defined steps and dependencies between steps, thus creating
    the pipeline flow.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：作业是按顺序执行的过程。可能有用于**构建**、**测试**、**生成包**等作业。使用**作业**允许我们拥有定义良好的步骤和步骤之间的依赖关系，从而创建管道流程。'
- en: '**build-and-deploy** : This is the definition for a job named **build-and-deloy**
    . The **name** parameter produces a more user-friendly description during pipeline
    execution, but the job’s name can be referenced in the pipeline flow.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**build-and-deploy**：这是名为**build-and-deploy**的作业的定义。**name**参数在管道执行期间产生一个更用户友好的描述，但可以在管道流程中引用作业的名称。'
- en: '**Steps** : Steps are the tasks or actions that are performed in each Job.
    For this example, only two tasks need to be performed.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：步骤是在每个作业中执行的任务或动作。对于这个例子，只需要执行两个任务。'
- en: '**uses: actions/checkout@v4.1.7** : This is a native GitHub action that aims
    to clone the repository. The **checkout** action is necessary since runners are
    created on demand and don’t have the application’s source code.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uses: actions/checkout@v4.1.7**：这是一个旨在克隆存储库的本地GitHub动作。由于运行器是按需创建的，并且没有应用程序的源代码，因此**checkout**动作是必要的。'
- en: '**name: Build and publish Docker image** : Here, we’re executing an inline
    action where we define a script to build and publish the Docker image.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name: Build and publish Docker image**：在这里，我们执行一个内联动作，其中定义了一个构建和发布Docker镜像的脚本。'
- en: '**docker build -t ${{ secrets.DOCKER_HUB_USERNAME }} /urlshortener:latest .**
    : This script builds the Docker image. Note the use of the secret containing the
    Docker Hub username. This is necessary so that we can tag the image with its owner
    – that is, the Docker Hub username. We’re using the **latest** label here to facilitate
    understanding.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker build -t ${{ secrets.DOCKER_HUB_USERNAME }} /urlshortener:latest .**：此脚本构建Docker镜像。注意使用包含Docker
    Hub用户名的秘密。这是必要的，以便我们可以用其所有者的标签标记镜像——即Docker Hub用户名。我们在这里使用**latest**标签以方便理解。'
- en: '**echo ${{ secrets.DOCKER_HUB_PASSWORD }} | docker login -u ${{ secrets.DOCKER_HUB_USERNAME
    }} --password-stdin** : This command is executed in a Linux bash shell, which
    allows us to combine commands and execute other commands by obtaining input and
    output from previously executed commands. In this case, we’re writing the secret
    that contains the Docker Hub user’s password and sending the output as a parameter
    to the **docker login** command. This way, the secret won’t be exposed in the
    pipeline execution log. The **docker login** command is required for publishing
    new versions of images.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**echo ${{ secrets.DOCKER_HUB_PASSWORD }} | docker login -u ${{ secrets.DOCKER_HUB_USERNAME
    }} --password-stdin**：此命令在Linux bash shell中执行，允许我们通过从先前执行的命令获取输入和输出来组合命令并执行其他命令。在这种情况下，我们正在写入包含Docker
    Hub用户密码的秘密，并将输出作为参数发送到**docker login**命令。这样，秘密就不会在管道执行日志中暴露。**docker login**命令是发布新版本镜像所必需的。'
- en: '**working-directory: ./Chapter-10/UrlShortener** : The directory containing
    the **Dockerfile** file.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**working-directory: ./Chapter-10/UrlShortener**：包含**Dockerfile**文件的目录。'
- en: '**docker push** : The **docker push** command submits the previously generated
    image to Docker Hub.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker push**：**docker push**命令将先前生成的镜像提交到Docker Hub。'
- en: With this, the pipeline has been configured and contains both the CI and CD
    pipelines, where a new version of the Docker image is published at the end of
    the pipeline. At this point, it’s time to run the created GitHub action.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，管道已经配置完毕，并包含CI和CD管道，在管道的末尾发布Docker镜像的新版本。此时，是时候运行创建的GitHub操作了。
- en: Running the CI/CD pipeline
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行CI/CD管道
- en: In the pipeline editor, click the **Commit Changes** button. You’ll be taken
    to a new page where you must click **Commit Changes** once more. This is necessary
    since we’re creating a new file in the repository.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道编辑器中，点击**提交更改**按钮。您将被带到新页面，在那里您必须再次点击**提交更改**。这是必要的，因为我们正在在存储库中创建一个新文件。
- en: When you commit these changes, the pipeline will be triggered automatically.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当您提交这些更改时，管道将自动触发。
- en: 'Click on the **Actions** tab; you’ll see the pipeline’s execution, as shown
    in *Figure 10* *.26* :'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**操作**选项卡；您将看到管道的执行，如图*图10* *.26* 所示：
- en: '![Figure 10.26 – Running the GitHub action](img/B21788_10_26.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![图10.26 – 运行GitHub操作](img/B21788_10_26.jpg)'
- en: Figure 10.26 – Running the GitHub action
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26 – 运行GitHub操作
- en: 'After running the pipeline, the new image will be generated in Docker Hub,
    as shown in *Figure 10* *.27* :'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 运行管道后，新镜像将在Docker Hub中生成，如图*图10* *.27* 所示：
- en: '![Figure 10.27 – Container image published on Docker Hub by GitHub Actions](img/B21788_10_27.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![图10.27 – GitHub Actions在Docker Hub上发布的容器镜像](img/B21788_10_27.jpg)'
- en: Figure 10.27 – Container image published on Docker Hub by GitHub Actions
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27 – GitHub Actions在Docker Hub上发布的容器镜像
- en: 'To test the new image on your local machine, run the following command:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地机器上测试新镜像，请运行以下命令：
- en: '[PRE26]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new image will be downloaded, which means your application can be run on
    your local machine at [http://localhost:7777](http://localhost:7777) .
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 新镜像将被下载，这意味着您可以在本地机器上运行应用程序，地址为[http://localhost:7777](http://localhost:7777)。
- en: As we’ve learned, GitHub Actions can automate tasks in environments for the
    purpose of CD. This brings agility and consistency and allows teams to act quickly
    in the face of the constant changes demanded by the market.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，GitHub Actions可以自动化CD环境中的任务。这带来了敏捷性和一致性，并允许团队在面对市场对持续变化的需求时迅速行动。
- en: At this point, any changes that are made to your repository and submitted to
    GitHub will automatically generate a new version of the container for your Docker
    Hub user.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，对您的存储库所做的任何更改并提交到GitHub都将自动为您的Docker Hub用户生成一个新的容器版本。
- en: GitHub Actions has several applications and, together with solutions developed
    in ASP.NET Core 9, it’s a powerful tool for creating high-quality applications.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions有多个应用，与ASP.NET Core 9中开发的解决方案一起，它是一个创建高质量应用程序的强大工具。
- en: In this section, we learned about the fundamentals of working in a continuous
    flow of value delivery. We’ll explore how to attain a cloud-native application
    development mindset in the next chapter.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了在持续的价值交付流程中工作的基础知识。我们将在下一章探讨如何获得云原生应用程序开发的心态。
- en: Summary
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to publish ASP.NET Core 9 applications and generate
    a publishing package using the **dotnet** CLI tool. Furthermore, we learned how
    to publish an application in an Azure cloud environment and explored the fundamentals
    of Docker’s container strategy. Using the knowledge we’d acquired, we were able
    to learn how value delivery flows through DevOps practices such as CI and CD and
    benefits from automated processes via GitHub Actions. All the knowledge we’ve
    acquired in this chapter forms the basis for the next chapter, where we’ll learn
    about cloud-native development with ASP.NET Core 9.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用**dotnet** CLI工具发布ASP.NET Core 9应用程序并生成发布包。此外，我们还学习了如何在Azure云环境中发布应用程序，并探讨了Docker容器策略的基础。利用我们所获得的知识，我们能够了解价值交付如何通过CI和CD等DevOps实践流动，并从GitHub
    Actions的自动化流程中受益。本章所获得的所有知识构成了下一章的基础，我们将学习如何使用ASP.NET Core 9进行云原生开发。
