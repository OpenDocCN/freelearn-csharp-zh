<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-79"><a id="_idTextAnchor078"/>4</h1>
<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Fortify Your Code With Structural Patterns</h1>
<p>Recently, my wife asked a question that should have been simple to answer: “What did you do for fun when you were a little boy, say 9 or 10 years old?” I had to think about it. When I was 9 or 10, computers in the home were not possible, unless you lived in a military bunker that had a steady high voltage continuous sine wave power feed. The bunker would also have needed several thousand square feet of raised flooring, industrial-grade air conditioning, and a steady supply of clean water to use for CPU cooling. This wasn’t a normal living environment for most of my friends when we were 9 or 10. The question was difficult because as soon as I turned 12, I got my first computer. It was the Radio Shack TRS-80, complete with a level 1 8-bit Z-80 processor, 4 K (as in 4,000 bytes – just bytes - not Kilo, Mega, nor Giga) of memory, a monochrome monitor with a resolution of 128 by 48 very blocky pixels, and a cassette tape deck for loading and storing programs and data. The new computer occupied my every waking moment and since then, I’ve devoted probably far more of my life to screen time than I would care to admit. However, the question was: what did I do for fun before my computer? After a minute of thinking, I remembered that I built model rockets.</p>
<p>Just up the street from the house where I grew up was a hobby shop that sold model rocket kits along with engines and launchers. On Saturday mornings, I’d paw through mom’s purse, scrape together 5 USD, and walk to the shop to grab a kit. In the beginning, they were simple “level 1” kits that you could assemble and launch in a few hours. As I grew more adept, the models became more complicated with elements such as parachutes that deployed when the rocket had spent its fuel and reached its apogee. One rocket even had a single-shot camera that would take an aerial picture on its way back to Earth. The fancy kits had rockets that resembled spaceships from the Star Wars movie (there was only one back then) and Battlestar Galactica.</p>
<p>The rockets generally had a similar structure. However, as they became more sophisticated, more instructions were required to assemble them correctly and launch them safely. This reminds me of our next collection of patterns. </p>
<p>Structural patterns are designed to help you assemble objects into larger, more complex structures, thus avoiding the stovepipe monolithic structure that we’ve come to abhor. Structural patterns are to larger systems what creation patterns are to individual object instances. Structural patterns help us maintain flexibility and efficiency. There are quite a few documented structural patterns, but this chapter focuses on four of the most important patterns:</p>
<ul>
<li><strong class="bold">The Decorator pattern</strong></li>
<li><strong class="bold">The Façade pattern</strong></li>
<li><strong class="bold">The Composite pattern</strong></li>
<li><strong class="bold">The Bridge pattern</strong></li>
</ul>
<p>As in earlier chapters, these structural patterns will be demonstrated within the context of simple command-line programs. This will limit the amount of noise you would encounter with more complex, though probably more interesting, desktop, web, or gaming projects.</p>
<p>This chapter assumes <a id="_idIndexMarker252"/>you understand the basics of the <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>). All patterns are diagrammed using UML class diagrams throughout the book.  If UML is a new concept for you, check out <a href="B18605_Appendix_2.xhtml#_idTextAnchor204"><em class="italic">Appendix 2</em></a> of this book.  You don’t need to understand all of UML’s 14 diagram types. I only use class diagrams because that is all we need for our pattern work.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Technical requirements</h1>
<p>Throughout the book, I assume you know how to create new C# projects in your favorite <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>). I do not spend any time on the mechanics of setting up and running projects in this chapter. However, if you need a tutorial on IDEs or how to set up a project, check out <a href="B18605_Appendix_1.xhtml#_idTextAnchor178"><em class="italic">Appendix 1</em></a> of this book. Should you decide to code along with me, you’ll need the following:</p>
<ul>
<li>A computer running the Windows operating system. I’m using Windows 10. Since the projects are simple command-line projects, I’m pretty sure everything here would also work on a Mac or Linux, but I haven’t tested the projects on those operating systems.</li>
<li>A supported IDE such as Visual Studio, JetBrains Rider, or Visual Studio Code with C# extensions. I’m using Rider 2021.3.3.</li>
<li>Some version of the .NET SDK. Again, the projects are simple enough that our code shouldn’t be reliant on any particular version. I am using the .NET Core 6 SDK.</li>
</ul>
<p>If you’d like the code, you can find the completed project files for this chapter on GitHub at <a href="https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-4">https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-4</a>.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>B2B (back to bicycles)</h1>
<p>In our last episode, sisters Kitty and Phoebe had decided to open their own bicycle factory: Bumble Bikes. They intend to leverage Kitty’s expertise and design the most innovative bicycles on the road. Phoebe is capitalizing on her own engineering skills by designing and building robotics. Although neither sister is a professionally trained software developer, their father, a retired time-traveling software engineer, had taught the girls to code at a young age. The sisters know their way around an IDE, but they are only just learning about patterns. Therefore, the coding task at hand is to write the robotic control software that will run an automated factory.</p>
<p>The robotic manufacturing systems take<a id="_idIndexMarker253"/> instances of <code>Bicycle</code> classes and translate those into physical bicycles. The girls have mastered Creational patterns and they have settled on using<a id="_idIndexMarker254"/> the Builder pattern. The Builder pattern will be used to create any type of bicycle component needed and assemble those components into a finished bicycle.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>The Decorator pattern</h1>
<p>It was a<a id="_idIndexMarker255"/> hectic Monday morning for Kitty and Phoebe. Over the weekend, Kitty had ridden a prototype mountain bike around some of the trails near her home in the rocky desert of West Texas. She wanted a challenging test, so she chose Black Gap Road in Big Bend, a US national park. Big Bend derives its name from a large bend in the Rio Grande river, which forms the park’s border, as well as the United States’ southern border with Mexico. Black Gap Road is well known as a challenging trail. It has washouts, shallow creek crossings, and an actual gap (after which the road is named). The gap consists of a narrow passage between two large hills formed from volcanic rock. In the middle of the gap is a ledge that drops about 3 feet (about 1 meter) into the next section. Kitty had driven over the ledge in her Jeep many times, but never on a bike. She misjudged the drop and wound up flat on her back. After catching her breath, she got back on her bicycle and completed the trail. Phoebe was waiting at the trailhead for Kitty to pick her up with the Jeep.</p>
<p>On Monday morning, their <a id="_idIndexMarker256"/>phones started ringing. Phoebe spent almost an hour on the phone speaking with a raw material supplier. Based on the amount of material the girls were projecting, the supplier informed them they would need to set up an account on the supplier’s extranet, which is a private network available to larger customers. Bumble Bikes could get favorable pricing on raw materials. However, to take advantage of the pricing, Bumble Bikes had to commit to creating an interface between their robotic manufacturing system and the supplier’s inventory control system. Phoebe saw this as a positive because it meant that in the short term, she could leverage the inventory control system of her supplier, rather than having to create this system herself. The only downside was that Phoebe would need to modify her software, in particular the <code>Bicycle</code> class, to provide notifications to the supplier’s API. The <code>Bicycle</code> class <a id="_idIndexMarker257"/>had been internally released and was already in use. Cracking open the class to add the notifiers required by the supplier would force her to violate the open-closed principle that states: you should never modify code that is in production by changing the class. Instead, she should find a way to extend the class.</p>
<p>Meanwhile, Kitty was on her phone talking to the president of a company that owns a large number of bicycle dealerships across the United States. The company wants to become the exclusive dealer for Bumble Bikes in the US. The sisters had envisioned selling directly to customers as well as forming agreements with small local bicycle shops. They were surprised a big chain of stores would be interested in their nascent product line. After a long discussion with the president, Kitty learned one of the requirements for doing business with the dealerships was that each bicycle ordered would need an owner’s manual and would have to be printed with each dealership’s details scattered throughout the manual. A large-scale printing system would be provided by the company that owned the dealerships, so the girls wouldn’t have to come up with the capital for any equipment. </p>
<p>As fate would have it, the two hung up from their respective calls at the exact same time.</p>
<p><em class="italic">“You won’t believe this!”</em> Phoebe exclaimed.</p>
<p><em class="italic">“No, you won’t believe this!”</em> Kitty countered.</p>
<p>The two <a id="_idIndexMarker258"/>were excited as they discussed what had transpired. On Friday, they were a small bicycle start-up. The next Monday morning, they were positioned to be a serious competitor in the US bicycle market. Their dreams were coming true more quickly than they could have imagined. All they had to do was make a few modifications to their code.</p>
<p><em class="italic">“It’s simple!”</em> said Phoebe. <em class="italic">“We can just change the </em><em class="italic">Bicycle class and add the new properties and methods to meet our new requirements.”</em></p>
<p><em class="italic">“Not so fast,” </em>replied Kitty, and then she continued, <em class="italic">“The Bicycle classes are already in production. Changing</em><em class="italic"><a id="_idIndexMarker259"/></em><em class="italic"> them conflicts with the open-closed principle. Besides, not every bicycle object needs the new manual printing behavior. If we force the behavior on every subclass, we’re violating the interface segregation principle. We’d be violating two SOLID principles!”</em></p>
<p><em class="italic">“Oh, yeah,”</em> Phoebe said dejectedly. The two did some research and came across an idea that seemed sound. If they could create a class that wrapped or decorated the <code>Bicycle</code> class, they could create an extended class with new behaviors without breaking any of their existing implementations.</p>
<p>The Decorator pattern allows you to add properties and methods to a class without touching the original class, while still honoring any concrete implementations. You can see a generic drawing for the Decorator pattern in <em class="italic">Figure 4.1</em>:</p>
<div><div><img alt="Figure 4.1: The Decorator pattern. " height="935" src="img/B18605_Figure_4.1.jpg" width="1339"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: The Decorator pattern.</p>
<p>The parts of the pattern are <a id="_idIndexMarker260"/>categorized and explained here:</p>
<ol>
<li><code>IComponent</code> is the<a id="_idIndexMarker261"/> interface that defines the behavior we intend to wrap.</li>
<li><code>ConcreteComponent</code> is <a id="_idIndexMarker262"/>the original implementation. In the example presented thus far, this would be the API from the microcontroller vendor.</li>
<li><code>Decorator</code> is <a id="_idIndexMarker263"/>an abstract class that holds a reference to the concrete component via the interface.</li>
<li><code>ConcreteDecorator1</code> is a <a id="_idIndexMarker264"/>concrete class that extends the decorator class but adds some additional state definitions in the form of properties or fields.</li>
<li><code>ConcreteDecorator2</code> extends <a id="_idIndexMarker265"/>the decorator with additional operations.</li>
</ol>
<p>Kitty and Phoebe needed to add two different behaviors to their <code>Bicycle</code> class. One behavior would interface with the raw material supplier’s inventory control system. The other behavior would allow customized manuals to be printed at the factory and shipped with the bicycles to hundreds of dealerships throughout the US. Ideally, there should also be a way to add both behaviors to their <code>Bicycle</code> objects. In other words, they really wanted their decorators to stack. Stacking would allow them to potentially modify all their <code>Bicycle</code> classes to work with the raw material supplier’s system, but only deal with printing manuals for bikes sold through their dealership agreement. They should be able to add these behaviors or omit them as appropriate. Kitty headed to the whiteboard and<a id="_idIndexMarker266"/> ultimately settled on the structure shown in <em class="italic">Figure 4.2</em>:</p>
<div><div><img alt="Figure 4.2: Kitty’s implementation of the Decorator pattern. " height="978" src="img/B18605_Figure_4.21.jpg" width="1202"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: Kitty’s implementation of the Decorator pattern.</p>
<p>Let’s go over the<a id="_idIndexMarker267"/> classes in the diagram:</p>
<ol>
<li value="1">This is the interface we created in <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Getting Creative with Creational Patterns</em>, to represent our bicycles. Nothing has changed.</li>
<li>This is the abstract <code>Bicycle</code> class that implements the interface. Nothing has changed here either. In fact, neither the interface nor the abstract class has changed.</li>
<li>This is the abstract decorator class. Strictly speaking, you don’t necessarily need the word <em class="italic">decorator</em> in the class name. It’s here for the sake of clarity. Note that it uses composition to include a <code>protected</code> property, which contains a reference to a class that implements <code>IBicycle</code>. This object is set by the constructor while simultaneously implementing the <code>IBicycle</code> interface. At first glance, this doesn’t seem very DRY. As you’ll see, it will be. This will make sense when you see it in the code.</li>
<li>The Decorator classes. Here<a id="_idIndexMarker268"/> we have two: <code>DocumentedBicycle</code> and <code>NotifyingBicycle</code>. You can have as many as you need. You can stack them in your implementation, making it possible to have a <code>Bicycle</code> object with either a manual printer or a notifier, or both or neither. As Bumble Bikes expands and new business requirements are realized, we can potentially add and selectively stack more decorators without disturbing the original bicycle class itself.</li>
<li>The <code>IDocumentor</code> and <code>INotifier</code> interfaces define the decorating behaviors. Keeping them as interfaces prevents the decorator from being tightly coupled to concrete implementation.</li>
</ol>
<p>Decorators are used to add new properties and methods (or if you prefer, behaviors) to objects without modifying the original class. This allows you to honor the open-closed principle by cleverly extending the class. In this case, we are extending the class by wrapping it, rather than merely extending using inheritance.</p>
<p>There are three steps involved in <a id="_idIndexMarker269"/>decorating a class:</p>
<ol>
<li value="1">Create a class with a <code>private</code> member containing the class you want to decorate. In our case, we’ll be decorating the <code>AbstractBicycle</code> class. We need a class that contains a <code>private</code> property of the <code>IBicycle</code> type, and a constructor that allows us to set this property.</li>
<li>We need to implement all the properties and methods that are already in the <code>IBicycle</code> interface. When we implement the getter, setter, and regular methods for the decorator, we pass them through to the private instance. In effect, we’ve wrapped the class and the decorator performs exactly as in the original class.</li>
<li>We add the<a id="_idIndexMarker270"/> decorating properties and methods. If you intend to stack your decorators, it is important to have a common method that can link them together. We’ll be using the <code>Build()</code> method.</li>
</ol>
<p>Let’s look at Kitty’s code <a id="_idIndexMarker271"/>implementation. We’ll work from the bottom up, beginning with the two interfaces. She adds the <code>IDocumentor</code> interface. This allows dealership customized manuals to be printed when the bicycle is built:</p>
<pre class="source-code">public interface IDocumentor
{
  public void PrintManual();
}</pre>
<p>And then she adds the <code>INotifier</code> interface, which defines a function to communicate with the raw material supplier’s inventory control system:</p>
<pre class="source-code">public interface INotifier
{
  public void Notify();
}</pre>
<p>Next, let’s look at the <code>AbstractBicycleDecorator</code> class:</p>
<pre class="source-code">public abstract class AbstractBicycleDecorator : IBicycle 
{
  protected readonly IBicycle UndecoratedBicycle;</pre>
<p>The <code>protected</code> field to hold the original <code>IBicyle</code> object is crucial here. This is the original, undecorated object instance we’ll be decorating:</p>
<pre class="source-code">  protected AbstractBicycleDecorator(IBicycle bicycle)
  {
    UndecoratedBicycle = bicycle;
  }</pre>
<p>Next, we need to implement the <code>IBicycle</code> interface in the decorating class. We do this by passing everything through to the private undecorated object set by the constructor. Each call <a id="_idIndexMarker272"/>to the decorator class will be passed along to the undecorated instance:</p>
<pre class="source-code">  public string ModelName
  {
    get =&gt; UndecoratedBicycle.ModelName;
    set =&gt; UndecoratedBicycle.ModelName = value;
  }
  public int Year =&gt; UndecoratedBicycle.Year;
  public string SerialNumber =&gt; 
    UndecoratedBicycle.SerialNumber;
  public BicycleGeometries Geometry
  {
    get =&gt; UndecoratedBicycle.Geometry;
    set =&gt; UndecoratedBicycle.Geometry = value;
  }
  public BicyclePaintColors Color
  {
    get =&gt; UndecoratedBicycle.Color; 
    set =&gt; UndecoratedBicycle.Color = value; 
  }
  public SuspensionTypes Suspension { 
    get =&gt; UndecoratedBicycle.Suspension;
    set =&gt; UndecoratedBicycle.Suspension = value;
  }
  public ManufacturingStatus BuildStatus { 
    get =&gt; UndecoratedBicycle.BuildStatus;
    set =&gt; UndecoratedBicycle.BuildStatus = value;
  }</pre>
<p>Finally, we’ll implement the <code>Build()</code> function as abstract. In our original <code>Bicycle</code> class, which was also <a id="_idIndexMarker273"/>abstract, we implemented this method within the class. This is important because we’re actually making changes to the way the bicycles are built. As you’ll see, this method provides the means to stack our decorators:</p>
<pre class="source-code"> public abstract void Build();
}</pre>
<p>Let’s finally move into the two decorator classes. Kitty’s requirement to print manuals comes first because she’s the elder sister. At least, that’s what she’s always arguing. Here, the <code>DocumentedBicycle</code> class is extending <code>AbstractBicycleDecorator</code>:</p>
<pre class="source-code">public class DocumentedBicycle : AbstractBicycleDecorator
{</pre>
<p>There’s a <code>private</code> field to hold an <code>IDocumentor</code> object:</p>
<pre class="source-code">  private IDocumentor _documentor;
  public DocumentedBicycle(IBicycle bicycle, ManualPrinter 
                           printer) : base(bicycle)
  {
    _documentor = printer;
  }</pre>
<p>Here’s the actual decoration. The <code>Build()</code> method that exists on any object passed into the constructor is called. Then, the additional decorating behavior – in this case calling the <code>PrintManual()</code> method on the decoration – is called:</p>
<pre class="source-code">  public override void Build()
  {
    UndecoratedBicycle.Build();
    _documentor.PrintManual();
  }
}</pre>
<p>Phoebe’s requirement <a id="_idIndexMarker274"/>to notify the supplier’s inventory control system is implemented in its own decorator class:</p>
<pre class="source-code">public class NotifyingBicycle : AbstractBicycleDecorator
{
  private readonly INotifier _notifier;
  public NotifyingBicycle(IBicycle bicycle, INotifier 
                         notifier) : base(bicycle)
  {
    _notifier = notifier;
  }
  public override void Build()
  {
    UndecoratedBicycle.Build();
    _notifier.Notify();
  }
}</pre>
<p>The structure is identical, except, of course, for the decoration. This time, we pass in an object that meets the <code>INotifier</code> interface. We call the appropriate method when the <code>Build()</code> method of the original undecorated object is called.</p>
<p>Now, we need some<a id="_idIndexMarker275"/> concrete classes to satisfy the <code>INotifier</code> and <code>IDocumentor</code> interfaces. We’ll keep these simple. The <code>IDocumentor</code> interface is realized with a class called <code>ManualPrinter</code>:</p>
<pre class="source-code">public class ManualPrinter : IDocumentor
{
  public void PrintManual()
  {
    Console.ForegroundColor = ConsoleColor.Cyan;
    Console.WriteLine("The manual is printing!");
    Console.ResetColor();
  }
}</pre>
<p>The <code>PrintManual()</code> method is our added behavior. All this does for this example is print the line <code>The manual is printing!</code> Since there is a lot of text flying around in our console, I elected to make the decorator’s output cyan-colored to make it easy to spot. An implementation of the <code>INotifier</code> interface might look as follows:</p>
<pre class="source-code">public class MaterialsInventoryNotifier : INotifier
{
  public void Notify()
  {
    Console.ForegroundColor = ConsoleColor.Yellow;
    Console.WriteLine("The materials inventory control 
      system has been notified regarding the manufacture of 
        this bicycle.");
    Console.ResetColor();
  }
}</pre>
<p>Again, I added <a id="_idIndexMarker276"/>a splash of color to the output to make it easier to spot. This time, it is yellow. It has been a while since I’ve punned, so let’s wrap this up with some code that makes use of our decorator classes! </p>
<p>These are the contents of the <code>Program.cs</code> file in the sample project files:</p>
<pre class="source-code">var regularRoadBike = new RoadBike();  //no decorators.
regularRoadBike.Build();
Console.WriteLine("+++++++++++++++++++++++++++++++++++++");</pre>
<p>This is a normal, undecorated <code>RoadBike</code> object. BORING! We’ve seen that one before!  Let’s decorate it with the ability to print a custom manual:</p>
<pre class="source-code">var bikeManualPrinter = new ManualPrinter();
var documentedBike = new DocumentedBicycle(new RoadBike(), 
                                          bikeManualPrinter);
documentedBike.Build();</pre>
<p>This time, we instantiated <code>DocumentedBicycle</code>, which is our decorator. It needs an undecorated <code>RoadBike</code> and a <code>ManualPrinter</code>. When we call the build method, the <code>DocumentedBicycle</code> class calls the <code>Build()</code> method on the <code>RoadBike</code> class. Then, it calls its own <code>Build()</code> method that adds the new manual-printing behavior.</p>
<p>If you didn’t pick up on it, I’m adding some separators, so when we run the example, it will be easy to see each part of the run:</p>
<pre class="source-code">Console.WriteLine("+++++++++++++++++++++++++++++++++++++");</pre>
<p>That was a blast! Let’s do another one! This time, let’s try out the <code>NotifyingBicycle</code> decorator. It works the same way. First, we make an instance of <code>MaterialsInventoryNotifier</code>, which embodies the new behavior the decorator is adding to <code>RoadBike</code>:</p>
<pre class="source-code">var manufacturingInventoryNotifier = new MaterialsInventory
    Notifier();</pre>
<p>Next, we <a id="_idIndexMarker277"/>instantiate the <code>NotifyingBicycle</code> class, passing in a new <code>RoadBike</code> for decoration, along with <code>manufacturingInventoryNotifier</code>:</p>
<pre class="source-code">var notifierBike = new NotifyingBicycle(new RoadBike(), 
    manufacturingInventoryNotifier);</pre>
<p>Now, we call the decorator’s <code>Build()</code> method:</p>
<pre class="source-code">notifierBike.Build();
Console.WriteLine("+++++++++++++++++++++++++++++++++++++");</pre>
<p>Remember <a id="_idIndexMarker278"/>how this works: the decorator (<code>NotifyingBicycle</code>) has a <code>Build()</code> method. So does the <code>RoadBike</code> class it decorates. The decorator calls the <code>Build()</code> method on <code>RoadBike</code>, which produces a <code>RoadBike</code> object. Then, the decorator calls its own <code>Build()</code> method, which adds the notification behavior.</p>
<p>The cool thing about decorators is that they stack. For the pièce de résistance, we’ll put both decorators on the <code>RoadBike</code> object at the same time:</p>
<pre class="source-code">var notifyingDocumentedBike = new NotifyingBicycle(new 
    DocumentedBicycle(new RoadBike(), bikeManualPrinter), 
        manufacturingInventoryNotifier);
notifyingDocumentedBike.Build();</pre>
<p>Yikes! That’s hard to read. Let’s break it apart. In the middle, you’ll find a new undecorated <code>RoadBike</code> class:</p>
<pre class="source-code">var notifyingDocumentedBike = new NotifyingBicycle(new 
    DocumentedBicycle(<strong class="bold">new RoadBike()</strong>, bikeManualPrinter), 
        manufacturingInventoryNotifier);
notifyingDocumentedBike.Build();</pre>
<p>Now, move <a id="_idIndexMarker279"/>out from there and you’ll find where we make <code>DocumentedBicycle</code> using this new <code>RoadBike</code>:</p>
<pre class="source-code">var notifyingDocumentedBike = new NotifyingBicycle(<strong class="bold">new </strong>
<strong class="bold">    DocumentedBicycle(new RoadBike(), bikeManualPrinter)</strong>,<strong class="bold"> </strong>
<strong class="bold">        </strong>manufacturingInventoryNotifier);
notifyingDocumentedBike.Build();</pre>
<p>We passed in <code>bikeManualPrinter</code>. In real life, be careful of re-using your instances in this way. We used <code>bikeManualPrinter</code> before and now we’re passing it into a second bike. These are passed by reference, meaning if you change any property on <code>bikeManualPrinter</code>, it will affect both the value of <code>documentedBike</code> from the earlier example and this <code>notifyingDocumentedBike</code> we’re building now.</p>
<p>Now, let’s move all the way to the outer constructor:</p>
<pre class="source-code"><strong class="bold">var notifyingDocumentedBike = new NotifyingBicycle(</strong>new 
    DocumentedBicycle(<strong class="bold">new RoadBike()</strong>, bikeManualPrinter), 
        manufacturingInventoryNotifier<strong class="bold">);</strong>
notifyingDocumentedBike.Build();</pre>
<p>The outermost constructor creates an instance of <code>NotifyingBicycle</code> using the new <code>DocumentedBicycle</code>, which uses a new <code>RoadBike</code>. At each level, we pass in a decorating behavior.</p>
<p>To put this another way, <code>notifyingDocumentedBike</code> is created using a new <code>DocumentedBicycle</code>, plus <code>ManualPrinter</code>. <code>DocumentedBicycle</code> is created using a new <code>RoadBike</code>.</p>
<p>You can see the output from the run program. <em class="italic">Figure 4.3</em> shows a run of the <code>DocumentedBicycle</code> decorator, followed by the <code>NotifyingBicycle</code> decorator. The final run shows both decorators on the same object running successfully. The code indicates color coding for the output, but this book is not printed in color. Or maybe it is and you need an eye exam:</p>
<div><div><img alt="Figure 4.3: The output from the run of Program.cs for the DecoratorExample project (to save space, the output from the undecorated RoadBike is not shown). " height="743" src="img/B18605_Figure_4.31.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: The output from the run of Program.cs for the DecoratorExample project (to save space, the output from the undecorated RoadBike is not shown).</p>
<p>You can <a id="_idIndexMarker280"/>see why the Decorator pattern is a crowd favorite among developers. You can use it when you need to add behaviors to an object without breaking existing implementations. Decorators can be used to create layers of business logic that can be stacked or combined as needed. For example, only bikes sold through the dealership network will need the <code>DocumentedBicycle</code> decorator, but all of them that use raw materials from our supplier will need the <code>NotifyingBicycle</code> decorator. If we make a bicycle with raw materials from another source that won’t be sold through the dealer network, then we do not need any of the decorators. </p>
<p>You can also use a decorator to extend classes that are awkward or impossible to extend through regular inheritance. Consider a class that is sealed, meaning it can’t be extended through inheritance. You can still extend it using a decorator! This can result in you feeling as though you’re an outlaw. This is normal and may lead you to obtaining a black cowboy hat and learning the lyrics to every song written by Johnny Cash. You’ve been warned.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>The Façade pattern</h1>
<p><em class="italic">“Ugh!”</em> Phoebe exclaims. It’s 4 a.m. at Phoebe’s workshop. Her formerly white lab coat is covered in <a id="_idIndexMarker281"/>grease and she’s wading through aluminum shavings shed by an industrial lathe. She’s trying to build one of her robotic arms. She has several different designs, but this one is a heavy model that’s bolted to the floor. There are three variations of the arm. One arm is equipped with a welder used to weld the aluminum alloy bicycle frames together, another one has a buffer used to perfect the finish on the bicycles after they are painted, and the last one is equipped with a gripper used to hold the bicycle during assembly. Phoebe wanted to build several arms of each type. She was constrained by her budget and could only afford to build 10 arms. She decided the best combination for the arms would be three welders, three buffers, and four grippers. After whiteboarding the process, she realized her factory would not be able to keep up with the demand generated by the sisters’ stellar marketing campaigns. The Kickstarter alone had already generated hundreds of orders and the factory wasn’t even operational yet! Phoebe was having trouble coming up with a way to make this factory work.</p>
<p>Her sister Kitty had been working on the control software. The two had agreed on how the software would work in advance of creating the robotics because sometimes making the software before the hardware is practical. The software design is fluid and easy to change. It can drive the hardware design, which is less fluid and more expensive to change. This is one of those cases. On a whim, Phoebe pulls Kitty’s GitHub repo and switches to the branch where Kitty had designed the object structure for the control arms.</p>
<p>Phoebe finds Kitty’s implementation of the Decorator pattern and it gives her an idea. She can think of the attachments for the robot arm as decorators! This way she can make 10 arms, but the arms can perform whatever action is needed by switching the decorator. To be clear, Phoebe isn’t creating software. She’s taking inspiration from the Decorator pattern and making a robotic arm with interchangeable attachments, thus allowing the basic arm to perform many functions as needed without building a new arm for each task.</p>
<div><div><img alt="Figure 4.4: Phoebe finds inspiration in the Decorator pattern. " height="517" src="img/B18605_Figure_4.41.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Phoebe finds inspiration in the Decorator pattern.</p>
<p>This is fantastic! However, there’s another problem. Each attachment will be built from components from different suppliers and each will have a different API to control the arm’s attachment.</p>
<p>A few <a id="_idIndexMarker282"/>weeks ago, Kitty left the s	mall town of Alpine, Texas, where she was finishing up her Industrial Design degree at Sul Ross University. She drove her bright yellow Jeep Wrangler eight hours northeast to Dallas, Texas where her sister Phoebe was finishing her studies in engineering at Southern Methodist University. The purpose of Kitty’s visit, aside from the superior collegiate nightlife in Dallas, was to research and source potential parts for their factory robotics. They already had access to some of the more basic needs for manufacturing bicycles. At one point during their father’s career, he had spent a few years working for a helicopter factory in Fort Worth, Texas. Fort Worth is adjacent to Dallas and the residents refer to the area as the Dallas Fort-Worth metroplex. During their father’s time at the helicopter factory, he made many contacts that could help the girls achieve their goals. Everything they needed from machine shops to advanced computer-controlled laser cutting and fabrication was but a phone call away. The electronics, however, were a different story. The girls had decided to develop the robotics using readily<a id="_idIndexMarker283"/> available <strong class="bold">commercial off-the-shelf</strong> (<strong class="bold">COTS</strong>) components. </p>
<p>Servomotors are electrical motors that allow for precise control of angular or linear positioning, along with velocity and acceleration. They are widely deployed in the development of robotic and human-controlled industrial machinery. The objective for Bumble Bikes is to have an automated factory. Kitty began looking into microcontrollers. Microcontrollers are tiny<a id="_idIndexMarker284"/> computers that allow <strong class="bold">application programmer interface</strong>-(<strong class="bold">API</strong>-) level interactions to control anything, including servomotors. The servomotors might be connected to the computer using pin connectors, sometimes called “hats”, that seat onto the microcontroller’s printed circuit board. The local computer store in Dallas had a robust section of their supermarket-sized facility dedicated to the purveyance of microcontrollers, servomotors, and all the related electronics needed.</p>
<p>One week <a id="_idIndexMarker285"/>and one large workbook of Libre Office Calc spreadsheets later, they had a working bill of materials for building the robot arms and their three different attachments. Assembling the parts into an electrically viable robotic arm is elementary. The hardest part is writing the software. The girls sourced three different microcontrollers with three different APIs for each arm attachment: one for the grabber, one for the welder, and another for the buffer.</p>
<p>A simple solution would be to write a stovepipe application that calls the APIs directly based on any required logic dictated by the needs of the manufacturing process. The sisters’ recent experience with factory patterns has trained them to be wary of such strategies. Quick and easy solutions are neither sustainable nor maintainable in the long term, and they are thinking long-term. They want to build their robots once and those robots, being well maintained, conceivably could run forever. </p>
<p>One of Kitty’s professors, Professor Charles Dexter Ward, had taught a class titled <em class="italic">Introduction to Smart Product Design</em>. It was an entire semester on the exact problem the girls are solving: how to design efficient automated systems using sensors and microcontrollers. Dr. Ward had cautioned Kitty and her academic colleagues about vendor lock-in. Kitty and Phoebe are starting a business by turning a passion project into an enterprise they can pass to their children and grandchildren. It doesn’t make sense to trust that the microcontrollers they buy now, and their related APIs, will remain unchanged for the long term or even a few years into the future. By tightly coupling to the current APIs directly, the sisters would be trusting that the API developers they use today will remain in business as long as Bumble Bikes. This would also assume that the APIs will continue to evolve and be maintained in accordance with their application’s needs. Naturally, this would be a very naïve assumption.</p>
<p>A safer bet is that new microcontroller APIs will be introduced into the market and from different companies every few years. The method signatures and the way the API itself is invoked will be different than they<a id="_idIndexMarker286"/> are today. Consider common technology for remote API calls 20 years ago. <strong class="bold">Common Object Request Broker</strong> Architecture (<strong class="bold">CORBA</strong>) was replaced by <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>). SOAP, in <a id="_idIndexMarker287"/>turn, has been entirely displaced<a id="_idIndexMarker288"/> by <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>), common in web development and the <strong class="bold">Internet-of-Things</strong> (<strong class="bold">IoT</strong>) industry, which<a id="_idIndexMarker289"/> is still nascent in the year 2022. I’ll wager many well-trained software developers reading this book have little to no exposure<a id="_idIndexMarker290"/> to CORBA or SOAP, just as your descendent colleagues will likely have something very different from REST. Any system that is tightly coupled to any API has a life span equal to the shortest life span of its tightly coupled components. Kitty has taken this particular lesson to heart. Within the software, Kitty had represented the control arm with an interface that implemented the robot arms performing abstract operations. These can be mapped to the API. She’s using <strong class="bold">the Façade pattern</strong>. </p>
<p><em class="italic">Façade,</em> in regular English, or in this case, French, means “face”. In architecture (the kind with buildings, not software), it refers to the front of a building. A façade is usually ornate and represents what designers call <em class="italic">curb appeal</em>. One of the most famous façades I can think of is the castle at Walt Disney World in Florida, seen in <em class="italic">Figure 4.5.</em>  A sidenote: Dear Internal Revenue Service, please accept my amended return with my deduction labeled “book research trip to Disney.” It was purely business, I assure you.</p>
<div><div><img alt="Figure 4.5: The front façade of the castle at Walt Disney World in Florida presents an ornate appearance to the outside world. " height="823" src="img/B18605_Figure_4.51.jpg" width="822"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: The front façade of the castle at Walt Disney World in Florida presents an ornate appearance to the outside world.</p>
<p>In software<a id="_idIndexMarker291"/> architecture, the Façade pattern works in reverse. Instead of a fancy ornate face to an object or API, it’s a simplified point of access. This nifty pattern can insulate your programs from vendor lock-in by situating itself between your code and the APIs you’re calling. As an added bonus, the façade also allows you to simplify the interface to the API, or even multiple APIs by only exposing the parts that matter.</p>
<p>In the case of Bumble Bikes, Phoebe and Kitty only need basic functions that allow the robotic arm attachments to move and then call the specific API routines that allow for welding, buffing, and grabbing. The respective APIs could have thousands of exposed objects, methods, and properties between them, but we only need a few. Likewise, there might be a dozen of these APIs, but from our code’s perspective, there is one library we’re calling. The API could even be called in a non-obvious way such as CORBA (hopefully not), REST, or directly as an imported assembly dependency. The façade would take care of all this seamlessly. When the APIs change in future releases or are replaced with different APIs from different vendors, you only need to replace the façade. The underlying code remains untouched. If you’ve used an <strong class="bold">Object Relational Mapper</strong> (<strong class="bold">ORM</strong>) with a <a id="_idIndexMarker292"/>database, that qualifies as a façade because it gives you simplified access to the database. This often allows you to switch out the database, say from Oracle to SQL Server, without changing your code.</p>
<p>This is <a id="_idIndexMarker293"/>how Kitty solved the API problem in the software. She created an interface that defined the behaviors of the robot arms. Then, she created a decorator, which is code that implements the interface. She then wraps the API calls, successfully mapping the abstractly defined behaviors to the specific calls to the API. Kitty, by designing the software in this way, has broken the dependency on the APIs, and by extension, prevented vendor lock-in. Any API can be decorated or wrapped following Kitty’s behavioral interface. When the next generation of microcontroller APIs becomes available, Kitty just needs to write a wrapper for the new API that conforms it to her software’s requirements encapsulated in the interface. The robotic control software remains closed for modification. This would not be the case if she tightly coupled it to the microcontroller’s API. Had she done that, every revision to the API would require a partial rewrite, along with serious testing and validation efforts for Kitty’s entire software suite. How often have you encountered, or even performed, a fix to one part of your software and the fix breaks something somewhere else? Have you ever said, “That’s impossible! There’s no way changing something in library A could affect the operation of library B!”? This is indicative of a program built on tightly coupled operations. Changing anything can and will have a cascading effect. The more complex the system, the more likely some stage of the cascade will have a deleterious effect on the overall system. This has been avoided by using the Façade pattern. While closed for modification, Kitty’s program is open for extension because she can easily add new wrappers that follow the interfaces used by her software. She need only develop and test the new software, not the entire control program. The program at large is insulated from rippling failures through de-coupling. Kitty’s engineering notebook documents her implementation of this pattern using <em class="italic">Figure 4.6</em>:</p>
<div><div><img alt="Figure 4.6: Kitty’s engineering notebook diagram of her implementation of the Facade pattern. " height="891" src="img/B18605_Figure_4.61.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Kitty’s engineering notebook diagram of her implementation of the Facade pattern.</p>
<p>The parts of <a id="_idIndexMarker294"/>the pattern implementation can be explained by the numbers:</p>
<ol>
<li value="1">The <code>RobotArmFacade</code> class <a id="_idIndexMarker295"/>is consumed by the client in place of direct references to the three third-party APIs represented by numbers <code>SomeOtherSubSystemOperation300()</code>, <code>SomeOtherSubsystemOperation400()</code>, and <code>SomeOtherSubSystemOperation99()</code> are my clever way of hinting these third-party APIs are massive without drawing a diagram that fills the page with imaginary API methods. Our application only needs a few of these methods, so only those we need are exposed in the façade.</li>
<li><code>WelderAttachmentAPI</code> represents<a id="_idIndexMarker296"/> a third-party library, perhaps a NuGet package, that controls the welding arm attachment on Phoebe’s robot arm.</li>
<li><code>BuffingAPI</code> represents <a id="_idIndexMarker297"/>a third-party library, perhaps a NuGet package, that controls the buffing attachment.</li>
<li><code>GrabbingAPI</code> represents<a id="_idIndexMarker298"/> a third-party library, perhaps a NuGet package, that controls the grabbing attachment.</li>
</ol>
<p>Note that many of <a id="_idIndexMarker299"/>the methods within the three third-party classes are similar. </p>
<p><code>WelderAttachmentAPI</code> exposes <code>MoveTo(int, int, int)</code>, allowing the control software to position the welding attachment in three-dimensional space. <code>BuffingAPI</code> uses <code>Quaternion</code>, which is a three-dimensional coordinate combined with an angular rotation. If you ever work with the Unity3D game engine, which uses C# as its flagship coding language, you’ll get to know and love quaternions despite their very complicated mathematical nature. Thankfully, with the Façade pattern, you don’t need to fully understand the inner workings, such as Euler angles and the concept of gimbal lock, to use them. <code>GrabbingAPI</code> provides <code>SetLocation(int, int)</code> with two coordinates since that attachment only needs to move in two dimensions.</p>
<p>All three APIs have a common feature that moves the robot arm into position, but they are not identical in the way they are implemented or called. Each has a different method signature. This is a perfect use case for a façade because you can expose a single method to control movement and selectively call the correct API method based on which arm attachment is in use.</p>
<p>Similarly, each API has some method for activating is main function: <code>Weld()</code>, <code>Buff()</code>, and <code>Grab()</code> respectively. Again, the façade can hide the complexity of calling multiple methods. While it may seem they achieve different goals, we can hide that complexity behind a single method that calls the correct API method based again on the type of attachment in use.</p>
<p>Let’s look at the code in the <code>RobotArmFaçade</code> class. First, we have an <code>enum</code> that defines the attachments:</p>
<pre class="source-code">public enum ArmAttachments { Welder, Buffer, Grabber }</pre>
<p>Next comes the class itself and its constituent member variables:</p>
<pre class="source-code">public class RobotArmFacade
{
  private readonly WelderAttachmentApi _welder;
  private readonly BuffingApi _buffer;
  private readonly GrabbingApi _grabber;
  public ArmAttachments ActiveAttachment;</pre>
<p>You might <a id="_idIndexMarker300"/>note a similarity here with the Decorator pattern. We have private instances of the three APIs in the façade itself. It will be the job of the façade class to pass instructions through to the correct API in the correct format. The private members are initialized with a constructor:</p>
<pre class="source-code">public RobotArmFacade(WelderAttachmentApi welder, 
    BuffingApi buffer, GrabbingApi grabber)
  {
    _welder = welder;
    _buffer = buffer;
    _grabber = grabber;
    ActiveAttachment = ArmAttachments.Welder;
  }</pre>
<p>The <code>ActiveAttachment</code> member is arbitrarily set to default to the welder. Next, our façade will expose the methods for activating the currently active attachment. If it’s a welder, it will weld. A grabber will grab and a buffer will buff, but it doesn’t make sense to expose the methods by name. The façade makes things simpler. Kitty elects to call the façade method <code>Actuate()</code> and this method determines what is actually called behind the curtain:</p>
<pre class="source-code">public void Actuate()
  {
    switch (ActiveAttachment)
    {
      case ArmAttachments.Buffer:
        _buffer.Buff();
        break;
      case ArmAttachments.Grabber:
        _grabber.Grab();
        break;
      case ArmAttachments.Welder:
        _welder.Weld();
        break;
      default:
        throw new ArgumentOutOfRangeException();
    }
  }</pre>
<p>Lastly, we <a id="_idIndexMarker301"/>need to expose a simple way to move the arms and position the attachments. This one requires a little more thought since each API method has a different method signature. Kitty decides the obvious solution is to pick the most complicated requirement, <code>Quaternion</code>. Quaternions are part of the .NET <code>System.Numerics</code> library. This struct holds four values, W, X, Y, and Z of the <code>Single</code> type per the documentation. Since it is the most complicated requirement, it can be made to service the simpler method signatures by ignoring the parts of the quaternion we don’t need:</p>
<pre class="source-code">public void MoveTo(Quaternion quaternion)
  {
    var roundX = (int)Math.Round(quaternion.X, 0);
    var roundY = (int)Math.Round(quaternion.Y, 0);
    var roundZ = (int)Math.Round(quaternion.Z, 0);</pre>
<p>The two APIs, <code>WelderAttachmentAPI</code> and <code>GrabbingAPI</code>, need integers. First, we’ll convert the single numbers in the quaternion into integers by rounding as shown in the preceding code. Next, we’ll call the appropriate API based on the active attachment:</p>
<pre class="source-code">    switch (ActiveAttachment)
    {
      case ArmAttachments.Buffer:
        _buffer.Position(quaternion);
        break;
      case ArmAttachments.Welder:
        _welder.MoveTo(roundX, roundY, roundZ);
        break;
      case ArmAttachments.Grabber:
        _grabber.SetLocation(roundX, roundY);
        break;
      default:
        throw new ArgumentOutOfRangeException();
    }
  }</pre>
<p>The buffer<a id="_idIndexMarker302"/> attachment requires a quaternion, so our code will just be passing through the original argument. The X, Y, and Z coordinates can be made compatible with the other two method signatures by rounding the numbers and ignoring anything in the quaternion you don’t need.</p>
<p>Phoebe decides her assembly line should be very simple. The robotics generally only need to worry about where along the assembly line they are positioned, so her control program will vary the X coordinate in every case. As a further measure of control, Phoebe decides to create a control program that knows precisely what the X coordinates are for each station on her assembly line. </p>
<p>Her control program consists of this code:</p>
<pre class="source-code">const int numberOfAssemblyStations = 20;
const float consistentY = 52.0f;
const float consistentZ = 128.0f;
const float consistentW = 90.0f;</pre>
<p>First, we see a <a id="_idIndexMarker303"/>set of constants. We have a maximum of ten robotic arms owing to Phoebe’s material and financial constraints. Since the arms can be made to work as a team, Phoebe discovers she can power 20 stations by systematically moving the robots from station to station, swapping out arm attachments as needed. She carefully calibrates her equipment and finds the ideal Y and Z coordinates. She sets them as constants along with a default rotational angle of 90 degrees, which works with all her processes.</p>
<p>Next, Phoebe creates an array to hold the coordinates of her 20 stations as quaternions:</p>
<pre class="source-code">var assemblyStations = new Quaternion
    [numberOfAssemblyStations];</pre>
<p>Since the assembly line is literally a straight line, it is easy to evenly space the stations 25 feet apart along the line’s X axis. A simple loop can then pre-populate the array of quaternions that represent the workstations on the assembly line:</p>
<pre class="source-code">for (var i = 0; i &lt; numberOfAssemblyStations; i++)
{
  var xPosition = i * 25.0f;
  assemblyStations[i] = new Quaternion(xPosition, 
      consistentY, consistentZ, consistentW);
}</pre>
<p>We are now ready to set the robotic dance in motion.</p>
<p>Let’s instantiate our <code>RobotArmFacade</code>, set the attachment to a welder, and move it to station zero, which is the first position in the array of quaternions. Once it’s there, we’ll tell it to perform a weld using the <code>Actuate()</code> method on the façade:</p>
<pre class="source-code">Console.WriteLine("RobotArm 0: Robotic arm control system 
    activated!");
var robotArm0 = new RobotArmFacade(new 
    WelderAttachmentApi(), new BuffingApi(), new 
        GrabbingApi());
Console.WriteLine("Initializing welder function in arm 0");
robotArm0.ActiveAttachment = ArmAttachments.Welder;
robotArm0.MoveTo(assemblyStations[0]);
robotArm0.Actuate();</pre>
<p>Next, let’s move <a id="_idIndexMarker304"/>the arm to station <code>3</code> where we need a buffer to smooth out a metal extrusion on a bicycle frame. Once the arm is in place, we’ll buff using the <code>Actuate()</code> method:</p>
<pre class="source-code">Console.WriteLine("Initializing buffer function in arm 0");
robotArm0.ActiveAttachment = ArmAttachments.Buffer;
robotArm0.MoveTo(assemblyStations[3]);
robotArm0.Actuate();</pre>
<p>Splendid! The arm is now needed to grab a part and hold it in place for painting at station <code>7</code>:</p>
<pre class="source-code">Console.WriteLine("Initializing grabber function 
    in arm 0");
robotArm0.ActiveAttachment = ArmAttachments.Grabber;
robotArm0.MoveTo(assemblyStations[7]);
robotArm0.Actuate();</pre>
<p>Initially, we needed to deal with three different APIs from three different vendors to work with three different pieces of hardware. By using the Façade pattern, we were able to deal with one common interface for all three APIs, which isolates the bulk of our code from changes made in the API. When the API changes, we may need to change the façade, but we won’t need to change anything else.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>The Composite pattern</h1>
<p>Phoebe <a id="_idIndexMarker305"/>continued to work on the electronics. Kitty, however, was starting to worry about some of the fundamental considerations for her designs. Initially, the girls had agreed to use commercially available components, but Phoebe realized they could manufacture all the parts they need themselves. That way, assuming Bumble Bikes had access to all the raw materials, such as aluminum alloys, plastic, and rubber, they could have tighter control over the cost, durability, and weight of their final product. These factors influence everything from how Bumble Bikes sources its raw materials to the final sales price. The final sales price is factored by adding in the cost of goods sold, or in this case, the cost to manufacture, package, and deliver a bicycle. Kitty had some preliminary spreadsheets on her iPad. They were complicated, though. Kitty really wanted to ditch the two-dimensional thinking presented by her spreadsheets and come up with a better way to represent the cost of making a bicycle.</p>
<p>Kitty opened her backpack and her heart sank. Her iPad, or what was left of it, spilled on to the worktable as a collection of broken glass and jagged plastic shards. She remembered her crash at Big Bend last weekend. She had misjudged the drop on a 3-foot (1-meter) ledge on Black Gap Road, flipped over her front handlebar, and landed on her back. Her backpack, which contained her iPad, had broken her fall. Everything was on that iPad! Thankfully, her father had drilled the number one house rule into her head. <em class="italic">“Always protect the gear!”</em> he would say. <em class="italic">“We make our livelihood with our tablets and our laptops. Others use them to play games and watch movies. There’s nothing wrong with that, but we use ours to make our mortgage, so take care of your gear!”</em> He would usually shout this epithet very early in the morning when he would invariably trip trying to avoid someone’s tablet, phone, or computer that had been left on the floor right along the path he took as he sleepily lumbered to the kitchen in the mornings in search of caffeine. Owing to this sage wisdom, the tablet was backed up. When Kitty had purchased it in Dallas from her favorite computer store, she had opted to get the extra 99 USD replacement guarantee that covered everything, including accidental damage. The new iPad arrived in the mail the next day and Kitty, being a student of industrial design, reveled in the unboxing of her new digital compatriot.</p>
<p>For all the criticisms she had about Apple products, such as the inability to upgrade or repair them, there was one thing nobody could deny. They have the coolest packaging of any product in the tech industry. The packaging itself is a work of industrial art: from the heavier than necessary gauge of cardboard to the way all the packages fit together to take up as little space as possible.</p>
<p>As Kitty <a id="_idIndexMarker306"/>was waiting for her cloud backup to restore all her data and apps, a lightning bolt thought struck her. Apple had solved the very problem she was considering. The way the packages fit together, where some are inside of others, reminded her of a tree structure. The iPad shipped with the tablet, a charger, a USB-C style cable, and a tiny box containing a beautifully printed instruction manual that everybody just throws away. There was a warranty card and a few other printed cards touting Apple’s responsible stance on the environment and an advert for AppleCare, Apple’s own service plan. The iPad itself was housed inside a coated cardboard insert where all the pieces in the package fit together precisely. The charger and cord fit in a niche below a sunken niche carved out for the iPad itself. Everything was coated with plastic, so nothing would be marred or scratched during shipment. The intricate package, depicted in <em class="italic">Figure 4.7</em> in a way that will not get me sued, contained as many small boxes and cardboard pieces as the actual electronics they held. Naturally, a product designer at Apple could tell precisely how much any of the smaller boxes or wrapped components within the larger package weighed at any time, as well as how much each of the intricate die-cut cardboard components cost to make. That designer probably agonized for months looking for ways to shave fractions of pennies off the package material cost, just as the iPad’s designers had stressed over weight, power, and heat concerns:</p>
<div><div><img alt="Figure 4.7: Kitty’s new tablet came intricately packaged. She realized it could be modeled as a tree structure, and perhaps bicycle components might be modeled in the same way.  " height="646" src="img/B18605_Figure_4.71.jpg" width="852"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Kitty’s new tablet came intricately packaged. She realized it could be modeled as a tree structure, and perhaps bicycle components might be modeled in the same way. </p>
<p>So far, Kitty had successfully created class models for high-level bicycle components, such as the frame. She and Phoebe had committed themselves to the idea that they would manufacture everything for the bicycles themselves, including the crankset. The crankset consists of all the parts that make the bicycle move when you push down on the pedals. Bumble Bikes <a id="_idIndexMarker307"/>intended to position itself on the market as a cut above big-box stores in terms of its build quality. That meant every gram would be scrutinized by sophisticated customers who were conditioned to having to buy a bicycle, discard most of the components it came with, and replace them with better, lighter components. There is always a perfect balance between the weight and cost of the crankset for many riders. The racing community will pay a premium for parts that are several grams lighter, while casual riders want a product that’s less expensive and they don’t mind the extra weight.</p>
<p>The crankset, as with the boxes, can be modeled as a tree, as we’ll soon see. If you’re not personally familiar with the parts on a bicycle that comprise a crankset, and you’re curious, see Kitty’s CAD drawing in <em class="italic">Figure 4.8</em> where she was kind enough to diagram most of them for us:</p>
<div><div><img alt="Figure 4.8: The crankset for a typical bicycle involves components that can be nested in a tree-like structure to solve our immediate problems with cost and weight. " height="801" src="img/B18605_Figure_4.81.jpg" width="1060"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: The crankset for a typical bicycle involves components that can be nested in a tree-like structure to solve our immediate problems with cost and weight.</p>
<p>When you <a id="_idIndexMarker308"/>are presented with modeling a tree-like structure of objects that can conform to a common interface, you should immediately think of the Composite pattern. The Composite pattern allows you to compose a tree of objects and then work with the structure as if it were a single object. The tree is composed of containers and leaves. A leaf is a tree element that doesn’t have any sub-elements. A container is a tree element that has other leaves and containers within it. Graphically, this looks similar to a file folder structure on your computer. The files are leaves and the folders are containers:</p>
<div><div><img alt="Figure 4.9: The file structure of your computer’s hard drive is represented as a tree consisting of leaves (files) and containers (folders). " height="1004" src="img/B18605_Figure_4.91.jpg" width="880"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: The file structure of your computer’s hard drive is represented as a tree consisting of leaves (files) and containers (folders).</p>
<p>We can model part of our group set this way as well. For our mechanically inclined readers, I’m not necessarily suggesting these parts literally fit inside each other in the physical world. I’m suggesting they can be modeled this way to solve the problem at hand in terms of weight and cost. In this model, the crankset consists of the bottom bracket, which is basically a big hole at the bottom of the bicycle frame fitted with bearings, and a shaft extends through the bottom bracket. The shaft is connected to a set of chainrings. Most bicycles have one, two, or three chainrings depending on what kind of bicycle it is. Road bikes usually have two: a large chainring for general riding and a small chairing that is used to climb hills. In our model, the small chain ring is treated as a leaf where all other components so far have been containers.</p>
<p>The <a id="_idIndexMarker309"/>chainrings connect to the crank arms, which are one big piece, even though they might appear to be two separate arms. The arms attach to the left and right pedals, which are the leaves and the end of our tree structure.</p>
<p>The composite pattern allows you to work with complex tree structures elegantly by allowing you to make full use of recursion and polymorphism. Just be careful that you work with classes that have a very common interface. You might be introducing code smell if you must shoe-horn a bunch of classes that don’t really fit together. This pattern pairs nicely with the Builder pattern already in use because the builder can be made to assemble the tree structure. The basic structure of the composite pattern is shown in <em class="italic">Figure 4.10</em>:</p>
<div><div><img alt="Figure 4.10: The Composite pattern. " height="656" src="img/B18605_Figure_4.101.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: The Composite pattern.</p>
<p>Let’s understand<a id="_idIndexMarker310"/> this figure in detail:</p>
<ol>
<li value="1">The <code>Component</code> class will implement some interface with the methods needed to access the overall functionality. Here, we’re calling that <code>Run()</code>. Components can contain leaves and other components.</li>
<li>The <code>Leaf</code> class represents nodes in the tree that can’t contain anything else.</li>
<li>The <code>Composite</code> object allows for the creation and maintenance of a tree structure using components and leaves.</li>
<li>The client program accesses the composite tree as it needs and can treat simple and complex objects identically.</li>
</ol>
<p>I want to reiterate that we are <em class="italic">not</em> attempting to model the physical structure of our bicycle. This model is a cost model and defines the relationships within a group of components, not the order of physical assembly. The fields we’re interested in are cost and weight, and those fields will form an interface that describes the common properties of any bicycle component regardless of its form, construction, or purpose.</p>
<p>Kitty’s version looks as follows in <em class="italic">Figure 4.11</em>:</p>
<div><div><img alt="Figure 4.11: Kitty has changed the structure of the basic pattern found in Figure 4.x to suit her needs. Note this isn’t the diagram of the full hierarchy, it’s just the structure of the pattern  " height="1013" src="img/B18605_Figure_4.111.jpg" width="1332"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: Kitty has changed the structure of the basic pattern found in Figure 4.x to suit her needs. Note this isn’t the diagram of the full hierarchy, it’s just the structure of the pattern </p>
<p>The implementation<a id="_idIndexMarker311"/> of this pattern only requires one abstract class and a horde of concrete classes based on the abstract class. The following are the contents of Kitty’s abstract <code>BicycleComponent</code> class, which forms the vital common interface needed by the pattern. We need two private properties to hold the <code>weight</code> and <code>cost</code> values of the component:</p>
<pre class="source-code">public abstract class BicycleComponent
{
  private float Weight { get; set; }
  private float Cost { get; set; }</pre>
<p>Next, we need a list to hold any subcomponents. Kitty specified an interface for the type instead of directly coupling to the <code>List&lt;&gt;</code> class:</p>
<pre class="source-code">  public IList&lt;BicycleComponent&gt; SubComponents;</pre>
<p>These three <a id="_idIndexMarker312"/>properties are initialized in a constructor where we pass in <code>weight</code> and <code>cost</code> as floats. The <code>SubComponents</code> list is initialized as an empty list:</p>
<pre class="source-code">  protected BicycleComponent(float weight, float cost)
  {
    SubComponents = new List&lt;BicycleComponent&gt;();
    Weight = weight;
    Cost = cost;
  }</pre>
<p>Next, we need two methods to display the weights and costs of the components along with any subcomponents. These can leverage recursion to print out the entire tree, which is handy for Kitty’s cost analysis. We only need to do this on containers, not leaves, since leaves will be printed with their containers. We determine whether we’re dealing with a leaf by checking <code>SubComponents.Count</code>. If it is zero, we are dealing with a leaf, and we simply return. Otherwise, we loop and print the weight and cost of the subcomponents:</p>
<pre class="source-code">  public void DisplayWeight()
  {
    if (SubComponents.Count &lt;= 0) return;
    foreach (var component in SubComponents)
    {
      Console.WriteLine(component.GetType().Name + " weighs 
          " + component.Weight);
      component.DisplayWeight();
    }
  }</pre>
<p>Here, we do <a id="_idIndexMarker313"/>the same thing with cost:</p>
<pre class="source-code">  public void DisplayCost()
  {
    if (SubComponents.Count &lt;= 0) return;
    foreach (var component in SubComponents)
    {
      Console.WriteLine(component.GetType().Name + " costs 
          $" + component.Cost + " USD");
      component.DisplayCost();
    }
  }
}</pre>
<p>The concrete code for the Composite pattern is generally very repetitive, as you’ll see. In fact, Kitty does something here she doesn’t do anywhere else. She makes one file containing many classes. She names the file <code>CompositeParticipants.cs</code>, the partial contents of which follow in the code below. She did it this way because effectively it’s a collection of very simple concrete classes that inherit from a base class. If you want to see the whole class, consult Kitty’s code in the chapter’s sample code project:</p>
<pre class="source-code">public class Pedal : BicycleComponent
{
  public Pedal(float weight, float cost) : base(weight, 
    cost)
  {
  }
}
public class CrankArm : BicycleComponent
{
  public CrankArm(float weight, float cost) : base(weight, 
    cost)
  {
  }
}
public class LargeChainRing : BicycleComponent
{
  public LargeChainRing(float weight, float cost) : 
    base(weight, cost)
  {
  }
}</pre>
<p>As you can see, this isn’t rocket surgery. Every part is simply modeled as a concrete implementation of the abstract class. I’ve shown three classes here. There are seven in total that all look the same save for the class name.</p>
<p>At first glance, this <a id="_idIndexMarker314"/>might seem odd until you see how the composite’s tree is constructed in the client code within the <code>Program.cs</code> file. Within that file, Kitty builds the tree from the bottom up. This isn’t a requirement, but it does make it easy to understand. The leaves at the bottom of the tree are the petals or pedals:</p>
<pre class="source-code">var leftPedal = new Pedal(234.14f, 11.32f);
var rightPedal = new Pedal(234.14f, 11.32f);</pre>
<p>The pedals connect to the crank arm. I’m suddenly reminded of the old song <em class="italic">Dem Bones</em> where the toe bone is connected to the foot bone. The foot bone is connected to the heel bone. The song continues up to the head bone followed by an invocation of the songwriter’s creator. Here, the pedal bone is connected to the crank arm bone, except they aren’t bones:</p>
<pre class="source-code">var crankArm = new CrankArm(432.93f, 34.32f);
crankArm.SubComponents.Add(leftPedal);
crankArm.SubComponents.Add(rightPedal);</pre>
<p>We create <a id="_idIndexMarker315"/>the instance of <code>CrankArm</code>, then add the pedals to its <code>SubComponents</code> list. <code>crankArm</code> is connected to <code>largeChainRing</code>. So is <code>smallChainRing</code>, which itself becomes a leaf:</p>
<pre class="source-code">var largeChainRing = new LargeChainRing(57.0983f, 13.53f);
var smallChainRing = new SmallChainRing(52.57f, 11.33f);
largeChainRing.SubComponents.Add(smallChainRing);
largeChainRing.SubComponents.Add(crankArm);</pre>
<p>The large chainring is connected to the shaft:</p>
<pre class="source-code">var shaft = new Shaft(82.03f, 19.55f); // can you dig it?
shaft.SubComponents.Add(largeChainRing);</pre>
<p>The shaft fits through the bottom bracket:</p>
<pre class="source-code">var bottomBracket = new BottomBracket(284.834f, 11.51f);
bottomBracket.SubComponents.Add(shaft);</pre>
<p>That’s our crank set, but I’ll add a top-level instance of <code>CrankSet</code> and pass in zeros for the cost and weight since the crank set itself comprises its subcomponents:</p>
<pre class="source-code">var crankSet = new CrankSet(0f, 0f); 
crankSet.SubComponents.Add(bottomBracket);</pre>
<p>Now for the magical part of our show. We’ll call the two methods and get a recursive detail of the whole structure:</p>
<pre class="source-code">Console.WriteLine(" ---------- Weights -----------------");
crankSet.DisplayWeight();
Console.WriteLine(" ------------ Cost ------------------");
crankSet.DisplayCost();</pre>
<p>The result of the run is shown in <em class="italic">Figure 4.12</em>:</p>
<div><div><img alt="Figure 4.12: The run results of our Composite pattern project. " height="780" src="img/B18605_Figure_4.121.jpg" width="1199"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: The run results of our Composite pattern project.</p>
<p>The Composite pattern<a id="_idIndexMarker316"/> is used whenever you need to process a hierarchical structure as a tree. The main requirement for the pattern to be effective is that every node in the tree must conform to a common interface. If that can be managed, you can use this pattern to process the tree in any manner you might need. You can add new class types to your tree, so long as they conform to the common interface. Using this pattern, you can create novel processing capabilities while honoring the open-closed principle. Recursion and polymorphism can be exploited to expedite your processing. The client code will treat nodes and containers identically since they have a common structure, which is really the hard part. You have to find a way to make everything in the tree conform to the common interface, which isn’t always easy.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>The Bridge pattern</h1>
<p>The <strong class="bold">Bridge pattern</strong> is a<a id="_idIndexMarker317"/> structural design pattern that lets you split a large class or set of closely related classes into two separate hierarchies: abstraction and implementation. Kitty and Phoebe set up a Kickstarter page to promote Bumble Bikes and gauge the interest on the market. Backers can preview and pre-order the <em class="italic">Palo Duro Canyon Ranger</em>, Bumble Bike’s flagship mountain bike design. The project has been well received, but the Kickstarter backers are complaining about the lack of color choices on the bikes. In the original design, the girls purposefully limited the color choices because they were using inheritance for almost everything. The problem with using inheritance is becoming a clear theme: it can lead to a run-away proliferation of classes, as seen in <em class="italic">Figure 4.13</em>. Can you imagine supporting 20 colors per bicycle model, and expanding to 20 models of bicycles? That’s a lot of subclasses!</p>
<div><div><img alt="Figure 4.13: Class proliferation may sound as if it’s a Marxist political construct, but it becomes a problem when you over-use inheritance (we clearly need a better way to represent a finite set of supported colors for our bicycles). " height="509" src="img/B18605_Figure_4.131.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13: Class proliferation may sound as if it’s a Marxist political construct, but it becomes a problem when you over-use inheritance (we clearly need a better way to represent a finite set of supported colors for our bicycles).</p>
<p>Perhaps the simplest way to solve this is to simply create a property on your base bicycle class to hold <a id="_idIndexMarker318"/>the color. Maybe have it store a common color structure such as <strong class="bold">Red Green Blue</strong> (<strong class="bold">RGB</strong>) or <strong class="bold">Cyan Magenta Yellow Black</strong> (<strong class="bold">CMYK</strong>), which<a id="_idIndexMarker319"/> is the color model used by printers. This works fine if you’re dealing 100% with software and you need to represent a color within a gamut supported by your user’s graphics card or printer.</p>
<p>In an industry such as bicycle manufacturing, this won’t work, because we aren’t just representing any possible color of light or paint. We need to represent a finite set of paints to be mixed and applied using machinery. This dimension of realism means there are limits to how the color system can work. The girls must keep the base colors and topcoats in stock, and they must take into account the setup and cleaning costs of their painting <a id="_idIndexMarker320"/>machinery. Limiting each bike to one available color handles all this nicely without any design problems. In effect, they were counting on controlling a variable in their software by making a single color a business requirement. As it turns out, the market won’t bear that constraint. Competitors can offer a range of colors. Phoebe herself remembers the most important aspect of her new bike when she was 9 was that it was pink. She didn’t care about where it came from or whether it had a fancy label on the frame. It had to be pink.</p>
<p>When we looked at the Decorator pattern earlier in this chapter, the problem was similar. We added external features, such as bells and lights, which could also be represented with an exponentially growing tree of subclasses. So, why not use a decorator here? Perhaps, you could think of a paint job as a decorator. Decorators, though, are designed to stack. We can stack a bell, headlights, taillights, fenders, mirrors, and even bicycle theft alarms on top of one another within the object hierarchy to build the perfect bicycle without altering the abstract bicycle base class. There’s something not quite right about stacking paint jobs or even stacking your bell or lights onto a paint job. The paint, conceptually speaking, is more a part of the frame than something that decorates it. Beware of learning a pattern and then wielding it as a golden hammer. The decorator doesn’t really fit here, even though not using the pattern has a similar side effect.</p>
<p>When you read about the Bridge pattern in the GoF book, and I always encourage you to go to the original academic sources when you can, you will find it couched in very academic language. They talk about a bridge between an abstraction and its implementation. We can vary each independently of one other by keeping the two separate. We have a business requirement for a new dimension that is an integral part of our bicycle’s frame and we need to vary that dimension independently of the abstract bicycle. When you want to vary two or more dimensions independently, while avoiding a combinatorically increasing number of subclasses, you need the Bridge pattern.</p>
<p>You can see a representation of the Bridge pattern in <em class="italic">Figure 4.14</em>. I may have had a little fun with the visuals, but it does make it easy to see why this pattern is called a <em class="italic">bridge</em>:</p>
<div><div><img alt="Figure 4.14: The Bridge pattern allows you to vary two sides of your object structure independently along two different dimensions. " height="800" src="img/B18605_Figure_4.141.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14: The Bridge pattern allows you to vary two sides of your object structure independently along two different dimensions.</p>
<p>Let’s review the <a id="_idIndexMarker321"/>elements of the Bridge pattern in our diagram by the numbers:</p>
<ol>
<li value="1">This is the client that accesses the functionality in the abstraction.</li>
<li>This is the abstraction side of the bridge. This is usually the class structure that you started with and the structure that worked well until you realized you had additional dimensions you needed to model.</li>
<li>Refinements to the abstraction are subclasses that make sense and that don’t create a runaway multi-dimensional class structure. We have several refinements by way of four different types of bicycles that inherit from the abstract bicycle class.</li>
<li>The implementation interface is on the other side of the bridge. This is where you model the dimension that will vary independently of the abstraction. Note the bridge itself between the two consists of a compositional relationship. The abstraction has an implementation of the second dimension.</li>
<li>This is the<a id="_idIndexMarker322"/> concrete implementation of the second dimension based on the interface.</li>
<li>That’s a shark. Studies have shown that you are 68.342% more likely to be attacked by a shark if you don’t use the Bridge pattern to decouple your complicated classes. It doesn’t even matter if you live inland. Nobody knows why. It’s SCIENCE! Don’t argue.</li>
</ol>
<p>Let’s take a look at Kitty’s version of the Bridge pattern diagram applied to the bicycle paint problem in <em class="italic">Figure 4.15</em>:</p>
<div><div><img alt="Figure 4.15: Kitty’s whiteboard rendition of the bridge pattern applied to her paint problem. " height="958" src="img/B18605_Figure_4.151.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15: Kitty’s whiteboard rendition of the bridge pattern applied to her paint problem.</p>
<p><em class="italic">“Whoa, whoa, WHOA! Wait one fluffy minute!”</em> Phoebe exclaimed as she stomped her foot on the ground. <em class="italic">“You can’t do this! The only way to make this work is to break the open-closed principle! We’ve held this rule as sacrosanct!”</em> Kitty stared blankly at the board. Phoebe is right. She usually was, especially when she stomped her feet, a trait she got from her mother.</p>
<p><em class="italic">“We already </em><em class="italic"><a id="_idIndexMarker323"/></em><em class="italic">have a color attribute in the abstract Bicycle class,”</em> Kitty observed. <em class="italic">“But because it’s a stinkin’ enum, we can’t extend it, nor can we subclass it,”</em> Phoebe added. <em class="italic">“What about a decorator?”</em> Kitty asked. <em class="italic">“Maybe, but it seems as though we’re going to wind up with a lot more code and complexity than we would if we just changed the original design,”</em> Phoebe said. Neither wanted to give up. For the next few hours, the two pored over articles on other patterns that might help them. The problem here is that the original model used an enumeration to define the colors. A limitation of the C# language holds that an enumeration cannot be extended. </p>
<p>If they subclass or decorate the original <code>IBicycle</code> interface or the abstract <code>Bicycle</code> class, they’ll need to add the <code>PaintJob</code> attribute, but they’ll be stuck with the existing <code>Color</code> attribute. Inheritance doesn’t give us a way to hide or remove deprecated code. Covering it up with a façade doesn’t feel right either. Even if you covered the unused member with a façade, it would also change the interface you use to work with the bicycle classes.</p>
<p><em class="italic">“Gaga! We are going to </em><em class="italic"><a id="_idIndexMarker324"/></em><em class="italic">have to change the type in the bicycle base class!”</em> Phoebe said angrily. “Gaga” is a word Phoebe had trained herself to say in place of less socially acceptable words, such as the ones most people say when they stub their toe really, really, hard. The two railed against the realization with the fervor of defense attorneys trying to free an innocent man accused of capital murder. They pored over software engineering books and books on patterns. A common thread in all those books is that never once did any of the authors ever make a design mistake. They either presented trivial examples such as shapes, circles, and squares, or they presented patterns in a way that was too hypothetical – <code>ClassA</code> inherits from <code>ClassB</code>, and so on. The examples weren’t very useful, but they were very safe, as far as examples go. The GoF book presents real-world use cases via a windowed software project mainly aimed at Unix users working with SmallTalk, which isn’t widely used outside of government and academic circles. </p>
<p>Late one night, the sisters found the clarity that had been eluding them. Two of the most important books in the world of agile development with patterns are Robert Martin’s books titled <em class="italic">Agile Software Development, Principles, Patterns and Practices</em>, as well as the rewrite for C# developers titled <em class="italic">Agile Software Development, Principles, Patterns and Practices in C#</em>. The GoF book introduced the world to formalized software patterns, but Uncle Bob’s books introduced the world to SOLID and agile principles coupled with those patterns. Don’t worry. They aren’t tightly coupled. That would be a horribly recursive nightmare. </p>
<p>If you’re reading the e-book version of this book, assuming there is one, get out your e-highlighter for the next three sentences. Analog highlighters can be used on analog books.</p>
<p>Uncle Bob reminds us that it is impossible to foresee every design consideration ahead of time. Nobody is prescient, which is a point we made in the first chapter of this book. Lack of prescience leads to design problems that are usually solved with stovepipe-style fixes.</p>
<p>It may seem as though we’re abandoning our open-closed principle. You should never abandon the SOLID principles. But sometimes you must break them for the greater good.  Martin’s books describe this as taking a bullet and realizing the opportunity to learn from the mistake. He also reasons for you to consider every element within your code that can be refactored in an identical manner with the hope that you need only to take one such bullet. In the real world, as software grows, you will need to adhere to good principles, but you can’t be shackled by them.</p>
<p>Patterns can <a id="_idIndexMarker325"/>help you avoid the need to change the base class, but occasionally you will need to change the design because not changing it will make everything worse. Equally as important is the exercise of removing dead code from the software. This too necessitates breaking SOLID principles. It is far better to remove the dead code than leave it in for the sake of dogma.</p>
<p>In this particular case, changing the way we implement the property allows us to serve our business requirements in a flexible way true to the spirit of SOLID principles without being fettered by them. This is a call you should find yourself making on rare occasions. Changing the interface to use the new <code>IPaintJob</code> interface adds significant business value to the overall design. </p>
<p>We now have a way to model the bicycle, which we’ve had for a while, and a business-savvy way to model the paint job. Kitty and Phoebe can now offer their customers bicycles in a variety of colors. We’ve gone from limiting customers to a finite set of one color per bicycle to a set that is limited only by the gamut of the paints. We’ve shifted from a software limitation on the business to a limitation of real-world chemistry and machinery. I’ve personally always held that business should define software, not the other way around.</p>
<p>The Bridge pattern isolates the <code>Bicycle</code> classes from being tightly coupled to an equally complicated model. There is little doubt that over time, the painting model and the bicycle model will continue to grow in complexity, but now they do so in isolation. </p>
<p>Let’s look at the code for the Bridge pattern. For this book’s example code, I’ll be leaving all the code we have written so far intact. In real life, I’d begrudgingly modify the <code>IBicycle</code> interface. For the sake of the book and continuity, I’ll be putting Kitty and Phoebe’s code into a slightly different format. Phoebe sternly objected, but the editor stepped in and she ultimately capitulated.</p>
<p>I’ll start by making a new interface to use in place of <code>IBicycle</code>. All I’m going to do here is take out the offending <code>Color</code> property:</p>
<pre class="source-code">public interface ISimplifiedBicycle
{
  public string ModelName { get; set; }
  public int Year { get; }
  public string SerialNumber { get; }
  public BicycleGeometries Geometry { get; set; }
  public SuspensionTypes Suspension { get; set; }
  public ManufacturingStatus BuildStatus { get; set; }
  public void Build();
}</pre>
<p>The bridge we’re building has two sides. The bicycle side is represented by this new <code>ISimplifiedBicycle </code>interface, and the implementation side is used to independently model a complex object that describes how the bicycles might be painted. </p>
<p>Since classes and interfaces describing a paint job will probably be used across several different projects, Kitty adds a new namespace to the <code>BumbleBikesLibrary</code> we saw her create in <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>.  She adds a new folder called <code>PaintableBicycle</code>.  The rest of the code presented in this chapter can be found in the library project which is in <code>chapter-3/BumbleBikesLibrary/PaintableBicycle</code>.</p>
<p>For the latter, Phoebe devised an interface she thinks can describe anything her robots can paint:</p>
<pre class="source-code">public interface IPaintJob
{
  public string Name { get; set; }
  public int Cyan { get; set; }
  public int Magenta { get; set; }
  public int Yellow { get; set; }
  public int Black { get; set; }
  public IPrimer Primer { get; set; }
  public IPaintTopCoat TopCoat { get; set; }
  public void ApplyPrimer();
  public void ApplyPaint();
  public void ApplyTopCoat();
}</pre>
<p>Every paint job <a id="_idIndexMarker326"/>created in the system will have a marketable name, which is stored in the <code>Name</code> property. The paint system Kitty wants to use is based on the same CMYK color space used by traditional printing. She also intends to use a paint finish she calls <code>TopCoat</code>. Since this too is likely going to be reused later, it belongs in the library Kitty created in <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>. You’ll find this in the book’s sample code in <code>chapter-3/BumbleBikesLibrary/PaintableBicycle</code>. The paint finish will make the bicycle’s paint job take on a beautiful glossy sheen and protect the paint from scratches and sun exposure. Here’s an interface that describes the paint finish:</p>
<pre class="source-code">public enum PaintTopCoatTypes { TopCoatClear, GlamorClear, 
    TurboClear, HigherSolidClear }
public interface IPaintTopCoat
{
  public string Name { get; set; }
  public PaintTopCoatTypes Type { get; set; }
}</pre>
<p><em class="italic">“Hold up, Kitty!”</em> Phoebe exclaimed. <em class="italic">“Why are we using another enum? That was nothing but trouble last time!”</em> </p>
<p>Kitty defended her design decision by saying, “We were short-sighted thinking we could get away with one color per bicycle. But when it comes to primers and paint finishes, there are classifications for each that rarely ever change.  The code for the primer is probably going to be reused, so Kitty puts the code in the library she created in <a href="B18605_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>. You can find it in <code>chapter-3/BumbleBikesLibrary/PaintableBicycle</code>. The <code>PaintTopCoatTypes</code> enum contains the same set that has been in use for several decades. The makers improve the chemistry in the products, but they never introduce anything revolutionary. The same goes for primer.” Kitty brought up her <code>Primer</code> interface:</p>
<pre class="source-code">public enum PrimerColors { Gray, White, Black }
public enum PrimerTypes {Epoxy, Urethane, Polyester, 
    AcidEtch, Enamel, Lacquer, MoistureCure}
public interface IPrimer
{
  public string ManufacturerStockKeepingUnit { get; set; }
  public PrimerTypes Type { get; set; }
  public bool IsLowVoc { get; set; }
}</pre>
<p>Naturally, a good <a id="_idIndexMarker327"/>paint job starts with a good primer. To expand on Kitty’s point, these primers have been around for a long time. Kitty put more in the enum than she’d likely use just to be careful. The girls source a few they might use, but for the most part, the good old-fashioned gray primer used for automotive painting seems to work best. She has fields for the manufacturer’s <code>isLovVoc</code>, that tells her whether<a id="_idIndexMarker329"/> the paint is considered to be low in <code>false</code>, we’d want to be sure to wear a respirator around the painting equipment.</p>
<p>The structure of the paint job model is taking shape. Compared to a simple color term, it is relatively complex. As you can see, the Bridge pattern truly helps us. The main objective of the Bridge pattern is to allow two complex object structures to be developed and maintained independently of one another. The bicycle models have gone through many interactions by name and have become more and more robust models. Now, we have this complex paint job model. The two need to go together, but a day could come when either the bicycle model or the paint model might undergo drastic changes. The bridge is, as with many of the patterns we’ve studied so far, insulating parts of our code from change while simultaneously making all of our code flexible and reusable.</p>
<p>To handle our use case for the <a id="_idIndexMarker330"/>Bridge pattern, I’ll make another interface that inherits from <code>ISimplifiedBicycle</code> called <code>IPaintableBicycle</code>. We’re doing it this way to maintain as much flexibility as we can:</p>
<pre class="source-code">public interface IPaintableBicycle : ISimplifiedBicycle
{
 IPaintJob PaintJob { get; set; } 
}</pre>
<p>Kitty and Phoebe <a id="_idIndexMarker331"/>have four bicycle designs that need to implement this interface. It makes sense to set up an abstract class to implement the interface:</p>
<pre class="source-code">public abstract class PaintableBicycle : IPaintableBicycle
{
  public string ModelName { get; set; }
  public int Year { get; }
  public string SerialNumber { get; }
  public BicycleGeometries Geometry { get; set; }
  public SuspensionTypes Suspension { get; set; }
  public ManufacturingStatus BuildStatus { get; set; }
  public IPaintJob PaintJob { get; set; }</pre>
<p>The <code>Build()</code> method requires an update as well. The <code>Bicycle</code> class has a line that prints the color of the bicycle. We still need to do that, but instead of deriving it from the enum, we’ll work with the name of the paint job:</p>
<pre class="source-code"> public void Build()
  {
    Console.WriteLine($"Manufacturing a 
        {Geometry.ToString()} frame...");
    BuildStatus = ManufacturingStatus.FrameManufactured;
    PrintBuildStatus();
    
    Console.WriteLine($"Painting the frame 
                     {PaintJob.Name}");</pre>
<p>We also need to apply the other parts of the paint job:</p>
<pre class="source-code">    PaintJob.ApplyPrimer();
    PaintJob.ApplyPaint();
    PaintJob.ApplyTopCoat();
    BuildStatus = ManufacturingStatus.Painted;
    PrintBuildStatus();</pre>
<p>The rest of <a id="_idIndexMarker332"/>the class can remain the same. You will find the full code in the chapter’s source code available on GitHub.</p>
<p>The new paint system exceeds the Kickstarter backers’ expectations. Not only can Bumble Bikes support custom colors for every bicycle but they can also support custom gradient paint jobs. This is a feature rarely seen in the bicycle industry outside of shops specializing in custom paint and assembly.</p>
<p>The Bridge pattern can be implemented any time you have two or more class hierarchies that are complicated and need to be used together. At its core, the Bridge pattern is little more than composition. The reason it is recognized as a pattern is it becomes a thoughtful exercise in decoupling. It usually arises within the design phase. You start with a class and it gets more and more complex as you design it. Ideally, you find this growth in complexity when you are modeling the class, and you decouple it before it ever reaches code. In the real world, it comes up several iterations or even several years into the project, and you need to remember this has happened before. It will happen again. Eventually, it will happen to you. There is a solution, and that’s the heart and soul of software development patterns.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Summary</h1>
<p>Kitty and Phoebe’s modeling of the bicycle products and the automated manufacturing process and apparatus is growing more sophisticated as the two learn and invent their new business. This is how it works, and from the outside looking in, I’d say they’re doing an amazing job. It is very normal for a software developer to be an expert at software design and development, but far less of an expert in their understanding of the business problems they are tasked to solve. Software projects are really an evolution involving the developer’s understanding of the business and the needs of their customers and stakeholders.</p>
<p>In this chapter, we learned several structural patterns that allow us to continue to make our software more sophisticated yet simple to maintain and extend. You’ve also noticed a common theme: the basic tools of inheritance and composition afforded by an object-oriented programming language are not, by themselves, enough to build robust software. These structural patterns allow us to use the tools of composition and inheritance to maximum effect without boxing our designs into a quagmire of spaghetti-like object hierarchies.</p>
<p>The Decorator pattern allows us to extend existing classes by decorating or wrapping new functionality around the original class. The decorators can stack as a Russian Matryoshka doll does, where one doll is nested inside another.</p>
<div><div><img alt="Figure 4.16: A Russian Matryoshka doll (each doll nests inside the larger one, the same way decorators wrap around base classes or stack on other decorators). " height="627" src="img/B18605_Figure_4.161.jpg" width="1618"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16: A Russian Matryoshka doll (each doll nests inside the larger one, the same way decorators wrap around base classes or stack on other decorators).</p>
<p>Phoebe mastered the Façade pattern, which allows us to abstract and insulate our software from complex dependencies. The pattern allows you to put a simple face on a complex API by uniformly exposing operations, even if they aren’t uniform under the covers. You can also use a façade to only expose the elements in a complex API or structure that are important to your implementations. If in the future, the third-party API changes significantly, you can replace the façade without having tightly coupled API calls sprinkled throughout your code.</p>
<p>Kitty was able to model the bicycles’ group sets in a tree-like structure that allowed her to easily use recursion to find the cost and weight of the components together or in combination. Any time you need to deal with a tree, you should think, as Kitty did, of the Composite pattern.</p>
<p>With the cost and weight analysis problem solved, the girls teamed up to deal with the market’s demand for a wider color choice in the Bumble Bikes line-up. Initially, Kitty and Phoebe had decided to limit color selections to make the job of modeling the bicycles easier. However, their Kickstarter campaign indicated a high demand for more color choices. When Kitty tried to solve the problem using inheritance, she found herself faced with a huge number of subclasses. For each model of bicycle and each color, the number of classes grew out of control. Kitty solved the problem by modeling the two dimensions, the bicycle and the paint colors, independently using the Bridge pattern. They were even able to create a system capable of custom gradient paint jobs, to the delight of their Kickstarter backers. Having applied the Bridge pattern, the bicycle and the paint systems can grow independently from each other yet remain related through composition.</p>
<p>At this point, we’ve covered two of the three groups of patterns. Creational patterns helped us with object instantiation. Structural patterns helped us with new ways of thinking about how we build complicated objects with more sophistication than simply using inheritance and composition. The last group, covered in the next chapter, is a set of patterns to help you design “well-behaved” classes with behavioral patterns.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Questions</h1>
<ol>
<li value="1">Why is the Decorator pattern sometimes referred to as a wrapper?</li>
<li>How can you use a decorator to extend a sealed class?</li>
<li>Which pattern is most effective at decoupling complex object structures in a way that allows them to mature separately?</li>
<li>When is the best time to consider using the Façade pattern?</li>
<li>Which pattern allows you to leverage recursion and polymorphism with a tree-like structure?</li>
<li>Have you ever run into a situation where you had to violate SOLID principles? Can you think of any way to avoid Phoebe and Kitty’s resolution when applying the Bridge pattern?</li>
</ol>
<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Further reading</h1>
<ul>
<li>Martin, Robert C., James Newkirk, and Robert S. Koss. <em class="italic">Agile software development: principles, patterns, and practices</em>. Vol. 2. Upper Saddle River, NJ: Prentice Hall, 2003.</li>
<li>Martin, Robert C., and Micah Martin. <em class="italic">Agile principles, patterns, and practices in C# (Robert C. Martin)</em>. Prentice Hall PTR, 2006.</li>
<li>The companion website for this book is <a href="https://www.csharppatterns.dev">https://www.csharppatterns.dev</a>. Go check in and see what’s new.</li>
</ul>
</div>
</div>
</body></html>