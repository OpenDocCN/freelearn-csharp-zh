- en: Facade
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观
- en: The Facade pattern is considered a Structural pattern so, as with most patterns
    of this type, it primarily focuses on identifying simple ways of establishing
    relationships between objects. The Facade pattern is an easy pattern to grasp
    because its name perfectly implies its design. The primary intent of the Facade
    pattern is to offer a simplified front-facing interface that abstracts the intricate
    inner workings of complex systems. This approach is beneficial for game developers
    because games are mostly constructed on layers of complexity and interacting systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式被认为是一种结构模式，因此，与这类模式的大多数模式一样，它主要关注识别建立对象之间简单关系的方法。外观模式是一个容易掌握的模式，因为其名称完美地体现了其设计。外观模式的主要意图是提供一个简化的前端接口，抽象出复杂系统的复杂内部工作。这种方法对游戏开发者来说是有益的，因为游戏主要是建立在复杂层次和交互系统之上的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: We will be reviewing the basics of the Facade pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾外观模式的基础知识
- en: We will use the Facade pattern to implement a save system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用外观模式来实现一个保存系统
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This is a hands-on chapter, so you will need to have a basic understanding of
    Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实践章节，因此你需要对Unity和C#有基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下具体的Unity引擎和C#语言概念：
- en: Singleton
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Serializable
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可序列化
- en: If you're unfamiliar with these concepts, please review them before starting
    this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请在开始本章之前复习它们。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：
- en: '[http://bit.ly/2I30suS](http://bit.ly/2I30suS)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2I30suS](http://bit.ly/2I30suS)'
- en: An overview of the Facade pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式概述
- en: 'The Facade pattern''s name is analogous to a facade in architecture—as the
    name implies, it''s an exterior face that hides a complex structure. But, contrary
    to architecture, in software development, the goal of a Facade is not to beautify,
    but instead to simplify. As we are going to see in the following diagram, the
    implementation of the Facade pattern is usually limited to a single class that
    acts as a simplified interface to a complex array of interdependent sub-systems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式的名字与建筑中的外观类似——正如其名所暗示的，它是一个隐藏复杂结构的表面。但是，与建筑不同，在软件开发中，外观模式的目标不是美化，而是简化。正如我们将在以下图中看到的，外观模式的实现通常仅限于一个充当复杂相互依赖子系统简化接口的单个类：
- en: '![](img/fd5961a2-1b26-4510-8034-d986cbc013ef.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd5961a2-1b26-4510-8034-d986cbc013ef.png)'
- en: As we can see, when a client calls the `SaveGame()` function of `SaveManager`, there's
    a series of calls made to various dependencies and sub-systems (namely `ScoreSystem`,
    `CloudManager`, and `UIManager`). All of this happens behind the scenes; the client
    is unaware of the number of the sub-systems being called to complete his request.
    So, to save the current game's status, the client only needs to know that there's
    a single function in the `SaveManager` class, and the Facade pattern implementation
    does the rest behind the scenes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，当客户端调用`SaveManager`的`SaveGame()`函数时，会有一系列调用到各种依赖和子系统（即`ScoreSystem`、`CloudManager`和`UIManager`）。所有这些都在幕后发生；客户端并不知道需要调用多少个子系统来完成其请求。因此，为了保存当前游戏的状态，客户端只需要知道`SaveManager`类中有一个单一的功能，外观模式实现会在幕后完成剩余的工作。
- en: Benefits and drawbacks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'The Facade pattern has some substantial benefits, but can also present some
    long-term drawbacks:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式有一些实质性的优点，但也可能带来一些长期缺点：
- en: 'The **benefits** are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: '**Simplified interface to a complex body of code**: A solid Facade class will
    hide complexity and dependencies, while providing a simplified interface'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化复杂代码体的接口**：一个稳固的外观类将隐藏复杂性和依赖关系，同时提供一个简化的接口'
- en: '**Localization of all your dependency calls**: The Facade allows you to localize
    and group your dependencies into a single class'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有依赖调用的本地化**：外观模式允许你将依赖关系本地化并分组到一个单独的类中'
- en: '**Easier refactoring**: Having complexity and dependency issues between sub-systems
    isolated in Facade classes simplifies the refactoring process, because you can
    refactor them in isolation without affecting clients, as the interfaces stay consistent'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化重构**：将子系统之间的复杂性和依赖性问题隔离在门面类中简化了重构过程，因为您可以在不影响客户端的情况下独立重构它们，因为接口保持一致'
- en: 'The following are some **drawbacks** to watch out for:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的**缺点**：
- en: '**It makes it easier to hide the mess**: Having an excess of Facade classes
    can make it easier for programmers to disguise lousy code by making their architecture
    look simple to use, while brushing potential long-term architectural issues under
    the carpet.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐藏混乱变得更容易**：拥有过多的门面类可以使程序员更容易通过使他们的架构看起来简单易用来掩盖糟糕的代码，同时将潜在的长远架构问题掩盖起来。'
- en: '**Too many managers**: Manager classes are popular among Unity developers,
    and they often implement them by combining the Singleton and Facade patterns.
    This approach provokes an architecture that becomes an extensive collection of
    globally accessible managers. This type of design becomes very difficult to test
    and manage because the manager classes all become dependent on each other.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过多的管理者**：门面类在Unity开发者中很受欢迎，他们通常通过结合单例和门面模式来实现它们。这种方法会导致一个成为全局可访问管理者的大量集合的架构。这种类型的设计变得非常难以测试和管理，因为所有管理者类都相互依赖。'
- en: The Facade establishes a new interface, whereas the Adapter recycles an old
    interface. It's important, when implementing patterns that might look and sound
    similar, to keep in mind that they're not necessarily identical in purpose.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 门面建立了一个新的接口，而适配器则回收了一个旧的接口。在实现看起来和听起来可能相似的模式时，记住它们的目的不一定相同是很重要的。
- en: An example use case
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个用例示例
- en: 'We are going to build a simple *save game* feature using a combination of the
    Facade and Singleton patterns. Our system has several steps that need to be executed
    in a specific sequence to complete the process of saving the player''s progress.
    Here are the steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用门面和单例模式的组合来构建一个简单的*存档游戏*功能。我们的系统有几个步骤需要按特定顺序执行以完成保存玩家进度的过程。以下是步骤：
- en: Trigger **User Interface** (**UI**) feedback to indicate the game is saving
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发**用户界面**（**UI**）反馈以指示游戏正在保存
- en: Get the current player's data (health, score, ID)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前玩家的数据（健康、分数、ID）
- en: Save the player's data to disk
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将玩家的数据保存到磁盘
- en: Upload the save to the Cloud
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存档上传到云
- en: We must respect the specific order of the preceding steps because we can't save
    to the disk before getting the current state of the player. But having to type
    each step manually in the right sequence every time we want to implement a save
    game event in our scripts can be time-consuming and error-prone. So, we are going
    to use the Facade pattern to establish a simple re-usable interface for our save
    game system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须尊重前面步骤的特定顺序，因为我们不能在获取玩家当前状态之前将数据保存到磁盘。但是，每次我们想要在我们的脚本中实现存档游戏事件时，都必须手动以正确的顺序输入每个步骤，这既耗时又容易出错。因此，我们将使用门面模式为我们的存档游戏系统建立一个简单的可重用接口。
- en: A code example
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'As we are going to see, the Facade pattern is straightforward, so we will keep
    the following code example simple and straight to the point:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，门面模式很简单，所以我们将保持以下代码示例简单直接：
- en: 'First off, we are going to write the classes for each of our sub-system examples:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为每个子系统的示例编写类：
- en: '`Player`: This class represents our player component:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`：这个类代表我们的玩家组件：'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ScoreManager`: This class is responsible for managing the scoring system;
    it will return the current player''s score:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScoreManager`：这个类负责管理评分系统；它将返回当前玩家的分数：'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`CloudManager`: This class is responsible for managing the cloud account of
    the current player, including uploading their local save data:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloudManager`：这个类负责管理当前玩家的云账户，包括上传他们的本地存档数据：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`UIManager`: And finally, the UI manager is responsible for displaying the
    UI components:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIManager`：最后，UI管理器负责显示UI组件：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our next important class is a container that will hold the properties of the
    current player that we want to save. Notice that it''s `Serializable`—this is
    because we are going to serialize an instance of this class when we save it to
    disk:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下一个重要的类是一个容器，它将保存我们想要保存的当前玩家的属性。请注意，它是`Serializable`——这是因为当我们将其保存到磁盘时，我们将序列化这个类的实例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Up next is the actual class that will act as our Facade. To avoid having a
    code example that''s ten pages long, we are going to focus only on writing an
    elementary `SaveManager` class:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们将作为外观实际使用的类。为了避免有一个长达十页的代码示例，我们将只专注于编写一个基本的`SaveManager`类：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see, this small example of a `SaveManager` class presents a core
    problem: saving a player''s progression has many steps and dependencies. Imagine
    if we had to write those steps by hand throughout our code every time we wanted
    to trigger a save game—this would be very difficult to maintain and debug.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个`SaveManager`类的简单示例展示了一个核心问题：保存玩家的进度有许多步骤和依赖。想象一下，如果我们每次想要触发保存游戏时都必须手动编写这些步骤，这将非常难以维护和调试。
- en: 'We can see the benefits of the Facade pattern in action in the following `Client`
    class:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在下面的`Client`类中看到外观模式在实际中的好处：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we can save the current player state from anywhere with just one line of
    code. This benefit is possible because our `SaveManager` is acting like a Facade
    and offering a simplified interface to a larger body of code. We have also localized
    the entire save game process so we can easily maintain it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需一行代码就可以从任何地方保存当前玩家的状态。这种好处之所以可能，是因为我们的`SaveManager`正在充当外观，为更大的代码库提供一个简化的接口。我们还本地化了整个保存游戏过程，这样我们就可以轻松地维护它。
- en: Summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have the Facade pattern in our toolkit. It fits in perfectly with the
    reality of managing a complex code base that has an extensive collection of sub-systems
    that are constantly interacting with each other and are codependent, as in most
    video games. If the Facade pattern is used wisely, and not as a crutch or a way
    to mask messy code, it can become a cornerstone of your architecture. But the
    most critical point to keep in mind is that when you have a feature that relies
    on a collection of sub-systems to operate, it's a good idea to localize those
    dependencies so you can easily debug, maintain, and refactor them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在工具箱中有了外观模式。它完美地适应了管理一个复杂代码库的现实，这个代码库拥有大量不断相互交互且相互依赖的子系统，就像大多数视频游戏一样。如果外观模式被明智地使用，而不是作为一种拐杖或掩盖混乱代码的方式，它可以成为你架构的基石。但最关键的一点是要记住，当你有一个依赖于多个子系统来运行的功能时，将那些依赖项本地化是一个好主意，这样你可以轻松地进行调试、维护和重构。
- en: In the next chapter, we will explore the Adapter pattern, a close cousin of
    the Facade pattern, but with a very different design and intent.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨适配器模式，它是外观模式的一个近亲，但具有非常不同的设计和意图。
- en: Exercises
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In this chapter, we wrote the first draft of a `SaveManager` class. As an exercise,
    try to write for yourself a complete save system for your game. It will be a valuable
    long-term investment if you design one that can be re-usable for multiple projects.
    From experience, I often witness game project's get into difficulty later on in
    their development cycle because they don't have a solid save and serialization
    system in place early on, so having one already prepared in your back pocket can
    very helpful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们编写了`SaveManager`类的第一个草稿。作为一个练习，尝试为你自己的游戏编写一个完整的保存系统。如果你设计的是一个可以用于多个项目的可重用系统，这将是一项有价值的长期投资。从经验来看，我经常看到游戏项目在开发后期遇到困难，因为它们在早期没有建立一个稳固的保存和序列化系统，所以提前准备好一个可以随时使用的系统会非常有帮助。
- en: Further reading
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Programming Patterns* by Robert Nystrom, available here:[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《游戏编程模式》由Robert Nystrom所著，可在以下链接找到：[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)
