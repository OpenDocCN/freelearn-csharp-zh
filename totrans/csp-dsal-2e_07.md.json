["```cs\npublic class TreeNode<T>\n{\n    public T? Data { get; set; }\n    public TreeNode<T>? Parent { get; set; }\n    public List<TreeNode<T>> Children { get; set; } = [];\n    public int GetHeight()\n    {\n        int height = 1;\n        TreeNode<T> current = this;\n        while (current.Parent != null)\n        {\n            height++;\n            current = current.Parent;\n        }\n        return height;\n    }\n}\n```", "```cs\npublic class Tree<T>\n{\n    public TreeNode<T>? Root { get; set; }\n}\n```", "```cs\nTree<int> tree = new() { Root = new() { Data = 100 } };\ntree.Root.Children =\n[\n    new() { Data = 50, Parent = tree.Root },\n    new() { Data = 1, Parent = tree.Root },\n    new() { Data = 150, Parent = tree.Root }\n];\ntree.Root.Children[2].Children =\n[\n    new() { Data = 30, Parent = tree.Root.Children[2] }\n];\n```", "```cs\npublic record Person(string Name, string Role);\n```", "```cs\nTree<Person> company = new()\n{\n    Root = new()\n    {\n        Data = new Person(\"Marcin Jamro\",\n            \"Chief Executive Officer\"),\n        Parent = null\n    }\n};\ncompany.Root.Children =\n[\n    new() { Data = new Person(\"John Smith\",\n        \"Head of Development\"), Parent = company.Root },\n    new() { Data = new Person(\"Alice Batman\",\n        \"Head of Research\"), Parent = company.Root },\n    new() { Data = new Person(\"Lily Smith\",\n        \"Head of Sales\"), Parent = company.Root }\n];\ncompany.Root.Children[2].Children =\n[\n    new() { Data = new Person(\"Anthony Black\",\n        \"Senior Sales Specialist\"),\n        Parent = company.Root.Children[2] }\n];\n```", "```cs\npublic class BinaryTreeNode<T>\n    : TreeNode<T>\n{\n    public new BinaryTreeNode<T>?[] Children { get; set; }\n        = [null, null];\n    public BinaryTreeNode<T>? Left\n    {\n        get { return Children[0]; }\n        set { Children[0] = value; }\n    }\n    public BinaryTreeNode<T>? Right\n    {\n        get { return Children[1]; }\n        set { Children[1] = value; }\n    }\n}\n```", "```cs\npublic class BinaryTree<T>\n{\n    public BinaryTreeNode<T>? Root { get; set; }\n    public int Count { get; set; }\n}\n```", "```cs\nprivate void TraversePreOrder(BinaryTreeNode<T>? node,\n    List<BinaryTreeNode<T>> result)\n{\n    if (node == null) { return; }\n    result.Add(node);\n    TraversePreOrder(node.Left, result);\n    TraversePreOrder(node.Right, result);\n}\n```", "```cs\nprivate void TraverseInOrder(BinaryTreeNode<T>? node,\n    List<BinaryTreeNode<T>> result)\n{\n    if (node == null) { return; }\n    TraverseInOrder(node.Left, result);\n    result.Add(node);\n    TraverseInOrder(node.Right, result);\n}\n```", "```cs\nprivate void TraversePostOrder(BinaryTreeNode<T>? node,\n    List<BinaryTreeNode<T>> result)\n{\n    if (node == null) { return; }\n    TraversePostOrder(node.Left, result);\n    TraversePostOrder(node.Right, result);\n    result.Add(node);\n}\n```", "```cs\npublic List<BinaryTreeNode<T>> Traverse(TraversalEnum mode)\n{\n    List<BinaryTreeNode<T>> nodes = [];\n    if (Root == null) { return nodes; }\n    switch (mode)\n    {\n        case TraversalEnum.PreOrder:\n            TraversePreOrder(Root, nodes);\n            break;\n        case TraversalEnum.InOrder:\n            TraverseInOrder(Root, nodes);\n            break;\n        case TraversalEnum.PostOrder:\n            TraversePostOrder(Root, nodes);\n            break;\n    }\n    return nodes;\n}\n```", "```cs\npublic enum BinaryTree class is GetHeight. It returns the height of the tree, which can be understood as the maximum number of steps to travel from any leaf node to the root. The implementation is as follows:\n\n```", "```cs\n\n After the introduction to the topic of binary trees, let’s see an example where this data structure is used for storing questions and answers in a simple quiz.\nExample – simple quiz\nAs an example of a binary tree, a simple quiz application will be prepared. The quiz consists of a few questions and answers, shown depending on previously taken decisions. The application presents the question, waits until the user presses *Y* (yes) or *N* (no), and proceeds to the next question or shows the answer.\nThe structure of the quiz is created in the form of a binary tree, as follows:\n![Figure 7.7 – ﻿Illustration of the simple quiz example](img/B18069_07_07.jpg)\n\nFigure 7.7 – Illustration of the simple quiz example\nAt the beginning, the user is asked whether they have any experience in application development. If so, the program asks whether they have worked as a developer for more than 5 years. In the case of a positive answer, the result regarding applying to work as a senior developer is presented. Of course, other answers and questions are shown in the case of different decisions taken by the user.\nThe implementation of the simple quiz requires the `BinaryTree` and `BinaryTreeNode` classes, which were presented and explained earlier. Each node stores only a `string` value as data, representing either a question or an answer.\nLet’s take a look at the main part of the code:\n\n```", "```cs\n\n In the first line, the `GetTree` method is called to construct a tree with questions and answers. Such a method will be shown next. Then, the root node is taken as the current node, for which the following operations are taken until an answer is reached.\nAt the beginning, you check whether the left and right child nodes exist – that is, whether it is a question and not an answer. Then, the textual content is written in the console, and the program waits until the user presses a key. If it is equal to *Y*, the current node’s left child is used as the current node. In the case of pressing *N*, the current node’s right child is used instead.\nWhen decisions taken by the user cause an answer to be shown, it is presented in the console, and `null` is assigned to the `node` variable. Therefore, you break out of the `while` loop.\nAs mentioned, the `GetTree` method is used to construct a binary tree with questions and answers. Its code is presented as follows:\n\n```", "```cs\n\n At the beginning, a new instance of the `BinaryTree` generic class is created, and you assign a new instance of `BinaryTreeNode` to the `Root` property.\nWhat is interesting is that even while creating questions and answers programmatically, you create some kind of a tree-like structure because you use the `Children` property and specify items directly within such constructions. Therefore, you do not need to create many local variables for all questions and answers. It is worth noting that a question-related node is an instance of the `BinaryTreeNode` class with two child nodes (for *yes* and *no* decisions), while an answer-related node is a leaf, so it does not contain any child nodes.\nImportant note\nIn the presented solution, the values of the `Parent` property of the `BinaryTreeNode` instances are not set. If you want to use them or get the height of a node or a tree, you should set them on your own.\nThe simple quiz application is ready! You can build the project, launch it, and answer a few questions to see the results. Then, let’s close the program and proceed to the next section, where a variant of the binary tree data structure is presented.\nBinary search trees\nA binary tree is an interesting data structure that allows the creation of a hierarchy of elements, with the restriction that each node can contain at most two children, but without any rules about relationships between the nodes. For this reason, if you want to check whether a binary tree contains a given value, you need to check each node, traversing the tree using one of three available modes: pre-order, in-order, or post-order. This means that the lookup time is linear, namely *O(n)*.\nWhat about a situation where there are some precise rules regarding relations between nodes in a tree? Let’s imagine a scenario where you know that the left subtree contains nodes with values smaller than the root’s value, while the right subtree contains nodes with values greater than the root’s value. Then, you can compare the searched value with the current node and decide whether you should continue searching in the left or right subtree. Such an approach can significantly limit the number of operations necessary to check whether the tree contains a given value. It seems quite interesting, doesn’t it?\nThis approach is applied in the **binary search tree (BST)** data structure. It is a kind of binary tree that introduces two strict rules regarding relations between nodes in the tree. **The rules state that for any node, the values of all nodes in its left subtree must be smaller than its value, and the values of all nodes in its right subtree must be greater than** **its value.**\nCan you add duplicates to BSTs?\nIn general, a BST can contain two or more elements with the same value. However, within this book, a simplified version is given, which does not accept more than one element with the same value.\nHow does it look in practice? Let’s take a look at the following diagram of BSTs:\n![Figure 7.8 – ﻿Illustration of binary search trees.](img/B18069_07_08.jpg)\n\nFigure 7.8 – Illustration of binary search trees.\nThe tree shown on the left-hand side contains 12 nodes. Let’s check whether it complies with the BST rule. You can do so by analyzing each node in the tree, except leaf nodes. Let’s start with the root node (with value **50**), which contains four descendant nodes in the left subtree (**40**, **30**, **45**, **43**), all smaller than **50**. The root node contains seven descendant nodes in the right subtree (**60**, **80**, **70**, **65**, **75**, **90**, **100**), all greater than **50**. That means that the BST rule is satisfied for the root node. While checking the BST rule for node **80**, you see that the values of all descendant nodes in the left subtree (**70**, **65**, **75**) are smaller than **80**, while the values in the right subtree (**90**, **100**) are greater than **80**. You should perform the same verification for all other nodes. Similarly, you can confirm that the BST from the right-hand side of the diagram adheres to the rules.\nHowever, two such BSTs significantly differ in their **topology**. Both have the same height, but the number of nodes is different, namely 12 and 7\\. The one on the left seems to be **fat**, while the other is rather **skinny**. Which one is better? To answer this question, let’s think about the algorithm for searching a value in the tree. As an example, the process of searching for the value **43** is shown in the following diagram:\n![Figure 7.9 – Searching for a given value in a BST](img/B18069_07_09.jpg)\n\nFigure 7.9 – Searching for a given value in a BST\nAt the beginning (**Step 1**), you take a value of the root node (that is, **50**) and check whether the given value (**43**) is smaller or greater. It is smaller, so you proceed to search in the left subtree (**Step 2**). Thus, you compare **43** with **40**. This time, the right subtree is chosen because **43** is greater than **40**. Next, **43** is compared with **45** (**Step 3**), and the left subtree is chosen. Here, you compare **43** with **43**, and the given value is found (**Step 4**). If you take a look at the tree, you will see that only four comparisons are necessary.\nWhat about the performance?\nThe shape of a tree has a great impact on the lookup performance. Of course, **it is much better to have a fat tree with limited height than a skinny tree with a bigger height**. The performance boost is caused by making decisions as to whether searching should be continued in the left or right subtree, without the necessity of analyzing the values of all nodes. If nodes do not have both subtrees, the positive impact on the performance will be limited. In the worst case, when each node contains only one child, the search time is even linear. However, in the ideal BST, the lookup time is an *O(log* *n)* operation.\nAfter this short introduction, let’s proceed to the implementation in the C# language. At the end, you will see an example that shows how to use this data structure in practice.\nImplementation\nThe implementation of a BST is a bit more difficult than the previously described variants of trees. For example, it requires you to prepare operations of insertion and removal of nodes from a tree, which do not break the rule regarding the arrangement of elements in the BST. You will see a solution shortly.\nTree\nThe whole tree is represented by an instance of the `BinarySearchTree` class, which inherits from the `BinaryTree` generic class, as in the following code snippet:\n\n```", "```cs\n\n It is worth mentioning that the type of data, stored in each node, should be comparable. For this reason, it has to implement the `IComparable` interface. Such a requirement is necessary because the algorithm needs to know the relationships between values.\nOf course, it is not the final version of the implementation of the `BinarySearchTree` class. You will very soon learn how to add new features, such as lookup, insertion, and removal of nodes.\nLookup\nNow, let’s take a look at the `Contains` method, which checks whether the tree contains a node with a given value. Of course, this method takes into account the BST rule regarding the arrangement of nodes to limit the number of comparisons. The code is presented in the following block:\n\n```", "```cs\n\n The method takes only one parameter, namely the value to find in the tree. Inside the method, a `while` loop exists. Within it, the searched value is compared with the value of the current node. If they are equal (the comparison returns `0`), the value is found, and `true` is returned to inform that the search is completed successfully. If the searched value is smaller than the value of the current node, the algorithm continues searching in the left subtree. Otherwise, the right subtree is used instead.\nHow to compare objects?\nThe `CompareTo` method is provided by the implementation of the `IComparable` interface from the `System` namespace. Such a method makes it possible to compare two values. If they are equal, `0` is returned. If the object on which the method is called is bigger than the parameter, a value higher than `0` is returned. Otherwise, a value lower than `0` is returned.\nThe loop is executed until the node is found or there is no suitable child node to follow.\nInsertion\nThe next necessary operation is the insertion of a node into a BST. Such a task is a bit more complicated because you need to find a place for adding a new element that will not violate BST rules. Let’s take a look at the code of the `Add` method:\n\n```", "```cs\n\n The method takes one parameter, namely a value that should be added to the tree. Within the method, you find a parent element (using the `GetParentForNewNode` auxiliary method, shown a bit later), where a new node should be added as a child. Then, a new instance of the `BinaryTreeNode` class is created, and the values of its `Data` and `Parent` properties are set.\nIn the following part of the method, you check whether the found parent element is equal to `null`. It means that there are no nodes in the tree, and a new node should be added as the root, which is well visible in the line, where a reference to the node is assigned to the `Root` property.\nThe next comparison checks whether the value for addition is smaller than the value of the parent node. In such a case, a new node should be added as the left child of the parent node. Otherwise, the new node is placed as the right child of the parent node. At the end, the number of elements stored in the tree is incremented.\nLet’s take a look at the auxiliary method for finding the parent element for a new node:\n\n```", "```cs\n\n This method takes one parameter, namely a value of the new node. Within this method, you declare two variables representing the currently analyzed node (`current`) and the parent node (`parent`). Such values are modified in a `while` loop until the algorithm finds a proper place for the new node.\nIn the loop, you store a reference to the current node as the potential parent node. Then, you check whether the value for addition is equal to the value of the current node. If so, an exception is thrown because it is not allowed to add more than one element with the same value to the analyzed version of the BST. If the value for addition is smaller than the value of the current node, the algorithm continues searching for a place for the new node in the left subtree. Otherwise, the right subtree of the current node is used. At the end, the value of the `parent` variable is returned to indicate the found location for the new node.\nRemoval\nYou now know how to create a new BST, add some nodes to it, as well as check whether a given value already exists in the tree. However, can you also remove an item from a tree? Of course! The main method regarding the removal of a node from the tree is named `Remove` and takes only one parameter, namely the value of the node that should be removed. The implementation of the `Remove` method is as follows:\n\n```", "```cs\nprivate void Remove(BinaryTreeNode<T>? node, T data)\n{\n    if (node == null)\n    {\n        return;\n    }\n    else if (data.CompareTo(node.Data) < 0)\n    {\n        Remove(node.Left, data);\n    }\n    else if (data.CompareTo(node.Data) > 0)\n    {\n        Remove(node.Right, data);\n    }\n    else\n    {\n        if (node.Left == null || node.Right == null)\n        {\n            BinaryTreeNode<T>? newNode =\n                node.Left == null && node.Right == null\n                    ? null\n                    : node.Left ?? node.Right;\n            ReplaceInParent(node, newNode!);\n            Count--;\n        }\n        else\n        {\n            BinaryTreeNode<T> successor =\n                FindMinimumInSubtree(node.Right);\n            node.Data = successor.Data;\n            Remove(successor, successor.Data!);\n        }\n    }\n}\n```", "```cs\nprivate void ReplaceInParent(BinaryTreeNode<T> node,\n    BinaryTreeNode<T> newNode)\n{\n    if (node.Parent != null)\n    {\n        BinaryTreeNode<T> parent =\n            (BinaryTreeNode<T>)node.Parent;\n        if (parent.Left == node) { parent.Left = newNode; }\n        else { parent.Right = newNode; }\n    }\n    else { Root = newNode; }\n    if (newNode != null) { newNode.Parent = node.Parent; }\n}\n```", "```cs\nBinaryTreeNode<T> successor =\n    FindMinimumInSubtree(node.Right);\nnode.Data = successor.Data;\nRemove(successor, successor.Data!);\n```", "```cs\nprivate BinaryTreeNode<T> FindMinimumInSubtree(\n    BinaryTreeNode<T> node)\n{\n    while (node.Left != null) { node = node.Left; }\n    return node;\n}\n```", "```cs\nBinarySearchTree<int> tree = new();\ntree.Root = new BinaryTreeNode<int>() { Data = 100 };\ntree.Root.Left = new() { Data = 50, Parent = tree.Root };\ntree.Root.Right = new() { Data = 150, Parent = tree.Root };\ntree.Count = 3;\nVisualize(tree, \"BST with 3 nodes (50, 100, 150):\");\n```", "```cs\ntree.Add(75);\ntree.Add(125);\nVisualize(tree, \"BST after adding 2 nodes (75, 125):\");\n```", "```cs\ntree.Add(25);\ntree.Add(175);\ntree.Add(90);\ntree.Add(110);\ntree.Add(135);\nVisualize(tree, \"BST after adding 5 nodes\n    (25, 175, 90, 110, 135):\");\n```", "```cs\ntree.Remove(25);\nVisualize(tree, \"BST after removing the node 25:\");\ntree.Remove(50);\nVisualize(tree, \"BST after removing the node 50:\");\ntree.Remove(100);\nVisualize(tree, \"BST after removing the node 100:\");\n```", "```cs\nforeach (TraversalEnum mode\n    in Enum.GetValues<TraversalEnum>())\n{\n    Console.Write($\"\\n{mode} traversal:\\t\");\n    Console.Write(string.Join(\", \",\n        tree.Traverse(mode).Select(n => n.Data)));\n}\n```", "```cs\nvoid Visualize(BinarySearchTree<int> tree, string caption)\n{\n    char[,] console = Initialize(tree, out int width);\n    VisualizeNode(tree.Root, 0, width / 2,\n        console, width);\n    Console.WriteLine(caption);\n    Draw(console);\n}\n```", "```cs\nconst int ColumnWidth = 5;\nchar[,] Initialize(BinarySearchTree<int> tree,\n    out int width)\n{\n    int height = tree.GetHeight();\n    width = (int)Math.Pow(2, height) - 1;\n    char[,] console =\n        new char[height * 2, ColumnWidth * width];\n    for (int y = 0; y < console.GetLength(0); y++)\n    {\n        for (int x = 0; x < console.GetLength(1); x++)\n        {\n            console[y, x] = ' ';\n        }\n    }\n    return console;\n}\n```", "```cs\nvoid VisualizeNode(BinaryTreeNode<int>? node, int row,\n    int column, char[,] console, int width)\n{\n    if (node == null) { return; }\n    char[] chars = node.Data.ToString().ToCharArray();\n    int margin = (ColumnWidth - chars.Length) / 2;\n    for (int i = 0; i < chars.Length; i++)\n    {\n        int col = ColumnWidth * column + i + margin;\n        console[row, col] = chars[i];\n    }\n    int columnDelta = (width + 1) /\n        (int)Math.Pow(2, node.GetHeight() + 1);\n    VisualizeNode(node.Left, row + 2,\n        column - columnDelta, console, width);\n    VisualizeNode(node.Right, row + 2,\n        column + columnDelta, console, width);\n    DrawLineLeft(node, row, column, console, columnDelta);\n    DrawLineRight(node, row, column, console, columnDelta);\n}\n```", "```cs\nvoid DrawLineLeft(BinaryTreeNode<int> node, int row,\n    int column, char[,] console, int columnDelta)\n{\n    if (node.Left == null) { return; }\n    int sci = ColumnWidth * (column - columnDelta) + 2;\n    int eci = ColumnWidth * column + 2;\n    for (int x = sci + 1; x < eci; x++)\n    {\n        console[row + 1, x] = '-';\n    }\n    console[row + 1, sci] = '+';\n    console[row + 1, eci] = '+';\n}\n```", "```cs\nvoid DrawLineRight(BinaryTreeNode<int> node, int row,\n    int column, char[,] console, int columnDelta)\n{\n    if (node.Right == null) { return; }\n    int sci = ColumnWidth * column + 2;\n    int eci = ColumnWidth * (column + columnDelta) + 2;\n    for (int x = sci + 1; x < eci; x++)\n    {\n        console[row + 1, x] = '-';\n    }\n    console[row + 1, sci] = '+';\n    console[row + 1, eci] = '+';\n}\n```", "```cs\nvoid Draw(char[,] console)\n{\n    for (int y = 0; y < console.GetLength(0); y++)\n    {\n        for (int x = 0; x < console.GetLength(1); x++)\n        {\n            Console.Write(console[y, x]);\n        }\n        Console.WriteLine();\n    }\n}\n```", "```cs\nPre-order traversal:    110, 75, 90, 150, 125, 135, 175\nIn-order traversal:     75, 90, 110, 125, 135, 150, 175\nPost-order traversal:   90, 75, 135, 125, 175, 150, 110\n```", "```cs\npublic class TrieNode\n{\n    public TrieNode[] Children { get; set; }\n        = new TrieNode[26];\n    public bool IsWord { get; set; } = false;\n}\n```", "```cs\npublic class Trie\n{\n    private readonly TrieNode _root = new();\n}\n```", "```cs\npublic bool DoesExist(string word)\n{\n    TrieNode current = _root;\n    foreach (char c in word)\n    {\n        TrieNode child = current.Children[c - 'a'];\n        if (child == null) { return false; }\n        current = child;\n    }\n    return current.IsWord;\n}\n```", "```cs\npublic void Insert(string word)\n{\n    TrieNode current = _root;\n    foreach (char c in word)\n    {\n        int i = c - 'a';\n        current.Children[i] = current.Children[i] ?? new();\n        current = current.Children[i];\n    }\n    current.IsWord = true;\n}\n```", "```cs\npublic List<string> SearchByPrefix(string prefix)\n{\n    TrieNode current = _root;\n    foreach (char c in prefix)\n    {\n        TrieNode child = current.Children[c - 'a'];\n        if (child == null) { return []; }\n        current = child;\n    }\n    List<string> results = [];\n    GetAllWithPrefix(current, prefix, results);\n    return results;\n}\n```", "```cs\nprivate void GetAllWithPrefix(TrieNode node,\n    string prefix, List<string> results)\n{\n    if (node == null) { return; }\n    if (node.IsWord) { results.Add(prefix); }\n    for (char c = 'a'; c <= 'z'; c++)\n    {\n        GetAllWithPrefix(node.Children[c - 'a'],\n            prefix + c, results);\n    }\n}\n```", "```cs\nTrie trie = new();\ntrie.Insert(\"algorithm\");\ntrie.Insert(\"aid\");\ntrie.Insert(\"aim\");\ntrie.Insert(\"air\");\ntrie.Insert(\"ai\");\ntrie.Insert(\"airport\");\ntrie.Insert(\"airplane\");\ntrie.Insert(\"allergy\");\ntrie.Insert(\"allowance\");\ntrie.Insert(\"all\");\ntrie.Insert(\"allow\");\nbool isAir = trie.DoesExist(\"air\");\nList<string> words = trie.SearchByPrefix(\"ai\");\nforeach (string word in words)\n{\n    Console.WriteLine(word);\n}\n```", "```cs\nai\naid\naim\nair\nairplane\nairport\n```", "```cs\nAfghanistan\nAlbania\nAlgeria (...)\nPakistan\nPalau\nPanama\nPapua New Guinea\nParaguay\nPeru\nPhilippines\nPoland\nPortugal (...)\nZambia\nZimbabwe\n```", "```cs\nusing System.Text.RegularExpressions;\nTrie trie = new();\nstring[] countries =\n    await File.ReadAllLinesAsync(\"Countries.txt\");\nforeach (string country in countries)\n{\n    Regex regex = new(\"[^a-z]\");\n    string name = country.ToLower();\n    name = regex.Replace(name, string.Empty);\n    trie.Insert(name);\n}\n```", "```cs\nstring text = string.Empty;\nwhile (true)\n{\n    Console.Write(\"Enter next character: \");\n    ConsoleKeyInfo key = Console.ReadKey();\n    if (key.KeyChar < 'a' || key.KeyChar > 'z') { return; }\n    text = (text + key.KeyChar).ToLower();\n    List<string> results = trie.SearchByPrefix(text);\n    if (results.Count == 0) { return; }\n    Console.WriteLine(\n        $\"\\nSuggestions for {text.ToUpper()}:\");\n    results.ForEach(r => Console.WriteLine(r.ToUpper()));\n    Console.WriteLine();\n}\n```", "```cs\nEnter next character: p\nSuggestions for P:\nPAKISTAN\nPALAU\nPANAMA\nPAPUANEWGUINEA\nPARAGUAY\nPERU\nPHILIPPINES\nPOLAND\nPORTUGAL\nEnter next character: o\nSuggestions for PO:\nPOLAND\nPORTUGAL\nEnter next character: l\nSuggestions for POL:\nPOLAND\nEnter next character: e\n```", "```cs\n\n```"]