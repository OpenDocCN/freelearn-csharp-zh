<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Decorator</h1>
                </header>
            
            <article>
                
<p>The Decorator is one of those rare patterns where the name represents its purpose perfectly. As its name implies, the Decorator pattern permits us to decorate an object; this is, of course, a very vague explanation. So, a more concrete but simple explanation of its core purpose is that it offers us a way to decorate old code with new code, by dynamically adding functionality to an object.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will review the basics of the Decorator pattern</li>
<li>We will build a system to add attachments to a rifle dynamically</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter is hands-on, so you will need to have a basic understanding of Unity and C#.<br/></p>
<p>We will be using the following specific Unity engine and C# language concept:</p>
<ul>
<li>Constructors</li>
</ul>
<p>If you are unfamiliar with this concept, please review it before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2U0MT6x">http://bit.ly/2U0MT6x</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The basics of the Decorator pattern</h1>
                </header>
            
            <article>
                
<p>The Decorator pattern is the type of pattern that you would need to implement in code in order to fully understand, so we are going to keep the theory section brief. In its most basic form, the Decorator pattern offers us a mechanism that permits us to add behaviors to objects at runtime without altering the objects in the process.</p>
<p>As its name implies, it decorates objects; but it does so by chaining references of decorator objects through the constructor of a base class. It might sound abstract, but in practice it works, because of the way objects refer to each other in memory.</p>
<p>Let's look at the following diagram in order to visualize the relationship structure between classes in the Decorator pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3d39cef-7c29-4fb1-8c3b-c7fe649bc279.png" style="width:42.25em;height:37.08em;"/></p>
<p>As you can see, there's an interface, <kbd>IRifle</kbd>, which is offering an implementation contract to all classes that want to be rifles. But, the most important class in the diagram is the <kbd>RifleDecorator</kbd>. It's the class that will permit us to attach the <kbd>WithScope</kbd> and <kbd>WithStabilizer</kbd> decorators to any rifle object that implements <kbd>IRifle</kbd>.</p>
<p>But, before writing this in code, let's review some of the core benefits and possible drawbacks when using the Decorator pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks</h1>
                </header>
            
            <article>
                
<p>The Decorator pattern has an excellent reputation; it's even a significant part of the Python language. So, its benefits often outweigh its drawbacks, as we can see in the following list:</p>
<p>The following are the benefits:</p>
<ul>
<li><strong>Alternative to subclassing</strong>: The Decorator pattern focuses on injecting functionality into an object, instead of inheriting and then extending.</li>
<li><strong>Manageable permutations</strong>: Features and requirements change all the time during production; the Decorator pattern offers a way to add functionality by distributing it through self-contained components, without modifying core implementations.</li>
<li><strong>Runtime dynamics</strong>: The Decorator pattern permits us to add functionality to an object at runtime without modifying it directly.</li>
</ul>
<p>The following are the drawbacks:</p>
<ul>
<li><strong>Code complexity</strong>: Like most advanced patterns, implementing the Decorator pattern can result in a more complex code base.</li>
<li><strong>Relationship complexity</strong>: Keeping track of the chain of initialization and the relationships between decorators can become very complicated if there are multiple layers of decorators around an object.</li>
</ul>
<div class="packt_infobox">The drawbacks of specific patterns are often related to the complexity and verbosity they add to a code base. It's mostly an issue when working in a team of members with various levels of experience, because junior programmers might not have the skills to recognize specific patterns just by reading the code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case example</h1>
                </header>
            
            <article>
                
<p>Weapons are an essential element of video games, especially in the first-person shooter (FPS) genre. A very cool and profitable feature to have in an FPS is weapon customization. The ability to upgrade a basic rifle by attaching new components to it, such as a scope or silencer, is very engaging. But, as a game programmer, having to write all these variations and configurations in code, in a structured and modular manner, can be very complicated.<br/>
<br/>
But, with the Decorator pattern, we can reproduce the real-life concept of attaching components to a configurable weapon in code. This is what we are going to do in the following code example.</p>
<div class="packt_infobox">The Adapter and Decorator patterns are similar, but Adapter is used to adapt an object's interface, while Decorator enhances an object’s responsibilities.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>A particular thing to keep in mind in the following code example is that we are going to use constructors. It's often recommended not to use them in Unity, because if you are working with <kbd>Monobehaviours</kbd> or <kbd>ScritableObjects</kbd> derived classes and you attach them to <kbd>GameObjects</kbd> included in a scene, the engine will automatically initialize them. But, in this example, we are going to break this rule; mainly because the Decorator is dependent on the internal mechanisms of the constructor, as we are going to see in the following code snippets:</p>
<ol>
<li>Let's begin the implementation of our weapon customization system by writing an interface that will be used as an <em>implementation</em> <em>contract</em> for all our derived rifle types:</li>
</ol>
<pre style="padding-left: 60px">public interface IRifle<br/>{<br/>    float GetAccuracy();<br/>}</pre>
<p style="padding-left: 60px">As we can see, it's a simple interface with one function that returns the accuracy value of a rifle as a float.</p>
<ol start="2">
<li>Now that we have a standard interface for all our rifle objects, let's write a concrete rifle class that will represent a basic configuration of a rifle:</li>
</ol>
<p class="mce-root"/>
<pre style="padding-left: 60px">public class BasicRifle : IRifle<br/>{<br/>    private float m_BasicAccurancy = 5.0f;<br/><br/>    public float GetAccuracy()<br/>    {<br/>        return m_BasicAccurancy;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>BasicRifle</kbd> class is doing nothing special; it just implements the <kbd>IRifle</kbd> interface; but we are going to use it as a foundation object that we are going to decorate with attachments that will upgrade its default accuracy.</p>
<ol start="3">
<li>We now need a class that will take the responsibility of attaching the decorators to our <kbd>BasicRifle</kbd> object:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">abstract public class RifleDecorator : IRifle<br/>{<br/>    protected IRifle m_DecoaratedRifle;<br/><br/>    public RifleDecorator(IRifle rifle)<br/>    {<br/>        m_DecoaratedRifle = rifle;<br/>    }<br/><br/>    public virtual float GetAccuracy()<br/>    {<br/>        return m_DecoaratedRifle.GetAccuracy();<br/>    }<br/>}</pre>
<p style="padding-left: 60px">We are implementing the core of the Decorator pattern in the <kbd>RifleDecorator</kbd> class. We can see that the <kbd>RifleDecorator</kbd> class is implementing the <kbd>IRifle</kbd> interface, but there's a small detail that's very important to notice. The <kbd>GetAccuracy()</kbd> function is virtual, which means that any derived class of <kbd>RifleDecorator</kbd> will be able to override it.</p>
<ol start="4">
<li>Now that we have our Decorator class, let's see how an actual decorator object will attach itself to our <kbd>BasicRifle</kbd> object during runtime:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">public class WithScope : RifleDecorator<br/>{<br/>    private float m_ScopeAccurancy = 20.0f;<br/>    <br/>    // Constructor<br/>    public WithScope(IRifle rifle) : base(rifle) {}<br/><br/>    public override float GetAccuracy()<br/>    {<br/>        return base.GetAccuracy() + m_ScopeAccurancy;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The first thing to notice is the constructor; it takes an <kbd>IRifle</kbd> type object as an argument, and then calls its base constructor. This approach might seem very tangled at first view, but it's going to become clear once we implement the client side of this example. Another detail to note is that we are overriding the <kbd>GetAccuracy()</kbd> function, but also changing the overall accuracy of the rifle by adding <kbd>m_ScopeAccurancy</kbd> to the base value in the return path.</p>
<ol start="5">
<li>To showcase the flexibility of the Decorator pattern, let's add another decorator to our example:</li>
</ol>
<pre style="padding-left: 60px">public class WithStabilizer : RifleDecorator<br/>{<br/>    private float m_StabilizerAccurancy = 10.0f;<br/>    <br/>    // Constructor<br/>    public WithStabilizer(IRifle rifle) : base(rifle) {}<br/><br/>    public override float GetAccuracy()<br/>    {<br/>        return base.GetAccuracy() + m_StabilizerAccurancy;<br/>    }<br/>}</pre>
<p style="padding-left: 60px"><kbd>WithStabilizer</kbd> has the same implementation as the <kbd>WithScope</kbd>, except for the final accuracy value that it returns.</p>
<ol start="6">
<li>Now, it's time to implement the client; this is where we are going to trigger the decoration feature of the Decorator pattern:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown("b"))<br/>        {<br/>            IRifle rifle = new BasicRifle();<br/>            Debug.Log("Basic accuracy: " + rifle.GetAccuracy()); <br/>        }<br/><br/>        if (Input.GetKeyDown("s"))<br/>        {<br/>            IRifle rifle = new BasicRifle();<br/>            rifle = new WithScope(rifle);<br/>            Debug.Log("WithScope accuracy: " + rifle.GetAccuracy()); <br/>        }<br/><br/>        if (Input.GetKeyDown("t"))<br/>        {<br/>            IRifle rifle = new BasicRifle();<br/>            rifle = new WithScope(new WithStabilizer(rifle));<br/>            Debug.Log("Stabilizer+Scope accuracy: " + <br/>            rifle.GetAccuracy()); <br/>        }<br/>    }<br/>}</pre>
<p>The most important element to notice in this class is the chaining of the constructor calls in the following line:</p>
<pre style="padding-left: 60px">rifle = new WithScope(new WithStabilizer(rifle));</pre>
<p>With this line of code, we are basically attaching the <kbd>WithScope</kbd> and <kbd>WithStabilizer</kbd> decorators to a <kbd>BasicRifle</kbd> instance by chaining them with the base constructor.</p>
<p>So, we can now get different accuracy outputs depending on how many attachments we attach to the <kbd>BasicRifle</kbd> instance, as follows. </p>
<p><span>The following code returns accuracy of </span><kbd>5.0f</kbd>:</p>
<pre>IRifle rifle = new BasicRifle();<br/>rifle.GetAccuracy();</pre>
<p>The following code returns accuracy of <kbd>25.0f</kbd>:</p>
<pre>IRifle rifle = new WithScope(rifle);<br/>rifle.GetAccuracy();</pre>
<p><span>The following code r</span>eturns accuracy of <kbd>35.0f</kbd>:</p>
<pre class="mce-root">IRifle rifle = new WithScope(new WithStabilizer(rifle));<br/>rifle.GetAccuracy();</pre>
<p>So, by using the Decorator pattern, we now have an underlying implementation of a dynamic weapon customization system that we can extend to build a collection of runtime attachments for our game's weaponry.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we reviewed a pattern that offers a game programmer a flexible way to implement an often requested feature – weapon customization. It appears that the Decorator pattern was perfectly designed to accomplish this type of task. But, as you can imagine, the Decorator can be used to implement all kinds of customizable systems and features, such as the following:</p>
<ul>
<li>Vehicle upgrades</li>
<li>Armour and clothing</li>
</ul>
<p>In the next chapter, we will transition out of Behavioral patterns and will instead focus on Decouplers, starting with the Event Bus.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Practice</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we decided to use native C# constructors, which is proper because we were not using <kbd>MonoBehaviours</kbd> or <kbd>ScritableObjects</kbd>. But this not always the case, so, as an exercise, you should try to refactor the code example we just completed, but without any constructors and primarily using native Unity <kbd>MonoBehaviours</kbd> and <kbd>ScriptableObjects</kbd>.</p>
<p>You can find hints on how to accomplish this in the official Unity API documentation on <kbd>ScriptableObjects</kbd>; please check the <em>Further reading</em> section for more information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Unity – Scripting API: ScriptableObject<br/></em><a href="https://docs.unity3d.com/ScriptReference/ScriptableObject.html">https://docs.unity3d.com/ScriptReference/ScriptableObject.html</a></li>
<li><span><em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm<br/>
<a href="http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610">http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610</a><a href="http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610"/></span></li>
</ul>


            </article>

            
        </section>
    </body></html>