<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer068">
<h1 class="chapter-number" id="_idParaDest-156"><a id="_idTextAnchor165"/>10</h1>
<h1 id="_idParaDest-157"><a id="_idTextAnchor166"/>Working with Remote Data</h1>
<p>So far, we’ve dug deep into MVVM and .NET MAUI, covering everything from the basics of the MVVM design, from data binding and Dependency Injection to navigation and handling user input. But there’s one big piece of the puzzle we haven’t tackled yet: getting data from <span class="No-Break">the internet.</span></p>
<p>It’s hard to imagine an app these days that doesn’t talk to an online service to grab fresh data. Adding backend communications also means we need to tackle some architectural challenges such as maintaining separation of concerns, building your app with maintainability in mind, and <span class="No-Break">so on.</span></p>
<p>Here’s what we’ll dive into in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Revisiting the <span class="No-Break">model architecture</span></li>
<li>API communication <span class="No-Break">with Refit</span></li>
<li>API communication <span class="No-Break">from ViewModels</span></li>
</ul>
<p>By the end of this chapter, our <em class="italic">Recipes!</em> app will be more than just a standalone thing. It’ll communicate with a backend service to fetch fresh data and push updates. We’re going to equip it with the essential tools and skills needed for solid <span class="No-Break">MVVM apps.</span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor167"/>Technical requirements</h1>
<p>In this chapter, we update the general architecture of the <em class="italic">Recipes!</em> app to better facilitate communication with remote APIs. To ensure you’re on the same page, all resources and code snippets are available on GitHub: <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10</a>. If you wish to code along, start with the code in the <strong class="source-inline">Start</strong> folder, which has been refactored to serve as the foundation for this chapter. Upon completion, you can compare your work with the <strong class="source-inline">Finish</strong> folder to see the <span class="No-Break">finalized version.</span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor168"/>Revisiting the model architecture</h1>
<p>In our journey so far, our model has been straightforward. We simply used services that read local JSON <a id="_idIndexMarker667"/>files and fed <strong class="bold">Data Transfer Objects (DTOs)</strong> directly to our ViewModels. But as we introduce remote data, this simplistic model <span class="No-Break">won’t suffice.</span></p>
<p>A straightforward approach would be to make an API call directly within our service and pass the resulting DTOs to our ViewModels. However, leaning on the principle of SoC, I believe services <a id="_idIndexMarker668"/>shouldn’t be making API calls. Moreover, using API-specific DTOs directly within our ViewModels is a slippery slope. It tightly couples our application with the external API, which can lead to maintenance nightmares, especially if the API changes often or isn’t under <span class="No-Break">our control.</span></p>
<p>Instead, I advocate <a id="_idIndexMarker669"/>for mapping these DTOs to <strong class="bold">Plain Old CLR Objects (POCOs)</strong>, or entities or domain models – whatever you prefer to name them. The core idea? Work with types we own <span class="No-Break">and control.</span></p>
<p class="callout-heading">Tip</p>
<p class="callout">By keeping the interaction points between our app and the API to a minimum, our code will be less impacted by potential API changes, <span class="No-Break">enhancing maintainability.</span></p>
<p>To realize this, we’ll introduce <a id="_idIndexMarker670"/>the concept of <strong class="bold">repositories</strong> in our architecture. These repositories will interface with the API (or any data source), fetch the DTOs, map them to our domain models, and then supply them to our services and ViewModels. The following diagram captures this <span class="No-Break">envisioned architecture:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 10.1: Architectural overview" height="553" src="image/B20941_10_01.jpg" width="1317"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: Architectural overview</p>
<p>Now, one might ask: is this really needed? Can’t we just directly call an API from a service while using DTOs in our ViewModels? The answer is no, it is not needed; you can perfectly well <a id="_idIndexMarker671"/>call an API from a service if you want. This can definitely work for smaller “dumb” apps where all the business logic is done on the server. But as we scale or tackle more complex scenarios, thoughtful architecture becomes crucial for <span class="No-Break">several reasons:</span></p>
<ul>
<li><strong class="bold">Separation of concerns</strong>: By introducing repositories, we distinctly segregate the roles within <a id="_idIndexMarker672"/>our system. Repositories are primarily concerned with fetching data from a data source – be it an API or another data store – and then translating it into a format our services can readily use. Positioning the repository layer outside of the core project not only emphasizes its distinct responsibility but also ensures that changes or expansions to data sources don’t interfere with the core business logic. This separation enhances the system’s adaptability and maintainability. It becomes clear that the repository’s sole purpose is data retrieval, acting as a thin layer that fetches data from various sources and feeds it to the core services. With repositories acting as intermediaries, changes to the data source or alterations to the data structure are centralized, <span class="No-Break">streamlining modifications.</span></li>
<li><strong class="bold">Improved testability</strong>: By <a id="_idIndexMarker673"/>introducing a repository layer, we enhance our app’s testability. With repositories in place, we can effortlessly mock the data layer in our tests. This abstraction ensures our tests focus on the logic within our services, free from dependencies on external data sources. In <a href="B20941_13.xhtml#_idTextAnchor223"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Unit Testing</em>, we will be looking at this in much <span class="No-Break">more detail.</span></li>
<li><strong class="bold">Augmented services</strong>: The service layer remains free to introduce additional features <a id="_idIndexMarker674"/>such as caching, business logic, or data aggregation from multiple repositories. This decoupling means services aren’t tied directly to specific data sources and can <span class="No-Break">evolve independently.</span></li>
</ul>
<p>Before we dive deep into the concepts of repositories and other details, let’s explore the solution found in the <strong class="source-inline">Start</strong> folder of this chapter’s accompanying code base to understand the changes that have <span class="No-Break">been made.</span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor169"/>Updates to the codebase</h2>
<p>As we journey deeper into creating a robust MVVM architecture, it’s crucial to familiarize <a id="_idIndexMarker675"/>ourselves with changes and additions that <a id="_idIndexMarker676"/>have been made to the code base. If you take a look at the <strong class="source-inline">Start</strong> folder of the accompanying repository for this chapter, you’ll notice some changes. Here are <span class="No-Break">notable updates:</span></p>
<ul>
<li>A <strong class="source-inline">Recipes.Web.Api</strong> API project has been added. At its core, it still reads from local JSON files, reminiscent of our earlier services. The implementation of the API is pretty bare-bones and only for <span class="No-Break">demo purposes.</span></li>
<li>The new <strong class="source-inline">Recipes.Shared</strong> project holds the DTOs that the API returns <span class="No-Break">and accepts.</span></li>
<li>In the <strong class="source-inline">Features</strong> folder of the <strong class="source-inline">Recipes.Client.Core</strong> project, we’ve added new POCO or domain entities. These are reflections of our DTOs but designed to be entirely under our control, ensuring a smoother integration with the rest of our <span class="No-Break">app’s infrastructure.</span></li>
<li>A new <strong class="source-inline">Recipes.Client.Repositories</strong> project has been created. This project will hold the implementations of the repositories that we will be creating. The idea is to keep them separate from the <strong class="source-inline">Recipes.Client.Core</strong> project so that the core project is completely isolated from the API and its DTOs. This project also contains mappers that map the DTOs returned by the API to POCO entities that we will be using throughout <span class="No-Break">the app.</span></li>
<li>The services <a id="_idIndexMarker677"/>and ViewModels no longer depend <a id="_idIndexMarker678"/>upon DTOs. Now, they interact solely with our own POCOs, ensuring a clean and <span class="No-Break">maintainable architecture.</span></li>
<li>The <strong class="source-inline">ratings.json</strong> and <strong class="source-inline">recipedetails.json</strong> files have been removed from the <strong class="source-inline">Recipes.Mobile</strong> project as we are going to fetch our data from <span class="No-Break">the API.</span></li>
<li>The registrations of <strong class="source-inline">IRecipeService</strong> and <strong class="source-inline">IRatingsService</strong> in the <strong class="source-inline">MauiProgram</strong> class have been updated to <span class="No-Break">the following:</span><pre class="source-code">
builder.Services.AddTransient&lt;IRatingsService,
  RatingsService&gt;();
builder.Services.AddTransient&lt;IRecipeService,
  RecipeService&gt;();</pre></li> </ul>
<p>These changes set the stage for the introduction of repositories and interactions with <span class="No-Break">the API.</span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor170"/>Always return a result</h2>
<p>In conventional coding, exceptions are commonly used to indicate failure. While they’re useful for <em class="italic">exceptional</em> cases, they might not be the best choice for regular, expected error scenarios. Using exceptions for expected errors can clutter the code and make it harder <span class="No-Break">to follow.</span></p>
<p>That’s why I <a id="_idIndexMarker679"/>tend to use a <strong class="source-inline">Result&lt;TSuccess&gt;</strong> object to handle such cases. This object acts as a wrapper around the <a id="_idIndexMarker680"/>data we expect on success (<strong class="source-inline">TSuccess</strong>) and provides fields for an error code, error data, and an <strong class="source-inline">Exception</strong> error in the case of failure. It’s a very simple and convenient wrapper, as you can <span class="No-Break">see here:</span></p>
<pre class="source-code">
public sealed class Result&lt;TSuccess&gt;
{
    ...
    public bool IsSuccess { get; }
    public TSuccess? Data { get; }
    public string? ErrorCode { get; }
    public string? ErrorData { get; }
    public Exception? Exception { get; }
    private Result(TSuccess? data,
        string? errorCode, string? errorData,
        Exception? exception, bool isSuccess)
    {
        Data = data;
        ErrorCode = errorCode;
        ErrorData = errorData;
        Exception = exception;
        IsSuccess = isSuccess;
    }
}</pre> <p>As the <a id="_idIndexMarker681"/>following code block shows, this class also <a id="_idIndexMarker682"/>contains some static methods that instantiate a <strong class="source-inline">Success</strong> or <strong class="source-inline">Fail</strong> <strong class="source-inline">Result</strong> object, facilitating the usage of <span class="No-Break">this object:</span></p>
<pre class="source-code">
public static Result&lt;TSuccess&gt; Success(TSuccess data)
    =&gt; new Result&lt;TSuccess&gt;(data, null, null, null, true);
public static Result&lt;TSuccess&gt; Success()
    =&gt; new Result&lt;TSuccess&gt;(default, null, null,
        null, true);
public static Result&lt;TSuccess&gt; Fail(string errorCode,
  string? errorData = null, Exception? exception = null)
    =&gt; new Result&lt;TSuccess&gt;(default, errorCode,
        errorData, exception, false);
public static Result&lt;TSuccess&gt; Fail(Exception exception)
    =&gt; new Result&lt;TSuccess&gt;(default, nameof(exception),
        exception.Message, exception, false);</pre> <p>By using <a id="_idIndexMarker683"/>the <strong class="source-inline">Result</strong> object, we can easily distinguish between two types <span class="No-Break">of errors:</span></p>
<ul>
<li><strong class="bold">Unexpected errors</strong>: These <a id="_idIndexMarker684"/>are real “exceptions” that we <a id="_idIndexMarker685"/>can’t predict and don’t know how to handle. They are still best managed by <span class="No-Break">throwing exceptions.</span></li>
<li><strong class="bold">Expected errors</strong>: These <a id="_idIndexMarker686"/>include scenarios such as validation <a id="_idIndexMarker687"/>failures or transient network issues. For these, we use our <span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break"> object.</span></li>
</ul>
<p>For example, a mobile <a id="_idIndexMarker688"/>app unable to retrieve data isn’t an exceptional case; it’s a scenario we should plan for. The <strong class="source-inline">Result</strong> object allows us to handle such situations gracefully without resorting to exceptions. It offers a richer context than simply returning <strong class="source-inline">null</strong> or <strong class="source-inline">false</strong>, letting us understand why an operation failed. This even works when we talk to an API that we don’t control: this is just a simple wrapper around <span class="No-Break">an object.</span></p>
<p>The <strong class="source-inline">Result</strong> object brings clarity and consistency to our code. It removes uncertainties such as “<em class="italic">Can this method throw an exception? If so, what type? Is it the same exception type thrown in </em><span class="No-Break"><em class="italic">similar scenarios?</em></span><span class="No-Break">”</span></p>
<p class="callout-heading">Errors versus exceptions</p>
<p class="callout">By segregating expected errors from true exceptions, we make the code more readable and maintainable. It lets exceptions be what they should be: indicators of critical, <span class="No-Break">unexpected failures.</span></p>
<p>As we extend our <em class="italic">Recipes!</em> app to communicate with a backend API, the chances for various types of errors increase significantly. To prepare for this complexity, we’ll be wrapping the <a id="_idIndexMarker689"/>return values of our services and <a id="_idIndexMarker690"/>repositories in a <strong class="source-inline">Result</strong> object. This approach not only helps us deal effectively with expected errors but also brings a level of standardization and clarity to our error-handling strategy. Let’s see how this <strong class="source-inline">Result</strong> object brings elegance and robustness to <span class="No-Break">the ViewModels.</span></p>
<h3>Putting the Result object to work</h3>
<p>The following <a id="_idIndexMarker691"/>code snippet shows how the <strong class="source-inline">Result</strong> object can gracefully handle both successful and unsuccessful outcomes in <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">RecipeRatingsDetailViewModel</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
private async Task LoadData(RecipeDetail recipe)
{
...
    var loadRatings = await
        ratingsService.LoadRatings(recipe.Id);
    if(loadRatings.IsSuccess)
    {
        GroupedReviews = loadRatings.Data
        ...
        .ToList();
    }
    else
    {
        var shouldRetry = await dialogService.AskYesNo(
            "Failed to load", "Retry?");
        if (shouldRetry)
            await LoadData(recipe);
        else
            await navigationService.GoBack();
    }
}</pre> <p>This example underscores the elegance and robustness the <strong class="source-inline">Result</strong> object brings to our ViewModels. By using the <strong class="source-inline">IsSuccess</strong> property, we can immediately determine the success <a id="_idIndexMarker692"/>of the operation. If it’s successful, we proceed to work with the data we’ve received. If not, we offer the user a chance to retry or go back. Additionally, the <strong class="source-inline">Result</strong> object also contains valuable error information in <strong class="source-inline">ErrorMessage</strong>, <strong class="source-inline">ErrorCode</strong>, and <strong class="source-inline">Exception</strong>, allowing us to tailor our error-handling strategy, such as displaying specific error messages to the user. This approach removes the necessity of adding exception-handling sections across our ViewModels, leading to a cleaner, easier-to-read, and more maintainable <span class="No-Break">code structure.</span></p>
<p>If we would like <a id="_idIndexMarker693"/>to leverage C# <strong class="bold">pattern matching</strong> abilities, we could make the preceding code even more elegant, <span class="No-Break">like so:</span></p>
<pre class="source-code">
if (loadRatings is { IsSuccess: true, Data: var ratings })
{
    GroupedReviews = ratings
    ...
    .ToList();
}
else
{
    ...
}</pre> <p>By using <a id="_idIndexMarker694"/>pattern matching, we could check for the <strong class="source-inline">Result</strong> object’s <strong class="source-inline">IsSuccess</strong> property to be <strong class="source-inline">true</strong>, and in the same statement, assign the <strong class="source-inline">Result</strong> object’s <strong class="source-inline">Data</strong> property to the <strong class="source-inline">ratings</strong> variable. This allows us to access the <strong class="source-inline">Data</strong> property more easily through the <strong class="source-inline">ratings</strong> variable inside that <strong class="source-inline">if</strong> block. Now that we have a good understanding of the <strong class="source-inline">Result</strong> object, we can start adding repositories to <span class="No-Break">our architecture.</span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor171"/>Adding repository interfaces</h2>
<p>Let’s start <a id="_idIndexMarker695"/>adding repositories, the pieces of <a id="_idIndexMarker696"/>code that will directly interact with <span class="No-Break">our API:</span></p>
<ol>
<li>In the <strong class="source-inline">Recipes.Client.Core</strong> project, add an interface called <strong class="source-inline">IRecipeRepository</strong> to the <strong class="source-inline">Features/Recipes</strong> folder. Here’s what this interface <span class="No-Break">looks like:</span><pre class="source-code">
public interface IRecipeRepository
{
    Task&lt;Result&lt;LoadRecipesResponse&gt;&gt; LoadRecipes(
        int pageSize = 7, int page = 0);
    Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(string id);
}</pre><p class="list-inset">This interface defines the contract that any class needs to implement in order to be able to fetch recipes from a data source. There are two methods defined in this interface: <strong class="source-inline">LoadRecipes</strong> and <strong class="source-inline">LoadRecipe</strong>. The first method returns a <strong class="source-inline">LoadRecipesResponse</strong> object, which is a response containing a paged collection of recipes. The second method returns a <strong class="source-inline">RecipeDetail</strong> object for a recipe identified by its ID. The return value of both of these methods is wrapped in a <strong class="source-inline">Result</strong> object, allowing us to deal with the fact that the requested data (temporarily) couldn’t be retrieved, <span class="No-Break">for example.</span></p></li> <li>Head over <a id="_idIndexMarker697"/>to the <strong class="source-inline">RecipeService</strong> class and add a parameter of type <strong class="source-inline">IRecipeRepository</strong> to its <a id="_idIndexMarker698"/>constructor. A field is also added to keep a reference to this instance, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
public class RecipeService : IRecipeService
{
    readonly IRecipeRepository _recipeRepository;
...
    public RecipeService(
        IRecipeRepository recipeRepository)
    {
        _recipeRepository = recipeRepository;
    }
}</pre></li> <li>As there isn’t much “business logic” going on in the <strong class="source-inline">RecipeService</strong> class, its methods should just call the injected repository’s methods and return their result. Have <span class="No-Break">a look:</span><pre class="source-code">
public Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(
    string id) =&gt; <strong class="bold">_recipeRepository.LoadRecipe(id);</strong>
public Task&lt;Result&lt;LoadRecipesResponse&gt;&gt; LoadRecipes(
    int pageSize = 7, int page = 0)
    =&gt; <strong class="bold">_recipeRepository.LoadRecipes(pageSize, page);</strong></pre></li> </ol>
<p>We can add the same treatment to the <strong class="source-inline">RatingsService</strong> class: create a repository interface, add it as a dependency to the service, and call the interface’s methods from the <strong class="source-inline">RatingsService</strong> class’s methods. We’ll proceed <span class="No-Break">as follows:</span></p>
<ol>
<li>Let’s create an <strong class="source-inline">IRatingsRepository</strong> interface for the <strong class="source-inline">Features/Ratings</strong> folder and add the following definitions to the newly <span class="No-Break">created interface:</span><pre class="source-code">
Task&lt;Result&lt;IReadOnlyCollection&lt;Rating&gt;&gt;&gt;
    GetRatings(string recipeId);
Task&lt;Result&lt;RatingsSummary&gt;&gt; GetRatingsSummary(
    string recipeId);</pre><p class="list-inset">There are <a id="_idIndexMarker699"/>two methods defined in <a id="_idIndexMarker700"/>this interface: <strong class="source-inline">GetRatings</strong> and <strong class="source-inline">GetRatingsSummary</strong>. The first method returns a collection of <strong class="source-inline">Rating</strong> objects associated with the specified recipe ID. The second method returns a <strong class="source-inline">RatingsSummary</strong> for a recipe identified by its ID. As noted earlier, the return values are wrapped in a <span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break"> object.</span></p></li> <li>Next, we add <strong class="source-inline">IRatingsRepository</strong> as a dependency of the <strong class="source-inline">RatingsService</strong> class, by defining it as a <span class="No-Break">constructor parameter:</span><pre class="source-code">
public class RatingsService : IRatingsService
{
    readonly IRatingsRepository _ratingsRepository;
...
    public RatingsService(
        IRatingsRepository ratingsRepository)
    {
        _ratingsRepository = ratingsRepository;
    }
}</pre></li> <li>Finally, as the <strong class="source-inline">RatingsService</strong> class doesn’t contain any additional logic, this class will just call the repository’s methods, as you can <span class="No-Break">see here:</span><pre class="source-code">
public Task&lt;Result&lt;RatingsSummary&gt;&gt;
    LoadRatingsSummary(string recipeId)
    =&gt; <strong class="bold">_ratingsRepository.GetRatingsSummary(recipeId);</strong>
public Task&lt;&lt;Result&lt;IReadOnlyCollection&lt;Rating&gt;&gt;&gt;
    LoadRatings(string recipeId)
    =&gt; <strong class="bold">_ratingsRepository.GetRatings(recipeId);</strong></pre></li> </ol>
<p>That leaves <a id="_idIndexMarker701"/>us with one service left to <a id="_idIndexMarker702"/>update: <strong class="source-inline">FavoritesService</strong>. Unlike the previous services that we’ve been updating, <strong class="source-inline">FavoritesService</strong> does contain some additional logic. But let’s first take a look at what the <strong class="source-inline">IFavoritesRepository</strong> interface <span class="No-Break">looks like:</span></p>
<pre class="source-code">
public interface IFavoritesRepository
{
    Task&lt;Result&lt;IReadonlyCollection&lt;string&gt;&gt;&gt;
        LoadFavorites(string userId);
    Task&lt;Result&lt;Nothing&gt;&gt; Add(string userId, string id);
    Task&lt;Result&lt;Nothing&gt;&gt; Remove(string userId, string id);
}</pre> <p>This interface defines three methods: <strong class="source-inline">LoadFavorites</strong>, <strong class="source-inline">Add</strong>, and <strong class="source-inline">Remove</strong>. Since our favorites are stored on a centralized server, it’s essential to pass the user’s identifier (or <strong class="source-inline">userId</strong>) to the API. This ensures that favorites fetched, added, or removed are specific to that user. Neither the <strong class="source-inline">Add</strong> method nor the <strong class="source-inline">Remove</strong> method has an intrinsic return value. To be consistent with the rest of our APIs, we want to return a value wrapped in a <strong class="source-inline">Result</strong> object. That’s why a custom <strong class="source-inline">Nothing</strong> type is returned. This is just an empty struct, as you can <span class="No-Break">see here:</span></p>
<pre class="source-code">
public struct Nothing
{
}</pre> <p>Let’s update the <strong class="source-inline">FavoritesService</strong> so that it leverages the <span class="No-Break"><strong class="source-inline">IFavoritesRepository</strong></span><span class="No-Break"> interface:</span></p>
<ol>
<li>Go ahead <a id="_idIndexMarker703"/>and add the <strong class="source-inline">IFavoritesRepository</strong> interface to the <span class="No-Break"><strong class="source-inline">Features/Favorites</strong></span><span class="No-Break"> folder.</span></li>
<li>Update <strong class="source-inline">FavoritesService</strong> so that its constructor accepts a parameter of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">IFavoritesRepository</strong></span><span class="No-Break">:</span><pre class="source-code">
public class FavoritesService : IFavoritesService
{
    readonly IFavoritesRepository
        _favoritesRepository;
...
    public FavoritesService(
        IFavoritesRepository favoritesRepository)
    {
        _favoritesRepository = favoritesRepository;
    }
}</pre></li> <li><strong class="source-inline">FavoritesService</strong> keeps a list of the user’s favorites in memory. This in-memory <a id="_idIndexMarker704"/>list can easily be used in the <strong class="source-inline">IsFavorite</strong> method to rapidly check whether the given <strong class="source-inline">recipeId</strong> exists in the list. Here’s how we can load this list <span class="No-Break">in memory:</span><pre class="source-code">
List&lt;string&gt; favorites = null;
private async ValueTask LoadList()
{
    if (favorites is null)
    {
        var loadResult = await _favoritesRepository
            .LoadFavorites(GetCurrentUserId());
        if (loadResult.IsSuccess)
        {
            favorites = loadResult.Data.ToList();
        }
    }
}
//Dummy implementation,
//could be retrieved via injected service
private string GetCurrentUserId()
    =&gt; "3";</pre><p class="list-inset">The <strong class="source-inline">LoadList</strong> method calls the <strong class="source-inline">LoadFavorites</strong> method on the <strong class="source-inline">IFavoritesRepository</strong> when the favorites list is <strong class="source-inline">null</strong>. The “dummy” <strong class="source-inline">GetCurrentUserId</strong> method provides a fake identifier for the given user of the app. In a <a id="_idIndexMarker705"/>real-life scenario, this could be retrieved from an <span class="No-Break">injected service.</span></p></li> <li>As said <a id="_idIndexMarker706"/>before, this in-memory list facilitates the implementation of the <strong class="source-inline">IsFavorite</strong> method, as shown in the next <span class="No-Break">code block:</span><pre class="source-code">
public async Task&lt;bool&gt; IsFavorite(string id)
{
    await LoadList();
    return favorites is not null
        &amp;&amp; favorites.Contains(id);
}</pre><p class="list-inset">This method calls the <strong class="source-inline">LoadList</strong> method, which will retrieve the favorites from the API if the in-memory list is <strong class="source-inline">null</strong>. When favorites have been loaded, we can check whether the list contains the <span class="No-Break">given ID.</span></p></li> </ol>
<p>In contrast <a id="_idIndexMarker707"/>to the earlier services we discussed, where each method simply invoked a corresponding method in the injected <a id="_idIndexMarker708"/>repository, things are slightly more complex here due to the presence of an in-memory list. Also, because both the <strong class="source-inline">Add</strong> and <strong class="source-inline">Remove</strong> methods send a <strong class="source-inline">FavoriteUpdateMessage</strong> instance, they require some extra logic for implementation. Here’s how <span class="No-Break">it’s done:</span></p>
<ol>
<li>The first thing to do in <strong class="source-inline">FavoritesService</strong>’s <strong class="source-inline">Add</strong> method is to call the repository’s <strong class="source-inline">Add</strong> method, passing in the (fake) <strong class="source-inline">userId</strong> value, as <span class="No-Break">shown here:</span><pre class="source-code">
public async Task&lt;Result&lt;Nothing&gt;&gt; Add(string id)
{
    var result = await _favoritesRepository
        .Add(GetCurrentUserId(), id);
}</pre></li> <li>The <strong class="source-inline">Add</strong> method of the <strong class="source-inline">IFavoritesRepository</strong> returns a <strong class="source-inline">Nothing</strong> object wrapped in a <strong class="source-inline">Result</strong> object. Thanks to the <strong class="source-inline">Result</strong> object, we can check if the API call was successful or not. If that’s the case, we add the ID of the favorited recipe to the in-memory list of favorites and send the <strong class="source-inline">FavoriteUpdateMessage</strong> as <span class="No-Break">shown here:</span><pre class="source-code">
if (result.IsSuccess)
{
    if (favorites is not null
        &amp;&amp; !favorites.Contains(id))
        favorites.Add(id);
    WeakReferenceMessenger.Default
        .Send(new FavoriteUpdateMessage(id, true));
}
return result;</pre></li> <li>The <strong class="source-inline">Remove</strong> method <a id="_idIndexMarker709"/>is <span class="No-Break">very </span><span class="No-Break"><a id="_idIndexMarker710"/></span><span class="No-Break">similar:</span><pre class="source-code">
public async Task&lt;Result&lt;Nothing&gt;&gt; Remove(string id)
{
    var result = await _favoritesRepository
        .Remove(GetCurrentUserId(), id);
    if (result.IsSuccess)
    {
        if (favorites is not null
            &amp;&amp; favorites.Contains(id))
            favorites.Remove(id);
        WeakReferenceMessenger.Default
            .Send(
            new FavoriteUpdateMessage(id, false));
    }
    return result;
}</pre></li> </ol>
<p>With all of our code in place, it’s time to add implementations for these repositories and make sure they get registered in the <span class="No-Break">DI container.</span></p>
<h3>Adding and registering repository implementations</h3>
<p>There’s a dedicated project in which we can place the implementations of the repository interfaces. As <a id="_idIndexMarker711"/>these repositories <a id="_idIndexMarker712"/>will communicate to our API, I tend to use <strong class="source-inline">ApiGateway</strong> as the naming. Personally, I think this name perfectly illustrates its functionality. In the <strong class="source-inline">Recipes.Client.Repositories</strong> project, we can add three classes: <strong class="source-inline">FavoritesApiGateway</strong>, <strong class="source-inline">RatingsApiGateway</strong>, and <strong class="source-inline">RecipeApiGateway</strong>. These classes should implement the <strong class="source-inline">IFavoritesRepository</strong>, <strong class="source-inline">IRatingsRepository</strong>, and <strong class="source-inline">IRecipeRepository</strong> interfaces respectively. In the next section, we will be discussing how to effectively activate API communication <span class="No-Break">using Refit.</span></p>
<p>Now, let’s turn our attention to registering these repositories in the DI container. Instead of handling each registration in the <strong class="source-inline">MauiProgram</strong> class, we’ll delegate this task entirely to the code in the <span class="No-Break"><strong class="source-inline">Recipes.Client.Repositories</strong></span><span class="No-Break"> project:</span></p>
<ol>
<li>Add the <strong class="source-inline">Microsoft.Extensions.DependencyInjection.Abstractions</strong> NuGet package to the <span class="No-Break"><strong class="source-inline">Recipes.Client.Repositories</strong></span><span class="No-Break"> project.</span></li>
<li>In the <strong class="source-inline">Recipes.Client.Repositories</strong> project, add a <strong class="source-inline">ServiceCollectionExtension</strong> class. Here’s what this static class <span class="No-Break">looks like:</span><pre class="source-code">
public static class ServiceCollectionExtension
{
    public static IServiceCollection
        RegisterRepositories(
        this IServiceCollection services)
    {
        services.AddTransient&lt;IRatingsRepository,
            RatingsApiGateway&gt;();
        services.AddTransient&lt;IRecipeRepository,
            RecipeApiGateway&gt;();
        services.AddTransient&lt;IFavoritesRepository,
            FavoritesApiGateway&gt;();
        return services;
    }
}</pre><p class="list-inset">This <a id="_idIndexMarker713"/>class contains <a id="_idIndexMarker714"/>one method: <strong class="source-inline">RegisterRepositories</strong>. This method is an extension method that extends the <strong class="source-inline">IServiceCollection</strong> interface. To use <strong class="source-inline">IServiceCollection</strong>, ensure you’ve included the <strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong> namespace, which is part of the NuGet package we added in the first step. This method is all about registering the repositories. Ending the method by returning the <strong class="source-inline">services</strong> instance allows us to adopt a builder pattern, enabling the chaining of additional <span class="No-Break">extension methods.</span></p></li> <li>Now, we can head over to the <strong class="source-inline">MauiProgram.cs</strong> file and add the following to the <span class="No-Break"><strong class="source-inline">CreateMauiApp</strong></span><span class="No-Break"> method:</span><pre class="source-code">
builder.Services.RegisterRepositories();</pre><p class="list-inset">The <strong class="source-inline">RegisterRepositories</strong> extension method can only be resolved when the <strong class="source-inline">Recipes.Client.Repositories</strong> namespace <span class="No-Break">is added.</span></p></li> </ol>
<p>With all of this in place, the services of our app now depend on repositories that will eventually communicate to the app’s API. The implementation of those repository interfaces and their registration is done in the dedicated <strong class="source-inline">Recipes.Client.Repositories</strong> project. This keeps everything organized and modular and ensures a clear separation of concerns, making our codebase <span class="No-Break">more maintainable.</span></p>
<p>Although <a id="_idIndexMarker715"/>we now have repositories <a id="_idIndexMarker716"/>that are being registered, they still lack communication with our API. Moreover, we registered the <strong class="source-inline">RatingsApiGateway</strong>, <strong class="source-inline">RecipeApiGateway</strong>, and <strong class="source-inline">FavoritesApiGateway</strong> classes, which don’t exist yet. Let’s see how we can add these and leverage Refit to make API requests and receive strongly typed responses, making it easier to handle errors and <span class="No-Break">parse data.</span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor172"/>API communication with Refit</h1>
<p>Up to this point, we’ve set up a neat architecture for our repositories, but they’re still missing the <a id="_idIndexMarker717"/>ability to talk to our API. To add this functionality, we could use <strong class="source-inline">HttpClient</strong> manually to make API calls and deserialize the response. While that’s entirely possible, it’s also cumbersome and prone to errors, not to mention it takes a lot of boilerplate code to get <span class="No-Break">it right.</span></p>
<p>This is where <a id="_idIndexMarker718"/>Refit comes into the picture. Refit is a powerful library that simplifies API calls by providing a more declarative and less error-prone approach. Instead of writing tedious HTTP requests and responses, you just define a C# interface that maps to the API’s endpoints. Refit takes care of the underlying <strong class="source-inline">HttpClient</strong> calls, serialization, and deserialization for you, letting you focus on what matters – the logic of <span class="No-Break">your application.</span></p>
<p>In this section, we’ll see how Refit can make our life easier by reducing code complexity and increasing readability, while still offering customization options for more complex scenarios. So, let’s get our repositories talking to our API the <span class="No-Break">smart way.</span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor173"/>Getting started with Refit</h2>
<p>Refit is a <a id="_idIndexMarker719"/>type-safe REST client for .NET that allows you to easily make API calls by defining an interface. You annotate the interface methods with HTTP attributes such as <strong class="source-inline">[Get]</strong>, <strong class="source-inline">[Post]</strong>, and so on, specifying the API endpoints. Refit is then able to generate the implementation for you, turning those interface methods into API calls. Let’s take a look at <span class="No-Break">an example:</span></p>
<ol>
<li>First, we need to define the API endpoints we’ll be interacting with by declaring <span class="No-Break">an interface:</span><pre class="source-code">
public interface IRecipeApi
{
    [Get("/recipe/{recipeId}")]
    Task&lt;ApiResponse&lt;RecipeDto&gt;&gt;
        GetRecipe(string recipeId);
}</pre><p class="list-inset">Here, the <strong class="source-inline">IRecipeApi</strong> interface defines an API call for fetching a single recipe by its ID. The <strong class="source-inline">Refit.Get</strong> attribute is used to define an <strong class="source-inline">HTTP GET</strong> method for a specific endpoint. The <strong class="source-inline">{recipeId}</strong> portion of the endpoint specifies a path parameter <a id="_idIndexMarker720"/>that is used to pass the <strong class="source-inline">recipeId</strong> parameter to the method. When the <strong class="source-inline">GetRecipe</strong> method is called with a recipe ID, we want the Refit library to send an <strong class="source-inline">HTTP GET</strong> request to the specified endpoint, replacing the <strong class="source-inline">{recipeId}</strong> portion of the endpoint with the <span class="No-Break">specified ID.</span></p></li> <li>Secondly, we use <strong class="source-inline">RestService.For</strong> to generate an implementation of your interface, as <span class="No-Break">shown here:</span><pre class="source-code">
var api = RestService.For&lt;IRecipeApi&gt;(
        "https://api.yourservice.com");</pre><p class="list-inset">This single line of code creates an object that knows how to make the API calls defined in <strong class="source-inline">IRecipeApi</strong>. This <strong class="source-inline">RestService.For</strong> method accepts a string parameter that defines the base URL of the API. Alternatively, an instance of <strong class="source-inline">HttpClient</strong> can be passed as a parameter, instead of the string value. Refit will use the given <strong class="source-inline">HttpClient</strong> to communicate with the API. Later on in the chapter, we’ll see why passing in an <strong class="source-inline">HttpClient</strong> can <span class="No-Break">be useful.</span></p></li> <li>Finally, we can use the generated object to make API calls and handle the responses, as the following code <span class="No-Break">snippet demonstrates:</span><pre class="source-code">
var recipeResponse = await api.GetRecipe("1");
if (recipeResponse.IsSuccessStatusCode)
{
    RecipeDto recipe = recipeResponse.Content;
}</pre><p class="list-inset"><strong class="source-inline">recipeResponse</strong> is an object of type <strong class="source-inline">ApiResponse&lt;RecipeDto&gt;</strong> that gives you <a id="_idIndexMarker721"/>both the deserialized content and additional HTTP <span class="No-Break">response details.</span></p><p class="list-inset">Alternatively, you could also define a <strong class="source-inline">GetRecipe</strong> method in the <strong class="source-inline">IRecipeApi</strong> interface <span class="No-Break">as follows:</span></p><pre class="source-code">Task&lt;RecipeDto&gt; GetRecipe(string recipeId);</pre><p class="list-inset">This would just return the deserialized object. I prefer the approach that returns <strong class="source-inline">ApiResponse&lt;T&gt;</strong> because it provides a fuller picture of what’s happening during the API interaction, which is crucial for robust error handling and <span class="No-Break">insightful logging.</span></p></li> </ol>
<p>And there you have it: three simple steps to replace what would have otherwise been much more boilerplate code. Now, let’s get back to our <em class="italic">Recipes!</em> app and put this <span class="No-Break">into practice.</span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor174"/>Creating API interfaces</h2>
<p>Let’s add <a id="_idIndexMarker722"/>API interfaces to the <strong class="source-inline">Recipes.Client.Repositories</strong> project. Later on, we will be using them together with Refit to generate the required code to effectively communicate to <span class="No-Break">the API:</span></p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong>, right-click the <strong class="source-inline">Recipes.Client.Repositories</strong> project and select <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>. Name the <span class="No-Break">folder </span><span class="No-Break"><strong class="source-inline">Api</strong></span><span class="No-Break">.</span></li>
<li>Add an interface called <strong class="source-inline">IFavoritesApi</strong> to the newly created folder. The following code snippet shows what this interface <span class="No-Break">looks like:</span><pre class="source-code">
public interface IFavoritesApi
{
    [Get("/users/{userId}/favorites")]
    Task&lt;string[]&gt; GetFavorites(string userId);
    [Post("/users/{userId}/favorites")]
    Task AddFavorite(string userId,
        FavoriteDto favorite);
    [Delete("/users/{userId}/favorites/{recipeId}")]
    Task DeleteFavorite(string userId,
        string recipeId);
}</pre><p class="list-inset">This interface <a id="_idIndexMarker723"/>maps directly to the API endpoints responsible for managing user favorites. The <strong class="source-inline">Get</strong>, <strong class="source-inline">Post</strong> and <strong class="source-inline">Delete</strong> attributes specify the HTTP methods that should be used for each API call. Parameters such as <strong class="source-inline">userId</strong> that appear in the URL are automatically populated from the method arguments. Notice the <strong class="source-inline">favorite</strong> parameter in the <strong class="source-inline">AddFavorite</strong> method. This parameter is not part of the defined endpoint URL; instead, it gets serialized and sent as the request body. Alternatively, it’s also possible to explicitly indicate that the favorite parameter needs to be sent in the message’s body by using the <strong class="source-inline">Body</strong> attribute. This is what that <span class="No-Break">looks like:</span></p><pre class="source-code">[Post("/users/{userId}/favorites")]
    Task AddFavorite(string userId,
        <strong class="bold">[Body]</strong>FavoriteDto favorite);</pre></li> <li>Next, we can add the <strong class="source-inline">IRatingsApi</strong> interface, which looks <span class="No-Break">like this:</span><pre class="source-code">
public interface IRatingsApi
{
    [Get("/recipe/{recipeId}/ratings")]
    Task&lt;ApiResponse&lt;RatingDto[]&gt;&gt; GetRatings(
        string recipeId);
    [Get("/recipe/{recipeId}/ratingssummary")]
    Task&lt;ApiResponse&lt;RatingsSummaryDto&gt;&gt;
        GetRatingsSummary(string recipeId);
}</pre><p class="list-inset">Again, these methods and their attributes correspond with the endpoints that allow us <a id="_idIndexMarker724"/>to retrieve ratings and a ratings summary for a given <span class="No-Break">recipe ID.</span></p></li> <li>Finally, let’s define the <span class="No-Break"><strong class="source-inline">IRecipeApi</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
public interface IRecipeApi
{
    [Get("/recipe/{recipeId}")]
    Task&lt;ApiResponse&lt;RecipeDetailDto&gt;&gt;
      GetRecipe(string recipeId);
    [Get("/recipes")]
    Task&lt;ApiResponse&lt;RecipeOverviewItemsDto&gt;&gt;
      GetRecipes(int pageSize = 7, int pageIndex = 0);
}</pre><p class="list-inset">As you probably know by now, as with the previous ones, this interface also maps to certain API endpoints. The <strong class="source-inline">pageSize</strong> and <strong class="source-inline">pageIndex</strong> parameters of the <strong class="source-inline">GetRecipes</strong> method don’t appear in the endpoint of the <strong class="source-inline">Get</strong> attribute. As a result, they will be added as query string parameters when doing <span class="No-Break">the request.</span></p></li> </ol>
<p>With our API <a id="_idIndexMarker725"/>interfaces defined, it’s finally time to bridge the gap between our repositories and the actual <span class="No-Break">API calls.</span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor175"/>Integrating Refit</h2>
<p>Let’s integrate Refit into our repositories to make the API calls a breeze. It all starts with adding the <a id="_idIndexMarker726"/>Refit NuGet package to the <strong class="source-inline">Recipes.Client.Repositories</strong> project. To make integrating Refit even easier and avoid duplicate code later on, let’s first add a new <strong class="source-inline">ApiGateway</strong> abstract class to the <strong class="source-inline">Recipes.Client.Repositories</strong> project. The purpose of this class is to help us in executing a call and mapping the <strong class="source-inline">ApiResponse</strong> result to another type. This is what the <strong class="source-inline">InvokeAndMap</strong> method’s signature <span class="No-Break">looks like:</span></p>
<pre class="source-code">
protected async Task&lt;Result&lt;TResult&gt;&gt;
    InvokeAndMap&lt;TResult, TDtoResult&gt;(
    Task&lt;ApiResponse&lt;TDtoResult&gt;&gt; call,
    Func&lt;TDtoResult, TResult&gt; mapper)
{
}</pre> <p>This method returns a <strong class="source-inline">Task&lt;TResult&gt;</strong> object and takes in <span class="No-Break">two parameters:</span></p>
<ul>
<li>The <strong class="source-inline">call</strong> parameter is the API call to make, which returns an <span class="No-Break"><strong class="source-inline">ApiResponse&lt;TDtoResult&gt;</strong></span><span class="No-Break"> object</span></li>
<li>The <strong class="source-inline">mapper</strong> parameter is a method that takes in the <strong class="source-inline">TDtoResult</strong> object from the response and maps it to the <strong class="source-inline">TResult</strong> object that the <strong class="source-inline">InvokeAndMap</strong> <span class="No-Break">method returns</span></li>
</ul>
<p>The implementation is fairly straightforward: the method must execute the provided <strong class="source-inline">call</strong> parameter. If the resulting <strong class="source-inline">ApiResponse</strong> instance indicates success, the passed-in <strong class="source-inline">mapper</strong> parameter will be used to map the result from <strong class="source-inline">TDtoResult</strong> to <strong class="source-inline">TResult</strong>, which is wrapped in a <strong class="source-inline">Result</strong> object that indicates success. If the response doesn’t indicate success, a failed result is returned, containing the response’s status code. The following <a id="_idIndexMarker727"/>code block shows how <span class="No-Break">it’s done:</span></p>
<pre class="source-code">
try
{
    var response = await call;
    if (response.IsSuccessStatusCode)
    {
        return Result&lt;TResult&gt;
            .Success(mapper(response.Content));
    }
    else
    {
        return Result&lt;TResult&gt;.Fail("FAILED_REQUEST",
            response.Error.StatusCode.ToString());
    }
}
...</pre> <p>On top of that, we also need to be wary of potential exceptions being thrown, which we can handle as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
try
{
...
}
catch (ApiException aex)
{
    return Result&lt;TResult&gt;
        .Fail("ApiException",
            aex.StatusCode.ToString(), aex);
}
catch (Exception ex)
{
    return Result&lt;TResult&gt;.Fail(ex);
}</pre> <p>When an <a id="_idIndexMarker728"/>exception occurs, we should return a <strong class="source-inline">Result</strong> object that indicates failure, containing relevant data about <span class="No-Break">the exception.</span></p>
<p class="callout-heading">A note on robustness</p>
<p class="callout">When developing mobile applications, it’s important to remember that network conditions can be unpredictable. Mobile devices might move between different network zones, causing unstable connections. As a best practice, always consider implementing resilience patterns such as <strong class="bold">retry</strong> or <strong class="bold">circuit breaker</strong> when making API calls. A library such as <strong class="bold">Polly</strong> makes this straightforward, allowing you to define policies for handling transient faults and network hiccups. Leveraging such tools can greatly enhance the reliability of your app, ensuring a smoother user experience even under challenging network conditions. The abstract <strong class="source-inline">ApiGateway</strong> class is the perfect spot to add this kind of retry logic instead of directly returning a <strong class="source-inline">Fail</strong> result. Find out more about Polly <span class="No-Break">here: </span><a href="https://github.com/App-vNext/Polly"><span class="No-Break">https://github.com/App-vNext/Polly</span></a><span class="No-Break">.</span></p>
<p>In situations where the data type returned by the API interface is identical to the type we wish to encapsulate in a <strong class="source-inline">Result</strong> object, we can provide an overloaded <strong class="source-inline">InvokeAndMap</strong> method that eliminates the need for a type mapper. This is particularly useful when dealing with primitive types. The following snippet shows <span class="No-Break">this overload:</span></p>
<pre class="source-code">
protected Task&lt;Result&lt;T&gt;&gt;
    InvokeAndMap&lt;T&gt;(&lt;ApiResponse&lt;T&gt;&gt; call)
    =&gt; InvokeAndMap(call, e =&gt; e);</pre> <p>This base class will drastically simplify the mapping of a DTO returned by the API to a domain entity <a id="_idIndexMarker729"/>that gets encapsulated in a <strong class="source-inline">Result</strong> object. Now, let’s have a look at how we can utilize this <strong class="source-inline">InvokeAndMap</strong> method in <span class="No-Break">our repositories:</span></p>
<ol>
<li>First, make sure that all of our repositories (<strong class="source-inline">FavoritesApiGateway</strong>, <strong class="source-inline">RatingsApiGateway</strong>, and <strong class="source-inline">RecipeApiGateway</strong>) inherit this abstract <strong class="source-inline">ApiGateway</strong> class by adding the <span class="No-Break">following code:</span><pre class="source-code">
internal class FavoritesApiGateway : <strong class="bold">ApiGateway</strong>,
  IFavoritesRepository { ... }
internal class RatingsApiGateway : <strong class="bold">ApiGateway</strong>,
  IRatingsRepository { ... }
internal class RecipeApiGateway : <strong class="bold">ApiGateway</strong>,
  IRecipeRepository { ... }</pre></li> <li>Next, each of these repositories should get its corresponding API interface injected through its constructor. Let’s see what this looks like <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">RatingsApiGateway</strong></span><span class="No-Break">:</span><pre class="source-code">
internal class RatingsApiGateway : ApiGateway,
  IRatingsRepository
{
    <strong class="bold">readonly IRatingsApi _api;</strong>
...
    public RatingsApiGateway(<strong class="bold">IRatingsApi api</strong>)
    {
        <strong class="bold">_api = api;</strong>
    }
}</pre></li> <li>The injected <strong class="source-inline">IRatingsApi</strong> interface can now be used to do the network calls and retrieve <a id="_idIndexMarker730"/>the requested data from the API. The following code block shows the implemented <span class="No-Break"><strong class="source-inline">GetRatings</strong></span><span class="No-Break"> method:</span><pre class="source-code">
public Task&lt;Result&lt;IReadOnlyCollection&lt;Rating&gt;&gt;&gt;
    GetRatings(string recipeId)
    =&gt; InvokeAndMap(
        _api.GetRatings(recipeId), MapRatings);</pre><p class="list-inset">The <strong class="source-inline">GetRatings</strong> method calls the <strong class="source-inline">InvokeAndMap</strong> method of the base class. The <strong class="source-inline">GetRatings</strong> API call is passed in as a parameter, as well as the <strong class="source-inline">MapRatings</strong> method, which maps the <strong class="source-inline">RatingDto</strong> array returned by the API to an <strong class="source-inline">IReadOnlyCollection</strong> of <strong class="source-inline">Rating</strong> objects. The <strong class="source-inline">MapRatings</strong> method is a static method on the static <strong class="source-inline">RatingsMapper</strong> class. We can directly access <strong class="source-inline">RatingsMapper</strong>’s static mapping methods inside this class without explicitly needing to prepend its name because the following <strong class="source-inline">using</strong> statement is added to <span class="No-Break">the class:</span></p><pre class="source-code">using static Recipes.Client.Repositories.Mappers
  .RatingsMapper;</pre></li> <li>We can now do the exact same thing for the <strong class="source-inline">GetRatingsSummary</strong> method on <span class="No-Break">this class:</span><pre class="source-code">
public Task&lt;Result&lt;RatingsSummary&gt;&gt;
    GetRatingsSummary(string recipeId)
    =&gt; InvokeAndMap(_api.GetRatingsSummary(recipeId),
        MapRatingSummary);</pre></li> <li>Analogous to the previous examples, the implementation of the <strong class="source-inline">FavoritesApiGateway</strong> class can be done following the same pattern: inject the <strong class="source-inline">IFavoritesApi</strong> interface and use its methods to retrieve data from the API, leveraging <a id="_idIndexMarker731"/>the <strong class="source-inline">InvokeAndMap</strong> method of the <strong class="source-inline">ApiGateway</strong> <span class="No-Break">base class:</span><pre class="source-code">
internal class FavoritesApiGateway : ApiGateway,
    IFavoritesRepository
{
    readonly IFavoritesApi _api;
    public Task&lt;Result&lt;Nothing&gt;&gt; Add(
        string userId, string id)
        =&gt; InvokeAndMap(_api.AddFavorite(userId,
            new FavoriteDto(id)));
    public Task&lt;Result&lt;string[]&gt;&gt; LoadFavorites(
        string userId)
        =&gt; InvokeAndMap(_api.GetFavorites(userId));
    public Task&lt;Result&lt;Nothing&gt;&gt; Remove(string userId,
    string recipeId)
        =&gt; InvokeAndMap(_api.DeleteFavorite(userId,
            recipeId));
    public FavoritesApiGateway(IFavoritesApi api)
    {
        _api = api;
    }
}</pre><p class="list-inset">All of these methods in the <strong class="source-inline">FavoritesApiGateway</strong> use the overloaded <strong class="source-inline">InvokeAndMap</strong> method, which doesn’t do additional mapping: the data type returned by the API interface is the same as the one the repository returns, but it’s encapsulated in a <span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break"> object.</span></p></li> <li>The implementation of the <strong class="source-inline">RecipeApiGateway</strong> class shouldn’t contain any surprises; it only contains more mapping. But at its core, it follows the exact same pattern <a id="_idIndexMarker732"/>as the previous two classes. First, a field of type <strong class="source-inline">IRecipeApi</strong> needs to be added as a member and constructor parameter, as the following <span class="No-Break">snippet shows:</span><pre class="source-code">
internal class RecipeApiGateway : ApiGateway,
    IRecipeRepository
{
    readonly IRecipeApi _api;
...
    public RecipeApiGateway(IRecipeApi api)
    {
        _api = api;
    }
}</pre><p class="list-inset">The <strong class="source-inline">LoadRecipes</strong> method and the mappings it uses look <span class="No-Break">like this:</span></p><pre class="source-code">public Task&lt;Result&lt;LoadRecipesResponse&gt;&gt;
    LoadRecipes(int pageSize, int page)
    =&gt; InvokeAndMap(_api.GetRecipes(pageSize, page),
        MapRecipesOverview);</pre><p class="list-inset"><strong class="source-inline">LoadRecipes</strong> calls the <strong class="source-inline">InvokeAndMap</strong> method, passing in the <strong class="source-inline">GetRecipes</strong> method of the API interface. The <strong class="source-inline">MapRecipesOverview</strong> method is used to map the resulting object of type <strong class="source-inline">RecipesOverviewItemsDto</strong> to a <span class="No-Break"><strong class="source-inline">LoadRecipesResponse</strong></span><span class="No-Break"> object.</span></p><p class="list-inset">And finally, we can implement the <strong class="source-inline">LoadRecipe</strong> method. It can use the <strong class="source-inline">GetRecipe</strong> method of the <strong class="source-inline">IRecipeApi</strong> to get the data. The result will be mapped using the static <strong class="source-inline">MapRecipe</strong> method of the static <strong class="source-inline">RecipeMapper</strong> class. Take <span class="No-Break">a look:</span></p><pre class="source-code">public Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(
    string id)
    =&gt; InvokeAndMap(_api.GetRecipe(id), MapRecipe);</pre></li> </ol>
<p>We also need to update our <strong class="source-inline">ServiceCollectionExtension</strong> class. Because every repository now <a id="_idIndexMarker733"/>has a dependency on a particular API interface, we need to make sure these dependencies get registered as well. But first, we might want to add a new <strong class="source-inline">RepositorySettings</strong> class to the <strong class="source-inline">Recipes.Client.Repositories</strong> project. This class should be a way to pass settings from the app to the repositories, such as a specific <strong class="source-inline">HttpClient</strong> instance that needs to be used, for example. As the following code block shows, there’s not much to this class for this particular demo project. But in more complex applications, things such as particular serialization or authentication settings can be added here <span class="No-Break">as well:</span></p>
<pre class="source-code">
public class RepositorySettings
{
    public HttpClient HttpClient { get; }
    public RepositorySettings(HttpClient httpClient)
    {
        HttpClient = httpClient;
    }
}</pre> <p>Let’s fit the <a id="_idIndexMarker734"/>final pieces of the puzzle together, update the <strong class="source-inline">ServiceCollectionExtension</strong>, and call it from our app. Here’s what we need <span class="No-Break">to do:</span></p>
<ol>
<li>Add the <strong class="source-inline">RepositorySettings</strong> class, as shown earlier, to the <span class="No-Break"><strong class="source-inline">Recipes.Client.Repositories</strong></span><span class="No-Break"> project.</span></li>
<li>Add a parameter of type <strong class="source-inline">RepositorySettings</strong> to the <strong class="source-inline">RegisterRepositories</strong> extension method of the <strong class="source-inline">ServiceCollectionExtension</strong> class, as <span class="No-Break">shown here:</span><pre class="source-code">
public static class ServiceCollectionExtension
{
    public static IServiceCollection
        RegisterRepositories (
        this IServiceCollection services,
        <strong class="bold">RepositorySettings settings</strong>)
    {
        ...
        return services;
    }
}</pre></li> <li>As we saw earlier, Refit’s <strong class="source-inline">RestService.For</strong> method can be used to generate implementations of the API interfaces. The following snippet shows how we can register the generated implementations in the <span class="No-Break">DI container:</span><pre class="source-code">
services.AddSingleton((s) =&gt;
  RestService.For&lt;IRatingsApi&gt;(settings.HttpClient));
services.AddSingleton((s) =&gt;
  RestService.For&lt;IRecipeApi&gt;(settings.HttpClient));
services.AddSingleton((s) =&gt;
RestService.For&lt;IFavoritesApi&gt;(settings.HttpClient));</pre><p class="list-inset">The <strong class="source-inline">RestService.For</strong> method accepts an instance of <strong class="source-inline">HttpClient</strong> that will be used by Refit to do the API communication. An <strong class="source-inline">HttpClient</strong>, should be configured in the app and passed-in via <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">RepositorySettings</strong></span><span class="No-Break">.</span></p></li> <li>Finally, in the <strong class="source-inline">MauiProgram</strong> class, <a id="_idIndexMarker735"/>we can call the updated <strong class="source-inline">RegisterRepositories</strong> and pass-in a configured <strong class="source-inline">HttpClient</strong> as <span class="No-Break">shown here:</span><pre class="source-code">
var baseAddress = DeviceInfo.Platform ==
    DevicePlatform.Android
    ? "https://10.0.2.2:7220"
    : "https://localhost:7220";
var httpClient = HttpClientHelper
    .GetPlatformHttpClient(baseAddress);
builder.Services.RegisterRepositories(
    new RepositorySettings(httpClient));</pre><p class="list-inset">As the Android emulator runs in an isolated network environment behind a virtual router, it cannot directly access the development machine using <strong class="source-inline">localhost</strong>. Instead, the emulator provides a special <strong class="source-inline">10.0.2.2</strong> alias that routes to the development machine’s loopback interface, enabling you to access local <span class="No-Break">web services.</span></p><p class="list-inset">The <strong class="source-inline">Recipes.Mobile</strong> project contains an <strong class="source-inline">HttpClientHelper</strong> class that configures an <strong class="source-inline">HttpClient</strong> instance to be used for connecting to local web services. This is needed as some additional configuration specific to each platform needs to be done in order to effectively communicate to web services <span class="No-Break">hosted locally.</span></p></li> </ol>
<p class="callout-heading">Connecting to local web services</p>
<p class="callout">While developing software, it’s typical to run a local web service and access it using an app in either <a id="_idIndexMarker736"/>an Android emulator or an iOS simulator. Some additional configuration is needed in order for the app to communicate with your local web service. More information about connecting to a local web service and how to configure each platform can be found <span class="No-Break">here: </span><a href="https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services</span></a><span class="No-Break">.</span></p>
<p>If you want to debug the <em class="italic">Recipes!</em> app, we need to tell Visual Studio to run both the mobile app and the API. To do this, right-click <strong class="bold">Solution ‘Recipes App’</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Properties</strong>. In the pop-up, select <strong class="bold">Multiple startup projects</strong> and set the <strong class="bold">Action</strong> of both the <strong class="bold">Recipes.Mobile</strong> and <strong class="bold">Recipes.Web.Api</strong> projects <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Start</strong></span><span class="No-Break">.</span></p>
<p>As we wrap <a id="_idIndexMarker737"/>up this chapter, let’s briefly turn our attention to how we can call APIs from ViewModels, deal with loading indicators, and handle potential errors, all while providing a seamless <span class="No-Break">user experience.</span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor176"/>API communication from ViewModels</h1>
<p>When navigating to the <strong class="source-inline">RecipeDetailPage</strong>, you’ll see some data on the screen while the recipe <a id="_idIndexMarker738"/>is being loaded. The data being shown is <a id="_idIndexMarker739"/>the values defined as <strong class="source-inline">FallbackValue</strong> or <strong class="source-inline">TargetNullValue</strong> in the binding statements as a result of the data in <strong class="source-inline">RecipeDetailViewModel</strong> not being loaded yet. Although effective, I don’t think it looks pretty. Let’s see how we can improve this by showing a loading indicator while the data is <span class="No-Break">being loaded.</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor177"/>Showing a loading indicator</h2>
<p>One of the <a id="_idIndexMarker740"/>simplest yet effective ways to improve user experience is to provide visual feedback during API calls. Consider the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
private bool _isLoading = true;
public bool IsLoading
{
    get =&gt; _isLoading;
    set =&gt; SetProperty(ref _isLoading, value);
}
private async Task LoadRecipe(string recipeId)
{
    <strong class="bold">IsLoading = true;</strong>
...
    await Task.WhenAll(loadRecipeTask,
        loadIsFavoriteTask, loadRatingsTask);
...
    <strong class="bold">IsLoading = false;</strong>
}</pre> <p>Here, we set the <strong class="source-inline">IsLoading</strong> property of the <strong class="source-inline">RecipeDetailViewModel</strong> to <strong class="source-inline">true</strong> before we start <a id="_idIndexMarker741"/>loading the data and it is reverted back to <strong class="source-inline">false</strong> afterward. Thanks to the use of <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>, the UI thread is not blocked during this operation, allowing UI elements such as loading indicators to be updated <span class="No-Break">and rendered.</span></p>
<p>You can bind this property to a loading spinner in your XAML <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;Grid&gt;
    &lt;ScrollView&gt;
        ...
    &lt;/ScrollView&gt;
    &lt;Grid
        BackgroundColor="GhostWhite"
        <strong class="bold">IsVisible="{Binding IsLoading}"</strong>&gt;
        &lt;ActivityIndicator
            HorizontalOptions="Center"
            <strong class="bold">IsRunning="{Binding IsLoading}"</strong>
            VerticalOptions="Center" /&gt;
    &lt;/Grid&gt;
&lt;/Grid&gt;</pre> <p>As a result of this setup, whenever the API call – or any long-running process, for that matter – is in progress, the user receives a visual cue, indicating that the app is currently busy. In the <a id="_idIndexMarker742"/>preceding example, we’ve used a <strong class="source-inline">Grid</strong> property that overlays the entire page and contains an <strong class="source-inline">ActivityIndicator</strong>. However, you’re not limited to this approach; you could also use a message, an animation, or any other UI element that best suits your app’s design and <span class="No-Break">user experience.</span></p>
<p>Using a property to indicate that a task is in progress, and binding this property to the UI, is a common MVVM pattern for managing longer-running operations. The responsiveness is made possible by the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> construct, which keeps the UI thread unblocked, allowing for a smoother <span class="No-Break">user experience.</span></p>
<p>Earlier in this chapter, we already saw how the <strong class="source-inline">Result</strong> object can help us elegantly handle successful and unsuccessful results. Now, let’s take it a step further by enhancing the user experience by handling a <strong class="source-inline">Result</strong> object that <span class="No-Break">indicates failure.</span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor178"/>Handling failures</h2>
<p>Earlier in <a id="_idIndexMarker743"/>this chapter, we introduced the <strong class="source-inline">Result</strong> object as a way to elegantly handle failures. The object’s <strong class="source-inline">IsSuccess</strong> property indicates whether an operation is completed successfully or not. We’ve already seen that in successful cases, the <strong class="source-inline">Data</strong> property gives us access to the result. However, when <strong class="source-inline">IsSuccess</strong> is <strong class="source-inline">false</strong>, it’s crucial not to leave the user guessing. Instead, we should provide clear feedback and offer a way to resolve the issue. Let’s see how this is tackled in the <strong class="source-inline">LoadRecipes</strong> method <a id="_idIndexMarker744"/><span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RecipesOverviewViewModel</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
private async Task LoadRecipes(int pageSize, int page)
{
    LoadFailed = false;
    var loadRecipesTask =
        recipeService.LoadRecipes(pageSize, page);
    ...
    if(recipesResult.IsSuccess)
    {
        //Set TotalNumberOfRecipes property
        //Fill Recipes collection
        ...
    }
    else
    {
        <strong class="bold">LoadFailed = true;</strong>
        <strong class="bold">ReloadCommand =</strong>
<strong class="bold">            new AsyncRelayCommand(</strong>
<strong class="bold">            () =&gt; LoadRecipes(pageSize, page));</strong>
    }
}</pre> <p>As you can see, when the task isn’t successful, the <strong class="source-inline">LoadFailed</strong> property is set to <strong class="source-inline">true</strong>. Also, the <strong class="source-inline">ReloadCommand</strong> property gets initialized. The following code block shows how both properties are data-bound to the UI and will provide the user with some information and the ability to retry loading the list <span class="No-Break">of recipes:</span></p>
<pre class="source-code">
&lt;Grid&gt;
    &lt;CollectionView&gt;
    ...
    &lt;/CollectionView&gt;
    &lt;Grid
        BackgroundColor="{StaticResource Primary}"
        HorizontalOptions="Fill"
        <strong class="bold">IsVisible="{Binding LoadFailed}"</strong>
        VerticalOptions="Fill"&gt;
        &lt;VerticalStackLayout
            HorizontalOptions="Center"
            VerticalOptions="Center"&gt;
            &lt;Label Text="Unable to load recipes" /&gt;
            &lt;Button <strong class="bold">Command="{Binding ReloadCommand}"</strong>
                Text="Retry" /&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/Grid&gt;
&lt;/Grid&gt;</pre> <p>Additionally, we could <a id="_idIndexMarker745"/>show a custom error message to the user when a specific failure occurs. The <strong class="source-inline">ErrorMessage</strong>, <strong class="source-inline">ErrorCode</strong>, and <strong class="source-inline">Exception</strong> properties of the <strong class="source-inline">Result</strong> object could be used for that. This approach eliminates the need for scattering various exception-handling blocks throughout our ViewModels, thereby creating a more streamlined, readable, and maintainable <span class="No-Break">code base.</span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor179"/>Summary</h1>
<p>We kicked off this chapter by revisiting the architecture of our <em class="italic">Recipes!</em> app to include repositories. This addition was aimed at adhering to the principle of SoC and minimizing our app’s dependency on the API itself. We also introduced the <strong class="source-inline">Result</strong> object, a transformative component in our error-handling strategy. This single object encapsulates both success and failure states, making our ViewModels more robust and intelligible. By using the <strong class="source-inline">Result</strong> object, we’ve made it easier to handle anticipated errors in a graceful manner, while still keeping exceptions reserved for <span class="No-Break">critical failures.</span></p>
<p>After setting this architectural foundation, we moved on to explore the power and simplicity of Refit, a type-safe REST client. Refit has substantially streamlined the way we interact with APIs, making the code more readable <span class="No-Break">and maintainable.</span></p>
<p>We also looked at how the <strong class="source-inline">Result</strong> object elegantly fits into our ViewModels, making it far easier to handle expected errors and providing a uniform approach to error management. Alongside this, we discussed practical UI considerations, including loading indicators and error overlays, to offer the user an engaging and <span class="No-Break">informative experience.</span></p>
<p>You should now have a solid understanding of how to make API calls, manage responses, and provide real-time user feedback, all in a resilient and easily <span class="No-Break">maintainable way.</span></p>
<p>In the next chapter, we will be looking at how to create <span class="No-Break">MVVM-friendly controls.</span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li>Refit <span class="No-Break">documentation: </span><a href="https://reactiveui.github.io/refit/"><span class="No-Break">https://reactiveui.github.io/refit/</span></a></li>
<li>Consuming a REST-based web service with <span class="No-Break"><strong class="source-inline">HttpClient</strong></span><span class="No-Break">:</span><span class="No-Break"><span class="hidden"> </span></span><a href="https://learn.microsoft.com/dotnet/maui/data-cloud/rest"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/data-cloud/rest</span></a></li>
</ul>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer069">
<h1 id="_idParaDest-172" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor181"/>Part 3: Mastering MVVM Development</h1>
<p>This final part is all about refining and hardening your .NET MAUI app. We will delve deep into crafting controls that seamlessly integrate with MVVM. You will learn how to expand your app's reach with techniques for localization and fortify your code base with robust unit testing, ensuring stability and reliability. And when things don't go as planned, you will be able to rely on valuable troubleshooting and debugging tips to steer back <span class="No-Break">on course.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B20941_11.xhtml#_idTextAnchor182"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating MVVM-Friendly Controls</em></li>
<li><a href="B20941_12.xhtml#_idTextAnchor196"><em class="italic">Chapter 12</em></a>, <em class="italic">Localization with MVVM</em></li>
<li><a href="B20941_13.xhtml#_idTextAnchor223"><em class="italic">Chapter 13</em></a>, <em class="italic">Unit Testing</em></li>
<li><a href="B20941_14.xhtml#_idTextAnchor238"><em class="italic">Chapter 14</em></a>, <em class="italic">Troubleshooting and Debugging Tips</em></li>
</ul>
</div>
<div>
<div id="_idContainer070">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer071">
</div>
</div>
</div></body></html>