- en: Web Service Stack in ASP.NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的 Web 服务栈
- en: This chapter describes how to deal with controllers and actions in a web service
    stack. Controllers are a fundamental part of ASP.NET Core; they are the entry
    point of the HTTP requests. In this chapter, we will look closely at the mechanics
    of the controller classes and how they can transfer information to the client
    using the HTTP protocol.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何在 Web 服务栈中处理控制器和操作。控制器是 ASP.NET Core 的一个基本部分；它们是 HTTP 请求的入口点。在本章中，我们将仔细研究控制器类的机制以及它们如何使用
    HTTP 协议将信息传输到客户端。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What is a controller?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器是什么？
- en: Handling requests using controllers and actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制器和操作处理请求
- en: How to deal with DTO objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理 DTO 对象
- en: Implementing validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现验证
- en: By the end of the chapter, the reader will have a general overview of the web
    stack provided by ASP.NET Core and will know how to deal with incoming HTTP requests
    using controllers and actions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，读者将对该章提供的 Web 栈有一个总体概述，并将知道如何使用控制器和操作处理传入的 HTTP 请求。
- en: What is a controller?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器是什么？
- en: Controllers are the *C* part of the MVC pattern. They are a set of actions that
    usually handle requests from a client. You should bear in mind that what we are
    discussing in this chapter refers to the MVC stack that's defined by ASP.NET Core.
    Furthermore, if we take as reference the incoming requests, remember that they
    have already passed through the others middleware in the middleware pipeline and
    that they have already hit the *MVC middleware*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是 MVC 模式中的 *C* 部分。它们是一组通常处理来自客户端请求的操作。你应该记住，本章所讨论的内容是指由 ASP.NET Core 定义的
    MVC 栈。此外，如果我们以传入的请求为参考，请记住它们已经通过了中间件管道中的其他中间件，并且已经触发了 *MVC 中间件*。
- en: 'The following diagram shows how a request is typically handled:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了请求通常是如何处理的：
- en: '![](img/bf9541b7-bc49-4440-94c6-19cea945cfe0.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf9541b7-bc49-4440-94c6-19cea945cfe0.png)'
- en: 'As we discussed in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml),
    *REST 101 and Getting Started with ASP.NET Core*, the incoming request is usually
    generated by a client: the browser, another API, or an external system. The request
    is composed of an *HTTP verb,* a *URI*, *body payload*, and other additional information*.*
    The **Routing engine** handles the request and passes it to an *action method*
    inside one of our *controllers.* The **Action** methods usually proceed by providing
    a response. Furthermore, controllers usually interact with third-party systems
    through other classes, such as databases or other services. Finally, they serve
    the result in a specific format. In the case of MVC applications, they usually
    return a view, while in the case of the web API, they return the result in a format
    such as **JSON/XML**:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [第 1 章](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml) 中所讨论的，“REST 101 和 ASP.NET
    Core 入门”，传入的请求通常由客户端生成：浏览器、另一个 API 或外部系统。请求由一个 *HTTP 动词*、一个 *URI*、*请求体有效载荷*和其他附加信息组成。**路由引擎**处理请求并将其传递到我们
    *控制器* 中的一个 *操作方法*。**操作方法**通常通过提供响应来继续执行。此外，控制器通常通过其他类（如数据库或其他服务）与第三方系统交互。最后，它们以特定格式提供服务。在
    MVC 应用程序的情况下，它们通常返回一个视图，而在 Web API 的情况下，它们以 **JSON/XML** 等格式返回结果：
- en: '![](img/73cd4cb1-2e15-40a0-ac07-5c22eab039de.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73cd4cb1-2e15-40a0-ac07-5c22eab039de.png)'
- en: The preceding diagram shows the flow of an incoming request through the model-controller
    stack. As you can see, the flow is omitting the views part of the MVC stack since
    it is not useful for the purpose of building web services. The next part focuses
    on controllers and explains how to identify a controller.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了传入请求通过模型-控制器栈的流程。正如你所见，流程省略了 MVC 栈中的视图部分，因为它对于构建 Web 服务没有太大用处。下一部分将重点介绍控制器，并解释如何识别控制器。
- en: Identifying controllers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别控制器
- en: Controllers and actions are usually decorated with attributes and filters in
    a sort of meta-programming style, which allows developers to understand the purpose
    of the implemented code. ASP.NET Core follows a set of criteria to find the controllers
    in our project, usually by using a filesystem convention. Controllers are generally
    stored in the `Controllers` folder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器和操作通常以某种元编程风格装饰属性和过滤器，这允许开发者理解实现代码的目的。ASP.NET Core 遵循一系列标准来在我们的项目中查找控制器，通常是通过使用文件系统约定。控制器通常存储在
    `Controllers` 文件夹中。
- en: 'In order to be identified by the routing system, a controller class needs to
    be compliant with one of the following rules:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了被路由系统识别，控制器类需要遵守以下规则之一：
- en: The class is suffixed with `Controller`, or it inherits from a class that has
    the `Controller` suffix
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类以 `Controller` 后缀结尾，或者它继承自具有 `Controller` 后缀的类
- en: The class is decorated with the `[Controller]` or the `[ApiController]` attribute,
    which identifies it as a controller class
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类被装饰了 `[Controller]` 或 `[ApiController]` 属性，这表明它是一个控制器类
- en: As we mentioned in [Chapter 4](54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml),
    *Dependency Injection*, it is recommended to define controller dependencies using
    the constructor or action injection explicitly. The dependency injection approach
    improves the testability and maintainability of the controller.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第 4 章](54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml)中提到的*依赖注入*，建议显式使用构造函数或操作注入来定义控制器依赖项。依赖注入方法提高了控制器的可测试性和可维护性。
- en: Now, let's see how a widespread concept like inheritance can be applied to the
    controllers in order to extend their functionalities, and how ASP.NET Core provides
    some of the bases attributes to the controller classes using this technique.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将像继承这样的广泛概念应用于控制器以扩展其功能，以及 ASP.NET Core 如何使用这种技术为控制器类提供一些基本属性。
- en: Extending controllers
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展控制器
- en: 'As already mentioned, controllers are classes, therefore they can extend other
    types, including other controllers. This technique can be applied so that we can
    reuse a particular implementation or feature. In general, the controllers extend
    the `Controller` or `ControllerBase` classes, which are part of the ASP.NET Core
    framework. These base classes provide some utilities to manage requests and responses
    on behalf of the controller. First of all, let''s analyze the difference between
    the `Controller` and `ControllerBase` classes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，控制器是类，因此它们可以扩展其他类型，包括其他控制器。这种技术可以应用，以便我们可以重用特定的实现或功能。通常，控制器扩展 `Controller`
    或 `ControllerBase` 类，这些类是 ASP.NET Core 框架的一部分。这些基类为控制器提供了管理请求和响应的一些工具。首先，让我们分析
    `Controller` 和 `ControllerBase` 类之间的区别：
- en: '`ControllerBase` represents a base class for an MVC controller without view
    support. It provides some essential attributes to child classes, such as the `HttpContext`,
    `Request`, and `Response` attributes.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControllerBase` 代表一个没有视图支持的 MVC 控制器的基类。它为子类提供了一些基本属性，例如 `HttpContext`、`Request`
    和 `Response` 属性。'
- en: The `Controller` class extends the `ControllerBase` class, but it also adds
    some properties and methods for managing views, such as the `ViewData` attribute
    and the `View()` and `PartialView()` methods.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controller` 类扩展了 `ControllerBase` 类，但它还添加了一些用于管理视图的属性和方法，例如 `ViewData` 属性和
    `View()` 以及 `PartialView()` 方法。'
- en: When we deal with RESTful APIs and with web services in general, the `ControllerBase`
    class provides sufficient utilities. If we are dealing with views, however, we
    should extend the `Controller` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理 RESTful API 和一般意义上的 Web 服务时，`ControllerBase` 类提供了足够的工具。然而，如果我们处理视图，则应扩展
    `Controller` 类。
- en: The ApiController attribute
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ApiController` 属性'
- en: 'From version 2.1, ASP.NET Core introduced a new attribute, that is, the `ApiController`
    attribute:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.1 版本开始，ASP.NET Core 引入了一个新的属性，即 `ApiController` 属性：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ApiController` attribute is commonly coupled with the `ControllerBase`
    class to enable REST-specific behavior for controllers, and it allows us to build
    HTTP APIs. First of all, it provides *implicit model state validation*, which
    means that we do not need to explicitly check the `ModelState.IsValid` attribute
    in each action. Secondly, it also implicitly defines the model binding attributes,
    which means that we do not need to specify the `[FromBody]`, `[FromForm]`, `[FromHeader]`,
    `[FromQuery]`, or `[FromRoute]` attributes for each parameter. ASP.NET Core will
    define these for us using the following criteria:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiController` 属性通常与 `ControllerBase` 类结合使用，以使控制器能够实现 REST 特定的行为，并允许我们构建 HTTP
    API。首先，它提供了*隐式模型状态验证*，这意味着我们不需要在每个操作中显式检查 `ModelState.IsValid` 属性。其次，它还隐式定义了模型绑定属性，这意味着我们不需要为每个参数指定
    `[FromBody]`、`[FromForm]`、`[FromHeader]`、`[FromQuery]` 或 `[FromRoute]` 属性。ASP.NET
    Core 将根据以下标准为我们定义这些属性：'
- en: '`[FromBody]` is used for complex type parameters, such as custom classes or
    built-in objects.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromBody]` 用于复杂类型参数，例如自定义类或内置对象。'
- en: '`[FromForm]` is inferred for action parameters of the `IFormFile` or `IFormFileCollection`
    type.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromForm]` 用于推断 `IFormFile` 或 `IFormFileCollection` 类型的操作参数。'
- en: '`[FromRoute]` is inferred for any action parameter whose name matches a setting
    in the route template.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromRoute]` 用于任何名称与路由模板中设置匹配的操作参数。'
- en: '`[FromQuery]` is inferred for any other action parameters.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromQuery]` 用于推断任何其他操作参数。'
- en: 'Let''s examine the following generic action method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下通用操作方法：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the application of the `ApiController` attribute, the action method can
    be minimized, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用了 `ApiController` 属性之后，操作方法可以最小化，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `[FromBody]` attribute is implicitly specified because of the `ValueRequest`
    complex type. In the same way, the `ModelState.IsValid` check is also implicit:
    if the client passes a model that is not valid for the action, it will return
    `400 bad requests`. In the next section, we will look into the implementation
    of a simple controller that can handle and perform some logic using a repository
    class.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`[FromBody]` 属性由于 `ValueRequest` 复杂类型而被隐式指定。同样，`ModelState.IsValid` 检查也是隐式的：如果客户端传递了一个对操作无效的模型，它将返回
    `400 bad requests`。在下一节中，我们将探讨一个简单控制器的实现，该控制器可以使用仓库类处理和执行一些逻辑。'
- en: Handling requests using controllers and actions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制器和操作处理请求
- en: The purpose of action methods is to handle and respond to incoming requests.
    The example described in this section will show you how to deal with HTTP requests
    using controllers. We will apply some of the concepts we have looked at in previous
    chapters, such as dependency injection. The following example will use the same
    project structure we created in *Setting up an ASP.NET Core project* section of
    [Chapter 2](6127f023-703b-42e3-a76e-b70a7b110b90.xhtml), *Overview of ASP.NET
    Core.*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 操作方法的目的在于处理和响应传入的请求。本节中描述的示例将向您展示如何使用控制器处理HTTP请求。我们将应用我们在前几章中探讨的一些概念，例如依赖注入。以下示例将使用我们在
    [第2章](6127f023-703b-42e3-a76e-b70a7b110b90.xhtml) 的 *设置ASP.NET Core项目* 部分中创建的相同项目结构，*ASP.NET
    Core概述*。
- en: The source code for this section is available on GitHub at [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的源代码可在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3)。
- en: The next subsection introduces a plain in-memory repository that will be used
    to store some data and retrieve it through our controller stack. The purpose of
    this type of repository is to set up a quick storage system without introducing
    any additional application complexity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节介绍了一个简单的内存中仓库，它将被用来存储一些数据并通过我们的控制器堆栈检索它。这种类型仓库的目的是设置一个快速存储系统，而不引入任何额外的应用程序复杂性。
- en: Creating an in-memory repository
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建内存中仓库
- en: The simplest way to create an *in-memory* repository is to define a singleton
    class with a private attribute, which represents a collection of elements. The
    repository will be initialized as a *singleton type*; therefore, this specific
    life cycle guarantees that data will be persistent until the application is restarted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 *内存中* 仓库的最简单方法是通过定义一个具有私有属性的单一实例类，该属性代表一个元素集合。仓库将被初始化为 *单一实例类型*；因此，这种特定的生命周期保证了数据将持续到应用程序重启。
- en: At this stage, we don't need to use a repository with a real data source because
    we only need to focus on the HTTP part of our example and not how the data is
    stored. Later on in this book, we will take a look closer at the data access part.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们不需要使用带有真实数据源的仓库，因为我们只需要关注示例中的HTTP部分，而不是数据的存储方式。在本书的后续部分，我们将更详细地探讨数据访问部分。
- en: 'First of all, we need a model that represents the data we want to store using
    our repository. Let''s create a new folder, called `Models`, and create a new
    class named `Order.cs`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个模型来表示我们想要使用仓库存储的数据。让我们创建一个名为 `Models` 的新文件夹，并创建一个名为 `Order.cs` 的新类：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we need to define a new interface called `IOrderRepository`. The interface
    represents our order repository, and it will be located in a new folder called
    `Repositories`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个新的接口，称为 `IOrderRepository`。该接口表示我们的订单仓库，它将位于一个名为 `Repositories` 的新文件夹中：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our interface is implemented by the `MemoryOrderRepository` class, which provides
    the concrete logic of our interface:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接口由 `MemoryOrderRepository` 类实现，它提供了我们接口的具体逻辑：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `MemoryOrderRepository` class initializes a private list of the `Order`
    type. Furthermore, it also defines some operations that we can use to manipulate
    the list of orders, that are, the `Get`, `Add`, `Update`, and `Delete` methods.
    These methods use the LINQ syntax to act on the list elements. Furthermore, the
    main collection that's represented by the `_orders` attribute is declared as private
    in order to prevent any external access.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemoryOrderRepository` 类初始化一个私有的 `Order` 类型列表。此外，它还定义了一些我们可以用来操作订单列表的操作，即
    `Get`、`Add`、`Update` 和 `Delete` 方法。这些方法使用 LINQ 语法对列表元素进行操作。此外，由 `_orders` 属性表示的主要集合被声明为私有，以防止任何外部访问。'
- en: Note that each namespace path reflects the structure of the filesystem. For
    example, the `SampleAPI.Repositories` namespace reflects the `Sample.API/Repositories`
    filesystem path.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个命名空间路径反映了文件系统的结构。例如，`SampleAPI.Repositories` 命名空间反映了 `Sample.API/Repositories`
    文件系统路径。
- en: 'Finally, we can proceed by initializing the `MemoryOrderRepository` implementation
    as *a singleton.* To do that, we need to modify the `Startup` class and add our
    service to the *services collection* using the `AddSingleton` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过初始化 `MemoryOrderRepository` 实现作为 *单例* 来继续。为此，我们需要修改 `Startup` 类，并使用
    `AddSingleton` 方法将我们的服务添加到 *服务集合* 中：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following example uses the `IOrderRepository` interface for demonstration
    and learning purposes. I strongly suggest that you avoid using singleton instances
    to store data in memory since singleton instances are not persistent storage,
    and this also causes performance degradation in our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `IOrderRepository` 接口进行演示和学习目的。我强烈建议您避免使用单例实例在内存中存储数据，因为单例实例不是持久存储，这也导致我们的应用程序性能下降。
- en: In summary, we now have an `Order` class that describes a single order. The
    `IOrderRepository` interface allows us to store and read the data, and it has
    an in-memory implementation provided by the `MemoryOrderRepository` type, which
    uses the memory as a data store. Now, we have all the necessary components so
    that we can deal with the data and we can proceed by handling the client request
    through our controller.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们现在有一个描述单个订单的 `Order` 类。`IOrderRepository` 接口允许我们存储和读取数据，并且由 `MemoryOrderRepository`
    类型提供的内存实现，它使用内存作为数据存储。现在，我们拥有了处理数据和通过控制器处理客户端请求的所有必要组件。
- en: Handling client requests
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理客户端请求
- en: 'Every time we implement a class, we should always bear the *single* *responsibility*
    *principle* in mind.Therefore*,* the action methods inside our controllers should
    be simple handlers that call methods that act as data. The controllers in an ASP.NET
    Core service usually behave as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们实现一个类时，我们都应该始终牢记 *单一* *责任* *原则*。因此，*我们的控制器中的动作方法应该是简单的处理程序，调用作为数据操作的方法。ASP.NET
    Core 中的控制器通常表现如下：
- en: They make calls other classes in order to obtain or update data held in, for
    example, a repository class.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们调用其他类以获取或更新存储在，例如，仓库类中的数据。
- en: They handle exceptions. The action methods typically wrap the calls of other
    objects to catch exceptions. These are then presented to the client.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们处理异常。动作方法通常封装对其他对象的调用以捕获异常。然后，这些异常被呈现给客户端。
- en: They enhance the returned data using the required HTTP conventions.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们使用所需的 HTTP 规范增强返回的数据。
- en: 'Let''s proceed and build our controller class by creating a new `OrderController`
    type inside the `Controllers` folder. This bit of code includes the `ApiController`
    attribute and the extension to the `ControllerBase` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，通过在 `Controllers` 文件夹内创建一个新的 `OrderController` 类型来构建我们的控制器类。这段代码包括 `ApiController`
    属性和对 `ControllerBase` 类的扩展：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'ASP.NET Core provides two ways to deal with routing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供两种处理路由的方式：
- en: Decorating controllers with attributes
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性装饰控制器
- en: Extending the default routing system (for example, using the `MapRoute` method)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展默认的路由系统（例如，使用 `MapRoute` 方法）
- en: 'Defining routes using attributes covers a lot of cases and is suitable for
    a range of business requirements. It is also more straightforward in regard to
    the maintainability and readability of our code. The `[Route("api/order")]` attribute
    maps a specific controller to one particular route. In this case, the `OrderController`
    will respond at the `//hostname/api/order` URI. In addition, the ASP.NET Core
    framework also provides two placeholders: `[controller]` and `[action]`. They
    can be used to refer to the current controller or to the immediate action. For
    example, the previous snippet can also be written as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性定义路由可以覆盖很多情况，并且适用于各种业务需求。它也使得我们代码的维护性和可读性更加直接。`[Route("api/order")]` 属性将一个特定的控制器映射到一条特定的路由。在这种情况下，`OrderController`
    将响应于 `//hostname/api/order` URI。此外，ASP.NET Core 框架还提供了两个占位符：`[controller]` 和 `[action]`。它们可以用来引用当前控制器或直接的动作。例如，前面的代码片段也可以写成如下形式：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I strongly suggest avoiding the use of the `[controller]` and `[action]` placeholders.
    If you refactor the name of your controllers or actions, you also change the routing
    of your service without throwing any errors. Therefore, it can cause problems
    in systems with interdependent services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议避免使用 `[controller]` 和 `[action]` 占位符。如果你重构控制器或动作的名称，你也会改变服务的路由而不会抛出任何错误。因此，它可能会在相互依赖的服务系统中引起问题。
- en: Let's proceed by initializing and resolving the dependencies of the `OrderController`
    class. Furthermore, we will see how we can inject and initialize the `IOrderRepository`
    interface into the controller.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们初始化并解析 `OrderController` 类的依赖项。此外，我们将看到如何将 `IOrderRepository` 接口注入并初始化到控制器中。
- en: Handling HTTP methods using actions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动作处理 HTTP 方法
- en: 'Now that we have the `OrderController` definition and the `IOrderRepository`
    interface has been registered through the dependency injection engine, we can
    proceed by defining the explicit dependencies using *constructor injection*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `OrderController` 的定义，并且 `IOrderRepository` 接口已经通过依赖注入引擎注册，我们可以通过定义显式依赖项来继续，使用
    *构造函数注入*：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `OrderController` class depends on the `IOrderRepository` class, and it
    uses constructor injection to resolve the dependency. This dependency is clearly
    visible if we check the constructor signature of the controller. In most cases,
    you can get an idea of the level of complexity of a class by counting the number
    of dependencies that have been injected into the *constructor*. Therefore, as
    a general rule, when you see a class with a lot of dependencies injected into
    it, it is probably not compliant with the *single responsibility principle.*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderController` 类依赖于 `IOrderRepository` 类，并且它使用构造函数注入来解析依赖。如果我们检查控制器的构造函数签名，这种依赖关系将非常明显。在大多数情况下，你可以通过计算注入到
    *构造函数* 中的依赖项数量来了解一个类的复杂程度。因此，作为一般规则，当你看到一个有很多依赖项注入到其中的类时，它可能不符合 *单一职责原则*。'
- en: 'The controller classes usually group a set of action methods. As we discussed
    in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml), *REST 101 and Getting
    Started with ASP.NET Core*, HTTP verbs are essential in web APIs and REST services.
    They are used to indicate a specific operation on our data. For example, an HTTP
    GET corresponds to a read operation, while an HTTP POST corresponds to a creation
    action. Let''s continue with the implementation of the HTTP GET actions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器类通常将一组动作方法分组在一起。正如我们在 [第 1 章](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml)
    中讨论的，*REST 101 和 ASP.NET Core 入门*，HTTP 动词在 Web API 和 REST 服务中至关重要。它们用于指示我们对数据执行的具体操作。例如，HTTP
    GET 对应于读取操作，而 HTTP POST 对应于创建动作。让我们继续实现 HTTP GET 动作：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The implementation describes two actions, which means there are two different
    routes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实现描述了两个动作，这意味着存在两条不同的路由：
- en: '| **Http verb** | **URI** | **Action** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **Http verb** | **URI** | **Action** |'
- en: '| `GET` | `hostname/api/order` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `hostname/api/order` |'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `GET` | `hostname/api/order/<guid>` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `hostname/api/order/<guid>` |'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'As we mentioned previously, ASP.NET Core handles incoming requests and maps
    them to actions using the routing middleware. Routes are defined both in the startup
    code and in the attributes. Each HTTP verb has its corresponding attribute: `HttpGet`
    corresponds to the `GET` method, `HttpPost` corresponds to the `POST` method,
    and so on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，ASP.NET Core 通过路由中间件处理传入的请求并将它们映射到动作。路由既在启动代码中定义，也在属性中定义。每个 HTTP 动词都有一个对应的属性：`HttpGet`
    对应于 `GET` 方法，`HttpPost` 对应于 `POST` 方法，依此类推。
- en: 'In general, HTTP verb attributes have a signature that looks as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，HTTP动词属性具有以下签名：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The *template* is a stringparameter that represents the URL of a specific action.
    It may also accept some *routing constraints.* For example, `[HttpGet("{id:guid}")]`
    will receive a GUID identifier in the form of a string:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板*是一个字符串参数，表示特定操作的URL。它也可以接受一些*路由约束*。例如，`[HttpGet("{id:guid}")]`将接收一个以字符串形式出现的GUID标识符：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will look at routing constraints in more detail in [Chapter 6](88a48d0b-32c6-4adb-b907-ecd8365a3659.xhtml),
    *Routing System*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第6章[路由系统](88a48d0b-32c6-4adb-b907-ecd8365a3659.xhtml)中更详细地探讨路由约束。
- en: It is essential to bear in mind that routing constraints are not meant to be
    a validation system. If we have an invalid route, our service will return `404
    Not Found` and not `400 Bad Request`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 必须牢记，路由约束并不是为了成为一个验证系统。如果我们有一个无效的路由，我们的服务将返回`404 Not Found`而不是`400 Bad Request`。
- en: 'The `Name` parameter of the attribute indicates the route name that identifies
    that action method. In general, it doesn''t have any impact on the routing system.
    Besides, it is used to refer to the routing rule during the generation of the
    URL, and it must be unique in the entire code base. By following the preceding
    specifications, it is easy to implement the other CRUD operations in our controller.
    The result looks as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的`Name`参数表示标识该操作方法的路由名称。通常，它对路由系统没有影响。此外，它用于在生成URL时引用路由规则，并且在整个代码库中必须是唯一的。遵循前面的规范，我们很容易在我们的控制器中实现其他CRUD操作。结果如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we''ve had a quick look at the implementation controller, let''s have
    a closer look at the actions that are defined by it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速浏览了实现控制器，让我们更仔细地看看由它定义的操作：
- en: '| **HTTP verb** | **URI** | **Action** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **URI** | **操作** |'
- en: '| `GET` | `hostname/api/order` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `hostname/api/order` |'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `GET` | `hostname/api/order/<guid>` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `hostname/api/order/<guid>` |'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `POST` | `hostname/api/order` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `hostname/api/order` |'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `PUT` | `hostname/api/order/<guid>` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `hostname/api/order/<guid>` |'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `DELETE` | `hostname/api/order/<guid>` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `hostname/api/order/<guid>` |'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: We should also notice that the controller does not implement any validation
    on the input data. Furthermore, the `[ApiController]` attribute, when applied
    on top of a class, provides the *out-of-the-box validation* and model binding
    of ASP.NET Core. Therefore, all the associated objects, such as the `Order request`
    parameter, must be passed from the body of the request in case they are required.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意到，控制器不对输入数据进行任何验证。此外，当`[ApiController]`属性应用于类之上时，它提供了ASP.NET Core的*开箱即用验证*和模型绑定。因此，所有相关的对象，例如`Order请求`参数，如果需要，必须从请求体中传递。
- en: 'To run the ASP.NET Core api, we should run our application by executing `dotnet
    run` inside the project folder and perform an HTTP request using `curl` or whatever
    client, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行ASP.NET Core api，我们应该在项目文件夹中执行`dotnet run`来运行我们的应用程序，并使用`curl`或其他客户端执行HTTP请求，如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding command executes a GET request on the `/api/order` URL, using
    the `Content-Type: application/json`. Since ASP.NET Core provides HTTPS out-of-box
    we can ignore the certificate validation using the `-k` flag. Later in the book,
    we will see how to install the certificate locally.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '以下命令在`/api/order` URL上执行一个GET请求，使用`Content-Type: application/json`。由于ASP.NET
    Core默认提供HTTPS，我们可以使用`-k`标志忽略证书验证。本书后面我们将看到如何在本地上安装证书。'
- en: 'The output will look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For Windows users, starting from Windows 10, build 17063 ([https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/](https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/)),
    the OS ships with a copy of `curl` already set up and ready to use. However, it
    is possible to download and install `curl` from [https://curl.haxx.se/](https://curl.haxx.se/).
    Another option is to install `curl` using the Chocolatey package manager by executing
    `choco install curl` on your command line.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，从Windows 10版本17063开始（[https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/](https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/))，操作系统自带了一个已经设置好并准备好使用的`curl`副本。然而，您也可以从[https://curl.haxx.se/](https://curl.haxx.se/)下载并安装`curl`。另一个选项是使用Chocolatey包管理器通过在命令行中执行`choco
    install curl`来安装`curl`。
- en: 'Futhermore, if we try to perform a `curl` command with an empty payload as
    follow:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们尝试执行一个带有空有效载荷的`curl`命令如下：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output will look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we have passed an empty body payload using the `-d` empty flag.
    Therefore, the out-of-the-box model validation returns the error message in the
    request's response, and it returns an HTTP `400 Bad request` message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `-d` 空标志传递了一个空的正文有效载荷。因此，默认的模型验证在请求的响应中返回错误消息，并返回一个 HTTP `400 Bad
    request` 消息。
- en: In real-world applications, this kind of validation is not enough. It is usually
    replaced by some custom validations, such as *data annotation* or *fluent validation.*
    We will look at these techniques in more detail later in this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，这类验证是不够的。通常会被一些自定义验证所取代，例如 *数据注释* 或 *流畅验证*。我们将在本章的后面部分更详细地探讨这些技术。
- en: Responding to requests
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应请求
- en: Now that we have a controller that is able to handle our requests, we should
    focus on the response part. Looking at the `OrderController` from the response
    point of view, we may notice that it is not compliant with REST specifications.
    None of the action methods considers any failure states. What should happen if
    our data source is down? What should happen if the requested order is not present
    in our repository?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个能够处理我们请求的控制器，我们应该关注响应部分。从响应的角度来看 `OrderController`，我们可能会注意到它不符合 REST
    规范。没有任何动作方法考虑任何失败状态。如果我们的数据源出现故障会发生什么？如果请求的订单不在我们的存储库中，会发生什么？
- en: 'Let''s start by checking what happens when we ask for an order that doesn''t
    exist. To proceed with this check, all we need to do is make a `curl` request
    with a GUID that doesn''t exist:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查一下当我们请求一个不存在的订单时会发生什么。为了进行这项检查，我们只需要使用一个不存在的 GUID 进行 `curl` 请求：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding command-line instruction will produce the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令行指令将产生以下输出：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see from the response, ASP.NET Core automatically handles the empty
    result, and it returns the HTTP status `204 No Content`. It is important to note
    that all these behaviors came out of the box. Besides, it is also possible to
    override the default components and add our own custom validation implementation
    and response handling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从响应中我们可以看到，ASP.NET Core 自动处理了空结果，并返回了 HTTP 状态 `204 No Content`。需要注意的是，所有这些行为都是默认提供的。此外，还可以覆盖默认组件，并添加我们自己的自定义验证实现和响应处理。
- en: CreateAt response
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateAt 响应
- en: 'The `Post` action method is responsible for creating resources. Another principal
    responsibility of the `Post` action method is to tell the client where the resource
    is created and how to access it. This responsibility is usually implemented within
    the action method. ASP.NET Core provides two methods that can give this information
    to the client, which are `CreatedAtAction` and `CreatedAtRoute`. The following
    example shows how to use the `CreatedAtAction` method in our `Post` action:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post` 动作方法负责创建资源。`Post` 动作方法的另一个主要责任是告诉客户端资源创建的位置以及如何访问它。这种责任通常在动作方法中实现。ASP.NET
    Core 提供了两种可以向客户端提供这种信息的方法，即 `CreatedAtAction` 和 `CreatedAtRoute`。以下示例展示了如何在我们的
    `Post` 动作中使用 `CreatedAtAction` 方法：'
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After that, the response to the below `POST` request will appear as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，对以下 `POST` 请求的响应将如下所示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the response contains the `201 Created` header. It also provides
    the `Location` of the resource. This kind of information is useful for the client
    so that we can get more information about the resource.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，响应包含 `201 Created` 标头。它还提供了资源的 `Location`。这类信息对客户端很有用，我们可以获取更多关于资源的信息。
- en: 'The `CreateAtAction` method accepts three parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAtAction` 方法接受三个参数：'
- en: '`actionName` represents the name of the action that''s used for generating
    the URL.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionName` 表示用于生成 URL 的操作名称。'
- en: '`routeValues` is an object that contains all the parameters of the action.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routeValues` 是一个包含动作所有参数的对象。'
- en: '`value` is an object that represents the content of the response.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 是一个表示响应内容的对象。'
- en: An alternative to `CreateAtAction` is `CreateAtRoute`, which takes the `routeName`
    and generates the same result as `CreateAtAction`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAtAction` 的另一种选择是 `CreateAtRoute`，它接受 `routeName` 并生成与 `CreateAtAction`
    相同的结果。'
- en: Updating resources
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新资源
- en: The `Put` action handles how resources are updated. We should bear in mind that
    the `PUT` verb is intended as a total replacement of the specific resource. Therefore,
    when we call an API using a `PUT` verb, all the resource fields will be replaced
    with the *body payload.* As we will see later in this chapter, for a more precise
    update for some of the specific fields of our entity, it is better to use the
    `PATCH` verb.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Put`操作处理资源的更新方式。我们应该记住，`PUT`动词的目的是完全替换特定的资源。因此，当我们使用`PUT`动词调用API时，所有资源字段都将被`body
    payload`替换。正如我们将在本章后面看到的那样，为了对实体的一些特定字段进行更精确的更新，最好使用`PATCH`动词。'
- en: 'Another critical thing to keep in mind when we implement a `Put` action is
    that we need to handle Ids that don''t exist. APIs usually manage non-existent
    IDs in `Put` actions using two different approaches:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实施`Put`操作时，需要记住的另一件重要的事情是我们需要处理不存在的Ids。API通常在`Put`操作中使用两种不同的方法来管理不存在的Ids：
- en: When the client makes an update request on a non-existent ID, the API creates
    a new record with that resource.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端对一个不存在的ID发起更新请求时，API会使用该资源创建一个新的记录。
- en: When the client makes an update request on a non-existent ID, the API informs
    the client that the resource doesn't exist with a `404 Not Found` error.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端对一个不存在的ID发起更新请求时，API会通过一个`404 Not Found`错误通知客户端该资源不存在。
- en: I'm not a massive supporter of `CreateOrUpdate` methods. I prefer to keep the
    `Put` action compliant with the *single* *responsibility* *principle.* Therefore,
    separate the *create* and *update* operations into two different action methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是`CreateOrUpdate`方法的强烈支持者。我更喜欢让`Put`操作符合`单一`职责原则。因此，将`创建`和`更新`操作分别放入两个不同的操作方法中。
- en: 'Let''s see how we can implement our `Put` action:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现我们的`Put`操作：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first step is to check whether the order with the corresponding `id` exists.
    If it doesn't exist, the application returns a `404 Not Found` error. Otherwise,
    it performs the update operation and returns `200 Ok`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检查是否存在具有相应`id`的订单。如果不存在，应用程序将返回一个`404 Not Found`错误。否则，它将执行更新操作并返回`200 Ok`。
- en: Note that the `NotFound` result also contains a message. In real-world applications,
    this message is usually associated with a piece of code, that is, a custom error,
    and it is serialized into JSON or XML format.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`NotFound`结果还包含一条消息。在实际应用中，这条消息通常与一段代码相关联，即自定义错误，并将其序列化为JSON或XML格式。
- en: 'It is also significant to consider what should happen when the request contains
    `null` in `itemsIds`. It is essential to understand the difference between a `null`
    request object and an empty request object. In the first case, the client may
    accidentally call our APIs without passing any value. In the second case, the
    client explicitly requests our resource to be replaced with an empty value. Let''s
    modify our code to avoid `null` request values by adding the following guard as
    the first statement of our `Put` method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到请求中`itemsIds`包含`null`的情况也是非常重要的。理解`null`请求对象和空请求对象之间的区别是至关重要的。在前一种情况下，客户端可能意外地调用我们的API而没有传递任何值。在后一种情况下，客户端明确请求我们的资源被空值替换。让我们修改我们的代码，通过在`Put`方法的第一个语句中添加以下保护措施来避免`null`请求值：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding `if` statement returns a `BadRequest` message if the `ItemsIds`
    field is `null`. Therefore, the client that sent the request will now the source
    of the issue. In the next section, we will discover another widespread update
    technique implemented in RESTful web services.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`if`语句会在`ItemsIds`字段为`null`时返回一个`BadRequest`消息。因此，发送请求的客户端现在会知道问题的来源。在下一节中，我们将发现RESTful
    Web服务中实施的一种广泛使用的更新技术。
- en: Partial updating
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分更新
- en: '`Put` actions are used to replace a resource with another one. Therefore, the
    client must add the whole entity in the *body payload* of the request. If our
    entity is a complex object, keeping the entire entity in memory may cause performance
    issues. It is possible to avoid these problems by implementing a `Patch` action
    instead. The `Patch` action usually modifies an existing resource without replacing
    it, therefore you are able to specify only one the field you want to update. Let''s
    see how we can perform this kind of action in ASP.NET Core.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Put`操作用于用另一个资源替换资源。因此，客户端必须在请求的`body payload`中添加整个实体。如果我们的实体是一个复杂对象，将整个实体保留在内存中可能会导致性能问题。通过实现`Patch`操作可以避免这些问题。`Patch`操作通常在不替换资源的情况下修改现有的资源，因此您只能指定要更新的字段之一。让我们看看我们如何在ASP.NET
    Core中执行这种类型的操作。'
- en: 'First of all, let''s add a new field to our `Order.cs` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的 `Order.cs` 类中添加一个新字段：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, the `Order` class contains an additional field that represents the currency
    of our orders. Let''s create a `Patch` action in our `OrderController`. The code
    we are going to implement uses two NuGet packages that provide the support for
    the PATCH method and all the types that help us to perform the operations related
    to that type of HTTP verb. We can add the package to our project by running the
    following instructions in the `SampleAPI` project folder:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Order` 类包含了一个表示我们订单货币的额外字段。让我们在我们的 `OrderController` 中创建一个 `Patch` 动作。我们将要实现的代码使用了两个
    NuGet 包，这些包提供了对 PATCH 方法的支持以及所有帮助我们执行与该类型 HTTP 动词相关的操作的类型。我们可以通过在 `SampleAPI`
    项目文件夹中运行以下指令将包添加到我们的项目中：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first NuGet package provides the `JsonPatchDocument` class type, the second
    package enables the `NewtonsoftJson` serializer needed by the PATCH operation
    support. In addition, we should also enable the NewtonsoftJson serializer into
    the application by adding the following extension method in the `Startup` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 NuGet 包提供了 `JsonPatchDocument` 类类型，第二个包启用了 PATCH 操作支持所需的 `NewtonsoftJson`
    序列化器。此外，我们还应该在 `Startup` 类中添加以下扩展方法来将 NewtonsoftJson 序列化器启用到应用程序中：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Furthermore, it is possible to implement the `Patch` action method in the following
    way:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以以下方式实现 `Patch` 动作方法：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The aforementioned code has three key points:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有三个关键点：
- en: The action method reacts to the `HttpPatch` verb requests. Just like the `Put`
    action, it accepts a `Guid` as the input parameter, which identifies the target
    resource.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作方法响应 `HttpPatch` 动词请求。就像 `Put` 动作一样，它接受一个 `Guid` 作为输入参数，用于标识目标资源。
- en: The action method also accepts a `JsonPatchDocument` as the payload of the body.
    The `JsonPatchDocument` class is a generic class that is part of the ASP.NET Core
    Framework. More specifically, our action uses the `JsonPatchDocument<Order>` type
    to implement operations on our `Order` class.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作方法还接受一个 `JsonPatchDocument` 作为请求体的有效载荷。`JsonPatchDocument` 类是一个泛型类，它是 ASP.NET
    Core 框架的一部分。更具体地说，我们的动作使用 `JsonPatchDocument<Order>` 类型来对 `Order` 类执行操作。
- en: The action method applies the `JsonPatchDocument` class using the `ApplyTo`
    method, which merges the changes in the request to our target resource. Finally,
    it updates the repository.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作方法使用 `ApplyTo` 方法应用 `JsonPatchDocument` 类，该方法将请求中的更改合并到我们的目标资源中。最后，它更新了存储库。
- en: 'The `JsonPatchDocument` class accepts a specific request schema. For example,
    the following `curl` operation performs a partial update through the `PATCH` verb:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonPatchDocument` 类接受特定的请求模式。例如，以下 `curl` 操作通过 `PATCH` 动词执行部分更新：'
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this case, the body payload is a JSON array of objects: every object is
    composed of an `op` field, a `path`, and a `value`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，请求体有效载荷是一个对象的 JSON 数组：每个对象由一个 `op` 字段、一个 `path` 和一个 `value` 组成。
- en: 'The `op` field describes the operation to perform on our target, `path` refers
    to the name of our field, and `value` is the replacement for our target. In this
    case, the request will replace the `itemsIds` field with the value `[1,2]`. Furthermore,
    the `op` field accepts a bunch of operations on data, including `add` and `remove`.
    As we saw previously, the syntax is almost the same as it was in the previous
    example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`op` 字段描述了对目标要执行的操作，`path` 指的是我们字段的名称，而 `value` 是目标的替换值。在这种情况下，请求将用值 `[1,2]`
    替换 `itemsIds` 字段。此外，`op` 字段接受对数据的一组操作，包括 `add` 和 `remove`。正如我们之前看到的，语法几乎与上一个示例相同：'
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`JsonPatchDocument` is compliant with the specification of the **Internet Engineering
    Task Force** (**IETF**), an organization that promotes internet standards. You
    can find out more information about the `Patch` document syntax in the declaration
    of the standard at the following link: [https://tools.ietf.org/html/rfc5789](https://tools.ietf.org/html/rfc5789).
    All the other specifications about the HTTP method that we''ve discussed in this
    chapter can also be found here.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonPatchDocument` 符合 **互联网工程任务组**（**IETF**）的规范，这是一个推广互联网标准的组织。您可以在以下链接的标准声明中找到有关
    `Patch` 文档语法的更多信息：[https://tools.ietf.org/html/rfc5789](https://tools.ietf.org/html/rfc5789)。本章中讨论的所有其他关于
    HTTP 方法的规范也可以在这里找到。'
- en: You should pay attention when using the `JsonPatchDocument` object. The client
    may request to update a read-only field or a non-existent field. Furthermore,
    the `JsonPatchDocument` type requires a **validation step**. This problem is usually
    solved by creating a custom **data transfer object** (**DTO**) model for this
    kind of request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `JsonPatchDocument` 对象时，你应该注意。客户端可能请求更新只读字段或不存在字段。此外，`JsonPatchDocument`
    类型需要一个**验证步骤**。这个问题通常通过为这种请求创建一个自定义的**数据传输对象**（**DTO**）模型来解决。
- en: Let's move on to the next subsection, which describes the deleting process for
    the resources and how to implement the resulting action method in the controller
    class.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一个子节，它描述了资源的删除过程以及如何在控制器类中实现产生的动作方法。
- en: Deleting resources
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除资源
- en: The `Delete` action method is marked with the `HttpDelete` attribute. It usually
    accepts the identifier of the resource to remove.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete` 动作方法被标记为 `HttpDelete` 属性。它通常接受要删除的资源标识符。'
- en: In real-world applications, `Delete` action methods do not perform physical
    delete operation on the database. They actually carry out update operations. Real-world
    applications and web services typically perform soft deletes instead of physical
    deletes because it is essential to keep track of historical data and information
    that's stored by our services. If we think about an e-commerce application, for
    example, it would be crucial to keep track of orders that have been dispatched
    by our system. *Soft deletes* are usually implemented using an `isDeleted` flag
    or an object that represents the status of our resource. All the other routes
    that are implemented in our APIs should implement logic to filter out all the
    resources in a deleted state. For example, a `Get` route should exclude all the
    deleted resources before presenting them to the client.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，`Delete` 动作方法不会在数据库上执行物理删除操作。它们实际上执行更新操作。现实世界的应用和网络服务通常执行软删除而不是物理删除，因为这对于跟踪我们服务存储的历史数据和信息至关重要。如果我们考虑一个电子商务应用，例如，跟踪我们系统分发的订单就至关重要。*软删除*通常使用一个
    `isDeleted` 标志或表示我们资源状态的对象来实现。我们API中实现的所有其他路由都应该实现逻辑来过滤掉所有处于删除状态的资源。例如，一个 `Get`
    路由应该在将它们呈现给客户端之前排除所有已删除资源。
- en: 'In our case, we are going to implement a real delete operation on our `IOrderRepository`.
    The `Delete` action methods usually return a `204 No Content` error to confirm
    the deletion or a `404 Not Found` error if the client passes a non-existent identifier:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将在 `IOrderRepository` 上实现一个真正的删除操作。`Delete` 动作方法通常返回一个 `204 No Content`
    错误以确认删除，或者如果客户端传递一个不存在的标识符，则返回一个 `404 Not Found` 错误：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The implementation fetches the resource with the corresponding `id` from the
    `IOrderRepository` interface. It proceeds by checking whether the resource is
    `null`, and in this case, it will produce a not found error. If the order entity
    is present in the data source, it continues with the deletion process, and it
    returns a no content result. Now, let's proceed by having a look at the asynchronous
    process using a web service.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实现从 `IOrderRepository` 接口获取具有相应 `id` 的资源。它通过检查资源是否为 `null` 来继续，在这种情况下，它将产生一个未找到错误。如果订单实体存在于数据源中，它将继续删除过程，并返回一个无内容结果。现在，让我们通过查看使用网络服务的异步过程来继续。
- en: Asynchronous processing and acceptance status
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理和接受状态
- en: 'Sometimes, the operations on our resources are not applied immediately. Consider
    an order on an e-commerce website: it takes time to be dispatched and sent to
    our storage system. Therefore, data placed into a queue or something similar and
    handled as soon as possible.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们对资源的操作不会立即应用。考虑一个电子商务网站上的订单：它需要时间来分发并发送到我们的存储系统。因此，数据被放入队列或类似的东西，并尽快处理。
- en: These kinds of asynchronous processing structures may also be present in a web
    service. We also need to represent them and communicate with the client when these
    kinds of processes start.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这类异步处理结构也可能存在于一个网络服务中。当这些过程启动时，我们还需要表示它们并与客户端进行通信。
- en: 'In general, these kinds of processes have the following workflow:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这类过程具有以下工作流程：
- en: '![](img/fab174c8-cb4d-40a5-9b40-4a7d3680c1fa.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fab174c8-cb4d-40a5-9b40-4a7d3680c1fa.png)'
- en: 'The previous schema shows how the client interacts with an asynchronous process:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的架构展示了客户端如何与异步过程交互：
- en: The client sends a `POST` request to our services. The `POST` request triggers
    an asynchronous operation, which updates and adds the order to our storage.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向我们的服务发送 `POST` 请求。`POST` 请求触发异步操作，更新并添加订单到我们的存储中。
- en: The action method receives the request from the client and, if the request structure
    is as expected, triggers the asynchronous process and returns `202 Accepted` to
    the client. Otherwise, it returns `403 Bad Request`. The `202 Accept` code indicates
    that the asynchronous operation is running, but that it hasn't finished yet.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作方法从客户端接收请求，如果请求结构符合预期，则触发异步过程并向客户端返回 `202 已接受`。否则，它返回 `403 请求错误`。`202 接受`
    代码表示异步操作正在进行，但尚未完成。
- en: The client doesn't know precisely when the asynchronous process will end, but
    it is up to it to recall our service once the information has been updated. The
    `202 Accepted` message it is usually combined with a JSON message that contains
    some information, such as the estimated time, or the code of the process.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端不知道异步过程何时结束，但一旦信息更新，它就有责任调用我们的服务。通常与包含一些信息（如估计时间或进程代码）的 JSON 消息一起使用的 `202
    已接受` 消息。
- en: Note that all the example URIs present in this book doesn't contain *verbs*.
    For example, the previous implementation describes a process for generating new
    order. As you can see, the URI is `<hostname>/api/orderrequest`*,* and the only
    element that contains a verb is the HTTP method, which is `POST`*.* We shouldn't
    use *verbs* in URIs because they are used to identify resources and must, therefore,
    be nouns.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本书中出现的所有示例 URI 都不包含**动词**。例如，前面的实现描述了生成新订单的过程。如您所见，URI 是 `<hostname>/api/orderrequest`，唯一包含动词的元素是
    HTTP 方法，即 `POST`。我们不应该在 URI 中使用**动词**，因为它们用于标识资源，因此必须是名词。
- en: The next step in our web service stack journey is to see how we can decouple
    the requests and the response object from the core entities that are used by our
    application. This approach becomes really useful when a web service's complexity
    increases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 Web 服务堆栈之旅的下一步是了解我们如何将请求和响应对象与我们的应用程序使用的核心实体解耦。当 Web 服务的复杂性增加时，这种方法变得非常有用。
- en: Data transfer objects
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据传输对象
- en: 'In the previous section, we looked at how to manage HTTP requests and responses
    using controllers. In this section, we will look at how to manage complex objects
    in our requests and responses. This section is more focused on the *M* part of
    the MVC pattern. First of all, let''s distinguish between three different types
    of model that are usually present in web services:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了如何使用控制器管理 HTTP 请求和响应。在本节中，我们将探讨如何管理请求和响应中的复杂对象。本节更侧重于 MVC 模式中的 *M*
    部分。首先，让我们区分通常存在于 Web 服务中的三种不同类型的模型：
- en: The **Domain model**describes the entities and the resources in our web services.
    It often reflects the schema of our data source, and it is very close to the lower
    level and the business logic of the application.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域模型**描述了我们 Web 服务中的实体和资源。它通常反映了我们的数据源模式，并且非常接近应用的底层和业务逻辑。'
- en: The **Request model**is the representation of the model of the request. Each
    action method in our controller usually has its own **Request model**. As we will
    see later in this chapter, this is also the model that's associated with the validation
    of the request.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求模型**是请求模型的表示。我们控制器中的每个动作方法通常都有自己的**请求模型**。正如我们将在本章后面看到的那样，这也是与请求验证关联的模型。'
- en: The**Response model**is the view model, or the presentation model, of the web
    service. It represents the response of the request, and there is usually one **Response
    model** per action method.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应模型**是 Web 服务的视图模型或表示模型。它表示请求的响应，通常每个动作方法都有一个**响应模型**。'
- en: 'The following workflow schema shows how the models in our application are laid
    out:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的工作流程图展示了我们应用程序中的模型是如何布局的：
- en: '![](img/5ab39100-1893-475e-bb5e-170a75b4296d.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ab39100-1893-475e-bb5e-170a75b4296d.png)'
- en: As you can see, the **Request model** is the front part of our service; it represents
    the request. The **Domain model** is used to describe our stored data. Finally,
    the *response model* presents the data to the client. The request and response
    model are also defined as **data transfer objects** (**DTOs**)*.* These are not
    model classes at all; they transport information between the client and the server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**请求模型**是我们服务的最前端；它表示请求。**领域模型**用于描述我们存储的数据。最后，*响应模型*将数据呈现给客户端。请求和响应模型也被定义为**数据传输对象**（**DTOs**）。它们根本不是模型类；它们在客户端和服务器之间传输信息。
- en: Implementing request models
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现请求模型
- en: 'Now, let''s look at the implementation of some DTOs in practice. The `Order`
    entity describes some actions that accept `List<string>` as input. Let''s suppose
    that the implementation is getting more complex and our service needs to store
    additional information about our orders:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些DTOs的实际实现。`Order`实体描述了一些接受`List<string>`作为输入的操作。假设实现变得越来越复杂，我们的服务需要存储有关我们订单的额外信息：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The *domain model* is a critical part of our application. It is essential to
    keep it separated from the *request/response model*. Therefore, we should avoid
    having the *domain model* tightly coupled with the *request* and the *response*
    models. Let''s start by implementing the `OrderRequest` class, which will be a
    representation of the *create request model*. It will be used by the `Post` action
    method to create a new entity:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*领域模型*是我们应用程序的关键部分。将其与*请求/响应模型*分离至关重要。因此，我们应该避免将*领域模型*与*请求*和*响应*模型紧密耦合。让我们从实现`OrderRequest`类开始，它将代表*创建请求模型*。它将被`Post`动作方法用于创建新实体：'
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `OrderRequest` class contains the same fields as the `Order` *domain model*,
    apart from the `Id` field. This is because the client of the API should not insert
    the `Id` information. The request model makes our filesystem in a separate folder.
    In this case, as you can see from the namespace, `OrderRequest` is stored in the
    `Requests` folder. Our `OrderController` can use `OrderRequest` as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderRequest`类包含与`Order` *领域模型*相同的字段，除了`Id`字段。这是因为API的客户端不应该插入`Id`信息。请求模型使我们的文件系统在单独的文件夹中。在这种情况下，正如您从命名空间中可以看到的，`OrderRequest`存储在`Requests`文件夹中。我们的`OrderController`可以使用`OrderRequest`如下：'
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Post` action method accepts a parameter of the `OrderRequest` type, which
    is the representation of the order request that we want to create. To link incoming
    data with the domain model, we should create a `Map` method that initializes a
    new domain model that''s populated with the request model. Furthermore, we should
    also create a new instance of the `Order` object with the requested data and combine
    it with `IOrderRepository`. The same concept can be applied to the `Put` action
    method of our controller:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`动作方法接受一个`OrderRequest`类型的参数，这是我们想要创建的订单请求的表示。为了将传入的数据与领域模型关联起来，我们应该创建一个`Map`方法，该方法初始化一个新的领域模型，并用请求模型填充。此外，我们还应该创建一个新的`Order`对象实例，并用请求的数据填充，然后与`IOrderRepository`结合。同样的概念也可以应用于我们控制器的`Put`动作方法：'
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this case, we create a new `Map` method, which takes two parameters as input:
    the `OrderRequest` and the `Order`, and we can proceed by assigning each property
    of the request object to the order.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建一个新的`Map`方法，它接受两个输入参数：`OrderRequest`和`Order`，然后我们可以通过将请求对象的每个属性分配给订单来继续操作。
- en: Implementing response models
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现响应模型
- en: As we mentioned previously, another critical part of our APIs is the response
    model. The response model classes act as filters between the *domain model* and
    the *client.* For example, let's think about a particular field in our domain
    model that, for whatever reason, must not be part of our response. Response models
    help us deal with cases such as these.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们API的另一个关键部分是响应模型。响应模型类在*领域模型*和*客户端*之间充当过滤器。例如，让我们考虑领域模型中的一个特定字段，出于某种原因，它必须不包含在我们的响应中。响应模型帮助我们处理这类情况。
- en: 'Let''s suppose that we need to implement a *soft-delete* in our APIs. As we
    mentioned earlier, a *soft-delete* is a way to mark a record for the deletion
    or to temporarily prevent it from being selected. To perform a soft-delete on
    `MemoryOrderRepository`, we should add an `IsInactive` flag, which marks the target
    record as deleted:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在我们的API中实现*软删除*。正如我们之前提到的，*软删除*是一种标记记录以进行删除或暂时防止其被选择的方法。要在`MemoryOrderRepository`上执行软删除，我们应该添加一个`IsInactive`标志，该标志将目标记录标记为已删除：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `IsInactive` flag indicates whether `Order` is inactive or not. To complete
    the *soft-delete* implementation, we should change the `MemoryOrderRepository`.
    It should now cancel orders using the `IsInactive` flag.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsInactive` 标志表示 `Order` 是否处于非活动状态。为了完成 *软删除* 的实现，我们应该更改 `MemoryOrderRepository`。现在它应该使用
    `IsInactive` 标志来取消订单。'
- en: 'Furthermore, the `Get` method inside the repository should filter all the records
    by excluding inactive orders:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仓库内的 `Get` 方法应该通过排除非活动订单来过滤所有记录：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These changes eliminate inactive orders from the responses of our APIs. Since
    the `IsInactive` flag is implicit in the response of our APIs, we don''t need
    to serialize the `IsInactive` flag in the response JSON. Consequently, we can
    decouple the response of the `Get` action method from our domain model by adding
    a new response class called `OrderResponse`. It can be defined in the following
    way:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改消除了我们 API 响应中的非活动订单。由于 `IsInactive` 标志在我们的 API 响应中是隐含的，我们不需要在响应 JSON 中序列化
    `IsInactive` 标志。因此，我们可以通过添加一个名为 `OrderResponse` 的新响应类来解耦 `Get` 操作方法的响应和我们的领域模型。它可以按以下方式定义：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, the `OrderResponse` class model exposes all the fields except
    for the `IsInactive` flag. At this point, we can proceed by editing the `OrderController`
    class so that it maps the `Order` entity with the `OrderResponse` model in the
    following way:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`OrderResponse` 类模型公开了除了 `IsInactive` 标志之外的所有字段。在这个时候，我们可以通过编辑 `OrderController`
    类来继续操作，使其以以下方式将 `Order` 实体映射到 `OrderResponse` 模型：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This approach allows us to decouple the domain model from the response of our
    API. The `Map` method is the point at which we can decide which fields we should
    show.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们将领域模型与我们的 API 响应解耦。`Map` 方法是我们决定应该显示哪些字段的地方。
- en: Implementing validation of requests
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现请求验证
- en: 'We can now create dedicated types to represent our requests, but we should
    also consider adding validation. Validation is important if we wish to prevent
    messy data and possible exceptions in our web service. ASP.NET Core provides an
    out of the box way for us to implement validation in our controllers and services:
    `System.ComponentModel.DataAnnotations`. The namespace provides a set of attributes
    that can be used to describe the validation of model fields. For example, consider
    the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建专门的数据类型来表示我们的请求，但我们也应该考虑添加验证。如果我们希望防止数据混乱和可能出现的异常，验证是非常重要的。ASP.NET Core
    提供了一种现成的方式，让我们在我们的控制器和服务中实现验证：`System.ComponentModel.DataAnnotations`。该命名空间提供了一组属性，可以用来描述模型字段的验证。例如，考虑以下代码片段：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this case, the `[Required]` attribute specifies that both the `ItemsIds`
    and `Currency` attributes should not be `null` or empty; otherwise, the APIs will
    return the following validation message:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`[Required]` 属性指定 `ItemsIds` 和 `Currency` 属性都不应该是 `null` 或空；否则，API 将返回以下验证消息：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Simply reading through the model allows us to understand the constraints that
    were defined for the model, so this approach improves the readability and maintainability
    of our code. Furthermore, ASP.NET Core provides several popular built-in validation
    attributes: `[EmailAddress]`, `[StringLength]`, `[Url]`, `[CreditCard]`, and `[RegularExpression]`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地阅读模型，我们可以理解为模型定义的约束，因此这种方法提高了我们代码的可读性和可维护性。此外，ASP.NET Core 提供了几个流行的内置验证属性：`[EmailAddress]`、`[StringLength]`、`[Url]`、`[CreditCard]`
    和 `[RegularExpression]`。
- en: 'In the `Currency` field, we may add a constraint as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Currency` 字段中，我们可以添加以下约束：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, the `Currency` attribute will contain a currency code, such as
    EUR or USD. We can add a restriction on the maximum length of the field so that
    it is limited to three characters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Currency` 属性将包含货币代码，例如 EUR 或 USD。我们可以添加一个限制，以限制字段的长度，使其限于三个字符。
- en: Custom validation attributes
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证属性
- en: 'ASP.NET Core provides a way for us to create custom validations for our requests
    by extending `ValidationAttribute`, which means we can create custom validators
    for our types. Let''s create a more appropriate validation for our `Currency`
    attribute:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一种通过扩展 `ValidationAttribute` 来创建我们请求的自定义验证的方法，这意味着我们可以为我们的类型创建自定义验证器。让我们为我们的
    `Currency` 属性创建一个更合适的验证：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding implementation matches the request model currency with the list
    of `_acceptedCurrencyCodes`. If the match is successful, it returns `ValidationResult.Success`;
    otherwise, it returns a new validation result with a validation message. The `MemberName`
    attribute provides the name of the property that is associated with the custom
    validation attribute. Creating a custom validation attribute can be useful when
    we implement a more complex validation that involves third-party services or aggregate
    operations on the subject of the validation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现将请求模型货币与`_acceptedCurrencyCodes`列表进行匹配。如果匹配成功，则返回`ValidationResult.Success`；否则，返回一个包含验证信息的新的验证结果。`MemberName`属性提供了与自定义验证属性关联的属性的名称。在实现涉及第三方服务或对验证主题进行聚合操作的更复杂验证时，创建自定义验证属性可能很有用。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how we can build a web service stack using ASP.NET
    Core. We also looked at how to implement CRUD operations on a repository and how
    to deal with data transfer objects and validation. This chapter has provided a
    starting point and the knowledge we need to build a very simple web service using
    ASP.NET Core, including how to handle requests, how to use model binding, and
    how to validate requests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用ASP.NET Core构建一个Web服务堆栈。我们还探讨了如何在存储库上实现CRUD操作，以及如何处理数据传输对象和验证。本章提供了一个起点和构建一个非常简单的ASP.NET
    Core Web服务所需的知识，包括如何处理请求、如何使用模型绑定以及如何验证请求。
- en: In the next chapter, we will cover the routing system of ASP.NET Core in more
    detail by exploring how it can be extended and customized.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索如何扩展和自定义它来更详细地介绍ASP.NET Core的路由系统。
