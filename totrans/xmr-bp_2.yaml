- en: Chapter 2. Building a SpeechTalk Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduce development with `Xamarin.Forms`. We will build
    a cross-platform application for iOS, Android, and Windows Phone that integrates
    native platform speech services to speak text typed from a text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform development with `Xamarin.Forms`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up platform projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a `SpeechTalk.iOS` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a `SpeechTalk.Droid` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xamarin.Forms`, Windows Phone, and Visual Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inversion of Control (IoC) with `Xamarin.Forms`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AutoFac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS text-to-speech implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android text-to-speech implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up IoC with Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WinPhone text-to-speech implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoC with Windows Phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-independent styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform development with Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key ingredient in cross-platform development with Xamarin is code sharing.
    Sharing native code is great, but we still have the issue of writing separate
    user interface code for each platform. The **Windows Presentation Framework**
    (**WPF**) is a presentation system which uses an XML-based language known as **Extensible
    Application Markup Language** (**XAML**). Xamarin.Forms uses WPF and the **Model-View-View-Model**
    (**MVVM**) paradigm to build native user interfaces from a single C# shared code
    base, whilst maintaining access to all native APIs on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-platform development with Xamarin.Forms](img/B05293_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram represents a native architecture. We keep all the sharable
    code Inside the **Shared C# App Logic** block (normally a shared project) for
    each platform project to access, i.e. the `GalleryItem` class would be kept here
    since it is shared between both projects.
  prefs: []
  type: TYPE_NORMAL
- en: So how would this look in Xamarin.Forms?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `Xamarin.Forms`, since we have the ability to share the user interface
    screens, we can share the entire view and view model code between all platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![So how would this look in Xamarin.Forms?](img/B05293_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the code contained in the **Shared C# App Logic** block
    is contained in a **Portable Class Library** (**PCL**), which each native project
    will import. `Xamarin.Forms` makes it possible to share up to 85% of code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now delve into development and setup our first `Xamarin.Forms` project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up platform projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Xamarin Studio, let''s start by setting up the platform projects. Go to
    **File** | **New Solution** and select a **Xamarin.Forms** app from the cross-platform
    menu on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up platform projects](img/B05293_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the project is created, you will see both an iOS and Android project created
    along with a PCL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, we can't develop our Windows Phone applications through Xamarin
    Studio; we will be touching on this after the iOS and Android projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first `ContentPage` in XAML, right-click on the PCL, create
    a new XAML `ContentPage,` and call it `MainPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up platform projects](img/B05293_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`Xamarin.Forms` provides the option to build user interfaces entirely in C#,
    but it is recommended you stick with XAML because it is a very powerful markup
    language. The code required for a XAML sheet is much smaller than a user interface
    in C#.'
  prefs: []
  type: TYPE_NORMAL
- en: We also want to create a new folder called `Pages` and add `MainPage` to this
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first element on the page is a `Grid.` A Grid separates a layout by rows
    and columns based upon the entire size of the screen. Rows work from top to bottom
    and columns work from left to right; copy the following into the `MainPage.xaml`
    sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top we have an XML description tag exactly like Android, which specifies
    an encoding and a version. We have the declaration of a `ContentPage` with the
    XML namespace specification attribute `xmlns`. We then specify the class name
    and add the `ContentPage.Content` tags, where we will create the page layout.
    All these XML tags are generated automatically; the only change we made was the
    namespace of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Grid inserted between the `ContentPage.Content` tags has three rows and
    three columns. Each row definition is assigned `Auto`, meaning the height of the
    row is based on the element assigned to it. Since we have three rows assigned
    with `Auto`, the Grid will only fill the height of the contained elements (similar
    to the `wrap_content` flag in android). The Grid will take up the entire width
    of the page as its one column definition is set to "*", meaning it will stretch
    one column to the entire width of the page. We have our basic page layout, so
    let's leave it there and move back into the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SpeechTalk.PCL`, we have a file called `SpeechTalk.cs`; we should rename
    this `App.cs` to match the class name. In the `App.cs`, this is the application
    starting point. In the constructor of the application class, you will see a `MainPage`
    property automatically set like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So what is happening here?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the project is created, we automatically receive an `App` class with the `MainPage`
    property set to a new `ContentPage`. The preceding code block is an example of
    an interface built entirely via c-sharp. We want to replace this with an instantiation
    of our `MainPage`, and set this new object to the `MainPage` property of the `App`
    class. Here is the updated constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It's much cleaner, you can already see how messy the code would look like if
    we were to build complex user interfaces in **C#**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the SpeechTalk.iOS project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s also have a look at the project setup on the native side for iOS and
    Android. Open the `AppDelegate.cs` file; it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the super class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since `Xamarin.Forms` 1.3.1 and the updated unified API, all our app delegate
    should be inheriting is `Xamarin.Forms.Platform.iOS.FormsApplicationDelegate`.
    We also have the standard `FinishedLaunching` function; in here we must call `Forms.Init`
    which will initialize `Xamarin.Forms`, and then call `LoadApplication` with a
    new instantiation of the `App` class. We then return the base class `FinishedLaunching` function,
    passing in the app and options objects.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this `FinishedLaunching` function is an override of the standard
    app delegate function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must initialize forms before anything else occurs in this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the iOS application and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the SpeechTalk.iOS project](img/B05293_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fantastic, a blank application. That means we have now successfully run our
    first iOS `Xamarin.Forms` project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the SpeechTalk.Droid project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do the same for Android and set up `Xamarin.Forms` accordingly. Inside
    our Android project, open the `MainActivity.cs` class and look at the `OnCreate`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `MainActivity` class must inherit `Xamarin.Forms.Platform.Android.FormsApplicationActivity`;
    we must call the super class `OnCreate` method before we initialize `Xamarin.Forms`
    and load in our new instantiated app class. That's all, we can now run the Android
    application and see the exact same results, a blank page. Congratulations, you
    have just shared your first `Xamarin.Forms` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms, Windows Phone, and Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at sharing our `MainPage` interface with Windows Phone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not everyone will extend an app onto Windows Phone, so if you are not interested
    in creating a Windows Phone example you can skip this part.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be using Microsoft Visual Studio, so open it up and open the
    `SpeechTalk` solution file (`SpeechTalk.sln`) we created in Xamarin Studio. Portability
    between the two IDEs is very good; watch the solution port directly into Visual
    Studio and open your PCL file without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a `GIT` repository to help control the continuous change between Xamarin
    Studio and Visual Studio, we recommend creating a GIT repository for every chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The iOS and Android projects may not be compatible as we created these in Xamarin
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can build iOS and Android applications directly in Visual Studio, but running
    iOS applications will require a mac build host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to create a new Windows Phone project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.Forms, Windows Phone, and Visual Studio](img/B05293_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, the automated setup done with iOS and Android will not be done
    with the Windows Phone project. All the setup will be done manually, but this
    is good for walking you through the manual setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the **Xamarin.Forms** nuget package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.Forms, Windows Phone, and Visual Studio](img/B05293_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now its time to look at the `MainPage.xaml` and `MainPage.xaml.cs` files in
    the **Windows Phone** project.
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute, haven't we already made one of these?
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are preparing a Windows Phone project, we can see the original
    WPF structure used in Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `MainPage.xaml` and paste in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If any lines get underlined, just ignore them; this is an issue in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: What can we see here?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yes, this is XAML. Windows apps are all built using the WPF framework. We create
    the `Xamarin.Forms` element `forms:WindowsPhonePage`. Open the `MainPage.xaml.cs`
    in the Windows Phone project and update the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Project setup is quite simple, but we are not calling `Forms.Init` anywhere.
    Open up the `App.xaml.cs` file in the **Windows Phone** project and look for this
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We must manually add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the cache size to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we now need to reference the **SpeechTalk** PCL project we created
    in Xamarin Studio earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What can we see here?](img/B05293_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may run into issues with referencing this project to the targets set by
    the PCL by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What can we see here?](img/B05293_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To fix this issue, open the **SpeechTalk** PCL project and update the target
    configurations in **Properties**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What can we see here?](img/B05293_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Change** button where it says **Targets** and make sure the preceding
    checkboxes are selected. That's everything; try building and running the application.
    We should see a blank page like the Android and iOS projects. Gerat we have now
    made a cross-platform application for all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's get into the fun stuff with IoC.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of Control (IoC) with Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Inversion of Control** (**IoC**) principle is very a useful technique
    when writing cross-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: So why should we use it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sharing 100% of the code would be great, but it is not entirely possible; we
    still require some implementation from platform-specific features (for example
    different platform services, hardware, cameras). A way to tackle this problem
    is via an **IoC container**. Using the IoC principle, we use an abstraction for
    the functionality in our shared code and pass an implementation of the abstraction
    into our shared code. Our IoC containers handle the instantiation of an object's
    dependency tree. We can register objects to their inherited interfaces and allow
    containers to pass registered objects as their abstracted interfaces all the way
    down the dependency tree (all the way to PCL).
  prefs: []
  type: TYPE_NORMAL
- en: So how do we benefit from this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if I needed view models to call methods to a native Bluetooth service in
    a PCL project?
  prefs: []
  type: TYPE_NORMAL
- en: 'To put it simply, we can''t. Our PCL projects know nothing about Bluetooth
    services on the native side. We create an interface that sits in the PCL project,
    create a class that inherits this interface, and define the methods and access
    all the native features required. We then register this class to the inherited
    interface through our IoC container, and finally resolve this abstracted interface
    in our PCL project. When we call functions from this interface down in the PCL,
    it will be calling the registered class function definitions described on the
    native side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![So how do we benefit from this?](img/B05293_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now back to our `SpeechTalk` application. Because the PCL project cannot share
    code from the native side text-to-speech services, we will have to use IoC to
    access the native-side features from our PCL. Let''s start by declaring an interface
    for our text to speech service, creating a new folder called `Services`, and adding
    a new `ITextToSpeech.cs` file for the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Autofac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin implementing the different native sides to this interface,
    let''s first add in our IoC container to handle the abstraction. There are a few
    IoC containers that are free online; for this example we are going to use **Autofac**.
    Let''s add the NuGet packages for the PCL, iOS, and Android projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autofac](img/B05293_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our IoC container, let''s build the iOS implementation. For
    each platform, we want to create objects called **Modules** for registering abstracted
    interfaces. Let''s add a new folder called IoC to the PCL project and add a new
    file called `IoC.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this closer, we use this static class for registering modules, registering
    types, resolving registered types, creating the container, and building the container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ContainerBuilder` must be built after all types have been registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must register and start this container before we initialize the application.
    Open up your `AppDelegate.cs` file and update the `FinishedLaunching` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `InitIoC` function will first create the container, register the modules,
    and build the IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our container must be created before we can start registering, and our container
    builder must be built before we can start resolving.
  prefs: []
  type: TYPE_NORMAL
- en: Each module has register functions that will use the created `ContainerBuilder`
    to register types.
  prefs: []
  type: TYPE_NORMAL
- en: iOS text-to-speech implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each module will retrieve the current container used throughout the entire lifetime
    of your application. Inside the register function is where we register the class
    implementation of the text to speech interface. This will be done at the very
    start of the application before we load anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start first with adding the iOS module. Add a new folder in the iOS
    project called **Modules**, create a new file called `iOSModule.cs`, and paste
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the iOS text to speech service. Add a new folder called
    `Services` and add a new file called `TextToSpeech.cs`. In this file, we are going
    to access the iOS `AVSpeechSynthesizer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Looking closely at this class, we are going to use the speech synthesizer to
    produce a `SpeechUtterrance` object, which contains the text to speak. We also
    set the language, volume, and speech rate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Notice how we inherit the interface we are going to register through the
    IoC container?**'
  prefs: []
  type: TYPE_NORMAL
- en: As we are coding this class on the native side, we are able to access all native
    iOS features, so back in the PCL when we call the function `Speak` in the interface,
    the preceding code will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to implement the view model principles for our pages. Create
    a new folder called `ViewModels` and add two new files, `ViewModelBase.cs` and
    `MainPageViewModel.cs`. The `ViewModelBase` class will be the base call for all
    view models for handling property change events with any view model''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's look a bit closer. The first property defined is `PropertyChanged EventHandler`,
    which will fire on any property data change. Notice the use of the `#` define
    statements; these are useful for breaking up blocks of coding and navigating through
    your code sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are particularly useful when we have big code sheets.
  prefs: []
  type: TYPE_NORMAL
- en: The class inherits the `INotifyPropertyChanged` interface, meaning we have to
    define the `OnPropertyChanged` function. This function is used to fire the `PropertyChanged`
    event to signal that a property within this class has changed data. Now let's
    implement the `MainPageViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use the `OnPropertyChanged` principle with our `MainPageViewModel`?
  prefs: []
  type: TYPE_NORMAL
- en: 'With each property in the `MainPageViewModel`, we have to call the `OnPropertyChanged`
    function to fire the `EventHandler`, thus notifying of a data change for a particular
    property. Let''s begin by creating the `MainPageViewModel` with its private properties
    and constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the first time we are going to access the `Systems.Windows.Input` library.
    **Commands** are used for our `Button` object on the `ContentPage`; we will set
    up a binding on the button so whenever a press event occurs, this command will
    execute, running the action it is assigned in the constructor. Notice how we are
    passing the `TextToSpeech` interface; this is where things will get trickier with
    the IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add the public properties of the view model, which call the `OnPropertyChanged`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have our first view model. Notice the `get` and `set` methods
    for each property; they are exactly the same as functions, just with a nicer presentation.
    Every time we retrieve the data inside a `public` property, it will pull the data
    contained in the `private` property, and every time we set the `public` property,
    if the value is different to the current value, we will set the `private` variable
    contained and call the `OnPropertyChanged` function to fire the `EventHandler`
    in the base class. When this event fires, it will update whatever view is bound
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the PCL project, we are going to run through the concept of binding
    view models to views, displaying view model data, and propagating data changes
    through the `INotifyPropertyChanged` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with our `MainPage.cs` and complete the rest of the user interface
    for this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now have a `Label`, `Entry`, and `Button`; each has the `x:Name`, `Grid.Row`,
    and `Grid.Column` properties assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we relate the rows and columns to the definitions section previously?
  prefs: []
  type: TYPE_NORMAL
- en: We have also set, on the bounding Grid, padding values for left, up, right,
    and down; set the vertical options to `Center`; and set a row spacing of `10`.
    The `Padding` will place gaps around the entire bounds of the Grid and the `ContentPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Padding works exactly like margins in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The `RowSpacing` property will set the gaps between each row; as each element
    is placed in a new row, they will be stacked vertically with a pixel spacing of
    `10` between each. Since we only have 1 column, this column width will take up
    the entire width of the **Grid**, so each element will be at the full width of
    the `Grid`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, setting the `VerticalOptions` of the `Grid` to `Center` will position
    all elements to the center of the Grid. Now let's set up the binding between the
    `MainPage` and `MainPageViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, add it to the modules folder called `PCLModule.cs`, and
    paste in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hold on... why are we registering our pages and view models in the container?
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to abstract these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Registering both views and view models in the container allows us to add our
    related view models in the constructor; as we only ever need one instance of both
    the view and view model throughout the entire lifetime of the application, we
    can set up the `MainPage.xaml.cs` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The instance of the `MainPageViewModel` that was created in the container when
    registered will be pulled out of the `MainPage` constructor on creation. This
    is the same technique used with the instance of the `MainPageViewModel`, where
    we place the `ITextToSpeech` abstraction in the constructor; it will pull out
    the instance registered on the native side, and in turn we can now use this object
    to start calling the functions that will run the `native-side` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to the `MainPage.xaml` sheet, let''s set up the property bindings;
    update the label, entry, and button to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have set up bindings for the text on the label and entry properties; notice
    the two-way binding mode set on the entry text property?
  prefs: []
  type: TYPE_NORMAL
- en: What this means is if we change the data from the user interface (as it is a
    text box, will we will be changing the data on the UI front) or the view model,
    both endpoints will receive the data change accordingly. We have also set up a
    binding with the command on the button; now, whenever we press this button on
    the page, it will run the action assigned to it in the view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all the coding is done, let''s run the application; try typing in
    text and pressing the **Speak** button and have a listen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bindings](img/B05293_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well done! You have just completed your first iOS `Xamarin.Forms` application.
  prefs: []
  type: TYPE_NORMAL
- en: For some extra exercises, try changing the properties of volume and speech on
    the `SpeechUtterance` object for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Android text-to-speech implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's implement the IoC container and text to speech for Android. Start
    by creating a folder for the both the Android Modules and Services, add in two
    files to it, `TextToSpeechDroid.cs` and `DroidModule.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the text to speech service; for `TextToSpeechDroid.cs`. And
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This `IOnInitListener` interface requires the `OnInit` function to be implemented.
    The `OnInit` function is called to signal the completion of the `TextToSpeech`
    engine initialization. We then implement the interface's function `Speak` to speak
    the text passed in. At the start of the function, we check to see that a new `TextToSpeech`
    object has been initialized; if we have then speak the message.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up IoC with Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now for the IoC implementation. It works exactly the same as iOS; let''s add
    the Android module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to set up the IoC container in our `MainActivity.cs` class; simply
    copy the iOS function in the `AppDelegate` file called `initIoC` and paste this
    into the `MainActivity` class, replace the instantiation of the `iOSModule` with
    your `DroidModule`, then simply add the function call after the initialization
    of `Xamarin.Forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have issues trying to get the speech to work on Android. One thing you
    may need to set up first is within **Settings** | **Controls** | **Text-to-Speech**
    options. Here is where you will have to install voice data if the default has
    not already been installed. If you run the app and no speech occurs, you will
    have to configure the voice data.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for Android, now try running the app and hear some speech.
  prefs: []
  type: TYPE_NORMAL
- en: WinPhone text-to-speech implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we go back to Windows Phone for the last implementation. See how tricky
    it can be when you have to switch between multiple platforms. Imagine if we had
    to change languages and re-write IoC containers; the amount of work would be much
    greater. Not only that, there would be no point in using IoC, because we cannot
    share any code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So firstly, don''t forget to import the nuget package for **Autofac**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WinPhone text-to-speech implementation](img/B05293_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have access to the **Autofac** framework, let''s continue implementing
    the text to speech service. Start with adding a new folder called **Services**,
    then add the `TextToSpeechWinPhone.cs` file and implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this more closely, you can see the instantiation of `MediaElement`;
    this is used to play an audio source. Our source in this case is `SpeechSynthesisStream`;
    this stream is built via a speech synthesizer. When we call the function `SynthesizeTextToStreamAsync`,
    it will be an audio stream based on the text inserted into this function. We then
    set the `MediaElement` source to the stream and call the `Play` function to begin
    speaking. One addition to configuring Windows Phone is checking the capability
    in the app manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: IoC with Windows Phone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing IoC with Windows Phone is very much the same as iOS and Android.
    We simply add the same function, `InitIoC`, at our application''s starting point;
    in this case, it is the `MainPage` constructor of the Windows Phone project (try
    not to get the two confused), and we call it right before the `LoadApplication`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Simple! Now we can run the Windows application.
  prefs: []
  type: TYPE_NORMAL
- en: Platform independent styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hold on! What has happened with the `MainPage`—no button, no text?
  prefs: []
  type: TYPE_NORMAL
- en: 'What is happening here is we have not specified colors for these elements,
    so the default color of the text has come up as white. Open up `MainPage.xaml`
    and change the text colors accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be a good idea to color the background of the `Entry` object as well,
    so we can see the text definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now run it again and see the text, button, and entry background display.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! What if we don't want these colors to change for iOS and Android,
    or we want to set these colors differently based on the platform?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another trick to try: in the `MainPage.xaml` sheet, we are going to
    change the background color of the entry based upon whether it is iOS, Android,
    or Windows Phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by specifying the property tag we are changing, and then a tag for
    `OnPlatform` in which we specify the argument type, which is `Color`. Let''s take
    it a step further and change the text colors for the `Button` and `Label` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a nice little variation between styles for the first page. As you build
    more complex XAML sheets, you may find some areas where you will have to change
    pixel items, change color, and perform other styling to give it that extra edge.
  prefs: []
  type: TYPE_NORMAL
- en: Let's call it a day and end this project here; it's now time to build our GPS
    locator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a text to speech service using `Xamarin.Forms`.
    We have learned about native speech service libraries for each platform. In the next
    chapter, we will learn how to handle background location update events and using
    latitude and longitude to calculate positions. You will also learn how to implement
    location services on each platform by using `Xamarin.Forms` and `Xamarin.Forms.Maps`.
  prefs: []
  type: TYPE_NORMAL
