- en: Chapter 4. Comparing Approaches for Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：比较编程方法
- en: Up until this point, we have centered upon the C# language and its evolution.
    However, this evolution is not the only one in .NET framework as far as languages
    are concerned. Other languages have kept evolving as well (and this is independent
    of the fact that many more compilers have increased the list of languages for
    which there is a .NET version nowadays). Especially, there are two members of
    the .NET language ecosystem, F# and TypeScript, which are becoming increasingly
    popular among the programmer community, and we're going to—briefly—introduce them
    in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注 C# 语言及其演变。然而，就语言而言，.NET 框架中的这种演变并非唯一。其他语言也在不断进化（而且这与现在有更多编译器增加了支持
    .NET 版本的编程语言列表这一事实无关）。特别是，.NET 语言生态系统中有两个成员，F# 和 TypeScript，它们在程序员社区中越来越受欢迎，我们将在本章中简要介绍它们。
- en: Consequently, we will review some of the most relevant aspects of both languages,
    with C# as a reference in both cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将回顾两种语言中最相关的方面，在两种情况下都以 C# 作为参考。
- en: With this goal, our purpose is to roughly underline the most crucial programming
    structures in such a way that you can establish a comparison between the ways
    you code usual and everyday programming tasks but using different languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以此为目标，我们的目的是大致概述最关键的编程结构，以便您可以比较使用不同语言编码日常编程任务的方式。
- en: I'd like to add a note about VB.NET and why I'm not including it here. Even
    considering that VB.NET has evolved in parallel with the rest of the languages
    of the .NET ecosystem, (and VB.NET followers, please forgive me, but this is a
    tendency that most of you must have noticed for sure), the truth is that there's
    more hype around F# and JavaScript languages (and TypeScript, for that matter).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我想关于 VB.NET 和为什么我不包括它在这里添加一个说明。即使考虑到 VB.NET 与 .NET 生态系统中的其他语言并行发展，（VB.NET 追随者，请原谅我，但这是你们大多数人肯定已经注意到的趋势），但事实是，围绕
    F# 和 JavaScript 语言（以及 TypeScript）的炒作更多（就 TypeScript 而言）。
- en: That tendency is especially clear when we talk about future expectations. VB.NET
    users can be confident that while Microsoft doesn't say the opposite, VB.NET will
    keep on running as expected, and will be a language of the previously mentioned
    language's ecosystem, with all the goodness and advantages that a developer is
    used to find inside Visual Studio.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论未来期望时，这种趋势尤为明显。VB.NET 用户可以确信，尽管微软没有说相反的话，VB.NET 将继续按预期运行，并且将成为之前提到的语言生态系统中的一种语言，拥有开发者习惯在
    Visual Studio 中找到的所有优点和优势。
- en: 'Going back to F# and TypeScript, both have something in common: they belong
    to the category of functional languages (although TypeScript uses classes, which
    later on "compile" to functions). The first one will serve us as a comparison
    with C#, since it''s a compiled language, unlike TypeScript, which is an interpreted
    language.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 F# 和 TypeScript，两者有一个共同点：它们属于函数式语言的类别（尽管 TypeScript 使用类，这些类最终“编译”成函数）。第一个将作为与
    C# 的比较，因为它是编译型语言，而 TypeScript 是解释型语言。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The list of functional languages of all types keeps on growing. Wikipedia maintains
    a pretty comprehensive list of most of them at [https://en.wikipedia.org/wiki/Category:Functional_languages](https://en.wikipedia.org/wiki/Category:Functional_languages).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型的函数式语言列表不断增长。维基百科维护了一个相当全面的列表，列出了其中大部分语言，可以在 [https://en.wikipedia.org/wiki/Category:Functional_languages](https://en.wikipedia.org/wiki/Category:Functional_languages)
    找到。
- en: So, we'll review the differences between both approaches to programming and
    identify those programming structures that are intended to obtain the same results,
    each one expressed in its own style. Also, note that there are a number of applications
    out there to solve problems (especially mathematical and engineering ones) with
    an implementation of an F# DLL, since possibilities increase with every version
    as the language grows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将回顾两种编程方法之间的差异，并确定旨在获得相同结果（每个都以其自己的风格表达）的编程结构。此外，请注意，有大量应用程序可以解决（尤其是数学和工程问题），这些应用程序使用
    F# DLL 的实现，随着语言版本的不断增长，可能性也在增加。
- en: On the other hand, the continuous growth of TypeScript adoption has been clearly
    stated with the announcement by Google that TypeScript has been the language used
    in the building of their new version of the Angular framework (Angular 2.0), available
    since September 2016\. That's a quite unexpected collaboration!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，TypeScript 的持续增长通过 Google 的宣布得到了明确，即 TypeScript 已成为他们新版本 Angular 框架（Angular
    2.0）的构建语言，自 2016 年 9 月以来可用。这是一个相当意外的合作！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Foundations of functional languages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能型语言的基础
- en: F# as a fully functional language
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 作为一种完全功能型语言
- en: Equivalence of typical programming structures
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型编程结构的等价性
- en: Support in Visual Studio
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 中的支持
- en: TypeScript inception and main purposes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 的起源和主要目的
- en: Basic structures and programming characteristics
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本结构和编程特性
- en: TypeScript support in Visual Studio
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 中的 TypeScript 支持
- en: Functional languages
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能型语言
- en: A functional language is one that avoids changing the state and mutable data
    and mainly focuses its statements on the evaluation of code as mathematical functions.
    So, the entire programming experience is based on functions (or procedures) to
    construct its program flow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能型语言是一种避免改变状态和可变数据，主要关注代码作为数学函数评估的语言。因此，整个编程体验都是基于函数（或过程）来构建程序流程的。
- en: Note how different this approach is from object-oriented languages for whom
    everything is an object (some OOP languages have primitive types, such as Java,
    but, in general, types can always be considered objects).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种方法与面向对象语言的不同，面向对象语言中一切都是对象（一些面向对象语言有原始类型，如 Java，但通常，类型总可以被视为对象）。
- en: The next graphic shows some popular Imperative Languages as opposed to pure
    Functional Languages and the place F# (and Scala) occupy between the two models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表显示了某些流行的命令式语言与纯功能型语言的对比，以及 F#（和 Scala）在这两种模型之间的位置。
- en: 'With that in mind, the flow of the program''s goal keeps declaring functions
    that relate or base themselves in other functions until the goal is reached:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，程序目标的流程持续声明与其它函数相关或基于其它函数的函数，直到目标达成：
- en: '![Functional languages](img/image00483.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![功能型语言](img/image00483.jpeg)'
- en: A functional language does not have the side-effects of other imperative programming
    languages since the state does not change and the same call will return the same
    results as long as the function calls are made with the same arguments. Eliminating
    these kinds of side-effects can make the behavior much more predictive, and that's
    precisely one of the most important motivations for their use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 功能型语言没有其他命令式编程语言的副作用，因为状态不会改变，只要函数调用使用相同的参数，相同的调用将返回相同的结果。消除这些类型的副作用可以使行为更加可预测，这正是它们使用的重要动机之一。
- en: 'However, this advantage also implies a consideration: not all programs can
    be developed without these effects, especially those that require changing the
    state and the creation of I/O procedures.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种优势也意味着需要考虑：并非所有程序都可以在没有这些效果的情况下开发，尤其是那些需要改变状态和创建 I/O 过程的程序。
- en: Functional programming, as a discipline, has its roots in *Lambda Calculus*,
    originally developed as a formal system to express computation in terms of function
    abstractions, and it was first developed by Alonzo Church in the late twenties
    in the context of research on the foundations of mathematics.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一门学科，函数式编程的根源在于 *Lambda 演算*，最初作为一种形式系统，用于以函数抽象的形式表达计算，它最初由 Alonzo Church 在二十年代后期在研究数学基础的过程中开发。
- en: 'Two points should be noted here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应该注意两点：
- en: Lambda Calculus is a universal model of computation equivalent to the *Turing
    Machine*, as stated by Wikipedia. Furthermore, Turing himself refers to this work
    in his seminal paper on State Machines. There are interesting works that relate
    to both and explain their differences, although they're not the goal of this chapter.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 演算是一个通用的计算模型，与 *图灵机* 等价，正如维基百科所述。此外，图灵本人也在他的关于状态机的开创性论文中提到了这项工作。有一些有趣的工作与这两者相关，并解释了它们之间的差异，尽管这不是本章的目标。
- en: Even considering they're not the same as the lambda expressions we've seen so
    far in the C# language, there's a direct connection given that the Lambda Terms
    or Lambda Expressions used in Lambda Calculus refer to binding a variable in a
    function pretty much in the way we've seen in previous examples. For more information
    on Lambda Calculus, refer to [https://en.wikipedia.org/wiki/Lambda_calculus](https://en.wikipedia.org/wiki/Lambda_calculus).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使考虑到它们与我们在C#语言中看到的lambda表达式不完全相同，由于Lambda Calculus中使用的Lambda项或Lambda表达式基本上以我们在前面的例子中看到的方式绑定变量，因此存在直接的联系。有关Lambda
    Calculus的更多信息，请参阅[https://en.wikipedia.org/wiki/Lambda_calculus](https://en.wikipedia.org/wiki/Lambda_calculus)。
- en: F# 4 and .NET Framework
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 4和.NET Framework
- en: The first version of the F# language showed up in 2005, although it was something
    that you had to download and install separately. The language evolution process
    was originally managed by Don Syme from Microsoft Research, although nowadays,
    it uses an open development and engineering process, basically monitored by the
    F# Software Foundation, founded in 2013, which became a 501C3 nonprofit organization
    in 2014.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: F#语言的第一个版本出现在2005年，尽管当时你需要单独下载和安装。语言的发展过程最初由微软研究院的Don Syme管理，尽管现在它使用的是开放的开发和工程流程，基本上由成立于2013年的F#软件基金会监督，该基金会于2014年成为了一个501C3的非营利组织。
- en: Actually, the current version is 4.0, and it appeared in January 2016 along
    with several improvements in the tooling linked to Visual Studio. However, support
    for F# programming can be found also in **Xamarin Studio**, **Mono**, **MonoDevelop**,
    **SharpDevelop**, **MBrace**, and **WebSharper**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当前版本是4.0，它于2016年1月发布，并伴随着与Visual Studio相关的工具的几项改进。然而，F#编程语言的支持也可以在**Xamarin
    Studio**、**Mono**、**MonoDevelop**、**SharpDevelop**、**MBrace**和**WebSharper**中找到。
- en: According to **Syme**, F# originated from ML and has influences from other functional
    languages, mainly from **OCaml**, **C#**, **Python**, **Haskell**, **Scala**,
    and **Erlang**. To be more precise, Syme explains that from the syntactic point
    of view, the main influence comes from OCaml, while the object model aspect is
    inspired from C# and .NET.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**Syme**的说法，F#起源于ML，并受到了其他函数式语言的影响，主要是从**OCaml**、**C#**、**Python**、**Haskell**、**Scala**和**Erlang**。更准确地说，Syme解释说，从语法角度来看，主要影响来自OCaml，而对象模型方面则受到了C#和.NET的启发。
- en: F# is defined as a strongly typed, multi-paradigm, and functional-first programming
    language that encompasses functional, imperative, and object-oriented programming
    techniques.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: F#被定义为一种强类型、多范式和以函数式为主的编程语言，它包含了函数式、命令式和面向对象编程技术。
- en: It uses type inference from its inception in the way we've already seen from
    version 3.0 in C# when using the `var` keyword. However, F# admits explicit type
    annotations, and it requires it in certain situations. However, exceptions apart,
    every expression in F# is linked to a static type. If the function or expression
    doesn't return any value, the return type is named `unit`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它从一开始就使用类型推断，这与我们在C# 3.0版本中看到的使用`var`关键字的方式相同。然而，F#允许显式类型注解，并在某些情况下要求这样做。但是，除了一些例外，F#中的每个表达式都与一个静态类型相关联。如果函数或表达式不返回任何值，则返回类型命名为`unit`。
- en: The inevitable Hello World demo
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可避免的Hello World演示
- en: 'So, let''s start with the mandatory Hello World program, but first, keep in
    mind that you will have to activate F# tools in Visual Studio if you did not do
    that at installation time. (If you didn''t, when accessing the F# language section,
    you''ll be offered this activation.) Once activation is ready, you will be presented
    with a new type of project linked to this language in the way shown in the following
    screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从必做的Hello World程序开始，但首先，请记住，如果你在安装时没有这样做，你将需要在Visual Studio中激活F#工具。（如果没有，当访问F#语言部分时，你会被提供这种激活。）一旦激活就绪，你将看到一个与该语言相关联的新类型项目，就像以下截图所示：
- en: '![The inevitable Hello World demo](img/image00484.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![不可避免的Hello World演示](img/image00484.jpeg)'
- en: To start with, you can pick up the tutorial, which is a comprehensive collection
    of the different aspects of the language— it's pretty well structured—or just
    use a console application for that matter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以选择教程，这是一系列关于语言不同方面的综合集合——它结构相当合理——或者简单地使用控制台应用程序。
- en: 'If you opt for the tutorial, you can mark a section of the code you want to
    test, and if you right-click on that area, you''ll be presented with two options
    for execution: **Execute In Interactive** and **Debug In Interactive**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择教程，你可以标记你想要测试的代码部分，如果你在该区域右键点击，你会看到两个执行选项：**在交互式执行**和**在交互式调试**：
- en: '![The inevitable Hello World demo](img/image00485.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![不可避免的Hello World演示](img/image00485.jpeg)'
- en: To visualize the results, we can—of course—create an executable and launch it
    in a console window, but for this scenario, F# Interactive Window is more suitable.
    For completeness, keep in mind that you can call the compiler (named `fsc.exe`)
    using the **build** option in Visual Studio just like you would with any other
    project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化结果，我们当然可以创建一个可执行文件并在控制窗口中启动它，但在这个场景中，F#交互式窗口更合适。为了完整性，请记住，你可以使用Visual Studio中的**构建**选项调用编译器（命名为`fsc.exe`），就像调用任何其他项目一样。
- en: 'So, we''ll start with writing very simple code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从编写非常简单的代码开始：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This generates the following output in the **F# Interactive** window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**F#交互式**窗口生成以下输出：
- en: '![The inevitable Hello World demo](img/image00486.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![不可避免的Hello World演示](img/image00486.jpeg)'
- en: 'Here, we''ve done the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们做了以下操作：
- en: First, we used the `let` keyword in order to assign an arithmetic expression
    to variable `a`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`let`关键字将算术表达式赋值给变量`a`。
- en: Then, we used the same keyword for another variable, variable `b`, which uses
    the previous definition.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用相同的关键字为另一个变量，变量`b`，使用之前的定义。
- en: Finally, the `printfn` function of the F# library produced an output to the
    standard I/O, formatting the result in a manner similar to what we do in C#, just
    changing the `{0}..{1}` and so on, expressions into `%i` or the letter corresponding
    to the type of the value to be printed (`f` for float, `s` for strings, `d` for
    double, `A` for generic printing including arrays and tuples, and so on).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，F#库中的`printfn`函数向标准I/O输出，格式化结果的方式类似于我们在C#中做的那样，只是将`{0}..{1}`等表达式改为`%i`或打印要打印的值的类型的字母（例如，`f`用于浮点数，`s`用于字符串，`d`用于双精度，`A`用于包括数组和元组的通用打印，等等）。
- en: Note how the interactive window presents an echo of the members implied in the
    process, indicating its type as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意交互式窗口如何呈现过程中隐含的成员的回声，同时显示其类型。
- en: 'Keep in mind that since F# is considered another member of the Visual Studio
    family, it has its own area of configuration in the **Tools/Properties** dialog
    box, as shown in the next screenshot. In addition, another entry in this dialog
    allows you to configure behaviors of the **F# Interactive** window:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于F#被认为是Visual Studio家族的另一个成员，它在**工具/属性**对话框中有一个自己的配置区域，如下一张截图所示。此外，该对话框中的另一个条目允许你配置**F#交互式**窗口的行为：
- en: '![The inevitable Hello World demo](img/image00487.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![不可避免的Hello World演示](img/image00487.jpeg)'
- en: Identifiers and scope
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符和作用域
- en: The scope of an identifier indicates the area of code where such an identifier
    is usable. All identifiers, either functions or values, are scoped (valid) starting
    at the end of their definition until the end of the section in which they act.
    Additionally, in F#, you don't have to explicitly return any value, since the
    result of the computation is automatically assigned the corresponding identifier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符的作用域表示该标识符可用的代码区域。所有标识符，无论是函数还是值，都是从它们的定义结束开始，直到它们作用的部分结束的作用域（有效）。此外，在F#中，你不需要显式返回任何值，因为计算的结果会自动分配给相应的标识符。
- en: 'So, in order to create intermediate values for a computation, you denote it
    with indentation (by convention, the size of the indentation is 4, but the user
    can opt for any other value). Every indentation defines a new scope, and the end
    of every scope is marked by the end of the indentation. For example, let''s think
    of a function to calculate the hypotenuse of a right triangle:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了创建计算的中继值，你通过缩进来表示它（按照惯例，缩进的大小是4，但用户可以选择任何其他值）。每个缩进定义一个新的作用域，每个作用域的结束由缩进的结束标记。例如，让我们考虑一个计算直角三角形斜边的函数：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we define the `hypo` function, which receives two arguments of type `float`
    (note that we can explicitly indicate types with the syntax `arg:type`). Then,
    we declare `legsSquare` to be the sum of the squares of both triangle's legs,
    and this is done with a new level of indentation. Finally, we just calculate the
    square root of this intermediate variable without any other indication, which
    means that `System.Math.Sqrt(legsSquare)` is the return value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了 `hypo` 函数，它接收两个类型为 `float` 的参数（注意我们可以使用语法 `arg:type` 明确地指示类型）。然后，我们声明
    `legsSquare` 为两个三角形边的平方和，这是通过一个新的缩进级别来完成的。最后，我们只计算这个中间变量的平方根，没有任何其他指示，这意味着 `System.Math.Sqrt(legsSquare)`
    是返回值。
- en: Also, note how we make a reference to `System.Math` directly since it's included
    in the references of the project. Alternatively, you can use the `open` keyword
    to indicate a reference to `System` (such as `open System`), and then, you can
    use the `Math` static class in an unqualified way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意我们如何直接引用 `System.Math`，因为它包含在项目的引用中。或者，你可以使用 `open` 关键字来指示对 `System` 的引用（例如
    `open System`），然后，你可以无限制地使用 `Math` 静态类。
- en: Finally, we call `printfn` to format the output and make sure there's only one
    value to include in the formatted output string by enclosing the call to `hypo`
    in the parenthesis.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `printfn` 来格式化输出，并确保格式化输出字符串中只包含一个值，通过将 `hypo` 的调用放在括号中来做到这一点。
- en: 'Of course, the **F# Interactive** window will show the formatted result, as
    is expected:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，**F# Interactive** 窗口将显示格式化后的结果，正如预期的那样：
- en: '![Identifiers and scope](img/image00488.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![标识符和作用域](img/image00488.jpeg)'
- en: Lists
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'In F#, lists are ordered collections of immutable elements of the same type.
    Its generation admits many language-compatible options, but the initial style
    is very simple. If you go through the tutorial a bit, you''ll discover the following
    declaration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，列表是有序的不可变元素的集合，元素类型相同。它的生成允许许多与语言兼容的选项，但初始风格非常简单。如果你稍微浏览一下教程，你会发现以下声明：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, you are introduced to the range operator: (`..`), which denotes a sequence
    of elements deductible for the compiler. Due to the echo feature of the Interactive
    window, we just have to mark that line and select **Interactive Window** to view
    the results:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你被介绍到了范围运算符：(`..`)，它表示一个对编译器可导出的元素序列。由于 Interactive 窗口的回声功能，我们只需标记那一行并选择
    **Interactive Window** 来查看结果：
- en: '![Lists](img/image00489.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![列表](img/image00489.jpeg)'
- en: 'The range operator also admits the increment descriptor (..), allowing you
    to define a different, collective type, called sequence (`seq`) that supports
    many of the same functions as lists:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 范围运算符也接受增量描述符（..），允许你定义一个不同的、集体的类型，称为序列（`seq`），它支持与列表相同的许多函数：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we define a sequence of elements starting with `5`, going through `15`,
    and increasing in steps of three (the output being the following):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个以 `5` 开始，经过 `15`，以三的步长递增的元素序列（输出如下）：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the same manner as earlier, let''s mark the following sentence and proceed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，让我们标记以下句子并继续：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An array of tuples is created, each containing a number from 0 to 99 and its
    corresponding squares. There are a few things to notice in this sentence.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个元组数组，每个元组包含从 `0` 到 `99` 的一个数字及其对应的平方。在这个句子中有几点需要注意。
- en: Assigning something in squared brackets means that the expression inside it
    should be evaluated to an array (similar to JavaScript). We've seen this in the
    previous sentence as well, but this time, inside the brackets, we see a `for..in`
    loop and a `->` symbol, which indicate the generated value for each step in the
    loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号中赋值意味着其中的表达式应该被评估为一个数组（类似于 JavaScript）。我们也在上一句中看到了这一点，但这次，在括号内，我们看到一个 `for..in`
    循环和一个 `->` 符号，这表明循环每一步生成的值。
- en: This generated value turns out to be a tuple, since it's enclosed in parenthesis—a
    very powerful and expressive syntax.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成的值实际上是一个元组，因为它被括号包围——这是一个非常强大且富有表现力的语法。
- en: List objects contain several useful methods to manipulate their inner collections.
    One of them is `List.map`, which permits you to apply a function to each element
    in the list and returns a new list with the calculated results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象包含几个有用的方法来操作它们的内部集合。其中之一是 `List.map`，它允许你将一个函数应用于列表中的每个元素，并返回一个包含计算结果的新列表。
- en: It's important to note how close the philosophy of this approach reminds what
    we saw in C# when using generic's collections and passing a lambda expression
    to their methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这种方法的理念与我们在C#中使用泛型集合和传递lambda表达式给它们的方法时看到的非常相似。
- en: 'For example, we can write the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写以下代码：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `initialList` contains three float numbers, for which we want to calculate
    the square root. So, we generate another list (`sqrootList`) by calling `List.map`
    and passing to it as an argument an anonymous function that gets a value and returns
    its square root. The last argument is `initialList`. Note that the argument of
    `map` is just like a lambda expression.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`initialList`包含三个浮点数，我们想要计算它们的平方根。因此，我们通过调用`List.map`并传递一个匿名函数来生成另一个列表（`sqrootList`），该函数接收一个值并返回其平方根。最后一个参数是`initialList`。请注意，`map`的参数就像一个lambda表达式。
- en: 'Once more, the output in the **F# Interactive** windows is as expected:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，**F#交互式窗口**中的输出正如预期的那样：
- en: '![Lists](img/image00490.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![列表](img/image00490.jpeg)'
- en: Function declarations
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数声明
- en: 'We''ve seen how to use anonymous functions and how they can be passed as arguments
    to some methods. To declare a named function, you can use a similar syntax as
    what you used with variables but by specifying the arguments it can receive, following
    the function''s name:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用匿名函数以及它们如何作为参数传递给某些方法。要声明一个命名函数，你可以使用与变量类似的语法，但需要指定它可以接收的参数，并跟随函数的名称：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This time, `func1` is the name of the function, and `x` the argument to be
    passed, which can, optionally, be enclosed in parenthesis. Later on, we can combine
    the previous declaration with an assignment to a variable, which you can see if
    you continue to analyze this code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`func1`是函数的名称，`x`是要传递的参数，它可以选择性地用括号括起来。稍后，我们可以将之前的声明与赋值给变量的操作结合起来，这可以在继续分析此代码时看到：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, remember that arguments can be annotated (indicating its type explicitly):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，参数可以被注释（明确表示其类型）：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we need to indicate code structures inside the function, we will use indentation
    the way we saw in a previous sample along with the required expression to be evaluated
    (and that''s what `func3` does here):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在函数内部指示代码结构时，我们将使用与之前示例中相同的方式缩进，以及需要评估的表达式（这正是`func3`在这里所做的）：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note the difference between lists in relation with tuples, which are defined
    enclosed in parenthesis. Furthermore, a list can be generated using expressions
    that include loops, as you can see in the following code, which uses such a construction:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表与元组之间的区别，元组是通过括号定义的。此外，可以使用包含循环的表达式生成列表，如下面的代码所示，它使用了这种结构：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we have two `for` loops nested using the `for..in..do` syntax. Also,
    note the presence of the `yield` keyword, just like in C#. The previous code generates
    the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了嵌套的`for`循环，通过`for..in..do`语法实现。同时，请注意`yield`关键字的存在，这与C#中的用法类似。之前的代码生成了以下输出：
- en: '![Function declarations](img/image00491.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![函数声明](img/image00491.jpeg)'
- en: And the list goes on...
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推……
- en: The pipeline operator
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道操作符
- en: 'Another important feature of F# is the pipeline operator (`|>`). It serves
    to pass a value to a function but by *piping* the result. The definition is simple:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: F#的另一个重要特性是管道操作符（`|>`）。它用于将值传递给一个函数，但通过*管道*结果。定义很简单：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This means: take a parameter `x` and apply it to function `f`. In this way,
    the parameter is passed before the function and we can express chains of calculations
    in a very suitable manner. For instance, we can define a sum function and use
    it this way:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：取参数`x`并应用于函数`f`。这样，参数在函数之前传递，我们可以非常合适地表达一系列计算。例如，我们可以定义一个求和函数并这样使用它：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the execution, we''ll obtain a value of 10 for `chainOfSums`. For example,
    consider that we have the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们将获得`chainOfSums`的值为10。例如，考虑以下代码：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This means, take `numberList`, apply it to `List.map` of the function enclosed
    in parentheses (which calculates the square of every number in the list), and
    assign the result to the squares identifier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，取`numberList`，将其应用于括号内的`List.map`函数（该函数计算列表中每个数的平方），并将结果赋值给`squares`标识符。
- en: 'If we need to link several operations in a sequence over the same collection,
    we can concatenate the operator, as the next sample in the tutorial shows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在同一个集合上按顺序链接多个操作，我们可以连接操作符，正如教程中的下一个示例所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pattern matching
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Another useful structure when managing collections is the `match..with` construct.
    It's used with the `|` operator to indicate different options, much like what
    we would do in a `switch` and `case` statement in C#.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理集合时，另一个有用的结构是 `match..with` 构造。它与 `|` 操作符一起使用，以表示不同的选项，这与我们在 C# 中的 `switch`
    和 `case` 语句所做的一样。
- en: 'To test this in simple way, let''s try the typical recursive function to calculate
    the factorial of a number:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以简单的方式测试这一点，让我们尝试典型的递归函数来计算一个数字的阶乘：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the presence of the `rec` keyword as a modifier of the function's declaration
    in order to indicate that the function is recursive. The variable to test (`n`)
    goes in between the `match..with` structure and the `|` operator separates the
    distinct cases to be tested. Also, look at how the underscore operator (`_`) is
    used to indicate what to do with any other value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `rec` 关键字作为函数声明的修饰符的存在，以指示该函数是递归的。要测试的变量（`n`）位于 `match..with` 结构和 `|` 操作符之间，而下划线操作符（`_`）用于表示对任何其他值要做什么。
- en: 'The **F# Interactive** window, once more, will show the correct results:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**F# Interactive** 窗口再次显示了正确的结果：'
- en: '![Pattern matching](img/image00492.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![模式匹配](img/image00492.jpeg)'
- en: Classes and types
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类和类型
- en: F# can work well with classes and types, and by itself, it is considered a typed
    language. Actually, you can declare elements of any supported type using type
    abbreviations and type definitions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: F# 可以很好地与类和类型一起工作，并且本身被认为是类型化语言。实际上，你可以使用类型缩写和类型定义来声明任何受支持类型的元素。
- en: 'In the first case, we just establish aliases of existing types. You can declare
    these aliases using the `type` keyword followed by an identifier (the alias) and
    assign it to the type it represents:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们只是为现有类型建立别名。你可以使用 `type` 关键字后跟一个标识符（别名）来声明这些别名，并将其分配给它所表示的类型：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the second definition declares a new type construct made of two parts
    (`string` and `int`) that can be used later on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二个定义声明了一个由两部分（`string` 和 `int`）组成的新类型结构，可以在以后使用。
- en: 'The most common usage of types is to declare type definitions, indicating members
    as pairs of values (`key : type`) enclosed in curly braces, as the `RecordTypes`
    module of the tutorial reminds us (we reproduce it here):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '类型最常见的用法是声明类型定义，将成员作为括号内的值对（`key : type`）表示，正如教程中的 `RecordTypes` 模块提醒我们的那样（我们在此处重新呈现它）：'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we launch the previous code in the **F# Interactive** window, we will get
    the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 **F# Interactive** 窗口中运行前面的代码，我们将得到以下结果：
- en: '![Classes and types](img/image00493.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![类和类型](img/image00493.jpeg)'
- en: 'As you can see, the `contact1` identifier is qualified as `val (value)`. This
    value can also be used to declare further types based on the previous one. This
    is the purpose of the following declaration in the tutorial:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`contact1` 标识符被指定为 `val (值)`。此值也可以用于根据前面的类型声明进一步的类型。这正是教程中以下声明的目的：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, `contact2` is based on `contact1`, but there are two changed values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`contact2` 是基于 `contact1` 的，但有两组不同的值。
- en: 'The next definition makes things quite clear as well:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定义同样使事情变得非常清晰：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is used to convert the `ContactCard` type into a string as we check the
    output in the **F# Interactive** window after adding another sentence to test
    the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于将 `ContactCard` 类型转换为字符串，因为我们检查在添加另一句话以测试输出后 **F# Interactive** 窗口中的输出：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screenshot shows the output generated:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了生成的输出：
- en: '![Classes and types](img/image00494.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![类和类型](img/image00494.jpeg)'
- en: Casting
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类型转换
- en: In F#, casting sentences have their own specific operators. The two possible
    operations depend on the type of casting required (downcasting if you go from
    general to particular in the hierarchy, or upcasting if you proceed in the opposite
    way). As it happens, with C#, the hierarchy starts with `System.Object`, although
    there is an alias, `obj`, which we can use in its place.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，类型转换有自己的特定操作符。两种可能的操作取决于所需的类型转换类型（如果你从通用到特定在层次结构中转换，则是向下转换，如果你以相反的方式继续，则是向上转换）。实际上，与
    C# 一样，层次结构从 `System.Object` 开始，尽管有一个别名 `obj`，我们可以用它来代替。
- en: 'As for the behavior in relation to the compiler, let''s remember that upcasting
    is a safe operation because the compiler always knows the ancestors of the type
    to be converted. It is represented by a colon, followed by a greater-than sign
    (`:>`). For example, the following operation is legitimate:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 至于与编译器的行为相关，让我们记住向上转型是一个安全的操作，因为编译器总是知道要转换的类型的前辈。它由一个冒号，后跟一个大于号（`:>`）表示。例如，以下操作是合法的：
- en: '![Casting](img/image00495.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![转型](img/image00495.jpeg)'
- en: As we can see, the `someObject` identifier is declared in parenthesis as the
    result of a conversion from a literal string to `obj`. As a result, in the next
    sentence, Intellisense in V. Studio reminds us that `System.Object` declares exactly
    those members that appear in the contextual menu.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`someObject`标识符作为从字面字符串到`obj`的转换结果，在括号中声明。因此，在下一句中，V. Studio中的Intellisense提醒我们`System.Object`声明了那些出现在上下文菜单中的成员。
- en: The TypeScript language
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript语言
- en: 'For the last 5 or 6 years, there has been a growing hype around the languages
    used to build websites and web applications. As you surely know, the reason was
    mainly related to the proliferation of mobile devices of all types: tablets, phones,
    IoT devices, and so on.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去5到6年中，围绕用于构建网站和Web应用程序的语言的炒作日益增长。正如你肯定知道的，原因主要与各种类型移动设备的普及有关：平板电脑、手机、物联网设备等等。
- en: Parallel to this, back in 2008, a new effort for standardization emerged at
    the W3C ([http://www.w3.org](http://www.w3.org), the entity that takes care of
    most of the Internet language's specs) in order to update these languages of the
    Web and make them more suitable for this decade's needs. Announcements like the
    elimination of Flash components (or Silverlight, for that matter) on platforms
    such as MacOS or iOS only fostered these attempts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，回到2008年，W3C ([http://www.w3.org](http://www.w3.org)，负责大多数互联网语言规范的实体)出现了一项新的标准化努力，旨在更新这些网络语言并使它们更适合这个十年的需求。像在MacOS或iOS等平台上消除Flash组件（或者说是Silverlight）这样的公告，只是促进了这些尝试。
- en: For the first time in many years, a bunch of companies invested in the creation
    of this new Open Web that would be capable of holding any kind of content in a
    flexible, adaptable, easy-to-use, and responsive way.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来首次，许多公司投资于创建这种新的开放网络，它能够以灵活、适应性、易于使用和响应的方式承载任何类型的内容。
- en: All these efforts came to an end in 2015, with the final recommendation of HTML5
    ([https://www.w3.org/TR/html5/](https://www.w3.org/TR/html5/)) along with a number
    of specifications related to the CSS3 presentation syntax (it's not a language,
    remember). They adopted a *most-needed* approach in the writing and testing process,
    starting with those whose implementation was a due requirement, such as Media
    Queries (very important in mobile devices, as you know).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些努力在2015年画上了句号，最终推荐了HTML5 ([https://www.w3.org/TR/html5/](https://www.w3.org/TR/html5/))
    以及一系列与CSS3表现语法相关的规范（记住，它不是一个语言）。他们在编写和测试过程中采用了*最急需的*方法，从那些实现是必要要求的开始，例如媒体查询（正如你所知，在移动设备中非常重要）。
- en: Finally, the expected new version of the JavaScript language was published by
    ECMA ([http://www.ecma-international.org/](http://www.ecma-international.org/))
    and it received the name ECMAScript 2015 (previously named ES6 in the specification
    and testing processes).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，预期的JavaScript语言新版本由ECMA ([http://www.ecma-international.org/](http://www.ecma-international.org/))
    发布，并命名为ECMAScript 2015（在规范和测试过程中之前被称为ES6）。
- en: 'Important decisions were taken in the creation of the HTML, CSS, and JavaScript
    standards: preserving backward compatibility, applying good practices and principles
    (such as the S.O.L.I.D. principles), and above all, making these specifications
    *a continuous process of development and integration, for which the consensus
    of companies is key*. So, after this first release of the specifications, the
    work continued in all these areas, except now, engineers of the main user agents''
    manufacturers collaborated directly with W3C and ECMA in order to make the HTML,
    CSS, and JavaScript engines faster, more reliable, and up to date. The most evident
    applications that came up as a result are generally called modern browsers.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建HTML、CSS和JavaScript标准的过程中，做出了重要的决策：保持向后兼容性，应用良好的实践和原则（例如S.O.L.I.D.原则），最重要的是，使这些规范成为一个持续的开发和集成过程，其中公司的共识是关键。因此，在发布这些规范的第一版之后，所有这些领域的工作都继续进行，但现在，主要用户代理制造商的工程师直接与W3C和ECMA合作，以使HTML、CSS和JavaScript引擎更快、更可靠、更及时。由此产生的最明显的应用通常被称为现代浏览器。
- en: The new JavaScript
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的JavaScript
- en: So, a new JavaScript was born, which included many of the features that were
    long awaited by developers, such as classes, interfaces, scope variables, packages
    (finally, the concept of namespace shows up in the language, eliminating the need
    for closures), and many more.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个新的JavaScript诞生了，它包括了开发者长期以来一直期待的功能，例如类、接口、作用域变量、包（终于，命名空间的概念出现在语言中，消除了对闭包的需求），以及更多。
- en: Along with the new requirements, a set of libraries (a big one, by the way)
    appeared to help the developer in their daily tasks (they're numbered by hundreds,
    of thousands today).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新要求的出现，出现了一套库（实际上是一个很大的库）来帮助开发者完成日常任务（它们现在以数百、数千计）。
- en: 'As a consequence, the JavaScript language appeared to be the number one preference
    according to quite a few developer surveys carried out last year. One was carried
    out by the most popular code reference website among developers today: StackOverflow,
    which researched and published it with quite insightful results; you can read
    it at [http://stackoverflow.com/research/developer-survey-2015](http://stackoverflow.com/research/developer-survey-2015).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据去年进行的大量开发者调查，JavaScript语言似乎成为了首选。其中一项调查是由目前开发者中最受欢迎的代码参考网站StackOverflow进行的，它进行了研究并发表了具有深刻见解的结果；您可以在[http://stackoverflow.com/research/developer-survey-2015](http://stackoverflow.com/research/developer-survey-2015)上阅读。
- en: 'The poll is very wide and covers a lot of different aspects, with thousands
    of developers having participated. The following figure showing the language''s
    ranking is pretty important:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 投票范围非常广泛，涵盖了众多不同方面，有成千上万的开发者参与了调查。以下显示语言排名的图表非常重要：
- en: '![The new JavaScript](img/image00496.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![新的JavaScript](img/image00496.jpeg)'
- en: All this is great, but support for these features in browsers immediately became
    an important issue. Actually, support is insufficient and only a few browsers
    (the modern browsers, which we mentioned earlier), such as Chrome's latest versions,
    Microsoft Edge, and Firefox's recent updates, give enough coverage of the great
    amount of news and functionality proposed by the new standards.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很棒，但这些功能在浏览器中的支持立即成为一个重要问题。实际上，支持不足，只有少数浏览器（我们之前提到的现代浏览器），如Chrome的最新版本、Microsoft
    Edge和Firefox的最新更新，提供了对新标准提出的新闻和功能的大范围覆盖。
- en: To make matters even worse, versions of the same type of browser are not coincidental,
    since they might depend on the device we use to open a website. In order to finalize
    the list of problems linked to this situation, developers started to build big
    applications in which, not just dozens or hundreds but several thousands of lines
    of JavaScript were required.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要使情况变得更糟，同一类型的浏览器版本并非巧合，因为它们可能依赖于我们用来打开网站的设备。为了最终确定与这种情况相关的问题列表，开发者开始构建大型应用程序，在这些应用程序中，需要的不仅仅是几十或几百行，而是数千行JavaScript。
- en: So, the need for a new tool to build these sites and applications arose, and—once
    again—our admired Anders Hejlsberg decided to do something serious about it. The
    solution he proposed is called TypeScript.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要一个新的工具来构建这些网站和应用，而我们的尊敬的Anders Hejlsberg再次决定对此采取严肃的态度。他提出的解决方案被称为TypeScript。
- en: 'TypeScript: a superset of JavaScript'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript：JavaScript的超集
- en: 'So, what''s TypeScript and why is it a solution for these problems? The first
    question is answered on its own site at [http://www.typescriptlang.org/](http://www.typescriptlang.org/).
    TypeScript is, as the ineffable Wikipedia states:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，TypeScript是什么，为什么它是这些问题的解决方案？第一个问题在其自己的网站上得到了解答：[http://www.typescriptlang.org/](http://www.typescriptlang.org/)。正如难以言喻的维基百科所说：
- en: Typescript is a free and open source programming language developed and maintained
    by Microsoft. It is a strict superset of JavaScript, and adds optional static
    typing and class-based object-oriented programming to the language. TypeScript
    may be used to develop JavaScript applications for client-side or server-side
    (Node.js) execution.
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TypeScript是由微软开发和维护的免费开源编程语言。它是JavaScript的一个严格超集，并为语言添加了可选的静态类型和基于类的面向对象编程。TypeScript可用于开发客户端或服务器端（Node.js）执行的JavaScript应用程序。
- en: 'And, how does TypeScript achieve these goals? Again, Wikipedia reminds us that:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，TypeScript是如何实现这些目标的？再次，维基百科提醒我们：
- en: TypeScript is designed for development of large applications and transcompiles
    to JavaScript. As TypeScript is a superset of JavaScript, any existing JavaScript
    programs are also valid TypeScript programs.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TypeScript是为开发大型应用程序而设计的，并转译为JavaScript。由于TypeScript是JavaScript的超集，任何现有的JavaScript程序也是有效的TypeScript程序。
- en: '![TypeScript: a superset of JavaScript](img/image00497.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![TypeScript：JavaScript的超集](img/image00497.jpeg)'
- en: So, we can start writing or use already existing JavaScript, knowing that it
    will be 100% compatible with older browsers. However, the term transcompiles requires
    a bit of explanation. Since JavaScript (any version of it) is an interpreted,
    functional language, the one in charge of its execution will always be the JavaScript
    runtime embedded in the browser or user agent.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以开始编写或使用已经存在的JavaScript，知道它将100%与旧浏览器兼容。然而，术语转编译需要一些解释。由于JavaScript（任何版本）是一种解释性、函数式语言，负责其执行的一直是嵌入在浏览器或用户代理中的JavaScript运行时。
- en: 'So, transcompiling (or just transpiling, like most people call it) is the process
    of converting TypeScript code into pure JavaScript that can be interpreted correctly
    by browsers. The advantage is double: on the one hand, we can decide which version
    of JavaScript we want (JavaScript 3, 5, or 2015), and on the other hand, when
    used with a tool such as Visual Studio (or even Visual Studio Code, Emacs, Vim,
    Sublime Text, and Eclipse via a plug-in provided by Palantir Technologies, and
    so on), we''ll get all the benefits of Intellisense, code completion, dynamic
    analysis, and so on.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，转编译（或简称为转译，就像大多数人称呼的那样）是将TypeScript代码转换为浏览器可以正确解释的纯JavaScript的过程。优势是双重的：一方面，我们可以决定我们想要哪个版本的JavaScript（JavaScript
    3、5或2015），另一方面，当与Visual Studio（甚至Visual Studio Code、Emacs、Vim、Sublime Text和Eclipse（通过Palantir
    Technologies提供的插件）等工具一起使用时，我们将获得Intellisense、代码补全、动态分析等所有好处。
- en: Indeed, once those tools are configured, they can use Roselyn services to supply
    Intellisense, type inference, and all the goodness we all know and love from other
    languages. By convention (although it's not mandatory), TypeScript files have
    a `.ts` extension.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一旦这些工具配置完成，它们可以使用Roselyn服务来提供Intellisense、类型推断以及我们从其他语言中都知道和喜爱的所有优点。按照惯例（尽管不是强制性的），TypeScript文件具有`.ts`扩展名。
- en: So, what exactly is TypeScript?
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，TypeScript究竟是什么？
- en: 'The official answer to this question is that it is a superset of JavaScript
    that transpiles (generates after compilation) to valid JavaScript for whatever
    version you want to support: 3.0, 5.0 of ECMAScript 2015.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题的官方答案是，它是一个超集，可以将JavaScript（无论你想要支持哪个版本：ECMAScript 2015的3.0、5.0）编译（编译后生成）为有效的JavaScript。
- en: Furthermore, it allows you to work with features that won't be available until
    the next releases of the specification or—even if they are—features that are not
    yet supported in the majority of browsers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还允许你使用在规范的下一次发布中才可用的功能，或者即使它们已经可用，但在大多数浏览器中尚未得到支持的功能。
- en: 'Besides, the language starts with JavaScript, so any piece of JavaScript is
    also valid TypeScript. The big difference is that you work with a language that
    offers generally the same type of editing and compiling services that we''ve seen
    in this book related to Roslyn in particular: code completion, peek definitions,
    type checking, refactoring, code analysis, and so on.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，语言从JavaScript开始，因此任何JavaScript片段也是有效的TypeScript。最大的区别在于，你使用的是一种提供通常与我们在本书中看到的Roslyn相关的相同类型的编辑和编译服务的语言：代码补全、查看定义、类型检查、重构、代码分析等。
- en: Main features and coalitions
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要特性和联盟
- en: Another main feature is that the project was built to comply with any browser,
    any host, and any operating system. Actually, the TypeScript transpiler is written
    in TypeScript.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要特点是该项目旨在兼容任何浏览器、任何主机和任何操作系统。实际上，TypeScript 编译器是用 TypeScript 编写的。
- en: 'To summarize, the two most important characteristics that this architecture
    provide are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这个架构提供的两个最重要的特性如下：
- en: A whole set of tools enabled by static types
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由静态类型启用的一整套工具
- en: The possibility of using features in the future, with the confidence that the
    resulting code will work in every browser (or server).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来使用功能的可能性，有信心生成的代码将在每个浏览器（或服务器）上运行。
- en: With all these possibilities, a joint venture between Microsoft and Google appeared
    (to be precise, between the TypeScript team and Google's Angular Team) to work
    together in the new versions of Angular (2.0+).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些可能性中，微软和谷歌之间出现了一个合资企业（确切地说，是 TypeScript 团队和谷歌的 Angular 团队之间）来共同开发 Angular
    的新版本（2.0+）。
- en: Installing the tools
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装工具
- en: As always, we recommend that you download and install the latest version of
    the library, which is accompanied by some project templates. These templates cover
    the use of TypeScript with Apache/Cordova, with Node.js, or plain HTML.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们建议您下载并安装库的最新版本，它附带了一些项目模板。这些模板涵盖了使用 TypeScript 与 Apache/Cordova、Node.js
    或纯 HTML 的用法。
- en: You will find the latest version of TypeScript by searching for its name in
    the **Tools/Extensions and Updates** menu. There's another way to install it,
    by visiting the official site for the language located at [https://www.typescriptlang.org/](https://www.typescriptlang.org/),
    which also contains extra documentation, demos, and a REPL to test code snippets
    online.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 **工具/扩展和更新** 菜单中搜索其名称来找到 TypeScript 的最新版本。还有另一种安装方式，即访问位于 [https://www.typescriptlang.org/](https://www.typescriptlang.org/)
    的语言官方网站，该网站还包含额外的文档、演示和一个在线测试代码片段的 REPL。
- en: 'The current version that I''m using in this book is 1.8.4, but most likely,
    by the time the book is published, you''ll have access to versions higher than
    2.0\. After accepting to download the installable file, you''ll be presented with
    a confirmation dialog box like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中使用的是当前版本 1.8.4，但很可能会在本书出版时，您将能够访问高于 2.0 的版本。在同意下载可安装文件后，您将看到一个确认对话框，如下所示：
- en: '![Installing the tools](img/image00498.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![安装工具](img/image00498.jpeg)'
- en: If you want to try a more complete and self-explanatory test of TypeScript,
    you can create a new project named `HTML Application` with TypeScript which you'll
    find in `Templates/TypeScript` after the previous installation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试一个更完整且更具说明性的 TypeScript 测试，您可以在 `Templates/TypeScript` 中创建一个名为 `HTML Application`
    的新项目，这是在之前的安装之后可以找到的。
- en: 'The execution generates a web page, which shows a clock that changes the time
    every second. The review of the code structure is very informative:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行会生成一个网页，显示一个每秒更改一次时间的时钟。对代码结构的审查非常有信息量：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the `app.ts` file is defining a class (`Greeter`). The class
    has a state, defined using three fields, two of which relate to the user interface,
    so they are created as `HTMLElement`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`app.ts` 文件正在定义一个类（`Greeter`）。该类有一个状态，使用三个字段定义，其中两个与用户界面相关，因此它们被创建为 `HTMLElement`。
- en: The `constructor` method is in charge of the initialization. It gets an `HTMLElement`
    argument and creates a new `<span>` element next to it in order to display the
    time every second after reading it from the system's time. The value is assigned
    to the `innerText` argument of `<span>`, so it shows the current time from the
    beginning.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor` 方法负责初始化。它接收一个 `HTMLElement` 参数，并在读取系统时间后在其旁边创建一个新的 `<span>` 元素以显示时间。该值被分配给
    `<span>` 的 `innerText` 参数，因此它从开始就显示当前时间。'
- en: 'Then, we have two methods: `start()` and `stop()`. The first uses a lambda
    and assigns the value of the `timerToken` field to a `setInterval` method, which
    receives a function to be called periodically. The return value is useful if you
    want to cancel the process at anytime, as we will do in slightly modifying the
    demo.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有两个方法：`start()` 和 `stop()`。第一个使用 lambda 并将 `timerToken` 字段的值分配给 `setInterval`
    方法，该方法接收一个定期调用的函数。如果想要在任何时候取消该过程，这个返回值是有用的，正如我们在稍作修改的演示中所做的那样。
- en: 'The result is shown in the `HTMLElement` interface linked to it; note that
    only one element in the user interface is involved: a `div` element with its ID
    `content`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在与之链接的 `HTMLElement` 接口中；请注意，用户界面中只涉及一个元素：一个具有其 ID `content` 的 `div` 元素。
- en: The mechanism that turns on the clock is expressed after the definition of the
    `Greeter` class. In the `onload` event, the content element is linked to a new
    instance of the `Greeter` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 控制时钟启动的机制在定义`Greeter`类之后表达。在`onload`事件中，内容元素被链接到`Greeter`类的新实例。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To summarize, the class' purpose is to define a behavior and associate that
    behavior with a part of the user interface.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，类的目的是定义一种行为，并将这种行为与用户界面的一部分关联起来。
- en: 'We can stop the clock simply by including a button (or any other `HTMLElement`
    interface) and making a slight change in the TypeScript code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包含一个按钮（或任何其他`HTMLElement`接口）并在TypeScript代码中稍作修改来简单地停止时钟：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since `stop()` is already defined, there''s no need to change the `Greeter`
    class. We assign a call to the `stop()` method to the button''s `click` event,
    and that''s all that is required:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`stop()`方法已经定义，因此无需更改`Greeter`类。我们将对`stop()`方法的调用分配给按钮的`click`事件，这就是所需的所有操作：
- en: '![Installing the tools](img/image00499.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![安装工具](img/image00499.jpeg)'
- en: Transpiling to different versions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转译到不同版本
- en: Visual Studio gives us the option to choose which version of JavaScript will
    be generated after the process of transpilation. You just have to go to **Project**
    | **Properties** and select the **TypeScript Build** tab. You'll learn how you're
    offered several options on how you would like the transpiler to behave. One of
    them shows a ComboBox with the available final JavaScript options.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio为我们提供了选择在转译过程之后生成哪个JavaScript版本的选项。你只需转到**项目** | **属性**并选择**TypeScript构建**选项卡。你将了解你被提供了如何让转译器行为的多种选项。其中之一显示了一个ComboBox，其中包含了可用的最终JavaScript选项。
- en: 'Also, note that other options are available on JSX, managing comments, combining
    JavaScript, and so on in the way shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，JSX上还有其他选项，如管理注释、结合JavaScript等，具体方式如以下截图所示：
- en: '![Transpiling to different versions](img/image00500.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![转译到不同版本](img/image00500.jpeg)'
- en: A comparison of both files (`.ts` and `.js`) will make it clear how neat and
    concise (and object-oriented) the TypeScript code is in relation to the pure JavaScript.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两个文件（`.ts`和`.js`）将清楚地说明TypeScript代码相对于纯JavaScript的整洁和简洁（以及面向对象）。
- en: However, the benefits don't end there. This is just the beginning, since most
    advantages are related to the creation process in the editor, Intellisense, type
    inference, and the like...
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，好处并不止于此。这只是开始，因为大多数优势都与编辑器中的创建过程、Intellisense、类型推断等有关...
- en: Advantages in the IDE
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDE中的优势
- en: 'When we pass the cursor over a definition of the previous code, observe how
    every element is recognized by its type: the class itself and its members:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将光标移至前述代码的定义上时，观察每个元素是如何通过其类型被识别的：类本身及其成员：
- en: '![Advantages in the IDE](img/image00501.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![IDE中的优势](img/image00501.jpeg)'
- en: 'It''s not just about recognizing the initialization values. If we change a
    member''s value in the code and assign it to a different (non-compatible) type,
    the IDE will complain about this circumstance again:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是识别初始化值。如果我们更改代码中成员的值并将其分配给不同的（不兼容的）类型，IDE将再次对此情况提出抱怨：
- en: '![Advantages in the IDE](img/image00502.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![IDE中的优势](img/image00502.jpeg)'
- en: Even within `HTMLElements`, you can find this kind of Intellisense, since a
    walk over the `innerText` property of the `span` element will tell you that the
    property is a string value.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在`HTMLElements`内部，你也能找到这种Intellisense，因为遍历`span`元素的`innerText`属性会告诉你该属性是一个字符串值。
- en: 'To end with this example and change the functionality so that we can stop the
    clock, we only need to add any suitable element in the UI and assign it a call
    to `Greeter.stop()`, for example, with the following code to the HTML file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这个例子并改变功能，以便我们可以停止时钟，我们只需要在UI中添加任何合适的元素，并将其分配给`Greeter.stop()`的调用，例如，在以下代码中添加到HTML文件中：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the TypeScript code, the following is the `window.onload` assignment:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript代码中，以下是对`window.onload`的赋值：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just for the sake of completeness, I''m including the whole code of the TypeScript
    file after the proposed modification:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我在以下修改后包括TypeScript文件的整个代码：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will work like a charm. So, we can follow the OOP paradigm, create classes,
    define interfaces, and so on and still be working with pure JavaScript.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将像魔法一样起作用。因此，我们可以遵循OOP范式，创建类，定义接口等，同时仍然使用纯JavaScript。
- en: A note on TypeScript's object-oriented syntax
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于TypeScript面向对象语法的说明
- en: In this basic demo, the `Greeter` class is defined using the new `class` keyword
    available in ECMAScript 2015\. You can declare a state for the class by defining
    its members, followed by the corresponding type—either it is another type (such
    as an `HTMLElement`) or a primitive type, such as `number`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本演示中，`Greeter` 类是使用 ECMAScript 2015 中可用的新的 `class` 关键字定义的。你可以通过定义其成员并随后指定相应的类型来为类声明一个状态——要么是另一种类型（例如
    `HTMLElement`），要么是原始类型，如 `number`。
- en: The constructor gets the element passed to it, assigns it a text, and creates
    a new `span` element that will be the receiver of every new string the `start()`
    method generates in order to update the current time. Once that span is initialized,
    the preliminary state of the class is ready to start working.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数获取传递给它的元素，为其分配文本，并创建一个新的 `span` 元素，该元素将成为 `start()` 方法生成的每个新字符串的接收者，以便更新当前时间。一旦这个
    span 初始化完成，类的初步状态就准备好开始工作了。
- en: 'Later, two methods are defined: one to start the clock and another to stop
    it. Note that the clock is implemented using the `setInterval` function of JavaScript.
    The way to stop the interval process from keeping on running is by using a reference
    to the return value of that function. This is why `timerToken` is part of the
    class.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，定义了两个方法：一个用于启动时钟，另一个用于停止时钟。请注意，时钟是通过 JavaScript 的 `setInterval` 函数实现的。停止间隔过程继续运行的方法是使用该函数的返回值的引用。这就是为什么
    `timerToken` 是类的一部分。
- en: Also, observe the declaration of the callback function passed to `setInterval`,
    since it is another lambda expression, which creates a new string containing the
    current time every half second.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意传递给 `setInterval` 的回调函数的声明，因为它也是一个 lambda 表达式，每半秒创建一个包含当前时间的新字符串。
- en: There's another important thing to note. How does the demo work if there's no
    `app.js` file yet? Well, if you press the **Show all files** button in the **Solution
    Explorer** menu, you'll see that an `app.js` file has indeed been created, and
    prototype inheritance has been used to define the functionality, only that it's
    been created using the JavaScript 3 syntax, thus allowing older browsers to work
    with it without incompatibilities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一件重要的事情需要注意。如果没有 `app.js` 文件，演示如何工作？好吧，如果你在 **Solution Explorer** 菜单中按下 **Show
    all files** 按钮，你会看到确实已经创建了一个 `app.js` 文件，并且使用了原型继承来定义功能，只是它使用的是 JavaScript 3 语法，因此允许旧浏览器在不兼容的情况下与之协同工作。
- en: More details and functionality
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多细节和功能
- en: Up to this point, we've seen another approach to programming, this time, linked
    to the browser's universal language. With TypeScript, Microsoft takes a major
    step forward in covering its ecosystem of languages, and many companies are adopting
    it as an advanced solution that allows programming today with tomorrow's languages,
    as proclaimed by its slogan.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了另一种编程方法，这次是与浏览器的通用语言相关联。通过 TypeScript，微软在覆盖其语言生态系统方面迈出了重要的一步，许多公司正在采用它作为一项高级解决方案，允许使用明天的语言进行今天的编程，正如其口号所宣称的那样。
- en: In this introduction, our purpose was only to present the language and its main
    features and integration with Visual Studio. In [Chapter 8](part0044.xhtml#aid-19UOO2
    "Chapter 8. Open Source Programming"), *Open Source Programming*, we'll cover
    more aspects of the language so you can have a better idea of its possibilities.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个介绍中，我们的目的只是介绍该语言及其主要功能和与 Visual Studio 的集成。在 [第 8 章](part0044.xhtml#aid-19UOO2
    "第 8 章。开源编程") *开源编程* 中，我们将介绍该语言的更多方面，以便你更好地了解其可能性。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We skimmed the surface of some of the most typical characteristics of the F#
    and TypeScript languages, which are now part of the .NET language ecosystem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地概述了 F# 和 TypeScript 语言的一些最典型的特性，这些语言现在是 .NET 语言生态系统的一部分。
- en: Both are functional languages, but—as you saw—the differences between them are
    evident. In the first case, we saw how declarations are made and understood the
    important role of operators in the language.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种语言都是函数式语言，但正如你所见，它们之间的区别是明显的。在第一种情况下，我们看到了如何进行声明，并理解了运算符在语言中的重要作用。
- en: We also covered some of the most typical uses and looked for equivalent expressions
    in the C# language.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些最典型的用法，并在 C# 语言中寻找等效的表达式。
- en: As for TypeScript, we saw how it has become a superset of JavaScript, allowing
    the programmer to work using an OOP coding style while still transpiling the resulting
    code in a way that provides backward browser compatibility, even reaching version
    3 of the language.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TypeScript，我们看到了它如何成为JavaScript的超集，允许程序员使用面向对象编程风格进行工作，同时仍然以提供向后浏览器兼容性的方式转换生成的代码，甚至达到语言的第3版。
- en: We also explored the fundamental role that Visual Studio plays in editing this
    code, so we included some screenshots from the TypeScript Editor to prove this
    point. We'll see more about it in [Chapter 8](part0044.xhtml#aid-19UOO2 "Chapter 8. Open
    Source Programming"), *Open Source Programming*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了Visual Studio在编辑此代码中的基本作用，因此我们包含了一些来自TypeScript编辑器的截图来证明这一点。我们将在第8章[开源编程](part0044.xhtml#aid-19UOO2
    "第8章。开源编程")中了解更多关于它的情况，*开源编程*。
- en: In the next chapter, we will go deeper into programmability using Reflection
    and Interop Applications, which allow us to use other well-known tools, such as
    the Microsoft Office Suite, directly in our applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨使用反射和互操作应用程序的可编程性，这些应用程序允许我们直接在我们的应用程序中使用其他知名工具，例如Microsoft Office套件。
