<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Lights and Effects</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using lights and cookie textures to simulate a cloudy day</li><li class="listitem" style="list-style-type: disc">Adding a custom Reflection map to a scene</li><li class="listitem" style="list-style-type: disc">Creating a laser aim with Projector and Line Renderer</li><li class="listitem" style="list-style-type: disc">Reflecting surrounding objects with Reflection Probes</li><li class="listitem" style="list-style-type: disc">Setting up an environment with Procedural Skybox and Directional Light</li><li class="listitem" style="list-style-type: disc">Lighting a simple scene with Lightmaps and Light Probes</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Introduction</h1></div></div></div><p>Whether you're willing to make a better-looking game, or add interesting features, lights and effects can boost your project and help you deliver a higher quality product. In this chapter, we will look at the creative ways of using lights and effects, and also take a look at some of Unity's new features, such as <a class="indexterm" id="id481"/><strong>Procedural Skyboxes</strong>, <strong>Reflection Probes</strong>, <strong>Light Probes</strong>, and custom <a class="indexterm" id="id482"/><strong>Reflection Sources</strong>.</p><p>Lighting is<a class="indexterm" id="id483"/> certainly an <a class="indexterm" id="id484"/>area that has received a lot of attention from Unity, which now<a class="indexterm" id="id485"/> features real-time <strong>Global Illumination</strong> technology <a class="indexterm" id="id486"/>provided by <strong>Enlighten</strong>. This new technology provides better and more realistic results for both real-time and baked lighting. For more information on<a class="indexterm" id="id487"/> Unity's Global Illumination system, check out its documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/GIIntro.html">http://docs.unity3d.com/Manual/GIIntro.html</a>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec170"/>The big picture</h2></div></div></div><p>There are<a class="indexterm" id="id488"/> many ways of creating light sources in Unity. Here's a quick overview of the most common methods.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec45"/>Lights</h3></div></div></div><p>Lights are<a class="indexterm" id="id489"/> placed into the scene as game objects, featuring a <strong>Light</strong> component. They can function in <a class="indexterm" id="id490"/><strong>Realtime</strong>, <strong>Baked</strong>, or <strong>Mixed</strong> modes. Among<a class="indexterm" id="id491"/> the other properties, they can have their <strong>Range</strong>, <strong>Color</strong>, <strong>Intensity</strong>, and<a class="indexterm" id="id492"/> <strong>Shadow Type</strong> set by<a class="indexterm" id="id493"/> the user. There<a class="indexterm" id="id494"/> are<a class="indexterm" id="id495"/> four types <a class="indexterm" id="id496"/>of lights:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Directional Light</strong>: This is normally <a class="indexterm" id="id497"/>used to simulate the sunlight</li><li class="listitem" style="list-style-type: disc"><strong>Spot Light</strong>: This works like a <a class="indexterm" id="id498"/>cone-shaped spot light</li><li class="listitem" style="list-style-type: disc"><strong>Point Light</strong>: This is<a class="indexterm" id="id499"/> a bulb lamp-like, omnidirectional light</li><li class="listitem" style="list-style-type: disc"><strong>Area Light</strong>: This baked-only light type is <a class="indexterm" id="id500"/>emitted in all directions from a rectangle-shaped entity, allowing for a smooth, realistic shading</li></ul></div><p>For an overview<a class="indexterm" id="id501"/> of the light types, check Unity's documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Lighting.html">http://docs.unity3d.com/Manual/Lighting.html</a>.</p><div><img alt="Lights" src="img/1362_06_50.jpg"/><div><p>Different types of lights</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec46"/>Environment Lighting</h3></div></div></div><p>Unity's <a class="indexterm" id="id502"/><strong>Environment Lighting</strong> is often achieved through the combination of a <strong>Skybox</strong> material and sunlight defined by the scene's <strong>Directional Light</strong>. Such a combination creates an ambient light that is integrated into the scene's environment, and which can be set as <strong>Realtime</strong> or <strong>Baked into Lightmaps</strong>.</p><div><img alt="Environment Lighting" src="img/1362_06_51.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec47"/>Emissive materials</h3></div></div></div><p>When applied to <a class="indexterm" id="id503"/>static objects, materials featuring the <strong>Emission</strong> colors or maps will cast light over surfaces nearby, in both real-time and baked modes, as shown in the following screenshot:</p><div><img alt="Emissive materials" src="img/1362_06_52.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec48"/>Projector</h3></div></div></div><p>As its name <a class="indexterm" id="id504"/>suggests, a <strong>Projector</strong> can be used to simulate projected lights <a class="indexterm" id="id505"/>and shadows, basically by projecting a material and its texture map onto the other objects.</p><div><img alt="Projector" src="img/1362_06_53.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec49"/>Lightmaps and Light Probes</h3></div></div></div><p>
<strong>Lightmaps</strong> are basically<a class="indexterm" id="id506"/> texture maps generated from the scene's lighting information and applied to the scene's static objects in order to avoid the use of processing-intensive real-time<a class="indexterm" id="id507"/> lighting.</p><p>
<strong>Light Probes</strong> are a <a class="indexterm" id="id508"/>way of sampling the scene's illumination at specific points in order<a class="indexterm" id="id509"/> to have it applied onto dynamic objects without the use of real-time lighting.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec50"/>The Lighting window</h3></div></div></div><p>The <strong>Lighting</strong> window, which<a class="indexterm" id="id510"/> can be found through navigating to the <strong>Window</strong> | <strong>Lighting</strong> menu, is the hub for setting and adjusting the scene's illumination<a class="indexterm" id="id511"/> features, such as Lightmaps, Global Illumination, Fog, and much more. It's strongly recommended that you take a look at Unity's documentation on the subject, which <a class="indexterm" id="id512"/>can be found at <a class="ulink" href="http://docs.unity3d.com/Manual/GlobalIllumination.html">http://docs.unity3d.com/Manual/GlobalIllumination.html</a>.</p><div><img alt="The Lighting window" src="img/1362_06_54.jpg"/></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Using lights and cookie textures to simulate a cloudy day</h1></div></div></div><p>As it can be <a class="indexterm" id="id513"/>seen in many first-person shooters <a class="indexterm" id="id514"/>and survival horror games, lights and shadows can add a great deal of realism to a scene, helping immensely<a class="indexterm" id="id515"/> to create the right atmosphere for the game. In this recipe, we will create a cloudy outdoor environment using cookie textures. Cookie textures work as masks for lights. It functions by adjusting the intensity of the light projection to the cookie texture's alpha channel. This allows for a silhouette effect (just think of the bat-signal) or, as in this particular case, subtle variations that give a filtered quality to the lighting.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec171"/>Getting ready</h2></div></div></div><p>If you don't have access to an image editor, or prefer to skip the texture map elaboration in order to focus on the<a class="indexterm" id="id516"/> implementation, please use the image file called <code class="literal">cloudCookie.tga</code>, which is provided inside the <code class="literal">1362_06_01</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec172"/>How to do it...</h2></div></div></div><p>To simulate a<a class="indexterm" id="id517"/> cloudy outdoor environment, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In your<a class="indexterm" id="id518"/> image editor, create a new 512 x 512 pixel image.</li><li class="listitem">Using black as the foreground color and white as the background color, apply the Clouds filter (in Photoshop, this is done by navigating to the <strong>Filter</strong> | <strong>Render</strong> | <strong>Clouds</strong> menu).<div><img alt="How to do it..." src="img/1362_06_01.jpg"/></div><div><div><h3 class="title"><a id="note34"/>Note</h3><p>Learning about the Alpha channel is useful, but you could get the same result without it. Skip steps 3 to 7, save your image as <code class="literal">cloudCookie.png</code> and, when changing texture type in step 9, leave Alpha from Greyscale checked.</p></div></div></li><li class="listitem">Select your entire image and copy it.</li><li class="listitem">Open the <strong>Channels</strong> window (in Photoshop, this can be done by navigating to the <strong>Window</strong> | <strong>Channels</strong> menu).</li><li class="listitem">There should be three channels: <strong>Red</strong>, <strong>Green</strong>, and <strong>Blue</strong>. Create a new channel. This will be<a class="indexterm" id="id519"/> the <strong>Alpha</strong> channel.</li><li class="listitem">In the <strong>Channels</strong> <a class="indexterm" id="id520"/>window, select the <strong>Alpha 1</strong> channel and paste your image into it.<div><img alt="How to do it..." src="img/1362_06_02.jpg"/></div></li><li class="listitem">Save your image file as <code class="literal">cloudCookie.PSD</code> or <code class="literal">TGA</code>.</li><li class="listitem">Import <a class="indexterm" id="id521"/>your image file to Unity and select it in the <strong>Project</strong> view.</li><li class="listitem">From the <strong>Inspector</strong> view, change its <strong>Texture Type</strong> to <strong>Cookie</strong> and its <strong>Light Type</strong> to <strong>Directional</strong>. Then, click on <strong>Apply</strong>, as shown:<div><img alt="How to do it..." src="img/1362_06_03.jpg"/></div></li><li class="listitem">We will need a surface to actually see the lighting effect. You can either add a plane to your<a class="indexterm" id="id522"/> scene (via navigating to the <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Plane</strong> menu), or create a <strong>Terrain</strong> (menu option <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Terrain</strong>) and edit it, if you so you wish.</li><li class="listitem">Let's add a light to our scene. Since we want to simulate sunlight, the best option is to <a class="indexterm" id="id523"/>create a <strong>Directional Light</strong>. You can do this through the drop-down menu named <strong>Create</strong> | <strong>Light</strong> | <strong>Directional Light</strong> in the <strong>Hierarchy</strong> view.</li><li class="listitem">Using the <strong>Transform</strong> <a class="indexterm" id="id524"/>component of the <strong>Inspector</strong> view, reset the light's <strong>Position</strong> to <strong>X</strong>: <code class="literal">0</code>, <strong>Y</strong>: <code class="literal">0</code>, <strong>Z</strong>: <code class="literal">0</code> and its <strong>Rotation</strong> to <strong>X</strong>: <code class="literal">90</code>; <strong>Y</strong>: <code class="literal">0</code>; <strong>Z</strong>: <code class="literal">0</code>.</li><li class="listitem">In the <strong>Cookie</strong> field, select the <strong>cloudCookie</strong> texture that you imported earlier. Change the <strong>Cookie Size</strong> field to <code class="literal">80</code>, or a value that you feel is more appropriate for the scene's dimension. Please leave <strong>Shadow Type</strong> as <strong>No Shadows</strong>.<div><img alt="How to do it..." src="img/1362_06_04.jpg"/></div></li><li class="listitem">Now, we need a script to translate our light and, consequently, the <strong>Cookie</strong> projection. Using the <strong>Create</strong> drop-down menu in the <strong>Project</strong> view, create a new C# Script<a class="indexterm" id="id525"/> named <code class="literal">MovingShadows.cs</code>.</li><li class="listitem">Open your script and<a class="indexterm" id="id526"/> replace everything <a class="indexterm" id="id527"/>with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class MovingShadows : MonoBehaviour{
  public float windSpeedX;
  public float windSpeedZ;
  private float lightCookieSize;
  private Vector3 initPos;

  void Start(){
    initPos = transform.position;
    lightCookieSize = GetComponent&lt;Light&gt;().cookieSize;
  }

  void Update(){
    Vector3 pos = transform.position;
    float xPos= Mathf.Abs (pos.x);
    float zPos= Mathf.Abs (pos.z);
    float xLimit = Mathf.Abs(initPos.x) + lightCookieSize;
    float zLimit = Mathf.Abs(initPos.z) + lightCookieSize;

    if (xPos &gt;= xLimit)
      pos.x = initPos.x;

    if (zPos &gt;= zLimit)
      pos.z = initPos.z;

    transform.position = pos;
    float windX = Time.deltaTime * windSpeedX;
    float windZ = Time.deltaTime * windSpeedZ;
    transform.Translate(windX, 0, windZ, Space.World);
  }
}</pre></div></li><li class="listitem">Save your <a class="indexterm" id="id528"/>script and apply it to the <strong>Directional Light</strong>.</li><li class="listitem">Select the <a class="indexterm" id="id529"/><strong>Directional Light</strong>. In the <strong>Inspector</strong> view, change the parameters <strong>Wind Speed X</strong> and <a class="indexterm" id="id530"/><strong>Wind Speed Z</strong> to <code class="literal">20</code> (you can change these values as you wish, as shown).<div><img alt="How to do it..." src="img/1362_06_05.jpg"/></div></li><li class="listitem">Play your scene. The shadows will be moving.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec173"/>How it works...</h2></div></div></div><p>With our script, we are telling the <strong>Directional Light</strong> to move across the <em>X</em> and <em>Z</em> axis, causing the <strong>Light Cookie</strong> texture to be displaced as well. Also, we reset the light object to its original position whenever it traveled a distance that was either equal to or greater than the <strong>Light Cookie Size</strong>. The light position must be reset to prevent it from traveling too far, causing problems in real-time render and lighting. The <strong>Light Cookie Size</strong> parameter is used to ensure a smooth transition.</p><p>The reason we are not enabling shadows is because the light angle for the <em>X</em> axis must be 90 degrees (or there will be a noticeable gap when the light resets to the original position). If you want dynamic shadows in your scene, please add a second <strong>Directional Light</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec174"/>There's more...</h2></div></div></div><p>In this recipe, <a class="indexterm" id="id531"/>we have applied a cookie texture<a class="indexterm" id="id532"/> to a <strong>Directional</strong><a class="indexterm" id="id533"/><strong> Light</strong>. But what if we were using the <strong>Spot</strong> or <strong>Point Lights</strong>?</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec51"/>Creating Spot Light cookies</h3></div></div></div><p>Unity<a class="indexterm" id="id534"/> documentation has an excellent tutorial on how to make the <strong>Spot Light</strong> cookies. This is great to simulate shadows coming from <a class="indexterm" id="id535"/>projectors, windows, and so on. You can<a class="indexterm" id="id536"/> check it out at <a class="ulink" href="http://docs.unity3d.com/Manual/HOWTO-LightCookie.html">http://docs.unity3d.com/Manual/HOWTO-LightCookie.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec52"/>Creating Point Light Cookies</h3></div></div></div><p>If you want to use<a class="indexterm" id="id537"/> a cookie texture with a <strong>Point Light</strong>, you'll need to change the <strong>Light Type</strong> in the <strong>Texture Importer</strong> section <a class="indexterm" id="id538"/>of the <strong>Inspector</strong>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Adding a custom Reflection map to a scene</h1></div></div></div><p>Whereas<a class="indexterm" id="id539"/> Unity <strong>Legacy Shaders</strong> use individual <strong>Reflection Cubemaps</strong> per material, the new <strong>Standard Shader</strong> gets its reflection from the scene's <strong>Reflection Source</strong>, as configured in the <strong>Scene</strong> section of the <strong>Lighting</strong> window. The level of reflectiveness for each material is now given by its <strong>Metallic</strong> value or <strong>Specular</strong> value (for materials using Specular setup). This new method can be a <em>real</em> time saver, allowing you to quickly assign the same reflection map to every object in the scene. Also, as you can imagine, it helps keep the overall look of the scene coherent and cohesive. In this recipe, we will learn how to take advantage of the <strong>Reflection Source</strong> feature.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec175"/>Getting ready</h2></div></div></div><p>For this recipe, we will prepare a <strong>Reflection Cubemap</strong>, which is basically the environment to be projected as a reflection onto the material. It can be made from either six or, as shown in this recipe, a single image file.</p><p>To help us with this recipe, it's been provided a Unity package, containing a prefab made of a 3D object and a basic Material (using a TIFF as Diffuse map), and also a JPG file to be used as the reflection map. All these files are inside the <code class="literal">1362_06_02</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec176"/>How to do it...</h2></div></div></div><p>To add Reflectiveness and Specularity to a material, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import <code class="literal">batteryPrefab.unitypackage</code> to a new project. Then, select <code class="literal">battery_prefab</code> object from the <strong>Assets</strong> folder, in the <strong>Project</strong> view.</li><li class="listitem">From the <strong>Inspector</strong> view, expand the <strong>Material</strong> component and observe the asset preview window. Thanks to the <strong>Specular</strong> map, the material already features a reflective look. However, it looks as if it is reflecting the scene's default <strong>Skybox</strong>, as shown:<div><img alt="How to do it..." src="img/1362_06_06.jpg"/></div></li><li class="listitem">Import the<a class="indexterm" id="id540"/> <code class="literal">CustomReflection.jpg</code> image file. From the <strong>Inspector</strong> view, change its <strong>Texture Type</strong> to <strong>Cubemap</strong>, its <strong>Mapping</strong> to <strong>Latitude - Longitude Layout (Cylindrical)</strong>, and check the boxes for <strong>Glossy Reflection</strong> and <strong>Fixup Edge Seams</strong>. Finally, change its <strong>Filter Mode</strong> to <strong>Trilinear</strong> and click on the <strong>Apply</strong> button, shown as follows:<div><img alt="How to do it..." src="img/1362_06_07.jpg"/></div></li><li class="listitem">Let's replace the Scene's Skybox with our newly created <strong>Cubemap</strong>, as the <strong>Reflection</strong><a class="indexterm" id="id541"/><strong> map</strong> for our scene. In order to do this, open the <strong>Lighting</strong> window by navigating to the <strong>Window</strong> | <strong>Lighting</strong> menu. Select the <strong>Scene</strong> section and use the drop-down menu to change the <strong>Reflection Source</strong> to <strong>Custom.</strong> Finally, assign the newly created <code class="literal">CustomReflection</code> texture as the <strong>Cubemap</strong>, shown as follows:<div><img alt="How to do it..." src="img/1362_06_08.jpg"/></div></li><li class="listitem">Check out<a class="indexterm" id="id542"/> for the new reflections on the <code class="literal">battery_prefab</code> object.<div><img alt="How to do it..." src="img/1362_06_09.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec177"/>How it works...</h2></div></div></div><p>While it is the material's specular map that allows for a reflective look, including the intensity and smoothness of the reflection, the refection itself (that is, the image you see on the reflection) is given by the <a class="indexterm" id="id543"/><strong>Cubemap</strong> that we have created from the image file.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec178"/>There's more...</h2></div></div></div><p>Reflection Cubemaps can be achieved in many ways and have different mapping properties.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec53"/>Mapping coordinates</h3></div></div></div><p>The <strong>Cylindrical</strong> mapping that we applied was well-suited for the photograph that we used. However, depending<a class="indexterm" id="id544"/> on how the reflection image is generated, a <strong>Cubic</strong> or <strong>Spheremap</strong>-based mapping can be more appropriate. Also, note that the <strong>Fixup Edge Seams</strong> option will try to make the image seamless.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec54"/>Sharp reflections</h3></div></div></div><p>You might have noticed<a class="indexterm" id="id545"/> that the reflection is somewhat blurry compared to the original image; this is because we have ticked the <strong>Glossy Reflections</strong> box. To get a sharper-looking reflection, deselect this option; in which case, you can also leave the <strong>Filter Mode</strong> option as default (Bilinear).</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec55"/>Maximum size</h3></div></div></div><p>At 512 x 512 pixels, our reflection map will probably run fine on the lower-end machines. However, if the<a class="indexterm" id="id546"/> quality of the reflection map is not so important in your game's context, and the original image dimensions are big (say, 4096 x 4096), you might want to change the texture's <strong>Max Size</strong> at the <strong>Import Settings</strong> to a lower number.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Creating a laser aim with Projector and Line Renderer</h1></div></div></div><p>Although using <a class="indexterm" id="id547"/>GUI elements, such as a cross-hair, is a valid way to allow players to aim, replacing (or combining) it with a projected laser dot might be a <a class="indexterm" id="id548"/>more interesting approach. In<a class="indexterm" id="id549"/> this recipe, we will use the <strong>Projector</strong><a class="indexterm" id="id550"/> and <strong>Line</strong> components to implement this concept.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec179"/>Getting ready</h2></div></div></div><p>To help us with this recipe, it's been provided with a Unity package containing a sample scene featuring a character holding a laser pointer, and also a texture map named <code class="literal">LineTexture</code>. All files are inside the <code class="literal">1362_06_03</code> folder. Also, we'll make use of the <strong>Effects</strong> assets package provided by Unity (which you should have installed when installing Unity).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec180"/>How to do it...</h2></div></div></div><p>To create a laser dot aim with a Projector, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import <code class="literal">BasicScene.unitypackage</code> to a new project. Then, open the scene named <strong>BasicScene</strong>. This is a basic scene, featuring a player character whose aim is controlled via <a class="indexterm" id="id551"/>mouse.</li><li class="listitem">Import the <strong>Effects</strong> package by navigating to the <strong>Assets</strong> | <strong>Import Package</strong> | <strong>Effects</strong> menu. If you want to import only the necessary files within the package, deselect <a class="indexterm" id="id552"/>everything in the <strong>Importing</strong><a class="indexterm" id="id553"/><strong> package</strong> window by clicking<a class="indexterm" id="id554"/> on the <strong>None</strong> button, and then check the <strong>Projectors</strong> folder only. Then, click on <strong>Import</strong>, as shown:<div><img alt="How to do it..." src="img/1362_06_10.jpg"/></div></li><li class="listitem">From the <strong>Inspector</strong> view, locate the <code class="literal">ProjectorLight</code> shader (inside the <strong>Assets</strong> | <strong>Standard Assets</strong> | <strong>Effects</strong> | <strong>Projectors</strong> | <strong>Shaders</strong> folder). Duplicate the file and name the new copy as <code class="literal">ProjectorLaser</code>.</li><li class="listitem">Open <code class="literal">ProjectorLaser</code>. From the first line of the code, change <code class="literal">Shader "Projector/Light"</code> to <code class="literal">Shader "Projector/Laser"</code>. Then, locate the line of code – <code class="literal">Blend DstColor One</code> and change it to <code class="literal">Blend One One</code>. Save and close the file.<div><div><h3 class="title"><a id="note35"/>Note</h3><p>The reason for editing the shader for the laser was to make it stronger by changing its blend type to <strong>Additive</strong>. Shader programming is a complex subject, which is beyond the scope of this book. However, if you want to learn more about it, check <a class="indexterm" id="id555"/>out Unity's documentation on the subject, which is available at <a class="ulink" href="http://docs.unity3d.com/Manual/SL-Reference.html">http://docs.unity3d.com/Manual/SL-Reference.html</a>, and also the book called <em>Unity Shaders and Effects Cookbook</em>, published by Packt.</p></div></div></li><li class="listitem">Now that we <a class="indexterm" id="id556"/>have fixed the shader, we need a material. From the <strong>Project</strong> view, use the <strong>Create</strong> drop-down menu to create a new <strong>Material</strong>. Name it <code class="literal">LaserMaterial</code>. Then, select it from the <strong>Project</strong> view and, from the <strong>Inspector</strong> view, change<a class="indexterm" id="id557"/> its <strong>Shader</strong> to <strong>Projector/Laser</strong>.</li><li class="listitem">From the <strong>Project</strong><a class="indexterm" id="id558"/> view, locate the <strong>Falloff</strong> texture. Open it in your image editor and, except for the first and last columns column of pixels<a class="indexterm" id="id559"/> that should be black, paint everything white. Save the file and go back to Unity.<div><img alt="How to do it..." src="img/1362_06_55.jpg"/></div></li><li class="listitem">Change the <strong>LaserMaterial</strong>'s <strong>Main Color</strong> to red (RGB: <code class="literal">255</code>, <code class="literal">0</code>, <code class="literal">0</code>). Then, from the texture slots, select the <strong>Light</strong> texture as <strong>Cookie</strong> and the <strong>Falloff</strong> texture as <strong>Falloff</strong>.<div><img alt="How to do it..." src="img/1362_06_11.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, find <a class="indexterm" id="id560"/>and select the <strong>pointerPrefab</strong> object (<strong>MsLaser</strong> | <strong>mixamorig:Hips</strong> | <strong>mixamorig:Spine</strong> | <strong>mixamorig:Spine1</strong> | <strong>mixamorig:Spine2</strong> | <strong>mixamorig:RightShoulder</strong> | <strong>mixamorig:RightArm</strong> | <strong>mixamorig:RightForeArm</strong> | <strong>mixamorig:RightHand</strong> | <strong>pointerPrefab</strong>). Then, from the <a class="indexterm" id="id561"/><strong>Create</strong> drop-down menu, select <strong>Create Empty Child</strong>. Rename the new child of <strong>pointerPrefab</strong> as <strong>LaserProjector</strong>.</li><li class="listitem">Select the <strong>LaserProjector</strong> object. Then, from the <strong>Inspector</strong> view, click the <strong>Add Component</strong><a class="indexterm" id="id562"/> button and navigate to <strong>Effects</strong> | <strong>Projector</strong>. Then, from the <strong>Projector</strong> component, set the <strong>Orthographic</strong><a class="indexterm" id="id563"/> option as true and set <strong>Orthographic Size</strong> as <code class="literal">0.1</code>. Finally, select <strong>LaserMaterial</strong> from the <strong>Material</strong> slot.</li><li class="listitem">Test the scene. You will be able to see the laser aim dot, as shown:<div><img alt="How to do it..." src="img/1362_06_12.jpg"/></div></li><li class="listitem">Now, let's create a material for the <strong>Line Renderer</strong> component that we are about to add. From<a class="indexterm" id="id564"/> the <strong>Project</strong> view, use the <strong>Create</strong> drop-down menu to add a new <strong>Material</strong>. Name<a class="indexterm" id="id565"/> it as <strong>Line_Mat</strong>.</li><li class="listitem">From the <strong>Inspector</strong> view, change<a class="indexterm" id="id566"/> the shader of the <strong>Line_Mat</strong> to <strong>Particles/Additive</strong>. Then, set its <strong>Tint Color</strong> to red (RGB: <code class="literal">255</code>;<code class="literal">0</code>;<code class="literal">0</code>).</li><li class="listitem">Import the<a class="indexterm" id="id567"/> <code class="literal">LineTexture</code> image file. Then, set it as the <strong>Particle Texture</strong> for the <strong>Line_Mat</strong>, as shown:<div><img alt="How to do it..." src="img/1362_06_13.jpg"/></div></li><li class="listitem">Use the <strong>Create</strong> drop-down menu from <strong>Project</strong> view to add a C# script named <code class="literal">LaserAim</code>. Then, open it in your editor.</li><li class="listitem">Replace everything with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;
public class LaserAim : MonoBehaviour {

  public float lineWidth = 0.2f;
  public Color regularColor = new Color (0.15f, 0, 0, 1);
  public Color firingColor = new Color (0.31f, 0, 0, 1);
  public Material lineMat;
  private Vector3 lineEnd;
  private Projector proj;
  private LineRenderer line;

  void Start () {
    line = gameObject.AddComponent&lt;LineRenderer&gt;();
    line.material = lineMat;
    line.material.SetColor("_TintColor", regularColor);
    line.SetVertexCount(2);
    line.SetWidth(lineWidth, lineWidth);
    proj = GetComponent&lt;Projector&gt; ();
  }

  void Update () {
    RaycastHit hit;
    Vector3 fwd = transform.TransformDirection(Vector3.forward);

    if (Physics.Raycast (transform.position, fwd, out hit)) {
      lineEnd =  hit.point;
      float margin = 0.5f;
      proj.farClipPlane = hit.distance + margin;

    } else {
      lineEnd = transform.position + fwd * 10f;
    }
    line.SetPosition(0, transform.position);
    line.SetPosition(1, lineEnd);

    if(Input.GetButton("Fire1")){
      float lerpSpeed = Mathf.Sin (Time.time * 10f);
      lerpSpeed = Mathf.Abs(lerpSpeed);
      Color lerpColor = Color.Lerp(regularColor, firingColor, lerpSpeed);
      line.material.SetColor("_TintColor", lerpColor);

    }
    if(Input.GetButtonUp("Fire1")){
      line.material.SetColor("_TintColor", regularColor);
    }
  }
}</pre></div></li><li class="listitem">Save your script <a class="indexterm" id="id568"/>and attach it to the <strong>LaserProjector </strong><a class="indexterm" id="id569"/>game object.</li><li class="listitem">Select the <strong>LaserProjector</strong> GameObject. From the <strong>Inspector</strong> view, find the <strong>Laser Aim</strong> <a class="indexterm" id="id570"/>component and fill the <strong>Line Material</strong><a class="indexterm" id="id571"/> slot with the <code class="literal">Line_Mat</code> material, as shown:<div><img alt="How to do it..." src="img/1362_06_14.jpg"/></div></li><li class="listitem">Play the scene. The laser aim is ready, and looks as shown:<div><img alt="How to do it..." src="img/1362_06_15.jpg"/></div><div><div><h3 class="title"><a id="note36"/>Note</h3><p>In this recipe, the width of the laser beam and its aim dot have been exaggerated. Should you need a more realistic thickness for your beam, change the <strong>Line Width</strong> field of the <strong>Laser Aim</strong> component to <code class="literal">0.05</code>, and the <strong>Orthographic Size</strong> of the <strong>Projector</strong> component to <code class="literal">0.025</code>. Also, remember to make the beam more opaque by setting the <strong>Regular Color</strong> of the <strong>Laser Aim</strong><a class="indexterm" id="id572"/> component brighter.</p></div></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec181"/>How it works...</h2></div></div></div><p>The laser aim effect was<a class="indexterm" id="id573"/> achieved by combining two different effects: a <strong>Projector</strong> and <strong>Line Renderer</strong>.</p><p>A <strong>Projector</strong>, which <a class="indexterm" id="id574"/>can be used to simulate light, shadows, and more, is a component that projects a material (and its texture) onto other game objects. By attaching a projector to the <strong>Laser Pointer</strong> object, we have ensured that it will face the right direction at all times. To get the right, vibrant look, we have edited the projector material's <strong>Shader</strong>, making it brighter. Also, we have scripted a way to prevent projections from going through objects, by<a class="indexterm" id="id575"/> setting its <strong>Far Clip Plane</strong> on approximately the same level of the first object that is receiving the projection. The line of code that is responsible for this action is—<code class="literal">proj.farClipPlane = hit.distance + margin;</code>.</p><p>Regarding the <strong>Line Renderer</strong>, we have opted to create it dynamically, via code, instead of manually adding the component to the game object. The code is also responsible for setting up its appearance, updating the line vertices position, and changing its color whenever the fire button is<a class="indexterm" id="id576"/> pressed, giving it a glowing/pulsing look.</p><p>For more details on how<a class="indexterm" id="id577"/> the script works, don't forget to<a class="indexterm" id="id578"/> check out the commented code, available <a class="indexterm" id="id579"/>within the <code class="literal">1362_06_03</code> | <code class="literal">End</code> folder.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Reflecting surrounding objects with Reflection Probes</h1></div></div></div><p>If you want your scene's environment to be reflected by game objects, featuring reflective materials (such as the ones with high Metallic or Specular levels), then you can achieve such effect using <strong>Reflection Probes</strong>. They allow for real-time, baked, or even custom reflections through the use of Cubemaps.</p><p>Real-time reflections<a class="indexterm" id="id580"/> can be expensive in terms of processing; in which case, you should favor baked reflections, unless it's really necessary to<a class="indexterm" id="id581"/> display dynamic objects being reflected (mirror-like objects, for instance). Still, there are some ways real-time reflections can be optimized. In this recipe, we will test three different configurations for reflection probes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Real-time reflections (constantly updated)</li><li class="listitem" style="list-style-type: disc">Real-time reflections (updated on-demand) via script</li><li class="listitem" style="list-style-type: disc">Baked reflections (from the Editor)</li></ul></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec182"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a basic scene, featuring three sets of reflective objects: one is constantly moving, one is static, and one moves whenever it is interacted with. The <code class="literal">Probes.unitypackage</code> package that is containing the scene can be found inside the <code class="literal">1362_06_04</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec183"/>How to do it...</h2></div></div></div><p>To reflect the surrounding objects using the Reflection probes, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import <code class="literal">Probes.unitypackage</code> to a new project. Then, open the scene named <strong>Probes</strong>. This is a basic scene featuring three sets of reflective objects.</li><li class="listitem">Play the scene. Observe that one of the systems is dynamic, one is static, and one rotates randomly, whenever a key is pressed.</li><li class="listitem">Stop the scene.</li><li class="listitem">First, let's create a constantly updated real-time reflection probe. From the <strong>Create</strong> drop-down button of the <strong>Hierarchy</strong> view, add a <strong>Reflection Probe</strong> to the scene (<strong>Create</strong> | <strong>Light</strong> | <strong>Reflection Probe</strong>). Name it as <code class="literal">RealtimeProbe</code> and make it a child of the <strong>System 1 Realtime</strong> | <strong>MainSphere</strong> game object. Then, from the<a class="indexterm" id="id582"/> <strong>Inspector</strong><a class="indexterm" id="id583"/> view, the <strong>Transform</strong> component, change its <strong>Position</strong> to <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">0</code>; <strong>Z</strong>: <code class="literal">0</code>, as shown:<div><img alt="How to do it..." src="img/1362_06_16.jpg"/></div></li><li class="listitem">Now, go to the <strong>Reflection Probe</strong> component. Set <strong>Type</strong> as <strong>Realtime</strong>; <strong>Refresh Mode</strong> as <strong>Every Frame</strong> and <strong>Time Slicing</strong> as <strong>No time slicing</strong>, shown as follows:<div><img alt="How to do it..." src="img/1362_06_17.jpg"/></div></li><li class="listitem">Play the scene. The reflections will be now be updated in real time. Stop the scene.</li><li class="listitem">Observe that the only object displaying the real-time reflections is <strong>System 1 Realtime</strong> | <strong>MainSphere</strong>. The reason for this is the <strong>Size</strong> of the Reflection Probe. From the <strong>Reflection Probe</strong> component, change its <strong>Size</strong> to <strong>X</strong>: <code class="literal">25</code>; <strong>Y</strong>: <code class="literal">10</code>; <strong>Z</strong>: <code class="literal">25</code>. Note that the small red spheres are now affected as well. However, it is important to notice that all objects display the same reflection. Since our reflection probe's origin is placed at the same location as the <strong>MainSphere</strong>, all reflective objects<a class="indexterm" id="id584"/> will display reflections from that point of view.<div><img alt="How to do it..." src="img/1362_06_18.jpg"/></div></li><li class="listitem">If you want to<a class="indexterm" id="id585"/> eliminate the reflection from the reflective objects within the reflection probe, such as the small red spheres, select the objects and, from the <strong>Mesh Renderer</strong> component, set <strong>Reflection Probes</strong> as <strong>Off</strong>, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362_06_19.jpg"/></div></li><li class="listitem">Add a new <strong>Reflection Probe</strong> to the scene. This time, name it <code class="literal">OnDemandProbe</code> and make it a child of the <strong>System 2 On Demand</strong> | <strong>MainSphere</strong> game object. Then, from the <strong>Inspector</strong> view, <strong>Transform</strong> component, change its <strong>Position</strong> to <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">0</code>; <strong>Z</strong>: <code class="literal">0</code>.</li><li class="listitem">Now, go to the <a class="indexterm" id="id586"/><strong>Reflection Probe</strong> component. Set <strong>Type</strong> as <strong>Realtime</strong>, <strong>Refresh Mode</strong> as <a class="indexterm" id="id587"/><strong>Via scripting</strong>, and <strong>Time Slicing</strong> as <strong>Individual faces</strong>, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362_06_20.jpg"/></div></li><li class="listitem">Using the <strong>Create</strong> drop-down menu in the <strong>Project</strong> view, create a new C# Script named <code class="literal">UpdateProbe</code>.</li><li class="listitem">Open your script and replace everything with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class UpdateProbe : MonoBehaviour {
  private ReflectionProbe probe;

  void Awake () {
    probe = GetComponent&lt;ReflectionProbe&gt; ();
    probe.RenderProbe();
  }

  public void RefreshProbe(){
    probe.RenderProbe();
  }
}</pre></div></li><li class="listitem">Save your script and attach it to the <strong>OnDemandProbe</strong>.</li><li class="listitem">Now, find the <a class="indexterm" id="id588"/>script named <code class="literal">RandomRotation</code>, which is attached to the <strong>System 2 On Demand</strong> | <strong>Spheres</strong> object, and open it in the code editor.</li><li class="listitem">Right before the <code class="literal">Update()</code> function, add the following lines:<div><pre class="programlisting">private GameObject probe;
private UpdateProbe up;
void Awake(){
  probe = GameObject.Find("OnDemandProbe");
  up = probe.GetComponent&lt;UpdateProbe&gt;();
}</pre></div></li><li class="listitem">Now, locate the line of code called <code class="literal">transform.eulerAngles = newRotation;</code> and, immediately after it, add the following line:<div><pre class="programlisting">up.RefreshProbe();</pre></div></li><li class="listitem">Save the script and test your scene. Observe how the <strong>Reflection Probe</strong> is updated whenever <a class="indexterm" id="id589"/>a key is pressed.</li><li class="listitem">Stop the scene. Add a third <strong>Reflection Probe</strong> to the scene. Name it as <code class="literal">CustomProbe</code> and make it a child of the <strong>System 3 On Custom</strong> | <strong>MainSphere</strong> game object. Then, from the <strong>Inspector</strong> view, the <strong>Transform</strong> component, change its <strong>Position</strong> to <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">0</code>; <strong>Z</strong>: <code class="literal">0</code>.</li><li class="listitem">Go to the <strong>Reflection Probe</strong> component. Set <strong>Type</strong> as <strong>Custom </strong>and click on the <strong>Bake</strong> button, as shown:<div><img alt="How to do it..." src="img/1362_06_21.jpg"/></div></li><li class="listitem">A <strong>Save File</strong> dialog <a class="indexterm" id="id590"/>window will show up. Save the file as <code class="literal">CustomProbe-reflectionHDR.exr</code>.</li><li class="listitem">Observe that the reflection<a class="indexterm" id="id591"/> map does not include the reflection of red spheres on it. To change this, you have two options: set the <strong>System 3 On Custom</strong> | <strong>Spheres</strong> GameObject (and all its children) as <strong>Reflection Probe Static</strong> or, from the <strong>Reflection Probe</strong> component of the <strong>CustomProbe</strong> GameObject, check the <strong>Dynamic Objects</strong> option, as shown, and bake the map again (by clicking on the <strong>Bake</strong> button).<div><img alt="How to do it..." src="img/1362_06_22.jpg"/></div></li><li class="listitem">If you want your<a class="indexterm" id="id592"/> reflection <strong>Cubemap</strong> to <a class="indexterm" id="id593"/>be dynamically baked while you edit your scene, you can set the <strong>Reflection Probe Type</strong> to <strong>Baked</strong>, open the <strong>Lighting</strong> window (the <strong>Assets</strong> | <strong>Lighting</strong> menu), access the <strong>Scene</strong> section, and check the <strong>Continuous Baking</strong> option as shown. Please note that this mode won't include dynamic objects in the reflection, so be sure to set <strong>System 3 Custom</strong> | <strong>Spheres</strong> and <strong>System 3 Custom</strong> | <strong>MainSphere</strong> as <strong>Reflection Probe Static</strong>.<div><img alt="How to do it..." src="img/1362_06_23.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec184"/>How it works...</h2></div></div></div><p>The <strong>Reflection Probes</strong> <a class="indexterm" id="id594"/>element act like omnidirectional cameras that render <strong>Cubemaps</strong> and apply them onto the objects within their <a class="indexterm" id="id595"/>constraints. When creating <strong>Reflection Probes</strong>, it's important to be aware of how the different types work:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Real-time Reflection Probes</strong>: Cubemaps are updated at runtime. The real-time Reflection<a class="indexterm" id="id596"/> Probes have three different <strong>Refresh Modes</strong>: <strong>On Awake</strong> (Cubemap is baked once, right before the scene starts); <strong>Every frame</strong> (Cubemap is constantly updated); <strong>Via scripting</strong> (Cubemap is updated whenever the <strong>RenderProbe</strong> function is used).<p>Since Cubemaps feature six sides, the <strong>Reflection Probes</strong> features <strong>Time Slicing</strong>, so each side can be updated independently. There are three different types of Time Slicing: <strong>All Faces at Once</strong> (renders all faces at once and calculates mipmaps over 6 frames. Updates the probe in 9 frames); <strong>Individual Faces</strong> (each face is rendered over a number of frames. It updates the probe in 14 frames. The results can be a bit inaccurate, but it is the least expensive solution in terms of frame-rate impact); <strong>No Time Slicing</strong> (The <strong>Probe</strong> is rendered and mipmaps are calculated in <a class="indexterm" id="id597"/>one frame. It provides high accuracy, but it also the most expensive in terms of frame-rate).</p></li><li class="listitem" style="list-style-type: disc"><strong>Baked:</strong> Cubemaps are<a class="indexterm" id="id598"/> baked during editing the screen. Cubemaps can be either manually or <a class="indexterm" id="id599"/>automatically updated, depending whether the <strong>Continuous Baking</strong> option is <a class="indexterm" id="id600"/>checked (it can be found at the <strong>Scene</strong> section of the <strong>Lighting</strong> window).</li><li class="listitem" style="list-style-type: disc"><strong>Custom:</strong> The<a class="indexterm" id="id601"/> Custom Reflection Probes can be either manually baked from the scene (and even include Dynamic objects), or created from a premade Cubemap.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec185"/>There's more...</h2></div></div></div><p>There are a number of additional settings that can be tweaked, such as <strong>Importance</strong>, <strong>Intensity</strong>, <strong>Box Projection</strong>, <strong>Resolution, HDR</strong>, and so on. For a complete view on each of these settings, we<a class="indexterm" id="id602"/> strongly recommend that you read Unity's documentation on the subject, which is available at <a class="ulink" href="http://docs.unity3d.com/Manual/class-ReflectionProbe.html">http://docs.unity3d.com/Manual/class-ReflectionProbe.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Setting up an environment with Procedural Skybox and Directional Light</h1></div></div></div><p>Besides the<a class="indexterm" id="id603"/> traditional 6 Sided and Cubemap, Unity now features a third type of skybox: the <strong>Procedural Skybox</strong>. Easy to create and setup, the <a class="indexterm" id="id604"/><strong>Procedural Skybox</strong> can be used in conjunction with a<a class="indexterm" id="id605"/> <strong>Directional Light</strong> to provide <strong>Environment Lighting</strong> to your scene. In this recipe, we will learn about different<a class="indexterm" id="id606"/> parameters of the <strong>Procedural Skybox</strong>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec186"/>Getting ready</h2></div></div></div><p>For this recipe, you will need to import Unity's Standard Assets Effects package, which you should have installed when installing Unity.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec187"/>How to do it...</h2></div></div></div><p>To set up an <a class="indexterm" id="id607"/><strong>Environment Lighting</strong> using the <strong>Procedural Skybox</strong> and <strong>Directional Light</strong>, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new<a class="indexterm" id="id608"/> scene inside a Unity project. Observe that a new scene already includes two objects: the <strong>Main Camera</strong> and a <strong>Directional Light</strong>.</li><li class="listitem">Add some <a class="indexterm" id="id609"/>cubes to your scene, including one at <strong>Position X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">0</code>; <strong>Z</strong>: <code class="literal">0</code> scaled to <strong>X</strong>: <code class="literal">20</code>; <strong>Y</strong>: <code class="literal">1</code>; <strong>Z</strong>: <code class="literal">20</code>, which is to be used as the ground, as shown:<div><img alt="How to do it..." src="img/1362_06_24.jpg"/></div></li><li class="listitem">Using the<a class="indexterm" id="id610"/> <strong>Create</strong> drop-down menu from the <strong>Project</strong> view, create a new Material and name it <code class="literal">MySkybox</code>. From the <strong>Inspector</strong> view, use the appropriate drop-down menu to change the <strong>Shader</strong> of <strong>MySkybox</strong> from <strong>Standard</strong> to <strong>Skybox/Procedural</strong>.</li><li class="listitem">Open the <strong>Lighting</strong> window (menu <strong>Window</strong> | <strong>Lighting</strong>), access the <strong>Scene</strong> section. At the <strong>Environment Lighting</strong> subsection, populate the <strong>Skybox</strong> slot with the <strong>MySkybox</strong> material, and the <strong>Sun</strong> slot with the <strong>Directional Light</strong> from the <strong>Scene</strong>.</li><li class="listitem">From the <a class="indexterm" id="id611"/><strong>Project</strong> view, select <strong>MySkybox</strong>. Then, from the <strong>Inspector</strong> view, set <strong>Sun size</strong> as <code class="literal">0.05</code> and <strong>Atmosphere Thickness</strong> as <code class="literal">1.4</code>. Experiment by changing the <strong>Sky Tint</strong> color to RGB: <code class="literal">148</code>; <code class="literal">128</code>; <code class="literal">128</code>, and the <strong>Ground</strong> color to a value that resembles the scene cube floor's color (such as RGB: <code class="literal">202</code>; <code class="literal">202</code>; <code class="literal">202</code>). If you<a class="indexterm" id="id612"/> feel the scene is too bright, try bringing the <strong>Exposure</strong> level down to <code class="literal">0.85</code>, shown as follows:<div><img alt="How to do it..." src="img/1362_06_25.jpg"/></div></li><li class="listitem">Select the<a class="indexterm" id="id613"/> <strong>Directional Light</strong> and change its <strong>Rotation</strong> to <strong>X</strong>: <code class="literal">5</code>; <strong>Y</strong>: <code class="literal">170</code>; <strong>Z</strong>: <code class="literal">0</code>. Note that the scene<a class="indexterm" id="id614"/> should resemble a dawning environment, something like the following scene:<div><img alt="How to do it..." src="img/1362_06_26.jpg"/></div></li><li class="listitem">Let's make things even more interesting. Using the <strong>Create</strong> drop-down menu in the <strong>Project</strong> view, create a new C# Script named <code class="literal">RotateLight</code>. Open your script and replace everything with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;
public class RotateLight : MonoBehaviour {
  public float speed = -1.0f;
  void Update () {
    transform.Rotate(Vector3.right * speed * Time.deltaTime);
  }
}</pre></div></li><li class="listitem">Save it <a class="indexterm" id="id615"/>and add it as<a class="indexterm" id="id616"/> a component to the <strong>Directional Light</strong>.</li><li class="listitem">Import the <strong>Effects</strong> Assets <a class="indexterm" id="id617"/>package into your project (via the <strong>Assets</strong> | <strong>Import Package</strong> | <strong>Effects </strong>menu).</li><li class="listitem">Select the <strong>Directional Light</strong>. Then, from <strong>Inspector</strong> view, <strong>Light</strong> component, populate the <strong>Flare</strong> slot with the <code class="literal">Sun</code> flare.</li><li class="listitem">From the <strong>Scene</strong> section<a class="indexterm" id="id618"/> of the <strong>Lighting</strong> window, find the <strong>Other Settings</strong> subsection. Then, set <strong>Flare Fade Speed</strong> as <code class="literal">3</code> and <strong>Flare Strength</strong> as <code class="literal">0.5</code>, shown as follows:<div><img alt="How to do it..." src="img/1362_06_27.jpg"/></div></li><li class="listitem">Play the scene. You <a class="indexterm" id="id619"/>will see the<a class="indexterm" id="id620"/> sun rising and the Skybox colors changing accordingly.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec188"/>How it works...</h2></div></div></div><p>Ultimately, the <a class="indexterm" id="id621"/>appearance of Unity's native Procedural Skyboxes depends on the five parameters that make them up:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Sun size</strong>: The size of<a class="indexterm" id="id622"/> the bright yellow sun that is drawn onto the skybox is located according to the <strong>Directional Light</strong>'s <strong>Rotation</strong> on the <em>X</em> and <em>Y</em> axes.</li><li class="listitem" style="list-style-type: disc"><strong>Atmosphere Thickness</strong>: This<a class="indexterm" id="id623"/> simulates how dense the atmosphere is for this skybox. Lower values (less than <code class="literal">1.0</code>) are good for simulating the outer space settings. Moderate values (around <code class="literal">1.0</code>) are suitable for the earth-based environments. Values that are slightly above <code class="literal">1.0</code> can be useful when simulating air pollution and other dramatic settings. Exaggerated values (like more than <code class="literal">2.0</code>) can help to illustrate extreme conditions or even alien settings.</li><li class="listitem" style="list-style-type: disc"><strong>Sky Tint</strong>: It is the color that is <a class="indexterm" id="id624"/>used to tint the skybox. It is useful for fine-tuning or creating stylized environments.</li><li class="listitem" style="list-style-type: disc"><strong>Ground</strong>: This is the color <a class="indexterm" id="id625"/>of the ground. It can really affect the <strong>Global Illumination</strong> of the scene. So, choose a value that is close to the level's terrain and/or geometry (or a neutral one).</li><li class="listitem" style="list-style-type: disc"><strong>Exposure</strong>: This <a class="indexterm" id="id626"/>determines the amount of light that gets in the skybox. The higher levels <a class="indexterm" id="id627"/>simulate overexposure, while the lower values simulate underexposure.</li></ul></div><p>It is important to notice that the <strong>Skybox</strong> appearance will respond to the scene's <strong>Directional Light</strong>, playing the role of the <strong>Sun</strong>. In this case, rotating the light around its <em>X</em> axis can create dawn and sunset scenarios, whereas rotating it around its <em>Y</em> axis will change the position of the sun, changing the cardinal points of the scene.</p><p>Also, regarding the <strong>Environment Lighting</strong>, note that although we have used the <strong>Skybox</strong> as the <strong>Ambient Source</strong>, we could have chosen a <strong>Gradient</strong> or a single <strong>Color</strong> instead—in which case, the scene's illumination wouldn't be attached to the Skybox appearance.</p><p>Finally, also regarding the <strong>Environment Lighting</strong>, please note that we have set the <strong>Ambient GI</strong> to <strong>Realtime</strong>. The reason for this was to allow the real-time changes in the GI, promoted by the rotating <strong>Directional Light</strong>. In case we didn't need these changes at runtime, we could have chosen the <strong>Baked</strong> alternative.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Lighting a simple scene with Lightmaps and Light Probes</h1></div></div></div><p>Lightmaps are a <a class="indexterm" id="id628"/>great alternative to real-time lighting, as they can provide the desired look to an environment without being processor-intensive. There is one <a class="indexterm" id="id629"/>downside, though—since there is no way of baking Lightmaps onto the dynamic objects, the lighting of the<a class="indexterm" id="id630"/> important elements of the game (such as player characters themselves) can look artificial, failing to match the intensity of the surrounding area. The solution? <strong>Light Probes</strong>.</p><p>
<strong>Light Probes</strong> work by<a class="indexterm" id="id631"/> sampling the light intensity over the location that they are placed at. Dynamic objects, once <strong>Light Probe</strong>-enabled, will be lit according to the interpolation of the nearest probes around them.</p><div><img alt="Lighting a simple scene with Lightmaps and Light Probes" src="img/1362_06_48.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec189"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a basic scene, including a simple game environment and an instance of Unity's Rollerball sample asset, which will be used as the player character. The geometry for the scene was<a class="indexterm" id="id632"/> created using <strong>ProBuilder 2.0</strong>, an extension developed by ProCore, and was sold at Unity's Asset Store and at ProCore's website (<a class="ulink" href="http://www.protoolsforunity3d.com">http://www.protoolsforunity3d.com</a>). ProBuilder is a fantastic level <a class="indexterm" id="id633"/>design tool that speeds up the design process considerably for both simple and complex level design.</p><p>The <code class="literal">LightProbes.unitypackage</code> package, containing the scene and all necessary files, can be found inside the <code class="literal">1362_06_06</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec190"/>How to do it...</h2></div></div></div><p>To reflect the surrounding<a class="indexterm" id="id634"/> objects using the <strong>Reflection </strong><a class="indexterm" id="id635"/><strong>Probes</strong>, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import <code class="literal">LightProbes.unitypackage</code> to a new project. Then, open the scene named <strong>LightProbes</strong>. The scene features a basic environment and a playable Rollerball game sequence.</li><li class="listitem">First, let's set up<a class="indexterm" id="id636"/> the light from our scene. From the <strong>Hierarchy</strong> view, select the <strong>Directional Light</strong>. Then, from<a class="indexterm" id="id637"/> the <strong>Inspector</strong> view, set <strong>Baking</strong> as <strong>Baked</strong>. Also, at the top of the <strong>Inspector</strong>, to the right of the object's name, check the <strong>Static</strong> box, shown as follows:<div><img alt="How to do it..." src="img/1362_06_28.jpg"/></div></li><li class="listitem">Now, let's set up the <strong>Global Illumination</strong> for the scene. Open the <strong>Lighting</strong> window (via the menu <strong>Window</strong> | <strong>Lighting</strong>) and select the <strong>Scene</strong> section. Then, from the <strong>Environment Lighting</strong> subsection, set <code class="literal">SkyboxProbes</code> (available from the <strong>Assets</strong>) as <strong>Skybox</strong>, and the scene's <strong>Directional Light</strong> as <strong>Sun</strong>. Finally, change the <strong>Ambient GI </strong>option from <strong>Realtime</strong> to <strong>Baked</strong>, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362_06_29.jpg"/></div></li><li class="listitem"><strong>Lightmaps</strong> can be <a class="indexterm" id="id638"/>applied onto static objects only. From the <strong>Hierarchy</strong> view, expand<a class="indexterm" id="id639"/> the <strong>Level</strong> game object to reveal the list of the children objects. Then, select every<a class="indexterm" id="id640"/> child and set them as <strong>Static</strong>, as shown:<div><img alt="How to do it..." src="img/1362_06_30.jpg"/></div></li><li class="listitem">Imported 3D <a class="indexterm" id="id641"/>meshes must feature <strong>Lightmap UV Coordinates</strong>. From the <strong>Project</strong> view, find and select the <code class="literal">lamp</code> mesh. Then, from the <strong>Inspector</strong> view, within the <strong>Model</strong> section of the <strong>Import Settings</strong>, check the <strong>Generate Lightmap UVs</strong> option, and click on the <strong>Apply</strong> button to confirm changes, shown as follows:<div><img alt="How to do it..." src="img/1362_06_31.jpg"/></div></li><li class="listitem">Scroll down<a class="indexterm" id="id642"/> the <strong>Import Settings</strong> view and expand the lamp's <strong>Material</strong> component. Then, populate the <strong>Emission</strong><a class="indexterm" id="id643"/> field with the texture named <code class="literal">lamp_EMI</code>, available<a class="indexterm" id="id644"/> from the <strong>Assets</strong> folder. Finally, change <strong>the Global Illumination</strong> option<a class="indexterm" id="id645"/> to <strong>Baked</strong>. This will make the lamp object emit a green light that will be baked into the <strong>Lightmap</strong>.<div><img alt="How to do it..." src="img/1362_06_32.jpg"/></div></li><li class="listitem">Open the <strong>Lighting</strong> window. By default, the <strong>Continuous Baking</strong> option will be checked. Uncheck it, as shown, so that we can bake the <strong>Lightmaps</strong> on demand.<div><img alt="How to do it..." src="img/1362_06_33.jpg"/></div></li><li class="listitem">Click on the<a class="indexterm" id="id646"/> <strong>Build</strong> button and wait for the Lightmaps to be generated.</li><li class="listitem">From the<a class="indexterm" id="id647"/> <strong>Hierarchy</strong> view, select the <strong>RollerBall</strong>. Then, from the <strong>Inspector</strong> view, find the <strong>Mesh Renderer</strong> component and <a class="indexterm" id="id648"/>check the<a class="indexterm" id="id649"/> <strong>Use Light Probes</strong> option, as shown:<div><img alt="How to do it..." src="img/1362_06_34.jpg"/></div></li><li class="listitem">Now, we need to create the <strong>Light Probes</strong> for the scene. From the <strong>Hierarchy</strong> view, click on the <strong>Create</strong> drop-down menu and add a <strong>Light Probe Group</strong> to the scene (<strong>Create</strong> | <strong>Light</strong> | <strong>Light Probe Group</strong>).</li><li class="listitem">To facilitate the manipulation of the probes, type <code class="literal">Probe</code> into the search field of the <strong>Hierarchy</strong> view. This will isolate the newly created <strong>Light Probe Group</strong>, making it<a class="indexterm" id="id650"/> the only editable object on the scene.<div><img alt="How to do it..." src="img/1362_06_35.jpg"/></div></li><li class="listitem">Change your <a class="indexterm" id="id651"/>viewport layout to <strong>4 Split</strong> by<a class="indexterm" id="id652"/> navigating to <strong>Window</strong> | <strong>Layouts</strong> | <strong>4 Split</strong>. Then, set viewports as <strong>Top</strong>, <strong>Front</strong>, <strong>Right</strong>, and <strong>Persp</strong>. Optionally, change <strong>Top</strong>, <strong>Front</strong> and <strong>Right</strong> views to the <strong>Wireframe</strong> mode. Finally, make sure that they are set to orthographic view, as<a class="indexterm" id="id653"/> shown in the following screenshot. This will make it easier for you to position the <strong>Light Probes</strong>.<div><img alt="How to do it..." src="img/1362_06_36.jpg"/></div></li><li class="listitem">Position<a class="indexterm" id="id654"/> the initial <strong>Light Probes</strong> at the corners<a class="indexterm" id="id655"/> of the top room of<a class="indexterm" id="id656"/> the level. To move<a class="indexterm" id="id657"/> the Probes around, simply click and drag them, as shown:<div><img alt="How to do it..." src="img/1362_06_37.jpg"/></div></li><li class="listitem">Select the four <a class="indexterm" id="id658"/>probes to the left side <a class="indexterm" id="id659"/>of the tunnel's entrance. Then, duplicate them by clicking on the appropriate button <a class="indexterm" id="id660"/>on the <strong>Inspector</strong> view or, alternatively, use the <em>Ctrl</em>/<em>Cmd</em> + <em>D</em> keys. Finally, drag the new <a class="indexterm" id="id661"/>probes slightly to the right, to a point that they are no longer over the shadow that is projected by the wall, shown as follows:<div><img alt="How to do it..." src="img/1362_06_38.jpg"/></div></li><li class="listitem">Repeat the<a class="indexterm" id="id662"/> last step, this time duplicating the probes<a class="indexterm" id="id663"/> next to the tunnel's entrance<a class="indexterm" id="id664"/> and bringing them inward towards the group. To delete the <a class="indexterm" id="id665"/>selected probes, either use the respective button on the <strong>Light Probe Group</strong> component, or use the <em>Ctrl</em>/<em>Cmd</em> + <em>Backspace</em> keys.<div><img alt="How to do it..." src="img/1362_06_39.jpg"/></div></li><li class="listitem">Duplicate and<a class="indexterm" id="id666"/> reposition the four probes that are nearest to the tunnel, repeating the<a class="indexterm" id="id667"/> operation five times and conforming each duplicate set to the shadow, projected<a class="indexterm" id="id668"/> by the tunnel.<div><img alt="How to do it..." src="img/1362_06_40.jpg"/></div></li><li class="listitem">Use the <strong>Add </strong><a class="indexterm" id="id669"/><strong>Probe</strong> button to place the three probes over well-lit areas of the scene.<div><img alt="How to do it..." src="img/1362_06_41.jpg"/></div></li><li class="listitem">Now, add<a class="indexterm" id="id670"/> <strong>Light Probes</strong> within<a class="indexterm" id="id671"/> the shadow that is projected<a class="indexterm" id="id672"/> by the<a class="indexterm" id="id673"/> L-shaped wall.<div><img alt="How to do it..." src="img/1362_06_42.jpg"/></div></li><li class="listitem">Since the Rollerball is able to jump, place the higher probes even higher, so that they will <a class="indexterm" id="id674"/>sample the lighting above the shadowed areas of the scene.<div><img alt="How to do it..." src="img/1362_06_45.jpg"/></div></li><li class="listitem">Placing too many <strong>Light Probes</strong> on a scene might be memory intensive. Try optimizing the <strong>Light Probes Group</strong> by removing the probes from the regions that the<a class="indexterm" id="id675"/> player won't have access to. Also, avoid overcrowding the regions of continuous lighting conditions by removing the probes that are too close to others in the same lighting condition.<div><img alt="How to do it..." src="img/1362_06_46.jpg"/></div></li><li class="listitem">To check<a class="indexterm" id="id676"/> out which Light Probes<a class="indexterm" id="id677"/> are influencing the <strong>Rollerball</strong> at any place, move the <strong>Rollerball</strong> GameObject <a class="indexterm" id="id678"/>around the scene. A polyhedron will indicate which probes are being interpolated <a class="indexterm" id="id679"/>at that position, as shown:<div><img alt="How to do it..." src="img/1362_06_47.jpg"/></div></li><li class="listitem">From the <a class="indexterm" id="id680"/>bottom of the <strong>Lighting</strong> window, click on the <strong>Build</strong> button and wait for the Lightmaps<a class="indexterm" id="id681"/> to be baked.<div><img alt="How to do it..." src="img/1362_06_43.jpg"/></div></li><li class="listitem">Test the <a class="indexterm" id="id682"/>scene. The Rollerball will be lit <a class="indexterm" id="id683"/>according to the Light Probes.<div><img alt="How to do it..." src="img/1362_06_44.jpg"/></div></li><li class="listitem">Keep adding probes until the level is completely covered.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec191"/>How it works...</h2></div></div></div><p>
<strong>Lighmaps</strong> are basically texture maps including scene lights/shadows, global illumination, indirect illumination, and objects featuring the <strong>Emissive</strong> materials. They can be generated automatically or on demand by Unity's lighting engine. However, there are some points<a class="indexterm" id="id684"/> that you should pay attention to, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set all the<a class="indexterm" id="id685"/> non-moving objects and lights to be baked as <strong>Static</strong></li><li class="listitem" style="list-style-type: disc">Set the game lights as <strong>Baked</strong></li><li class="listitem" style="list-style-type: disc">Set the<a class="indexterm" id="id686"/> scene's <strong>Ambient GI</strong> as <strong>Baked</strong></li><li class="listitem" style="list-style-type: disc">Set the <strong>Global Illumination</strong> option of the emissive materials as <strong>Baked</strong></li><li class="listitem" style="list-style-type: disc"><strong>Generate Light UV</strong>s for all 3D meshes (specially the imported ones)</li><li class="listitem" style="list-style-type: disc">Either <strong>Build</strong> the Lightmaps manually from the <strong>Lighting</strong> window, or set the <strong>Continuous Baking</strong> option checked</li></ul></div><p>
<strong>Light Probes</strong> work by sampling the scene's illumination at the point that they're placed at. A dynamic object that has <strong>Use Light Probes</strong> enabled has its lighting determined by the interpolation between the lighting values of the four Light Probes defining a volume around it (or, in case there are no probes suited to define a volume around the dynamic object, a triangulation between the nearest probes is used).</p><p>It is important to<a class="indexterm" id="id687"/> notice that even if you are working on a level that is flat, you shouldn't place all your probes on the same level, as <strong>Light Probe Groups</strong> will form a volume in order to the interpolation to be calculated correctly. This and more<a class="indexterm" id="id688"/> information on the subject can be found in the Unity's documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/LightProbes.html">http://docs.unity3d.com/Manual/LightProbes.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec192"/>There's more...</h2></div></div></div><p>In case you can spare some processing power, you can exchange the use of Light probes for a <strong>Mixed</strong> light. Just delete the <strong>Light Probe Group</strong> from your scene, select the <strong>Directional Light</strong> and, from the <strong>Light</strong> component, change <strong>Baking</strong> to <strong>Mixed</strong>. Then, set <strong>Shadow Type</strong> as <strong>Soft Shadows</strong> and <strong>Strength</strong> as <code class="literal">0.5</code>, as shown in the following screen. Finally, click on the <strong>Build</strong> button and wait for the Lightmaps to be baked. The real-time light/shadows will be cast into/from the dynamic objects, such as <strong>Rollerball</strong>.</p><div><img alt="There's more..." src="img/1362_06_49.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Conclusion</h1></div></div></div><p>This chapter aimed to present you with some of the Unity's new features in lighting, and occasionally teaches you a few tricks with lights and effects. By now, you should be familiar with some of the concepts introduced by Unity 5, comfortable with a variety of techniques, and, hopefully, willing to explore some of the functionalities discussed throughout the recipes deeper.</p><p>As always, Unity's documentation on the subject is excellent, so we encourage you to go back to the recipes and follow the provided URLs.</p></div></body></html>