<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-34"><a id="_idTextAnchor101"/>2</h1>
<h1 id="_idParaDest-35"><a id="_idTextAnchor102"/>Building Our First .NET MAUI App</h1>
<p>In this chapter, we will create a to-do list app and, in doing so, explore all the bits and pieces of what makes up an app. We will look at creating pages, adding content to pages, navigating between pages, and creating a stunning layout. Well, <em class="italic">stunning</em> might be a bit of a stretch, but we will be sure to design the app so that you can tweak it to your needs once it is complete!</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Setting up the project</li>
<li>Persisting data locally on a device using the repository pattern</li>
<li>What MVVM is and why it’s a great fit for .NET MAUI</li>
<li>Using .NET MAUI pages (as views) and navigating between them using .NET MAUI controls in XAML</li>
<li>Using data binding</li>
<li>Using styling in .NET MAUI</li>
</ul>
<h1 id="_idParaDest-36"><a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>Technical requirements</h1>
<p>To complete this project, you need to have Visual Studio installed on your <strong class="bold">Macintosh</strong> (<strong class="bold">Mac</strong>) or PC, as well as the .NET mobile components. Refer to <em class="italic">Chapter 1</em>, <em class="italic">Introduction to .NET MAUI</em>, for more details on how to set up your environment.<a id="_idTextAnchor105"/> This chapter provides screenshots and instructions for Visual Studio on Windows.</p>
<p>This chapter will be a classic <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong> chapter, guiding you step by step through the process of creating your first to-do list app. No downloads will be required whatsoever, apart from a few NuGet packages.</p>
<p>You can find the full source for the code in this chapter at <a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition">https://github.com/Packt
Publishing/MAUI-Projects-3rd-Edition</a> in the <code>Chapter02</code> folder.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor106"/>Project overview</h1>
<p>Everyone needs a<a id="_idIndexMarker176"/> way of keeping track of things. To kick-start our .NET MAUI development learning curve, we’ve decided that a to-do list app is the best way to get started and to help you keep track of things. A simple, classic win-win scenario.</p>
<p>We will start by creating a project and defining a repository to store the items of a to-do list. We will render these items in list form and allow the user to edit them using a detailed user interface. We will also look at how to store the to-do list items locally on a device<a id="_idIndexMarker177"/> through <strong class="bold">SQLite.NET</strong> so that they don’t get lost when we exit the app<a id="_idTextAnchor107"/>.</p>
<p>The build time for this project is about 2 hour<a id="_idTextAnchor108"/><a id="_idTextAnchor109"/>s.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor110"/>Setting up the project</h1>
<p>.NET MAUI introduces a <a id="_idIndexMarker178"/>new code-sharing paradigm called single project. Previously, in Xamarin.Forms, you would have had a separate project for each platform your app would be deployed to. In .NET MAUI, all platforms are in a single project that is multi-targeted to all the supported platforms. By default, all code is considered shared, unless it is in one of the platform-specific subfolders. We will explore this further as we progress through this and future chapters.</p>
<p>Let’s get starte<a id="_idTextAnchor111"/>d!</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor112"/>Creating the new project</h2>
<p>The first step is <a id="_idIndexMarker179"/>to create a new .NET MAUI project. Open Visual Studio 2022 and select <strong class="bold">Create a </strong><strong class="bold">new project</strong>:</p>
<div><div><img alt="Figure 2.1 – Visual Studio 2﻿022" src="img/Figure_2.1_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Visual Studio 2<a id="_idTextAnchor113"/>022</p>
<p>This will <a id="_idIndexMarker180"/>open the <code>maui</code> and select the <strong class="bold">.NET MAUI App</strong> item from the list:</p>
<div><div><img alt="Figure 2.2 – Create a new proje﻿ct" src="img/Figure_2.2_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Create a new proje<a id="_idTextAnchor114"/>ct</p>
<p>Complete the next <a id="_idIndexMarker181"/>page of the wizard by naming your project <code>DoToo</code>, then click <strong class="bold">Next</strong>:</p>
<div><div><img alt="Figure 2.3 – Configure your new proj﻿ect" src="img/Figure_2.3_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Configure your new proj<a id="_idTextAnchor115"/>ect</p>
<p>The next step will <a id="_idIndexMarker182"/>prompt you for the version of .NET Core to <a id="_idIndexMarker183"/>support. At the time of writing, .NET 6 is available as <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>), and .NET 7 is available as <strong class="bold">Standard Term Support</strong>. For this <a id="_idIndexMarker184"/>book, we will assume that you will be using .NET 7:</p>
<div><div><img alt="Figure 2.4 – Additional information" src="img/Figure_2.4_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Additional information</p>
<p>Finalize the setup by clicking <strong class="bold">Create</strong> and wait for Visual Studio to create the proj<a id="_idTextAnchor116"/>ect.</p>
<p>Congratulations! We’ve <a id="_idIndexMarker185"/>just created our first .NET MAUI app. Let’s take a look at what the template wizard generated fo<a id="_idTextAnchor117"/>r us.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor118"/>Examining the files</h2>
<p>The selected template<a id="_idIndexMarker186"/> has now created a single project called <code>DoToo</code> as<a id="_idIndexMarker187"/> a .NET library that can target iOS, Mac Catalyst (macOS), Android, and Windows platforms. You can switch the target platform using the main toolbar in Visual Studio, as shown in <em class="italic">Figure 2</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 2.5 – The Debug Target drop-down menu" src="img/Figure_2.5_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – The Debug Target drop-down menu</p>
<p>The Windows platform is selected by default, but you can easily switch to iOS or Android by using the <strong class="bold">Debug Target</strong> drop-down menu. In the dropdown under the <strong class="bold">Framework</strong> sub-menu, you will find all the supported target platforms.</p>
<p>The target framework <a id="_idIndexMarker188"/>will also change appropriately when you choose a target device. If you select an emulator under the <strong class="bold">Android Emulators</strong> menu item, then the Android target framework will become the current framework, whereas if you select an iOS simulator or device from one of the iOS menu items, iOS will be the current fra<a id="_idTextAnchor119"/>mework.</p>
<p>The project should now look as follows:</p>
<div><div><img alt="Figure 2.6 – .NET MAUI project str﻿ucture" src="img/Figure_2.6_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – .NET MAUI project str<a id="_idTextAnchor120"/>ucture</p>
<p>We will highlight a few important files in the project so that we have a<a id="_idTextAnchor121"/> basic understanding of<a id="_idIndexMarker189"/> what they are. First, we will look at the shared code, after which we’ll look at the files/code specific to each platform (stored under the different platform fo<a id="_idTextAnchor122"/>lders).</p>
<h3>Shared code</h3>
<p>Under <code>Dependencies</code>, we will find references to any external dependencies, such as each <a id="_idIndexMarker190"/>referenced .NET mobile framework. Under each framework, you <a id="_idIndexMarker191"/>will find the .NET MAUI dependency under the <code>packages</code> folder. We will update the .NET MAUI package version in the <em class="italic">Updating the .NET MAUI packages</em> section and add more dependencies as we progress through this chapter.</p>
<p>The <code>MauiProgram.cs</code> file is the starting point for the application. The initial template will generate a <code>MauiProgram</code> class that looks as follows:</p>
<pre class="source-code">
public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        builder
            .UseMauiApp&lt;App&gt;()
            .ConfigureFonts(fonts =&gt;
            {
                fonts.AddFont("OpenSans-Regular.ttf", 
"OpenSansRegular");
                fonts.AddFont("OpenSans-Semibold.ttf", 
"OpenSansSemibold");
            });
#if DEBUG
        builder.Logging.AddDebug();
#endif
        return builder.Build();
    }
}</pre> <p>The static <code>MauiProgram</code> class contains a single <code>CreateMauiApp</code> method that returns <code>MauiApp</code>. This instance is created by using <code>MauiAppBuilder</code>, which works in much the same way that the ASP.NET builders work; <code>MauiAppBuilder</code> uses a <code>Application</code> instance.</p>
<p class="callout-heading">What is a Fluent API?</p>
<p class="callout">A Fluent API allows<a id="_idIndexMarker193"/> method chaining wherein each method of the API returns the same context. Fluent APIs form a distinct language in themselves by using terms specific to the topic of the API. This makes the API easier to grasp and use. C#’s <strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>) is a<a id="_idIndexMarker194"/> good example of a Fluent API.</p>
<p>Extension methods are used to add features and services to the <code>MauiApp</code> instance. The <code>UseMauiApp</code> extension method identifies the subclass of <code>Microsoft.Maui.Controls.Application</code> to use. By default, this class is defined in the <code>App.xaml</code> and <code>App.xaml.cs</code> files. Another extension method, <code>ConfigureFonts</code>, is used by the template to register custom font files in use by the application. Yet another example of an extension method that can be used is <code>ConfigureLifecycleEvents</code>, which is used to set up handlers for the cross-platform life cycle <a id="_idIndexMarker195"/>events <a id="_idIndexMarker196"/>available in .NET MAUI. We will discuss <code>ConfigureLifecycleEvents</code> more in <em class="italic">Chapter 3</em>, <em class="italic">Converting a Xamarin.Forms App into .</em><em class="italic">NET MAUI</em>.</p>
<p>The <code>App.xaml</code> file is a XAML file that represents the app. This is a good place to put application-wide resources, which we will do later. We can also see the <code>App.xaml.cs</code> file, which contains the startup code.</p>
<p>If we open <code>App.xaml.cs</code>, we can see the starting point for our .NET MAUI application:</p>
<pre class="source-code">
public partial class App : Application
{
    public App()
    {
        InitializeComponent();
        MainPage = new AppShell();
    }
}</pre> <p>The <code>MainPage</code> property is assigned to a page, which is particularly important as this determines which page is shown first to the user. In this template, this is the <code>DoToo.AppShell()</code><strong class="bold"> </strong>class.</p>
<p>The <code>AppShell.xaml</code> and <code>AppShell.xaml.cs</code> files declare the first visible UI component in the .NET MAUI app. Shell provides a form of navigation between pages. When <a id="_idIndexMarker197"/>you <a id="_idIndexMarker198"/>open <code>AppShell.xaml</code>, it should look like this:</p>
<pre class="source-code">
&lt;Shell
    x:Class="DoToo.AppShell"
    xmlns=http://schemas.microsoft.com/dotnet/2021/maui
    xmlns:x=http://schemas.microsoft.com/winfx/2009/xaml
    
    Shell.FlyoutBehavior="Disabled"&gt;
    &lt;ShellContent
        Title="Home"
        ContentTemplate="{DataTemplate local:MainPage}"
        Route="MainPage" /&gt;
&lt;/Shell&gt;</pre> <p>The <code>ShellContent</code> element identifies an individual page that is displayed within the shell. The <code>ContentTemplate</code> attribute is used to locate the class that implements the page – in this case, <code>MainPage</code> – while <code>Route</code> is the unique identifier for the page.</p>
<p>The last two files are the <code>MainPage.xaml</code> file, which contains the first page of the application, and the code-behind file, which is called <code>MainPage.xaml.cs</code>.</p>
<p>Next, we will work through each platform’s files. Each platform has a unique folder under the <code>Platforms</code> folder. Android files are in the <code>Android</code> folder, iOS files are in the <code>iOS</code> folder, Mac Catalyst files are in the <code>MacCatalyst</code> folder, Tizen files are in the <code>Tizen</code> folder, and <a id="_idIndexMarker199"/>Windows <a id="_idIndexMarker200"/>files are in the <code>Windows</code> folder.</p>
<h3>Android</h3>
<p>The Android-specific<a id="_idIndexMarker201"/> platform code lives <a id="_idIndexMarker202"/>under the <code>Platforms/Android</code> folder in the project:</p>
<div><div><img alt="Figure 2.7 – Android-specific files" src="img/Figure_2.7_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Android-specific files</p>
<p>The important files here are <code>MainActivity.cs</code> and <code>MainApplication.cs</code>. These two files contain the entry point for our application when we run the app on an Android device. A standard Android app will declare <code>MainLauncher</code> property of the <code>Activity</code> class attribute. <code>MauiAppCompatActivity</code> will search for a type decorated with <code>ApplicationAttribute</code> and instantiate it.</p>
<p>This attribute can be found in the <code>MainApplication</code> class in <code>MainApplication.cs</code>. During initialization, <code>MainApplication</code> will call the <code>CreateMauiApp</code> method, which, in turn, calls <code>MauiProgram.CreateMauiApp</code>, which we explored earlier in this chapter.</p>
<p>You don’t need to understand these files in detail; just remember that they are important for i<a id="_idTextAnchor123"/>n<a id="_idTextAnchor124"/>itializing our app.</p>
<h3>iOS and Mac Catalyst</h3>
<p>The iOS and Mac<a id="_idIndexMarker203"/> Catalyst platform<a id="_idIndexMarker204"/> files are identical, but each has a folder for customizing the platform. Each platform’s files are contained in their respective named folder under the <code>Platform</code> folder:</p>
<div><div><img alt="Figure 2.8 – iOS platform-specific files" src="img/Figure_2.8_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – iOS platform-specific files</p>
<p><code>AppDelegate.cs</code> is the equivalent of the <code>MainApplication</code> class in the Android platform. It contains a single method called <code>CreateMauiApp</code> that has the same implementation as Android; it calls the <code>MauiProgram.CreateMauiApp</code> method.</p>
<p>The <code>Program.cs</code> file is the entry point for an iOS app. It contains the <code>Main</code> method, which calls <code>UIApplication.Main</code>, the launching point for an iOS application, and references the <code>AppDelegate<a id="_idTextAnchor125"/></code> type to instantiate.</p>
<p>The code starts by initializing .NET MAUI and then loads the application. After that, it returns control to iOS. It must do this within 17 seconds; otherwise, the app is terminated by the OS.</p>
<p>The <code>info.plist</code> file is an iOS-specific file that contains information about the app, such as the bundle ID and its provisioning profiles. Visual Studio has a graphical editor for the <code>info.plist</code> file, but since it is a standard XML file, it can be edited in any text editor.</p>
<p>As with the Android <a id="_idIndexMarker205"/>app’s startup code, we <a id="_idIndexMarker206"/>don’t need to under<a id="_idTextAnchor126"/>stand what is going on here in detail, other than that it’s important for<a id="_idTextAnchor127"/> initializing our app.</p>
<h3>Tizen</h3>
<p>Tizen is Samsung’s<a id="_idIndexMarker207"/> custom distribution of Android. The <code>Main.cs</code> file is the<a id="_idIndexMarker208"/> launching point and, like the Android platform, the <code>Program</code> class has a <code>CreateMauiApp</code> method. Tizen is not enabled by default. To enable it, follow the instructions in the comments in the <code>DoToo.csproj</code> file. To develop applications for Tizen, you will need to install additional software distributed by Samsung.</p>
<h3>Windows</h3>
<p>The last <a id="_idIndexMarker209"/>platform <a id="_idIndexMarker210"/>we will examine is the <strong class="bold">WinUI</strong> app. The file <a id="_idIndexMarker211"/>structure looks as follows:</p>
<div><div><img alt="Figure 2.9 – Windows-specific files" src="img/Figure_2.9_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Windows-specific files</p>
<p>It has an <code>App.xaml</code> file, which is like the one in the shared code, but specific to <code>App.xaml.cs</code>. This <a id="_idIndexMarker212"/>file is the Windows equivalent of Android’s <code>MauiApplication</code>, which contains the <code>CreateMauiApp</code> method.</p>
<p>That’s it for the<a id="_idIndexMarker213"/> platform project files. Next, we will look at how to keep .NET MAUI up to date.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor128"/>Updating the .NET MAUI packages</h2>
<p class="callout-heading">Note – Windows users</p>
<p class="callout">Since .NET MAUI is distributed as part of Visual Studio, it is best to allow Visual Studio to update the packages when you update Visual Studio. If you follow these steps, you can probably get .NET MAUI into an unusable state.</p>
<p>.NET MAUI is<a id="_idIndexMarker214"/> distributed as a set of optional <code>dotnet workload</code> command. To see the currently installed workloads and their versions, you can use the <code>dotnet workload list</code> command. Visual Studio 2022 has a built-in developer PowerShell to execute commands. To access it, press <em class="italic">Ctrl</em> + <em class="italic">`</em> on both macOS and Windows.</p>
<p>Running the <code>dotnet workload list</code> should give you the following output. Note that your version numbers may be higher:</p>
<pre class="console">
C:\Users\cummings.michael\Source\Repos\DoToo
&gt; dotnet workload list
Installed Workload Ids      Manifest Version                              Installation Source
---------------------------------------------------------------------------------------------
maui-windows                6.0.486/6.0.400                          
     VS 17.3.32901.215
maui-maccatalyst            6.0.486/6.0.400                          
     VS 17.3.32901.215
maccatalyst                 15.4.446-ci.-release-6-0-4xx.446/6.0.400
      VS 17.3.32901.215
maui-ios                    6.0.486/6.0.400                         
      VS 17.3.32901.215
ios                         15.4.446-ci.-release-6-0-4xx.446/6.0.400
      VS 17.3.32901.215
maui-android                6.0.486/6.0.400                         
      VS 17.3.32901.215
android                     32.0.448/6.0.400                        
      VS 17.3.32901.215
Use `dotnet workload search` to find additional workloads to install.</pre> <p>To update the <a id="_idIndexMarker216"/>packages in the MAUI workload, you can run <code>dotnet workload update</code>. This is a sample of the result from running that command:</p>
<pre class="console">
C:\Users\cummings.michael\Source\Repos\DoToo
&gt; dotnet workload update
No workloads installed for this feature band. To update workloads 
installed with earlier SDK
versions, include the --from-previous-sdk option.
Updated advertising manifest microsoft.net.sdk.android.
Updated advertising manifest microsoft.net.sdk.tvos.
Updated advertising manifest microsoft.net.sdk.macos.
Updated advertising manifest microsoft.net.sdk.maui.
Updated advertising manifest microsoft.net.workload.emscripten.
Updated advertising manifest microsoft.net.sdk.ios.
Updated advertising manifest microsoft.net.sdk.maccatalyst.
Updated advertising manifest microsoft.net.workload.mono.toolchain.
Downloading microsoft.net.sdk.android.manifest-6.0.400.msi.x64 
(32.0.465)
Installing Microsoft.NET.Sdk.Android.Manifest-6.0.400.32.0.465-x64.msi 
......... Done
Downloading microsoft.net.sdk.ios.manifest-6.0.400.msi.x64 (15.4.454)
Downloading microsoft.net.sdk.maccatalyst.manifest-6.0.400.msi.x64 
(15.4.454)
Downloading microsoft.net.sdk.macos.manifest-6.0.400.msi.x64 
(12.3.454)
Installing Microsoft.NET.Sdk.macOS.Manifest-6.0.400.12.3.454-x64.msi ...... Done
Downloading microsoft.net.sdk.maui.manifest-6.0.400.msi.x64 (6.0.540)
Installing Microsoft.NET.Sdk.Maui.Manifest-6.0.400.6.0.540-x64.msi 
...... Done
Downloading microsoft.net.sdk.tvos.manifest-6.0.400.msi.x64 (15.4.454)
Downloading microsoft.net.workload.mono.toolchain.manifest-6.0.400.
msi.x64 (6.0.9)
Installing Microsoft.NET.Workload.Mono.ToolChain.Manifest-
6.0.400.6.0.9-x64.msi ....... Done
Downloading microsoft.net.workload.emscripten.manifest-6.0.400.msi.x64 
(6.0.9)
Installing Microsoft.NET.Workload.Emscripten.Manifest-
6.0.400.6.0.9-x64.msi ...... Done
No workloads installed for this feature band. To update workloads 
installed 
with earlier SDK versions, include the --from-previous-sdk option.
Successfully updated workload(s): .</pre> <p>To see the<a id="_idIndexMarker217"/> result, just run the <code>dotnet workload list</code> command again:</p>
<pre class="console">
C:\Users\cummings.michael\Source\Repos\DoToo
&gt; dotnet workload list
Installed Workload Ids      Manifest Version
Installation Source
---------------------------------------------------------------------------------------------
maui-windows                6.0.540/6.0.400                            
   VS 17.3.32901.215
maui-maccatalyst            6.0.540/6.0.400                            
   VS 17.3.32901.215
maccatalyst                 15.4.446-ci.-release-6-0-4xx.446/6.0.400   
   VS 17.3.32901.215
maui-ios                    6.0.540/6.0.400                            
   VS 17.3.32901.215
ios                         15.4.446-ci.-release-6-0-4xx.446/6.0.400   
   VS 17.3.32901.215
maui-android                6.0.540/6.0.400                            
   VS 17.3.32901.215
android                     32.0.465/6.0.400                           
   VS 17.3.32901.215
Use `dotnet workload search` to find <a id="_idTextAnchor129"/><a id="_idTextAnchor130"/><a id="_idTextAnchor131"/>additional workloads to install.</pre> <p>Now that we<a id="_idIndexMarker218"/> have a basic understanding of how .NET MAUI projects are structured, we can start building our first app!</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor132"/>Creating a repository and a TodoItem model</h1>
<p>Any good architecture<a id="_idIndexMarker219"/> always <a id="_idIndexMarker220"/>involves abstraction. In this app, we need something to store and retrieve the items of our to-do list. Later, these will be stored in a SQLite database, but adding a reference to the database directly in the code that is responsible for the GUI is generally a bad idea as it tightly couples your data storage implementation to the UI layer, making it harder to test your UI code independently from the database.</p>
<p>So, what we need is something to abstract our database from the GUI. For this app, we’ve chosen to use a simple repository pattern. This repository is simply a class that sits between the SQLite database and our upcoming <code>ViewModel</code> class. This is the class that handles the interaction with the view, which, in turn, handles the GUI.</p>
<p>The repository will expose methods for getting, adding, and updating items, as well as events that allow other parts of the app to react to changes in the repository. It will be hidden behind an interface so that we can replace the entire implementation later without modifying anything but a line of code in the init<a id="_idTextAnchor133"/>ialization of the app. This is made possible by<a id="_idIndexMarker221"/> the <strong class="bold">Microsoft.Extension<a id="_idTextAnchor134"/>s.DependencyInjection</strong> NuGet package.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor135"/>Defining a to-do list item</h2>
<p>We will start by<a id="_idIndexMarker222"/> creating a <code>TodoItem</code> class, which represents a single item on the list. This is a<a id="_idIndexMarker223"/> simple <strong class="bold">Plain Old CLR Object</strong> (<strong class="bold">POCO</strong>) class, where <strong class="bold">CLR</strong> stands <a id="_idIndexMarker224"/>for <strong class="bold">Common Language Runtime</strong>. In other words, this is a .NET class without any dependencies on third-party assemblies. To create the class, follow these steps:</p>
<ol>
<li>In the <code>DoToo</code> project, create a folder called <code>Models</code>.</li>
<li>Add a class called <code>TodoItem.cs</code> to that folder and enter the following code:<pre class="source-code">
namespace DoToo.Models;
using System;
public class TodoItem
{
    public int Id { get; set; }
    public string Title { get; set; }<a id="_idTextAnchor136"/>
    public bool Completed { get; set; }
    public DateTime Due { get; set; }
}</pre></li> </ol>
<p>This code is self-explanatory; it’s a simple POCO class that only contains properties and no logic. We have a <code>Title</code> property that describes what we want to be done, a flag named <code>Completed</code> that determines whether the to-do list item is completed, a <code>Due</code> date for when we expect it<a id="_idIndexMarker225"/> to be done, and a unique <code>Id</code> property t<a id="_idTextAnchor137"/><a id="_idTextAnchor138"/>hat we will need later for the database.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor139"/>Creating a repository and its interface</h2>
<p>Now that<a id="_idIndexMarker226"/> we <a id="_idIndexMarker227"/>have the <code>TodoItem</code> class, let’s define an interface that describes a repository that will store our to-do list items:</p>
<ol>
<li>In the <code>DoToo</code> project, create a folder called <code>Repositories</code>.</li>
<li>Create an interface called <code>ITodoItemRepository.cs</code> in the <code>Repositories</code> folder <a id="_idIndexMarker228"/>and <a id="_idIndexMarker229"/>write the following code:<pre class="source-code">
namespace DoToo.Repositories;
using DoToo.Models;
public interface ITodoItemRepository
{
    event EventHandler&lt;TodoItem&gt; OnItemAdded;
    event EventHandler&lt;TodoItem&gt; OnItemUpdated;
    Task&lt;List&lt;TodoItem&gt;&gt; GetItemsAsync();
    Task AddItemAsync(TodoItem item);
    Task UpdateItemAsync(TodoItem item);
    Task AddOrUpdateAsync(TodoItem item);
}</pre></li> </ol>
<p class="callout-heading">Wait, what? No Delete method?</p>
<p class="callout">The eagle-eyed among you might have noticed that we are not defining a <code>Delete</code> method in this interface. This is something that should be in a real-world app. While the app that we are creating in this chapter does not support deleting items, we are quite sure tha<a id="_idTextAnchor140"/>t you could add this yourself if you want to!</p>
<p>This interface defines everything we need for our app. It is there to create logical insulation between your implementation of a repository and the user of that repository. If any other parts of your application want an instance of <code>ITodoItemRepository</code>, we can pass it an object that implements <code>ITodoItemRepository</code>, regardless of how it’s implemented.</p>
<p>With that said, let’s implement <code>ITodoItemRepository</code>:</p>
<ol>
<li>Create a class called <code>TodoItemRepository.cs</code> in the <code>Repositories</code> folder.</li>
<li>Enter the <a id="_idIndexMarker230"/>following <a id="_idIndexMarker231"/>code:<pre class="source-code">
namespace DoToo.Repositories;
using DoToo.Models;
public class TodoItemRepository : ITodoItemRepository
{
    public event EventHandler&lt;TodoItem&gt; OnItemAdded;
    public event EventHandler&lt;TodoItem&gt; OnItemUpdated;
    public async Task&lt;List&lt;TodoItem&gt;&gt; GetItemsAsync()
    {
        return null; // Just to make it build
    }
    public async Task AddItemAsync(TodoItem item)
    {
    }
    public async Task UpdateItemAsync(TodoItem item)
    {
    }
    public async Task AddOrUpdateAsync(TodoItem item)
    {
        if (item.Id == 0)
        {
            await AddItemAsync(item);
        }
        else
        {
            <a id="_idTextAnchor141"/>await UpdateItemAsync(item);
        }
    }
}</pre></li> </ol>
<p>This code is the bare-bones implementation of the interface, except for the <code>AddOrUpdateAsync(...)</code> method. This handles a small piece of logic that states that if the <code>Id</code> value of an item is <code>0</code>, it’s a new item. Any item with an <code>Id</code> value greater than <code>0</code> is stored in the database. This is because the database assigns a value larger than <code>0</code> when we create rows in a table.</p>
<p>There are also two <a id="_idIndexMarker232"/>events <a id="_idIndexMarker233"/>defined in<a id="_idTextAnchor142"/> the preceding code. They will be used to notify subscribers of <a id="_idTextAnchor143"/>a list of items that have been updated or added.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor144"/>Connecting SQLite to persist data</h2>
<p>We now have an<a id="_idIndexMarker234"/> interface, as well as a skeleton to <a id="_idIndexMarker235"/>implement that interface. The last thing we need to do to finish this section<a id="_idTextAnchor145"/> is to conne<a id="_idTextAnchor146"/>ct SQLite in the implementation of the repository.</p>
<h3>Adding the SQLite NuGet package</h3>
<p>To access SQLite in <a id="_idIndexMarker236"/>this project, we need to add a NuGet package called <code>sqlite-net-pcl</code> to the <code>DoToo</code> project. To do this, right-click on the <code>DoToo</code> project node of the solution and click <strong class="bold">Manage </strong><strong class="bold">NuGet Packages...</strong>:</p>
<div><div><img alt="Figure 2.10 – Manage NuGet Packages..." src="img/Figure_2.10_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Manage NuGet Packages...</p>
<p class="callout-heading">Portable Class Library (PCL)</p>
<p class="callout">You might <a id="_idIndexMarker237"/>have noticed that the NuGet package is suffixed with <code>-pcl</code>. This is an example of what happens when naming conventions go wrong. This package supports .NET Standard 1.0, even though the name says PCL, which was the predecessor of .NET Standard.</p>
<p>This brings up the <strong class="bold">NuGet Package </strong><strong class="bold">Manager</strong> window:</p>
<div><div><img alt="Figure 2.11 – NuGet Package Manager" src="img/Figure_2.11_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – NuGet Package Manager</p>
<p>To install the SQLite NuGet package, follow these steps:</p>
<ol>
<li>Click <code>sqlite-net-pcl</code> in the search box.</li>
<li>Select the package<a id="_idIndexMarker238"/> by <strong class="bold">sQLite-net</strong> and click <strong class="bold">Install</strong>.</li>
<li>A dialog will be displayed showing you all the packages that will be downloaded<a id="_idIndexMarker239"/> to your system; accept the changes to complete the installation.</li>
</ol>
<p class="callout-heading">Important</p>
<p class="callout">Version 1.8.116 of the <code>sqlite-net-pcl</code> package references versions of the native library that are not fully compatible with .NET 6+ on all platforms. To work around this, you need to add additional references to the following packages manually with a version of at least 2.1:</p>
<p class="callout">    - <code>SQLitePCLRaw.core</code></p>
<p class="callout">    - <code>SQLitePCLRaw.provider.sqlite3</code></p>
<p class="callout">    - <code>SQLitePCLRaw.bundle_green</code></p>
<p class="callout">    - <code>SQLitePCLRaw.provider.dynamic_cdecl</code></p>
<p class="callout">See <a href="https://github.com/praeclarum/sqlite-net/issues/1102">https://github.com/praeclarum/sqlite-net/issues/1102</a> for more details and a potential resolution.</p>
<p>Once the installation is complete, we can add some code to the <code>TodoItem</code> class to map the C# object <a id="_idIndexMarker240"/>to a table and cr<a id="_idTextAnchor147"/><a id="_idTextAnchor148"/><a id="_idTextAnchor149"/>eate the connection to the database in the repository.</p>
<h3>Updating the TodoItem class</h3>
<p>Since SQLite is <a id="_idIndexMarker241"/>a relational database, it needs to know some basic information about how to create the tables that will store our objects. This is done using attributes, which are defined in the SQLite namespace:</p>
<ol>
<li>Open <code>Models/TodoItem.cs</code>.</li>
<li>Add a <code>using SQLite</code> statement at the start of the file right below the <code>namespace</code> statement, as shown in the following code:<pre class="source-code">
namespace DoToo.Models;
<strong class="bold">using SQLite;</strong>
public class TodoItem</pre></li> <li>Add the <code>PrimaryKey</code> and <code>AutoIncrement</code> attributes right before the <code>Id</code> property, as shown in the following code:<pre class="source-code">
<strong class="bold">[PrimaryKey, AutoIncrement]</strong>
public int Id { get; set; }</pre><p class="list-inset">The <code>PrimaryKey</code> attribute instructs SQLite that the <code>Id</code> property is the primary key of the table. The <code>AutoIncrement</code> attribute makes sure that the value of <code>Id</code> is increased by 1 for each new <code>TodoItem</code> class that is added to the table.</p></li> </ol>
<p>With the data object classes properly configured, it<a id="_idTextAnchor150"/><a id="_idTextAnchor151"/> is now time to create the connection to the database.</p>
<h3>Creating a connection to the SQLite database</h3>
<p>We will now add<a id="_idIndexMarker242"/> all the code needed to communicate with the database. The first thing we need to do is define a connection field that will hold the connection to the database:</p>
<ol>
<li>Open the <code>Repositories/TodoItemRepository.cs</code> file.</li>
<li>Add a <code>using SQLite</code> statement right below the existing <code>using</code> statements, as shown in the following code:<pre class="source-code">
namespace DoToo.Repositories;
using DoToo.Models;
<strong class="bold">using SQLite;</strong>
public class TodoItemRepository : ITodoItemRepository</pre></li> <li>Add<a id="_idTextAnchor152"/> the following field right below the class declaration:<pre class="source-code">
private SQLiteAsyncConnection connection;</pre></li> </ol>
<p>The connection needs to be initialized. Once it is initialized, it can be reused throughout the lifespan of the repository. Since the method is asynchronous, it cannot be called from the constructor without introducing a locking strategy. To keep things simple, we will simply call it from each of the methods that are defined by the interface. To do so, add the following code to the <code>TodoItemRepository</code> class:</p>
<pre class="source-code">
private async Task CreateConnectionAsync() 
{ 
    if (connection != null) 
    { 
        return; 
    } 
 
    var documentPath = Environment.GetFolderPath(Environment.
SpecialFolder.MyDocuments); 
    var databasePath = Path.Combine(documentPath, "TodoItems.db"); 
 
    connection = new SQLiteAsyncConnection(databasePath);  
    await connection.CreateTableAsync&lt;TodoItem&gt;(); 
 
    if (await connection.Table&lt;TodoItem&gt;().CountAsync() == 0) 
    { 
        await connection.InsertAsync(new TodoItem() 
        { 
            Title = "Welcome to DoToo", 
            Due = DateTime.Now 
        }); 
    } 
}</pre> <p>The method begins<a id="_idIndexMarker243"/> by checking whether we already have a connection. If we do, we can simply <code>return</code>. If we don’t have a connection set up, we define a path on the disk to indicate where we want the database file to be located. In this case, we will choose the <code>MyDocuments</code> folder. .NET MAUI will find the closest match to this on each platform that we target.</p>
<p>Then, we create the connection and store the reference to that connection in the <code>connection</code> field. We need to make sure that SQLite has created a table that mirrors the schema of the <code>TodoItem</code> table. To make developing the app easier, we add a default to-do list item if the <code>TodoItem</code> table is empty.</p>
<p>Next, we<a id="_idTextAnchor153"/><a id="_idTextAnchor154"/><a id="_idTextAnchor155"/>’ll add the implementation for the database operations.</p>
<h3>Implementing the GetItemsAsync(), AddItemsAsync(), and UpdateItemsAsync() methods</h3>
<p>The only <a id="_idIndexMarker244"/>thing left<a id="_idIndexMarker245"/> to do<a id="_idIndexMarker246"/> in the repository is to implement the methods for getting, adding, and updating items:</p>
<ol>
<li>Locate the <code>GetItemsAsync()</code> method in the <code>TodoItemRepository</code> class.</li>
<li>Update the <code>GetItemsAsync()</code> method with the following code:<pre class="source-code">
public async Task&lt;List&lt;TodoItem&gt;&gt; GetItemsAsync()
{
    await CreateConnectionAsync();
    return await connection.Table&lt;TodoItem&gt;().ToListAsync();
}</pre><p class="list-inset">To ensure that the connection to the database is valid, we call the <code>CreateConnectionAsync()</code> method we created in the previous section. When this method returns, we can ensure that it is initialized and that the <code>TodoItem</code> table has been created.</p><p class="list-inset">Then, we use the connection to access the <code>TodoItem</code> table and return a <code>List&lt;TodoItem&gt;</code> item that contains all the to-do list items in the database.</p></li> </ol>
<p class="callout-heading">SQLite and LINQ</p>
<p class="callout">SQLite supports querying data<a id="_idIndexMarker247"/> using LINQ. You can play around with this after the project is complete to get a better understanding of how to work it with databases in your app.</p>
<p>The code for adding items is even simpler:</p>
<ol>
<li>Locate the <code>AddItemAsync()</code> method in the <code>TodoItemRepository</code> class.</li>
<li>Update the <code>AddItemAsync()</code> method with the following code:<pre class="source-code">
public async Task AddItemAsync(TodoItem item)
{
    await CreateConnectionAsync();
    await connection.InsertAsync(item);
    OnItemAdded?.Invoke(this, item);
}</pre><p class="list-inset">The call to <code>CreateConnectionAsync()</code> makes sure that we have a connection in the same way as we did for the <code>GetItemsAsync()</code> method. After this, we insert it into the database using the <code>InsertAsyncAsync(...)</code> method on the <code>connection</code> object. After an item has been inserted into the tabl<a id="_idTextAnchor156"/>e, we invoke the <code>OnItemAdded</code> event to notify any subscribers.</p></li> </ol>
<p>The code to update<a id="_idIndexMarker248"/> an <a id="_idIndexMarker249"/>item is the same as the <code>AddItemAsync()</code> method but also<a id="_idIndexMarker250"/> includes calls to <code>UpdateAsync</code> and <code>OnItemUpdated</code>. Let’s finish up by updating the <code>UpdateItemAsync()</code> method with the following code:</p>
<ol>
<li>Locate the <code>UpdateItemAsync()</code> method in the <code>TodoItemRepository</code> class.</li>
<li>Update the <code>UpdateItemAsync()</code> method with the following code:<pre class="source-code">
public async Task UpdateItemAsync(TodoItem item)
{
    await CreateConnectionAsync();
    await connecti<a id="_idTextAnchor157"/>on.UpdateAsync(item);
    OnItemUpdated?.Invoke(this, item);
}</pre></li> </ol>
<p>In the next section, we’ll get<a id="_idTextAnchor158"/> started with MVVM. Grab a cup of coffee and let’s get started!</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor159"/>Using MVVM – creating views and ViewModels</h1>
<p><strong class="bold">Model-View-ViewModel</strong>, or <strong class="bold">MVVM</strong> for<a id="_idIndexMarker251"/> short, is all<a id="_idIndexMarker252"/> about <strong class="bold">separation of concerns</strong>. It is an architectural<a id="_idIndexMarker253"/> pattern that defines three<a id="_idIndexMarker254"/> parts, each of which has a specific meaning:</p>
<ul>
<li><code>ViewModel</code>.</li>
<li><strong class="bold">View</strong>: This is the visual component. In .NET MAUI, this is represented by a page.</li>
<li><strong class="bold">ViewModel</strong>: This is the class that acts as the glue between the model and the view.</li>
</ul>
<p>We are introducing MVVM here because the MVVM pattern was designed specifically around XAML-based GUIs. This app and the rest of the apps in this book will use XAML to define the GUI and we will use the MVVM pattern to separate the code into the three aforementioned parts.</p>
<p>In this app, we could say that the model is the repository and the to-do list items it returns. <code>ViewModel</code> refers to this repository and exposes properties that the view can bind to. The ground rule is that any logic should reside in <code>ViewModel</code> and no logic should reside in the view. The view should know how to present data, such as converting a Boolean value into <code>Yes</code> or <code>No</code>.</p>
<p>MVVM can be implemented in many ways and there are quite a few frameworks that we can use to do<a id="_idIndexMarker255"/> so, such<a id="_idIndexMarker256"/> as <strong class="bold">Prism</strong>, <strong class="bold">MVVMCross</strong>, or even <strong class="bold">TinyMvvm</strong>. In<a id="_idIndexMarker257"/> this chapter, we have chosen to keep things simple and implement MVVM in a <a id="_idIndexMarker258"/>vanilla way first, and then use portions of the <strong class="bold">CommunityToolkit.Mvvm</strong> library. CommunityTookit.Mvvm is an open source library produced by the .NET Foundation. It is a replacement <a id="_idIndexMarker259"/>for the <strong class="bold">MVVMLight</strong> library.</p>
<p>The main benefits of using MVVM as an architectural pattern are a clear separation of concerns, cleaner code, and great testability of <code>ViewModel</code>. If you are interested in learning more about MVVM, and how to use it with .NET MAUI, visit <a href="https://learn.microsoft.com/en-us/dotnet/arch﻿﻿﻿itecture/maui/mvvm">https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm</a>.</p>
<p>Well, enough <a id="_idIndexMarker260"/>of that – let’s write some<a id="_idIndexMarker261"/> code instead!</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor163"/>Defining a ViewModel base class</h2>
<p><code>ViewModel</code> is the mediator <a id="_idIndexMarker262"/>between the view and the model. We can benefit from it greatly by creating a common base class for all our <code>ViewModel</code> classes to inherit from. To do this, follow these steps:</p>
<ol>
<li>Create a folder called <code>ViewModels</code> in the <code>DoToo</code> project.</li>
<li>Create a class called <code>ViewModel</code> in the <code>ViewModels</code> folder.</li>
<li>Add the following code:<pre class="source-code">
using System.ComponentModel;
public abstract class ViewModel : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler PropertyChanged;
    public void RaisePropertyChanged(params string[] 
propertyNames)
    {
        foreach (var propertyName in propertyNames)
        {
            PropertyChanged?.Invoke(this, new 
PropertyChangedEventArgs(propertyName));
         }
    }
    public INavigation Navigation { get; set; }
}</pre></li> </ol>
<p>The <code>ViewModel</code> class is a base class for all <code>ViewModel</code> objects. It is not meant to be instantiated on its own, so we mark it as <code>abstract</code>. It implements <code>INotifyPropertyChanged</code>, which is an interface defined in <code>System.ComponentModel</code> in the .NET base class libraries. This interface only defines one thing – the <code>PropertyChanged</code> event. Our <code>ViewModel</code> class must raise this event whenever we want the GUI to be aware of any changes to a property. This can be done manually by adding code to a setter in a property, as we did in the current implementation, or by using the <strong class="bold">CommunityToolkit.Mvvm</strong> library. We will talk about this in more detail in the next section.</p>
<p>We will also take a little shortcut here by adding an <code>INavigation</code> property to <code>ViewModel</code>. This will help us with navigation later on. This is also something that can (and should) be <a id="_idIndexMarker263"/>abstracted since we don’t want <code>ViewModel</code> to be depen<a id="_idTextAnchor164"/><a id="_idTextAnchor165"/><a id="_idTextAnchor166"/>dent on .NET MAUI to be able to reuse the <code>ViewModel</code> classes on any platform.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor167"/>Introducing the CommunityToolkit.Mvvm library’s ObservableObject and ObservableProperty</h2>
<p>The traditional<a id="_idIndexMarker264"/> way of implementing<a id="_idIndexMarker265"/> a <code>ViewModel</code> class is to inherit it from a base class (such as the <code>ViewModel</code> class that we defined previously) and then add code that might look as follows:</p>
<pre class="source-code">
public class MyTestViewModel : ViewModel
{
    private string name;
    public string Name
    {
        get { return name; }
        set
        {
            if (name != value)
            {
                name = value;
                RaisePropertyChanged(nameof(Name));
            }
        }
    }
}</pre> <p>Each property that we want to add to a <code>ViewModel</code> class yields 13 lines of code. Not too bad, you might think. However, considering that a <code>ViewModel</code> class could potentially contain 10 to 20 properties, this rapidly turns into a lot of code. We can do better than this.</p>
<p>In just a few <a id="_idIndexMarker266"/>simple <a id="_idIndexMarker267"/>steps, we can use the CommunityToolkit.Mvvm library to automatically inject almost all the code during the build process:</p>
<ol>
<li>In the <code>DoToo</code> project, install the CommunityToolkit.Mvvm NuGet package.</li>
<li>Update the <code>ViewModel</code> class so that it looks like this:<pre class="source-code">
<strong class="bold">using CommunityToolkit.Mvvm.ComponentModel;</strong>
<strong class="bold">[ObservableObject]</strong>
public abstract <strong class="bold">partial</strong> class ViewModel
{
    public INavigation Navigation { get; set; }
}</pre></li> </ol>
<p>We have changed the base class of our <code>ViewModel</code> class so that it has an <code>ObservableObject</code> attribute and added the <code>partial</code> modifier. This attribute will add the base implementation of <code>INotifyPropertyChanged</code> that was previously in our <code>ViewModel</code> base class automatically during the build process.</p>
<p>Once our base class has been modified, we can use the <code>ObservableProperty</code> attribute to automatically generate the property implementation. The result is that the test class we had previously is reduced to a single line of code per property. This makes the code base more readable because everything happens behind the scenes:</p>
<pre class="source-code">
public partial class MyTestViewModel : ViewModel
{
    [ObservableProperty]
    string name;
}</pre> <p>There are a few things to note about the previous example. First, the class must be marked as <code>partial</code> for the <code>ObservableProperty</code> attribute to work, just like the <code>ObservableObject</code> attribute. Second, when using the <code>ObservableProperty</code> attribute, you place it on<a id="_idIndexMarker268"/> a<a id="_idIndexMarker269"/> private field, not a property. The CommunityToolkit.Mvvm library uses <strong class="bold">Source Generators</strong>, a feature added in .NET 5, to generate the actual property implementation.</p>
<p>One of the great things about using Source Generators is that you can always view the generated source to see how things work. For example, to view the generated source for the <code>ViewModel</code> class, do the following:</p>
<ol>
<li>Open the <code>ViewModel.cs</code> file.</li>
<li>Right-click the <code>ViewModel</code> type name.</li>
<li>Select <strong class="bold">Goto Implementation</strong>.</li>
</ol>
<p>Normally, this would do nothing, as you are in the implementation of <code>ViewModel</code>. However, since there is additional generated code, Visual Studio will show you a list of locations that contain implementations for <code>ViewModel</code>, similar to what’s shown here:</p>
<div><div><img alt="Figure 2.12 – Finding all implementations of ViewModel" src="img/Figure_2.12_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Finding all implementations of ViewModel</p>
<p>The first item in the list is what we added to the <code>ViewModel.cs</code> file, and the second item in the list is the generated code. By double-clicking the item, it will open the generated code in a new code window. In the <em class="italic">Creating TodoItemViewModel</em> section, you can follow the<a id="_idIndexMarker270"/> same<a id="_idIndexMarker271"/> steps to see what is generated for the property implementations.</p>
<p>Now that we’ve seen how to implement proper<a id="_idTextAnchor168"/><a id="_idTextAnchor169"/>ties using a sample <code>ViewModel</code>, it is time to create the concrete <code>ViewModel</code> classes.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor170"/>Creating MainViewModel</h2>
<p>So far, we have mainly <a id="_idIndexMarker272"/>prepared to write the code that will make up the app itself. <code>MainViewModel</code> is the <code>ViewModel</code> class for the first view that is displayed to the user. It is responsible for providing data and logic to a list of to-do list items. We will create the bare-bones <code>ViewModel</code> classes and add code to them as we progress through this chapter:</p>
<ol>
<li>Create a class called <code>MainViewModel</code> in the <code>ViewModels</code> folder.</li>
<li>Add the following template code and resolve the references:<pre class="source-code">
public class MainViewModel : ViewModel
{
    private readonly ITodoItemRepository repository;
    public MainViewModel(ITodoItemRepository repository)
    {
        this.repository = repository;
        Task.Run(as<a id="_idTextAnchor171"/>ync () =&gt; await LoadDataAsync());
    }
    private async Task LoadDataAsync()
    {
    }
}</pre></li> </ol>
<p>The structure of <a id="_idIndexMarker273"/>this class is something that we will reuse for all the <code>ViewModel</code> classes to come.</p>
<p>Let’s summarize the important features we want the <code>ViewModel</code> class to have:</p>
<ul>
<li>We inherit from the <code>ViewModel</code> class to gain access to shared logic, such as the <code>INotifyPropertyChanged</code> interface and common navigation code.</li>
<li>All dependencies to other classes, such as repositories and services, which are passed through the constructor of <code>ViewModel</code>. This is handled by the <code>Microsoft.Extensions.DependencyInjection</code>, which is the implementation of the dependency injection we are using. We will add support for automatic dependency injection in the <em class="italic">Wiring up dependency </em><em class="italic">injection</em> section.</li>
<li>We use an<a id="_idIndexMarker274"/> asynchronous call to <code>LoadDataAsync()</code> as an entry point to initial<a id="_idTextAnchor172"/>ize the <code>ViewModel</code> class. Different MV<a id="_idTextAnchor173"/>VM libraries might do this in different ways, but the basic functionality is the same.</li>
</ul>
<h2 id="_idParaDest-50"><a id="_idTextAnchor174"/>Creating TodoItemViewModel</h2>
<p><code>TodoItemViewModel</code> is <a id="_idIndexMarker275"/>the <code>ViewModel</code> class that represents each item in the to-do list on <code>MainView</code>. It does not have an entire view of its own, although it could have. Instead, it is rendered by a template in <code>ListView</code>. We will get back to this when we create the controls for <code>MainView</code>.</p>
<p>The important thing here is that this <code>ViewModel</code> object represents a single item, regardless of where we choose to render it.</p>
<p>Let’s create the <code>TodoItemViewModel</code> class:</p>
<ol>
<li>Create a class called <code>TodoItemViewModel</code> in the <code>ViewModels</code> folder.</li>
<li>Update the class so that it matches the following code:<pre class="source-code">
namespace DoToo.ViewModels;
using CommunityToolkit.Mvvm.ComponentModel;
using DoToo.Models;
public partial class TodoItemViewModel : ViewModel
{
    public TodoItemViewModel(TodoItem item) =&gt; Item = item;
    public event EventHandler ItemStatusChanged;
    [ObservableProperty]
    TodoIte<a id="_idTextAnchor175"/>m item;
    public string StatusText =&gt; Item.Completed ? "Reactivate" : "Completed";
}</pre></li> </ol>
<p>As with any other <code>ViewModel</code> class, we inherit the <code>TodoItemViewModel</code> class from <code>ViewModel</code>. We conform to the pattern of injecting all the dependencies into the constructor. In this case, we pass an instance of the <code>TodoItem</code> class to the constructor that the <code>ViewModel</code> object will use to expose the view.</p>
<p>The <code>ItemStatusChanged</code> event handler will be used later when we want to signal to the view that the state of the <code>TodoItem</code> class has changed. The <code>Item</code> property allows us to access the item that we passed in.<a id="_idTextAnchor176"/></p>
<p>The <code>Statu<a id="_idTextAnchor177"/>sText</code> property <a id="_idIndexMarker276"/>is used to make the status of the to-do item human-readable in the view.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor178"/>Creating the ItemViewModel class</h2>
<p><code>ItemViewModel</code> represents <a id="_idIndexMarker277"/>the to-do list item in a view that can be used to create new items and edit existing ones:</p>
<ol>
<li>In the <code>ViewModels</code> folder, create a class called <code>ItemViewModel</code>.</li>
<li>Add the following code:<pre class="source-code">
namespace DoToo.ViewModels;
using DoToo.Repositories;
public class ItemViewModel : ViewModel
{
    private readonly ITodoItemRepository repository;
    public ItemView<a id="_idTextAnchor179"/>Model(ITodoItemRepository repository)
    {
        this.repository = repository;
    }
}</pre></li> </ol>
<p>The pattern is the same as for the previous two <code>ViewModel</code> classes:</p>
<ul>
<li>We use dependency injection to pass the <code>TodoItemRepository</code> class to the <code>Vie<a id="_idTextAnchor180"/>wModel</code> object</li>
<li>We use inher<a id="_idTextAnchor181"/>itance from the <code>ViewModel</code> base class to add the common features<a id="_idIndexMarker278"/> defined by the base class</li>
</ul>
<h2 id="_idParaDest-52"><a id="_idTextAnchor182"/>Creating the MainView view</h2>
<p>Now that we are <a id="_idIndexMarker279"/>done with the <code>ViewModel</code> classes, let’s create the skeleton code and the XAML required for the views. The template created a file named <code>MainPage.xml</code>. In MVVM, the convention is to use a <code>-View</code> suffix instead. We will also want to place all our views together in a subfolder, as we did with the <code>ViewModel</code> classes. Let’s deal with the <code>MainPage.xml</code> file first, which is the view that will be loaded first:</p>
<ol>
<li>Delete the <code>MainPage.xml</code> file from the root of the project.</li>
<li>Create a folder called <code>Views</code> in the <code>DoToo</code> project.</li>
<li>Right-click on the <code>Views</code> folder, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.</li>
<li>Select <strong class="bold">.NET MAUI</strong> under the <strong class="bold">C# Items</strong> node on the left.</li>
<li>Select <code>MainView</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the page:</li>
</ol>
<div><div><img alt="Figure 2.13 – Adding a new XAML file" src="img/Figure_2.13_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Adding a new XAML file</p>
<p>Let’s add<a id="_idIndexMarker280"/> some content to the newly created view:</p>
<ol>
<li>Open <code>MainView.xaml</code>.</li>
<li>Remove all the template code below the <code>ContentPage</code> root node and add the XAML code highlighted in the following code:<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/
maui"
             
  x:Class="DoToo.Views.MainView"
  <strong class="bold">Title="Do Too!</strong>"&gt;
<strong class="bold">  &lt;ContentPage.ToolbarItems&gt;</strong>
<strong class="bold">    &lt;ToolbarItem Text="Add" /&gt;</strong>
<strong class="bold">  &lt;/ContentPage.ToolbarItems&gt;</strong>
<strong class="bold">  &lt;Grid&gt;</strong>
<strong class="bold">    &lt;Grid.RowDefinitions&gt;</strong>
<strong class="bold">      &lt;RowDefinition Height="auto" /&gt;</strong>
<strong class="bold">      &lt;RowDefinition Height="*" /&gt;</strong>
<strong class="bold">    &lt;/Grid.RowDefinitions&gt;</strong>
<strong class="bold">    &lt;Button Text="Toggle filter" /&gt;</strong>
<strong class="bold">    &lt;ListView Grid.Row="1"&gt;</strong>
<strong class="bold">    &lt;/ListView&gt;</strong>
<strong class="bold">  &lt;/Grid&gt;</strong>
&lt;/ContentPage&gt;</pre></li> </ol>
<p>To be able to access custom converters, we need to add a reference to a local namespace. The <code></strong> line defines this namespace for us. We will not use it directly in this case, but it’s a good idea to have a local namespace defined. If we create custom controls, we can access them by writing something such as <strong class="source-inline">&lt;</code><code>local:MyControl /&gt;</code>.</p>
<p>The <code>Title</code> property on the <code>ContentPage</code> page gives the page a title. Depending on the platform we are running on, the title is displayed differently. If we use a standard navigation bar, it will be displayed at the top, for example, in both iOS and Android. A page should always have a title.</p>
<p>The <code>ContentPage.ToolbarItems</code> node defines a toolbar item for adding new to-do items. It will also <a id="_idIndexMarker281"/>be rendered <a id="_idTextAnchor184"/>differently based on the platform, but it always follows the platform-specific UI guidelines.</p>
<p>A page in .NET MAUI (and in an XML document, in general) can only have one root node. The root node in a .NET MAUI page populates the <code>Content</code> property of the page itself. Since we want our <code>MainView</code> view to contain a list of items and a button at the top to toggle a filter (to switch between all items and only active items), we need to add a <code>Layout</code> control to position them on the page. <code>Grid</code> is a control that allows you to split up the available space based on rows and columns.</p>
<p>For our <code>MainView</code> view, we want to add two rows. The first row is a space calculated by the height of the button (<code>Height="auto"</code>) and the second row takes up all the remaining space for <code>ListView</code> (<code>Height="*"</code>). Elements such as <code>ListView</code> are positioned in the grid using the <code>Grid.Row</code> and <code>Grid.Column</code> attributes. Both properties default to <code>0</code> if they are not specified, just like the button.</p>
<p><code>ListView</code> is a control that presents items in a list, which is coincidently exactly what our app will do. It’s worth noting that .NET MAUI does have a control called <code>CollectionView</code>, which can handle displaying collections of items better than <code>ListView</code>. Subsequent chapters will use this control, but we wanted to introduce you to the good old <code>ListView</code> control as well.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you are interested in how <code>Grid</code> works, you can search for more information about .NET MAUI grids on the internet or check out the official documentation at <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid</a>.</p>
<p>We also need to<a id="_idIndexMarker282"/> wire up <code>ViewModel</code> to the view. This can be done by passing the <code>ViewModel</code> class in the constructor of the view:</p>
<ol>
<li>Open the code-behind file of <code>MainView</code> by expanding the <code>MainView.xaml</code> file in <code>MainView.xaml.cs</code>.</li>
<li>Add a <code>using DoToo.ViewModels</code> statement to the top of the file, adjacent to the existing <code>using</code> statements.</li>
<li>Modify the constructor of the class so that it looks as follows by adding the highlighted code:<pre class="source-code">
public MainView(<strong class="bold">MainViewModel viewModel</strong>)
{
    In<a id="_idTextAnchor185"/>itializeComponent();
    <strong class="bold">viewModel.Navigation = Navigation;</strong>
    <strong class="bold">BindingContext = viewModel;</strong>
}</pre></li> </ol>
<p>We follow the same pattern as we did with the <code>ViewModel</code> classes by passing any dependencies through the constructor. A view is always dependent on a <code>ViewModel</code> class. To simplify the project, we also assign the <code>Navigation</code> property of the page directly to the <code>Navigation</code> property defined in the <code>ViewModel</code> base class. In a larger project, we might want to abstract this property as well to make sure that we separate the <code>ViewModel</code> classes from .NET MAUI. For the sake of this app, however, it is OK to reference it directly.</p>
<p>Lastly, we assign <code>ViewModel</code> to the <code>BindingContext</code> class of the page. This<a id="_idTextAnchor186"/> tells the .NET MAUI binding engine to use our <code>ViewModel</code> object for the bindings that we will create<a id="_idIndexMarker283"/> later.</p>
<p>At this point, since we have removed <code>MainPa<a id="_idTextAnchor187"/>ge</code>, the project will no longer run. We will fix this in the <em class="italic">Making the app run</em> section later.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor188"/>Creating the ItemView view</h2>
<p>The second view <a id="_idIndexMarker284"/>we will add is <code>ItemView</code>. We will use this to add and edit the to-do list items:</p>
<ol>
<li>Create a new content page (in the same way that we created the <code>MainView</code> view) and name it <code>ItemView</code>.</li>
<li>Edit the XAML file so that it appears as in the following code. The changes are highlighted:<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ContentPage xmlns=http://schemas.microsoft.com/dotnet/2021/maui
              xmlns:x=http://schemas.microsoft.com/winfx/2009/xaml
  x:Class="DoToo.Views.ItemView"
<strong class="bold">  Title="New todo item"&gt;</strong>
<strong class="bold">  &lt;ContentPage.ToolbarItems&gt;</strong>
<strong class="bold">    &lt;ToolbarItem Text="Save" /&gt;</strong>
<strong class="bold">  &lt;/ContentPage.ToolbarItems&gt;</strong>
<strong class="bold">  &lt;StackLayout Padding="14"&gt;</strong>
<strong class="bold">    &lt;Label Text="Title" /&gt;</strong>
<strong class="bold">    &lt;Entry /&gt;</strong>
<strong class="bold">    &lt;Label Text="Due" /&gt;</strong>
<strong class="bold">    &lt;DatePicker /&gt;</strong>
<strong class="bold">    &lt;StackLayout Orientation="Horizontal"&gt;</strong>
<strong class="bold">      &lt;Switch /&gt;</strong>
<strong class="bold">      &lt;Label Text="Completed" /&gt;</strong>
<strong class="bold">    &lt;/StackLayout&gt;</strong>
<strong class="bold">  &lt;/StackLayout&gt;</strong>
&lt;/ContentPage&gt;</pre></li> </ol>
<p>As with <code>MainView</code>, we need a title. We will give it a default title of <code>New todo item</code> for now, but we will change this to <code>Edit todo item</code> when we reuse this view for editing later on. The<a id="_idIndexMarker285"/> user must be able to save a new or edited item, so we have added a toolbar <code>Save</code> button. The content of the page uses <code>StackLayout</code> to structure the controls. <code>StackLayout</code> adds an element vertically (the default option) or horizontally based on the space it calculates that the element takes up. This is a CPU-intensive process, so we should only use it on small portions of our layout. In <code>StackLayout</code>, we add a <code>Label</code> control, which is a line of text over the <code>Entry</code> control that comes underneath it. The <code>Entry</code> control is a text input control that contains the name of the to-do list item. Then, we have a section for <code>DatePicker</code>, where the user can select a due date for the to-do list item. The final control is a <code>Switch</code> control, which renders a toggle button to control when an item is complete, as well as a heading next to it. Since we want these to be displayed next to each other horizontally, we use a horizontal <code>StackLayout</code> control to do this.</p>
<p>The last step for the views is to wire up the <code>ItemViewModel</code> model to <code>ItemView</code>:</p>
<ol>
<li>Open the code-behind file of <code>ItemView</code> by expanding the <code>ItemView.xaml</code> file in <strong class="bold">Solution Explorer</strong>.</li>
<li>Add a <code>using DoToo.ViewModels</code> statement to the top of the file, adjacent to the existing <code>using</code> statements.</li>
<li>Modify the constructor of the class so that it looks as follows. Add the code that is marked in bold:<pre class="source-code">
public ItemView (<strong class="bold">ItemViewModel viewmodel</strong>)
{
    InitializeComponent ();
    <strong class="bold">viewmodel.Navigation = Navigation;</strong>
    <strong class="bold">BindingContext = viewmodel;</strong>
}</pre></li> </ol>
<p>This <a id="_idTextAnchor189"/><a id="_idTextAnchor190"/><a id="_idTextAnchor191"/>code is<a id="_idIndexMarker286"/> identical to the code that we added for <code>MainView</code>, except for the type of <code>ViewModel</code> class.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor192"/>Wiring up dependency injection</h2>
<p>Earlier, we <a id="_idIndexMarker287"/>discussed the dependency injection pattern, which states that all dependencies, such as the repositories and view models, must be passed through the constructor of the class. This requirement has several benefits:</p>
<ul>
<li>It increases the readability of the code since we can quickly determine all the external dependencies</li>
<li>It makes dependency injection possible</li>
<li>It makes unit testing possible by mocking classes</li>
<li>We can control the lifetime of an object by specifying whether it should be a singleton or a new instance for each resolution</li>
</ul>
<p>Dependency injection is a pattern that lets us determine, at runtime, which instance of an object should be passed to a constructor when an object is created. We do this by defining a container where we register all the types of a class. We let the framework that we are using resolve any dependencies between them. Let’s say that we ask the container for a <code>MainView</code> class. The container takes care of resolving <code>MainViewModel</code> and any dependencies that the class has.</p>
<p>.NET MAUI uses the <code>Microsoft.Extensions.DependencyInjection</code> NuGet library internally<a id="_idIndexMarker288"/> and it is exposed for us to use in our applications. The first step is to register the classes we want to participate in dependency injection.</p>
<h3>Registering View, ViewModels, and Services</h3>
<p>For our<a id="_idIndexMarker289"/> classes<a id="_idIndexMarker290"/> to be<a id="_idIndexMarker291"/> available through dependency injection, they need to be registered with the dependency injection service. .NET MAUI exposes the dependency injection service using the <code>Services</code> property of the <code>MauiAppBuilder</code> class. The <code>Services</code> property will return an <code>IServiceCollection</code> object, also referred to as the container. <code>IServiceCollection</code> has two methods we are interested in, <code>AddSingleton</code>, and <code>AddTransient</code>. The “Transient” and “Singleton” in the method names refer to the lifetime of the objects. Transient objects are created every time they are requested from the container. Singleton objects are created only once, and that one instance is returned every time the class is requested from the container.</p>
<p>When registering classes with the container, it is recommended to use extension methods to group the types. For this app, there are three groups: <code>View</code>, <code>ViewModels</code>, and <code>Services</code>. The extension methods will take a single parameter and return a single value, the <code>MauiAppBuilder</code> instance. This is how the Builder pattern is implemented and allows us to chain the methods on the builder defined in the <code>CreateMauiApp</code> method.</p>
<p>To implement the methods, follow these steps:</p>
<ol>
<li>Open the <code>MauiProgram.cs</code> file.</li>
<li>Make the following changes to the <code>MauiProgram</code> class. The changes are highlighted in bold:<pre class="source-code">
<strong class="bold">using DoToo.Repositories;</strong>
public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        builder
            .UseMauiApp&lt;App&gt;()
            .ConfigureFonts(fonts =&gt;
            {
                fonts.AddFont("OpenSans-Regular.ttf", 
"OpenSansRegular");
                fonts.AddFont("OpenSans-Semibold.ttf", 
"OpenSansSemibold");
<strong class="bold">            })</strong>
<strong class="bold">            .RegisterServices()</strong>
<strong class="bold">            .RegisterViewModels()</strong>
<strong class="bold">            .RegisterViews();</strong>
            return builder.Build();
    }
<strong class="bold">    public static MauiAppBuilder RegisterServices(this </strong>
<strong class="bold">MauiAppBuilder mauiAppBuilder)</strong>
<strong class="bold">    {</strong>
<strong class="bold">    mauiAppBuilder.Services.AddSingleton&lt;ITodoItemRepository,TodoItemRepository&gt;();</strong>
<strong class="bold">        return mauiAppBuilder;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    public static MauiAppBuilder RegisterViewModels(this </strong>
<strong class="bold">MauiAppBuilder mauiAppBuilder)</strong>
<strong class="bold">    {</strong>
<strong class="bold">         mauiAppBuilder.Services.AddTransient&lt;ViewModels.</strong>
<strong class="bold">MainViewModel&gt;();</strong>
<strong class="bold">        mauiAppBuilder.Services.AddTransient&lt;ViewModels.</strong>
<strong class="bold">ItemViewModel&gt;();</strong>
<strong class="bold">        return mauiAppBuilder;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    public static MauiAppBuilder RegisterViews(this </strong>
<strong class="bold">MauiAppBuilder mauiAppBuilder)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        mauiAppBuilder.Services.AddTransient&lt;Views.MainView&gt;();</strong>
<strong class="bold">        mauiAppBuilder.Services.AddTransient&lt;Views.ItemView&gt;();</strong>
<strong class="bold">        return mauiAppBuilder;</strong>
<strong class="bold">    }</strong>
}</pre></li> </ol>
<p>Normally, registering a type is done by using the type name as the generic argument to the registration method, as in <code>mauiAppBuilder.Services.AddTransient&lt;Views.MainView&gt;();</code>. But that doesn’t work if you need to resolve an interface to an implementation, like what is happening in the <code>RegisterServices</code> method. There, the registration method doesn’t use the generic argument; instead, it passes in the type to register as the first argument, and the second argument is the type of the instance to return.</p>
<p class="callout-heading">Info</p>
<p class="callout">To learn more about how <code>Microsoft.Extensions.DependencyInjection</code> works, visit <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection">https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection</a> in y<a id="_idTextAnchor193"/>our favorite browser.</p>
<p>Now<a id="_idIndexMarker292"/> that <a id="_idIndexMarker293"/>dependency <a id="_idIndexMarker294"/>injection is wired up, we can get the project running again.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor194"/>Making the app run</h2>
<p>There are just <a id="_idIndexMarker295"/>a few more changes we need to make to enable the app to run:</p>
<ol>
<li>Open the <code>App.xaml.cs</code> file by expanding the <code>App.xaml</code> node in the <code>DoToo</code> project.</li>
<li>Modify the following lines in bold:<pre class="source-code">
public App(<strong class="bold">Views.MainView view</strong>)
{
    InitializeComponent();
    <strong class="bold">MainPage = new NavigationPage(view);</strong>
}</pre></li> <li><code>AppShell.Xaml</code> and <code>AppShell.xaml.cs</code> are no longer used, so they can be deleted from the project.</li>
</ol>
<p>When .NET MAUI initializes the <code>App</code> class via the builder, it does so by using the dependency injection container, so any arguments you add to the <code>App</code> constructor are resolved from the container as well, and their dependencies too. In this case, we are importing the <code>MainView</code> class (and all its dependencies, including <code>MainViewModel</code> and <code>TodoItemRepository</code>) and wrapping it in <code>NavigationPage</code>. <code>NavigationPage</code> is a page defined in .NET MAUI that adds a navigation bar and enables the user to navigate to other views.</p>
<p class="callout-heading">Information</p>
<p class="callout">.NET MAUI includes <code>Shell</code>, and we have a whole chapter about it in this book. However, to become a good .NET MAUI developer, you n<a id="_idTextAnchor195"/>eed to know the basics, and the basics of navigating in .NET MAUI uses the good old <code>NavigationPage</code> control.</p>
<p>That’s it! Now, your <a id="_idIndexMarker296"/>project should start. Depending on the platform you are using, it might look as follows:</p>
<div><div><img alt="Figure 2.14 – The DoToo application in the Windows subsystem for Android" src="img/Figure_2.14_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – The DoToo application in the Windows subsystem for Android</p>
<p>Now that we have the app running with a basic UI, let’s add some functionality, starting with displaying data.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you are debugging the app using the Windows target framework and it isn’t working, and you aren’t getting <a id="_idIndexMarker297"/>any error messages, try u<a id="_idTextAnchor196"/><a id="_idTextAnchor197"/>sing the Android target framework. Sometimes, you can get better error reporting from a different platform.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor198"/>Adding data bindings</h1>
<p>Data binding is the <a id="_idIndexMarker298"/>heart and soul of MVVM. This is the way that the views and ViewModel communicate with each other. In .NET MAUI, we need two things to make data binding happen:</p>
<ul>
<li>We need an object to implement <code>INotifyPropertyChanged</code>.</li>
<li>We need to set the <code>BindingContext</code> class of the page to that object. We already do this on both <code>ItemView</code> and <code>MainView</code>.</li>
</ul>
<p>A useful feature of data binding is that it allows us to use two-way communication. For example, when data binding text to an <code>Entry</code> control, the property<a id="_idTextAnchor199"/> on the data-bound object is updated directly. Consider the following XAML:</p>
<pre class="source-code">
&lt;Entry Text="{Binding Title}" /&gt;</pre> <p>To make this work, we need a property named <code>Title</code> on the string object. We have to look at the documentation, define an object, and <a id="_idIndexMarker299"/>let <strong class="bold">IntelliSense</strong> provide us with a hint to find out what type our property should be.</p>
<p>Controls that perform an action, such as <code>Button</code>, usually expose a property called <code>Command</code>. This property is of the <code>ICommand</code> type, and we can either return <code>Microsoft.Maui.Controls.Command</code> or an implementation of our own. The <code>Command</code> property is explained in the next section, where we will use it to navigate to <code>ItemView</code>.</p>
<p>In the next few sections, we will be adding the data binding and command implementations to our views and ViewModels, starting with navigating from <code>MainView</code> to <code>ItemView</code>.</p>
<p class="callout-heading">Information</p>
<p class="callout">It’s also worth noting that .NET MAUI supports one-way binding in addition to two-way data binding, which comes in handy when you wa<a id="_idTextAnchor200"/>nt to display data in a view but not allow it to updat<a id="_idTextAnchor201"/>e the ViewModel. From a performance perspective, it’s a good idea to mark those bindings<a id="_idIndexMarker300"/> as one-way bindings.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor202"/>Navigating from MainView to ItemView to add a new item</h2>
<p>We have an <code>Add</code> toolbar<a id="_idIndexMarker301"/> button in <code>MainView</code>. When the user taps this button, we want it to take them to <code>ItemView</code>. The MVVM way to do this is to define a command and then bind that command to the button.</p>
<p>In .NET MAUI, to navigate to a view, you need a reference to an instance of the destination. In this case, that would be <code>ItemView</code>. Since all our views have been registered with the dependency injection container, we will need a reference to the container to request a new instance of the view when we are ready to navigate. We will use constructor injection to have the container provide us with its instance, like this:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code>.</li>
<li>Add a <code>using</code> statement for <code>DoToo.Views</code>.</li>
<li>Add the following field to the class:<pre class="source-code">
private readonly IServiceProvider services;</pre></li> <li>Modify the constructor as follows. The changes are highlighted:<pre class="source-code">
public MainViewModel(ITodoItemRepository repository, 
<strong class="bold">IServiceProvider services</strong>)
{
    this.repository = repository;
    <strong class="bold">this.services = services;</strong>
    Task.Run(async () =&gt; await LoadDataAsync());
}</pre></li> </ol>
<p>This will capture the instance of <code>ItemView</code> that was created by the dependency injection container in a class field. Now, let’s look at the command implementation.</p>
<p>All commands should be exposed as a generic <code>ICommand</code> type. This abstracts the actual command implementation, which is good general practice to follow. The command must be a property; in our case, we are creating a new <code>Command</code> object that we assign to this property. The property is read-only, which is usually fine for a <code>Command</code> object. The action of the command (the code that we want to run when the command is executed) is passed to the constructor of the <code>Command</code> object.</p>
<p>Following those requirements, you might end up writing something like th<a id="_idTextAnchor203"/>e following:</p>
<pre class="source-code">
public ICommand AddItem =&gt; new Command(async () =&gt;
{
    await Navigation.PushAsync(itemView);
});</pre> <p>There is a lot of boilerplate code in that implementation that you would have to repeat for each<a id="_idIndexMarker302"/> command. This boilerplate code can get in the way of what the command is doing. Like how we were able to eliminate boilerplate code with properties, we can do the same with <code>ICommand</code>, but instead, we can use the <code>RelayCommand</code> attribute. The <code>RelayCommand</code> attribute uses a source generator to wrap a method in a new <code>Command</code> instance and expose it through a property. The property name that’s generated is the method name with “Command” appended to it.</p>
<p> Now, we can add the <code>Command</code> object’s implementation:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code>.</li>
<li>Add the following method to the class:<pre class="source-code">
[RelayCommand]
public async Task AddItemAsync() =&gt; await Navigation.
PushAsync(services.GetRequiredService&lt;ItemView&gt;());</pre></li> <li>Add <code>using CommunityToolkit.Mvvm.Input;</code> to the <code>usings</code> section of the file.</li>
<li>Update the class definition to allow the Source Generators to do their thing:<pre class="source-code">
public <strong class="bold">partial</strong> class MainViewModel : ViewModel</pre></li> </ol>
<p>The action of the command is simply to use the <code>Navigation</code> service to push the <code>itemView</code> instance onto the stack for us.</p>
<p>After that, we just need to wire up the <code>AddItemAsync</code> command from <code>ViewModel</code> to the <code>Add</code> button in the view:</p>
<ol>
<li>Open <code>Views/MainView.xaml</code>.</li>
<li>Update the <code>ContentPage</code> element:<pre class="source-code">
&lt;ContentPage xmlns=http://schemas.microsoft.com/dotnet/2021/maui
             xmlns:x=http://schemas.microsoft.com/winfx/2009/xaml
  <strong class="bold"></strong>
  x:Class="DoToo.Views.MainView"
  <strong class="bold">x:DataType="viewModels:MainViewModel"</strong>
  Title="Do Too!"&gt;</pre></li> <li>Add the <code>Command</code> attribute to <code>ToolbarItem</code>:<pre class="source-code">
&lt;ContentPage.ToolbarItems&gt;
  &lt;ToolbarItem Text="Add" <strong class="bold">Command="{Binding AddItemAsyncCommand}"</strong> /&gt;
&lt;/Co<a id="_idTextAnchor204"/>ntentPage.ToolbarItems&gt;</pre></li> </ol>
<p>Run the app<a id="_idTextAnchor205"/> <a id="_idIndexMarker303"/>and tap the <code>Add</code> button to navigate to the new <code>ItemView</code> view. Notice that the back button appears automatically.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor206"/>Adding new items to the list</h2>
<p>Now that we have<a id="_idIndexMarker304"/> finished adding navigation to a new item, let’s add the code to create a new item and save it to the database:</p>
<ol>
<li>Open <code>ViewModels/ItemViewModel.cs</code>.</li>
<li>Add the<a id="_idIndexMarker305"/> following code in bold:<pre class="source-code">
<strong class="bold">using CommunityToolkit.Mvvm.ComponentModel;</strong>
<strong class="bold">using CommunityToolkit.Mvvm.Input;</strong>
<strong class="bold">using DoToo.Models;</strong>
using DoToo.Repositories;
public <strong class="bold">partial</strong> class ItemViewModel : ViewModel
{
    private readonly ITodoItemRepository repository;
    <strong class="bold">[ObservableProperty]</strong>
    <strong class="bold">TodoItem item;</strong>
    public ItemViewModel(ITodoItemRepository repository)
    {
        this.repository = repository;
        <strong class="bold">Item = new TodoItem() { Due = DateTime.Now.AddDays(1) };</strong>
    }
    <strong class="bold">[RelayCommand]</strong>
    <strong class="bold">public async T<a id="_idTextAnchor207"/>ask SaveAsync()</strong>
    <strong class="bold">{</strong>
        <strong class="bold">await repository.AddOrUpdateAsync(Item);</strong>
        <strong class="bold">await Navigation.PopAsync();</strong>
    <strong class="bold">}</strong>
}</pre></li> </ol>
<p>The <code>Item</code> property holds a reference to the current item that we want to add or edit. A new item is created in the constructor and when we want to edit an item, we can simply assign our own item to this property. The new item is not added to the database unless we execute the <code>Save</code> command defined at the end. Once the item has been added or updated, we remove the view from the navigation stack and return to <code>MainView</code> again.</p>
<p class="callout-heading">Information</p>
<p class="callout">Since the navigation keeps pages in a stack, the framework declares methods that reflect operations that you can perform on a stack. The operation of removing the topmost item in a stack is known as <em class="italic">popping the stack</em>, so instead of <code>RemoveAsync()</code>, we have <code>PopAsync()</code>. To add a page to the navigation stack, we push it, so the method is called <code>PushAsync()</code>.</p>
<p>Now that we have<a id="_idIndexMarker306"/> extended <code>ItemViewModel</code> with the necessary commands and properties, it’s time to data-bind them in the XAML:</p>
<ol>
<li>Open <code>Views/ItemView.xaml</code>.</li>
<li>Add the code marked in bold:<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ContentPage
  xmlns=http://schemas.microsoft.com/dotnet/2021/maui
    xmlns:x=http://schemas.microsoft.com/winfx/2009/xaml
  <strong class="bold"></strong>
  x:Class="DoToo.Views.ItemView"
  <strong class="bold">x:DataType="viewModels:ItemViewModel"</strong> &gt;
  &lt;ContentPage.ToolbarItems&gt;
    &lt;ToolbarItem Text="Save" <strong class="bold">Command="{Binding </strong>
<strong class="bold">SaveAsyncCommand}"</strong> /&gt;
  &lt;/ContentPage.ToolbarItems&gt;
  &lt;StackLayout Padding="14"&gt;
    &lt;Label Text="Title" /&gt;
    &lt;Entry <strong class="bold">Text="{Binding Item.Title}"</strong> /&gt;
    &lt;Label Text="Due" /&gt;
    &lt;DatePicker <strong class="bold">Date="{Binding Item.Due}"</strong> /&gt;
    &lt;StackLayout Orientation="Horizontal"&gt;
    &lt;Switch <strong class="bold">IsToggled="{Binding Item.Completed}"</strong> /&gt;
    &lt;Label Text="Completed" /&gt;
  &lt;/StackLayout&gt;
&lt;/ContentPage&gt;</pre></li> </ol>
<p>The binding to the <code>ToolbarItems</code> command attribute triggers the <code>SaveAsync</code> command exposed by <code>ItemViewModel</code> when a user taps the <code>Save</code> link. It’s worth noting again that any attribute called <code>Command</code> indicate<a id="_idTextAnchor208"/>s that an action will take place and we must bind it to an instance of an object implementing the <code>ICommand</code> interface.</p>
<p>The <code>Entry</code> control that represents the title is data-bound to the <code>Item.Title</code> property of <code>ItemViewModel</code>, and the <code>Datepicker</code> and <code>Switch</code> controls bind similarly to their respective properties.</p>
<p>We could have exposed <code>Title</code>, <code>Due</code>, and <code>Complete</code> as properties directly on <code>ItemViewModel</code>, but <a id="_idIndexMarker307"/>instead, we chose to reuse the already-existing <code>TodoItem</code> object as a ref<a id="_idTextAnchor209"/><a id="_idTextAnchor210"/>erence. This is fine, so long as the properties of the <code>TodoItem</code> object implement the <code>INotifyPropertyChange</code> interface.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor211"/>Binding ListView in MainView</h2>
<p>A to-do list<a id="_idIndexMarker308"/> is <a id="_idIndexMarker309"/>not much use without a list of items. Let’s extend <code>MainViewModel</code> with a list of items:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code>.</li>
<li>Add <code>using System.Collections.ObjectModel</code> in the <code>using</code> section of the class.</li>
<li>Add a property for the to-do list items:<pre class="source-code">
[ObservableProperty]
ObservableCollection&lt;TodoItemViewModel&gt; items;</pre></li> </ol>
<p><code>ObservableCollection</code> is like an ordinary collection, but it has a useful superpower: it can notify listeners about changes in the list, such as when items are added or deleted. The <code>ListView</code> control listens to changes in the list and updates itself automatically based on these. However, it’s important to be aware that a change to an item in the list will not trigger an update. Changing the title of an item will not cause the list to re-render. Let’s move on to implementing the rest of <code>MainViewModel</code>.</p>
<p>Now, we need some data:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code>.</li>
<li>Replace (or complete) the <code>LoadDataAsync</code> method and create the <code>CreateTodo</code><strong class="source-inline">
ItemViewModel</strong> and <code>ItemStatusChanged</code> methods:<pre class="source-code">
private async Task LoadDataAsync()
{
    var items = await repository.GetItemsAsync();
    var itemViewModels = items.Select(i =&gt; CreateTodoItemViewModel(i));
    Items = new ObservableCollection&lt;TodoItemViewModel&gt; 
(itemViewModels);
}
private TodoItemViewModel CreateTodoItemViewModel(TodoItem item)
{
    var itemViewModel = new TodoItemViewModel(item);
    itemViewModel.ItemStatusChanged += ItemStatusChanged;
    return itemViewModel;
}
private void ItemStatusChanged(object sender, EventArgs e)
{
}</pre></li> <li>Resolve all <a id="_idIndexMarker310"/>new<a id="_idIndexMarker311"/> references by adding the following <code>using</code> statements:<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
using DoToo.Models;</pre></li> </ol>
<p>The <code>LoadData</code> method calls the repository to fetch all items. Then, we wrap each to-do list item in <code>TodoItemViewModel</code>. This contains more information that is specific to the view that we don’t want to add to the <code>TodoItem</code> class. It is good practice to wrap plain objects in <code>ViewModel</code>; this makes it simpler to add actions or extra properties to it. <code>ItemStatusChanged</code> is a stub that is called when we change the status of the to-do list item from <code>active</code> to <code>completed</code>, and vice versa.</p>
<p>We also need to hook up some events from the repository to know when data changes:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code>.</li>
<li>Add the following code in bold:<pre class="source-code">
public MainViewModel(TodoItemRepository repository, 
IServiceProvider services)
{
    <strong class="bold">repository.OnItemAdded += (sender, item) =&gt;</strong>
        <strong class="bold">items.Add(CreateTodoItemViewModel(item));</strong>
    <strong class="bold">repository.OnItemUpdated += (sender, item) =&gt;</strong>
        <strong class="bold">Task.Run(async () =&gt; await LoadDataAsync<a id="_idTextAnchor212"/>());</strong>
    this.repository = repository;
    this.services = services;
    Task.Run(async () =&gt; await LoadDataAsync());
}</pre></li> </ol>
<p>When an item is added to the repository, no matter who added it, <code>MainView</code> will add it to the <code>items</code> list. Since<a id="_idIndexMarker312"/> the<a id="_idIndexMarker313"/> items collection is an observable collection, the list updates. If an item is updated, we simply reload the list.</p>
<p>Let’s data-bind our items to <code>ListView</code>:</p>
<ol>
<li>Open <code>MainView.xaml</code> and locate the <code>ListView</code> element.</li>
<li>Modify it so that it reflects the following code:<pre class="source-code">
&lt;ListView Grid.Row="1"
<strong class="bold">  RowHeight="70" ItemsSource="{Binding Items}"&gt;</strong>
<strong class="bold">  &lt;ListView.ItemTemplate&gt;</strong>
<strong class="bold">    &lt;DataTemplate x:DataType="viewModels:TodoItemViewModel"&gt;</strong>
<strong class="bold">      &lt;ViewCell&gt;</strong>
<strong class="bold">        &lt;Grid Padding="15,10"&gt;</strong>
<strong class="bold">          &lt;Grid.RowDefinitions&gt;</strong>
<strong class="bold">              &lt;RowDefinition /&gt;</strong>
<strong class="bold">              &lt;RowDefinition /&gt;</strong>
<strong class="bold">          &lt;/Grid.RowDefinitions&gt;</strong>
<strong class="bold">          &lt;Grid.ColumnDefinitions&gt;</strong>
<strong class="bold">            &lt;ColumnDefinition Width="10" /&gt;</strong>
<strong class="bold">            &lt;ColumnDefinition Width="*" /&gt;</strong>
<strong class="bold">          &lt;/Grid.ColumnDefinitions&gt;</strong>
<strong class="bold">          &lt;BoxView Grid.RowSpan="2" /&gt;</strong>
<strong class="bold">          &lt;Label Grid.Column="1"</strong>
<strong class="bold">            Text="{Binding Item.Title}" FontSize="Medium" /&gt;</strong>
<strong class="bold">          &lt;Label Grid.Column="1" Grid.Row="1"</strong>
<strong class="bold">            Text="{Binding Item.Due}" FontSize="Micro" /&gt;</strong>
<strong class="bold">          &lt;Label Grid.Column="1" Grid.Row="1"</strong>
<strong class="bold">            HorizontalTextAlignment="End" Text="Completed"</strong>
<strong class="bold">            IsVisible="{Binding Item.Completed}"</strong>
<strong class="bold">            FontSize="Micro" /&gt;</strong>
<strong class="bold">        &lt;/Grid&gt;</strong>
<strong class="bold">      &lt;/ViewCell&gt;</strong>
<strong class="bold">    &lt;/DataTemplate&gt;</strong>
<strong class="bold">  &lt;/ListView.ItemTemplate&gt;</strong>
&lt;/ListView&gt;</pre></li> </ol>
<p>The <code>ItemsSource</code> binding tells <code>ListView</code> where to find the collection to iterate over and is local to <code>ViewModel</code>. Any bindings in the <code>ViewCell</code> node, however, are local to each item that we iterate in the list. In this case, we are binding to <code>TodoItemViewModel</code>, which contains a property named <code>Item</code>. This, in turn, has properties such as <code>Title</code>, <code>Due</code>, and <code>Completed</code>. We can navigate down the hierarchy of objects without any<a id="_idTextAnchor213"/> problem when defining a binding.</p>
<p><a id="_idTextAnchor214"/>The <code>DataTemplate</code> element defines what each row will look like. We use a grid to partition the space, just as we did earlier.</p>
<p>You may have noticed that we didn’t discuss what <code>BoxView</code> was for, and it isn’t bound to any properties of <code>ViewModel</code>. The next two sections will cover how we can use the <code>Completed</code> property<a id="_idIndexMarker314"/> to<a id="_idIndexMarker315"/> color code our items with <code>BoxView</code>.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor215"/>Creating a ValueConverter object for the item’s status</h2>
<p>Sometimes, we<a id="_idIndexMarker316"/> want to bind to objects that are a representation of the original value. This could be a piece of text that is based on a Boolean value. Instead of <code>true</code> and <code>false</code>, for example, we might want to write <code>Yes</code> and <code>No</code> or return a color. This is where <code>ValueConverter</code> comes in handy. It can be used to convert a value to and from another value. We are going to write a <code>ValueConverter</code> object that converts the status of a to-do list item into a color:</p>
<ol>
<li>In the root of the <code>DoToo</code> project, create a folder called <code>Converters</code>.</li>
<li>Create a class called <code>StatusColorConverter.cs</code> in the <code>Converters</code> folder and add the following code:<pre class="source-code">
using System;
using System.Globalization;
public class StatusColorConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object 
parameter, CultureInfo culture)
    {
        return (Color)Application.Curre<a id="_idTextAnchor216"/>nt.Resources[
        (bool)value ? "CompletedColor" : "ActiveColor"];
    }
    public object ConvertBack(object value, Type targetType, 
object parameter, CultureInfo culture)
    {
        return null;
    }
}</pre></li> </ol>
<p>A <code>ValueConverter</code> object is a class that implements <code>IValueConverter</code>. This, in turn, only has two methods defined. The <code>Convert</code> method is called when the view reads data from <code>ViewModel</code> and the <code>ConvertBack</code> method is used when <code>ViewModel</code> gets data from the view. The <code>ConvertBack</code> method is only used for controls that return data from plain text, such as the <code>Entry</code> control.</p>
<p>If we look at the implementation of the <code>Convert</code> method, we’ll notice that any value passed to the<a id="_idIndexMarker317"/> method is of the <code>object</code> type. This is because we don’t know what type the user has bound to the property to which we are adding this <code>ValueConverter</code> class. We may also notice that we fetch colors from a resource file. We could have defined the colors in the code, but this is not recommended. So, instead, we went the extra mile and added them as a global resource to the <code>App.xaml</code> file. Resources are a good thing to take another look at once you have finished this chapter:</p>
<ol>
<li>Open <code>App.xaml</code> in the <code>DoToo</code> project.</li>
<li>Add the following <code>ResourceDictionary</code> element:<pre class="source-code">
&lt;Application ...&gt;
    &lt;Application.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;ResourceDictionary.MergedDictionaries&gt;
                &lt;ResourceDictionary Source="Resources/Styles/Colors.xaml" /&gt;
                &lt;ResourceDictionary Source="Resources/Styles/
Styles.xaml" /&gt;
        &lt;/ResourceDictionary.MergedDictionaries&gt;
<strong class="bold">        &lt;ResourceDictionary&gt;</strong>
<strong class="bold">            &lt;Color x:Key="CompletedColor"&gt; #1C8859 &lt;/Color&gt;</strong>
<strong class="bold">            &lt;Color x:Key="ActiveColor"&gt; #D3D3D3 &lt;/Color&gt;</strong>
<strong class="bold">        &lt;/ResourceDictionary&gt;</strong>
        &lt;/ResourceDictionary&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;</pre></li> </ol>
<p><code>ResourceDictionary</code> can define a wide range of different objects. We only need the two colors that we want to access from <code>ValueConverter</code>. Notice that these can be accessed by the<a id="_idIndexMarker318"/> key given to them and from any o<a id="_idTextAnchor217"/><a id="_idTextAnchor218"/><a id="_idTextAnchor219"/>ther XAML file using a static resource binding.</p>
<p><code>ValueConverter</code> itself is referenced as a static resource but from a local scope.</p>
<h3>Using ValueConverter</h3>
<p>We want to use our <a id="_idIndexMarker319"/>brand-new <code>StatusColorConverter</code> object in <code>MainView</code>. Unfortunately, we have to jump through some hoops to make this happen. We need to do three things:</p>
<ul>
<li>Define a namespace in XAML</li>
<li>Define a local resource that represents an instance of the converter</li>
<li>Declare that we want to use the converter in the binding</li>
</ul>
<p>Let’s start with the namespace:</p>
<ol>
<li>Open <code>Views/MainView.xaml</code>.</li>
<li>Add the following namespace to the page:<pre class="source-code">
&lt;ContentPage  xmlns="http://schemas.microsoft.com/dotnet/2021/
maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/
xaml"
  
<strong class="bold">  </strong>
  x:Class="DoToo.Views.MainView" Title="Do Too!&gt;</pre></li> </ol>
<p>Add a <code>Resource</code> node to the <code>MainView.xaml</code> file:</p>
<ol>
<li>Open <code>Views/MainView.xaml</code>.</li>
<li>Add the <a id="_idIndexMarker320"/>following <code>ResourceDictionary</code> element, shown in bold under the root element of the XAML file:<pre class="source-code">
&lt;ContentPage ...&gt;
<strong class="bold">  &lt;ContentPage.Resources&gt;</strong>
<strong class="bold">    &lt;ResourceDictionary&gt;</strong>
<strong class="bold">        &lt;converters:StatusColorConverter </strong>
<strong class="bold">x:Key="statusColorConverter"/&gt;</strong>
<strong class="bold">    &lt;/ResourceDictionary&gt;</strong>
<strong class="bold">  &lt;/ContentPage.Resources&gt;</strong>
  &lt;ContentPage.ToolBarItems&gt;
    &lt;ToolbarItem Text="Add" Command="{Binding AddItem}" /&gt;
  &lt;/ContentPage.ToolbarItems&gt;
  &lt;Grid ...&gt;
  &lt;/Grid&gt;
&lt;/ContentPage&gt;</pre></li> </ol>
<p>This has the same form as the global resource dictionary, but since this one is defined in <code>MainView</code>, it can only be accessed from there. We could have defined this in the global resource d<a id="_idTextAnchor220"/>ictionary, but it’s usually more efficient to define objects that you only consume in one place as close to that place as possible.</p>
<p>The last step is to add the converter:</p>
<ol>
<li>Locate the <code>BoxView</code> node in the XAML file.</li>
<li>Add the <code>BackgroundColor</code> XAML, which is marked in bold:<pre class="source-code">
&lt;BoxView Grid.RowSpan="2"
<strong class="bold">        BackgroundColor="{Binding Item.Completed,</strong>
<strong class="bold">        Converter={StaticResource statusColorConverter}}"</strong> /&gt;</pre></li> </ol>
<p>What we have done here is bind a <code>bool</code> value to a property that takes a <code>Color</code> object. Right before the data binding takes pla<a id="_idTextAnchor221"/>ce, however, <code>ValueConverter</code> converts the <code>bool</code> valu<a id="_idTextAnchor222"/>e into a<a id="_idIndexMarker321"/> color. This is just one of the many cases where <code>ValueConverter</code> comes in handy. Keep this in mind when you define the GUI.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor223"/>Navigating to an item using a command</h2>
<p>We want to be<a id="_idIndexMarker322"/> able to see the details for a selected to-do list item. When we tap a row, we should navigate to the item in that row.</p>
<p>To do this, we need to add the following code:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code>.</li>
<li>Add the <code>SelectedItem</code> property, the <code>OnSelectedItemChanging</code> event handler, and the <code>NavigateToItemAsync</code> method to the class:<pre class="source-code">
[ObservableProperty]
TodoItemViewModel selectedItem;
partial void OnSelectedItemChanging(TodoItemViewModel value)
{
    if (value == null)
    {
        return;
    }
    MainThread.BeginInvokeOnMainThread(async () =&gt; {
        await NavigateToItemAsync(value);
    });
}
private async Task NavigateToItemAsync(TodoItemViewModel item)
{
    var itemView = services.GetRequiredService&lt;ItemView&gt;();
    var vm = itemView.BindingContext as ItemViewModel;
    vm.Item = item.Item;
    itemView.Title = "Edit todo item";
    await Navigation.PushAsync(itemView);
}</pre></li> </ol>
<p>The <code>SelectedItem</code> property is a property that we will data-bind to <code>ListView</code>. When we select a row in <code>ListView</code>, this property is set to the <code>TodoItemViewModel</code> object that represents that row. We are using the <code>ObservableProperty</code> attribute here to carry out its <code>PropertyChanged</code> magic. However, since the setter is being generated through the <code>ObservableProperty</code> attribute, there is no place to add additional code to the property. Luckily, the <code>ObservableProperty</code> source generator also adds two partial methods that can be implemented. We are using <code>OnSelectedItemChanging</code> to add additional functionality to the setter. The other partial method is <code>OnSelectedItemChanged</code>. <code>OnSelectedItemChanging</code> is called before the property value has changed and <code>OnSelectedItemChanged</code> is called after the value has changed. Remember that you can always view the generated source to learn more about how these attributes are extending your code.</p>
<p>The <code>OnSelectedItemChanging</code> method then calls <code>NavigateToItem</code>, which creates a new <code>ItemView</code> view using the .NET MAUI dependency injection container. At this point, we change the <code>Title</code> of the view from <code>"Add todo item"</code> to <code>"Edit todo item"</code>. We extract <code>ViewModel</code> from the newly created <code>ItemView</code> view and assign the current <code>TodoItem</code> object that <code>TodoItemViewModel</code> contains. Confused? Remember that <code>TodoItemViewModel</code> wraps a <code>TodoItem</code> object, and it is that item that we want to pass to <code>ItemView</code>.</p>
<p>We are not <a id="_idIndexMarker323"/>done yet. Now, we need to data-bind the new <code>SelectedItem</code> property to the right place in the view:</p>
<ol>
<li>Open <code>Views/MainView.xaml</code>.</li>
<li>Locate <code>ListView</code> and add the attributes in bold:<pre class="source-code">
&lt;ListView <strong class="bold">x:Name="ItemsListView"</strong> Grid.Row="1" RowHeight="70"
    ItemsSource="{Binding Items}"
    <strong class="bold">SelectedItem="{Binding SelectedItem}"</strong>&gt;</pre></li> </ol>
<p>The <code>SelectedItem</code> attribute binds the <code>SelectedItem</code> property’s <code>ListView</code> view to the <code>ViewModel</code> property. When the selection o<a id="_idTextAnchor224"/>f an item in <code>ListView</code> changes, the <code>ViewModel</code> property’s <code>SelectedItem</code> property is called and we navigate to the new and exciting views.</p>
<p>The <code>x:Name</code> attribute is for naming <code>ListView</code> because we need to make a small and ugly hack to make this work. <code>ListView</code> stays selected after the navigation is done. When we navigate back, it cannot be selected again until we select another row. To mitigate this, we need to hook up to the <code>ItemSelected</code> event of <code>ListView</code> and reset the selected item directly on <code>ListView</code>. This is not recommended because we shouldn’t have any logic in our views, but sometimes, we have no other choice:</p>
<ol>
<li>Open <code>Views/MainView.xaml.cs</code>.</li>
<li>Add the following code in bold:<pre class="source-code">
public MainView(MainViewModel viewmodel)
{
    InitializeComponent();
    viewmodel.Navigation = <a id="_idTextAnchor225"/>Navigation;
    BindingContext = viewmodel;
<strong class="bold">    ItemsListView.ItemSelected += (s, e) =&gt;</strong>
<strong class="bold">    <a id="_idTextAnchor226"/>    ItemsListView.SelectedItem = null;</strong>
}</pre></li> </ol>
<p>We should<a id="_idIndexMarker324"/> now be able to navigate to an item in the list. Next, we will mark it as complete.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor227"/>Marking an item as complete using a command</h2>
<p>We need to add a <a id="_idIndexMarker325"/>functionality that allows us to toggle items between <code>complete</code> and <code>active</code>. It is possible to navigate to the detailed view of the to-do list item, but this is too much work for a user. Instead, we’ll add a <code>ContextAction</code> item to <code>ListView</code>. In iOS, for example, this is accessed by swiping left on a row:</p>
<ol>
<li>Open <code>ViewModel/TodoItemViewModel.cs</code>.</li>
<li>Add a <code>using</code> statement for <code>CommunityToolkit.Mvvm.Input</code>.</li>
<li>Add a command to toggle the status of the item and a piece of text that describes the status:<pre class="source-code">
[RelayCommand]
void ToggleCompleted()
{
    Item.Completed = !Item.Completed;
    ItemStatusChanged?.Invoke(this, new EventArgs());
}</pre></li> </ol>
<p>Here, we have added a command for toggling the state of an item. When executed, it inverses the current state and raises the <code>ItemStatusChanged</code> event so that subscribers are notified. To change the text of the context action button depending on the status, we added a <code>StatusText</code> property. This is not recommended practice because we are adding code that only exists because of a specific UI case to <code>ViewModel</code>. Ideally, this<a id="_idIndexMarker326"/> would be handled by the view, perhaps by using <code>ValueConverter</code>. To save us from having to implement these steps, however, we have left it as a string property:</p>
<ol>
<li>Open <code>Views/MainView.xaml</code>.</li>
<li>Locate the <code>ListView.ItemTemplate</code> node and add the following <code>ViewCell.ContextActions</code> node:<pre class="source-code">
&lt;ListView.ItemTemplate&gt;
  &lt;DataTemplate&gt;
    &lt;ViewCell&gt;
<strong class="bold">      &lt;ViewCell.ContextActions&gt;</strong>
<strong class="bold">        &lt;MenuItem Text="{Binding StatusText}" Command="{Binding </strong>
<strong class="bold">ToggleCompletedCommand}" /&gt;</strong>
<strong class="bold">      &lt;/<a id="_idTextAnchor228"/><a id="_idTextAnchor229"/>ViewCell.ContextActions&gt;</strong>
      &lt;Grid Padding="15,10"&gt;
      ...
      &lt;/Grid&gt;
    &lt;/ViewCell&gt;
  &lt;/DataTemplate&gt;
&lt;/ListView.ItemTemplate&gt;</pre></li> </ol>
<h2 id="_idParaDest-63"><a id="_idTextAnchor230"/>Creating the filter toggle function using a command</h2>
<p>We want to be <a id="_idIndexMarker327"/>able to toggle<a id="_idIndexMarker328"/> between viewing active items only and all the items. We will create a simple mechanism to do this.</p>
<p>Hook up the changes in <code>MainViewModel</code> as follows:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code> and locate <code>ItemStatusChangeMethod</code>.</li>
<li>Add the implementation to the <code>ItemStatusChanged</code> method and a property called <code>ShowAll</code> to control the filtering:<pre class="source-code">
private void ItemStatusChanged(object sender, EventArgs e)
{
<strong class="bold">    i<a id="_idTextAnchor231"/>f (sender is TodoItemViewModel item)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (!ShowAll &amp;&amp; item.Item.Completed)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            Items.Remove(item);</strong>
<strong class="bold">        }</strong>
<strong class="bold">        Task.Run(async () =&gt; await repository.UpdateItemAsync(item.Item));</strong>
<strong class="bold">    }</strong>
}
<strong class="bold">[ObservableProperty]</strong>
<strong class="bold">bool showAll;</strong></pre></li> </ol>
<p>The <code>ItemStatusChanged</code> event handler is triggered when we use the context action from the previous section. Since the sender is always an object, we try to cast it to <code>TodoItemViewModel</code>. If this is successful, we check whether we can remove it from the list if <code>ShowAll</code> is not <code>true</code>. This is a small optimization; we could have called <code>LoadData</code> and reloaded the entire list, but since the <code>Items</code> list is set to <code>ObservableCollection</code>, it communicates to <code>ListView</code> that one item has been removed from the list. We also call the repository to update the item to persist the change of status.</p>
<p>The <code>ShowAll</code> property is what controls which state our filter is in. We need to adjust the <code>LoadData</code> method to reflect this:</p>
<ol>
<li>Locate the <code>Load</code> method in <code>MainViewModel</code>.</li>
<li>Add the<a id="_idIndexMarker329"/> following<a id="_idIndexMarker330"/> lines of code marked in bold:<pre class="source-code">
private async Task LoadDataAsync()
{
    var items = await repository.GetItemsAsync();
<strong class="bold">    if (!ShowAll)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        items = items.Where(x =&gt; x.Completed == false).ToList();</strong>
<strong class="bold">    }</strong>
    var itemViewModels = items.Select(i =&gt; 
CreateTodoItemViewModel(i));
    Items = new ObservableCollection&lt;TodoItemViewModel&gt; (itemViewModels);
}</pre></li> </ol>
<p>If <code>ShowAll</code> is <code>false</code>, we limit the content of the list to the items that have not been completed. We can do this either by having two methods, <code>GetAllItems()</code> and<a id="_idTextAnchor232"/> <code>GetActiveItems()</code>, or by using a <code>filter</code> argument that can pass to <code>GetItemsAsync()</code>. Take a minute to think about how we could implement this.</p>
<p>Let’s add the code that toggles the filter:</p>
<ol>
<li>Open <code>ViewModels/MainViewModel.cs</code>.</li>
<li>Add the <code>FilterText</code> and <code>ToggleFilterAsync</code> properties:<pre class="source-code">
[RelayCommand]
private async Task ToggleFilterAsync()
{
    ShowAll = !ShowAll;
    await LoadDataAsync();
}</pre></li> </ol>
<p>The <code>ShowAll</code> property is a Boolean value, and that does not display well in a human-readable form. We <a id="_idIndexMarker331"/>will use <a id="_idIndexMarker332"/>another <code>ValueConverter</code> to change the status into a human-readable form:</p>
<ol>
<li>Create a new class in the <code>Converters</code> folder named <code>FilterTextConverter.cs</code>.</li>
<li>Add the following code:<pre class="source-code">
using System;
using System.Globalization;
internal class FilterTextConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object 
parameter, CultureInfo culture)
    {
        return (bool)value ? "All" : "Active";
    }
    public object ConvertBack(object value, Type targetType, 
object parameter, CultureInfo culture)
    {
        return null;
    }
}</pre></li> </ol>
<p><code>FilterTextConverter</code> is very similar to the previous converter we created. The difference is that in the <code>Convert</code> method, we convert a <code>bool</code> value into the <code>"All"</code> or <code>"Active"</code> string. This converter will be used in the view to change the value of <code>ShowAll</code> into a value more suitable for display in the user interface.</p>
<p>The logic for the <code>ToggleFilterAsync</code> command is a simple inversion of the state and then a call to <code>LoadDataAsync</code>. This, in turn, causes the list to be reloaded.</p>
<p>Before we can <a id="_idIndexMarker333"/>filter the items, we <a id="_idIndexMarker334"/>need to hook up the filter button to <code>Command</code> and <code>Converter</code>:</p>
<ol>
<li>Open <code>Views/MainView.xaml</code>.</li>
<li>Add the following highlighted entry to <code>ResourceDictionary</code>:<pre class="source-code">
&lt;ResourceDictionary&gt;
    &lt;converters:StatusColorConverter  x:Key=
"statusColorConverter"/&gt;
    <strong class="bold">&lt;converters:FilterTextConverter </strong>
<strong class="bold">x:Key="filterTextConverter"/&gt;</strong>
&lt;/ResourceDictionary&gt;</pre></li> <li>Locate the button that controls the filter (the only button in the file).</li>
<li>Adjust your code to reflect the following code:<pre class="source-code">
&lt;Button <strong class="bold">Text="{Binding ShowAll,Converter={StaticResource </strong>
<strong class="bold">filterTextConverter}, StringFormat='Filter: {0}'}<a id="_idTextAnchor233"/>"</strong>
<strong class="bold">    Command="{Binding ToggleFilter<a id="_idTextAnchor234"/>AsyncCommand}"</strong> /&gt;</pre></li> </ol>
<p>We have now finished with this feature! However, our app isn’t very attractive; we’ll deal with<a id="_idIndexMarker335"/> this<a id="_idIndexMarker336"/> in the following section.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor235"/>Laying out the contents</h1>
<p>This last section is <a id="_idIndexMarker337"/>about making<a id="_idTextAnchor236"/><a id="_idTextAnchor237"/><a id="_idTextAnchor238"/> the app look a bit nicer. We will just scratch the surface of the possibilities here, but this should give you some ideas about how styling works.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor239"/>Setting an application-wide background color</h2>
<p>Styles are a great<a id="_idIndexMarker338"/> way of applying<a id="_idIndexMarker339"/> styling to elements. They can be applied either to all elements of a type or the elements referenced by a key if you add an <code>x:Key</code> attribute:</p>
<ol>
<li>Open <code>App.xaml</code>.</li>
<li>Add the following XAML, which is in bold, to the file:<pre class="source-code">
&lt;ResourceDictionary&gt;
<strong class="bold">  &lt;Style TargetType="NavigationPage"&gt;</strong>
<strong class="bold">    &lt;Setter Property="BarBackgroundColor" Value="#A25EBB" /&gt;</strong>
<strong class="bold">    &lt;Setter Property="BarTextColor" Value="#FFFFFF" /&gt;</strong>
<strong class="bold">  &lt;/Style&gt;</strong>
<strong class="bold">  &lt;Style x:Key="FilterButton" TargetType="Button"&gt;</strong>
<strong class="bold">    &lt;Setter Property="Margin" Value="15" /&gt;</strong>
<strong class="bold">    &lt;Setter Property="BorderWidth" Value="1" /&gt;</strong>
<strong class="bold">    &lt;Setter Property="BorderColor" Value="Silver" /&gt;</strong>
<strong class="bold">    &lt;Setter Property="TextColor" Value="Black" /&gt;</strong>
<strong class="bold">  &lt;/Style&gt;</strong>
  &lt;Color x:Key="CompletedColor"&gt;#1C8859&lt;/Color&gt;
  &lt;Color x:Key="ActiveColor"&gt;#D3D3D3&lt;/Color&gt;
&lt;/ResourceDictionary&gt;</pre></li> </ol>
<p>The first style we will apply is a new background color and text color to the navigation bar. The second style will be applied to the filter button. We can define a style by setting <code>TargetType</code>, which tells .NET MAUI which type of object this style can be applied to. We can then add one or more properties that we want to set. The result will be the same as if we had added these properties directly to the element in the XAML code.</p>
<p>Styles that lack the <code>x:Key<a id="_idTextAnchor240"/></code> attribute are applied to all instances of the type defined in <code>TargetType</code>. Styles that have a <a id="_idTextAnchor241"/>key must be explicitly assigned in the XAML of the user interface. We will<a id="_idIndexMarker340"/> see examples <a id="_idIndexMarker341"/>of this when we define the filter button in the next section.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor242"/>Laying out the MainView and ListView items</h2>
<p>In this section, we <a id="_idIndexMarker342"/>will imp<a id="_idTextAnchor243"/><a id="_idTextAnchor244"/><a id="_idTextAnchor245"/>rove the appearance<a id="_idIndexMarker343"/> of <code>MainView</code> and <code>ListView</code>. Open <code>Views/MainView.xaml</code> and<a id="_idIndexMarker344"/> apply the<a id="_idIndexMarker345"/> changes in bold in the XAML code in each of the following sections.</p>
<h3>The ﬁlter button</h3>
<p>The filter button<a id="_idIndexMarker346"/> allows us to toggle the state of the list to show only the active to-do items or all the to-do items. Let’s style it to make it stand out a bit in the layout:</p>
<ol>
<li>Find the filter button.</li>
<li>Make the following changes:<pre class="source-code">
&lt;Button <strong class="bold">Style="{DynamicResource FilterButton}"</strong>
        Text="{Binding ShowAll,Converter={StaticResource 
filterTextConverter}, StringFormat='Filter: {0}'}"
        <strong class="bold">BackgroundColor="{DynamicResource ActiveColor}"</strong>
        <strong class="bold">TextColor="Black"</strong>
        Command="{Binding ToggleFilterCommand}"&gt;
<strong class="bold">  &lt;Button.Triggers&gt;</strong>
<strong class="bold">    &lt;DataTrigger TargetType="Button" Binding="{Binding ShowAll}" </strong>
<strong class="bold">Value="True"&gt;</strong>
<strong class="bold">      &lt;Setter Property="BackgroundColor" Value="{DynamicResource </strong>
<strong class="bold">CompletedColor}" /&gt;</strong>
<strong class="bold">      &lt;Setter Property="TextColor" Value="White" /&gt;</strong>
<strong class="bold">    &lt;/DataTrigger&gt;</strong>
<strong class="bold">  &lt;/Button.Triggers&gt;</strong>
&lt;/Button&gt;</pre></li> </ol>
<p>The style is applied <a id="_idIndexMarker347"/>using <code>DynamicResource</code>. Anything defined in a resource dictionary, either in the <code>App.xaml</code> file or in the local XAML file, is accessible through it. Then, we set <code>BackgroundColor</code>, again setting <code>DynamicResource</code> to <code>ActiveColor</code> and <code>TextColor</code> to <code>Black</code>.</p>
<p>The <code>Button.Triggers</code> node is a useful feature. We can define several types of triggers that fire when certain criteria are met. In this case, we use a data trigger that checks whether the value of <code>ShowAll</code> changes to <code>true</code>. If it do<a id="_idTextAnchor246"/>es, we set <code>TextColor</code> <a id="_idTextAnchor247"/>to white <a id="_idIndexMarker348"/>and <code>BackgroundColor</code> to <code>CompletedColor</code>. The coolest part is that when <code>ShowAll</code> becomes <code>false</code> again, it switches back to whichever value it was before.</p>
<h3>Touching up ListView</h3>
<p><code>ListView</code> could use a <a id="_idIndexMarker349"/>couple of minor changes. The first change is formatting the due date string to a more human-readable format and the second is changing the color of the <code>Completed</code> label to a nice green tint:</p>
<ol>
<li>Open <code>Views/MainView.xaml</code>.</li>
<li>Locate the labels that bind <code>Item.Due</code> and <code>Item.Completed</code> in <code>ListView</code>:<pre class="source-code">
&lt;Label Grid.Column="1" Grid.Row="1"
      Text="<strong class="bold">{Binding Item.Due, StringFormat='{0:MMMM d, yyyy}'}</strong>"
      FontSize="Micro" /&gt;
&lt;Label Grid.Column="1" Grid.Row="1"
      HorizontalTextAlignment="End"
      Text="Completed"
      IsVisible="{Binding Item.Completed}"
      FontSize="Micro"
      <strong class="bold">TextColor="{StaticResource CompletedColor}</strong>" /&gt;</pre></li> </ol>
<p>Here, we added a formatting string to the binding to format the date using a specific format. In this case, we used the <code>0:MMMM d, yyyy</code> format, which will display the date as a string in the format of, for example, May 5, 2020.</p>
<p>We also added a text color to the <code>Completed</code> label that is only visible if an item is completed. We did this by referencing our dictionary in <code>App.xaml</code>.</p>
<p>Now that all the code<a id="_idTextAnchor248"/> changes are complete, run our application. Here is a small gallery of screenshots that should match your application:</p>
<div><div><img alt="Figure 2.15 – DoToo on Android" src="img/Figure_2.15_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – DoToo on Android</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor249"/>Summary</h1>
<p>You should now have a good grasp of all the steps involved in creating a .NET MAUI app from scratch. In this chapter, we learned about the project structure and the important files in a newly created project. We talked about dependency injection and learned the basics of MVVM by creating all the views and the <code>ViewModel</code> classes needed. We also covered data storage in SQLite to persist data on our device in a fast and secure way. Using the knowledge you’ve gained from this chapter, you should now be able to create the backbone of any app you’d like.</p>
<p>The next chapter will focus on upgrading an existing Xamarin.Forms application to .NET MAUI.</p>
</div>
</body></html>