<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Advanced Thread Processing</h1></div></div></div><p>In this chapter, we will continue to learn about the <code class="literal">Thread</code> class and thread processing. In the previous chapter, we began discussing the <code class="literal">Thread</code> class and how to create and use threads. Now that we have begun learning about the <code class="literal">Thread</code> class, in this chapter we will take the discussion to the next level. We'll study new ways to keep control over concurrent threads and will continue to improve our parallel programming capabilities working with more challenging problems to solve. After following the instructions in this chapter, we will be able to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Break down a problem into pieces that can be run concurrently</li><li class="listitem" style="list-style-type: disc">Create highly independent blocks of code to run in multiple threads avoiding many concurrency problems</li><li class="listitem" style="list-style-type: disc">Use flags in multiple threads for coordination</li><li class="listitem" style="list-style-type: disc">Use techniques to have complete control over asynchronous and synchronous execution of threads</li><li class="listitem" style="list-style-type: disc">Use techniques to use multithreading in non-thread-safe components</li><li class="listitem" style="list-style-type: disc">Perform error handling in a multithreaded application</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Pipelining</h1></div></div></div><p>Pipelining is a common design<a id="id211" class="indexterm"/> pattern used in multithreaded applications. In <a class="link" href="ch09.html" title="Chapter 9. Pipeline and Producer-consumer Design Patterns">Chapter 9</a>, <em>Pipeline and Producer-consumer Design Patterns</em>, we will cover this in detail. But I wanted to briefly introduce it here, because we will use it in the examples in this chapter. Pipelining is a technique to solve a problem using concurrency. First, you divide the problem into parts that have to be executed in sequence with parts that can be executed in parallel. Then you implement the parallel parts using threads or tasks and run them concurrently to improve performance instead of running all of the functionality in sequence.</p><p>So far, we have worked with the <code class="literal">BackgroundWorker</code> component and the <code class="literal">Thread</code> class to create multithreaded applications. Parallel programming allowed us to achieve incredible performance enhancements and better UI feedback. How can we use threading and the <code class="literal">Thread</code> class to divide image-processing algorithms into many concurrent blocks of code? In this design pattern, we will take a problem, divide it into multiple pieces that we can tackle concurrently, and then assemble the pieces in the end to a final result.</p><p>In <a class="link" href="ch09.html" title="Chapter 9. Pipeline and Producer-consumer Design Patterns">Chapter 9</a>, <em>Pipeline and Producer-consumer Design Patterns</em>, we will learn different common design patterns for tackling common problems in a multithreaded approach. But without going into too much detail, in this chapter, we will perform a simple form of pipelining to accomplish our task:</p><div><img src="img/8321EN_04_01.jpg" alt="Pipelining"/></div><p>C# offers many techniques for working with images and bitmaps. However, many of them are not thread-safe. We cannot run many concurrent threads changing pixels in the same instance of the <code class="literal">Bitmap</code> (<code class="literal">System.Drawing.Bitmap</code>) class. Nevertheless, as we learned in the previous chapters, in order to apply parallel algorithms, we can avoid the problems instead of finding difficult solutions to them by using different design patterns such as <strong>pipelining</strong>. We <a id="id212" class="indexterm"/>can split the original bitmap into a number of completely independent bitmaps. Each thread can work with its independent bitmap instance safely. We can develop an algorithm that performs image manipulation of bitmap pixels and then, with great performance improvements over the single-threaded one, perform this algorithm in parallel on many bitmaps. Besides, we can also add code to pause and then restart the threads. The performance results will depend upon the number of cores or processors available in the computer (which we discussed in <a class="link" href="ch01.html" title="Chapter 1. Understanding Multiprocessing and Multiple Cores">Chapter 1</a>, <em>Understanding Multiprocessing and Multiple Cores</em>) in which we run the application.</p><p>By using the <code class="literal">Thread</code> class and the pipelining design pattern, we can achieve incredible performance improvements, an impressive user experience, and great scalability with reasonable programming efforts. The application we will build will be scalable to any size bitmap image and will be able to increase performance automatically as more core processors are added to the hardware without any coding changes!</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Explaining pipelining using an image processing application</h2></div></div></div><p>For our example in this chapter, we will use a Windows Forms application to perform image processing. We can do this in a<a id="id213" class="indexterm"/> <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) application, but I find<a id="id214" class="indexterm"/> that doing bitmap and pixel-level manipulation is more straightforward in the GDI-based <code class="literal">System.Drawing</code> library than the WPF-based System, Windows Media library. This same application can be redone using the <code class="literal">BitmapImage</code> and <code class="literal">CroppedBitmap</code> <a id="id215" class="indexterm"/>classes using the same core logic.</p><p>Image processing on large image files is a good candidate for a multithreaded solution because you can break the image into pieces and process each piece concurrently and then reassemble the pieces. In this example, we will take a bitmap image from NASA, break it into smaller bitmap files, search each bitmap for "old star", and then reassemble the bitmaps back into one large bitmap image file.</p><p>You will use your parallel programming skills to develop an application that has to detect the older stars from huge infrared portraits obtained by NASA's Spitzer Space Telescope. In the following screenshot, you can see a <a id="id216" class="indexterm"/>wispy star-forming region, called <strong>W5</strong>:</p><div><img src="img/8321EN_04_02.jpg" alt="Explaining pipelining using an image processing application"/><div><p>Image by NASA/JPL-Caltech/Harvard-Smithsonian CfA</p></div></div><p>In this portrait, the oldest stars can be seen as blue dots, especially in the center of the two hollow cavities. The white knotty areas are where the youngest stars are forming.</p><p>This image<a id="id217" class="indexterm"/> contains some of the best evidence yet for the triggered star formation theory. Scientists analyzing the photo have been able to show that the ages of the stars become progressively and systematically younger with distance from the center of the cavities.</p><p>You have to work<a id="id218" class="indexterm"/> on a very fast and efficient algorithm for detection of old stars, capable of changing the pixel colors of the old stars in the huge image to make them more visible to the scientists. They want you to use a fine-tuned, multithreading application that is capable of working with as many threads as the number of cores available in the computer where the star detection algorithm is being executed.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>How to do it</h2></div></div></div><p>To do this, we are going to build a new C# application and put the program logic into methods to detect old stars in any bitmap and prepare the bitmap input for many threads:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new C# project using the Windows Application template in Visual Studio. Use <code class="literal">OldStarsFinder</code> as the project's name.</li><li class="listitem">Add the following lines of code at the beginning of the form class definition (as we are going to use the <code class="literal">System.Threading.Thread</code> and <code class="literal">System.Drawing.Imaging</code> classes):<div><pre class="programlisting">using System.Threading;
using System.Drawing.Imaging;</pre></div></li><li class="listitem">Add the<a id="id219" class="indexterm"/> following lines in the form class definition to declare three new private variables:<div><pre class="programlisting">// The number of processors or cores available in the computer for this application
private int priProcessorCount = Environment.ProcessorCount;
// The bitmaps list
private List&lt;Bitmap&gt; prloBitmapList;
// The long list with the old stars count
private List&lt;long&gt; prliOldStarsCount;</pre></div></li><li class="listitem">Add the following function, <code class="literal">CropBitmap</code>. It will crop the bitmap received as a parameter and<a id="id220" class="indexterm"/> return the portion of the original defined by the <code class="literal">Rectangle</code> instance, <code class="literal">proRectangle</code>. This will allow us to split up any large image into a set of smaller images. The number in the set will correspond to the number of cores in the machine the application is running. This way we can maximize performance by using every core simultaneously to process the large image:<div><pre class="programlisting">private Bitmap CropBitmap(Bitmap proBitmap, Rectangle proRectangle)
{
// Create a new bitmap copying the portion of the original defined by proRectangle and keeping its PixelFormat
Bitmap loCroppedBitmap = proBitmap.Clone(proRectangle,proBitmap.PixelFormat);
// Return the cropped bitmap
return loCroppedBitmap;
}</pre></div></li><li class="listitem">Add the following function, <code class="literal">IsOldStar</code>. It will compare the pixel hue, saturation, and brightness to determine if their levels correspond to the typical color range offered by an old star in the infrared portraits:<div><pre class="programlisting">public bool IsOldStar(Color poPixelColor)
{
// Hue between 150 and 258
// Saturation more than 0.10
// Brightness more than 0.90
return ((poPixelColor.GetHue() &gt;= 150) &amp;&amp; (poPixelColor.GetHue() &lt;= 258) &amp;&amp; (poPixelColor.GetSaturation() &gt;= 0.10) &amp;&amp;(poPixelColor.GetBrightness() &lt;= 0.90)); 
}</pre></div></li><li class="listitem">Add the following procedure, <code class="literal">ThreadOldStarsFinder</code>. It will iterate through each<a id="id221" class="indexterm"/> pixel in the corresponding bitmap for the thread that launches it and count<a id="id222" class="indexterm"/> the old stars:<div><pre class="programlisting">private void ThreadOldStarsFinder(object  poThreadParameter)
{
// Retrieve the thread number received in objectpoThreadParameter
int liThreadNumber = (int)poThreadParameter;
// The pixel matrix (bitmap) row number (Y)
int liRow;
// The pixel matrix (bitmap) col number (X)
int liCol;
// The pixel color
Color loPixelColor;
// Get my bitmap part from the bitmap list
Bitmap loBitmap = prloBitmapList[liThreadNumber];

// Reset my old stars counter
prliOldStarsCount[liThreadNumber] = 0;
// Iterate through each pixel matrix (bitmap) row
for (liRow = 0; liRow &lt; loBitmap.Height; liRow++)
{
// Iterate through each pixel matrix (bitmap) cols
for (liCol = 0; liCol &lt; loBitmap.Width; liCol++)
{
// Get the pixel color for liCol and liRow
loPixelColor = loBitmap.GetPixel(liCol, liRow);
if (IsOldStar(loPixelColor))
{
// The color range corresponds to an old star
// Change its color to a pure blue
loBitmap.SetPixel(liCol, liRow, Color.Blue);
// Increase the old stars counter
prliOldStarsCount[liThreadNumber]++;
}
}
}
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>How it works</h2></div></div></div><p>The code required<a id="id223" class="indexterm"/> to find and count the potential old stars in any large bitmap portrait is now held in named functions and procedures, already prepared for dynamically created concurrent threads. We have laid the groundwork to<a id="id224" class="indexterm"/> implement this function in a Pipeline design pattern.</p><p>Why do we have to create a <code class="literal">CropBitmap</code> function? That is because we cannot access a single <code class="literal">Bitmap</code> instance pixel matrix from many different concurrent threads. If we do so, we will get an <code class="literal">InvalidOperationException</code>, as GDI+ is not prepared for multithreaded access.</p><p>We must split the original <code class="literal">Bitmap</code> into as many independent portions as the number of concurrent threads that will be working on it. The <code class="literal">CropBitmap</code> function will allow us to obtain a specific portion of a <code class="literal">Bitmap</code> instance and generate a list of new <code class="literal">Bitmap</code> instances (<code class="literal">prloBitmapList</code>).</p><p>As we have learned so far, there are many problems related to multithreaded applications and parallel algorithms. Since there are many threads running concurrently, we must be very careful when changing the values of variables in different threads. The best solution to such concurrency problems is <em>avoiding them</em> or preventing<a id="id225" class="indexterm"/> them via <strong>synchronization mechanisms</strong>. However, synchronization mechanisms have to be used very carefully, because they can decrease performance and generate too many context switches. Also, using them can introduce potential bugs that can be very difficult to debug.</p><p>How can we avoid the concurrency problems? It is very simple. As much as possible, we have to make each thread independent of the other concurrent threads working in the same global portion of resources. As we will see in later chapters, the Task Parallel Library is convenient for defining tasks and then running the tasks in parallel. In this case, the processing of each bitmap can be a task.</p><p>Splitting the original bitmap using the simple <code class="literal">CropBitmap</code> function avoids many conflicts related to concurrency that would have otherwise been very complex to troubleshoot. As each thread is going to work with its own bitmap, we are avoiding a potentially dangerous problem. This is one of the keys to developing multithreaded applications—properly segmenting work into pieces that can run in parallel. Dividing the bitmap image is a perfect example.</p><p>Another potential problem is counting the total number of old stars detected in the huge infrared bitmap portrait. If we used a shared member variable, we might have locking problems. If we have many threads concurrently changing the same variable value (at the same time), we will have to lock that variable each time its value is incremented. Locking a variable implies context switches and hence reduced performance. For this reason, we use the <code class="literal">long</code> list <code class="literal">prliOldStarsCount</code>. There is one counter for each thread, and we will obtain the total sum adding the <em>n</em> long values (<code class="literal">prliOldStarsCount</code>) to a new variable (where <em>n</em> is the number of star finder threads).</p><p>This way, we avoid locks as each thread has its own independent counter and we achieve a better performance compared to a solution that would use the confusing and complex locks.</p><p>In order to<a id="id226" class="indexterm"/> process an image in many concurrent threads, we must divide it into as many independent portions as the number of threads that will be running. As we have seen earlier, the <code class="literal">CropBitmap</code> function offers this utility.</p><p>This change<a id="id227" class="indexterm"/> in the image processing algorithm has its costs, and is not free. In this case, we will be counting stars on a per-pixel basis. However, when we must apply other more complex algorithms, we must consider many important additional changes to the basic code. We will continue with this topic later in this chapter.</p><p>Once each image part is processed, we must collect the results and recompose the original image with the changes made to its pixels.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Understanding the pixels' color compositions</h2></div></div></div><p>The infrared bitmap portrait does<a id="id228" class="indexterm"/> not have an exact blue (red = 0, green = 0, and blue = 255) color for an old star. There is a complex technique used to determine a star's age according to color ranges. This is easy to understand for human<a id="id229" class="indexterm"/> beings, but difficult for computers.</p><p>However, it is simple to generate an algorithm obtaining the following three components of a <code class="literal">Color</code> (<code class="literal">System.Drawing.Color</code>) instance:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Hue</strong>: This is <a id="id230" class="indexterm"/>obtained by the<a id="id231" class="indexterm"/> <code class="literal">GetHue()</code> method</li><li class="listitem" style="list-style-type: disc"><strong>Saturation</strong>: This is<a id="id232" class="indexterm"/> obtained by the<a id="id233" class="indexterm"/> <code class="literal">GetSaturation()</code> method (from 0.01 to 1.00)</li><li class="listitem" style="list-style-type: disc"><strong>Brightness</strong>: This<a id="id234" class="indexterm"/> is obtained by the<a id="id235" class="indexterm"/> <code class="literal">GetBrightness()</code> method (from 0.01 to 1.00)</li></ul></div><p>Using these color components, we can apply the following rules to determine whether a pixel in the infrared bitmap portrait corresponds to a potential old star or not:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hue is between 150 and 258</li><li class="listitem" style="list-style-type: disc">Saturation is more than 10% (0.10)</li><li class="listitem" style="list-style-type: disc">Brightness is more than 90% (0.90)</li></ul></div><p>It is easier to <a id="id236" class="indexterm"/>work with hue, saturation, and brightness values than with red, green, and blue values in order to determine an old star.</p><p>The <code class="literal">IsOldStar</code> function receives a <a id="id237" class="indexterm"/>
<code class="literal">Color</code> instance as a parameter and returns the results of applying the aforementioned rules to its hue, saturation, and brightness, as shown in the following lines of code:</p><div><pre class="programlisting">return ((poPixelColor.GetHue() &gt;= 150)
     &amp;&amp; (poPixelColor.GetHue() &lt;= 258)
     &amp;&amp; (poPixelColor.GetSaturation() &gt;= 0.10)
     &amp;&amp; (poPixelColor.GetBrightness() &lt;= 0.90));
</pre></div><p>This function is called for each pixel in the infrared bitmap portrait, and it returns a <code class="literal">bool</code> value.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Pausing and restarting threads</h1></div></div></div><p>It is important in a lot of cases to coordinate and wait on threads. Take, for example, a pipelining design. Once we start a group of concurrent threads, we then need to wait on them all to finish, collate their results, and move onto the nonconcurrent section. We need to know when threads finish and what their results are, so we can determine how to proceed.</p><p>There are several <a id="id238" class="indexterm"/>ways to coordinate and wait between threads. In the following example, we will show how you can check to see if a thread is still alive and processing and then wait on all of the threads to complete their bitmap processing work before we <a id="id239" class="indexterm"/>continue the rest of the application and reassemble the bitmap pieces.</p><p>In this example, we will use<a id="id240" class="indexterm"/> the <code class="literal">IsAlive</code> method to check the thread and then pause the main thread with the <code class="literal">Sleep</code> method for a period of time before checking again. This is a common design pattern to coordinate work between threads and monitor threads to know when they are finished.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>How to do it</h2></div></div></div><p>Now, we are going to<a id="id241" class="indexterm"/> create the UI and make some changes to create multiple threads dynamically to process each portion of a bitmap. In order to accomplish this, we must<a id="id242" class="indexterm"/> share data between the various threads, as we learned in the previous chapters. Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Stay in the project, <code class="literal">OldStarsFinder</code>.</li><li class="listitem">Open Windows Form, <code class="literal">Form1</code> (<code class="literal">frmStarsFinder</code>), in the form designer; add the following controls and align them as shown in the following screenshot:<div><img src="img/8321EN_04_03.jpg" alt="How to do it"/></div><p>The following are the controls:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One picture<a id="id243" class="indexterm"/> box (<code class="literal">picStarsBitmap</code>) showing one <a id="id244" class="indexterm"/>of the infrared portraits obtained <a id="id245" class="indexterm"/>by NASA's Spitzer Space Telescope (you can find many of them at <a class="ulink" href="http://www.nasa.gov">www.nasa.gov</a> or <a class="ulink" href="http://www.nasa.gov/multimedia/imagegallery/">http://www.nasa.gov/multimedia/imagegallery/</a>), with its <code class="literal">SizeMode</code> property set to <code class="literal">StretchImage</code>.</li><li class="listitem" style="list-style-type: disc">One button showing a star and its <code class="literal">Text</code> property set to <code class="literal">Find old star</code> (<code class="literal">butFindOldStars</code>). This button will start multiple old stars finder threads.</li></ul></div></li><li class="listitem">Add the following<a id="id246" class="indexterm"/> lines in the form's class definition to declare two new private variables:<div><pre class="programlisting">    // The threads list
    private List&lt;Thread&gt; prloThreadList;
    // The original huge infrared bitmap portrait
    Bitmap proOriginalBitmap;</pre></div></li><li class="listitem">Add the following<a id="id247" class="indexterm"/> procedure, <code class="literal">WaitForThreadsToDie</code>. It will make the main thread sleep in order to wait until the many concurrent threads finish their work:<div><pre class="programlisting">    private void WaitForThreadsToDie()
    {
        // A bool flag
        bool lbContinue = true;
        int liDeadThreads = 0;
        int liThreadNumber;
        while (lbContinue)
        {
            for (liThreadNumber = 0; liThreadNumber&lt; priProcessorCount; liThreadNumber++)
            {
                if (prloThreadList[liThreadNumber].IsAlive)
                {
                    // One of the threads is still alive, 
                    // exit the for loop and sleep 100 
                    // milliseconds
                    break;
                }
                else
                {
                    // Increase the dead threads count
                    liDeadThreads++;
                }
            }
            if (liDeadThreads == priProcessorCount)
            {
                // All the threads are dead, exit the while 
                // loop
                break;
            }
            Thread.Sleep(100);
            liDeadThreads = 0;
        }
    }</pre></div></li><li class="listitem">Add the following<a id="id248" class="indexterm"/> procedure, <code class="literal">ShowBitmapWithOldStars</code>. It will rebuild the bitmap adding each previously separated <a id="id249" class="indexterm"/>portion:<div><pre class="programlisting">    private void ShowBitmapWithOldStars()
    {
        int liThreadNumber;
        // Each bitmap portion
        Bitmap loBitmap;
        // The starting row in each iteration
        int liStartRow = 0;

        // Calculate each bitmap's height
        int liEachBitmapHeight = ((int)(proOriginalBitmap.Height / priProcessorCount)) + 1;

        // Create a new bitmap with the whole width and 
        // height
        loBitmap = new Bitmap(proOriginalBitmap.Width,proOriginalBitmap.Height);
        Graphics g = Graphics.FromImage((Image)loBitmap);
        g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;

        for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount; liThreadNumber++)
        {
            // Draw each portion in its corresponding 
            // absolute starting row
            g.DrawImage(prloBitmapList[liThreadNumber], 0,liStartRow);
            // Increase the starting row
            liStartRow += liEachBitmapHeight;
        }
        // Show the bitmap in the PictureBox picStarsBitmap
        picStarsBitmap.Image = loBitmap;

        g.Dispose();
    }</pre></div></li><li class="listitem">Open the <code class="literal">Click</code> event in the <a id="id250" class="indexterm"/>button, <code class="literal">butFindOldStars</code>, and enter the following<a id="id251" class="indexterm"/> code:<div><pre class="programlisting">    proOriginalBitmap = new Bitmap(picStarsBitmap.Image);

    // Thread number
    int liThreadNumber;
    // Create the thread list; the long list and the bitmap list
    prloThreadList = new List&lt;Thread&gt;(priProcessorCount);
    prliOldStarsCount = new List&lt;long&gt;(priProcessorCount);
    prloBitmapList = new List&lt;Bitmap&gt;(priProcessorCount);

    int liStartRow = 0;

    int liEachBitmapHeight = ((int)(proOriginalBitmap.Height / priProcessorCount)) + 1;

    int liHeightToAdd = proOriginalBitmap.Height;
    Bitmap loBitmap;

    // Initialize the threads
    for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount; liThreadNumber++)
    {
        // Just to occupy the number
        prliOldStarsCount.Add(0);

        if (liEachBitmapHeight &gt; liHeightToAdd)
        {
            // The last bitmap height perhaps is less than the other bitmaps height
            liEachBitmapHeight = liHeightToAdd;
        }

        loBitmap = CropBitmap(proOriginalBitmap, new Rectangle(0, liStartRow, proOriginalBitmap.Width,liEachBitmapHeight));
        liHeightToAdd -= liEachBitmapHeight;
        liStartRow += liEachBitmapHeight;
        prloBitmapList.Add(loBitmap);

        // Add the new thread, with a parameterized start 
        // (to allow parameters)
        prloThreadList.Add(new Thread(new ParameterizedThreadStart (ThreadOldStarsFinder)));
    }

    // Now, start the threads
    for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount; liThreadNumber++)
    {
        prloThreadList[liThreadNumber].Start(liThreadNumber);
    }

    WaitForThreadsToDie();

    ShowBitmapWithOldStars();</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Click on the <strong>Old Star Finder</strong> button. After a few seconds (depending on the parallel<a id="id252" class="indexterm"/> processing capabilities of the computer) in the W5 wispy star-forming<a id="id253" class="indexterm"/> region, a huge infrared portrait will be shown with its probable old stars in pure blue, as shown in the following screenshot:<div><img src="img/8321EN_04_04.jpg" alt="How to do it"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>How it works</h2></div></div></div><p>When the user clicks on the <strong>Old Star Finder</strong> button, the process executes in the following manner:</p><div><ol class="orderedlist arabic"><li class="listitem">The<a id="id254" class="indexterm"/> original image is divided into many independent bitmaps. Each portion will be assigned to a different thread.</li><li class="listitem">Many threads are created and then started (executed asynchronously) with a parameter so that they know which bitmap belongs to them.</li><li class="listitem">The main<a id="id255" class="indexterm"/> thread waits until all the star finder threads finish their work, sleeping 100 milliseconds in each query of the threads' state.</li><li class="listitem">Once all the threads finish their work, the main thread (the only one capable of touching the UI) rebuilds the divided bitmap and shows it in the picture box control.</li></ol></div><p>Each thread works in its independent block, without disturbing or interfering with the other threads.</p><p>The code used to divide the original bitmap dynamically into many smaller bitmaps is a bit complex. That is the price we have to pay for the performance enhancement and scalability of our application.</p><p>This line obtains a <code class="literal">Bitmap</code> instance from the <code class="literal">picStarsBitmap</code> picture box (we begin decoupling the UI, as we cannot touch it from independent threads):</p><div><pre class="programlisting">proOriginalBitmap = new Bitmap(picStarsBitmap.Image);</pre></div><p>These lines create the thread list, the <code class="literal">long</code> numbers list, and the bitmap list in order to let them grow dynamically at runtime depending on the number of available cores in the computer where the application runs:</p><div><pre class="programlisting">prloThreadList = new List&lt;Thread&gt;(priProcessorCount);
prliOldStarsCount = new List&lt;long&gt;(priProcessorCount);
prloBitmapList = new List&lt;Bitmap&gt;(priProcessorCount);</pre></div><p>We must create bitmaps corresponding to the the number of cores available. We use the rows to select a similar number of rows for each bitmap portion.</p><p>We define a variable <code class="literal">liStartRow</code> of type <code class="literal">int</code> as the starting row from where we will begin cropping the original bitmap:</p><div><pre class="programlisting">int liStartRow = 0;</pre></div><p>Then, we must determine the approximate number of rows for each bitmap:</p><div><pre class="programlisting">int liEachBitmapHeight = ((int)(proOriginalBitmap.Height /priProcessorCount)) + 1;</pre></div><p>However, depending on the number of cores and the original bitmap height, the result of this division might not be <a id="id256" class="indexterm"/>exact. That is another problem. Therefore, we use another <code class="literal">int</code> variable to calculate the height to be added to each iteration to solve that problem:</p><div><pre class="programlisting">int liHeightToAdd = proOriginalBitmap.Height;</pre></div><p>Then, the algorithm is simple; for each iteration of <code class="literal">liThreadNumber</code> do the following:</p><div><pre class="programlisting">if (liEachBitmapHeight &gt; liHeightToAdd)
{
    liEachBitmapHeight = liHeightToAdd;
}
loBitmap = CropBitmap(proOriginalBitmap, new Rectangle(0, liStartRow, proOriginalBitmap.Width, liEachBitmapHeight));
liHeightToAdd -= liEachBitmapHeight;
liStartRow += liEachBitmapHeight;
prloBitmapList.Add(loBitmap);</pre></div><p>If the height calculated for each bitmap is greater than the height to be added (this could happen in the last bitmap portion to be cropped), we reduce this number from the height to be added, which is the result of this line in each iteration:</p><div><pre class="programlisting">liHeightToAdd -= liEachBitmapHeight;</pre></div><p>Besides, in each iteration, the starting<a id="id257" class="indexterm"/> row increases the height calculated for each bitmap.</p><p>The following screenshot shows the results of applying this algorithm to the infrared portraits obtained by NASA's Spitzer Space Telescope with four threads:</p><div><img src="img/8321EN_04_05.jpg" alt="How it works"/></div><p>Using our <a id="id258" class="indexterm"/>classic C# programming skills, we can generate smart algorithms to split the work into many independent blocks of safe concurrent code. Again, mastering<a id="id259" class="indexterm"/> the lists is indeed necessary in parallel programming.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Signals between threads</h1></div></div></div><p>To help in coordinating the activity between the multiple threads, we can create variables accessible to the whole class and hence each thread. Then the threads can write to and read from these variables<a id="id260" class="indexterm"/> to help them coordinate activity and to keep overall track of what is happening between all of the threads.</p><p>We use threads with parameters, as we learned in the previous chapters, and start them with an asynchronous execution using the following loop:</p><div><pre class="programlisting">for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount; liThreadNumber++)
{
    prloThreadList[liThreadNumber].Start(liThreadNumber);
}</pre></div><p>Nevertheless, we must wait until the concurrent star finder threads finish their work in order to show the final modified bitmap in the UI. We do not want to use the <code class="literal">BackgroundWorker</code> component.</p><p>For this reason, we created the <code class="literal">WaitForThreadsToDie</code> procedure, which is called synchronously by the main application's thread. When this method returns, we can safely show the resulting bitmap in the UI because all the threads have finished their work. Of course, to achieve the same goal, we can also use the <code class="literal">BackgroundWorker</code> component combined with the threads created as instances of the <code class="literal">Thread</code> class, as we learned in the previous chapters.</p><p>The code<a id="id261" class="indexterm"/> in the <code class="literal">WaitForThreadsToDie</code> procedure is complex because we have to check for each created thread and we know the number of threads at runtime, as they are dynamically aligned with the number of available cores. We use a <code class="literal">bool</code> flag to determine whether the <code class="literal">while</code> loop must go on running or not. However, in this case, we did not change the value of the flag, but there are other cases in which this code pattern could be useful to modify the value of this variable used as a flag.</p><p>Once in the <code class="literal">while</code> loop (<code class="literal">lbContinue</code>), we must check for each thread to finish its work. We use the well-known <code class="literal">IsAlive</code> property:</p><div><pre class="programlisting">for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount;liThreadNumber++)
{
    if (prloThreadList[liThreadNumber].IsAlive)
    {
        break;
    }
    else
    {
        liDeadThreads++;
    }
} </pre></div><p>If one thread is alive, we will exit the <code class="literal">for</code> loop. If all the threads are not alive, <code class="literal">liDeadThreads</code> will equal the total number of created threads. Hence, we will exit the outer loop:</p><div><pre class="programlisting">if (liDeadThreads == priProcessorCount)
{
    break;
}</pre></div><p>The <code class="literal">break;</code> statement could be replaced by <code class="literal">lbContinue = false;</code> and we would achieve the same result.</p><p>If there is still a thread running, we call the <code class="literal">Sleep</code> method for the main thread and make it sleep for 100 milliseconds (0.1 seconds), and then reset the <code class="literal">liDeadThreads</code> variable:</p><div><pre class="programlisting">Thread.Sleep(100);
liDeadThreads = 0;</pre></div><p>The line with the call to the <code class="literal">Sleep</code> method is indispensable.</p><p>Using methods like these, and flags, we can have complete control over independent threads, without causing the classic problems related to concurrency and the loss of control over the<a id="id262" class="indexterm"/> independent threads.</p><p>As mentioned earlier, when the call to the <code class="literal">WaitForThreadsToDie</code> method returns, we can safely show the resulting bitmap in the UI because all the threads have finished their work. Hence, we call the <code class="literal">ShowBitmapWithOldStars</code> procedure.</p><p>This method reproduces the work done when dividing the original bitmap into several independent portions, but in the reverse order.</p><p>We repeat the height calculation process explained previously. Then, we must create a new bitmap with the whole width and height. This bitmap must hold the different portions aligned as they were extracted from the original bitmap:</p><div><pre class="programlisting">loBitmap = new Bitmap(proOriginalBitmap.Width,proOriginalBitmap.Height);
Graphics g = Graphics.FromImage((Image)loBitmap);
g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;</pre></div><p>Therefore, we use the <code class="literal">Bitmap</code> constructor passing the original bitmap width and height as parameters to define its size. Then, we create a <code class="literal">Graphics</code> instance from the <code class="literal">Bitmap</code> typecast to an <code class="literal">Image</code> (the <code class="literal">Bitmap</code> class is a descendant of the <code class="literal">Image</code> class).</p><p>Once we have the <code class="literal">Graphics</code> instance, we must draw each bitmap image processed by each thread in its corresponding row (<code class="literal">liStartingRow</code>), which is calculated the same way we did when separating the bitmap portions:</p><div><pre class="programlisting">for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount;liThreadNumber++)
{
    g.DrawImage(prloBitmapList[liThreadNumber], 0, liStartRow);
    liStartRow += liEachBitmapHeight;
}</pre></div><p>Besides, in each iteration, the starting row increases the height calculated for each bitmap. Then, we are ready to show the rebuilt bitmap in the picture box, <code class="literal">picStarsBitmap</code>:</p><div><pre class="programlisting">picStarsBitmap.Image = loBitmap;</pre></div><p>Decoupling the UI, we can generate impressive performance improvements changing basic linear programming algorithms.</p><p>The following screenshot shows the results of applying this algorithm to the infrared portraits obtained by NASA's Spitzer Space Telescope processed by four threads:</p><div><img src="img/8321EN_04_06.jpg" alt="Signals between threads"/></div><p>The<a id="id263" class="indexterm"/> screenshot shows a clear independency achieved by each thread.</p><p>Run the application changing the value of the <code class="literal">priProcessorCount</code> private variable from 1 to the number of available cores in your computer, and then compare the results.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>How to do it</h2></div></div></div><p>Now, we are going to make some changes to the code in order to use the event wait handles instead of using a loop to check for the threads that are alive:</p><div><ol class="orderedlist arabic"><li class="listitem">Stay in the project, <code class="literal">OldStarsFinder</code>.</li><li class="listitem">Open the code for <code class="literal">Program.cs</code>.</li><li class="listitem">Replace the line <code class="literal">[STAThread]</code> with the following line (before the <code class="literal">Main</code> method declaration):<div><pre class="programlisting">    [MTAThread]</pre></div></li><li class="listitem">Open the code for the Windows Form, <code class="literal">Form1</code> (<code class="literal">frmStarsFinder</code>).</li><li class="listitem">Add the following private variable:<div><pre class="programlisting">    // The AutoResetEvent instances array
    private AutoResetEvent[] praoAutoResetEventArray;</pre></div></li><li class="listitem">Replace the code in the <code class="literal">WaitForThreadsToDie</code> method with the following line:<div><pre class="programlisting">    // Just wait for the threads to signal that every work 
    // item has finished
    WaitHandle.WaitAll(praoAutoResetEventArray);</pre></div></li><li class="listitem">Add the following line of code in the local variables declaration of the <code class="literal">ShowBitmapWithOldStars</code> method, before the line <code class="literal">int liStartRow = 0;</code> (we must create the array according to the number of available cores):<div><pre class="programlisting">    // Create the AutoResetEvent array with the number of 
    // cores available
  praoAutoResetEventArray = new AutoResetEvent[priProcessorCount];</pre></div></li><li class="listitem">Add the following line of code in the thread creation loop in the <code class="literal">ShowBitmapWithOldStars</code> method, before the line <code class="literal">prloThreadList.Add(new Thread(new ParameterizedThreadStart(ThreadOldStarsFinder)));</code> (we must create an <code class="literal">AutoResetEvent</code> instance with a false initial state for each thread):<div><pre class="programlisting">    // Create a new AutoResetEvent instance for that thread with its initial state set to false
    praoAutoResetEventArray[liThreadNumber] = new AutoResetEvent(false);</pre></div></li><li class="listitem">Add the<a id="id264" class="indexterm"/> following line of code at the end of the <code class="literal">ThreadOldStarsFinder</code> method (we must signal that the work item has finished):<div><pre class="programlisting">    // The thread finished its work. Signal that the work 
    // item has finished.
    praoAutoResetEventArray[liThreadNumber].Set();</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Click on the <strong>Old Star Finder</strong> button. After a few seconds (depending on the parallel processing capabilities of the computer), the W5 wispy star-forming region will be shown in the huge infrared portrait with the probable old stars shown in pure blue. You will not notice any changes in the application.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>How it works</h2></div></div></div><p>When the user clicks<a id="id265" class="indexterm"/> on the <strong>Old Star Finder</strong> button:</p><div><ol class="orderedlist arabic"><li class="listitem">The original image is divided into many independent bitmaps. Each portion will be assigned to a different thread.</li><li class="listitem">Many threads and their auto-reset event handlers are created to allow communication between the threads.</li><li class="listitem">The threads are started (executed asynchronously) with a parameter so that they know which bitmap belongs to them.</li><li class="listitem">Once each thread finishes its work, it signals that the work is done, setting the auto-reset event.</li><li class="listitem">The main thread waits until all the star finder threads finish their work, waiting for all the necessary signals from the multiple auto-reset events.</li><li class="listitem">Once all the threads finish their work, the main thread (the only one capable of touching the UI) rebuilds the divided bitmap and shows it in the picture box control.</li></ol></div><p>The code used to<a id="id266" class="indexterm"/> wait for all the threads to finish their work is easier and more elegant.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Using the AutoResetEvent class to handle signals between threads</h2></div></div></div><p>An <code class="literal">AutoResetEvent</code> instance <a id="id267" class="indexterm"/>allows us to notify a waiting thread that an event has occurred. It is a subclass of the <code class="literal">WaitHandle</code> and <code class="literal">EventWaitHandle</code> classes.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>
<strong>Event wait handles</strong> encapsulate<a id="id268" class="indexterm"/> operating-system-specific objects that wait for exclusive access to shared resources. Using them, it is easier to wait for the threads' signals to continue working when their jobs are done.</p></div></div><p>First, we have to <a id="id269" class="indexterm"/>create event wait handles corresponding to the number of threads. We do it in the following line, in the <code class="literal">FindOldStarsAndShowResult</code> method:</p><div><pre class="programlisting">praoAutoResetEventArray = new AutoResetEvent[priProcessorCount];</pre></div><p>We use an array because the <code class="literal">WaitAll</code> method receives an array of wait handles as a parameter.</p><p>Before creating each new instance of the <code class="literal">Thread</code> class, we create a new <code class="literal">AutoResetEvent</code> instance for each thread, with its initial state (a <code class="literal">bool</code> state) set to <code class="literal">false</code>:</p><div><pre class="programlisting">praoAutoResetEventArray[liThreadNumber] = new AutoResetEvent(false);</pre></div><p>Thus, each independent thread can access its own <code class="literal">AutoResetEvent</code> instance. Once the thread finishes its work, it signals that the job is done calling the <code class="literal">Set</code> method, as shown in the following line, at the end of the <code class="literal">ThreadOldStarsFinder</code> procedure:</p><div><pre class="programlisting">praoAutoResetEventArray[liThreadNumber].Set();</pre></div><p>The event wait handle's<a id="id270" class="indexterm"/> initial state <a id="id271" class="indexterm"/>was <code class="literal">false</code>; now it is <code class="literal">true</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Using the WaitHandle class to check for signals</h2></div></div></div><p>On the other side, the main UI thread has to wait until all the concurrent star finder threads finish their <a id="id272" class="indexterm"/>work in order to show the final modified bitmap in the UI. Thus, it must wait for all the event handles to have their state set to <code class="literal">true</code>, instead of the initial <code class="literal">false</code>.</p><p>This happens when<a id="id273" class="indexterm"/> all the threads have finished their work and have called the <code class="literal">Set</code> method for their corresponding <code class="literal">AutoResetEvent</code> instance.</p><p>We can check that using a single line of code in the <code class="literal">WaitForThreadsToDie</code> method:</p><div><pre class="programlisting">WaitHandle.WaitAll(praoAutoResetEventArray);</pre></div><p>The <code class="literal">WaitAll</code> method <a id="id274" class="indexterm"/>will monitor all the event handles, waiting for their signals to change (the threads' completion). It receives an array of event handles as a parameter.</p><p>We must change the application's threading model to a multithreaded apartment in order to be able to use the <code class="literal">WaitHandle.WaitAll</code> method. If we do not do so, the method call will fail and generate an exception. Therefore, we have to replace the line <code class="literal">[STAThread]</code>, before the <code class="literal">Main</code> method declaration, with <code class="literal">[MTAThread]</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Joining threads</h1></div></div></div><p>We have already examined <em>joining</em> a thread in the previous chapter. When you join a thread, you tell the<a id="id275" class="indexterm"/> current thread to wait on the thread, which you are joining, to complete. This allows you to coordinate work between two threads.</p><p>This was very handy in the example where we wanted to know when one piece is complete before we start the next piece.</p><p>For our application, let's say we want to examine how the performance changes if all of the bitmap processing threads run sequentially instead of concurrently.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>How to do it</h2></div></div></div><p>If we want all of our bitmap processing threads to run sequentially, then right after we start a thread, we will join<a id="id276" class="indexterm"/> the thread. This will halt execution of the main thread until the bitmap processing thread we just started has finished. To do this, change the bottom <code class="literal">for</code> loop in the <code class="literal">butFindOldStars_Click</code> event handler and add the following line:</p><div><pre class="programlisting">prloThreadList[liThreadNumber].Join();</pre></div><p>So, now the <code class="literal">for</code> loop looks like this:</p><div><pre class="programlisting">            // Now, start the threads
            for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount; liThreadNumber++)
            {
                prloThreadList[liThreadNumber].Start(liThreadNumber);

                //Wait here on the Thread you just created to 
                // complete.
                prloThreadList[liThreadNumber].Join();

            }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>How it works</h2></div></div></div><p>Now, run the application and click on the <strong>Old Star Finder</strong> button. Comment the line out and rerun the application. What do you see?</p><p>You will notice that the time to process the image and complete the process is much slower with the extra line of code versus without the extra line of code. As we mentioned previously, this is because we are pausing the main thread each time we execute a new thread to process part of the bitmap image. So, we are not processing the image concurrently but sequentially.</p><p>For our application, this is not very practical, but for many problems there is a reason why you might want to do this. The main lesson here is that the <code class="literal">Thread</code> class has several ways to control processing, so you, the developer, can have complete control over how threads are created, executed, and coordinated. This is also why this is referred to as <strong>heavyweight concurrency</strong><a id="id277" class="indexterm"/> because it takes extra effort and work by the developer to accomplish the exact behavior that you want.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Locking resources to ensure thread-safe data</h1></div></div></div><p>So far we have chosen to design our application in a manner so that there is no need to lock resources to protect them from being "stomped" on by other threads, thereby causing race conditions<a id="id278" class="indexterm"/> and other unexpected behavior.</p><p>The lock syntax is as follows:</p><div><pre class="programlisting">                        lock (objVariable)
                        {
                            
                        }</pre></div><p>The code between the brackets is executed in a thread-safe manner and will not let other threads operate on the object being locked until the lock execution is completed.</p><p>Other threads that try to perform an operation on an object that is locked will wait until the lock is freed before they continue their operation on the object. This is important to note because it can create "locking" issues where one thread is waiting on a resource locked by another thread. This can be self-defeating when trying to gain performance improvements with multithreading code if the multiple threads are constantly waiting on each other to let go of a resource. This is one of the reasons we have designed the code to use a separate list of long values to count old stars with one item in the list for each thread instead of one variable total that all of the threads update.</p><p>On a separate note, when using locks, you need to be careful not to create a deadlock situation. This occurs when one thread is waiting on an object locked by another thread and that thread is waiting on an object locked by the first thread. Hence, each thread is waiting on the other thread and neither can proceed.</p><p>It is also worthwhile noting that locks are handled differently in between C# 3.0 and C# 4.0. In 3.0, the following is how a lock is translated into code:</p><div><pre class="programlisting">var temp = object1;

Monitor.Enter(temp);

try
{
    // body
}
finally
{
    Monitor.Exit(temp);
}</pre></div><p>In C# 4.0, it is handled as follows:</p><div><pre class="programlisting">bool locked = false;
var temp = object1;
try
{
    Monitor.Enter(temp, ref locked);
    // body
}
finally
{
    if (locked)
    {
        Monitor.Exit(temp); 
    }
}</pre></div><p>As you can see, in C# 4.0, if the lock is not taken on an object, nothing different happens to the object.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>How to do it</h2></div></div></div><p>Now, let's look<a id="id279" class="indexterm"/> at our code and make a simple change to use a single variable to hold our old star count. Let's do it with and without the lock and see the different behaviors.</p><div><ol class="orderedlist arabic"><li class="listitem">First, let's add the following to the top of our class in the declaration statements:<div><pre class="programlisting">//Old stars count using a lock to protect thread safety.
        private String prsOldStarsCount = "0";</pre></div></li><li class="listitem">Also, add a label control and set the <code class="literal">Text</code> property to <code class="literal">Old Stars Count</code> and add a textbox control and set the <code class="literal">Name</code> property to <code class="literal">tbCount</code>.</li></ol></div><p>This variable will hold our old star count and all of the threads will update this one variable. You will notice that we are using a string instead of an integer. This is because an integer is a base type of the language and not an object. Because of this, it is thread-safe by default and does not need to be locked. So, to demonstrate our point, we will use a <code class="literal">String</code> object as a counter.</p><p>Now, in the <code class="literal">ThreadOldStarsFinder</code> method, add the following code to the end (and inside) of the nested <code class="literal">for</code> loop:</p><div><pre class="programlisting">lock (prsOldStarsCount)
            {
                int i = Convert.ToInt32(prsOldStarsCount);
                i= i + 1;
                prsOldStarsCount = i.ToString();
            }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>How it works</h2></div></div></div><p>As you can see from this example, each time one of the processing threads updates the count, it will lock the resource, update <code class="literal">prsOldStarsCount</code>, and then unlock it. This protects its integrity but will slow down the overall processing because of the extra context switching that<a id="id280" class="indexterm"/> the lock will cause.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Error handling with threads</h1></div></div></div><p>In this section, we will discuss various ways of using the <code class="literal">try..catch</code> block to perform error handling and coordination of multiple threads.</p><p>In this example, we are going to write a simple console application that demonstrates a typical producer-consumer model. We will also demonstrate using a <code class="literal">try..catch</code> to coordinate activities<a id="id281" class="indexterm"/> as well as the join and lock mechanism previously discussed. This exercise will cement everything we have learned in this chapter so<a id="id282" class="indexterm"/> far.</p><p>Also, as we will see in future chapters the producer-consumer design pattern is one of the most commonly used design patterns in multithreaded problem solving and is used a lot with the Task Parallel Library. It describes a design where one thread (or a group of threads) "produces" some output, and a second thread (or group of threads) "consumes" that output and performs some logic on it. Typically, you will multithread the "production" of some results into a queue, and then will multithread the "consumption" of the produced results from the queue.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>How to do it</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open up Visual Studio and create a new project called <code class="literal">ProducerConsumer</code>.</li><li class="listitem">Let's create three classes, a <code class="literal">Producer</code> class, a <code class="literal">Consumer</code> class, and a <code class="literal">Cell</code> class. The <code class="literal">Producer</code> class will produce cells, and the consumer class will consume cells. In the <code class="literal">Main</code> method, we will start a producer and a consumer thread and then join them.</li><li class="listitem">Add the following code in the <code class="literal">Program.cs</code> file so it looks like this:<div><pre class="programlisting">using System;
using System.Threading;

public class ProducerConsumer
{
    public static void Main(String[] args)
    {
        int result = 0;   // Results output
        Cell cell = new Cell();

        Producer producer = new Producer(cell, 5);  
        Consumer consumer = new Consumer(cell, 5);  

        Thread producerThread = new Thread(new ThreadStart(producer.ThreadRun));
        Thread consumerThread = new Thread(new ThreadStart(consumer.ThreadRun));

        try
        {
            producerThread.Start();
            consumerThread.Start();

            // Join both threads.
            producerThread.Join();   
            consumerThread.Join();

        }
        catch (ThreadStateException e)
        {
            System.Diagnostics.Debug.WriteLine(e);  // Output text of exception.
            result = 1;            // Set result to indicate an error.
        }
        catch (ThreadInterruptedException e)
        {
            System.Diagnostics.Debug.WriteLine(e);  // Output text noting an interruption.
            result = 1;            // Set result to indicate an error.
        }

        Environment.ExitCode = result;
    }
}

public class Producer
{
    Cell cell;        
    int quantity = 1;  

    public Producer(Cell box, int request)
    {
        cell = box;          
        quantity = request;  
    }
    public void ThreadRun()
    {
        for (int looper = 1; looper &lt;= quantity; looper++)
            cell.Write(looper);  // "producing"
    }
}

public class Consumer
{
    Cell cell;        
    int quantity = 1;  

    public Consumer(Cell box, int request)
    {
        cell = box;         
        quantity = request;  
    }
    public void ThreadRun()
    {
        int value;
        for (int looper = 1; looper &lt;= quantity; looper++)
            value = cell.Read();    // Consume the result by putting it in value
    }
}

public class Cell
{
    int cellContents;      
    bool State = false;  
    public int Read()
    {
        lock (this)   // Synchronizing block of code.
        {
            if (!State)
            {            // Wait until Cell.Write is done producing
                try
                {
                    Monitor.Wait(this);     // Waits for the Monitor.Pulse in Write
                }
                catch (SynchronizationLockException e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                }
                catch (ThreadInterruptedException e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                }
            }
            System.Diagnostics.Debug.WriteLine(String.Format("Consumed cell item {0}", cellContents));
            State = false;    // Consumption is done.

            Monitor.Pulse(this);   // Pulse tells Cell.Write that Cell.Read is finished.
        }   

        return cellContents;
    }

    public void Write(int n)
    {
        lock (this)  // Synchronization block
        {
            if (State)
            {      // Wait until Cell.Read is done consumption.
                try
                {
                    Monitor.Wait(this);   // Wait for the Monitor.Pulse in Read.
                }
                catch (SynchronizationLockException e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                }
                catch (ThreadInterruptedException e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                }
            }
            cellContents = n;
            System.Diagnostics.Debug.WriteLine(String.Format("Produced cell item {0}", cellContents));
            State = true;    // Set State to indicate production is done.

            Monitor.Pulse(this);  // Pulse tells Cell.Read that Cell.Write is finished.

        }   
    }
}</pre></div></li><li class="listitem">Let's run this console application. In Visual Studio, make sure that you are displaying<a id="id283" class="indexterm"/> the <strong>Output</strong> window. You can do this<a id="id284" class="indexterm"/> by going to the <strong>View</strong> menu and selecting <strong>Output</strong>. Once you run the application, you should see something like the following in your <strong>Output</strong> window:<div><img src="img/8321EN_04_07.jpg" alt="How to do it"/></div></li></ol></div><p>As you can<a id="id285" class="indexterm"/> see in our application, we coordinate between the producer and the consumer, and using the <code class="literal">try..catch</code> block and locks, we are able to produce one item and then consume that item.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>How it works</h2></div></div></div><p>Here, in this example, we<a id="id286" class="indexterm"/> show how synchronization is done using locks and a <code class="literal">Monitor</code> object. The <code class="literal">Pulse</code> method notifies a thread, which is in the waiting queue, of a change in the object's state.</p><p>In this example, we create a <code class="literal">Cell</code> object that has two methods, <code class="literal">Read</code> and <code class="literal">Write</code>. Two other objects are created from the <code class="literal">Producer</code> and <code class="literal">Consumer</code> classes. These objects have a method <code class="literal">ThreadRun</code> whose job is to call <code class="literal">Cell.Read</code> and <code class="literal">Cell.Write</code>. The synchronization is done by waiting for "pulses" from the <code class="literal">Monitor</code> object. These pulses will come in the order they are received. </p><p>So, first an item is produced (the consumer at this point is waiting for a pulse), then a pulse occurs, and then the consumer "consumes" what was<a id="id287" class="indexterm"/> produced. Meanwhile the producer is waiting for a pulse. This is<a id="id288" class="indexterm"/> then repeated until we reach the limit we set when we created the <code class="literal">Producer</code> and <code class="literal">Consumer</code> objects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we took a deeper dive into working with the <code class="literal">Thread</code> class. Through our examples, we learned how to coordinate threads in a more advanced way. We learned how to use the <code class="literal">try..catch</code> block, the <code class="literal">Monitor</code> object, locks, <code class="literal">Join</code>, <code class="literal">IsAlive</code>, and <code class="literal">Sleep</code> methods to coordinate activities between threads.</p><p>We also introduced two common design patterns that we will explore in much more detail in the later chapters—the pipelining and the producer-consumer patterns. These are commonly used to solve problems in a parallel application. They are good ways to segment the work that can be done in parallel from the work that cannot be done in parallel.</p><p>As we have discussed, this type of parallel programming is called heavyweight concurrency because the heavy lifting is done by you, the programmer. You have to manage and control the different threads to achieve the behavior you intended. You have to track which threads run and when and which threads are waiting and why. This does create complexity and work for the programmer but it also allows for very tight control of the execution. There are times when this is the best way to ensure proper behavior of your application.</p><p>Next, in <a class="link" href="ch05.html" title="Chapter 5. Lightweight Concurrency – Task Parallel Library (TPL)">Chapter 5</a>, <em>Lightweight Concurrency – Task Parallel Library (TPL)</em>, we will start to examine lightweight concurrency and the Task Parallel Library. This allows you to let .NET handle some of this coordination for you. It is important that you have full understanding of the <code class="literal">Thread</code> class before moving on to the Task library and lightweight concurrency.</p></div></body></html>