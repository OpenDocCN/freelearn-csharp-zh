<html><head></head><body>
		<div id="_idContainer019">
			<h1 id="_idParaDest-96" class="chapter-number"><a id="_idTextAnchor158"/>4</h1>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor159"/>Honest Functions, Null, and Option</h1>
			<p>In this chapter, we discuss the art and science of honest functions, the intricacies of null, and the C# tools tailored to address them. But before we dive deep, let’s lay out <span class="No-Break">the roadmap:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">honest functions</span></li>
				<li>The problems with <span class="No-Break">hidden nulls</span></li>
				<li>Embracing honesty with nullable <span class="No-Break">reference types</span></li>
				<li>Beyond <span class="No-Break">null: Option</span></li>
				<li><span class="No-Break">Real-world scenarios</span></li>
			</ul>
			<p>As you navigate through this chapter, be on the lookout for practical advice and evidence-backed guidelines. Come with a curious mind, and by the end, you’ll possess the know-how to write more transparent and resilient <span class="No-Break">C# code.</span></p>
			<p>Just as we did in our previous chapters, let’s assess where you stand. Here, there are three tasks for you. If you’re unsure about tackling them, dive into this chapter right away. But, if you feel confident in your skills, perhaps you might skim through and jump to the sections that challenge you the most. Ready? <span class="No-Break">Let’s go!</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor160"/>Task 1 – Refactor for honest return types</h1>
			<p>Here’s a function<a id="_idIndexMarker180"/> in Steve’s tower defense game that retrieves a tower based on its ID. Refactor it to return an honest type indicating <span class="No-Break">potential nullability:</span></p>
			<pre class="source-code">
public Tower GetTower(int towerId)
{
     var tower = _gameState.GetTowerById(towerId);
     return tower;
}</pre>			<h1 id="_idParaDest-99"><a id="_idTextAnchor161"/>Task 2 – Guard against null inputs</h1>
			<p>Refactor the following <a id="_idIndexMarker181"/>function to guard against null inputs using preconditions and throw appropriate exceptions if the precondition <span class="No-Break">isn’t met:</span></p>
			<pre class="source-code">
public void UpgradeTower(TowerUpgradeInfo upgradeInfo)
{
     _gameState.UpgradeTower(upgradeInfo);
}</pre>			<h1 id="_idParaDest-100"><a id="_idTextAnchor162"/>Task 3 – Pattern matching with nullable types</h1>
			<p>Given the following<a id="_idIndexMarker182"/> classes, write a method that receives an enemy and returns a string with its description using <span class="No-Break">pattern matching:</span></p>
			<pre class="source-code">
public abstract class Enemy {}
public class GroundEnemy : Enemy
{
     public int Speed { get; set; }
     public int Armor { get; set; }
}
public class FlyingEnemy : Enemy
{
     public int Altitude { get; set; }
     public int DodgeChance { get; set; }
}
public class BossEnemy : Enemy
{
     public int Health { get; set; }
     public string SpecialAbility { get; set; }
}
public string GetEnemyDetails(Enemy? enemy)
{
     // Your code here
}</pre>			<p>Again, if you are sure you know the right answers to all three tasks, you can skip this chapter. Of course, you <a id="_idIndexMarker183"/>can always come back if you have any questions. Now let’s discuss honest functions and <span class="No-Break">their benefits.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor163"/>Honest functions – definition and understanding</h1>
			<p>A few days after his <a id="_idIndexMarker184"/>conversation with Julia about pure functions and side effects, Steve was eager to learn more. He called Julia to ask what he should <span class="No-Break">study next.</span></p>
			<p>Julia: <em class="italic">Let’s talk about honest functions, </em><strong class="source-inline">null</strong><em class="italic">, and </em><strong class="source-inline">Option</strong><em class="italic"> types,’ she suggested. ‘These concepts are crucial for writing clear, </em><span class="No-Break"><em class="italic">predictable code.</em></span></p>
			<p>Steve: <em class="italic">Sounds great! But what exactly are </em><span class="No-Break"><em class="italic">honest functions?</em></span></p>
			<p>Julia: <em class="italic">An honest function provides a clear, unambiguous contract between the function and its callers, resulting in code that’s more robust, less prone to bugs, and easier to </em><span class="No-Break"><em class="italic">reason about.</em></span></p>
			<p>So what exactly is an <span class="No-Break">honest function?</span></p>
			<p>In the simplest terms, an honest function is one where its type signature fully and accurately describes its behavior. If a function claims that it will take an integer and return another integer, then that’s precisely what it will do. There are no hidden gotchas, no exceptions thrown out of the blue, and no subtle changes to global or static state that aren’t reflected in the <span class="No-Break">function’s signature.</span></p>
			<p>Consider the following <span class="No-Break">C# function:</span></p>
			<pre class="source-code">
public static int Divide(int numerator, int denominator)
{
    return numerator / denominator;
}</pre>			<p>At first glance, this function seems to fulfill its promise. It takes two integers and returns their quotient. However, what happens when we pass zero as the denominator? <strong class="source-inline">DivideByZeroException</strong> is thrown. The function was not entirely honest with us; its signature did not warn us about this potential pitfall. An honest version of this function would explicitly signal the potential for failure in <span class="No-Break">its signature.</span></p>
			<p>So, how does this <a id="_idIndexMarker185"/>concept of honesty tie into the broader context of functional programming and the software development industry? In functional programming, functions are the building blocks of your code. The more clearly and honestly these functions describe their behavior, the easier it is to build larger, more complex programs. Each function serves as a reliable component that behaves just as its signature describes, allowing developers to confidently compose and reuse <span class="No-Break">these functions.</span></p>
			<p>As Julia explained honest functions, Steve’s eyes lit up <span class="No-Break">with understanding.</span></p>
			<p>Steve: <em class="italic">So it’s like when I tell my teammates I’ll deliver a feature by Friday, I should actually </em><span class="No-Break"><em class="italic">do it?</em></span></p>
			<p>Julia: <em class="italic">Exactly! In programming, our functions should be just </em><span class="No-Break"><em class="italic">as reliable.</em></span></p>
			<p>Now, let’s dive deeper into the benefits of using <span class="No-Break">honest functions:</span></p>
			<ul>
				<li><strong class="bold">Improved readability</strong>: Honest<a id="_idIndexMarker186"/> functions make the code more straightforward to read and understand. There’s no need to dive into the implementation to grasp what the function is doing. The function’s signature is a contract that accurately describes <span class="No-Break">its behavior.</span></li>
				<li><strong class="bold">Enhanced predictability</strong>: With honest functions, surprises are drastically minimized. The function’s behavior is precisely what is described in the signature, leading to fewer unexpected bugs and exceptions <span class="No-Break">at runtime.</span></li>
				<li><strong class="bold">Increased reliability</strong>: By minimizing surprises and explicitly handling potential error scenarios, honest functions result in a more robust code base that can withstand the rigors <a id="_idIndexMarker187"/>of <span class="No-Break">real-world usage.</span></li>
			</ul>
			<p>Consider a code base where every function is honest. Any developer, familiar or not with the code, could look at a function signature and know immediately what it does, what it needs, and what it might return, including any potential error conditions. It’s like having a well-documented code base without the need for verbose documentation. That’s the power and<a id="_idIndexMarker188"/> promise of <span class="No-Break">honest functions.</span></p>
			<p>In the following sections, we’ll explore how to implement honest functions in C# and how to deal with potential dishonesty, such as nulls or exceptions. Fasten your seatbelts, because our journey into the world of honest and dishonest functions is <span class="No-Break">just beginning!</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor164"/>The problems with hidden nulls</h1>
			<p>Steve recalled a <a id="_idIndexMarker189"/>recent bug in his tower <span class="No-Break">defense game.</span></p>
			<p>Steve: <em class="italic">I think I’ve run into this problem. My game crashed when trying to upgrade a tower that </em><span class="No-Break"><em class="italic">didn’t exist.</em></span></p>
			<p>Julia: <em class="italic">That’s a classic example, let’s look at how we can prevent that using what we’re </em><span class="No-Break"><em class="italic">learning today.</em></span></p>
			<p>Have you ever felt confused trying to figure out why your program stopped working? Most times, the problem comes from a well-known <strong class="source-inline">NullReferenceException</strong>. This section looks at the tricky connection between C# and null, pointing out the problems many <span class="No-Break">developers face.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor165"/>A quick look back – C# and null</h2>
			<p>To understand<a id="_idIndexMarker190"/> our current problem, let’s look back a bit. Tony Hoare, an important <a id="_idIndexMarker191"/>computer expert, called the null reference a “huge mistake.” The idea was to provide developers with a tool to show when a value was missing. At first, it seemed like a good plan, but it ended up causing many problems and mistakes in languages – <span class="No-Break">C# included.</span></p>
			<p>When C# was introduced, it used this idea from older programming methods, letting developers use null to show something was missing. But over time, this simple choice caused a lot of<a id="_idIndexMarker192"/> errors <a id="_idIndexMarker193"/><span class="No-Break">and mix-ups.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor166"/>Common mistakes and the troubling NullReferenceException</h2>
			<p>All C# developers, whether new or experienced, have come across <strong class="source-inline">NullReferenceException</strong>. This error <a id="_idIndexMarker194"/>happens when you try to use something that <span class="No-Break">isn’t there.</span></p>
			<p>Think about a program that gets user information. You might expect to always find <span class="No-Break">a user:</span></p>
			<pre class="source-code">
var user = FindUserById(userId);
var fullName = $"{user.FirstName} {user.LastName}";</pre>			<p>Oops! If <strong class="source-inline">FindUserById</strong> can’t find a user, the second line will give <strong class="source-inline">NullReferenceException</strong>, which, if not caught, will terminate the whole execution of the thread. This mistake happens because we thought a user would always be there. This shows how hidden nulls can cause unexpected problems in <span class="No-Break">our code.</span></p>
			<p>Many programs are much bigger than this example, which makes these kinds of mistakes hard to find and fix. These hidden problems can stay hidden for a long time, causing errors when you least <span class="No-Break">expect them.</span></p>
			<p>Hidden nulls can be thought of as unseen traps. They can catch out both new and experienced programmers. Plus, they go against the main idea of functional programming, which values clear and <span class="No-Break">expected outcomes.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor167"/>Not all bad – the value of null</h2>
			<p>It’s easy to blame null for <a id="_idIndexMarker195"/>these problems. But the real issue is how it’s used. Null can be helpful if used in a clear way to show something is missing. The problem comes when its use is unclear, leading to many <span class="No-Break">potential errors.</span></p>
			<p>The journey of C# with null has had its ups and downs. But, as we’ll learn in the next sections, C# now has multiple ways to handle null, making our code clearer and more straightforward. And one of these ways is to use nullable <span class="No-Break">reference types.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor168"/>Embracing honesty with nullable reference types</h1>
			<p>Handling null in C# has <a id="_idIndexMarker196"/>always been quite a challenge. Many software developers (me included) advocate doing a check for <strong class="source-inline">NullReferenceException</strong>s as a mandatory task in a code review checklist. In most cases, it is really easy to check for possible null values just by looking at the pull request, even without an IDE. Recently, we received help when Microsoft introduced nullable reference types. So, now, the compiler will join us in the search of possible disasters caused <span class="No-Break">by null.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor169"/>What are nullable reference types?</h2>
			<p>In the simplest terms, <strong class="bold">Nullable Reference Types</strong> (or <strong class="bold">NRTs</strong> for short) are a feature in C# that allows <a id="_idIndexMarker197"/>developers to clearly indicate whether a reference type can be null or not. With this, C# gives us a tool to make our intentions clear right from the start. Think of it as a signpost, guiding other developers (and even our future selves) about what to expect from <span class="No-Break">our code.</span></p>
			<p>Without NRTs, every reference type in C# could potentially be <strong class="source-inline">null</strong>. This would create a guessing game. Is this variable going to have a value or is it going to be <strong class="source-inline">null</strong>? Now, with NRTs, we don’t have to guess anymore. The code itself tells <span class="No-Break">the story.</span></p>
			<p>Let’s look at a basic example to grasp <span class="No-Break">the concept:</span></p>
			<pre class="source-code">
string notNullable = "Hello, World!";
string? nullable = null;</pre>			<p>In the preceding snippet, the <strong class="source-inline">notNullable</strong> variable is a regular string that can’t be assigned <strong class="source-inline">null</strong> (if you try, the compiler will warn you). On the other hand, since C# 8.0, nullable is explicitly marked with <strong class="source-inline">?</strong>, indicating that it can <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<p>In some cases, you might want to assign <strong class="source-inline">null</strong> to a variable that is not marked as nullable. In this case, to suppress warnings, you can use the <strong class="source-inline">!</strong> sign to let the compiler know that you are aware of what you are doing and everything is going according <span class="No-Break">to plan:</span></p>
			<pre class="source-code">
string notNullable = "Hello, World!";
notNullable = null!;</pre>			<p>One of the biggest advantages of NRTs is that the C# compiler will warn you if you’re potentially doing something risky with null values. It’s like having a friendly guide always looking over your shoulder, ensuring you don’t fall into the common traps of <span class="No-Break">null misuse.</span></p>
			<p>For instance, if you try to<a id="_idIndexMarker198"/> access properties or methods on a nullable reference without checking for <strong class="source-inline">null</strong>, the compiler will give you <span class="No-Break">a heads-up.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor170"/>Transitioning to NRTs</h2>
			<p>For those with <a id="_idIndexMarker199"/>existing C# projects, you might be wondering: <em class="italic">Will my project be littered with warnings if I enable NRTs?</em> The answer is no. By default, NRTs are turned off. You can opt into this feature, file by file, allowing for a <span class="No-Break">smooth transition.</span></p>
			<p>NRTs are a good answer to the long-standing challenge posed by null references. By making the potential presence of null explicit in our code, we take a giant leap toward clarity, safety, and functional honesty. In the end, embracing NRTs not only makes our code more resilient but also ensures that our intentions, as developers, <span class="No-Break">are transparent.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor171"/>Enabling nullable reference types</h2>
			<p>To enable NRTs, we<a id="_idIndexMarker200"/> need to tell the C# compiler that we’re ready for its guidance. This is done using a simple directive: <strong class="source-inline">#</strong><span class="No-Break"><strong class="source-inline">nullable enable</strong></span><span class="No-Break">.</span></p>
			<p>Place this at the start of your <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">cs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
#nullable enable</pre>			<p>From this point onward in the file, the compiler creates a specific nullable context and assumes that all reference types are non-nullable by default. If you want a type to be nullable, you’ll have to mark it explicitly <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">?</strong></span><span class="No-Break">.</span></p>
			<p>With NRTs enabled, the C# compiler becomes your safety net, pointing out potential issues with nulls in your code. Whenever you try to assign null to a reference type without the <strong class="source-inline">?</strong> marker or when you attempt to access a potentially null variable without checking it, the compiler will <span class="No-Break">warn you.</span></p>
			<p>Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
string name = null; // This will trigger a warning
string? maybeName = null; // This is okay</pre>			<h2 id="_idParaDest-110"><a id="_idTextAnchor172"/>Disabling nullable reference types</h2>
			<p>While transitioning <a id="_idIndexMarker201"/>a project to use NRTs, there may be sections of your code where you’d prefer to delay the transition. You can turn off NRTs for those specific sections using the <strong class="source-inline">#nullable </strong><span class="No-Break"><strong class="source-inline">disable</strong></span><span class="No-Break"> directive:</span></p>
			<pre class="source-code">
#nullable disable</pre>			<p>This tells the compiler to revert to the old behavior, treating all reference types as <span class="No-Break">potentially nullable.</span></p>
			<p>You might wonder why C# chose to use directives for this feature. The reason is flexibility. By using directives, developers can gradually introduce NRTs into their projects, one file or even one section of code at a time. This phased approach makes it easier to adapt <span class="No-Break">existing projects.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor173"/>Warnings and annotations options</h2>
			<p>Speaking of a phased approach, there<a id="_idIndexMarker202"/> are two more options to set our nullable contexts: <strong class="source-inline">warnings</strong> and <strong class="source-inline">annotations</strong>. You can use them by writing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
#nullable enable warnings</pre>			<p>Or, you can <span class="No-Break">write this:</span></p>
			<pre class="source-code">
#nullable enable annotations</pre>			<p>The main purpose of these<a id="_idIndexMarker203"/> options is to ease the migration of your existing code from a fully disabled null context to a fully enabled one. In short, we want to start with the <strong class="source-inline">warnings</strong> option in order to get dereference warnings. When all warnings are fixed, we can switch to <strong class="source-inline">annotations</strong>. This option will not give us any warnings, but it will start to treat our variables as non-nullable unless declared with the <strong class="source-inline">?</strong> <span class="No-Break">mark.</span></p>
			<p>To get more information about these options and nullable context in generated files, and to find out more about three nullabilities – oblivious, nullable, and non-nullable, I recommend you read the article <em class="italic">Nullable reference types</em> (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references">https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references</a>). You might also want to read the article “Update a codebase with nullable reference types to improve null <a id="_idIndexMarker204"/>diagnostic <span class="No-Break">warnings” (</span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor174"/>The bigger picture – project-wide settings</h2>
			<p>While directives are<a id="_idIndexMarker205"/> great for granular control, you can also enable NRTs for an entire project. In the project settings, or directly in the <strong class="source-inline">.csproj</strong> file, set the <strong class="source-inline">&lt;Nullable&gt;</strong> element <span class="No-Break">to enable:</span></p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
&lt;/PropertyGroup&gt;</pre>			<p>This setting treats every file in the project as if it started with the <strong class="source-inline">#nullable enable</strong> directive. When you turn on a nullable context for the whole project, you might want to keep some parts of the code from generating warnings, but use the project-wide nullable context after it. In that case, you can use the <span class="No-Break"><strong class="source-inline">restore</strong></span><span class="No-Break"> option:</span></p>
			<pre class="source-code">
#nullable enable
// The section of the code where nullable reference types are enabled.
#nullable restore</pre>			<p>Enabling nullable reference types is like turning on a light in a previously dim room. It reveals potential pitfalls and ensures that we write safer, clearer code. With the tools C# provides, we have both granular and broad control over this feature, making the transition to a more transparent coding style both manageable <span class="No-Break">and rewarding.</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor175"/>Returning with intention</h1>
			<p>In the realm of functional<a id="_idIndexMarker206"/> programming, a function’s primary aim is to be transparent. By transparent, we mean that the function should not just do what its name implies, but also, its return type should offer a clear contract of what to expect. Let’s dive deep into crafting honest return types <span class="No-Break">in C#.</span></p>
			<p>A seasoned developer knows that a function’s name or signature alone might not depict the entire story. Consider <span class="No-Break">the following:</span></p>
			<pre class="source-code">
UserProfile GetUserProfile(int userId);</pre>			<p>On the surface, this function seems to promise that it’ll fetch a user profile given a user ID. However, questions linger. What if the user doesn’t exist? What if there’s an error retrieving <span class="No-Break">the profile?</span></p>
			<p>Now consider <span class="No-Break">an alternative:</span></p>
			<pre class="source-code">
UserProfile? GetUserProfile(int userId);</pre>			<p>By simply<a id="_idIndexMarker207"/> introducing <strong class="source-inline">?</strong> to the return type, the function becomes more transparent about its intention. It suggests: <em class="italic">I’ll try to fetch a user profile for this ID. But there’s a possibility you might get </em><span class="No-Break"><em class="italic">a null</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor176"/>The distinction between UserProfile and UserProfile?</h2>
			<p>While the distinction<a id="_idIndexMarker208"/> might seem minute, the implications <span class="No-Break">are vast:</span></p>
			<ul>
				<li><strong class="bold">Expectation setting</strong>: With <strong class="source-inline">UserProfile?</strong>, you immediately know there’s a possibility of not getting a <span class="No-Break">user profile.</span></li>
				<li><strong class="bold">Defensive coding</strong>: Knowing the return can be null, you’ll naturally write safer code to handle <span class="No-Break">such cases.</span></li>
				<li><strong class="bold">Error handling</strong>: Instead of exceptions or error codes to signify missing data, a nullable return type provides a clear, type-safe way to express the possibility <span class="No-Break">of absence.</span></li>
			</ul>
			<p>Let’s see this <span class="No-Break">in practice:</span></p>
			<pre class="source-code">
var userProfile = GetUserProfile(userId);
if (userProfile is null)
{
    // Handle the scenario when the profile is not available
}
else
{
    // Proceed with the user profile data
}</pre>			<p>As you can see, with the help of NRTs, we can understand code more clearly and process its results <a id="_idIndexMarker209"/>correctly. And all we did to achieve it was just tweaking the method’s signature a <span class="No-Break">little bit.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor177"/>Honoring a function’s contract</h2>
			<p>An honest function goes <a id="_idIndexMarker210"/>beyond just indicating potential null returns. It creates a mindset of “return with intention.” When returning with intention, you’re not merely returning data; you’re communicating <span class="No-Break">a state.</span></p>
			<p>Consider the <span class="No-Break">following examples.</span></p>
			<p><strong class="bold">Returning collections</strong>: Instead of returning null for empty collections, always return an empty list or array. This prevents <strong class="source-inline">null</strong> checks and avoids <span class="No-Break">potential </span><span class="No-Break"><strong class="source-inline">NullReferenceException</strong></span><span class="No-Break">s:</span></p>
			<pre class="source-code">
List&lt;Order&gt; GetOrdersForUser(int userId)
{
    return ordersRepository.FindByUserId(userId) ?? new List&lt;Order&gt;();
}</pre>			<p><strong class="bold">Fetching data</strong>: When retrieving data that might not exist, instead of exceptions, a nullable type paints a <span class="No-Break">clearer picture:</span></p>
			<pre class="source-code">
Product? FindProductById(int productId)
{
    return productsRepository.GetById(productId);
}</pre>			<p>Transparent return types result in fewer surprises and more robust code. By clearly communicating what a function can return, you do <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Reduce errors</strong>: Because developers will handle scenarios they might have <span class="No-Break">overlooked otherwise</span></li>
				<li><strong class="bold">Promote clarity</strong>: Developers spend less time digging into function implementations, relying on return types to <span class="No-Break">guide behavior</span></li>
				<li><strong class="bold">Foster trust</strong>: A clear contract ensures that the function lives up to its promise, creating a sense of reliability in the <span class="No-Break">code base</span></li>
			</ul>
			<p>As we continue to explore honest functions, always remember: your functions are both performers and communicators. Let them not just do their task, but also communicate their intent and potential <a id="_idIndexMarker211"/>outcomes transparently. In doing so, you build resilient systems, create clear contracts, and encourage a safer, more predictable <span class="No-Break">coding environment.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor178"/>Demanding honesty from function inputs</h1>
			<p>A truly robust system <a id="_idIndexMarker212"/>is not just about what you return; it’s also about what you accept. Guarding your functions against potentially misleading or harmful inputs is paramount in creating predictable, <span class="No-Break">error-resistant applications.</span></p>
			<p>Consider this common scenario: You have a function that expects a certain type of input. However, when a <strong class="source-inline">null</strong> value sneaks its way in, your function breaks down, leading to the infamous <strong class="source-inline">NullReferenceException</strong>. To mitigate this, C# provides a way to demand honesty from function inputs using nullable <span class="No-Break">reference types.</span></p>
			<p>Let’s say you define a function <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    // Some operations on profile
}</pre>			<p>The intention is clear: the function expects <strong class="source-inline">UserProfile</strong>. However, what’s stopping a developer from passing <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">?</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor179"/>Nullable reference types to the rescue</h2>
			<p>As we discussed<a id="_idIndexMarker213"/> earlier, with C# 8.0, nullable reference<a id="_idIndexMarker214"/> types add another layer of protection. By turning on nullable reference types using <strong class="source-inline">#nullable enable</strong>, the compiler becomes <span class="No-Break">your guardian:</span></p>
			<pre class="source-code">
#nullable enable
public void UpdateUserProfile(UserProfile profile)
{
    // Some operations on profile
}</pre>			<p>Now, if any developer tries to pass a nullable <strong class="source-inline">UserProfile</strong> to the function, the compiler will raise a warning. This nudges developers in the right direction and prevents potential <span class="No-Break">runtime errors.</span></p>
			<p>However, warnings do not guarantee that <strong class="source-inline">null</strong> will not be used, so let’s look at another approach. Here, we defend the method with the simplest guard in a straightforward <span class="No-Break">null check:</span></p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    if (profile is null)
    {
        throw new ArgumentNullException(nameof(profile), "Profile cannot be null!");
    }
    // Some operations on profile
}</pre>			<p>This check ensures that if the function is ever provided <strong class="source-inline">null</strong>, it’ll immediately halt execution and provide a <span class="No-Break">clear reason.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor180"/>Using preconditions and contracts</h2>
			<p>Contracts and<a id="_idIndexMarker215"/> preconditions take the idea of guarding to a new level. By defining a set of rules that must hold true before a function can proceed, you’re making the function’s <span class="No-Break">expectations explicit.</span></p>
			<p>Consider the CodeContracts (<a href="https://github.com/Microsoft/CodeContracts">https://github.com/Microsoft/CodeContracts</a>) library provided by Microsoft. With this, you can ensure your function’s preconditions with a more <span class="No-Break">expressive syntax:</span></p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    Contract.Requires&lt;ArgumentNullException&gt;(profile != null, "Profile cannot be null!");
    // Some operations on profile
}</pre>			<p>This code is much more concise, however, it guards our method from <strong class="source-inline">null</strong> values in the <span class="No-Break">same way.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor181"/>Using built-in checks</h2>
			<p>In C# 6.0, we <a id="_idIndexMarker216"/>received a new way to guard against null values – <span class="No-Break"><strong class="source-inline">ArgumentNullException.ThrowIfNull</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    ArgumentNullException.ThrowIfNull(profile);
    // Some operations on profile
}</pre>			<p>Now, this code looks even cleaner and easier to read. Also, a more enhanced method for strings appeared in C# 7.0: <strong class="source-inline">ArgumentException.ThrowIfNullOrEmpty</strong>. It not only checks for null but also ensures that the string is <span class="No-Break">not empty:</span></p>
			<pre class="source-code">
public void UpdateUserEmail(long userId, string email)
{
    ArgumentException.ThrowIfNullOrEmpty(email);
    // Updating the email after finding the user by ID
}</pre>			<h2 id="_idParaDest-120"><a id="_idTextAnchor182"/>The power of explicit non-null inputs</h2>
			<p>By demanding non-null <a id="_idIndexMarker217"/>arguments, you do <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Improve predictability</strong>: Functions behave as expected since rogue nulls don’t <span class="No-Break">derail them</span></li>
				<li><strong class="bold">Boost developer confidence</strong>: With clear contracts, developers can invoke functions <span class="No-Break">without second-guessing</span></li>
				<li><strong class="bold">Reduce debugging time</strong>: Catching potential issues at compile time is always faster than <span class="No-Break">runtime debugging</span></li>
			</ul>
			<p>In order to write good functional code, ensuring clarity in what you accept is just as crucial as being transparent in what you return. By demanding honesty from function inputs, you’re laying a solid foundation for code that’s both reliable <span class="No-Break">and resilient.</span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor183"/>Pattern matching and nullable types</h1>
			<p>Pattern matching is <a id="_idIndexMarker218"/>a powerful tool in the C# arsenal, serving as a mechanism to make the code not only more expressive but also clearer and safer. When combined with nullable types, pattern matching helps us guard our code against <span class="No-Break">potential pitfalls.</span></p>
			<p>Pattern matching, introduced in C# 7.0 and enhanced in subsequent versions, is a feature that allows you to test a value against a pattern, providing a way to extract information from the value when it conforms to <span class="No-Break">the pattern.</span></p>
			<p>Consider the classic <strong class="source-inline">switch</strong> statement, evolved with <span class="No-Break">pattern matching:</span></p>
			<pre class="source-code">
object tower = GetRandomTower();
switch (tower)
{
    case ArcherTower a:
        Console.WriteLine($"It's an Archer Tower with a range of {a.Range}!");
        break;
    case CannonTower c:
        Console.WriteLine($"It's a Cannon Tower with an explosion radius of {c.ExplosionRadius}!");
        break;
    default:
        throw new Exception("Unknown tower type!");
        break;
}</pre>			<p>Here, <strong class="source-inline">ArcherTower</strong> and <strong class="source-inline">CannonTower</strong> are types. If <strong class="source-inline">tower</strong> is of type <strong class="source-inline">ArcherTower</strong>, it not only enters the respective case block but also casts it to the <strong class="source-inline">ArcherTower</strong> type, allowing <a id="_idIndexMarker219"/>you to access its <span class="No-Break">properties directly.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor184"/>Pattern matching with nullable types</h2>
			<p>Pattern matching<a id="_idIndexMarker220"/> truly shines when dealing with nullable types. Let’s consider a situation where we fetch a <span class="No-Break">user profile:</span></p>
			<pre class="source-code">
UserProfile? profile = GetUserProfile(userId);</pre>			<p>How do we handle this potential null in a type-safe, clear manner? Enter <span class="No-Break">pattern matching.</span></p>
			<h3>Using the “is” pattern</h3>
			<p>Ideally, our code should <a id="_idIndexMarker221"/>be easy to read, and what could be easier than using plain English? The “is” pattern is designed to assist <span class="No-Break">with that:</span></p>
			<pre class="source-code">
if (profile is null)
{
    Console.WriteLine("Profile not found.");
}
else
{
    Console.WriteLine($"Welcome, {profile.Name}!");
}</pre>			<p>This immediately makes the code more readable, drawing a clear distinction between <span class="No-Break">the scenarios.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor185"/>Switch expressions with property patterns</h2>
			<p>Introduced<a id="_idIndexMarker222"/> in C# 8.0, the <strong class="source-inline">switch</strong> expression paired with property patterns provides an even more concise way to handle <span class="No-Break">complex conditions:</span></p>
			<pre class="source-code">
public class Book
{
    public bool IsPublished { get; set; }
    public bool IsDraft { get; set; }
}
string bookStatus = book switch
{
    null =&gt; "No book found",
    { IsPublished: true, IsDraft: false } =&gt; "Published Book",
    { IsPublished: false, IsDraft: true } =&gt; "Draft Book",
    { IsPublished: false, IsDraft: false } =&gt; "Unpublished Book",
    _ =&gt; "Unknown book status"
};</pre>			<p>Here, not only do we check for null, but we also examine specific properties of the <strong class="source-inline">Book</strong> object, making<a id="_idIndexMarker223"/> decisions based on <span class="No-Break">their values.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor186"/>Ensuring clarity with nullable types</h2>
			<p>The amalgamation of pattern<a id="_idIndexMarker224"/> matching and nullable types ensures <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Safety</strong>: By handling potential nulls explicitly, you reduce the risk of <span class="No-Break">runtime errors</span></li>
				<li><strong class="bold">Expressiveness</strong>: Patterns allow you to condense complex conditional logic into concise, <span class="No-Break">readable constructs</span></li>
				<li><strong class="bold">Readability</strong>: Clear distinctions between different conditions and outcomes enable developers to understand the <span class="No-Break">flow effortlessly</span></li>
			</ul>
			<p>Pattern matching, when combined with nullable types, is a formidable tool for any C# developer. It not only streamlines code but also strengthens it, allowing you to write applications that are more resilient to unexpected scenarios. Use it and your code will be both a joy to write and a model <span class="No-Break">of reliability.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor187"/>The null object pattern</h1>
			<p>The null object pattern<a id="_idIndexMarker225"/> is a design pattern that provides an object as a surrogate for the lack of an object of a given interface. Essentially, it provides default behavior in the absence of meaningful data or behavior. This pattern is particularly useful in scenarios where you’d expect an object but don’t have one, and don’t want to <a id="_idIndexMarker226"/>constantly check <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor188"/>The problem with null checks</h2>
			<p>Imagine you’re developing<a id="_idIndexMarker227"/> a system where you have a series of operations to perform on a <strong class="source-inline">User</strong> object. Now, not every user might be initialized in the system, which often leads <span class="No-Break">to this:</span></p>
			<pre class="source-code">
if (user != null)
{
    user.PerformOperation();
}</pre>			<p>This might seem innocent for a single check. But when your code base is littered with such null checks, the code becomes verbose and less readable. The proliferation of null checks can also obscure the primary business logic, making the code base harder to maintain <span class="No-Break">and understand.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor189"/>The null object solution</h2>
			<p>The null object pattern <a id="_idIndexMarker228"/>provides an elegant solution to this problem. Instead of using a null reference to convey the absence of an object, you create an object that implements the expected interface but does nothing – a “<span class="No-Break">null object.”</span></p>
			<p>Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
public interface IUser
{
    void PerformOperation();
}
public class User : IUser
{
    public void PerformOperation()
    {
        // Actual implementation here
    }
}
public class NullUser : IUser
{
    public void PerformOperation()
    {
        // Do nothing: this is a null object
    }
}</pre>			<p>In situations where a user isn’t available, instead of returning <strong class="source-inline">null</strong>, you’d return an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">NullUser</strong></span><span class="No-Break">.</span></p>
			<p>Now, when you want to<a id="_idIndexMarker229"/> perform an operation, you can confidently do so without checking <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
user.PerformOperation();</pre>			<p>Regardless of whether <strong class="source-inline">user</strong> is <strong class="source-inline">RealUser</strong> or <strong class="source-inline">NullUser</strong>, the code won’t <span class="No-Break">throw </span><span class="No-Break"><strong class="source-inline">Null</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">ReferenceException</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor190"/>Advantages</h2>
			<p>Implementing the<a id="_idIndexMarker230"/> null object pattern offers several <span class="No-Break">key advantages:</span></p>
			<ul>
				<li><strong class="bold">Reduction of conditional statements</strong>: You can decrease the number of explicit null checks, leading to cleaner and more <span class="No-Break">readable code.</span></li>
				<li><strong class="bold">Safety</strong>: The risk of null reference exceptions gets <span class="No-Break">drastically reduced.</span></li>
				<li><strong class="bold">Polymorphism</strong>: By treating the null object the same as other objects, you can leverage the power of polymorphism, which can simplify and clarify <span class="No-Break">the code.</span></li>
				<li><strong class="bold">Clarity in intent</strong>: Null objects can have meaningful names, making it clear when a “do-nothing” or <a id="_idIndexMarker231"/>default behavior <span class="No-Break">is intentional</span></li>
			</ul>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor191"/>Limitations and considerations</h2>
			<p>While the null object<a id="_idIndexMarker232"/> pattern has its benefits, it’s not always the <span class="No-Break">best solution:</span></p>
			<ul>
				<li><strong class="bold">Overhead</strong>: For very large systems or deeply nested structures, introducing null objects everywhere can <span class="No-Break">add overhead</span></li>
				<li><strong class="bold">Complexity</strong>: If the interface or base class changes frequently, maintaining a corresponding null object can <span class="No-Break">become tedious</span></li>
				<li><strong class="bold">Obscured errors</strong>: If you’re not careful, using null objects can potentially mask problems in the system, since they provide default behavior that might hide issues that would have otherwise been exposed by a <span class="No-Break">null reference</span></li>
			</ul>
			<p>The null object pattern is a powerful tool in the arsenal of a C# developer. It’s not a one-size-fits-all solution, but when applied judiciously, it can greatly improve code clarity and robustness. Like all design patterns, understanding when and where to apply it is crucial. So don’t hurry to use it everywhere, and let’s look at a more functional approach – the <span class="No-Break"><strong class="source-inline">Option</strong></span><span class="No-Break"> type.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor192"/>Beyond null – using Option</h1>
			<p><strong class="source-inline">Nullable&lt;T&gt;</strong>, which is <a id="_idIndexMarker233"/>embedded in C#, is a great tool to work with <strong class="source-inline">null</strong> values, but there is a better and more straightforward construct for the handling of null values. <strong class="source-inline">Option</strong> is a type that provides more expressive tools for conveying the presence or absence of a value, serving as a richer alternative to <span class="No-Break">nullable types.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor193"/>A brief introduction to Option</h2>
			<p>At its core, the <strong class="source-inline">Option</strong> type can be thought of as a container that may or may not contain a value. Typically, it’s<a id="_idIndexMarker234"/> represented as either <strong class="source-inline">Some</strong> (which wraps a value) or <strong class="source-inline">None</strong> (indicating the absence of <span class="No-Break">a value).</span></p>
			<p>Usually, the implementation of <strong class="source-inline">Option</strong> looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public struct Option&lt;T&gt;
{
     private readonly bool _isSome;
     private readonly T _value;
     public static Option&lt;T&gt; None =&gt; default;
     public static Option&lt;T&gt; Some(T value) =&gt; new Option&lt;T&gt;(value);
     Option(T value)
     {
          _value = value;
          _isSome = _value is not null;
     }
     public bool IsSome(out T value)
     {
          value = _value;
          return _isSome;
     }
}</pre>			<p>While C# doesn’t have a built-in <strong class="source-inline">Option</strong> type, you can use the one above or use a library such as LanguageExt (<a href="https://github.com/louthy/language-ext">https://github.com/louthy/language-ext</a>), which provides <span class="No-Break">this functionality.</span></p>
			<p>Now, let’s look at how we can leverage the <span class="No-Break"><strong class="source-inline">Option</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
public Option&lt;UserProfile&gt; GetUserProfile(int userId)
{
    var user = database.FindUserById(userId);
    return new Option&lt;UserProfile&gt;(user);
}</pre>			<p>Another way <a id="_idIndexMarker235"/>to use <strong class="source-inline">Option</strong> is to write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public Option&lt;UserProfile&gt; GetUserProfile(int userId)
{
    var user = database.FindUserById(userId);
    return user is not null
   ? Option&lt;UserProfile&gt;.Some(user)
   : Option&lt;UserProfile&gt;.None;
}</pre>			<p>This code is more straightforward, however, the code before it is <span class="No-Break">more concise.</span></p>
			<p>Now, when calling this function, we can handle the result in a more <span class="No-Break">expressive manner:</span></p>
			<pre class="source-code">
var profileOption = GetUserProfile(userId);
UserProfile profile;
if (!profileOption.IsSome(out profile))
{
     // Handle the scenario when the profile is not available
}
// Continue with profile operations</pre>			<p>This approach makes the handling of potential missing values explicit <span class="No-Break">and clear.</span></p>
			<p>As Steve delved into <strong class="source-inline">Option</strong> types, he thought “This reminds me of how we handle power-ups in our <a id="_idIndexMarker236"/>games, sometimes they’re there, sometimes <span class="No-Break">they’re not.”</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor194"/>Advantages of the Option type over nullable types</h2>
			<p>When it comes to <a id="_idIndexMarker237"/>handling values that might be absent, opting for the <strong class="source-inline">Option</strong> type presents distinct advantages in <span class="No-Break">your code:</span></p>
			<ul>
				<li><strong class="bold">Expressiveness</strong>: Using <strong class="source-inline">Some</strong> and <strong class="source-inline">None</strong> constructs makes the code’s intention unmistakable. There’s a clear distinction between having a value and <span class="No-Break">lacking one.</span></li>
				<li><strong class="bold">Safety</strong>: The <strong class="source-inline">Option</strong> type forces you to handle both <strong class="source-inline">Some</strong> and <strong class="source-inline">None</strong> scenarios, reducing potential oversights in <span class="No-Break">your code.</span></li>
				<li> <strong class="bold">Extensibility</strong>: <strong class="source-inline">Option</strong> types often work together with other functional methods, enabling powerful and <span class="No-Break">concise transformations.</span></li>
			</ul>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor195"/>The interplay of Option and nullable types</h2>
			<p>It’s worth noting that <a id="_idIndexMarker238"/>while the <strong class="source-inline">Option</strong> type provides a robust mechanism for managing optional values, it doesn’t entirely replace nullable types. Instead, consider them as tools in your toolbox, each with <span class="No-Break">its strengths:</span></p>
			<ul>
				<li>Use nullable reference types when working with native C# constructs or when interfacing with libraries/frameworks <span class="No-Break">expecting them</span></li>
				<li>Adopt the <strong class="source-inline">Option</strong> type in scenarios requiring richer functional operations or when building libraries with a <span class="No-Break">functional flavor</span></li>
			</ul>
			<p>The <strong class="source-inline">Option</strong> type brings a taste of pure functional programming to the C# world, offering a sophisticated toolset for handling optional values. By integrating these constructs into your applications, you elevate the clarity, robustness, and expressiveness of your code. While the learning curve might be steeper than with nullable types, the <a id="_idIndexMarker239"/>rewards in terms of code quality and resilience are well worth <span class="No-Break">the effort.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor196"/>Practical scenarios – handling nulls effectively</h1>
			<p>As you must have <a id="_idIndexMarker240"/>already seen, dealing with nulls isn’t just a theoretical concern; it’s a daily challenge. By examining real-world scenarios, we can better appreciate the need for clear strategies in managing nulls and ensuring robust, <span class="No-Break">reliable applications.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor197"/>Case study – managing YouTube videos</h2>
			<p><strong class="bold">Scenario</strong>: A system<a id="_idIndexMarker241"/> retrieves video details from a database. Not every video ID queried will have a corresponding <span class="No-Break">video entry.</span></p>
			<p><span class="No-Break"><strong class="bold">Traditional approach</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public Video GetVideoDetails(int videoId)
{
    var video = database.FindVideoById(videoId);
    if (video == null)
    {
        throw new VideoNotFoundException($"Video with ID {videoId} not found.");
    }
    return video;
}</pre>			<p><span class="No-Break"><strong class="bold">Option approach</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public Option&lt;Video&gt; GetVideoDetails(int videoId)
{
    var video = database.GetVideoById(videoId);
    return new Option&lt;Video&gt;(video);
}</pre>			<p>By returning <strong class="source-inline">Video?</strong>, we’re signaling the potential absence of a video explicitly. Calling functions can then use <a id="_idIndexMarker242"/>pattern matching or direct null checks to handle the <span class="No-Break">absence gracefully.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor198"/>Case study – managing different video types</h2>
			<p><strong class="bold">Scenario</strong>: As YouTube<a id="_idIndexMarker243"/> started supporting various video formats and sources (e.g., live streams, 360-degree videos, standard uploads), the backend systems had to correctly identify and process each video type. With the platform’s increasing complexity and new video formats being introduced, using traditional if-else statements to handle these became cumbersome and less maintainable. Pattern matching emerged as an efficient solution to <span class="No-Break">this challenge.</span></p>
			<p><span class="No-Break"><strong class="bold">Traditional approach</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public string GetVideoDetails(Video video)
{
    if (video is LiveStream)
    {
        var liveStream = video as LiveStream;
        return $"Live Stream titled '{liveStream.Title}' is currently {liveStream.Status}.";
    }
    else if (video is Video360)
    {
        var video360 = video as Video360;
        return $"360-Degree Video titled '{video360.Title}' with a resolution of {video360.Resolution}.";
    }
    // ... and so on for other video types
    else
    {
        return "Unknown video type.";
    }
}</pre>			<p><strong class="bold">Pattern </strong><span class="No-Break"><strong class="bold">matching approach</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public string GetVideoDetails(Video video)
{
    return video switch
    {
        LiveStream l =&gt; $"Live Stream titled '{l.Title}' is currently {l.Status}.",
        Video360 v =&gt; $"360-Degree Video titled '{v.Title}' with a resolution of {v.Resolution}.",
        StandardUpload s =&gt; $"Standard video titled '{s.Title}' uploaded on {s.UploadDate}.",
        _ =&gt; "Unknown video type."
    };
}</pre>			<p>Pattern matching provided a more elegant, concise, and readable approach to handling different video types. As YouTube introduces new video formats or features, they can be seamlessly integrated <a id="_idIndexMarker244"/>into the <strong class="source-inline">GetVideoDetails</strong> function. This modern approach reduces potential errors, simplifies the code, and <span class="No-Break">enhances maintainability.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor199"/>Case study – working with non-existing objects</h2>
			<p><strong class="bold">Scenario</strong>: As YouTube <a id="_idIndexMarker245"/>expanded globally, it was increasingly common to encounter incomplete or missing data due to various reasons, such as network hiccups, data migration issues, or regional content restrictions. Using traditional null checks became increasingly cumbersome, leading to scattered logic throughout the code base. The null object pattern offered a systematic approach to provide a default object instead of a <span class="No-Break">null reference.</span></p>
			<p><span class="No-Break"><strong class="bold">Traditional approach</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public Video GetVideo(int videoId)
{
    var video = database.FindVideoById(videoId);
    if (video == null)
    {
        throw new VideoNotFoundException($"Video with ID {videoId} not found.");
    }
    return video;
}</pre>			<p>And when displaying <a id="_idIndexMarker246"/><span class="No-Break">the video:</span></p>
			<pre class="source-code">
var video = GetVideo(videoId);
if(video != null)
{
    Display(video);
}
else
{
    ShowError("Video not found");
}</pre>			<p><strong class="bold">Null object </strong><span class="No-Break"><strong class="bold">pattern approach</strong></span><span class="No-Break">:</span></p>
			<p>First, create a default object <span class="No-Break">for videos:</span></p>
			<pre class="source-code">
public class NullVideo : Video
{
    public override string Title =&gt; "Video not available";
    public override string Description =&gt; "This video is currently not available.";
    // Other default properties or methods...
}</pre>			<p>Then modify the <span class="No-Break">fetching method:</span></p>
			<pre class="source-code">
public Video GetVideo(int videoId)
{
    return database.FindVideoById(videoId) ?? new NullVideo();
}</pre>			<p>Then display <span class="No-Break">the video:</span></p>
			<pre class="source-code">
var video = GetVideo(someId);
Display(video); // No special null handling here</pre>			<p>By adopting the null object pattern, YouTube’s Video Management System managed to encapsulate the behavior associated with null or missing data within the default “null object,” leading to <a id="_idIndexMarker247"/>more unified and predictable system behavior. It removed numerous null checks scattered throughout the code base, reducing the chances of null reference exc<a id="_idTextAnchor200"/>eptions, and enhancing the system’s robustness <span class="No-Break">and maintainability.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor201"/>The impact of handling nulls in real-world scenarios</h2>
			<p>In real-life situations, how <a id="_idIndexMarker248"/>we deal with null values in our code can have a big impact. Let’s explore how handling nulls can make <span class="No-Break">a difference:</span></p>
			<ul>
				<li><strong class="bold">Error reduction</strong>: By acknowledging and handling potential nulls proactively, we drastically reduce the occurrence of runtime errors such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">NullReferenceException</strong></span></li>
				<li><strong class="bold">Clearer intention</strong>: Using tools such as nullable reference types and pattern matching, our code more transparently communicates <span class="No-Break">potential outcomes</span></li>
				<li><strong class="bold">Developer confidence</strong>: When the system’s behavior is predictable, developers can integrate and extend it with <span class="No-Break">greater confidence</span></li>
			</ul>
			<p>In real-world scenarios, the unknowns and uncertainties are plentiful. By incorporating clear and transparent handling of potential nulls, we ensure that our applications are both resilient and maintainable. Whether you’re managing video data, processing forms, or integrating with third-party services, a deliberate approach to null management can make all <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker249"/></span><span class="No-Break"> difference.</span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor202"/>The reality of honesty in C# – why there will never be truly honest functions</h1>
			<p>C# is a multi-paradigm<a id="_idIndexMarker250"/> language, offering a lot of features, each designed with various considerations in mind. As we venture into the topic of “honest functions,” we must also acknowledge that C#’s design, while powerful, has <span class="No-Break">some trade-offs.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor203"/>The compromises of the C# language design</h1>
			<p>C#’s design involves certain <a id="_idIndexMarker251"/>trade-offs. Let’s examine them and understand <span class="No-Break">their impact:</span></p>
			<ul>
				<li><strong class="bold">Historical baggage</strong>: C# has evolved over the years, adding new features while ensuring backward compatibility. This means that older, less “honest” ways of doing things will always remain a part of <span class="No-Break">the language.</span></li>
				<li><strong class="bold">Performance versus safety</strong>: Offering both low-level performance-oriented features and high-level safety features is not easy. Sometimes, the requirements of performance might lead developers away from purely “<span class="No-Break">honest” constructs.</span></li>
				<li><strong class="bold">Broad audience</strong>: C# is designed for a vast range of developers, from those writing system-level code to high-level enterprise applications. As a result, the language can’t be too opinionated in favor of any single paradigm, including <span class="No-Break">functional programming.</span></li>
				<li><strong class="bold">Exceptions system</strong>: The current system of exceptions makes it virtually impossible to have a truly honest function. Why? Because every method can generate <strong class="source-inline">OutOfMemoryException</strong>, for example. Although, we might think that if we are the creators of our code it will do as we wish, don’t forget that the <strong class="bold">Common Language Runtime</strong> (<strong class="bold">CLR</strong>) is the<a id="_idIndexMarker252"/> true master here and it can interfere with <span class="No-Break">our intentions.</span></li>
			</ul>
			<p>C# offers a rich variety of features, enabling developers to craft solutions across different paradigms. In our pursuit of honesty and clarity, we should recognize and respect the trade-offs intrinsic to the language’s design. Additionally, we need to remember that our <a id="_idIndexMarker253"/>code does not run in an ideal world and that the environment also impacts the way our <span class="No-Break">programs work.</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor204"/>Practical tips and best practices</h1>
			<p>As we navigate the nuances of functional programming in C# and its approach to handling nulls, some practical strategies emerge. These strategies ensure that our applications remain robust while benefiting from t<a id="_idTextAnchor205"/>he enhanced clarity and predictability that functional <span class="No-Break">paradigms provide.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor206"/>Strategies for migrating existing code bases to adopt nullable reference types and Option</h2>
			<p>Let’s consider <a id="_idIndexMarker254"/>strategies for migrating your existing code bases to adopt nullable reference types <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Option</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Incremental adoption</strong>: Instead of overhauling the entire code base, start by enabling nullable reference types in specific areas or projects. This can be achieved using the <strong class="source-inline">#nullable </strong><span class="No-Break"><strong class="source-inline">enable</strong></span><span class="No-Break"> directive:</span><pre class="source-code">
#nullable enable
// The section of the code where nullable reference types are enabled.
#nullable restore</pre></li>				<li><strong class="bold">Use of analysis tools</strong>: Tools such as Roslyn analyzers (<a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview">https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview</a>) can help identify potential nullability issues <span class="No-Break">in code.</span></li>
				<li><strong class="bold">Refactoring with caution</strong>: When introducing the <strong class="source-inline">Option</strong> type, ensure you understand the implications of the calling code. Functio<a id="_idTextAnchor207"/>ns may return different types, requiring adjustments to the <span class="No-Break">calling logic.</span></li>
			</ul>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor208"/>Common pitfalls and how to navigate them</h2>
			<p>Let’s take a closer <a id="_idIndexMarker255"/>look at common pitfalls and discover how to effectively <span class="No-Break">navigate them:</span></p>
			<ul>
				<li><strong class="bold">Assuming non-null values prematurely</strong>: Even with nullable reference types enabled, always validate inputs, especially if they come from <span class="No-Break">external sources:</span><pre class="source-code">
public void ProcessData(string? data)
{
    if (data is null)
    {
        throw new ArgumentNullException(nameof(data));
    }
    // Rest of the processing...
}</pre></li>				<li><strong class="bold">Overusing Option</strong>: While the <strong class="source-inline">Option</strong> type is powerful, it might not be suitable for every scenario. For simple cases where nullability is self-explanatory, nullable reference types might be <span class="No-Break">more appropriate.</span></li>
				<li><strong class="bold">Forgetting legacy code</strong>: Older parts of the code base may not adhere to new paradigms. When integra<a id="_idTextAnchor209"/>ting new and old code, be cautious of potential mismatches <span class="No-Break">in expectations.</span></li>
			</ul>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor210"/>Testing strategies for null and Option handling</h2>
			<p>Let’s talk about how to <a id="_idIndexMarker256"/>test your code when it deals with null and <strong class="source-inline">Option</strong> in a functional programming way. It’s important to test that your code works correctly, and now we’ll explore how to <span class="No-Break">do that:</span></p>
			<ul>
				<li><strong class="bold">Unit testing with null values</strong>: Ensure unit tests cover scenarios where null values are passed to functions. This helps catch potential null-related issues before they <span class="No-Break">reach production:</span><pre class="source-code">
[Test]
public void GetUser_NullInput_ThrowsException()
{
    // arrange part of the test
    // act &amp; assert
    Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; sut.GetUser(null));
}</pre></li>				<li><strong class="bold">Testing Option return types</strong>: When functions return <strong class="source-inline">Option</strong> types, tests should cover <a id="_idIndexMarker257"/>both <strong class="source-inline">Some</strong> and <strong class="source-inline">None</strong> scenarios to ensure all code paths <span class="No-Break">are verified:</span><pre class="source-code">
[Test]
public void GetUser_PresetUserId_ReturnsProfile()
{
    // arrange part of the test
    // act
    var result = sut.GetUser(123);
    // assert
    User user;
    if (!result.IsSome(out user))
    {
        Assert.Fail("Expected a user profile.");
    }
    // The rest of the assertions
}</pre></li>				<li><strong class="bold">Integration testing</strong>: Beyond unit tests, integration tests should be employed to validate interactions between different components, especially when dealing with databases, APIs, or other external systems that might return unexpected <span class="No-Break">null values.</span></li>
			</ul>
			<p>Learning about functional programming in C# might not be an easy thing, but you have already started this <a id="_idIndexMarker258"/>venture and continued it right up to the current lines. You are doing great, so keep it up, and let’s reinforce the knowledge you’ve acquired with our traditional <span class="No-Break">three exercises.</span></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor211"/>Exercises</h1>
			<p>Now that Steve has learned about honest functions, null, and Option types, Julia has prepared some challenges to help him apply these concepts to his tower defense game. Let’s see if you can help Steve <span class="No-Break">solve them!</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor212"/>Exercise 1</h2>
			<p>Steve’s game needs to fetch tower information reliably. Refactor this function to use an honest return type that clearly indicates when a tower might not <span class="No-Break">be found:</span></p>
			<pre class="source-code">
public Tower GetTowerByPosition(Vector2 position)
{
     var tower = _gameMap.FindTowerAt(position);
     return tower;
}</pre>			<h2 id="_idParaDest-147"><a id="_idTextAnchor213"/>Exercise 2</h2>
			<p>In the game players can apply power-ups to towers. Refactor this function to ensure it handles null <span class="No-Break">inputs gracefully:</span></p>
			<pre class="source-code">
public void ApplyPowerUp(Tower tower, PowerUp powerUp)
{
     tower.ApplyPowerUp(powerUp);
     _gameState.UpdateTower(tower);
}</pre>			<h2 id="_idParaDest-148"><a id="_idTextAnchor214"/>Exercise 3</h2>
			<p>Steve wants to provide players with detailed information about the enemies they’re facing. Using the enemy classes from his game, implement a function that generates descriptive strings for each <span class="No-Break">enemy type:</span></p>
			<pre class="source-code">
public abstract class Enemy {}
public class Goblin : Enemy
{
     public int Strength { get; set; }
     public bool HasWeapon { get; set; }
}
public class Dragon : Enemy
{
     public int FireBreathDamage { get; set; }
     public int WingSpan { get; set; }
}
public class Wizard : Enemy
{
     public string[] Spells { get; set; }
     public int MagicPower { get; set; }
}
public string DescribeEnemy(Enemy? enemy)
{
     // Your implementation here
}</pre>			<h1 id="_idParaDest-149"><a id="_idTextAnchor215"/>Solutions</h1>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor216"/>Exercise 1</h2>
			<p>Incorporate the <strong class="source-inline">Option</strong> return type to signify that a user may or may not <span class="No-Break">be found:</span></p>
			<pre class="source-code">
public Option&lt;Tower&gt; GetTowerByPosition(Vector2 position)
{
     var tower = _gameMap.FindTowerAt(position);
     return Option&lt;Tower&gt;.Some(tower);
}</pre>			<h2 id="_idParaDest-151"><a id="_idTextAnchor217"/>Exercise 2</h2>
			<p>Utilize a built-in check for null inputs that will throw an exception if the user profile <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public void ApplyPowerUp(Tower? tower, PowerUp? powerUp)
{
     ArgumentNullException.ThrowIfNull(tower, nameof(tower));
     ArgumentNullException.ThrowIfNull(powerUp, nameof(powerUp));
     tower.ApplyPowerUp(powerUp);
     _gameState.UpdateTower(tower);
}</pre>			<h2 id="_idParaDest-152"><a id="_idTextAnchor218"/>Exercise 3</h2>
			<p>Employ pattern matching to address potential null <span class="No-Break">values elegantly:</span></p>
			<pre class="source-code">
public string DescribeEnemy(Enemy? enemy)
{
     return enemy switch
     {
                  Goblin g =&gt; $"A goblin with {g.Strength} strength, {(g.HasWeapon ? "armed" : "unarmed")}.",
                  Dragon d =&gt; $"A dragon with {d.FireBreathDamage} fire breath damage and a {d.WingSpan}m wingspan.",
                  Wizard w =&gt; $"A wizard with {w.MagicPower} magic power, knowing {w.Spells.Length} spells.",
                  null =&gt; "No enemy in sight.",
                  _ =&gt; "An unknown enemy approaches!"
     };
}</pre>			<p>These exercises and their solutions provide an applied understanding of the concepts covered, guiding you toward a functional and robust approach to handling nulls and honest functions in C#. Keep experimenting, keep iterating, and always lean into the principles of functional programming to craft clearer, more resilient <span class="No-Break">C# code.</span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor219"/>Summary</h1>
			<p>As our journey through honest functions and the intricacies of null handling in C# draws to a close, let’s reflect on our discoveries and look to <span class="No-Break">the future.</span></p>
			<p>We have traversed the history and implications of <strong class="source-inline">null</strong> in C#. We’ve understood its nuances, its dangers, and its power. By now, the infamous <strong class="source-inline">NullReferenceException</strong> should be less of a nemesis and more of an old acquaintance you nod at from across the room, acknowledging its presence but never letting it disrupt <span class="No-Break">your day.</span></p>
			<p>Honest functions – or functions that explicitly state their intentions, inputs, and outputs – represent a paradigm shift toward predictability, clarity, and resilience. Embracing honesty in functions is not merely about avoiding pitfalls but about embracing a philosophy of transparency. In doing so, we create code that other developers can trust, understand, and <span class="No-Break">build upon.</span></p>
			<p>We’ve dived deep into the realms of nullable reference types and pattern matching and even touched upon the null object pattern and the <strong class="source-inline">Option</strong> type, all of which present us with powerful tools to express our intentions with precision <span class="No-Break">and grace.</span></p>
			<p>Yet, as with all tools, it’s essential to remember that their strength lies in their appropriate application. The world of C# is vast, and while functional programming principles offer much value, they are but one aspect of a rich tapestry. It’s up to you, the developer, to discern when to employ these concepts and when to lean into other paradigms. As we add a functional paradigm to our habitual way of coding, it may cause different errors and we’d better be ready to work with them. That’s why I invite you to read the next chapter, about <span class="No-Break">error handling.</span></p>
		</div>
	

		<div id="_idContainer020" class="Content">
			<h1 id="_idParaDest-154" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor220"/>Part 2:Advanced Functional Techniques</h1>
			<p>Building on the foundations established in Part I, we now delve into more advanced functional programming techniques. We’ll start by exploring functional approaches to error handling, moving beyond traditional try-catch blocks to more elegant solutions. Next, we’ll cover higher-order functions and delegates, unlocking the power of functions as first-class citizens. The section concludes with an in-depth look at functors and monads, advanced concepts that provide powerful tools for managing complexity in <span class="No-Break">your code.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21069_05.xhtml#_idTextAnchor221"><em class="italic">Chapter 5</em></a><em class="italic">, Error Handling</em></li>
				<li><a href="B21069_06.xhtml#_idTextAnchor270"><em class="italic">Chapter 6</em></a><em class="italic">, Higher-Order Functions and Delegates</em></li>
				<li><a href="B21069_07.xhtml#_idTextAnchor332"><em class="italic">Chapter 7</em></a><em class="italic">, Functors and Monads</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer021">
			</div>
		</div>
		<div>
			<div id="_idContainer022" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>