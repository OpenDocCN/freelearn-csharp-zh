- en: Working with Data Bindings
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with CLR properties and UI notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dependency properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with attached properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding to an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding to a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element-to-element data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting data in a `DataGrid` control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping data in a `DataGrid` control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering data in a `DataGrid` control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using value converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multi-value converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data binding** is a technique to establish a connection between the UI of
    the application and the business logic in order to have proper data synchronization
    between them. Though you can directly access UI controls from code behind to update
    their content, data binding has become the preferred way to update the UI layer
    for its automatic notification system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make data binding work in WPF applications, both sides of the binding must
    provide a change notification to the other side. The source property of a data
    binding can be a .NET CLR property or a dependency property, but the target property
    must be a dependency property, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14330605-76a3-417e-b2ec-fca74e9203e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Data binding is typically done in XAML using the `{Binding}` markup extension.
    In this chapter, we are going to learn more about the WPF data binding mechanism
    by exploring a few recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CLR properties and UI notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CLR properties are just a wrapper around the private variables to expose
    getters and setters to retrieve and assign the value of a variable. You can use
    these normal CLR properties in data binding, but the automatic UI notifications
    are not possible by default, unless you create the notification mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to perform data binding with CLR properties
    and then learn how to trigger notifications from the code to automatically update
    the UI when the value changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with data binding with normal CLR properties, open your Visual
    Studio IDE and create a new WPF application project called `CH04.NotificationPropertiesDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create CLR properties that send notifications
    to the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` file and give the window a name. For example, name
    the current window `window` by adding the following syntax to the `Window` tag:
    `x:Name="window"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now divide the default `Grid` into a few rows and columns. Copy the following
    XAML markup inside your `Grid` panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the grid has been divided into rows and columns, let''s add a few text
    and button controls inside it. Place these at proper cells, as shared in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the code behind the file `MainWindow.xaml.cs` and add two CLR properties
    named `Department` and `PersonName` inside it. The first property (`Department`)
    always returns a constant string, whereas the second property (`PersonName`) can
    accept values from the user. Here''s the complete code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code-behind class, add the following event implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the application. As shown in the following screenshot, enter
    your name in the `TextBox` and click the Submit button. A message will be shown
    to the user with the entered name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/221e6c32-5d83-4f94-9ef1-2062272bf311.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the Reset button and watch the behavior. Even though the code
    has been written to set the property with an empty string, the UI was not modified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8bee4bd9-c134-48b7-9348-7e56371f9fab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To send a notification to the UI when there is a change in the associated property,
    you need to implement the `INotifyPropertyChanged` interface, present in the `System.ComponentModel`
    namespace. Open the `MainWindow.xaml.cs` file and add the`INotifyPropertyChanged`
    interface as defined here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to add the following `using` namespace declaration to resolve the
    build issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `PropertyChanged` event implementation inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now notify the framework to update the UI when there is a change in the property
    value. Modify the existing implementation of the `PersonName` property to give
    a call to the `OnPropertyChanged` event, passing the name of the property as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you are using C# 6 and above, you can remove the hardcoded strings by using
    the `nameof` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the application once again. Enter your name in the input box and
    hit the Submit button. You will see the message box mentioning the entered name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close the message box and hit the Reset button. You will see that the text
    in the `TextBox` initialized to an empty string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/18267dcb-d8c5-4cc0-86a8-4eed1d270284.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, the `Department` property has a data binding with
    the `TextBlock` control and thus the associated `TextBlock` displays the text
    returned by the property. Similarly, the `PersonName` property has a data binding
    with a `TextBox` control. As the data binding has been made to the `Text` property
    of the `TextBlock` (with `TwoWay` mode), it automatically updates the associated
    property when the user changes it in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: So, when you hit the Submit button, the `OnSubmit` event triggers, and it directly
    reads the `PersonName` property instead of fetching the text from the UI by accessing
    the `Text` property of the `TextBox` control.
  prefs: []
  type: TYPE_NORMAL
- en: When you hit the Reset button, the `OnReset` event triggers and it sets the
    `PersonName` property to an empty string. But the UI does not change. This is
    because the CLR property does not have a notification mechanism to automatically
    update the UI when a value change happens to it.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this, WPF uses the `INotifyPropertyChanged` interface, which defines
    a `PropertyChanged` event to automatically push the UI notification to update
    the elements in the UI thread. In the example, when you set the `PersonName` property,
    the `OnPropertyChanged` event fires from the property `setter` and notifies the
    UI that the `PersonName` has been modified. The UI then sets the value based on
    the property value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data binding can be unidirectional (source > target or target > source) or
    bidirectional (source < > target), known as **mode**, and is defined in four categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OneTime**: This type of data binding mode causes the source property to initialize
    the target property. After the binding gets generated, no notifications will be
    triggered. You should use this type of data binding where the source data does
    not change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OneWay**: This type of binding causes the source property to automatically
    update the target property. The reverse is not possible here. For example, if
    you want to display a label/text in the UI based on some condition in the code
    behind or business logic, you need to use `OneWay` data binding as you don''t
    need to update back the property from the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TwoWay**: This type of binding is a bidirectional data binding, where both
    the source property and the target property can send update notifications. This
    is applicable for editable forms where the user can change the value displayed
    in the UI. For example, the `Text` property of a `TextBox` control supports this
    type of data binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OneWayToSource**: This is another unidirectional data binding, which causes
    the target property to update the source property (the reverse of `OneWay` binding).
    Here, the UI sends notification to the context and no notification is generated
    if the context changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a simple diagram, describing how the various data binding modes work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d2f78d4-084b-4607-a235-b0bdd9776aed.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with dependency properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WPF provides a set of services which can be used to extend the CLR properties
    to provide additional benefits such as automatic UI notifications in the ecosystem.
    To implement the dependency property, the class must be inherited from the `DependencyObject`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: A CLR property reads directly from the private member of the class, whereas
    a dependency property is stored in a dictionary of keys and values provided by
    the base class. As the dependency property stores the property only when it is
    changed, it uses a great deal less memory and is accessed faster.
  prefs: []
  type: TYPE_NORMAL
- en: To easily create a dependency property in a `.cs` file, use the `propdp` code
    snippet. In any class file which is inherited from `DependencyObject`, write `propdp`
    followed by *TAB* to generate the structure of it. Navigate using the *TAB* key
    and change the type, name, owner, and metadata details.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use a dependency property to automatically
    notify the UI that a change has been made in the property value, which will reduce
    the burden of defining the `PropertyChanged` event from the `INotifyPropertyChanged`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open the Visual Studio IDE and create a project named `CH04.DependencyPropertyDemo`.
    Make sure that you have selected the WPF application type as a project template.
    We will use the same example that we have created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a dependency property, bind it to the
    UI, and send notifications from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From Solution Explorer, open the `MainWindow.xaml` page and use the same UI
    design that we have used in the previous example. Copy the following XAML markup
    and replace the content of the `MainWindow.xaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the code-behind file and add the following CLR property inside the
    class. We don''t need to make it a dependency property, as the value is always
    constant here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, inside the class, write `propdp` and press the *TAB* key twice. It will
    create the structure of the property system. By default, `int` will be highlighted.
    Replace it with `string`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *TAB* key once again and rename the property name from `MyProperty`
    to `PersonName`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *TAB* key once again to change the focus to the `ownerclass` name
    parameter of the `Register` method. Rename it to the class name of the owner.
    In our case, it is `MainWindow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the *TAB* key once again to move the focus to the property metadata.
    Here you can set the default value of the property. By default, `0` (zero) is
    selected. Change it to `string.Empty`. Here''s the complete implementation of
    our dependency property, named `PersonName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the following event implementations for the Submit and Reset buttons
    inside the `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As the code change has been done, let''s build and run the application. You
    will see the application window pop up on the screen. Enter a name in the provided
    input box and click Submit. The message box will be shown, including the entered
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/276819c8-4fb5-411c-84bd-71031c93bbf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Reset button. This will clear the text inside the input box (`TextBox`
    control):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d295ae5e-01fa-481f-a798-a1a2f4db2ee2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The getters and setters work differently in dependency properties. Rather than
    returning or setting a value from/to its private field (`CLR` property), the dependency
    property calls `GetValue(DependencyProperty)` or `SetValue(DependencyProperty,
    value)` from its base class `DependencyObject`. In our example, the name of the
    dependency property is `PersonNameProperty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The static `Register` method of the `DependencyProperty` class takes a few
    parameters to create the `dependency` property. The first parameter that it takes
    is the actual `name` of the property. The second parameter is the `type` of the
    property, the third is the `owner type` which is basically the class name where
    the `dependency` property is going to create. The next parameter it takes is the
    metadata information, where you can assign the default value of the property.
    Here is the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you set a value from the XAML, by providing a data binding with the property,
    it sets the value which you can pick from an accessible place. Similarly, when
    you set the value from code, it automatically notifies the UI that a change has
    been made and performs the same change in the UI. Thus, it reduces the burden
    of implementation of the `INotifyPropertyChanged` interface and its associated
    `PropertyChanged` event.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The property metadata of the `Register` method can take one to three arguments
    to it. The first one is the default value that we have seen earlier. The second
    one is the `PropertyChangedCallback`, which is to be called by the property system
    whenever the effective value of the property changes. The third one is the `CoerceValueCallback`,
    which is to be called whenever the property system calls `System.Windows.DependencyObject.CoerceValue`
    method against the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, the property metadata is created using one to two parameters
    defining the default value and the property changed callback. Let''s learn with
    an example demonstrating how this can be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `OnPropertyChangedCallback` event will be raised whenever you change
    the value of the property. You can take further action based on the event trigger.
    You can also call other non-static members from the callback event by accessing
    the `DependencyObject` "`d`".
  prefs: []
  type: TYPE_NORMAL
- en: You can also validate a dependency property before submitting it to the property
    system. The fifth parameter of the `Register` method accepts a delegate, called
    `ValidateValueCallback`. You can implement it to validate the effective value
    of the `dependency` property. If the value has been validated properly, it will
    return `true`; if not it will be treated as invalid and will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with attached properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An attached property is a kind of `dependency` property which is intended to
    be used as a global property type and is settable on any object. It does not have
    conventional property wrapper and can still be used to receive notification of
    a value change. Unlike dependency properties, attached properties are not defined
    in the same class where they are used.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of using attached properties is to allow different child elements
    to specify unique values of a property, which is actually defined in a parent
    element. For example, you can use `Grid.Row`, `Grid.Column` in any child elements
    of the `Grid` panel. Similarly, the `Canvas.Left`, `Canvas.Top` attached properties
    are used in any child elements of a `Canvas` panel.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create an `Attached` property and perform
    the operation from a different class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a new project called `CH04.AttachedPropertyDemo`, based on the
    WPF application project type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, perform the following steps to create the `Attached` property named `SelectOnFocus`,
    to a `TextBox` control, which when enabled will select the text on focus change
    by using the *TAB* key:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Solution Explorer, right-click on the project, and add a new class by following
    the Add | Class... context menu path. Give the class the name `TextBoxExtensions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `TextBoxExtensions.cs` file and add the following `using` namespace
    inside the class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Inside the class body, type `propa` and press *TAB* twice. This will create
    the structure of the attached dependency property and the keyboard focus will
    move to the `property` type, which is `int` by default. Change it to `bool`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *TAB* again to select `MyProperty`. Rename it to `SelectOnFocus`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*TAB* it once again to select the `ownerclass` and change it to `TextBoxExtensions`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press *TAB* to set the property metadata. Set the default value to `false`.
    Set the `PropertyChangedCallback` parameter to `OnSelectOnFocusChanged`. Here''s
    the complete code, including the callback event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `MainWindow.xaml` file and replace the existing XAML content with
    the following one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Focus on the first textbox. It won't have any selection by default. Press *TAB*
    to move the focus to the second textbox. The entire text of the textbox will be
    highlighted. Press *TAB* again to focus on the first textbox. There won't be any
    selection, as the said attached property was added to the second textbox only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependency properties are registered by calling the `DependencyProperty.Register`
    method, whereas attached properties are registered by calling the `DependencyProperty.RegisterAttached`
    method. It takes four parameters—the actual name of the property, type of the
    property, type of the owner, and property metadata.
  prefs: []
  type: TYPE_NORMAL
- en: When you set the property to the control, as an attached property (`extensions:TextBoxExtensions.SelectOnFocus="True"`,
    in our example), in the XAML, it registers it to the WPF property system during
    the instance load and fires the `PropertyChangedCallback` defined in the `RegisterAttached`
    method. In the preceding example, the `OnSelectOnFocusChanged` event will be called,
    which will register the `GotFocus` event on the associated `TextBox` control to
    perform the selection of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a specific control such as `TextBox`, you can use `UIElement` to
    generalize the association. In this way, you can apply it to any control, by registering
    the attached property in the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding to an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have learned how to create CLR properties with the `INotifyPropertyChanged`
    interface; we have also learned about the dependency property with a simple data
    type. There are many instances when you need to bind an object of some class/model
    to an UI and display its associated properties necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to do object data binding to show and retrieve
    information to and from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open the Visual Studio instance and create a new project named `CH04.ObjectBindingDemo`.
    Make sure you select the proper WPF application project type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the model and dependency property, and
    bind the data to the UI controls, so that, when a change happens in underlying
    data, it automatically reflects in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a data model. From Solution Explorer, right-click on
    the project and navigate to the context menu entry Add | Class... and create a
    class file called `Person.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content of the `Person` class with the following three properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to Solution Explorer once again and double-click to open the `MainWindow.xaml.cs`
    file. Create a dependency property named `PersonDetails` and set its data type
    as `Person`. Also, set its default value to `null` as shared here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after the `InitializeComponent()` method call, inside the constructor
    of the `MainWindow` class, initialize the `PersonDetails` property and set it
    as the `DataContext` of the selected class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, as the backend code is ready, let's open the `MainWindow.xaml` file to
    design the UI and do the data binding with our model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `Grid` panel with the following XAML markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compile the project and run the application. You will see the following
    UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15628741-7329-45f9-8b2a-66eb5057bab7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UI of the application has two `TextBlock` controls to represent the data
    and one `TextBox` to get input from the user. In the first `TextBlock` control,
    we have multiple `<Run/>` commands to bind the data value from the `Person` class,
    along with other static texts and a `Hyperlink` to create a link. The data of
    the UI class is bound to the `DataContext`, which is `PersonDetails` in our case.
    The properties binded to the UI come from the `Person` class, which is the data
    type of the `PersonDetails` dependency property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextBox` control is bound to the `Experience` property, which is again
    bound to the third `Run` command of the first `TextBlock`. Hence, it is showing
    `10` in both places. Now change the value of the `TextBox` control to `15` and
    press the *TAB* key to change the focus. This will trigger the `TextChanged` event
    of the `TextBox` and modify the underlying property named `Experience`. Due to
    its nature, the notification will be automatically sent to the UI and the `TextBlock`
    control will get updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ec33b64-7349-44e1-979b-1f937baa2a16.png)'
  prefs: []
  type: TYPE_IMG
- en: Data binding to a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned about object data binding to show a single object on the UI, let's
    begin with binding a collection of data objects in a UI to display all the records
    to the user. We will discuss it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open a Visual Studio instance and create a new project called `CH04.CollectionBindingDemo`.
    Make sure you use the WPF application project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a collection data model and bind it to
    the UI, using a `DataGrid` control:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Solution Explorer, right-click on the project. From the context menu,
    navigate to Add | Class... to create a class file named `Employee.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Employee.cs` file and replace the class implementation with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `MainWindow.xaml.cs` file and add the following `using` statement
    to define `ObservableCollection` inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `MainWindow` class implementation, create a dependency property
    named `Employees`, of type `ObservableCollection<Employee>`, as shared here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just after the `InitializeComponent()` method call inside the constructor,
    write the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `MainWindow.xaml` file and a `DataGrid` control inside the default
    `Grid` panel. Create three columns and bind their values to the `FirstName`, `LastName`,
    and `Department` properties of the `Employee` object. Make sure you set the `AutoGenerateColumns`
    property of the `DataGrid` to `False`. Here''s the complete XAML markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build the project and run the application. You will see the following screen,
    along with the data inside a `DataGrid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5fe8ba1a-dccd-4197-bd40-07dbd1818a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you bind a collection of objects to a `DataGrid`, it creates data grid
    rows for each object present in the collection. The column defines the properties
    exposed by the object.
  prefs: []
  type: TYPE_NORMAL
- en: When the `AutoGenerateColumns` property of the `DataGrid` is set to `True` (default),
    it automatically creates the columns based on the property list. In this example,
    we have set the `AutoGenerateColumns` property to `False` and defined the individual
    columns explicitly. Using this method, you can define which column to show or
    hide. Once you set the collection to the `ItemsSource` property of the `DataGrid`,
    it populates the rows and columns accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also define the binding in the XAML. To do this, first open the `MainWindow.xaml.cs`
    and remove the line `dataGrid.ItemsSource = Employees;`. Now, go to the `MainWindow.xaml`
    file and give the window a name (`x:Name="window"`). Now, set the `ItemsSource`
    property of the `DataGrid` control, as mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application once again, by building the project. You will see
    the same output on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Element-to-element data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few recipes, we learned how to do object-to-element data binding.
    Though this is commonly used, you will need element-to-element data binding within
    the same XAML page to reduce the extra lines of codes in the code-behind file.
    In this recipe, we will learn how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, launch your Visual Studio IDE and create a new WPF application project.
    Give it the name `CH04.ElementToElementBindingDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now perform the following steps to design the UI with a `TextBlock` and a `Slider`
    control. Then we will bind the value of the slider control with the `FontSize`
    property of the `TextBlock`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` page and replace the default `Grid` panel with the
    following XAML markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now build the project and run it. You will see the application UI on the screen,
    with a `TextBlock` and a `Slider` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now increase or decrease the slider value to see the change in the UI, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/739b0f1e-58be-4931-8db5-03a725eaa071.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you drag the thumb of the slider, it increases or decreases the value of
    the slider control (`fontSizeSlider`, in our example). The `FontSize` property
    of the `TextBlock` control is directly bound to the value of the slider. So, when
    you drag the slider, based on the value, it increases or decreases the font size.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `TextBlock` has a few `Run` commands. The `Text` property of
    one of the `Run` commands is also binded with the slider value, and thus, you
    can see the number (current value of slider) on the screen as the font size.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting data in a DataGrid control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DataGrid` control is used to show a number of records in a tabular format.
    Rows and columns are used to display the data. Along with other common functionalities,
    the WPF `DataGrid` control offers a default sorting feature. You can also customize
    this to handle it programmatically. In this recipe, we will learn how to add the
    sorting feature to `DataGrid` and trigger it on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this recipe, open your Visual Studio editor and create a
    new WPF application project, called `CH04.DataGridSortDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following to create a data model, populate it, and bind it to a
    `DataGrid` in the UI. Later, add a `CheckBox` control to customize the sorting
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, right-click on the Solution Explorer, create a new class file named
    `Employee.cs`, by following the right-click context menu entry Add | Class...,
    and add a few properties in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `MainWindow.xaml.cs` file and add a dependency property, `Employees`,
    of type `ObservableCollection<Employee>`. Make sure you add the following namespaces,
    `System.Collections.ObjectModel` and `System.ComponentModel`, in order to resolve
    the required classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the constructor of the `MainWindow` class, initialize the `Employees`
    collection as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now open the `MainWindow.xaml` page and replace the default `Grid` panel with
    a `StackPanel`. Add a `DataGrid` control inside it and give it a name (let's say,
    `dataGrid`). Set its `AutoGenerateColumns` property to `False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create four data grid columns of type `DataGridTextColumn` and create the data
    binding with the properties exposed from the `Employee` model. Here''s the XAML
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as the data grid is already in place, assign the `Employees` collection
    as the `ItemsSource` property of the data grid. You can do this inside the `MainWindow.xaml.cs`
    file, just after initialization of the `Employees` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application now, you will see a `DataGrid` control with the
    records that we have added into the collection. You will be able to sort the records
    by clicking on the column headers, which is the default functionality of the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24cea8ab-2139-4446-9c93-ecf876d2a1e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to add a `CheckBox` control in the UI to toggle the sort on demand.
    Let''s do this for the `Department` column. Add the following `CheckBox` inside
    the `StackPanel`, just after the `DataGrid` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `MainWindow.xaml.cs` file once again, and add the following
    event inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application again. You will see a new checkbox, under the data
    grid. Toggle the selection (check status) and observe the behavior on the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3b2a54f-fb4e-4427-9054-bad6cc0464aa.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the `OnSortByDepartment` event triggers, it gets the default view of the
    data grid and adds `SortDescription` to the `SortDescriptions` property of the
    default view instance. `SortDescription` takes the property name as the first
    argument. It defines the column for which you want to add the sort functionality.
    The second parameter is the `ListSortDirection`, which can be either `Ascending`
    or `Descending`.
  prefs: []
  type: TYPE_NORMAL
- en: It's not limited to a single `SortDescriptor`. You can add more based on your
    requirement. At any point of time, when you want to reset the view from the applied
    sort description, you can call the `SortDescriptions.Clear()` method on the view
    (in our case, it is `cvs`).
  prefs: []
  type: TYPE_NORMAL
- en: Grouping data in a DataGrid control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DataGrid` control also allows you to group the records by field name. In
    this recipe, we are going to learn how to implement this feature using the `PropertyGroupDescription`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with creating a new project called `CH04.DataGridGroupDemo`. Make
    sure you select the WPF application template while creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create groups while displaying records in `DataGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the project, create the `Employee` model class and expose some properties,
    like we shared earlier in the *Sorting data in a DataGrid control* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the same dependency property (`Employees`, of type `ObservableCollection<Employee>`)
    in the `MainWindow.xaml.cs` file and populate the collection with some data records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the `MainWindow.xaml` file and add the attribute `x:Name="window"`
    to give the `Window` a name, so that we can perform element-to-element data binding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the default `Grid` panel with `StackPanel` and add a `DataGrid` control
    inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `ItemsSource` property of the `DataGrid` to bind the `Employees` collection,
    exposed from the code behind as a dependency property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Set the `AutoGenerateColumns` of the data grid to `False`, as we are going to
    add the columns manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the following XAML snippet, add the four columns to the data grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, add a `CheckBox` control, just after the `DataGrid`, to enable it to
    apply grouping to the records by department name. Here''s the complete XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are going to add grouping on the `DataGrid` records, we need to design
    the group style. Add the following snippet inside the `DataGrid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will need to add the `OnGroupByDepartment` event implementation. Open
    the `MainWindow.xaml.cs` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Run the application now. You will see that the UI contains a `DataGrid` with
    some records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the checkbox that says Group by Department and observe the behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c3067186-1900-4915-88bb-bdcc02180bd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Uncheck the checkbox to revert the view to its original state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you trigger the `OnGroupByDepartment` event, it retrieves the instance
    of the default view of `DataGrid` and applies the group description to it. The
    grouping applies based on the property name, passed to the `PropertyGroupDescription`,
    as shared here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on that, the group style applies to the data grid. The template contains
    an `Expander` control with the name of the column to be grouped as the `Header`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can now expand or collapse the groups and apply sorting or filtering to
    drill down the data. It helps to find the correct record easily.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also modify the `Expander Header` to display the number of records
    inside a group. The `ItemCount` property can be used to display the record count.
    Modify the `Expander.Header`, as shared here, to customize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the application again. Once the window loads, click on the
    checkbox to group the records by department name. Observe the item count in the
    expander, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2719de3-0fa4-4955-8d25-9b04043577ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Filtering data in a DataGrid control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we display a set of huge records in a `DataGrid`, it often becomes difficult
    for the user to search for and find a particular record from the grid. In such
    cases, you may want to provide an additional feature to filter the records to
    a specific search term.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add a search box to filter records in a
    `DataGrid` control.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating a WPF application project named `CH04.DataGridFilterDemo`
    in your Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now perform the following steps to add the search functionality attached to
    the grid records:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has been created, add a new `Employee` model class inside the
    project and expose some properties, like we shared earlier in the *Sorting data
    in a DataGrid control* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the same dependency property (`Employees`, of type `ObservableCollection<Employee>`)
    in the `MainWindow.xaml.cs` file and populate the collection with some data records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the `MainWindow.xaml` file and add the attribute `x:Name="window"`
    to give the `Window` a name, so that we can perform element-to-element data binding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the default `Grid` panel with a `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now insert the following horizontal `StackPanel`, containing one `TextBlock`
    and one `TextBox`, inside the root `StackPanel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `DataGrid` control, having four columns inside it. Set the `AutoGenerateColumns`
    to `False` and add the data binding of the `ItemsSource` property with the `Employees`
    collection (`ItemsSource="{Binding Employees, ElementName=window}"`). Here''s
    the complete code for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now navigate to the `MainWindow.xaml.cs` file, and add the following code blocks
    to implement the `OnFilterChanged` event that gets triggered whenever any text
    changes in the `searchBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the project and run the application. You will see the following
    UI on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8bb6ba8f-4aba-4b77-a93e-d2f72014d403.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now filter the records by entering some search term in the textbox. Let''s
    enter `Finance` as the keyword and see the behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c3e64cdd-119f-4849-95de-7c313a82c997.png)'
  prefs: []
  type: TYPE_IMG
- en: If you change the search term to perform the following from the records, it
    will filter out only those records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you enter a search term, it fires the event `OnFilterChanged` and retrieves
    the default view of the `DataGrid`. It exposes a property named `Filter`, which
    is a predicate. In our example, we assigned the predicate `OnFilterApplied` on
    the `Filter` property, which, when called, compares the term with `Department`,
    `FirstName`, `LastName`, and returns `true` if a match is found. Based on the
    `boolean` value, it shows the said record.
  prefs: []
  type: TYPE_NORMAL
- en: Using static bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we use static properties in our applications. Along with WPF 4.5, Microsoft
    provided us with the option to use static properties in XAML markup, while performing
    data binding. In this recipe, we will learn how to create such bindings. These
    can be useful in the next recipes while using Converters, Styles, and Templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating a new project, called `CH04.StaticBindingDemo`. Open
    your Visual Studio IDE and select the WPF application project as the project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the project has been created, perform the following steps to learn static
    binding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` page and add a `Label` inside the `Grid` panel.
    Give it a background color (let''s say, `OrangeRed`) and run the application.
    This is what we use most often to write hardcoded values inline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change it to set a background color from the system defined colors.
    To do this, we need to use `{x:Static}` markup extension to access the static
    properties. Here''s how the code will be changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also access locally defined resources, within the XAML page or defined
    in a centralized `ResourceDictionary`. Let''s define a color within the same page,
    under `Window`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `Foreground` property to the label, to assign its foreground color. Let''s
    bind it with the static resource (`myBrush`), that we defined earlier. Here''s
    the code for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s build and run the application. You will see the colors similar to
    the following screenshot, where the background will have a light gray color (based
    on the color set to your system''s `ControlDarkBrush`) and the foreground will
    have a greenish yellow color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2f60b3b-453e-4b65-9016-e899914a0ee9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A markup extension is a class that derives from `System.Windows.Markup.MarkupExtension`
    and implements a single method named `ProvideValue`. In this example, we have
    used the `{x:Static}` markup extension, implemented by the `System.Windows.Markup.StaticExtension`
    class, which allowed you to access the static property.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `{StaticResource}` is used to access the resource (`Color`, `Brush`,
    `Converter`, and more), defined in a XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Using value converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converters are often useful when you want to perform data binding between two
    properties that have incompatible types. In such cases, you will need a piece
    of code which creates a bridge between source and target. This piece of code is
    defined as a **value converter**.
  prefs: []
  type: TYPE_NORMAL
- en: The `IValueConverter` interface is used to create value converters and contains
    two methods named `Convert` and `ConvertBack:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert(...)**: It gets called when the source updates the target object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConvertBack(...)**: It gets called when the target object updates the source
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create value converters and use them while
    data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by creating a new WPF project. Call it `CH04.ConverterDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin with the value converter, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Solution Explorer, open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `Grid` with the following XAML markup, which contains
    a `CheckBox` and a `Rectangle` inside a `StackPanel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a data binding between the `Visibility` property of the `Rectangle`
    and the `IsChecked` property of the `CheckBox` control. If you build and run the
    application, you will see that there exists no visible change in the UI when you
    change the checked state of the checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16d39b4b-fbae-4449-985a-f15f497a4a25.png)'
  prefs: []
  type: TYPE_IMG
- en: As the `Visibility` property does not accept `boolean` values, the `Rectangle`
    stays always visible by default. Now we will add the converter to it, which will
    automatically convert the value from `bool` to `Visibility`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create a new class file in the project. Name it `BoolToVisibilityConverter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BoolToVisibilityConverter.cs` file and add the following namespaces—`System`,
    `System.Globalization`, `System.Windows`, and `System.Windows.Data` as `using`
    statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, mark the class as `public` and implement the `IValueConverter` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two code blocks inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the `MainWindow.xaml` file and add the following XMLNS namespace,
    so that we can declare the converter as a window resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Window` tag, add the following markup to declare the converter
    that we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the binding syntax of the `Visibility` property of `Rectangle`, associate
    the converter as `StaticResource`, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, build the project and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the checkbox will be unchecked and the rectangle will not be visible
    on the screen. Change the state of the checkbox to checked and observe that the
    rectangle will become visible on the screen. Unchecking the box will again hide
    the rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79724832-3b9e-4b6f-b302-a0aa63222852.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A value converter is used to convert one value to another, by implementing the
    `IValueConverter` interface. The values may be of the same type or different types,
    but require some transformation that is not possible declaratively. These are
    often powerful because they are written in code, and hence have more logic to
    control the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the converter is generally created in the XAML page and declared
    as a resource. Then it sets to the controls by using binding expressions with
    the `Converter` property.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the source property changes, the converter returns a different result
    through the `Convert` method. The `ConvertBack` method is called in a two-way
    binding mode, where the source and target are reversed. In a one-way binding,
    there's no need to implement `ConvertBack` and generally we set its body to return
    an exception, like this—`throw new NotImplementedException()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can extend the functionality of the converter by using the converter parameter.
    Let's modify the `Convert` method to utilize the parameter named `parameter` and
    reverse the visibility based on its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, open the `BoolToVisibilityConverter.cs` and modify the class implementation
    as shared in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `MainWindow.xaml` file and modify the data binding of the `Visibility`
    property of the `Rectangle` to have a `ConverterParameter=inverse`, as shared
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build and run the application. You will see that, this time, the rectangle
    will be visible by default when the checkbox is unchecked. Now change the status
    of the checkbox to check, and you will see that the rectangle becomes visible
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc010dd1-837e-4796-aac1-22924c24bad4.png)'
  prefs: []
  type: TYPE_IMG
- en: You can, of course, change the implementation and the value of the `ConverterParameter`,
    based on your business requirement, and use the same converter class to return
    different values on various conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `BooleanToVisibilityConverter`, provided by .NET Framework.
    You can read more about this converter here: [https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx).'
  prefs: []
  type: TYPE_NORMAL
- en: Using multi-value converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to change the target value based on multiple values of the same
    or different types, you will need to use multi-binding. This is done by using
    a multi-value converter (`IMultiValueConverter` interface).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build a sample demo to learn how to work with multi-binding
    and multi-value converters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio IDE and create a new project called `CH04.MultiValueConverterDemo`,
    based on the WPF application project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the project is created, follow these steps to design the UI and do a multi-binding
    between multiple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Solution Explorer, open the `MainWindow.xaml` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the default `Grid` panel, create a few rows and columns, so that we
    can position elements at specific cells. Let''s divide the `Grid` into five rows
    and three columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Grid` panel, insert the following XAML code snippet to add few
    labels and input boxes inside the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the project and run the application. You will see four input boxes on
    the screen, along with their associated labels as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1656b782-5683-48f8-bee6-d3705f04be3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's close the application and return to the Solution Explorer. Create a new
    class named `FullNameConverter` inside the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `FullNameConverter.cs` file and implement `IMultiValueConverter` on
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the following `using` namespaces in the class file—`System`, `System.Globalization`,
    and `System.Windows.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add the following two methods inside the class, which implements the methods
    defined in `IMultiValueConverter` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now navigate to the `MainWindow.xaml` page and add the following XMLNS namespace,
    so that the converter can be accessible from the XAML markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add the converter to the window resource. To do this, inside the `Window`
    tag, add the following markup to define the instance by key name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `Text` property of the `fullName` textbox, define the multi-binding
    to bind the property with the `Text` property of three `TextBox` controls. Here''s
    the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the binding is done, build the project and run the application. You will
    see the same UI on the screen. Enter some strings in the `Firstname`, `Middle`,
    and `Lastname` fields. Observe the value in the `Fullname` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a1186b7b-855f-431f-aac6-2e0849b5d863.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, change the `Fullname` field to hold three strings. Press the *TAB*
    key once you are done, and observe the value of the other three fields—`Firstname`,
    `Middle` and `Lastname`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use a converter of type `IMultiValueConverter` in a `MultiBinding`,
    it passes the values defined by the `Binding` tag to the `Convert` method as an
    object array. In our preceding example, we passed three string values (`firstName`,
    `middleName`, and `lastName`) to the `Convert` method. The method then concatenated
    the strings to form a single string, which was the output string of the `Fullname`
    field as the binding was made with its `Text` property.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when we changed the value of the `Fullname` field, the `ConvertBack`
    method triggered by the binding converter and returned the splitted strings. As
    per the binding order, those automatically got assigned to the respective fields—`Firstname`,
    `Middle`, and `Lastname`.
  prefs: []
  type: TYPE_NORMAL
