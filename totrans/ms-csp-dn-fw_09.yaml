- en: Chapter 9. Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter and the next one are dedicated to different views of application
    development. In [Chapter 10](part0055.xhtml#aid-1KEEU1 "Chapter 10. Design Patterns"),
    *Design Patterns*, we will cover design patterns, good practices, and different
    solutions provided by the theorists about them. However, in this chapter, our
    goal is the structure of the application itself and the tools available its construction.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, first, we'll recommend a very useful guide to help you in the
    selection of the model to be used, depending on the application you have to build;
    and we'll go on to the process itself, as recommended by Microsoft Solutions Framework
    and its Governance Model. Security planning and design should also be considered
    by creating a *Threat Model*, addressing security scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: To adequately build the different deliverables that the application's life cycle
    requires, we'll use Visio and check how this tool can be the perfect complement
    to the application's architect team, with all types of templates to help in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the area of development, testing, and deployment, we'll dig into Visual
    Studio Enterprise and learn how to reverse-engineer code and generate code maps
    and diagrams and its support for UML.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll cover some aspects related to the final deployment phase and
    the different solutions at our disposal with the current tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Altogether, in this chapter, we will discuss following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The election of an architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of Visio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio architecture, testing, and analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The election of an architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first problem that arises when a new application is projected has much to
    do with the election of the model and the tools and artifacts that will better
    suit our needs and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft published *.NET Technology Guide for Business Applications* in 2013,
    authored by Cesar de la Torre and David Carmona (both senior program managers
    at Microsoft/Redmond) to provide its customers with a vision about the principles
    and restrictions to be considered when selecting a model for an application. You
    can freely download it at [https://blogs.msdn.microsoft.com/microsoft_press/2013/11/13/free-ebook-net-technology-guide-for-business-applications/](https://blogs.msdn.microsoft.com/microsoft_press/2013/11/13/free-ebook-net-technology-guide-for-business-applications/).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the guide offers an exhaustive tour of all the different scenarios
    that developers might face and details the pros and cons that you should consider
    before deciding which tools and technologies are adequate for your business problem.
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once this selection is made, you can dig into **Application Lifetime Management**
    (**ALM**). So, what''s the path to follow in order to get to a happy end? Consider
    that even today, some facts reflected in statistics seem frightening:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One out of six IT projects ends up having an average cost of 200% over the
    projected target and a schedule delay of 70% (source*: Harvard Business Review*:
    [https://hbr.org/2011/09/why-your-it-project-may-be-riskier-than-you-think/ar/1](https://hbr.org/2011/09/why-your-it-project-may-be-riskier-than-you-think/ar/1))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Economy losses just in the United States are estimated at $50-$150 billion
    per year due to different types of failed IT projects (source: *Gallup Business
    Review*: [http://www.gallup.com/businessjournal/152429/cost-bad-management.aspx#1](http://www.gallup.com/businessjournal/152429/cost-bad-management.aspx#1))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fewer than a third of all projects were successfully completed on time and
    on the budget over the past year (source: *Standish Group*: [https://www.versionone.com/assets/img/files/CHAOSManifesto2013.pdf](https://www.versionone.com/assets/img/files/CHAOSManifesto2013.pdf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these facts in mind, we need to explore how to properly manage a new project
    with some confidence and within the schedule and target that we initially foresaw.
  prefs: []
  type: TYPE_NORMAL
- en: A universal platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On one hand, we count on a complete set of tools and technologies (what we understand
    by the development platform) that allow any developer to build applications for
    any type of model, platform, or technology.
  prefs: []
  type: TYPE_NORMAL
- en: This universal offer is even clearer now that it was in the Guide's publication,
    given the new options around the Universal Windows Platform and .NET Core (which
    we've already mentioned in this book and will see in more detail in the final
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, ASP.NET Core, and the rest of the initiatives related to Node.js,
    Apache Cordova, Linux support in Azure, SQL Server support in Linux, Office for
    Mac OS, and even the recent Visual Studio for Mac, present a vast panorama of
    opportunities for developers, which extends beyond Windows and its related technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram was officially published by Microsoft and reviewed in detail
    by several evangelists, showing the continuous growth in the scope of the Microsoft
    Development ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A universal platform](img/image00596.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We saw in this book that .NET has kept evolving since the beginning, and now,
    it provides a state-of-the-art developing experience no matter what the type of
    application to be developed is, or whether we are coding for the server or the
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, you can program cloud services or on-premise services equally
    well, using C#, or you can use Node.js as a backend, as we saw in the previous
    chapter. The location of the server is also independent since everything you install
    and deploy on your server is also installable and deployable in Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, with the new ASP.NET CORE version, you can deploy your applications in
    two ways: using `Microsoft.AspNetCore.Server.WebListener` (which is Windows-only)
    or with `Microsoft.AspNetCore.Server.Kestrel`, which is cross-platform and can
    work in any host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the client side, you can build applications for the desktop either using
    Windows Forms, Windows Presentation Foundation, or even HTML5 + CSS3 + JavaScript
    for browser based solutions inside or outside Microsoft devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option is now empowered by the excellent support that Visual Studio
    offers for applications for Apache/Cordova and/or Xamarin as mobile solutions
    that run anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, of course, this is just a rough view of the large amount of possibilities
    now available in the platform, which keeps on growing.
  prefs: []
  type: TYPE_NORMAL
- en: The MSF application model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft Solutions Framework is, as defined by Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Microsoft Solutions Framework (MSF) is a set of principles, models, disciplines,
    concepts, and guidelines for delivering information technology solutions from
    Microsoft. MSF is not limited to developing applications only, it is also applicable
    to other IT projects like deployment, networking or infrastructure projects. MSF
    does not force the developer to use a specific methodology (Waterfall, Agile)
    but lets them decide what methodology to use."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, MSF sits on top of any methodology and recommends what to do in all phases
    of ALM. It has been around for four versions since its creation, the fourth being
    the latest revision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two models defined by MSF are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Team Model**, which deals with the people who compound the development
    and management of the project, and their responsibilities and operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Governance Model**, previously called the **Process Model**, which describes
    the different phases to pass through when building a project, and that includes
    five or six phases depending on the version to be used, going from the first steps
    to the final implementation and deployment (and even further)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also defines three disciplines or sets of tasks to be performed and guides
    to follow in relation to the project''s completion. These disciplines are Project
    Management, Risk Management, and Readiness Management. The official Microsoft
    documentation on the ALM offers a clear schema of these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MSF application model](img/image00597.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's review the most important keys of these models and how they explain and
    propose well-defined procedures and practices along the ALM.
  prefs: []
  type: TYPE_NORMAL
- en: The Team Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Team Model is based on a schema that defines the different roles you can
    assign to the development team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft proposes a new Team Model, as opposed to the classical Hierarchical
    Model, in order to avoid its typical drawbacks, which summarizes in several aspects:
    communication overhead, misunderstanding from non-direct contacts, lack of clarity
    in team roles and responsibilities, detached members, and process overheads.'
  prefs: []
  type: TYPE_NORMAL
- en: MSF proposes, in turn, that the Team Model be made up of a *team of peers*,
    whose members relate to each other as equals and know clearly which responsibility
    every member owns and which decisions are based on consensus.
  prefs: []
  type: TYPE_NORMAL
- en: The Team Model gives all members an equally important role in the final success
    of the project. In this way, many of the unclear responsibilities and vague definitions
    that are common to other Project Management solutions are suitably addressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next graphic, you can see how the authors and evangelists of the official
    Microsoft course on MSF organize these roles around the concept of a Team of Peers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Team Model](img/image00598.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the official schema, there are seven roles—all declared of
    having equal importance. Note, however, that for small teams, the same person
    might appear in more than one role.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the main responsibilities of each role are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product management**: Be the contact with the customer, guaranteeing its
    satisfaction and serving as the voice of the customer for the Program management
    role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functional areas for this role are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Marketing/corporate communications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Business analysis
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Product planning
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program management**: Be in charge of managing the project''s constraints,
    and be the voice of the team with product management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overall, the functional areas should be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Project management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Program management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Process assurance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Project quality management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Project operations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architecture**: The goal is to design the solution in a way as per the business
    goals without forgetting the project''s limitations (the budget, schedule, and
    so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functional areas of this role are mainly these two:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Solution architecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical architecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development**: Generate code, agreeing with the project specifications, style
    indications, schedule milestones, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functional areas in this case as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Solution development
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technology consulting
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: This is to take care of testing when all the issues are correctly
    addressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, four aspects of testing are considered critical (in different scenarios):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User experience**: This is understood as another form of testing and should
    improve the user experience and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, the goals are closer to the user interaction:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical support communications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Training
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface design
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release operations**: All operations require satisfactory installation, plus
    giving hints to the team with respect to future releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this final phase, the functional tasks are mainly as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical support communications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Training
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface design
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The way the Team Model is established, however, makes some roles incompatible.
    This depends on the type of responsibilities that a role owns because some of
    them are considered opposite in nature. The following graphic shows this situation
    in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Team Model](img/image00599.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is the case, for instance, with Program Management because the type of
    relations you carry on is, by nature, incompatible with Product Management (mainly
    responsible for the team). The most irreconcilable of all roles is the developer,
    which is—basically—incompatible with any other.
  prefs: []
  type: TYPE_NORMAL
- en: The Governance Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In brief, the authors of MSF define project governance as the set of tools,
    guides, and techniques, which provide enough oversight, process guidance, and
    rigor to efficiently and effectively use project resources and deliver a solution.
    All this happens while handling trade-off patronage decisions and balancing adherence
    to a set of potentially changing project constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'It deals with the process of building the application, and it''s traditionally
    divided into five or six phases depending on the model to be used. In the latest
    version (4.0), the schema presented by the Microsoft documentation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Governance Model](img/image00600.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you see, five phases are considered: **Envision**, **Plan**, **Build**,
    **Stabilize**, and **Deploy**. The transition from one phase to another takes
    place when you hit a milestone that assumes the existence of a set of deliverables
    approved by all members of the team.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main goals of these steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Envision**: Here, the goal is to define a clear comprehension of what is
    required within the context of project constraints (the initially mentioned Guide
    could be helpful here as well). Also, the documentation states that it supposes
    to assemble the necessary team to envisage solutions with options and approaches
    that best meet the needs while optimally satisfying constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan**: The preceding phase is sort of conceptual. This phase is about to
    concrete the previous ideas into tangible solutions: designing and implementing
    database structures in the RDBMS of choice, defining the user interfaces and their
    interactions with the final user, defining the proper configuration of the source
    code management tool (Team Foundation Server is the preferred choice for the Microsoft
    development environments), and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this phase, some aspects of security should be clearly established, especially
    those that might imply a loss of assets, revelation of private information (non-intended
    disclosure), possible Denial of Service (DoS) attacks, and so on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: Most people relate this to just coding, but it goes a bit further.
    It should also consider good practices, style guidelines, and many other coding
    practices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find a dedicated page for coding conventions in C# at [https://msdn.microsoft.com/en-us/library/ff926074.aspx](https://msdn.microsoft.com/en-us/library/ff926074.aspx).
    In addition, a comprehensive list of the naming guidelines for .NET solutions
    is available at [https://msdn.microsoft.com/en-us/library/ms229002(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms229002(v=vs.110).aspx).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This phase also includes a willingness to learn new coding techniques and implement
    requirements in the best possible manner. It's interesting to note that MSF recommends
    that this phase should never exceed 33% percent of the total time assigned to
    the project.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stabilize**: The model emphasizes that this is not just about getting rid
    of bugs. Sometimes the problem lies in the usage of the application''s UI, the
    time required to access certain data after a request, or taking care that no collateral
    effects appear linked to a given process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, the user's perspective is very important as well, and certain techniques
    come in handy, such as unit tests, or behavior-driven tests, which simulate use
    cases from the beginning to the end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, security is another important aspect here. Behavior-driven tests
    should include all the security aspects evaluated and addressed if the Threat
    model has been properly designed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy**: This is about integrating the solution successfully into production
    and transferring the rest of the management to the support teams designated for
    that purpose. It''s the final phase, but many times, its ending just connects
    with the beginning of the second version (or update, or release, you name it…).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Just to deal with the deployment phase, Microsoft later created the Microsoft
    Operations Framework proposal, which covers every aspect of deployment, especially
    for applications with a certain volume and complexity (rising up to an entire
    operating system).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These complex cases are themselves treated as another project, with all its
    phases and considerations. In subsequent versions of MOF, the entire coverage
    for any IT operation is considered, together with all scenarios that we mentioned
    earlier: on-premises, in the cloud, mixed, and so on.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can access the complete documentation about this subject on its dedicated
    website at [https://msdn.microsoft.com/en-us/library/cc506049.aspx](https://msdn.microsoft.com/en-us/library/cc506049.aspx).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Risk Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Risk Model explains how to deal with security along all the previous phases
    and how to take security into consideration from the very beginning of the application's
    life cycle. Some theoreticians prefer to include it in the process model itself,
    as we saw in the diagram at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to cover security in more depth in [Chapter 11](part0065.xhtml#aid-1TVKI1
    "Chapter 11. Security"), *Security*, (based on the OAuth 2.0 standard), so it
    is not the goal to discuss these techniques in depth here, but I would like to
    review the principles on which the Risk Model is based.
  prefs: []
  type: TYPE_NORMAL
- en: The MSF Risk Management discipline makes a distinction between risks and issues
    (or problems that already exist or known problems). Thus, it defines a type of
    risk management that proactively identifies, analyzes, and addresses risks in
    order to improve the probability of success.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy is to anticipate rather than react to problems, so the team should
    prepare for problem resolutions before problems occur in order to be able to react
    proactively and directly to the root causes, not only to symptoms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official documentation schematizes risk management in the following graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Risk Model](img/image00601.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the first step is identifying and stating a given risk. It follows
    an analysis and prioritization of the problem to be resolved, which goes along
    with a mitigation plan and schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the planning phase, different areas of the application are assigned to different
    team members, and each member assumes the responsibility for the possible risks
    linked to it.
  prefs: []
  type: TYPE_NORMAL
- en: Risk evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MSF documentation also establishes a classification of the risks according
    to this table, which lists the possible sources in four types of risks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Risk classifications | Risk sources |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| People | Customers, end users, stakeholders, personnel, organizations, skills,
    and politics |'
  prefs: []
  type: TYPE_TB
- en: '| Process | Mission and goals, decision-making, project characteristics, budget,
    costs, schedules, requirements, designs, building, and testing |'
  prefs: []
  type: TYPE_TB
- en: '| Technology | Security, development and test environments, tools, deployment,
    support, operations environment, and availability |'
  prefs: []
  type: TYPE_TB
- en: '| Environment | Laws, regulations, competition, economy, technology, and business
    |'
  prefs: []
  type: TYPE_TB
- en: Risk assessment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The suggested procedure to evaluate risks is to publish a maintainable and
    accessible list in which every risk is evaluated using two factors: impact and
    probability, the first one being a pre-established value that the team estimates
    (let''s say from 1 to 100, 100 being the worst possible case).'
  prefs: []
  type: TYPE_NORMAL
- en: The second factor (the probability) is generally measured using the mathematical
    concept linked to this measurement (that is, a value between 0 and 1, 0 being
    the impossible and 1 being absolute certainty).
  prefs: []
  type: TYPE_NORMAL
- en: Later, both factors are multiplied and ordered as descending, so the most dangerous
    risks appear at the top, and the team can figure out their priority when they
    decide to take actions about it.
  prefs: []
  type: TYPE_NORMAL
- en: Risk action plans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Different tasks can be assigned to risk management in order to better cope
    with potential problems once these problems are detected and sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Research**: This is the process of finding more information about the risk
    before taking any action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance**: This means that it would be acceptable to live with the consequences
    if the risk occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoidance**: If we change the project''s scope, would the risk be avoided
    as well?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transfer**: In some cases, it''s possible to transfer the risk to other projects,
    teams, organizations, or individuals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: What can the team do to reduce any of the two factors mentioned
    earlier (probability or impact)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contingency plan**: The team should evaluate whether a planned strategy would
    help in case of the risk becoming real'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all these considerations, the team will collect and design a set of possible
    activities related to the Risk Model. Once that is done, the MSF documentation
    divides the proposed actions into two main areas, which they catalog as proactive
    and reactive.
  prefs: []
  type: TYPE_NORMAL
- en: The proactive approach means mitigation, that is, taking actions ahead of time
    in order to prevent a risk from occurring altogether, or—if the risk is inevitable—to
    reduce its impact to a level that can be considered acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: In the other case, we have to manage actions to reduce real problems (the risk
    became real), so it's imperative to analyze possible problems in advance and—let's
    face it—place ourselves in the worst case, imagining all feasible solutions. The
    team should also define a trigger, something that—if it happens—should start the
    contingency plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that these triggers (the same as the risks linked to them) not only
    have to do with code, but also with many other factors. The MSF documentation
    cites a few: a team member''s resignation, the number of bugs exceeding the acceptable
    limit, or a milestone completed with a significant delay; these are just some
    common cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the MSF assesses these rules, stating that Risk Management should
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensive**: It should address all of the elements in a project (not
    just technology elements, but people and process as well)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Systematic**: It should incorporate a reproducible process for project risk
    management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous**: It should occur along the entire project life cycle, not just
    in the first two phases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proactive**: It should seek to avoid or minify the impact of risk occurrences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible**: It should be adaptable to a wide range of risk analysis methodologies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Future-oriented**: It should be committed to individual- and enterprise-level
    learning and be supported by a Knowledge Base that serves for future endeavors
    later on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CASE tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, MSF does not force you to work with any specific tool, since
    it's only about good practices, procedures, and protocols to follow in order to
    reach the projected goals, and all that being carried out on time and within the
    project's budget (almost a dream, isn't it?).
  prefs: []
  type: TYPE_NORMAL
- en: However, there are tools that can, indeed, help you build these deliverables.
    This includes not only the source code, but also all reports, graphic schemes,
    and other documents that define and clarify the hardware and software structures
    and the desired behavior, both in the ALM and in production. This is something
    that goes far beyond the coding phase since every milestone requires its own documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '**CASE** (**Computer Aided Software Engineering**) Tools is the name given
    to the set of tools required for this purpose. If we talk about Microsoft, these
    case tools are quite numerous today.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, source code is aligned with Visual Studio in its different versions
    (also with the express versions and Visual Studio Code, as we've seen).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, Visual Studio integrates seamlessly with **Visual Studio Team Services**
    (**VSTS**), which the company defines as the set of services that allow software
    teams to share code, manage project advances and issues, and deliver software
    in any language (yes, in any language, including Java)— all in one package. Even
    more, Visual Studio Code and the latest Visual Studio 2017 can work directly with
    Github, as another choice for collaborative coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, what was previously called **Visual Studio On-line** is now part
    of VSTS and allows you to code, execute, and save the development projects online,
    including source code control, version control, and the like. It''s presented
    in different flavors and is excellent for source control and other coding services
    either on-premises or in the cloud (and it does not exclude Git or other types
    of repositories of code and different languages: C#, Java, JavaScript, and so
    on).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, you can use them independently of the building model of your choice:
    MSF Agile, MSF for **CMMI** (**Capability Maturity Model Integration**), or any
    other. The next diagram shows the schema of the main capabilities available in
    VSTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CASE tools](img/image00602.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, there are many other tasks that also require proper tooling and management
    (actually, there are a lot), but specifically, when the programmer deals with
    the two first phases of the development cycle, Microsoft Visio (now in version
    2016), might be a very useful one.
  prefs: []
  type: TYPE_NORMAL
- en: The role of Visio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it is considered part of the Microsoft Office Suite, it is actually
    delivered separately, and it's now part of Office 365 (online). As the company
    puts it, Visio's lemma is Complexity made simple, and it lets you build all sort
    of diagrams, which can even update dynamically (as the original data changes),
    covering hundreds of possible diagramming scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use it in conjunction with Microsoft Project and other related
    tools, and its capability to import and incorporate external information makes
    it a perfect solution to integrate data from other sources and convert it into
    a useful diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The role of Visio](img/image00603.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A first example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine that we already have the list of participants in our Team Model.
    We have discussed which role is competent for each member with them, and this
    information is written in an Excel sheet, indicating name, role, and photo for
    every member of the team. Each of the six roles has been assigned to a different
    person, as defined in the Team Model.
  prefs: []
  type: TYPE_NORMAL
- en: We can create an Organization Chart to express this initial statement, opening
    Visio and selecting **Organization Chart** among the templates Visio offers from
    the start. We even have an assistant to lead us in the process, if we prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have an options menu, **Data/Quick Import**, which recovers the data
    we need in order to give every shape its corresponding information. This can be
    done automatically if you have been careful when creating the Excel data, or you
    can do it manually since a new pane will open up, showing the information inside
    the Excel Sheet (refer to the screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A first example](img/image00604.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the process, if you do it either automatically or manually, you'll have the
    choice of changing the data, reassigning any shape, or loading images from a local
    or remote location to complete the Team Model Schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final shape should have an aspect similar to the one we include in the
    following figure with all roles assigned, names and pictures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A first example](img/image00605.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can now save the shape in a number of different formats or share it with
    any collaborative resource formerly installed for the project (not just TFS).
  prefs: []
  type: TYPE_NORMAL
- en: If the previous Excel sheet is located in an accessible place (previously indicated
    to the assistant), any changes could be checked. For instance, in order to apply
    modifications to a role or to add a new field of interest, you can make changes
    in the Excel Sheet and they would be reflected in the shape as soon as this is
    open again.
  prefs: []
  type: TYPE_NORMAL
- en: We also have templates to define any hardware architecture, network design,
    or any other hardware of software architecture that graphically schematizes the
    application's structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s think of a simple web application (ASP.NET MVC) that accesses
    a database and offers different devices to users (and form factors) along with
    the ability to list the contents of a few tables and modify them through CRUD
    operations, which we''ll instruct Visual Studio to generate for us. The following
    figure can express this scenario using multibrowser clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A first example](img/image00606.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding design is done starting from a Network and Peripherals template,
    with no special data imported, just using the shapes corresponding to the workstation,
    laptop, tablet, and smartphone and the connector features of Visio.
  prefs: []
  type: TYPE_NORMAL
- en: You connect every shape with the destination by dragging and dropping the sides
    of the connector from the center of the shapes that play the roles of initial
    connection (the emitter) to the center of the destination (the receiver). Also,
    note that you can add as many descriptive fields as required to any shape in order
    to specify, for example, network identifiers, IPs, hardware characteristics, users,
    roles, permissions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The database design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With respect to the database design, we don't need to use Visio. On one hand,
    part of the functionality linked to reverse engineering databases in Visio was
    deprecated as of version 2013 of the product. On the other hand, Microsoft moved
    a big part of this functionality to Visual Studio itself, as we mentioned in [Chapter
    6](part0034.xhtml#aid-10DJ41 "Chapter 6. SQL Database Programming"), *SQL Database
    Programming*, when reviewing the data access capabilities of the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, we can even use **SQL Server Management Studio** (**SSMS**) to generate
    a graphic schema of the data required for our purposes using the Database Diagrams
    feature of the tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should make sure that the database has a valid proprietary linked to a valid
    login. If you didn''t assign one to the database to be used, you can assign it
    in the **Properties** dialog box of every database listed in the **Object Explorer**.
    Inside the **Files** page, you should select a valid owner. The next graphic shows
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The database design](img/image00607.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**SSMS** could still ask you about installing the required objects to manage
    diagram creation, and once they''re accepted, you''ll be able to generate a new
    schema.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, we'll have a blank schema in the editor, where we can select the
    tables implied in the process. I'm selecting just a couple of tables (`SalesPerson`
    and `SalesTerritory`) to show the relation between them in the schema along with
    some other capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting schema should look similar to what is shown in the following
    screenshot. Note that the edition surface offers several options in the contextual
    menu, where you can add comments, other tables (not yet selected), view the details
    of the relationships between tables, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The database design](img/image00608.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Observe that the editor automatically recognizes all tables' relations (in this
    demo, the foreign key relation named `FK_SalesPerson_SalesTerritory_TerritoryId`
    and the configuration details of any selected object are presented in the **Properties**
    window, as usual).
  prefs: []
  type: TYPE_NORMAL
- en: You might need to refresh the Object Explorer, so SSMS recognizes the new diagram
    after you save it. If you make any modifications to the diagram that imply a change
    in the structure of the database, the new configuration will be checked before
    saving, using the values that appear in the **Properties** window. Should any
    change be incompatible with the current restrictions, the diagram won't be saved.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the demo application in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Later on, we create a new ASP.NET MVC application in order to use these two
    tables and access their data from web pages. At creation time, when we add a new
    ORM model using Entity Framework in the way we saw in [Chapter 6](part0034.xhtml#aid-10DJ41
    "Chapter 6. SQL Database Programming"), *SQL Database Programming*, we'll get
    a similar diagram (not exactly the same but basically containing the same information).
    We don't show it here since it has nothing meaningful with respect to the previous
    output.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this new diagram from inside Visual Studio, you will have access
    to other information related to the code the IDE generates in order to facilitate
    programmers with access to the database and use the Entity Framework libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such information, visible from the IDE''s **Properties** window, might show
    you interesting and specific data in relation to the objects we have selected
    for our diagram. This includes the template used in code generation, the code
    generation strategy, the name of the Entity Container, and several Boolean values
    (most of them changeable), indicating all aspects of such code. Refer to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the demo application in Visual Studio](img/image00609.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since our goal here is not the code itself but the process of creation and the
    deliverables you might generate when following the MSF, I'm going to instruct
    Visual Studio to generate all the scaffolding for a complete CRUD set of operations
    with these two tables. The generated code will then be used to reverse-engineer
    the resulting site from Visio and create other useful schemas.
  prefs: []
  type: TYPE_NORMAL
- en: So, I'll proceed as explained in [Chapter 6](part0034.xhtml#aid-10DJ41 "Chapter 6. SQL
    Database Programming"), *SQL Database Programming*, and ask the IDE to generate
    all this functionality from the **Add Controller** option for each of the tables
    selected here. It's a good practice to check the resulting files and test the
    basic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The only real change in the code I'll make at this point will be to add two
    new links in the main page (remember the `_Layout.cshtml` file), so these new
    options can be accessed directly from the landing page.
  prefs: []
  type: TYPE_NORMAL
- en: I also made some changes to the default information presented by the template,
    just to reflect the basic information offered by this demo instead of the template's
    information. However, the only operational changes will consist of adding a couple
    of links so that CRUD operations can be reached from the main page.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, I'll use two `ListItems` with `ActionLink` helpers to generate the new
    entries in the main menu and check whether they work properly, linking to the
    `Index` action method for each generated controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, these lists show the complete list of records for every table, and
    other links are generated automatically (**Edit**, **Details**, and **Delete**
    for each individual record, plus an option at the top to create a new record).
    The code is pretty simple in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking the preceding functionality, we''ll terminate the project at
    this time (refer to the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the demo application in Visual Studio](img/image00610.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Website design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's more in the design phase, that can be solved using Visio resources and
    tools. Now, we have a working website to test some of the capabilities of Visio
    in order to reverse-engineer a website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visio offers two different types of web templates: **Conceptual Web Site**
    and **Web Site Map**, as you''ll find out when searching for the available templates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the type of schema that some developers like to create before
    any other code action. That is, it lets you define the distinct components of
    the website and helps you with the configuration of each one, defining its shapes
    and fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Website design](img/image00611.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The website map, however, can be created from scratch, or it can be reverse-engineered,
    instructing Visio to read the file information from an already existing website.
    Actually, if you create a new diagram starting from this template, you'll be offered
    the possibility of reading the information from an existing website.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are many factors involved in such task, a **Settings…** button at
    the bottom lets you tune the way Visio should try to read the information. For
    this demo, since we have not published our site to any real hosting service, we
    can use the `localhost:port` configuration to configure Visio as to where to look
    for information.
  prefs: []
  type: TYPE_NORMAL
- en: Another important trick is that you should reduce the number of levels to two
    (in general). Finally, we can add the extensions for the Razor engine so that
    these files are recognized and analyzed properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you''ll see, many other aspects are available: the selection of communication
    protocols, the types of resources that appear in the list, the kind of layout
    to build the graphic tree, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Website design](img/image00612.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After a few seconds, you will be presented with a new diagram containing all
    the selected resources present on the website.
  prefs: []
  type: TYPE_NORMAL
- en: This final schema will be organized in just the same manner as the website,
    that is, hierarchical, starting from the initial URL and going top-down through
    all the levels, as indicated in the previous configuration (be careful with this
    value in some scenarios, or it could take a while to finish checking all possible
    links generated by the schema).
  prefs: []
  type: TYPE_NORMAL
- en: Another useful configuration refers (take a look at the figure) to the number
    of links to be analyzed. 300 is more than enough for this demo, but depending
    on the site, you might miss some of them (especially those located at the deepest
    levels).
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, once the tree is created, you can tune up different views of that
    tree and do further research with the help of a couple of tools that Visio enables
    by default: **FILTER WINDOW** and **LIST WINDOW**. Both appear collapsed next
    to the editing surface resulting from the process.'
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to watch is the size of the diagram. You can make it as big as
    you please, but by default, the schema fits in the available space (no matter
    how big the site is), so you might find the resulting graphic quite reduced (of
    course, the zooming tool will let you see it the way you prefer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the result should look similar to what is shown in the next capture
    (although I''ve changed the size and retouched some entries to make them more
    visible):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Website design](img/image00613.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you dig into the image, all details show up, and some aspects should be
    noted. In the areas pertaining to the `SalesPersons` and `SalesTerritories` controllers,
    you'll find as many links as registers are present when the `Index` action method
    returns, for example.
  prefs: []
  type: TYPE_NORMAL
- en: This means that for a very long listing, the number of graphics could be unmanageable.
    That's why limiting the number of links to 300 happens by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'With such a complex schema, the location of individual elements can be challenging
    if you do it directly from the shape. This is where **LIST WINDOW** comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Website design](img/image00614.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You just have to locate any item in the list and double-click on it; the graphic
    will locate and move to that element, showing its details.
  prefs: []
  type: TYPE_NORMAL
- en: Once the item is expanded, there's a bunch of available options that you can
    use. You'll find another collapsible window (Shape Data), which shows all the
    fields associated with the element of choice (the element, usually docks to the
    upper-right corner of the editing surface).
  prefs: []
  type: TYPE_NORMAL
- en: You can also expand the corresponding link to see which elements will be active
    when the view is being presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, you have a contextual menu, which includes the **Interactive Hyperlink
    Selection** option. If you click on the link, a new window will open up, presenting
    the real page at runtime that you would see if that link is selected. Refer to
    the screenshot corresponding to the **SalesTerritories/Edit/9** URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Website design](img/image00615.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The most useful aspect of this feature is that the window is not a read, view-only
    snapshot, but it lets you really change the information and will operate just
    the same as the real page in execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you try to change some data and there''s some incompatible
    information in the fields, the form will not be sent, and the error messages will
    show up, indicating the problem, as you can see in the following capture, in which
    a string is introduced where the field expects a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Website design](img/image00616.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Besides, we also have the choices offered by **FILTER WINDOW**, which permits
    the activation/deactivation of links and scripts in order to reduce the number
    of elements shown in the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Website design](img/image00617.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Overall, we count on a wide number of possibilities, which only start when the
    initial diagram is drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all these possibilities, we can gather a good number of deliverables to
    accompany our project's documentation, but Visio offers some extra functionalities
    in order to enhance our documentation.
  prefs: []
  type: TYPE_NORMAL
- en: One option is the possibility of generating reports in several formats (Excel,
    MS Access, Visio Graphics, among others), starting with the current shapes we're
    editing.
  prefs: []
  type: TYPE_NORMAL
- en: Since these reports can also be linked, you can refresh the information as changes
    take place in the project. To create a new report, we just have to move to the
    **Web Site Map** tab in Visio's main menu and select **Create Report**.
  prefs: []
  type: TYPE_NORMAL
- en: We can select an entire report, which includes all the elements selected in
    the map (what Visio calls Inventory), or we can create partial reports in order
    to take care of distinct aspects, such as generating only a **Links Report** or
    even a broken links report in the **Web Site Map** tab with the **Links with Errors**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, we'll be offered a final format to save the information, which
    can be an Excel Sheet, a Visio Shape, an HTML page, or an XML file. If we choose
    HTML files, they can easily be published to a corporate Office 365, a project's
    dedicated SharePoint site, or just to any website convenient for our team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows a web page generated in this way, including all the
    links discovered on our site. A basic table is presented, although you can tune
    all aspects of the generator, including the type of errors you want to exclude,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reports](img/image00618.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Many other options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not used to working with Visio, you'll have noticed a large number
    of other possibilities in order to visually express the distinct aspects of a
    project life cycle. Many are present since previous versions, but the company
    has enhanced and extended the number of options and functionalities in a meaningful
    way.
  prefs: []
  type: TYPE_NORMAL
- en: For example, since the first versions, Visio has the ability to create and update
    Calendar and Time diagrams in order to manage schedules and timetables, such as
    PERT and Gantt diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gantt diagrams, for example, let you control project management, task management,
    agendas, schedules, timetables, goal settings and, in general, a project''s lifecycle.
    Different templates are available: subtasks with the calendar, a simple task waterfall,
    and so on. The following screenshot shows the starting aspect of one of these
    templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Many other options](img/image00619.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, you also have configurable calendars in which you can insert all
    types of data for every date in order to extend control in a much more detailed
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: BPMN 2.0 (Business Process Model and Notation)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In relation to business processes, we find several solutions (Flow Charts, Organizational
    Charts, and so on), but it's worth noting that Visio now offers support for business
    standards as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard BPMN 2.0 is fully supported, and it offers several templates to
    represent the participants in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: BPMN Diagrams (start from scratch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BPMN Process with Gateway (for processes that include a gateway with two outcomes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BPMN Process with Multiple Roles (for cases where there is more that one major
    participant)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BPMN Address Change Process, which the tool recommends when a process participant
    includes more that one role or function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The main statement of the standard defines BPMN, stating *a standard Business
    Process Model and Notation (BPMN) will provide businesses with the capability
    of understanding their internal business procedures in a graphical notation and
    will give organizations the ability to communicate these procedures in a standard
    manner*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's interesting to note that these graphical proposals complement other classical
    schemes, especially certain UML diagrams (such as Activity diagrams or Sequence
    diagrams), helping clarify some business flows in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default BPMN Address Change Process template is a perfect example of this
    (refer to the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![BPMN 2.0 (Business Process Model and Notation)](img/image00620.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at what this process means: a customer changes her address
    and notifies a bank about it. There are three roles implied because **Help Desk**
    passes this new information to **Processing Center**, which, in turn, sends a
    confirmation to **Help Desk**, which sends changed confirmation to the client
    (the bank''s task ending right there). This can be expressed using a UML Sequence
    Diagram as well (and even a Use Case Diagram, since it implies three actors).'
  prefs: []
  type: TYPE_NORMAL
- en: So, a basic UML Diagram can express the initial scenario, and we can use a more
    detailed BPMN diagram to be more precise about the specifics of the task steps
    and completion.
  prefs: []
  type: TYPE_NORMAL
- en: UML standard support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer to follow the diagrams proposed by **OMG Universal Modelling Language**
    (**OMG UML**) (now in version 2.5), you'll also find excellent support for all
    types of diagrams defined by the specification (both in Visio and Visual Studio
    as well).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're interested in the current state of the UML Standard, the complete
    specification is available at [http://www.omg.org/spec/UML/Current](http://www.omg.org/spec/UML/Current).
  prefs: []
  type: TYPE_NORMAL
- en: That is, we can design diagrams for Use Cases, Classes, Activities, Sequences,
    and UML State Machines since all the required artifacts are present in the related
    templates and extra shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Just take a look at the **More Shapes/Software and Database/Software** menu
    to find all these templates and the shapes the standard defines for them.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio architecture, testing, and analysis tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visio is not the only tool to help the architect in designing and organizing
    a software project. All versions of Visual Studio include extra tools (depending
    on the version) in order to aid these tasks in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have the Visual Studio Enterprise Edition that I''m using now, you''ll
    find three main menu options in relation to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Architecture**: Options for Code Map generation and UML diagramming (with
    support for all types of diagrams we just mentioned)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: A set of tools for testing, including specific, focused dialog
    boxes and artifacts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis**: This covers Node.js profiling, code metrics, and code analysis,
    among other features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application's architecture using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to maintain good coding velocity and prevent technical debt, improvements
    in your application's architecture are crucial. Moreover, understanding the impact
    of a potential change in the code is fundamental at the time of deciding whether
    a change should be done, and if so, what the consequences will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first step is to generate a code map for the current solution. You can do
    it in two ways: generate it from scratch or use the **Generate Code Map for Solution**
    option. If you opt for the latter, a new DGML editor window will show up and a
    complex map will show the roots of the two main nodes: the DLL itself where our
    code is compiled (`WebApplication1.dll`), and another node called `Externals`,
    where you''ll find the relation of the DLLs used in the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll have to expand both nodes to understand the entire picture and their
    relationships. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application''s architecture using Visual Studio](img/image00621.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This type of diagrams are extremely useful in order to quickly view the main
    elements your application is made of. But it gets even better when we expand the
    nodes and identify our controllers or other configuration elements of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Since every node can be expanded, we can go deeper until we reach any class'
    member and its dependencies. If you double-click on any node, a new window will
    open with the matching source code and the caret located exactly where that member
    is defined.
  prefs: []
  type: TYPE_NORMAL
- en: This ability gives us a distinct look at the code and its relationships, where
    it's possible to quickly identify which member is being used by which and which
    libraries a class depends on, among other useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates this, marking two factors of interest:
    our controllers and the application''s configuration classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application''s architecture using Visual Studio](img/image00622.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you inspect the node's details, you'll see that you can keep on going deep
    down until you get all the details of the element checked.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the **Layout** submenu of the DGML editor, you can find extra analyzers
    to check for circular references, finding hubs or identifying unreferenced nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, the **Filters** window, which shows up next to the Solution Explorer,
    presents a list of the element types included in the diagram, all marked by default.
    To get a better understanding of what you have, you can unselect elements and
    the diagram will update automatically to show a new diagram, giving you the ability
    to change or save any view separately for a later study.
  prefs: []
  type: TYPE_NORMAL
- en: There's much more functionality available, as you'll see when you go through
    the distinct options of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other main feature of this menu is UML diagrams. It allows you to create
    a separate project, modeling project, based on the UML diagram of your choice
    or add the new diagrams to an existing project (refer to the screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application''s architecture using Visual Studio](img/image00623.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Class diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most interesting features of Visual Studio Enterprise (and, also
    in some other versions) is the capability to create class diagrams from the existing
    code. It was originally linked to UML Class diagrams, but now it belongs directly
    to the class diagramming features as a separate template.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can create a new class diagram for our project from the **New/Class
    Diagram** option in the **Add** menu. This will take you to a new editing surface,
    where you can drag and drop classes (just our classes and not the files they're
    stored in).
  prefs: []
  type: TYPE_NORMAL
- en: 'The editor will reverse-engineer our classes, so we can easily have our controllers''
    diagrams in three simple actions and come up with a figure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Class diagrams](img/image00624.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Overall, we have a complete infrastructure to express the details of our solutions
    and comply with the life cycle frameworks: either we use MSF or any other option.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing is about checking the quality of a product. Numerous techniques allow
    a programmer to test software, although the first actions should define exactly
    what is to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many approaches to testing: unit tests, regression tests, behavioral
    tests, integration tests, cyclomatic complexity tests, and many others, although
    unit tests are probably the most used among programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests verify the correctness of a function under certain assertions that
    the tester establishes using sentences expressed in the same language as the rest
    of the solution but specifically intended to launch a test engine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this doesn't guarantee that the code unit is correct; it only guarantees
    that it passes the conditions asserted by the test.
  prefs: []
  type: TYPE_NORMAL
- en: In the Agile Development Model (and in Extreme Model), part of the development
    phase adheres to the Test-Driven Design paradigm. In that model, you test units
    of implementation (functions, classes, or modules), expecting a correct execution
    of the unit in a way that drives the code that follows.
  prefs: []
  type: TYPE_NORMAL
- en: In the alternative model named **Behavior-Driven Design** (or **BDD**), we understand
    by behavior how a use case is resolved and completed, giving the process a collaboration
    context that extends the results to nonprogrammers (for instance, it can be shared
    with the *user experience* part of the Team Model).
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio offers wide support for testing, that's focused on unit tests
    and the most popular testing techniques. Let's review the way it works using a
    new ASP.NET MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application in Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recommended procedure to test our application in Visual Studio would be
    to create our application and indicate—at creation time—that we're going to use
    a test project as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify this explanation and, at the same time, make it easier for you
    to check this feature, I''ll create another MVC project, but this time, I''ll
    make sure that a test project is selected from the beginning in parallel to the
    main one (refer to the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our application in Visual Studio](img/image00625.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's not absolutely necessary, but strongly recommendable, that you create a
    separate project for testing. This will also help other members of the team if
    you consider that testing integrates extremely well with Team Foundation Server,
    and you can program the cadence and types of test to perform, assign responsibilities
    for the results, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the test project, a new class is created by default in order to test
    the `Home` controller named `HomeControllerTest`. It contains three methods, with
    the same names as the action methods included in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Observe, however, that both class and methods are marked with attributes [`TestClass`]
    and [`TestMethod`], respectively. This indicates the test engine, which members
    are part of the testing goals, and which ones should be only considered helper
    elements that collaborate in the testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to compile the solution (both projects) and open the **Test Explorer**
    window that you'll find in the **Test/Windows** menu. After a few seconds, the
    test engine will detect all the tests available in the solution and show them
    in the upcoming list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you will be offered a menu that lets you run all the tests or just
    the one selected or even create a playlist in which you indicate exactly which
    test you want to prove (all at once).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select only one test and run it, when the test succeeds, it will be
    marked **Passed**, and a new list will show the list of passed tests and the pending
    ones. For instance, after executing the test for the **About** method, you should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our application in Visual Studio](img/image00626.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After using the **Run All** option, the three tests should pass and be listed
    as correct. However, what if something goes wrong? To check what happens, change
    the string inside the `About` test method for any other string, and save the code.
  prefs: []
  type: TYPE_NORMAL
- en: After recompiling, you will learn how the test will not appear as passed; if
    you run the test, it will fail, and the second window of **Test Explorer** will
    present a list of references indicating what went wrong in order to give you a
    clue about how to fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that tests can be debugged, as with any other code. This will surely
    give you more clues about what's wrong with the test and with your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect to keep in mind is that your testing project will have to add
    references to the project to be tested as well as namespaces, such as using `Microsoft.VisualStudio.TestTools.UnitTesting`.
    In this demo project, Visual Studio does that by default, but if you add a new
    testing project, those references will depend on you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our application in Visual Studio](img/image00627.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, let's mention that there are several different assertions that you
    can use (check the Intellisense after the `Assert` class) and also that you can
    opt for a different testing environment. A search for test in the **Extensions
    and Updates** menu will show you a number of other testing frameworks that Visual
    Studio admits, such as NUnit Test, Jasmine, Karma, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Some of them (NUnit, for instance) are valid for C# as well, and others are
    focused on other languages, such as Jasmine and Karma, which are very popular
    when testing JavaScript solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The Analyze menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Analyze** menu lets you calculate code metrics (such as the Cyclomatic
    Complexity, Depth of Inheritance, Class Coupling, and others), which offer other
    aspects or views of your code's quality.
  prefs: []
  type: TYPE_NORMAL
- en: You can also check the code in search for inaccuracies using the **Code Analysis**
    configuration in the project's properties window (a feature we've already commented
    on in [Chapter 4](part0028.xhtml#aid-QMFO2 "Chapter 4. Comparing Approaches for
    Programming"), *Comparing Approaches for Programming*).
  prefs: []
  type: TYPE_NORMAL
- en: The end of the life cycle – publishing the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publication (deployment) is the final step of the Governance Model, and it may
    lead to a new version or upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Another common possibility is to enter into maintenance time, in which new modifications
    are proposed and the whole cycle starts again—only with a much more reduced scope
    in functionality (and thus, in the number or team members implied).
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio allows you to publish solutions in different ways depending on
    the type of application. Additionally, we can also use third-party versions that
    only require a free registration, such as the light InstallShield version that
    the IDE offers in the **Other Projects** section.
  prefs: []
  type: TYPE_NORMAL
- en: For Web Applications, there are many options. You can configure deployment using
    Team Foundation Server, or in this case, we can explore how to deploy this demo
    right from the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just select **Publish** in the **Build** menu (or right-click on the project),
    and a new P**ublish Web** window will show the main options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The end of the life cycle – publishing the solution](img/image00628.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A profile is required, and you can choose a previous profile publication (if
    there''s one defined) or select the **Custom** option, give it a name, and select
    the publication targets: **Web Deploy**, **Web Deploy Package**, **FTP**, or **File
    System**.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try the results before performing a real implementation, the
    **File System** option is useful. Create a new folder to serve as a destination,
    and instruct the Assistant to publish the application there.
  prefs: []
  type: TYPE_NORMAL
- en: If everything succeeds (you'll be informed about it in the **Output** window),
    all the required files will be copied (binaries included) to the destination folder,
    where you'll be able to check whether anything's missing and retouch the process
    until is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the application life cycle process, starting
    with a review of Microsoft's Solution Framework and its basic recommendations
    and guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Through MSF, we explored the characteristics of the Team and Governance Models
    and how to configure the roles of our development people and their responsibilities
    and what the main assets of the application are.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the main principles that apply to the design of a Risk Model,
    and the techniques used to assess the application's risks.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we reviewed the many options that Visio offers in order to create deliverables
    that visually express different aspects of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered other aspects of the architecture, testing, and deployment
    of the applications available in Visual Studio Enterprise Edition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will keep on talking about projects, but this time,
    the focus will be on the quality of the code and how good practices, well-known
    recommendations, software patterns and the like will help you in a better software
    design in order to improve your solution's stability and maintenance.
  prefs: []
  type: TYPE_NORMAL
