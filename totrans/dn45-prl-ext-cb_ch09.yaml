- en: Chapter 9. Dataflow Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from and writing to a dataflow block synchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from and writing to a dataflow block asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a producer-consumer dataflow pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dataflow pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling a dataflow block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the degree of parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlink dataflow blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `JoinBlock` to read from multiple data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Task Parallel Library's dataflow is a new library that is designed to increase
    the robustness of highly concurrent applications. TPL dataflow uses asynchronous
    message passing and pipelining to obtain more control and better performance than
    manual threading.
  prefs: []
  type: TYPE_NORMAL
- en: A dataflow consists of a series of blocks. Each block can be a source or target
    for data. Data typically enters into a dataflow by being posted to a propagation
    block, which is a block that implements `ISourceBlock<T>` and `ITargetBlock<T>`.
    The source block can be linked to other target or propagation blocks. The data
    flows from one block to the next block in the chain asynchronously. The data is
    buffered at the source or target block until it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: The predefined blocks fall into three categories. There are buffering blocks
    which hold data for use by data consumers, there are execution blocks that call
    a user-provided delegate for each piece of received data, and there are grouping
    blocks which combine data from one or more sources and under various constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL dataflow library provides three types of buffering blocks. There is
    the `System.Threading.Tasks.Dataflow.BufferBlock<T>` class, the `System.Threading.Tasks.Dataflow.BroadcastBlock<T>`
    class, and the `System.Threading.Tasks.Dataflow.WriteOnceBlock<T>` class. The
    `BufferBlock<T>` class is a general-purpose asynchronous messaging class. `BufferBlock<T>`
    stores a **First-In- First-Out** (**FIFO**) queue of messages that can be written
    to by multiple sources or read from by multiple targets.
  prefs: []
  type: TYPE_NORMAL
- en: The `BroadcastBlock<T>` class is useful when you pass multiple messages to another
    component, or a message to multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: The `WriteOnceBlock<T>` class is similar the `BroadcastBlock<T>` class, except
    that a `WriteOnceBlock<T>` object can be written one time only.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL dataflow library provides three types of execution blocks. There is
    the `ActionBlock<TInput>` class, the `System.Threading.Tasks.Dataflow.TransformBlock<TInput,
    TOutput>` class, and the `System.Threading.Tasks.Dataflow.TransformManyBlock<TInput,
    TOutput>` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `ActionBlock<TInput>` class is a target block that calls a delegate when
    it receives data. You can think of a `ActionBlock<TInput>` object as a delegate
    that runs asynchronously when data becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: The `TransformBlock<TInput, TOutput>` class resembles the `ActionBlock<TInput>`
    class, except that it acts both as a source and as a target.
  prefs: []
  type: TYPE_NORMAL
- en: The `TransformManyBlock<TInput, TOutput>` class resembles the `TransformBlock<TInput,`
    `TOutput>` class, except that `TransformManyBlock<TInput, TOutput>` produces zero
    or more output values for each input value, instead of only one output value for
    each input value.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL dataflow library also provides three types of join blocks. There is
    the `BatchBlock<T>` class, the `JoinBlock<T1, T2>` class, and the `BatchedJoinBlock<T1,
    T2>` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `BatchBlock<T>` class combines sets of input data, which are known as batches,
    into arrays of output data.
  prefs: []
  type: TYPE_NORMAL
- en: The `JoinBlock<T1, T2>` and `JoinBlock<T1, T2, T3>` classes collect input elements
    and propagate out `System.Tuple<T1, T2>` or `System.Tuple<T1, T2, T3>` objects
    that contain those elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `BatchedJoinBlock<T1, T2>` and `BatchedJoinBlock<T1, T2, T3>` classes collect
    batches of input elements and propagate out the `System.Tuple(IList(T1), IList(T2))`
    or `System.Tuple(IList(T1), IList(T2), IList(T3))` objects that contain those
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: The Dataflow library's infrastructure is built on .NET 4.5's Task Parallel Library.
    These dataflow components are useful when you have multiple operations that must
    communicate with one another asynchronously or when you want to process data as
    it becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from and writing to a dataflow block synchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a message synchronously to a dataflow block is done by calling the `Post<TInput>`
    method of a block. Let's use the `Receive` method of the block to receive data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a `Console` application that uses a `for`
    loop to synchronously write some numbers to `BufferBlock` using the `Post` method.
    The application then reads the data back from `BufferBlock` using the `Receive`
    method and writes the data to `Console`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TPL dataflow library doesn't ship with the rest of the TPL. To use the TPL
    dataflow library in your solutions, you need to use NuGet Package Manager to set
    your reference.
  prefs: []
  type: TYPE_NORMAL
- en: After creating your new project in Visual Studio 2012, go to the **Solution**
    **Explorer**, right-click on **References**, and click on **Manage** **NuGet**
    **Package**.![Getting ready…](img/0225OT_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the NuGet Package Manager window, click on **Online** from the menu on the
    left and search for **TPL Dataflow**.![Getting ready…](img/0225OT_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new `Console` application so we can see how to create a dataflow
    block and write to it synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `Dataflow ReadingWriting` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGetPackages**, and add a reference to the **TPL Dataflow** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, create a `BufferBlock<int>` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a `for` loop that loops from zero to ten and writes the square
    of the loop index to the buffer block using the `Post` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's create another `for` loop that loops from zero to ten that calls
    the `Receive` method on the buffer block for each iteration, and writes the results
    to `Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up by writing a message to the `Console` application and waiting for
    user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button, and your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simple example shows how to read from and write to a message block directly.
    More often, you will be connecting dataflow blocks to form pipelines, or linear
    sequences of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a block directly is a pretty easy matter; you just need to call the
    `Post<TInput>` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Post` method acts synchronously, and returns once the target block has
    decided to accept or reject the item.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, data can be directly received from `bufferingBlock` by calling the
    `Receive` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Receive` method has a few convenient overloads that can accept a time out
    period, `CancellationToken` or both.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from and writing to a dataflow block asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a message asynchronously to a dataflow block is done by calling the
    `SendAsync<TInput>` method of a block. You use the `ReceiveAsync` method of the
    block to receive data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a `Console` application that uses a `for`
    loop to asynchronously write some numbers to `BufferBlock` using the `SendAsync`
    method. The application then reads the data back from `BufferBlock` using the
    `ReceiveAsync` method and writes the data to `Console`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `Dataflow ReadWriteAsync` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to **Solution** **Explorer**, right-click on **references**, click
    on **Manage NuGet Packages** and add a reference to the TPL Dataflow library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a `static async` method that returns `Task` called `WriteDataAsync`.
    The method takes a `BufferBlock<int>` parameter, and uses a `for` loop to iterate
    from zero to ten. In each iteration of the loop, we need to use the `SendAsync`
    method to write the square of the loop indexer to `bufferingBlock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a `static async` method that returns `Task` called `ReadDataAsync`.
    The method takes a `BufferBlock<int>` parameter, and uses a `for` loop to read
    the data from `BufferBlock` and display it to `Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create the implementation of the `Main` method. Here we just
    need to wait on calls to `WriteDataAsync` and `ReadDataAsync`. We also need to
    wait on user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button. Your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This application uses the `SendAsync` method to asynchronously write to a `BufferBlock<int>`
    object and the `ReceiveAsync` method to read from the same object. We also use
    the `async` and `await` operators to send data to and read data from the target
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both the `ReadDataAsync` and `WriteDataAsync` methods are marked
    as `async`, with a return type of `Task`. We use the `await` keyword to asynchronously
    make the call to `SendAsync` and `ReceiveAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `ReceiveAsync` method is especially useful when you want to act on data
    as the data becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a producer-consumer dataflow pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TPL dataflow blocks can also be used in a producer-consumer pattern, where a
    producer sends messages to a block, and the consumer reads messages from a block.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a `Console` application to demonstrate
    a basic producer-consumer pattern that uses dataflow. The producer will use a
    `for` loop to create some random numbers and add them to `BufferBlock<int>`. The
    consumer task will asynchronously receive the data from `BufferBlock` as it becomes
    available, and returns a sum of all the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create another `Console` application and see how we can use dataflow blocks
    to implement a producer-consumer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `Dataflow ProducerConsumer` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to **Solution Explorer**, right-click on **References**, click on **Manage
    NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating a `static` method on the `Program` class called `Produce`.
    This method returns `void`, and takes a parameter of type `ITargetBlock<int>`.
    This method will use a `for` loop to generate random numbers, and then use the
    `Post` method to send them to the block. When the `Produce` method is finished
    adding, it calls the `Complete` method on the block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a method called `ConsumeAsync`. As you probably guessed from
    the method name, this is an `async` method that returns `Task<int>`.The `ConsumeAsync`
    method needs a parameter type of `ISourceBlock<int>`. This method used a `while`
    loop to get data from the block as it becomes available, and produces a sum of
    the numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ok, let's finish up by implementing the `Main` method of the `Program` class.
    This method just needs to start `producer` and `consumer`, and display the results
    when finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Produce` method is very straightforward. We declared a parameter of the
    interface type `ITargetBlock<TInput>`. `ITargetBlock` is an interface implemented
    by `BufferBlock` that represents a dataflow block that is a target for data.
  prefs: []
  type: TYPE_NORMAL
- en: The `Produce` method just uses a `for` loop to send data to the target block
    using the `Post` method. After it is finished adding the data, it calls the complete
    method to signal that it is finished.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`ConsumeAsync` accepts a parameter of the interface type `ISourceBlock`, which
    represents a dataflow block that is a source of data. To act asynchronously, the
    `ConsumeAsync` method calls the `OutputAvailiableAsync` method to receive a notification
    when the source block has data available when the source block is finished, and
    will never have additional data. Other than that, it just uses the `Receive` method
    to receive the data and sums up the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating a dataflow pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, you can use `Post`, `Receive`, and `RecieveAsync` to
    send and receive messages from source blocks. You can also connect message blocks
    to form a dataflow pipeline. A dataflow pipeline is a chain of dataflow blocks,
    each of which performs a specific task and contributes to a larger goal. Each
    block in the pipeline performs its work when it receives a message from another
    dataflow block.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are to return to our WordCount example one final time. We
    are going to create a `Console` application that forms a dataflow pipeline for
    downloading the contents of a classic book, filters out the small words from the
    book contents, and returns a count of the words.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how we can chain dataflow blocks together to form a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `DataflowPipeline` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first step is to create the dataflow blocks that participate in the pipeline.
    In the `Main` method, create `TransformBlock<string,string>` that takes the string
    input parameter and uses `WebClient` to download the book contents as a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's add `TransformBlock<string, string[]>` which receives the output
    from the previous block, removes the spaces, and splits the words into a string
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ok, let's create `TransformBlock<string[],int>` that filters out words less
    than three characters and returns a count of the words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create `ActionBlock<int>` to display the word count to `Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's use the `LinkTo` method to connect the source blocks and target blocks
    to form the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to add some completion tasks to enable each dataflow block to
    perform a final action after processing all data elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's add some code to `Main` to post the data to the pipeline, complete
    the pipeline activity, wait for the pipeline to finish, and wait for user input
    before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    display the output as shown in the following screenshot:![How to do it…](img/0225OT_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this application we used `TransformBlock<TInput, TOutput>` to enable each
    member of the pipeline to perform an operation on its input data and send the
    results to the next step in the pipeline. For example, `downloadBook TransformBlock`
    takes a string input and returns a string output to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The only exception is the tail of the pipeline is `ActionBlock<TInput>` because
    it performs an action on its input and does not produce a result.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to connect each block in the pipeline to the next. The `LinkTo`
    method of `DataflowBlock` is used to connect `ISourceBlock<TOutput>` to `TargetBlock<TInput>`.
    When you call the `LinkTo` method to connect a source to a target, the source
    will propagate data to the target as it becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We also added some completion tasks to propagate completion through the pipeline.
    Each completion task sets the next dataflow block to the completed state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we used `DataflowBlock.Post<TInput>` to synchronously send data to
    the head of the pipeline. The following is the URL string of the book we are downloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Cancelling a dataflow block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since dataflow blocks are built on the `Task` infrastructure of the TPL, cancellation
    is supported by obtaining `CancellationToken` from `CancellationTokenSource`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a dataflow pipeline to download the contents
    of a classic book and perform a word count, except this time, we will enable the
    blocks that form the pipeline to be cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how we can add cancellation to our dataflow blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `CancelDataflow` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method, create a new `CancellationTokenSource` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create the blocks that form the pipeline. The blocks are exactly
    as before, except, this time they are created with a new `ExecutionDataflowBlockOptions`
    parameter that sets `CancellationToken`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's use the `LinkTo` method to connect the source blocks and target blocks
    to form the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to add some completion tasks to enable each dataflow block to
    perform a final action after processing all data elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, add a `try` block to post the data to the head of the pipeline, complete
    the pipeline activity, and cancel the token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, add a `catch` block that handles `AggregateException` and a `finally`
    block to wait for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This application forms a dataflow pipeline to process the contents of a book
    and return a word count as in the previous recipe. The difference is that we set
    up cancellation by creating a `CancellationTokenSource` object, and then setting
    the `CancellationToken` property of the `ExecutionDataflowBlockOptions` object
    associated with the blocks in our pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We set the `CancellationToken` property of the `ExecutionDataflowBlockOptions`
    object to `CancellationToken` obtained from the `CancellationTokenSource` object.
  prefs: []
  type: TYPE_NORMAL
- en: As with all other cancellations in the TPL, we need to handle the `OperationCancelled`
    exception, which will be wrapped in a `AggregateException` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the degree of parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to use the `CancellationToken` property of
    the `ExecutionDataflowBlockOptions` object to enable cancellation of a pipeline.
    In this recipe, we will see how to use the `MaxDegreeOfParallelism` property to
    enable dataflow blocks to process more than one message at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a `Console` application that performs two dataflow calculations,
    and prints the elapsed time of each calculation. The first calculation sets the
    maximum degree of parallelism to one. The second operation is the same as the
    first, but sets the maximum degree of parallelism to the number of available processors
    on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how to add cancellation to our dataflow blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `DegreeOfParallelism` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating a `static` method on the `Program` class called `ComputeTime`.
    The method needs to accept an `integer` parameter for `maxDegreeOfParallelism`
    and an `integer` parameter for `messageCount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `ComputeTime` method, create `ActionBlock<int>` that just sleeps for
    the time period of the `integer` parameter. `ActionBlock` also needs to use a
    `ExecutionDataflowBlockOptions` parameter and set the `MaxDegreeOfParallelism`
    property to the value of the method parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's finish up the `ComputeTime` method by creating a `Stopwatch` object, using
    a `for` loop to post data to the action block, complete the action block, and
    return the elapsed time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to implement the `Main` method. Let's start by getting the processor
    count of your machine; call the `ComputeTime` method twice (once with the `maxDegreeOfParallelism`
    parameter set to one, and once with the `maxDegreeOfParallelism` parameter set
    to your processor count), and display the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    have results as shown in the following screenshot:![How to do it…](img/0225OT_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we just use the `ComputeTime` method to set the maximum degree
    of parallelism of `ActionBlock<int>` to the value of the `maxDegreeOfParallelism`
    method parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We call this method twice, once with the `maxDegreeOfParallelism` parameter
    set to one, and once with the `maxDegreeOfParallelism` parameter set to the processor
    count of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: A maximum degree of parallelism of one causes the dataflow block to process
    messages serially, and a degree of parallelism of greater than one enables the
    dataflow block to process messages in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Unlink dataflow blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously seen how to link dataflow blocks together to form a pipeline.
    This recipe is going to show how to unlink a dataflow block from its source.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to show how to unlink a dataflow block by creating a `Console`
    application that creates three transform blocks, each of which calls a method
    to perform a calculation. The transform block objects will each be linked to a
    `WriteOnceBlock<T>` object, with the `MaxMessages` property set to one. This will
    instruct the source blocks to unlink after the first message is received at the
    target.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `DegreeOfParallelism` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to **Solution Explorer**, right-click on **References**, click on **Manage
    NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's create a `static` method called `DoCalculation`. This method accepts
    `integer` and `CancellationToken` as parameters, and returns `integer`. This method
    is going to simulate a lengthy calculation that takes a few seconds to complete,
    then returns a somewhat arbitrary value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create another `static` method called `ReceiveFromAny<T>`. This
    method will take a parameter array of `ISourceBlock<T>` and return `T`. This method
    will receive a value from the first source in the `source` array that returns
    a value. It will create new `WriteOnceBlock<T>` and link it to each source block,
    with a `DataFlowLinkOptions` parameter and the `MaxMessages` property set to one.
    Finally, it will receive the value produced by `WriteOnceBlock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's implement the `Main` method. `Main` needs to create a new `CancellationToken`
    object, create three `System.Threading.Tasks.Dataflow.TransformBlock` objects
    that each call the `DoCalculation` method, posts data to each of `TransformBlocks`,
    and receives the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_09_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Main` method of this application is responsible for creating our `TransformBlock`
    objects, creating `Func` to call the `DoCalculation` method, posting some data
    to `TransformBlocks`, and calling `RecieveFromAny` with `TransformBlocks` as parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `RecieveFromAny` method creates a new `WriteOnceBlock<T>` object, uses a
    `for` loop to link the `WriteOnceBlocks` to the source `TransformBlocks`, and
    receives the first data the `WriteOnceBlock` produces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The link to the source blocks is created using the `LinkTo` method as before,
    but this time a new `DataflowLinkOptions` object is used as a parameter, with
    the `MaxMessages` property set to one.
  prefs: []
  type: TYPE_NORMAL
- en: The `MaxMessages` property is used to set the maximum number of messages that
    may be consumed across a link.
  prefs: []
  type: TYPE_NORMAL
- en: Using JoinBlock to read from multiple data sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is going to show how to use `JoinBlock` to perform an operation
    when data is available from multiple sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a `Console` application that defines two types of resources:
    `NetworkResource` and `MemoryResource`. We will use the `NetworkResource` and
    `MemoryResource` pair to perform an operation. To enable the operation to occur
    when both required resources are available, we will use `JoinBlock<T1, T2>`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how to use `JoinBlock` to perform an operation based on data from
    multiple sources.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **Console Application** project template and assign
    `JoinBlock` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to **Solution Explorer**, right-click on **References**, click on **Manage
    NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `Program` class above the `Main` method, create an `abstract` class
    definition for resource, and a concrete `class` definition for `MemoryResource`
    and `NetworkResource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `Main` method, create a `BufferBlock<MemoryResource>` and a `BufferBlock<NetworkResource>`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create a `JoinBlock<NetworkResource, MemoryResource>`. Create a `GroupingDataflowBlockOptions`
    object parameter and set the `Greedy` property to false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to create a `ActionBlock<Tuple<NetworkResource, MemoryResource>>`
    object to simulate `NetworkResource` doing a lengthy network access operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's finish up the `Main` method by linking the resource objects,
    linking `JoinBlock` to `ActionBlock`, and posting data to the resource blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    display results as shown in the following screenshot:![How to do it…](img/0225OT_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This application starts by creating two `BufferBlock<T>` objects; one holds
    network resources and one holds memory resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Then we created a non-greedy `JoinBlock` to join the network resources to the
    memory resources by setting the `Greedy` property to `false`. In the default greedy
    mode, the join block will greedily take the data from the source, but it still
    won't produce a result tuple until all necessary data is available. This is primarily
    important when sources are connected to multiple join blocks. If all of the joins
    take data greedily from the sources, you can end up in situations where data would
    be available to satisfy one of the joins, but end up being taken greedily and
    split across multiple joins such that none of them could be satisfied, and thus,
    none will produce results until more data comes along.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create `ActionBlock` that operates network and memory resources.
    The action just simulates a lengthy operation on a network resource and then releases
    the resources back to their pools.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we link our resources together, populate our resource pools and allow
    data to flow through for a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
