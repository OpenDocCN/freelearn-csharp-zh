<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>5. Concurrent Collections</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;5.&#160;Concurrent Collections">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05"></a>Chapter&#160;5.&#160;Concurrent Collections</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we are going to cover the following recipes:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Adding and removing items to <code class="literal">BlockingCollection</code></li>
            <li class="listitem" style="list-style-type: disc">Iterating a <code class="literal">BlockingCollection</code> with <code class="literal">GetConsumingEnumerable</code></li>
            <li class="listitem" style="list-style-type: disc">Performing LIFO operations with <code class="literal">ConcurrentStack</code></li>
            <li class="listitem" style="list-style-type: disc">Thread safe data lookups with <code class="literal">ConcurrentDictionary</code></li>
            <li class="listitem" style="list-style-type: disc">Cancelling an operation in a concurrent collection</li>
            <li class="listitem" style="list-style-type: disc">Working with multiple producers and consumers</li>
            <li class="listitem" style="list-style-type: disc">Creating object pool with <code class="literal">ConcurrentStack</code></li>
            <li class="listitem" style="list-style-type: disc">Adding blocking and bounding with <code class="literal">IProducerConsumerCollection</code></li>
            <li class="listitem" style="list-style-type: disc">Using multiple concurrent collections to create a pipeline</li>
          </ul>
        </div>
        <div class="section" title="Introduction">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title" id="sigil_toc_id_7"><a id="ch05lvl1sec50"></a>Introduction</h1>
              </div>
            </div>
          </div>
          <p>Although<a id="id326" class="indexterm"></a> <code class="literal">System.Collections</code> namespace offers a wide range of collections; the only thing which limits our use of them in a multi-threaded or parallel environment is that they are not thread safe. A non thread safe collection could lead to race conditions, which is a condition that occurs when two or more threads can access shared data and try to change it at the same time, producing unexpected errors.</p>
          <p>Concurrent collections in .NET Framework 4.5 allow the developers to create type safe as well as thread safe collections. These collection classes form an essential part of the parallel programming feature and are available under the namespace <a id="id327" class="indexterm"></a>
<code class="literal">System.Collections.Concurrent</code>.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Adding and removing items to BlockingCollection">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec51"></a>Adding and removing items to BlockingCollection</h1>
            </div>
          </div>
        </div>
        <p>
<code class="literal">BlockingCollection&lt;T&gt;</code> is a thread safe collection class that provides blocking and bounding functionality. Bounding means that you can set the maximum capacity of a collection, which enables you to control the maximum size of the collection in the memory.</p>
        <p>Multiple threads can add items<a id="id328" class="indexterm"></a> to a collection concurrently, but if the collection reaches capacity, the producing threads will block until items are removed. Multiple<a id="id329" class="indexterm"></a> consumers can remove items from the collection concurrently. If the collection becomes empty, consumption will block until more items are produced and added to the collection.</p>
        <p>In this recipe,<a id="id330" class="indexterm"></a> we will take a look at the basics of adding<a id="id331" class="indexterm"></a> items to, and removing items from <code class="literal">BlockingCollection</code>.</p>
        <p>We are going to create a <code class="literal">Console</code> application that initializes a range of integers and creates a parallel task to add the numbers to a blocking collection. Another parallel task will be created to remove items from the collection.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec92"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's start Visual Studio and see how to add and remove items with <code class="literal">BlockingCollection</code>.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">BlockingCollection</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create our range of input data and our blocking collection.<div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
var numbers = new BlockingCollection&lt;int&gt;(100);</pre>
</div></li>
              <li class="listitem">Now let's create simple producer <code class="literal">Task</code> which will use a <code class="literal">for</code> loop to iterate through the numbers of our source data and add them to the blocking collection. After we are finished with the loop, use the <code class="literal">CompleteAdding</code> method of <code class="literal">BlockingCollection</code> to indicate we are done producing data.<div class="informalexample"><pre class="programlisting">// A simple blocking producer 
Task.Factory.StartNew( ()=&gt;
{
    foreach (var item in data)
    {
        numbers.Add(item);
        Console.WriteLine("Adding:{0} Item Count={1}", item, numbers.Count);
    }
    numbers.CompleteAdding();
});</pre>
</div></li>
              <li class="listitem">Next, let's create<a id="id332" class="indexterm"></a> a simple consumer <code class="literal">Task</code> that uses a <code class="literal">while</code> loop to take items from <code class="literal">BlockingCollection</code> and<a id="id333" class="indexterm"></a> write the output to <code class="literal">Console</code>. Finish up by waiting for user input before exiting.<div class="informalexample"><pre class="programlisting">// A simple blocking consumer.
Task.Factory.StartNew(() =&gt;
{
        int item = -1;
        while (!numbers.IsCompleted)
        {
            try
            {
                item = numbers.Take();
            }
            catch (InvalidOperationException)
            {
                Console.WriteLine("Nothing to take");
                break;
            }
            Console.WriteLine("Taking:{0} ", item);
            // wait for a bit
             Thread.SpinWait(1000);
    }

    Console.WriteLine("\rNo more items to take.");
});

Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_01.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec93"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, we see how<a id="id334" class="indexterm"></a> to add items to and remove items from <code class="literal">BlockingCollection</code>. <code class="literal">BlockingCollection</code> is actually a wrapper for <code class="literal">IProducerConsumer&lt;T&gt;</code>, and provides the blocking and bounding capabilities for thread safe <a id="id335" class="indexterm"></a>collections. <code class="literal">BlockingCollection</code> takes <code class="literal">IProducerConsumerCollection</code> in its constructor, or uses <code class="literal">ConcurrentQueue</code> by default.</p>
          <p>Adding the source data to the collection was easy enough. We just had to loop through the source data and call the <code class="literal">Add</code> method of <code class="literal">BlockingCollection</code> to add the item. When we are finished adding items to the collection, we call the <code class="literal">CompleteAdding</code> method. After a collection has been marked as complete for adding, no more adding will be permitted, and threads removing items from the collection will not wait when the collection is empty.</p>
          <div class="informalexample">
            <pre class="programlisting">foreach (var item in data)
{
    numbers.Add(item);
    Console.WriteLine("Adding:{0} Item Count={1}", item, numbers.Count);
}
numbers.CompleteAdding();</pre>
          </div>
          <p>Consumer <code class="literal">Task</code> uses the <code class="literal">IsCompleted</code> property of <code class="literal">BlockingCollection</code> to control a <code class="literal">while</code> loop. The <code class="literal">IsCompleted</code> property, as you would expect, indicates if <code class="literal">BlockingCollection</code> has been marked as complete for adding, and is empty. Inside the <code class="literal">while</code> loop, we just use <a id="id336" class="indexterm"></a>the <code class="literal">Take</code> method to take an item from the <a id="id337" class="indexterm"></a>collection and display it on the <code class="literal">Console</code> application.</p>
          <div class="informalexample">
            <pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    while (!numbers.IsCompleted)
    {
        try
        {
            item = numbers.Take();
        }
        catch (InvalidOperationException)
        {
            Console.WriteLine("Nothing to take");
            break;
        }
    ...
    }
Console.WriteLine("\rNo more items to take.");
});</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Iterating a BlockingCollection with GetConsumingEnumerable">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec52"></a>Iterating a BlockingCollection with GetConsumingEnumerable</h1>
            </div>
          </div>
        </div>
        <p>
<code class="literal">BlockingCollection</code> provides us with an easier alternative for looping through a collection, and removing items without setting up a <code class="literal">while</code> loop, and checking the <code class="literal">IsCompleted</code> property. <code class="literal">BlockingCollection</code> gives us the ability to do a simple <code class="literal">foreach</code> loop with the <code class="literal">GetConsumingEnumerable</code> method.</p>
        <p>In this recipe, we <a id="id338" class="indexterm"></a>are going to create a <code class="literal">Console</code> application that initializes a range of source data and spins up a producer task to <a id="id339" class="indexterm"></a>add the data to the collection. The consumer of the collection data will use the <code class="literal">GetConsumingEnumerable</code> method to get <code class="literal">IEnumerable&lt;T&gt;</code> for items in the collection.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec94"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's take a look at how to iterate over a <code class="literal">BlockingCollection</code> with <code class="literal">GetConsumingEnumerable</code>.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Enumerate</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create our range of input data and our blocking collection.<div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
var numbers = new BlockingCollection&lt;int&gt;(100);</pre>
</div></li>
              <li class="listitem">Next<a id="id340" class="indexterm"></a> let's create a simple producer <code class="literal">Task</code> which will use a <code class="literal">for</code> loop to iterate through <a id="id341" class="indexterm"></a>the numbers of our source data and add them to the blocking collection.<div class="informalexample"><pre class="programlisting">// A simple blocking producer 
Task.Factory.StartNew( ()=&gt;
{
    foreach (var item in data)
    {
        numbers.Add(item);
        Console.WriteLine("Adding:{0} Item Count={1}", item, numbers.Count);
    }
    numbers.CompleteAdding();
});</pre>
</div></li>
              <li class="listitem">Finally, let's create a consumer <code class="literal">Task</code> which will iterate through the collection with a <code class="literal">foreach</code> loop by calling the <code class="literal">GetConsumingEnumerable</code> method of blocking collection. Finish up by waiting for user input before exiting.<div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var item in numbers.GetConsumingEnumerable())
    {                        
        Console.Write("\nConsuming item: {0}", item);                       
    }                    
});
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_02.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec95"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>Producer <code class="literal">Task</code> in this recipe is exactly the same as producer <code class="literal">Task</code> created in the first recipe. <a id="id342" class="indexterm"></a> The only real change to take note<a id="id343" class="indexterm"></a> of is that we no longer have to set up a <code class="literal">while</code> loop to take items from the collection, as we did in the first recipe.</p>
          <div class="informalexample">
            <pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    while (!numbers.IsCompleted)
    {
        try
        {
            item = numbers.Take();
        }
        catch (InvalidOperationException)
        {
            Console.WriteLine("Nothing to take");
            break;
        }
    ...
    }
Console.WriteLine("\rNo more items to take.");
});</pre>
          </div>
          <p>By calling<a id="id344" class="indexterm"></a> the <code class="literal">GetConsumingEnumerable</code> method of <code class="literal">BlockingCollection</code>, we can now use much cleaner<a id="id345" class="indexterm"></a> <code class="literal">foreach</code> loop syntax.</p>
          <div class="informalexample">
            <pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var item in result.GetConsumingEnumerable())
    {                        
        Console.Write("\nConsuming item: {0}", item);                       
    }                    
});
Console.ReadLine();</pre>
          </div>
          <p>The<a id="id346" class="indexterm"></a> <code class="literal">GetConsumingEnumerable</code> method takes a snapshot of the current state of the underlying collection and returns <code class="literal">IEnumerable&lt;T&gt;</code> for the collection items.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Performing LIFO operations with ConcurrentStack">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec53"></a>Performing LIFO operations with ConcurrentStack</h1>
            </div>
          </div>
        </div>
        <p>
<code class="literal">ConcurrentStack</code> is the thread safe counterpart of <code class="literal">Systems.Collections.Generic.Stack</code>, which is the standard <span class="strong"><strong>Last-In-First-Out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) container in the .NET Framework. For algorithms that favor stack usage such as depth-first searches, a<a id="id347" class="indexterm"></a> thread safe stack is a big benefit.</p>
        <p>In this recipe we are <a id="id348" class="indexterm"></a>going to take a look at the basic usage of <code class="literal">ConcurrentStack</code>. Our <code class="literal">Console</code> application for this recipe will initialize a range of data, which a simple producer <code class="literal">Task</code> will push onto the stack. Consumer <code class="literal">Task</code> will concurrently pop items from the stack and write them to <code class="literal">Console</code>.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec96"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's take a look at performing LIFO operations with <code class="literal">ConcurrentStack</code>.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start<a id="id349" class="indexterm"></a> a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ConcurrentStack</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the<a id="id350" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create our range of input data and our blocking collection.<div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
ConcurrentStack&lt;int&gt; stack = new ConcurrentStack&lt;int&gt;();</pre>
</div></li>
              <li class="listitem">Next, let's create a simple producer task which will use a <code class="literal">for</code> loop to iterate through the numbers of our source data and pop them onto the stack.<div class="informalexample"><pre class="programlisting">// producer 
Task.Factory.StartNew(() =&gt;
{
    foreach (var item in data)
    {
        stack.Push(item);
        Console.WriteLine("Pushing item onto stack:{0} Item Count={1}", 
      item, stack.Count);
    }
});</pre>
</div></li>
              <li class="listitem">Now let's create a consumer <code class="literal">Task</code> which will use a <code class="literal">while</code> loop to pop items off the stack while the <code class="literal">IsEmpty</code> property of the stack is false. Finish by waiting for user input before exiting.<div class="informalexample"><pre class="programlisting">//consumer
Task.Factory.StartNew(() =&gt;
{
    Thread.SpinWait(1000000);
    while (!stack.IsEmpty)
    {
        int result = 0;
        stack.TryPop(out result);
        Console.WriteLine("Popping item from stack:{0} Item Count={1}", 
      result, stack.Count);
    }
});
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual <a id="id351" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to <a id="id352" class="indexterm"></a>run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_03.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec97"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>
<code class="literal">ConcurrentStack</code> achieves thread safe access by using the <code class="literal">System.Threading.Interlocked</code> operations. Interlocked operations provide a simple mechanism for synchronizing access to variables shared by multiple threads. Interlocked operations are also very fast.</p>
          <p>For the most part, <code class="literal">ConcurrentStack</code> behaves like <code class="literal">System.Collections.Generic.Stack</code>. To push an item onto the stack, you just use the <code class="literal">Push</code> method.</p>
          <div class="informalexample">
            <pre class="programlisting">foreach (var item in data)
{
    stack.Push(item);
    Console.WriteLine("Pushing item onto stack:{0} Item Count={1}", 
    item, stack.Count);
}</pre>
          </div>
          <p>However, the <code class="literal">Pop</code>
<a id="id353" class="indexterm"></a> method was<a id="id354" class="indexterm"></a> removed in favor of <code class="literal">TryPop</code>. <code class="literal">TryPop</code> returns <code class="literal">true</code> if an item existed and was popped, otherwise it returns <code class="literal">false</code>. The <code class="literal">out</code> parameter contains the object removed if the pop was successful, otherwise it is indeterminate.</p>
          <div class="informalexample">
            <pre class="programlisting">while (!stack.IsEmpty)
{
    int result = 0;
    stack.TryPop(out result);
    Console.WriteLine("Popping item from stack:{0} Item Count={1}", 
    result, stack.Count);
}</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Thread safe data lookups with ConcurrentDictionary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec54"></a>Thread safe data lookups with ConcurrentDictionary</h1>
            </div>
          </div>
        </div>
        <p>
<code class="literal">ConcurrentDictionary</code> is the thread safe counterpart to the generic <code class="literal">dictionary</code> collection. Both are designed for quick lookups of data based on a key. However, <code class="literal">ConcurrentDictionary</code> allows us to interleave both reads and updates. <code class="literal">ConcurrentDictionary</code> <a id="id355" class="indexterm"></a>achieves its thread safety with no common lock to improve efficiency. It actually uses a series of locks to provide concurrent updates, and has lockless reads.</p>
        <p>In this recipe, we will create <a id="id356" class="indexterm"></a>
<code class="literal">ConcurrentDictionary</code> and initialize it with a small set of key value pairs. Our <code class="literal">dictionary</code> will be concurrently updated by one task and read by another.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec98"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's take a look at how to use <code class="literal">ConcurrentDictionary</code> for data lookups.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ConcurrentDictionary</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, let's <a id="id357" class="indexterm"></a>create <a id="id358" class="indexterm"></a>our <code class="literal">ConcurrentDictionary</code> and initialize it with some data.<div class="informalexample"><pre class="programlisting">var dictionary = new ConcurrentDictionary&lt;string, int&gt;();
dictionary["A"] = 1;
dictionary["B"] = 2;
dictionary["C"] = 3;
dictionary["D"] = 4;
dictionary["E"] = 5;
dictionary["F"] = 6;
dictionary["G"] = 7;
dictionary["H"] = 8;
dictionary["I"] = 9;
dictionary["J"] = 10;
dictionary["K"] = 11;
dictionary["L"] = 12;
dictionary["M"] = 13;
dictionary["N"] = 14;
dictionary["O"] = 15;</pre>
</div></li>
              <li class="listitem">Now let's create <code class="literal">Task</code> to update <code class="literal">dictionary</code> on a separate thread.<div class="informalexample"><pre class="programlisting">// update dictionary on a separate thread
Task.Factory.StartNew(() =&gt;
{
    foreach (var pair in dictionary)
    {
        var newValue = pair.Value + 1;
        dictionary.TryUpdate(pair.Key,newValue,pair.Value);
        Console.WriteLine("Updated key: {0} value:{1}", pair.Key, newValue);
    }   
});</pre>
</div></li>
              <li class="listitem">Now let's create another <code class="literal">Task</code> which will be concurrently reading from <code class="literal">dictionary</code>.<div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var pair in dictionary)
    {
        Console.WriteLine("Reading key: {0} value:{1}",pair.Key,pair.Value);
    }
});            

Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_04.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec99"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>
<code class="literal">ConcurrentDictionary</code> behaves like <code class="literal">dictionary</code> counterpart with slight differences. We are updating <code class="literal">dictionary</code> using the <code class="literal">TryUpdate</code> method. This method was added to provide us with <a id="id359" class="indexterm"></a>an atomic operation to check if the item exists, and if not, add it while still under an atomic lock.</p>
          <div class="informalexample">
            <pre class="programlisting">foreach (var pair in dictionary)
    {
        var newValue = pair.Value + 1;
        dictionary.TryUpdate(pair.Key,newValue,pair.Value);
        Console.WriteLine("Updated key: {0} value:{1}", pair.Key, newValue);
    }</pre>
          </div>
          <p>We are reading <code class="literal">dictionary</code> directly from the <code class="literal">Key</code> and <code class="literal">Value</code> properties of each <code class="literal">KeyValuePair</code> in the<a id="id360" class="indexterm"></a> collection.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Cancelling an operation in a concurrent collection">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec55"></a>Cancelling an operation in a concurrent collection</h1>
            </div>
          </div>
        </div>
        <p>When working with <code class="literal">BlockingCollection</code>, most <code class="literal">Add</code> and <code class="literal">Take</code> operations are performed in a loop.<a id="id361" class="indexterm"></a> The <code class="literal">TryAdd</code> and <code class="literal">TryTake</code> methods of <code class="literal">BlockingCollection</code> can accept a <code class="literal">CancellationToken</code> parameter so that we can respond to cancellation requests and break out of a loop.</p>
        <p>In this recipe, we are going to create a <code class="literal">Console</code> application that has producer <code class="literal">Task</code> and consumer <code class="literal">Task</code>. The producer will be adding items to <code class="literal">BlockingCollection</code> using <code class="literal">TryAdd</code>, and the consumer<a id="id362" class="indexterm"></a> will be removing items using <code class="literal">Try</code>.</p>
        <p>After the producer and consumer get started, we will call the <code class="literal">Cancel</code> method on a token source to see how we can use the <code class="literal">TryAdd</code> and <code class="literal">TryTake</code> overloads to handle cancellation of our operation.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec100"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime <code class="literal">Exception</code> is thrown, and intercepts the <code class="literal">Exception</code> before it gets to our handler.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</li>
              <li class="listitem">Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_05_05.jpg" alt="Getting ready…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec101"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how <a id="id363" class="indexterm"></a>to cancel a concurrent collection operation.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">CancelOperation</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the<a id="id364" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create a source range of numbers, instantiate our <code class="literal">CancellationTokenSource</code> and obtain <code class="literal">CancellationToken</code>.<div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
var numbers = new BlockingCollection&lt;int&gt;(100);
var tokenSource = new CancellationTokenSource();
var token = tokenSource.Token;</pre>
</div></li>
              <li class="listitem">Next, just below the previous lines, create a producer <code class="literal">Task</code> and pass in <code class="literal">CancellationToken</code>. The producer should add items to <code class="literal">BlockingCollection</code> by calling <code class="literal">TryAdd</code> inside a <code class="literal">try</code>/<code class="literal">catch</code> block. The <code class="literal">catch</code> block should handle <code class="literal">OperationCancelledException</code>.<div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var item in data)
    {
    try
    {
      numbers.TryAdd(item,5,token);
      Console.WriteLine("Adding:{0} Item Count={1}", 
        item, numbers.Count);
    }
    catch(OperationCanceledException)
    {
      Console.WriteLine("Adding operation has been cancelled");
      numbers.CompleteAdding();
      break;
    }
    }
    numbers.CompleteAdding();
},token);</pre>
</div></li>
              <li class="listitem">Now let's create a <a id="id365" class="indexterm"></a>consumer <code class="literal">Task</code> and pass in <code class="literal">CancellationToken</code>. The consumer task should take<a id="id366" class="indexterm"></a> items from <code class="literal">BlockingCollection</code> by calling <code class="literal">TryTake</code> inside a <code class="literal">try</code>/<code class="literal">catch</code> block. The <code class="literal">catch</code> block should handle <code class="literal">OperationCancelledException</code>.<div class="informalexample"><pre class="programlisting">// A simple blocking consumer.
Task.Factory.StartNew(() =&gt;
{
    
  while (!numbers.IsCompleted)
  {
    try
    {
      numbers.TryTake(out item,5,token);
    }
    catch (OperationCanceledException)
    {
      Console.WriteLine("Take operation has been cancelled");
      break;
    }
    Console.WriteLine("Taking:{0} ", item);
    // wait for a bit
    Thread.SpinWait(10000);
  }
  Console.WriteLine("\rNo more items to take.");
},token);</pre>
</div></li>
              <li class="listitem">Finally, let's have the main thread wait for a bit, then call the <code class="literal">Cancel</code> method of <code class="literal">CancellationTokenSource</code>. Wait for user input before exiting.<div class="informalexample"><pre class="programlisting">Thread.SpinWait(2000000);
tokenSource.Cancel();
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual <a id="id367" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to<a id="id368" class="indexterm"></a> run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_06.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec102"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>Responding to <a id="id369" class="indexterm"></a>cancellations when working with <code class="literal">BlockingCollection</code> is pretty consistent with other classes in the Task Parallel Library.</p>
          <p>In the producer task, we use the overload of <code class="literal">TryAdd</code> that accepts an out parameter, a timeout parameter and <code class="literal">CancellationToken</code>. We also call <code class="literal">TryAdd</code> in a <code class="literal">try</code>/<code class="literal">catch</code> block, so we can respond to <code class="literal">OperationCancelledException</code>. When the operation is cancelled, we call <code class="literal">CompleteAdding</code> to indicate we will be adding more items and execute a <code class="literal">break</code> statement to break out of the loop.</p>
          <div class="informalexample">
            <pre class="programlisting">foreach (var item in data)
{
  try
  {
    numbers.TryAdd(item,5,token);
    Console.WriteLine("Adding:{0} Item Count={1}", 
              item, numbers.Count);
  }
  catch(OperationCanceledException)
  {
    Console.WriteLine("Adding operation has been cancelled");
    numbers.CompleteAdding();
    break;
  }
}</pre>
          </div>
          <p>Things are very <a id="id370" class="indexterm"></a>similar on the consumer side. We pass<a id="id371" class="indexterm"></a> <code class="literal">CancellationToken</code> into <code class="literal">TryTake</code> and handle <code class="literal">OperationCancelledException</code> in our <code class="literal">catch</code> block. When the operation is cancelled, we issue a <code class="literal">break</code> statement to break out of the loop.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Working with multiple producers and consumers">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec56"></a>Working with multiple producers and consumers</h1>
            </div>
          </div>
        </div>
        <p>It is possible to use single <code class="literal">BlockingCollection</code> as a buffer between multiple producers and consumers.</p>
        <p>In this recipe, we are going to build a <code class="literal">Console</code> application that will create multiple producer tasks which <a id="id372" class="indexterm"></a>perform an expensive math operation on<a id="id373" class="indexterm"></a> a small range of numbers. We will also have two consumer tasks that loop through the <code class="literal">BlockingCollection</code> buffer and display the results.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec103"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's take a look at using a single <code class="literal">BlockingCollection</code> with multiple producers and consumers.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">MultiptleProducerConsumer</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">Let's start by creating a <code class="literal">static</code> method on the <code class="literal">Program</code> class which performs our expensive math operation.<div class="informalexample"><pre class="programlisting">private static double CalcSumRoot(int root)
{
  double result = 0;
  for (int i = 1; i &lt; 10000000; i++)
  {
    result += Math.Exp(Math.Log(i) / root);
  }
  return result;
}</pre>
</div></li>
              <li class="listitem">Now let's create another <code class="literal">static</code> method on the <code class="literal">Program</code> class that the consumers<a id="id374" class="indexterm"></a> will use to display the results to the <a id="id375" class="indexterm"></a><code class="literal">Console</code> application. This method will call <code class="literal">GetConsumingEnumerable</code> on <code class="literal">BlockingCollection</code> and loop through the collection.<div class="informalexample"><pre class="programlisting">private static void DisplayResults(BlockingCollection&lt;double&gt; results)
{
  foreach (var item in results.GetConsumingEnumerable())
  {
    Console.Write("\nConsuming item: {0}", item);
  }
}</pre>
</div></li>
              <li class="listitem">Next, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's define our <code class="literal">BlockingCollection</code> buffer and create <code class="literal">List&lt;Task&gt;</code>, so we can coordinate our multiple tasks, and create a couple of simple consumer <code class="literal">tasks</code> that will use the <code class="literal">DisplayResults</code> method to print out the results.<div class="informalexample"><pre class="programlisting">var results = new BlockingCollection&lt;double&gt;();
var tasks = new List&lt;Task&gt;();
var consume1 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume2 = Task.Factory.StartNew(() =&gt; DisplayResults(results));</pre>
</div></li>
              <li class="listitem">Now we need to create a <code class="literal">for</code> loop that loops from one to twenty-five, creating producer tasks that use the <a id="id376" class="indexterm"></a><code class="literal">CalcSumRoot</code> method to calculate the result, and then add the result to <code class="literal">BlockingCollection</code> by calling <code class="literal">TryAdd</code>. The loop must also add all of producer <code class="literal">tasks</code> to the <code class="literal">Task</code> list.<div class="informalexample"><pre class="programlisting">for (int item = 1; item &lt; 25; item++)
{
  var value = item;
  var compute = Task.Factory.StartNew(() =&gt;
  {
    var calcResult = CalcSumRoot(value);
    Console.Write("\nProducing item: {0}", calcResult);
    results.TryAdd(calcResult);
  });
  tasks.Add(compute);
}</pre>
</div></li>
              <li class="listitem">Finally, let's create a continuation to run after all producer <code class="literal">tasks</code> that are complete. The <a id="id377" class="indexterm"></a>continuation simply calls the <code class="literal">CompleteAdding</code> method<a id="id378" class="indexterm"></a> of <code class="literal">BlockingCollection</code> to indicate that we are done adding items<a id="id379" class="indexterm"></a> to the collection. Finish up by waiting for user input before exiting.<div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(),
result =&gt;
{
  results.CompleteAdding();
  Console.Write("\nCompleted adding.");
});

Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Notice the ordered results in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_07.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec104"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>By default, <code class="literal">BlockingCollection</code> uses <code class="literal">ConcurrentQueue&lt;T&gt;</code> as the backing store. <code class="literal">ConcurrentQueue</code> takes care of thread synchronization and <code class="literal">BlockingCollection</code> does a non-busy wait while <a id="id380" class="indexterm"></a>trying to take an item from the collection. That is, if the consumer calls <code class="literal">TryTake</code> when there are no items in the queue, it does a non-busy wait <a id="id381" class="indexterm"></a>until any items are available.</p>
          <p>In this recipe, we are spinning up producer <code class="literal">tasks</code> in a <code class="literal">for</code> loop. Each producer <code class="literal">task</code> is calling the <code class="literal">CalcSumRoot</code> method<a id="id382" class="indexterm"></a> which is a fairly expensive math operation. Our consumers are simply displaying the output to the screen. As a result, our two consumer <code class="literal">tasks</code> are probably spending most of their time in a non busy wait state.</p>
          <p>The producers and consumers are pretty simple, but we needed a way to call <code class="literal">CompleteAdding</code> after all producer <code class="literal">tasks</code> have finished. We handled this by adding all of our producer <code class="literal">Task</code> objects to <code class="literal">List&lt;Task&gt;</code>, and calling the <code class="literal">ContinueWhenAll</code> method of <code class="literal">Task.Factory</code>, so our continuation only runs when all of the producers complete. The only job of the continuation is to call the <code class="literal">CompleteAdding</code> method of <code class="literal">BlockingCollection</code>.</p>
          <div class="informalexample">
            <pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(),
result =&gt;
{
  results.CompleteAdding();
  Console.Write("\nCompleted adding.");
});

Console.ReadLine();</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Creating object pool with ConcurrentStack">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec57"></a>Creating object pool with ConcurrentStack</h1>
            </div>
          </div>
        </div>
        <p>An object pool is a set of pre-initialized objects that your application can use, rather than creating and destroying all of the objects it needs. If the instantiation cost of an object type is high, your application might benefit from a pool of objects.</p>
        <p>In this recipe, we are going to create an object pool based on <code class="literal">ConcurrentStack</code>. <code class="literal">ConcurrentStack</code> will<a id="id383" class="indexterm"></a> handle concurrent access issues using fast interlocked operations, and will dispense our objects in a LIFO manner. We <a id="id384" class="indexterm"></a>will also have an object pool client which creates three tasks. One creates objects and puts them in the pool, the other two tasks request objects from the pool on different threads.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec105"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's see how we can use <code class="literal">ConcurrentStack</code> to build a pool of pre-initialized objects.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ObjectPool</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Let's start by creating <a id="id385" class="indexterm"></a>our object pool<a id="id386" class="indexterm"></a> class. Right-click on the <code class="literal">ObjectPool</code> project in the <span class="strong"><strong>Solution Explorer</strong></span> and click on <span class="strong"><strong>Add</strong></span>, then choose<span class="strong"><strong> New Item</strong></span>. Select <span class="strong"><strong>Visual C# Items</strong></span>, and <span class="strong"><strong>Class.</strong></span> Enter <code class="literal">ConcurrentObjectPool</code> as the name of the class.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">ConcurrentObjectPool</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;</pre>
</div></li>
              <li class="listitem">We want our object pool to work with any type, so add a generic type parameter after the class name.<div class="informalexample"><pre class="programlisting">public class ConcurrentObjectPool&lt;T&gt;
{
}</pre>
</div></li>
              <li class="listitem">Our <code class="literal">ObjectPool</code> class<a id="id387" class="indexterm"></a> is going to need a couple of private state fields. We need a <code class="literal">ConcurrentStack</code> field which will provide our backing store and a <code class="literal">Func&lt;T&gt;</code> field which will hold an object creation function the pool can use to generate objects when the pool is empty. Inside the class declaration, add the following fields:<div class="informalexample"><pre class="programlisting">private ConcurrentStack&lt;T&gt; _objects;
private Func&lt;T&gt; _objectInitializer;</pre>
</div></li>
              <li class="listitem">Now we need a constructor for the <code class="literal">ConcurrentObjectPool</code> class. The constructor should take a <code class="literal">Func&lt;T&gt;</code> argument for the object generator and should instantiate a new <code class="literal">ConcurrentStack</code> object as the backing store.<div class="informalexample"><pre class="programlisting">public ConcurrentObjectPool(Func&lt;T&gt; objectInitializer)
{
  _objects = new ConcurrentStack&lt;T&gt;();
  _objectInitializer = objectInitializer;
}</pre>
</div></li>
              <li class="listitem">Now we need a <code class="literal">GetObject</code> method which will return a new object to the client. The <code class="literal">GetObject</code> method will try to pop an object off the stack. If it can't pop one off the stack, it will use <code class="literal">objectInitializer</code> to instantiate a new object.<div class="informalexample"><pre class="programlisting">public T GetObject()
{
  T item;
  if (_objects.TryPop(out item)) return item;
  return _objectInitializer();
}</pre>
</div></li>
              <li class="listitem">The last step for <a id="id388" class="indexterm"></a>our object pool is <a id="id389" class="indexterm"></a>a <code class="literal">PutObject</code> method that takes a generic item parameter and pushes it on the stack.<div class="informalexample"><pre class="programlisting">public void PutObject(T item)
{
  _objects.Push(item);
}</pre>
</div></li>
              <li class="listitem">Now we need to create the <code class="literal">Console</code> application that will use the object pool. Go back to <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives at the top of the file:<div class="informalexample"><pre class="programlisting">using System;
using System.Text;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">The first step is to instantiate our object pool. In the <code class="literal">main</code> method of the program class, create a <code class="literal">ConcurrentObjectPool</code> object and pass in a function that creates a new <code class="literal">StringBuilder</code> object as the constructor parameter.<div class="informalexample"><pre class="programlisting">var pool = new ConcurrentObjectPool&lt;StringBuilder&gt;(()=&gt;
  new StringBuilder("Pooled Object created by objectInitializer"));</pre>
</div></li>
              <li class="listitem">Now let's create a task that creates some objects and places them in <code class="literal">pool</code> using the <code class="literal">PutObject</code> method.<div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(() =&gt;
{
  for (var index = 0; index &lt; 10; index++)
  {
    StringBuilder newObject = new StringBuilder(string.Concat("Pooled object", 
          index.ToString()));
    Console.WriteLine("Putting pooled object: {0}", index.ToString());
    pool.PutObject(newObject);
  }
});</pre>
</div></li>
              <li class="listitem">Finally, let's create two continuation tasks that run after the first task is completed. <a id="id390" class="indexterm"></a>Both tasks just request<a id="id391" class="indexterm"></a> objects from the object <code class="literal">pool</code> using the <code class="literal">GetObject</code> method.<div class="informalexample"><pre class="programlisting">task1.ContinueWith((antecedent)=&gt;
{
  for (var index = 0; index &lt; 10; index++)
  {
    var pooledObject = pool.GetObject();
    Console.WriteLine("First Task: {0}", pooledObject.ToString());                    
  }
});

task1.ContinueWith((antecedent) =&gt;
{
  for (var index = 0; index &lt; 10; index++)
  {
    var pooledObject = pool.GetObject();
    Console.WriteLine("Second Tasks: {0}", pooledObject.ToString());
  }
});</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_08.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec106"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>There are other features we could have added to our object <code class="literal">pool</code>, such as controlling the concurrency level and/or using thread local segments to store our objects, but this simple implementation does<a id="id392" class="indexterm"></a> the job for our purposes.</p>
          <p>The constructor <a id="id393" class="indexterm"></a>of the object <code class="literal">pool</code> takes a function argument that it can use to generate an object if the pool is empty, and stores the function in a private <code class="literal">objectInitializer</code> field. We are just pooling <code class="literal">StringBuilder</code> objects in this sample, so we passed in the following function:</p>
          <div class="informalexample">
            <pre class="programlisting"> ()=&gt;new StringBuilder("Pooled Object created by objectInitializer")</pre>
          </div>
          <p>Our <code class="literal">GetObject</code> method<a id="id394" class="indexterm"></a>, which the client uses to get objects from <code class="literal">pool</code>, just uses the <code class="literal">TryPop</code> method of <code class="literal">ConcurrentStack</code> to return an object. If <code class="literal">TryPop</code> fails to return anything because the stack is empty, we just return the result of the <code class="literal">objectInitializer</code> function.</p>
          <div class="informalexample">
            <pre class="programlisting">public T GetObject()
{
  T item;
  if (_objects.TryPop(out item)) return item;
  return _objectInitializer();
}</pre>
          </div>
          <p>The <code class="literal">PutObject</code> method<a id="id395" class="indexterm"></a> probably doesn't require much explanation. It just uses the <code class="literal">Push</code> method of <code class="literal">ConcurrentStack</code> to push an object onto the stack.</p>
          <p>Given that we chose to use <code class="literal">ConcurrentStack</code>, our object references are returned in a LIFO fashion. We could have chosen another type of backing store if this didn't work for us. For example, we could have chosen to use <code class="literal">ConcurrentQueue</code> as a backing store to have items returned in a <a id="id396" class="indexterm"></a>
<span class="strong"><strong>First-In-First-Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) fashion, or we could have used <code class="literal">ConcurrentBag</code> to provide unordered storage.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Adding blocking and bounding with IProducerConsumerCollection">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec58"></a>Adding blocking and bounding with IProducerConsumerCollection</h1>
            </div>
          </div>
        </div>
        <p>By default, <code class="literal">BlockingCollection</code> uses <code class="literal">ConcurrentQueue</code> as its backing store. However, you can add blocking and <a id="id397" class="indexterm"></a>bounding functionality to any custom or derived collection class by implementing the <a id="id398" class="indexterm"></a>
<code class="literal">IProducerConsumerCollection</code> interface in the class. You can then use an instance of the custom <a id="id399" class="indexterm"></a>collection class as the backing store for <code class="literal">BlockingCollection</code>.</p>
        <p>In this recipe, we are going to<a id="id400" class="indexterm"></a> create a custom priority queue and use the custom queue as the backing store for <code class="literal">BlockingCollection</code>.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec107"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's examine how we can use <code class="literal">IProducerConsumerColletion</code> to add blocking and bounding <a id="id401" class="indexterm"></a>functionality to a <a id="id402" class="indexterm"></a>custom collection.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <span class="strong"><strong>CustomBlockingBounding</strong></span> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">First, let's add a <code class="literal">Class</code> file for our custom queue. Right-click on the <span class="strong"><strong>CustomBlockingBounding </strong></span>project and click on <span class="strong"><strong>Add Item</strong></span>, and then click on <span class="strong"><strong>Add New Item</strong></span> and then click on <span class="strong"><strong>Class</strong></span>. Name the new class <code class="literal">PriorityQueue.cs</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">PriorityQueue</code> class:<div class="informalexample"><pre class="programlisting">using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections;
using System;
using System.Threading;</pre>
</div></li>
              <li class="listitem">Below the <code class="literal">PriorityQueue</code> class<a id="id403" class="indexterm"></a>, let's create an enumeration for our queue priority levels. We just want to use low, medium, and high as the possible priority levels.<div class="informalexample"><pre class="programlisting">public enum QueuePriorityLevel
{
  High = 0,
  Medium = 1,
  Low = 2
}</pre>
</div></li>
              <li class="listitem">Our custom collection class will hold <code class="literal">KeyValuePairs</code> of the queue priority level and the data queued. Add priority level and queued data generic type parameters to <code class="literal">Class</code> and declare the <code class="literal">IProducerConsumerCollection</code> interface.<div class="informalexample"><pre class="programlisting">public class PriorityQueue&lt;PriorityLevel, TValue&gt;: 
  IProducerConsumerCollection&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;
{

}</pre>
</div></li>
              <li class="listitem">Next, we need some private fields for the <code class="literal">PriorityQueue</code> class. We will need three <code class="literal">ConcurrentQueue&lt;QueuePriorityLevel, TValue&gt;</code> fields; one each for the low, <a id="id404" class="indexterm"></a>medium, and high priority queues. We will need an array of <a id="id405" class="indexterm"></a><code class="literal">ConcurrentQueue</code> to hold all of the queues and an integer count variable.<div class="informalexample"><pre class="programlisting">private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _lowPriotityQueue = null;
private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _mediumPriotityQueue = null;
private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _highPriotityQueue = null;
private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;[] _queues = null;
private int _count = 0;</pre>
</div></li>
              <li class="listitem">Now let's add a <a id="id406" class="indexterm"></a>default constructor to the <code class="literal">PriorityQueue</code> class that initializes all of our fields.<div class="informalexample"><pre class="programlisting">public PriorityQueue()
{
  _lowPriotityQueue = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel,TValue&gt;&gt;();
  _mediumPriotityQueue = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel,TValue&gt;&gt;();
  _highPriotityQueue = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel,TValue&gt;&gt;();
  _queues = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;[3]
  {
    _lowPriotityQueue,
    _mediumPriotityQueue,
    _highPriotityQueue
  };
}</pre>
</div></li>
              <li class="listitem">Next, we need to provide an implementation for several of the <code class="literal">IProducerConsumerCollection</code> interface members. Let's start with the <code class="literal">CopyTo</code> method. <a id="id407" class="indexterm"></a>This method makes a copy of our collection array to a destination array.<div class="informalexample"><pre class="programlisting">public void CopyTo(KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] array, int index)
{
  if (array == null) throw new ArgumentNullException();

  KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] temp = this.ToArray();
  for (int i = 0; i &lt; array.Length &amp;&amp; i &lt; temp.Length; i++)
    array[i] = temp[i];
}</pre>
</div></li>
              <li class="listitem">Now we <a id="id408" class="indexterm"></a>need to<a id="id409" class="indexterm"></a> provide<a id="id410" class="indexterm"></a> an implementation for the <a id="id411" class="indexterm"></a><code class="literal">ToArray</code> method which returns an array of <code class="literal">KeyValuePairs</code>.<div class="informalexample"><pre class="programlisting">public KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] ToArray()
{
  KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] result;

  lock (_queues)
  {
    result = new KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[this.Count];
    int index = 0;
    foreach (var q in _queues)
    {
      if (q.Count &gt; 0)
      {
        q.CopyTo(result, index);
        index += q.Count;
      }
    }
    return result;
  }
}</pre>
</div></li>
              <li class="listitem">Now we are getting to the key <code class="literal">IProducerConsumerCollection</code> method implementations. We need to provide an implementation for the <code class="literal">TryAdd</code> method<a id="id412" class="indexterm"></a> which is going to determine our private <code class="literal">ConcurrentQueue</code> collections to add the new item to, and then add the item, and use <code class="literal">Interlocked.Increment</code> to increment the count.<div class="informalexample"><pre class="programlisting">public bool TryAdd(KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  int priority = (int) item.Key;
  _queues[priority].Enqueue(item);
  Interlocked.Increment(ref _count);
  return true;
}</pre>
</div></li>
              <li class="listitem">The <code class="literal">TryTake</code> method<a id="id413" class="indexterm"></a> implementation needs to loop through the backing <code class="literal">ConcurrentQueues</code> in priority order, and try to take the first available item from one<a id="id414" class="indexterm"></a> of the <a id="id415" class="indexterm"></a>queues,<a id="id416" class="indexterm"></a> and decrement the count.<div class="informalexample"><pre class="programlisting">public bool TryTake(out KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  bool success = false;

  for (int i = 0; i &lt;= 2; i++)
  {
    lock (_queues)
    {
      success = _queues[i].TryDequeue(out item);
      if (success)
      {
        Interlocked.Decrement(ref _count);
        return true;
      }
    }
  }

  item = new KeyValuePair&lt;QueuePriorityLevel, TValue&gt;(0, default(TValue));
  return false;
}</pre>
</div></li>
              <li class="listitem">Next we need to implement the <code class="literal">GetEnumerator</code> methods required to implement <code class="literal">IEnumerable</code>.<div class="informalexample"><pre class="programlisting">public IEnumerator&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; GetEnumerator()
{
  for (int i = 0; i &lt;= 2; i++)
  {
    foreach (var item in _queues[i])
      yield return item;
  }
}

IEnumerator IEnumerable.GetEnumerator()
{
  return GetEnumerator();
}</pre>
</div></li>
              <li class="listitem">We're almost done with the collection. The last thing we need to do is implement a simple <a id="id417" class="indexterm"></a>getter for the <code class="literal">count</code> field. There is no need to provide an implementation for the other <code class="literal">IProducerConsumerCollection</code> members.<div class="informalexample"><pre class="programlisting">public int Count
{
  get { return _count; }
}</pre>
</div></li>
              <li class="listitem">Ok, let's <a id="id418" class="indexterm"></a>move on to our <code class="literal">Console</code> application which will use the custom <code class="literal">queue</code> class. <a id="id419" class="indexterm"></a>Open <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of the class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, start with some local variable declarations for a <code class="literal">PriorityQueue</code> variable, a <code class="literal">BlockingCollection</code> variable that takes the <code class="literal">PriorityQueue</code> variable as a constructor argument, and a list of tasks which will hold references to our producer and consumer <code class="literal">tasks</code>.<div class="informalexample"><pre class="programlisting">var queue = new PriorityQueue&lt;QueuePriorityLevel, int&gt;();
var bc = new BlockingCollection&lt;KeyValuePair&lt;QueuePriorityLevel, int&gt;&gt;(queue);
var tasks = new List&lt;Task&gt;();</pre>
</div></li>
              <li class="listitem">Our <code class="literal">Console</code> application<a id="id420" class="indexterm"></a> has a producer task which will add items to the priority queue with a random priority level. The consumer task will remove items from the queue in priority order and write the results to <code class="literal">Console</code>. Let's start with the <code class="literal">producer</code> task.<div class="informalexample"><pre class="programlisting">var producer = Task.Factory.StartNew(() =&gt;
{
  Random r = new Random();
  int itemsToAdd = 50;
  int count = 0;
  for (int i = 0; i &lt; itemsToAdd; i++ )
  {
    Thread.SpinWait(10000);
    // Generate random priority level
    QueuePriorityLevel[] values = (QueuePriorityLevel[])Enum.GetValues(typeof(QueuePriorityLevel));
    var priority = values[new Random().Next(0, values.Length)];                    
    var item = new KeyValuePair&lt;QueuePriorityLevel, int&gt;(priority, count++);
    bc.Add(item);
    Console.WriteLine("added priority {0}, data={1}", priority, item.Value);
  }
  Console.WriteLine("Producer is finished.");
 }).ContinueWith( (antecedent)=&gt;
   {
     bc.CompleteAdding();
   });</pre>
</div></li>
              <li class="listitem">Right after <a id="id421" class="indexterm"></a>the <code class="literal">producer</code> task, make a call to <code class="literal">Thread.SpinWait</code> to make the main thread wait for<a id="id422" class="indexterm"></a> a bit before starting the <code class="literal">consumer</code> task.<div class="informalexample"><pre class="programlisting">Thread.SpinWait(100000);</pre>
</div></li>
              <li class="listitem">Now let's add the<a id="id423" class="indexterm"></a> <code class="literal">consumer</code> task which will pull items from the queue and display the results to the <code class="literal">Console</code> application.<div class="informalexample"><pre class="programlisting">var consumer = Task.Factory.StartNew(() =&gt;
{
  while (!bc.IsCompleted )
  {
     KeyValuePair&lt;QueuePriorityLevel, int&gt; item = new KeyValuePair&lt;QueuePriorityLevel, int&gt;();
    bool success = false;
    success = bc.TryTake(out item);
    if (success)
    {
    Console.WriteLine("removed Priority = {0} data = {1} Collection Count= {2}", item.Key, item.Value, bc.Count);
    }
    else
      Console.WriteLine("No items remaining. count = {0}", bc.Count);
  }
  Console.WriteLine("Exited consumer loop");
});</pre>
</div></li>
              <li class="listitem">Finish up by adding the <code class="literal">producer</code> and <code class="literal">consumer</code> tasks to the list of <code class="literal">tasks</code>. Wait on both tasks to complete by calling <code class="literal">Task.WaitAll</code> inside a <code class="literal">try</code>/<code class="literal">catch</code> block. In the<a id="id424" class="indexterm"></a> <code class="literal">catch</code> block, handle any <code class="literal">AggregateException</code> that may be thrown. Lastly, wait for user input before exiting.<div class="informalexample"><pre class="programlisting">tasks.Add(producer);
tasks.Add(consumer);

try
{
  Task.WaitAll(tasks.ToArray());
}

catch (AggregateException ae)
{
  foreach (var v in ae.InnerExceptions)
    Console.WriteLine(v.Message);
}

Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual <a id="id425" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following<a id="id426" class="indexterm"></a> screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_09.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec108"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>There were a lot of codes in <a id="id427" class="indexterm"></a>this recipe, but the key points of the implementation can be distilled to just a few <code class="literal">IProducerConsumerCollection</code> interface method implementations.</p>
          <p>
<code class="literal">IProducerConsumerCollection&lt;T&gt;</code> defines a handful of methods for manipulating thread safe collections for producer/consumer usage.</p>
          <p>To create our custom <a id="id428" class="indexterm"></a>collection <a id="id429" class="indexterm"></a>class, we just implemented the <code class="literal">IProducerConsumerCollection</code> interface on our custom <code class="literal">PriorityQueue</code> class and used some <code class="literal">ConcurrentQueue</code> fields as our backing stores.</p>
          <div class="informalexample">
            <pre class="programlisting">public class PriorityQueue&lt;PriorityLevel, TValue&gt;: 
    IProducerConsumerCollection&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;
{
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _lowPriotityQueue = null;
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _mediumPriotityQueue = null;
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _highPriotityQueue = null;
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;[] _queues = null;
  private int _count = 0;	
  ...  
}</pre>
          </div>
          <p>The actual implementation of the <a id="id430" class="indexterm"></a>
<code class="literal">IProducerConsumerCollection.TryAdd</code> method is pretty simple. We just determine the queue to place the item in by casting our <code class="literal">QueuePriorityLevel</code> <a id="id431" class="indexterm"></a>enumeration to an integer, then enqueue the item. We then do <code class="literal">Interlocked.Increment</code> on our count field. <code class="literal">Interlocked.Increment</code> does a thread safe increment of the count field.</p>
          <div class="informalexample">
            <pre class="programlisting">public bool TryAdd(KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  int priority = (int) item.Key;
  _queues[priority].Enqueue(item);
  Interlocked.Increment(ref _count);
  return true;
}</pre>
          </div>
          <p>
<code class="literal">TryTake</code> isn't much more complex. We just loop through our three private backing queues in order of priority and remove the first item we come to. <code class="literal">TryTake</code> returns a bool to indicate of it was successful in taking an item.</p>
          <div class="informalexample">
            <pre class="programlisting">public bool TryTake(out KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  bool success = false;

  for (int i = 0; i &lt;= 2; i++)
  {
    lock (_queues)
    {
      success = _queues[i].TryDequeue(out item);
      if (success)
      {
        Interlocked.Decrement(ref _count);
        return true;
      }
    }
  }
}</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using multiple concurrent collections to create a pipeline">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec59"></a>Using multiple concurrent collections to create a pipeline</h1>
            </div>
          </div>
        </div>
        <p>A pipeline is like an assembly line in a factory. With the pipeline pattern, data is processed in a sequential order where the output from the first stage becomes the input for the second stage and so on. <a id="id432" class="indexterm"></a>Pipelines use parallel tasks and concurrent queues to process a series of input values.</p>
        <p>In this recipe, we are<a id="id433" class="indexterm"></a> going to create a simple pipeline that creates a range of numbers, doubles the numbers in the range, and then writes the results to <code class="literal">Console</code>.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec109"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how to create a pipeline by using multiple concurrent collections.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Pipeline</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, let's add a <code class="literal">static</code> method to the <code class="literal">Program</code> class to create the range. This method needs a <code class="literal">BlockingCollection</code> parameter. It will simply add items to <code class="literal">BlockingCollection</code> in a loop.<div class="informalexample"><pre class="programlisting">static void CreateRange(BlockingCollection&lt;int&gt; result)
{
  try
  {
    for (int i = 1; i &lt; 10; i++)
    {
      result.Add(i);
      Console.WriteLine("Create Range {0}", i);
    }
  }
  finally
  {
    result.CompleteAdding();
  }
}</pre>
</div></li>
              <li class="listitem">Next, let's create a <code class="literal">static</code> method to square the range. This method will take two <code class="literal">BlockingCollection</code> parameters and will square each of the items in the source collection and place them in the result collection.<div class="informalexample"><pre class="programlisting">static void SquareTheRange(BlockingCollection&lt;int&gt; source, BlockingCollection&lt;int&gt; result)
{
  try
  {
    foreach (var value in source.GetConsumingEnumerable())
    {
      result.Add((int)(value * value));
    }
  }
  finally
  {
    result.CompleteAdding();
  }
}</pre>
</div></li>
              <li class="listitem">Now let's <a id="id434" class="indexterm"></a>create a <code class="literal">static</code> method to display the results. This method will take a <code class="literal">BlockingCollection</code> parameter<a id="id435" class="indexterm"></a> <a id="id436" class="indexterm"></a>and will loop through its items and write the values to the <code class="literal">Console</code> application.<div class="informalexample"><pre class="programlisting">{
  foreach (var value in input.GetConsumingEnumerable())
  {
    Console.WriteLine("The result is {0}", value);
  }
}</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, declare the two <code class="literal">BlockingCollection&lt;int&gt;</code> variables. These blocking collections will be the data buffers for the pipeline.<div class="informalexample"><pre class="programlisting">var bufferA = new BlockingCollection&lt;int&gt;(10);
var bufferB = new BlockingCollection&lt;int&gt;(10);</pre>
</div></li>
              <li class="listitem">Create and start three tasks to call each of our three methods passing in the <code class="literal">BlockingCollection</code> buffers required for each method.<div class="informalexample"><pre class="programlisting">var createStage = Task.Factory.StartNew(() =&gt; 
  {
    CreateRange(bufferA);
  },TaskCreationOptions.LongRunning);
var squareStage = Task.Factory.StartNew(() =&gt; 
  {
    SquareTheRange(bufferA, bufferB);
  },TaskCreationOptions.LongRunning );

var displayStage = Task.Factory.StartNew(() =&gt; 
  {
    DisplayResults(bufferB);
  },TaskCreationOptions.LongRunning);</pre>
</div></li>
              <li class="listitem">Finally, wait <a id="id437" class="indexterm"></a>for all three tasks to complete by calling <code class="literal">Task.WaitAll</code>. Wait for user input before exiting.<div class="informalexample"><pre class="programlisting">Task.WaitAll(createStage, squareStage, displayStage);
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, <a id="id438" class="indexterm"></a>press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_05_10.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch05lvl2sec110"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, we created a simple pipeline composed of three stages. Each stage reads from and/or writes to a particular buffer. If your machine has more available processor cores than there are stages in the pipeline, the stages can run in parallel. The concurrent queues used by <code class="literal">BlockingCollection</code> will buffer all shared inputs and outputs.</p>
          <p>Each stage in the pipeline can add items to its output buffer as long as there is room. If the buffer is full, the pipeline stage waits for space to become available before adding an item. The stages can <a id="id439" class="indexterm"></a>also wait on inputs from the previous stage.</p>
          <p>The stages that produce data use <code class="literal">BlockingCollection.CompleteAdding</code> to signal that they are finished adding data. This tells the consumer that it can end its processing loop after all previously added data has been removed or processed.</p>
        </div>
      </div>
    </div>
</body>
</html>