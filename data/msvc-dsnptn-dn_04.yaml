- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Asynchronous Communication between Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间的异步通信
- en: We have just reviewed synchronous communication between microservices and the
    pros and cons of that method. Now, we will take a look at its opposite counterpart,
    asynchronous communication.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚回顾了微服务之间的同步通信及其优缺点。现在，我们将看看它的对立面，异步通信。
- en: Synchronous communication is needed at times and, based on the operation being
    carried out, can be unavoidable. It does introduce potentially long wait times
    as well as potential break points in certain operations. At this point, it is
    important to properly assess the operation and decide whether immediate feedback
    from an additional service is required to continue. Asynchronous communication
    means that we send data to the next service but do not wait for a response. The
    user will be under the impression that the operation was completed, but the actual
    work is being done in the background.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要同步通信，根据正在执行的操作，这可能不可避免。它确实引入了可能的长等待时间以及某些操作中的潜在中断点。在这个时候，正确评估操作并决定是否需要来自附加服务的即时反馈以继续进行是很重要的。异步通信意味着我们向下一个服务发送数据，但不等待响应。用户会认为操作已经完成，但实际上工作是在后台进行的。
- en: From that review, it is obvious that this method of communication cannot always
    be used but is necessary to implement certain flows and operations efficiently
    in our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次回顾中可以明显看出，这种通信方法并不总是可以使用，但在我们的应用程序中高效地实现某些流程和操作是必要的。
- en: 'After reading this chapter, we will be able to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完这一章后，我们将能够做到以下几件事情：
- en: Understand what asynchronous communication is and when we should use it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解异步通信是什么以及我们应该何时使用它
- en: Implement Pub-Sub communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现发布-订阅通信
- en: Learn how to configure a message bus (**RabbitMQ** or **Azure Service Bus**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何配置消息总线（**RabbitMQ**或**Azure Service Bus**）
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at this URL: [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch04](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch04)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在项目仓库中找到，该仓库托管在GitHub上，网址为：[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch04](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch04)
- en: Functioning with asynchronous communication
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步通信
- en: Let us revisit some vital definitions and concepts before moving forward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，让我们回顾一些重要的定义和概念。
- en: 'There are basically two messaging patterns that we will employ between microservices:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在微服务之间基本上使用两种消息模式：
- en: '**Synchronous communication**: We covered this pattern in the previous chapter,
    where one service calls another directly and waits for a response'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步通信**：我们在上一章中介绍了这种模式，其中一个服务直接调用另一个服务并等待响应'
- en: '**Asynchronous communication**: In this pattern, we use messages to communicate
    without waiting for a response'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步通信**：在这种模式中，我们使用消息进行通信，而不需要等待响应'
- en: 'There are times when one microservice needs another to complete an operation,
    but at the moment, it doesn’t need to know the outcome of the task. Let us think
    of sending confirmation emails after an appointment has been successfully booked
    by our health care management system. Imagine the user waiting on the user interface
    to complete its loading operation and show the confirmation. In between them clicking
    **Submit** and seeing the confirmation, the booking service needs to complete
    the following operations:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个微服务需要另一个微服务来完成一个操作，但此时它不需要知道任务的结果。让我们考虑在我们的健康管理系统成功预订预约后发送确认电子邮件的情况。想象一下用户在用户界面上等待加载操作完成并显示确认信息。在他们点击**提交**并看到确认信息之间，预订服务需要完成以下操作：
- en: Create an appointment record
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建预约记录
- en: Send an email to the doctor booked for the appointment
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向预约了预约的医生发送电子邮件
- en: Send an email to the patient who booked the appointment
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向预约了预约的患者发送电子邮件
- en: Create a calendar entry for the system
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为系统创建日历条目
- en: 'Despite our best efforts, the booking service attempting to complete these
    operations will take some time and might lead to a less than pleasing user experience.
    We could also argue that the responsibility of sending emails should not be native
    to the booking service. In the same way, calendar management should stand on its
    own. So, we could refactor the booking service’s tasks as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尽了最大努力，尝试完成这些操作的预订服务将需要一些时间，可能会导致用户体验不佳。我们也可以争论发送邮件的责任不应是预订服务的固有功能。同样，日历管理也应独立存在。因此，我们可以将预订服务的任务重构如下：
- en: Create an appointment record
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建预约记录
- en: Synchronously call the email service to send an email to the doctor booked for
    the appointment
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步调用邮件服务向预约的医生发送邮件
- en: Synchronously call the email service to send an email to the patient who booked
    the appointment
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步调用邮件服务向预约的患者发送邮件
- en: Synchronously call the calendar management service to create a calendar entry
    for the system
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步调用日历管理服务为系统创建日历条目
- en: Now, we have refactored the booking service to do fewer operations and offload
    the intricacies of non-appointment booking operations to other services. This
    is a good refactor, but we have retained and potentially amplified the main flaw
    in this design. We are still going to wait on the completion of one potentially
    time-consuming operation before we move on to the next operation, which runs the
    same risk. At this point, we can consider how important waiting on a response
    to these actions really is, relative to us entering the booking record in our
    database, which is the most important operation relative to allowing the user
    to know the outcome of the booking process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经重构了预订服务，使其执行的操作更少，并将非预约预订操作的复杂性转移到其他服务上。这是一个好的重构，但我们保留了，甚至可能放大了这种设计的主要缺陷。我们仍然会在进行下一个操作之前等待一个可能耗时的操作完成，这同样存在风险。在这个时候，我们可以考虑等待这些操作响应的重要性，相对于我们在数据库中输入预订记录，这是最重要的操作，相对于让用户知道预订过程的结果。
- en: In this setting, we can make use of an asynchronous communication pattern to
    ensure that the major operation gets completed and other operations, such as sending
    an email and entering a calendar entry, can happen eventually, without compromising
    our user experience.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以利用异步通信模式来确保主要操作完成，其他操作，如发送邮件和输入日历条目，最终会发生，而不会影响我们的用户体验。
- en: At a very basic level, we can still implement asynchronous communication using
    HTTP patterns. Let us discuss how effective this can be.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常基本的情况下，我们仍然可以使用 HTTP 模式实现异步通信。让我们讨论这可以有多有效。
- en: HTTP asynchronous communication
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 异步通信
- en: In seeming contrast to what we have explored so far, we can actually implement
    asynchronous communication via HTTP. If we assess how HTTP communication works,
    we form an assessment of success or failure based on the HTTP response we receive.
    Synchronously, we would expect the booking service to call the email service and
    then wait on an HTTP `200 OK` successful response code before it tries to move
    to the next command. Synchronously, we would actually try to send the email at
    the moment, and based on the success or failure of that operation, we would form
    our response.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止所探讨的似乎形成对比，我们实际上可以通过 HTTP 实现异步通信。如果我们评估 HTTP 通信的工作方式，我们会根据收到的 HTTP 响应形成成功或失败的评估。同步地，我们预计预订服务会调用邮件服务，并在收到
    HTTP `200 OK` 成功响应代码之前尝试进行下一个命令。同步地，我们实际上会在那一刻尝试发送邮件，并根据该操作的成功或失败形成我们的响应。
- en: Asynchronously, we would let the email service respond with an HTTP `202 ACCEPTED`
    response, which indicates that the service has accepted the task and will carry
    it out eventually. This way, the booking service can continue its operation based
    on that promise and spend less time on the operation. In the background, the email
    service will carry out the task when it gets around to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 异步地，我们将让邮件服务响应 HTTP `202 ACCEPTED` 状态码，这表示服务已接受任务并最终执行。这样，预订服务可以基于这个承诺继续其操作，并减少操作时间。在后台，邮件服务将在适当的时候执行该任务。
- en: While this does alleviate some of the pressure that the booking service carries,
    there are other patterns, such as the Pub-Sub pattern, that can be implemented
    to make this process smoother. Let us review this pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实减轻了预订服务的一些压力，但还有其他模式，如 Pub-Sub 模式，可以实现以使此过程更顺畅。让我们回顾一下这个模式。
- en: Understanding Pub-Sub communication
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解发布-订阅通信
- en: The Pub-Sub pattern has gained a fair amount of popularity and acclaim and is
    widely used in distributed systems. *Pub* is short for *Publisher* and *Sub* is
    short for *Subscriber*. Essentially, this pattern revolves around publishing data,
    contextually called messages, to an intermediary messaging system, which can be
    described as resilient and reliable, and then having subscribing applications
    monitor this intermediary system. Once a message is detected, the subscribing
    application will conduct its processing as necessary.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅模式已经获得了相当多的流行度和赞誉，并且在分布式系统中被广泛使用。*Pub*代表*发布者*，而*Sub*代表*订阅者*。本质上，这种模式围绕将数据（在上下文中称为消息）发布到一个中介消息系统，该系统可以描述为具有弹性和可靠性，然后让订阅应用程序监控这个中介系统。一旦检测到消息，订阅应用程序将根据需要进行处理。
- en: Understanding message queues
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解消息队列
- en: Before we explore the Pub-Sub method, we need to understand the basics of messaging
    systems and how they work. The first model we will look at is called a *message
    queue*. A message queue is usually implemented as a bridge between two systems,
    a publisher and a consumer. When a publisher places messages in the queue, a consumer
    processes the information in the message as soon as it becomes available. Queues
    enforce a **first-in-first-out** (**FIFO**) delivery method, so the order of processing
    can always be guaranteed. This is usually implemented in a one-to-one communication
    scenario, so a specific queue is provisioned for each subscribing application.
    Payment systems tend to use this pattern heavily, where the actual sequence of
    submitted payments matters and they need to ensure the resilience of the instructions.
    If you think about it, payment systems generally have a very low failure rate.
    Most of the time when we submit a payment request, we can rest assured that it
    will be completed successfully at some point in the future.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索发布-订阅方法之前，我们需要了解消息系统的基本原理以及它们是如何工作的。我们将首先查看的模型被称为*消息队列*。消息队列通常被实现为两个系统之间的桥梁，即发布者和消费者。当发布者将消息放入队列时，消费者会尽快处理消息中的信息。队列强制执行**先进先出**（**FIFO**）的交付方法，因此处理顺序总是可以得到保证。这通常在点对点通信场景中实现，因此为每个订阅应用程序分配一个特定的队列。支付系统往往大量使用这种模式，其中提交支付的顺序很重要，并且它们需要确保指令的可靠性。如果你这么想，支付系统通常具有非常低的故障率。大多数时候，当我们提交支付请求时，我们可以放心，它将在未来的某个时刻成功完成。
- en: '*Figure 4.1* shows a publisher interacting with several message queues.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.1* 展示了一个发布者与几个消息队列的交互。'
- en: '![Figure 4.1 – Each message queue ensures that each application gets the exact
    data it needs and nothing more](img/Figure_4.1_B19100.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 每个消息队列确保每个应用程序获得所需的确切数据，而不多余任何数据](img/Figure_4.1_B19100.jpg)'
- en: Figure 4.1 – Each message queue ensures that each application gets the exact
    data it needs and nothing more
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 每个消息队列确保每个应用程序获得所需的确切数据，而不多余任何数据
- en: The unfortunate thing here is that one bad message can spell trouble for the
    other messages waiting in the queue, and so we have to consider this potential
    downside. We also have to consider that we have our first chink in the armor.
    Messages are also discarded after they are read, so special provisions need to
    be made for messages that were not processed successfully.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不幸的是，一个坏消息可能会给队列中等待的其他消息带来麻烦，因此我们必须考虑这个潜在的缺点。我们还得考虑我们 armor 上的第一个漏洞。消息在读取后也会被丢弃，因此需要对未成功处理的消息做出特殊安排。
- en: While message queues do have their uses and bring a certain level of reliability
    to our system design, in a distributed system, they can be a bit inefficient and
    introduce some cons that we might not be prepared to live with. In that event,
    we turn our attention to a more distributed messaging setup such as a message
    bus. We will discuss this next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然消息队列确实有其用途，并为我们的系统设计带来了一定程度的可靠性，但在分布式系统中，它们可能有点低效，并引入一些我们可能不愿意接受的缺点。在这种情况下，我们将注意力转向更分布式的中介消息设置，例如消息总线。我们将在下一节讨论这一点。
- en: Understanding message bus systems
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解消息总线系统
- en: A *message bus*, *event bus*, or *service bus* provides interfaces, where one
    published message can be processed by multiple or competing subscribers. This
    is advantageous in scenarios where we need to publish the same data to multiple
    applications or services. This way, we do not need to connect to multiple queues
    to send a message, but we can have one connection, complete one *send* action,
    and not worry about the rest.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息总线*、*事件总线*或*服务总线*提供接口，其中一条发布的消息可以被多个或竞争的订阅者处理。在需要将相同的数据发布到多个应用程序或服务的情况下，这很有优势。这样，我们不需要连接到多个队列来发送消息，而只需有一个连接，完成一个*发送*操作，就不必担心其他事情。'
- en: '*Figure 4.2* shows a publisher interacting with a message, which has several
    consumers.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.2*显示了一个发布者与消息的交互，该消息有多个消费者。'
- en: '![Figure 4.2 – This message bus has several consumers or subscribers listening
    for messages](img/Figure_4.2_B19100.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 此消息总线有多个消费者或订阅者正在监听消息](img/Figure_4.2_B19100.jpg)'
- en: Figure 4.2 – This message bus has several consumers or subscribers listening
    for messages
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 此消息总线有多个消费者或订阅者正在监听消息
- en: Going back to our scenario where booking an appointment has several operational
    concerns, we can use a message bus to distribute data to the relevant services
    and allow them to complete their operations in their own time. Instead of making
    direct calls to the other APIs, our appointment booking API will create a message
    and place it on the message bus. The email and calendar services are subscribed
    to the message bus and process the message accordingly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的场景，在预约时存在多个操作问题，我们可以使用消息总线将数据分发到相关服务，并允许它们在自己的时间完成操作。而不是直接调用其他API，我们的预约API将创建一个消息并将其放置在消息总线上。电子邮件和日历服务订阅了消息总线，并相应地处理消息。
- en: This pattern has several advantages where decoupling and application scalability
    are concerned. This aids in making the microservices even more independent from
    each other and reduces limitations associated with adding more services in the
    future. It also adds stability to the overall interactions of our services, since
    the message bus acts as a storage intermediary for the data needed to complete
    an operation. If a consuming service is unavailable, the message will be retained,
    and the pending messages will be processed once normalcy is restored. If all services
    are running and messages are backing up, then we can scale the number of instances
    of the services to reduce the message backlog more quickly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在解耦和应用程序可伸缩性方面，这种模式有几个优点。这有助于使微服务之间更加独立，并减少未来添加更多服务时的限制。它还增加了我们服务整体交互的稳定性，因为消息总线充当完成操作所需数据的存储中介。如果一个消费服务不可用，消息将被保留，一旦恢复正常，挂起的消息将被处理。如果所有服务都在运行且消息正在积压，那么我们可以扩展服务的实例数量，以更快地减少消息积压。
- en: There are several types of messages that you may encounter, but we will focus
    on two for this chapter. They are **command** and **event** messages. Command
    messages essentially request some action is performed. So, our message to the
    calendar services sends an instruction for a calendar entry to be created. Given
    the nature of these commands, we can take advantage of this asynchronous pattern
    and have the messages get picked up eventually. That way, even large numbers of
    messages will be processed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到几种不同类型的消息，但我们将专注于本章中的两种。它们是**命令**和**事件**消息。命令消息本质上请求执行某些操作。因此，我们发送给日历服务的消息会指示创建一个日历条目。鉴于这些命令的性质，我们可以利用这种异步模式，并最终处理这些消息。这样，即使大量消息也会被处理。
- en: Event messages simply announce that some action took place. Since these messages
    are generated after an action, they are worded in the past tense and can be sent
    to several microservices. In this case, the message to the email service can be
    seen as an event and our email service will relay that information accordingly.
    This type of message generally has just enough information to let the consuming
    services know what action was completed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事件消息只是宣布某些操作已经发生。由于这些消息是在操作之后生成的，它们使用的是过去时态，并且可以发送到多个微服务。在这种情况下，发送给电子邮件服务的消息可以被视为一个事件，我们的电子邮件服务将相应地传递该信息。这种类型的信息通常只包含足够的信息，让消费服务知道哪些操作已完成。
- en: Command messages are generally aimed at microservices that need to post or modify
    data. Until a message is consumed and actioned, the expected data will not be
    available for some amount of time. This is one of the key downsides to the asynchronous
    messaging model, and it is termed **eventual consistency**. We need to explore
    this in more detail and discover the best approaches to take.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 命令消息通常针对需要发布或修改数据的微服务。直到消息被消费并采取行动，预期的数据将无法在一段时间内可用。这是异步消息模型的一个主要缺点，被称为**最终一致性**。我们需要更深入地探讨这一点，并发现最佳采取的方法。
- en: Understanding eventual consistency
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解最终一致性
- en: One of the biggest challenges we face in microservices design is data management
    and developing a strategy for keeping data in sync, which sometimes means that
    we need to have multiple copies of the same data in several microservice databases.
    **Eventual consistency** is a notion in distributed computing systems that accepts
    that data will be out of sync for a period of time. This type of constraint is
    only acceptable in distributed systems and fault-tolerant applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务设计中我们面临的最大挑战之一是数据管理和制定保持数据同步的策略，这有时意味着我们需要在几个微服务数据库中保留相同数据的多个副本。**最终一致性**是分布式计算系统中的一个概念，它接受数据将在一段时间内不同步。这种约束仅在分布式系统和容错应用程序中是可接受的。
- en: It is easy enough to manage one dataset in one database, as is the case with
    a monolithic application, since data will always be up to date for any other part
    of the application to be able to access. A single database approach to our application
    gives us the guarantee of ACID transactions, which we discussed earlier, but we
    still are met with the challenge of **concurrency** management. Concurrency refers
    to the fact that we might have multiple versions of the same data available at
    different points. This challenge is easier to manage in a single database application
    but presents a unique challenge in a distributed system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一数据库中管理一个数据集是很容易的，就像单体应用程序一样，因为数据将始终是最新的，以便其他应用程序的部分能够访问。我们的应用程序采用单一数据库方法为我们提供了我们之前讨论过的ACID事务的保证，但我们仍然面临着**并发性**管理的挑战。并发性指的是我们可能在不同的时间点有相同数据的多个版本。在单一数据库应用程序中，这个挑战更容易管理，但在分布式系统中，它提出了独特的挑战。
- en: 'It is a reasonable assumption that when data changes in one microservice, data
    will change in another and lead to some inconsistency between the data stores
    for a period. The **CAP theorem** introduces the notion that we cannot guarantee
    all three of the main attributes of a distributed system: **consistency**, **availability**,
    and **partition tolerance**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据在一个微服务中发生变化时，数据将在另一个微服务中发生变化，并在一段时间内导致数据存储之间出现一些不一致。**CAP定理**引入了这样一个概念，即我们无法保证分布式系统的三个主要属性：**一致性**、**可用性**和**分区容错性**：
- en: '**Consistency**: This means that every read operation against a data store
    will yield the current and most up-to-date version of the data, or an error will
    be raised if the system cannot guarantee that it is the latest.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这意味着对数据存储的每次读取操作都将返回数据的当前最新版本，或者如果系统无法保证这是最新版本，则会引发错误。'
- en: '**Availability**: This means that data will always be returned for a read operation,
    even if this is not the latest guaranteed version.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这意味着对于读取操作，数据总是会返回，即使这不是最新保证的版本。'
- en: '**Partition tolerance**: This means that systems will operate even when there
    might be transient errors that would stop a system under normal circumstances.
    Imagine we have minor connectivity issues between our services and/or messaging
    systems. Data updates will be delayed, but this principle will suggest that we
    need to choose between **availability** and **consistency**.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容错性**：这意味着即使存在可能导致系统在正常情况下停止的短暂错误，系统也会继续运行。想象一下，我们服务之间或/和消息系统之间存在轻微的连接问题。数据更新将被延迟，但这个原则将建议我们需要在**可用性**和**一致性**之间做出选择。'
- en: Choosing consistency or availability is a very important decision moving forward.
    Given that microservices need to be generally always available, we must be careful
    with our decision and how strictly we impose our constraints around a system’s
    consistency policy – eventual or strong.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一致性或可用性是一个非常重要的决定。鉴于微服务通常需要始终可用，我们必须谨慎地做出决定，以及如何严格地在我们对系统一致性策略（最终一致性或强一致性）的约束上。
- en: There are scenarios where strong consistency is not required, since all the
    work that was performed by an operation is completed or rolled back. These updates
    are either lost (if rolled back) or will propagate to the other microservices
    in their own time, without having any detrimental effects on the overall operations
    of the application. If this model is selected, we can gauge our user experience
    through sensitization and letting them know that updates are not always immediate
    across the different screens and modules.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景中不需要强一致性，因为操作执行的所有工作要么已经完成，要么已回滚。这些更新要么丢失（如果已回滚），要么将在自己的时间内传播到其他微服务，而不会对应用程序的整体操作产生任何不利影响。如果选择这种模式，我们可以通过敏感化和让他们知道更新并不总是立即出现在不同的屏幕和模块中来衡量用户体验。
- en: Using the Pub-Sub model is the number one way to implement this kind of event-driven
    communication between services, where they all communicate via a messaging bus.
    With the completion of each operation, each microservice will publish an event
    message to the message bus, and other services will pick this up and process it
    eventually.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pub-Sub 模型是实现这种服务之间事件驱动通信的第一种方式，其中它们都通过消息总线进行通信。每个操作的完成，每个微服务都会向消息总线发布一个事件消息，其他服务最终会接收到并处理它。
- en: To implement eventual consistency, we usually use event-driven communication
    using a publish-subscribe model. When data is updated in one microservice, you
    can publish a message to a central messaging bus, and other microservices that
    have copies of the data can receive a notification by subscribing to the bus.
    Because the calls are asynchronous, the individual microservices can continue
    to serve requests using the copy of the data that they already have, and the system
    needs to tolerate that while it might not be consistent right away, meaning that
    the data may not all be in sync immediately, eventually it will be consistent
    across the microservices. Of course, implementing eventual consistency can be
    more complex than just firing and forgetting messages to a message bus. Later
    in this book, we’ll look at ways we can mitigate the risks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现最终一致性，我们通常使用基于事件的发布-订阅模型进行通信。当数据在一个微服务中更新时，你可以向中央消息总线发布一条消息，其他拥有数据副本的微服务可以通过订阅总线接收通知。因为调用是异步的，单个微服务可以继续使用它们已有的数据副本来服务请求，而系统需要容忍这种情况，即使数据可能一开始并不一致，这意味着数据可能不会立即同步，最终将在微服务之间保持一致。当然，实现最终一致性可能比仅仅向消息总线发送消息要复杂得多。在本书的后面部分，我们将探讨如何减轻风险的方法。
- en: Until now, we have explored the concepts of using event-driven or Pub-Sub patterns
    to facilitate asynchronous communication. All of these concepts have been based
    on the idea that we have a messaging system persisting and distributing messages
    between services and operations. Now, we need to explore some of our options in
    the forms of RabbitMQ and Azure Service Bus.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了使用事件驱动或 Pub-Sub 模式来促进异步通信的概念。所有这些概念都基于这样一个想法，即我们有一个消息系统在服务之间和操作之间持久化和分发消息。现在，我们需要探索一些选项，例如
    RabbitMQ 和 Azure Service Bus。
- en: Configuring a message bus (RabbitMQ or Azure Service Bus)
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置消息总线（RabbitMQ 或 Azure Service Bus）
- en: After waxing poetic about messaging buses and queues, we can finally discuss
    two excellent options for facilitating message-based service communication. They
    are **RabbitMQ** and **Azure Service Bus**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在对消息总线和队列进行了一番诗意般的描述之后，我们终于可以讨论两个促进基于消息的服务通信的优秀选项了。它们是 **RabbitMQ** 和 **Azure
    Service Bus**。
- en: These are by no means the only options, nor are they the best, but they are
    popular and can get the job done. Alternatives that you may encounter include
    **Apache Kafka**, which is famed for its high performance and low latency, or
    **Redis Cache**, which can double as a simple key-value caching store but also
    as a message broker. Ultimately, the tool you use is relative to what you need
    and what the tool offers your context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝对不是唯一的选择，也不是最佳选择，但它们很受欢迎，并且可以完成任务。你可能遇到的替代方案包括 **Apache Kafka**，以其高性能和低延迟而闻名，或者
    **Redis Cache**，它可以作为简单的键值缓存存储，也可以作为消息代理。最终，你使用的工具取决于你的需求以及工具为你提供的上下文。
- en: Let us explore how we can integrate with RabbitMQ in a .NET Core application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在 .NET Core 应用程序中与 RabbitMQ 集成。
- en: Implementing RabbitMQ in an ASP.NET Core web API
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core Web API 中实现 RabbitMQ
- en: RabbitMQ is the most deployed and used open source message broker, at least
    at the time of writing. It supports multiple operating systems, has a ready-to-go
    container image, and is a reliable intermediary messaging system that is supported
    by several programming languages. It also provides a management UI that allows
    us to review messages and overall system performance as part of monitoring measures.
    If you plan to deploy a messaging system on-premises, then RabbitMQ is an excellent
    option.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是最广泛部署和使用的开源消息代理，至少在撰写本文时是这样。它支持多个操作系统，有一个现成的容器镜像，并且是一个由多种编程语言支持的可靠的中介消息系统。它还提供了一个管理界面，允许我们作为监控措施的一部分审查消息和整体系统性能。如果您计划在本地部署消息系统，那么
    RabbitMQ 是一个很好的选择。
- en: RabbitMQ supports sending messages in two main ways – **queues** and **exchanges**.
    We already have an appreciation for what queues are, and exchanges support the
    message bus paradigm.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 支持两种主要方式发送消息——**队列**和**交换机**。我们已经了解了队列是什么，而交换机支持消息总线模式。
- en: 'Let us take a look at what it takes to configure RabbitMQ on a Windows computer
    and what supporting C# code is needed to publish and consume. Let us start by
    including the `MassTransit.RabbitMQ` RabbitMQ package via NuGet. In our `Program.cs`
    file, we need to ensure that we configure `MassTransit` to use RabbitMQ by adding
    the following lines:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 Windows 计算机上配置 RabbitMQ 以及发布和消费所需的支撑 C# 代码。让我们首先通过 NuGet 包含 `MassTransit.RabbitMQ`
    RabbitMQ 包。在我们的 `Program.cs` 文件中，我们需要确保配置 `MassTransit` 使用 RabbitMQ，并添加以下行：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This creates an injectable service that can be accessed in any other part of
    our code. We need to inject `IPublishEndpoint` into our code, and this will allow
    us to submit a message to the RabbitMQ exchange:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个可注入的服务，可以在我们代码的任何其他部分访问。我们需要将 `IPublishEndpoint` 注入到我们的代码中，这将允许我们向 RabbitMQ
    交换机提交消息：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After creating an appointment record, we can share the record’s details on
    the exchange. The different subscribers will pick up this message and process
    what they need. Consumers are generally created as windows or background worker
    services that are always on and running. The following example shows how a consumer’s
    code might look:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建预约记录后，我们可以在交换机上共享记录的详细信息。不同的订阅者将接收到这条消息并处理他们所需的内容。消费者通常被创建为始终开启并运行的服务或后台工作服务。以下示例展示了消费者代码可能的样子：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our consumers will be able to receive any message of the `AppointmentMessage`
    type and use the information as they need to. Note that the data type for the
    message exchange is consistent between the producer and the consumer. So, it would
    be prudent of us to have a `CommonModels` project that sits in between and serves
    up these common data types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消费者将能够接收任何 `AppointmentMessage` 类型的消息，并按需使用这些信息。请注意，消息交换的数据类型在生产者和消费者之间是一致的。因此，我们最好有一个位于中间的
    `CommonModels` 项目，提供这些公共数据类型。
- en: 'If we implement this consumer in a console application, then we need to register
    a `appointment-created-event`. To create a console application that will listen
    until we terminate the instance, we need code that looks like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在控制台应用程序中实现此消费者，那么我们需要注册一个 `appointment-created-event`。要创建一个控制台应用程序，该程序将监听直到我们终止实例，我们需要如下代码：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have seen in a nutshell what it takes to communicate with a RabbitMQ
    exchange, let us review what is needed to communicate with the cloud-based Azure
    Service Bus.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经简要地了解了与 RabbitMQ 交换机通信所需的内容，让我们回顾一下与基于云的 Azure Service Bus 通信所需的内容。
- en: Implementing Azure Service Bus in an ASP.NET Core API
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core API 中实现 Azure Service Bus
- en: 'Azure Service Bus is an excellent choice for cloud-based microservices. It
    is a fully managed enterprise message broker that supports queues as well as Pub-Sub
    topics. Given Microsoft Azure’s robust availability guarantees, this service supports
    load balancing, and we can be assured of secure and coordinated message transfers
    if we choose this option. Similar to RabbitMQ, Azure Service Bus has support for
    **queues** and **topics**. Topics are the direct equivalent of **exchanges**,
    where we can have multiple services subscribed and waiting on new messages. Let
    us reuse the concept we just explored with RabbitMQ and review the code needed
    to publish a message on a topic and see what consumers would look like. We are
    going to focus on the code in this section and assume that you have already created
    the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Service Bus 是云基础微服务的绝佳选择。它是一个完全托管的面向企业的消息代理，支持队列以及 Pub-Sub 主题。鉴于 Microsoft
    Azure 强大的可用性保证，此服务支持负载均衡，如果我们选择此选项，我们可以确保消息传输的安全和协调。与 RabbitMQ 类似，Azure Service
    Bus 支持队列和主题。主题是交换的直接等价物，我们可以有多个服务订阅并等待新消息。让我们重用我们刚刚在 RabbitMQ 中探讨的概念，并回顾发布主题上消息所需的代码，看看消费者会是什么样子。我们将专注于本节中的代码，并假设您已经创建了以下内容：
- en: An Azure Service Bus resource
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure Service Bus 资源
- en: An Azure Service Bus topic
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure Service Bus 主题
- en: An Azure Service Bus subscription to the topic
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个订阅 Azure Service Bus 主题的 Azure Service Bus 订阅
- en: These elements all need to exist, and we will retrieve a connection string to
    Azure Service Bus through the Azure portal. To get started with the code, add
    the `Azure.Messaging.ServiceBus` NuGet package to the producer and consumer projects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素都必须存在，我们将通过 Azure 门户检索 Azure Service Bus 的连接字符串。要开始编写代码，请将 `Azure.Messaging.ServiceBus`
    NuGet 包添加到生产者和消费者项目中。
- en: 'In our publisher, we can create a service wrapper that can be injected into
    parts of the code that will publish messages. We will have something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的发布者中，我们可以创建一个服务包装器，它可以注入到将发布消息的代码部分。我们将有类似以下的内容：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, we declare an interface, `IMessagePublisher.cs`, and implement
    it through `MessagePublisher.cs`. When a message comes in, we create `ServiceBusMessage`
    and submit it to the specified topic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们声明了一个接口，`IMessagePublisher.cs`，并通过 `MessagePublisher.cs` 实现它。当收到消息时，我们创建
    `ServiceBusMessage` 并将其提交到指定的主题。
- en: 'We need to ensure that we register this service so that it can be injected
    into other parts of our code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们注册此服务，以便它可以注入到我们代码的其他部分：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let us look at the same controller and how it would publish a message
    to Azure Service Bus instead of RabbitMQ:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看同一个控制器，以及它是如何将消息发布到 Azure Service Bus 而不是 RabbitMQ 的：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we know how we can set up the publisher code, let us review what we
    need for a consumer. This code could be used by a background worker or Windows
    service to continuously monitor for new messages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何设置发布者代码，让我们回顾消费者所需的元素。此代码可用于后台工作者或 Windows 服务以持续监视新消息：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We start with defining an interface that outlines `Start` and `Stop` methods.
    This interface will be implemented by a consumer service class, which will connect
    to Azure Service Bus and begin executing code that listens to Service Bus for
    new messages and consumes them accordingly:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义一个接口开始，该接口概述了 `Start` 和 `Stop` 方法。这个接口将由一个消费者服务类实现，该类将连接到 Azure Service
    Bus 并开始执行监听 Service Bus 新消息并相应消费它们的代码：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From these two examples of how we interact with message bus systems, we can
    see that they are conceptually very similar. Similar considerations and techniques
    would be employed for any of the other message bus systems supported by .NET Core
    libraries.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们与消息总线系统交互的两个示例中，我们可以看到它们在概念上非常相似。对于 .NET Core 库支持的任何其他消息总线系统，都会采用类似的考虑和技巧。
- en: Surely, there are trade-offs when we implement this type of message-based communication.
    We now have an additional system and potential point of failure, so we must consider
    the additional infrastructural requirements. We also see that the code required
    adds more complexity to our code base. Let us dive into some of the disadvantages
    of this approach.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们实现这种基于消息的通信时，肯定会有权衡。我们现在有一个额外的系统，以及潜在的故障点，因此我们必须考虑额外的基础设施需求。我们还看到，所需的代码增加了我们的代码库的复杂性。让我们深入了解这种方法的一些缺点。
- en: Disadvantages of asynchronous communication between microservices
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间异步通信的缺点
- en: As with any system or programming method, there are always advantages and disadvantages
    that come with the territory. We have already explored why having an asynchronous
    messaging pattern is a good idea for operations that might be long-running. We
    need to ensure that the end user doesn’t spend too much time waiting on an entire
    operation to be completed. Messaging systems are an excellent way to shorten the
    perceived time it takes to complete an operation and allows services to operate
    as efficiently as possible on their own. They also aid in decoupling systems,
    allowing for greater scalability and introducing a certain level of stability
    to a system where data transfer and processing are concerned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何系统或编程方法一样，总有优势和劣势伴随着它。我们已经探讨了为什么对于可能运行时间较长的操作来说，拥有异步消息模式是一个好主意。我们需要确保最终用户不会花费太多时间等待整个操作完成。消息系统是缩短完成操作感知时间的一种极好方式，并允许服务尽可能高效地独立运行。它们还帮助解耦系统，允许更大的可扩展性，并在数据传输和处理方面为系统引入一定程度的稳定性。
- en: Now, disadvantages creep in when we analyze the real level of complexity that
    this pattern can introduce. Far more coordination needs to be considered when
    designing how our services interact with others, what data they need to share,
    and what events need to be posted when operations are completed. In the synchronous
    model, we will be more sure of tasks getting completed down the line, since we
    cannot move forward without a favorable response from the next service along the
    chain. In the asynchronous model using queues and buses, we have to rely on the
    consuming service(s) posting an event regarding the state of completion. We also
    have to ensure that there are no repeated calls and, in some cases, need to make
    a concerted effort to ensure that messages are processed in a specific order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们分析这种模式可能引入的实际复杂程度时，缺点就会逐渐显现。在设计我们的服务如何与其他服务交互、需要共享哪些数据以及操作完成后需要发布哪些事件时，需要考虑更多的协调。在同步模型中，我们将更有信心确保后续任务能够完成，因为我们不能在没有下一个服务链中服务有利的响应的情况下前进。在异步模型中使用队列和总线时，我们必须依赖消费服务（或服务）发布关于完成状态的事件。我们还需要确保没有重复的调用，在某些情况下，需要共同努力确保消息按特定顺序处理。
- en: This brings us to another disadvantage in the form of data consistency. Remember
    that the initial response from the message bus suggests that the operation is
    successful, but this just means that data was successfully submitted to the bus.
    After this, our consuming services still need to follow through and complete their
    operations. If one or more of these services fails to process and potentially
    submits the data to a data store, then we'll end up with inconsistency in our
    data. This is something to be mindful of, as it can lead to detrimental side effects
    and user attrition.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这又引出了另一个缺点，即数据一致性。记住，消息总线最初的响应表明操作是成功的，但这仅仅意味着数据已成功提交到总线。在此之后，我们的消费服务仍然需要继续并完成它们的操作。如果其中一项或多项服务未能处理并可能将数据提交到数据存储，那么我们的数据将出现不一致。这是我们需要注意的事情，因为它可能导致有害的副作用和用户流失。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a few things. We did a blow-by-blow comparison
    of how a process would be handled through synchronous API communication versus
    asynchronous communication. We then expanded our general knowledge of how messaging
    systems can be leveraged to support an asynchronous communication model for our
    services. In all of this, we discussed challenges that we can face with data consistency
    between operations and how we can gauge acceptable metrics for this unavoidable
    factor. In the latter parts, we reviewed two popular messaging systems and then
    discussed some of the outright disadvantages that we have to contend with in this
    paradigm.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了一些内容。我们详细比较了通过同步API通信与异步通信处理流程的方式。然后，我们扩展了我们关于如何利用消息系统来支持我们服务的异步通信模型的一般知识。在这个过程中，我们讨论了在操作之间可能面临的数据一致性挑战，以及我们如何衡量这个不可避免因素的可接受指标。在后面的部分，我们回顾了两种流行的消息系统，并讨论了在这个范式下我们必须应对的一些明显缺点。
- en: In our next chapter, we will explore the **Command-Query Responsibility Segregation**
    (**CQRS**) pattern and how it helps us to write cleaner code in our services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**命令-查询责任分离**（**CQRS**）模式以及它如何帮助我们编写更干净的服务代码。
