<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>5. Producing Tabular Reports</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;5.&#160;Producing Tabular Reports">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05"></a>Chapter&#160;5.&#160;Producing Tabular Reports</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will create a library that will help application developers to create tabular reports using a custom <span class="strong"><strong>Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>), created for this purpose. The tree-structured document object model will be traversed to produce output in the AdobeÂ® <span class="strong"><strong>Portable Document Format</strong></span> (<span class="strong"><strong>PDF</strong></span>) and HTML format. Support for new target formats would be seamless, with developers writing handlers for those. For PDF output, we plan to use the open source <span class="strong"><strong>iTextSharp</strong></span> library. During the course of this chapter, as a reader, you will learn the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Defining an object model for documents</li>
            <li class="listitem" style="list-style-type: disc">The composite pattern for modeling part/whole relationship</li>
            <li class="listitem" style="list-style-type: disc">Producing PDF documents by leveraging the iTextSharp library</li>
            <li class="listitem" style="list-style-type: disc">The visitor pattern and composite object traversal</li>
          </ul>
        </div>
        <div class="section" title="Requirements for the library">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch05lvl1sec29"></a>Requirements for the library</h1>
              </div>
            </div>
          </div>
          <p>Before we embark on writing the library, let us scribble down a preliminary requirements statement as follows:</p>
          <p>For a large class of business applications, we require tabular reports in various formats. The popular choice for output formats are PDF, HTML, SVG, and so on. We should create a library to produce tabular output in these formats. The library should define a unified programming model, and serve as an API for the developers. The contents of the documents and its tables should be separated from the processing layer to incorporate future output drivers.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Solutions approach">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec30"></a>Solutions approach</h1>
            </div>
          </div>
        </div>
        <p>Before writing the code, let us step back a bit to enumerate the details of the requirements. The library which we are planning to write should have the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Support for various output formats like HTML, PDF, and so on</li>
            <li class="listitem" style="list-style-type: disc">An object model for storing the contents of the table</li>
            <li class="listitem" style="list-style-type: disc">A unified programming model and API for developers</li>
            <li class="listitem" style="list-style-type: disc">Separate content and it's processing</li>
            <li class="listitem" style="list-style-type: disc">The ability to write new pluggable output processors (drivers)</li>
          </ul>
        </div>
        <p>We will start by creating a hierarchy of elements for storing document contents. A simple hierarchy which has been conceived is as follows:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_05_02.jpg" alt="Solutions approach"/>
        </div>
        <p>
</p>
        <p>We will encode our content in a tree-structured document model. For the sake of simplicity, we have reduced the number of document elements. In an industrial strength implementation of this library, we will have many more elements. We can create tables within tables in this scheme, as we allow nested tables. Before we get into the implementation of the aforementioned hierarchy, we will look into the specifics of the creation of a PDF document using an open source library.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="iTextSharp for the PDF output">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec31"></a>iTextSharp for the PDF output</h1>
            </div>
          </div>
        </div>
        <p>To produce the output of a document in the PDF format, we plan to use the .NET version of the open source iText library.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note23"></a>Note</h3>
            <p>The library can be downloaded from the iTextSharp website at the following address:&#160;<a class="ulink" href="https://www.nuget.org/packages/iTextSharp/">https://www.nuget.org/packages/iTextSharp/</a>.</p>
          </div>
        </div>
        <p>A simple program, which produces a PDF document using the library, is given next to make the reader understand the programming model of this library:</p>
        <pre class="programlisting">    using iTextSharp; 
    using iTextSharp.text; 
    using iTextSharp.text.pdf; 
    //------some code omitted 
    FileStream fs = new FileStream(@"D:\ab\fund.pdf",   
    FileMode.Create); 
    Document document = new Document(PageSize.A4, 25, 25, 30, 30); 
    PdfWriter writer = PdfWriter.GetInstance(document, fs); 
    document.AddAuthor("Praseed Pai"); 
    document.AddCreator("iTextSharp PDF Library"); 
    document.AddTitle("PDF Demo"); 
    document.Open(); 
    PdfPTable table = new PdfPTable(2); 
    PdfPCell cell = new PdfPCell(new Phrase("A Header which spans    
    Columns")); 
    cell.Colspan = 3; 
    cell.HorizontalAlignment = 1;  
    table.AddCell(cell); 
    table.AddCell("Col 1 Row 1"); 
    table.AddCell("Col 2 Row 1"); 
    table.AddCell("Col 3 Row 1"); 
    table.AddCell("Col 1 Row 2"); 
    table.AddCell("Col 2 Row 2"); 
    table.AddCell("Col 3 Row 2"); 
    document.Add(table); 
    document.Close(); 
    writer.Close(); 
    fs.Close(); 
</pre>
        <p>The preceding code will produce a PDF document with the contents given to the iTextsharp library through the iTextSharp API. Now we will focus on the creation of a DOM for storing our contents.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Composite and visitor pattern - A quick primer">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec32"></a>Composite and visitor pattern - A quick primer</h1>
            </div>
          </div>
        </div>
        <p>Whenever we deal with hierarchies like W3C DOM, document formats, graphics database or <span class="strong"><strong>abstract syntax tree</strong></span> (<span class="strong"><strong>AST</strong></span>) of a compiler, we create part/whole relationship. The GoF composite pattern is natural choice for creating hierarchies. Building hierarchies and its processing can be separated using GoF visitor pattern. The visitor pattern visits each node in the hierarchy and perform some action on the node. In a compiler, the tree representation of a program will be processed for type checking, code generation, trans compilation (source to source transformation) and so on. Sometimes people would like to perform additional activities on the tree. It is not feasible to add methods for processing the nodes within a node. Whenever a programmer wants a new method, we are forced to change every node in the hierarchy. A mechanism is necessary for processing to be decoupled from the nodes in a hierarchy. When we use visitor pattern, the nodes within the hierarchy becomes a container for data alone. We will write an expression composite to model a four function calculator to demonstrate the composite and visitor:</p>
        <pre class="programlisting">    public enum OPERATOR 
    { 
      //--- supports +,-,*/ 
      PLUS,MINUS,MUL,DIV 
    } 
    /// &lt;summary&gt; 
    /// Base class for all Expression 
    /// supports accept method to implement  
    /// so called "Double Dispatch". Search for  
    /// "Double Dispatch" and Visitor to understand more  
    /// about this strategy 
    /// &lt;/summary&gt; 
    public abstract class Expr 
    { 
      //------ Whenever we start traversal, we will start from  
      //------ the topmost node of a hierarchy and  
      //-------descends down the heirarchy 
      //------ The Visitor will call the accept method of a node 
      //------ and node will reflect it back to concrete class 
      //------ using Visit method. Thus Visitor dispatches the  
      //------ call to a node and node dispatches it back to the 
      //-------visit method of the Visitor. This is called a 
      //------ a double dispatch 
      public abstract double accept(IExprVisitor expr_vis); 
    } 
</pre>
        <p>The hierarchy for an expression is</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">Expr</code>
              <div class="itemizedlist">
                <ul class="itemizedlist">
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">Number</code>
                  </li>
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">BinaryExpr</code>
                  </li>
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">UnaryExpr</code>
                  </li>
                </ul>
              </div>
            </li>
          </ul>
        </div>
        <pre class="programlisting">    /// &lt;summary&gt; 
    ///  Our Visitor Interface. The Purpose of seperating Processing 
    ///  Of Nodes and Data Storage (heirarchy) is for various  
    ///  transformations on the composites created. 
    /// &lt;/summary&gt; 
    public interface IExprVisitor 
    { 
      double Visit(Number num); 
      double Visit(BinaryExpr bin); 
      double Visit(UnaryExpr un); 
    } 
</pre>
        <p>The following class will store an IEEE 754 double precision floating point value. Our evaluator will handle only constants, as an expression evaluator which supports variables will take additional effort and won't serve our primary purpose of demonstrating the composite and visitor pattern:</p>
        <pre class="programlisting">    /// &lt;summary&gt; 
    ///  Class Number stores a IEEE 754 doouble precision 
    ///  floating point 
    /// &lt;/summary&gt; 
    public class Number : Expr 
    { 
      public double NUM { get; set; } 
      public Number(double n) { this.NUM = n; } 
      public  override double accept(IExprVisitor expr_vis) 
      { 
        return expr_vis.Visit(this); 
      } 
    } 
</pre>
        <p>Now that we have created the <code class="literal">Number</code> node, we should create a node to compose values through a binary operator. The binary operators supported are <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">/</code>, <code class="literal">*</code> and the class has been named <code class="literal">BinaryExpr</code>:</p>
        <pre class="programlisting">    /// &lt;summary&gt; 
    ///  Class BinaryExpr models a binary expression of  
    ///  the form &lt;Operand&gt; &lt;OPER&gt; &lt;Operand&gt; 
    /// &lt;/summary&gt; 
    public class BinaryExpr : Expr 
    { 
      public Expr Left { get; set; } 
      public Expr Right { get; set; } 
      public OPERATOR OP { get; set; } 
      public BinaryExpr(Expr l,Expr r,OPERATOR op){ 
        Left = l; Right = r; OP = op; 
      } 
      public override double accept(IExprVisitor expr_vis) 
      { 
        //----- When this method gets invoked by a Concrete 
        //----- implementation of Visitor, the call is routed 
        //----- back to IExprVisitor.Visit(BinaryExpr ) 
        return expr_vis.Visit(this); 
      } 
    } 
</pre>
        <p>The following class implements unary expression node. We support unary operators <code class="literal">+</code> and <code class="literal">-</code>, in our evaluator:</p>
        <pre class="programlisting">    /// &lt;summary&gt; 
    /// Class UnaryExpr models a unary expression of the form 
    /// &lt;OPER&gt; &lt;OPERAND&gt;  
    /// &lt;/summary&gt;
   public  class UnaryExpr  : Expr { 
     public Expr Right; 
     public OPERATOR OP; 
     public UnaryExpr (Expr r,OPERATOR op) { 
       Right = r; OP = op; 
     } 
     public override double accept(IExprVisitor expr_vis) 
     { 
       //----- When this method gets invoked by a Concrete 
       //----- implementation of a Visitor, the call is routed 
       //----- back to IExprVisitor.Visit(UnaryExpr ) 
       return expr_vis.Visit(this); 
     } 
   } 
</pre>
        <p>We have defined a expression hierarchy which can be composed to form arithmetical expressions of arbitrary complexity. Our nodes store only data and references to child nodes. The processing of nodes are decoupled from the node proper, using visitor pattern. Let us see couple of examples which we can use to compose arithmetical expression. As an example, let us see how we can store the expression <span class="emphasis"><em>1+2</em></span> using our composites:</p>
        <pre class="programlisting">    Expr first = new BinaryExpr( 
      new Number(1), 
      new Number(2), 
      OPERATOR.PLUS); 
</pre>
        <p>The expression <span class="emphasis"><em>2+3*4 </em></span>can be encoded as:</p>
        <pre class="programlisting">    Expr r = new BinaryExpr(new Number(2), 
    new BinaryExpr( 
      new Number(3),  
      new Number(4),  
      OPERATOR.MUL), 
    OPERATOR.PLUS); 
</pre>
        <p>We can compose expressions of arbitrary complexity using this method. Now, we will see how we can process these composites using the visitor pattern. As an example, we will write a visitor which generates <span class="strong"><strong>Reverse Polish Notation</strong></span> (<span class="strong"><strong>RPN</strong></span>) from our expression tree. RPN is also called postfix notation and are used in some calculators and Forth programming language. Read more about RPN from the Internet.</p>
        <pre class="programlisting">    /// &lt;summary&gt; 
    ///  A Visitor implementation which converts Infix expression to  
    ///  a Reverse Polish Notation ( RPN)  
    /// &lt;/summary&gt; 
    public class ReversePolishEvaluator : IExprVisitor 
    { 
      public double Visit(Number num) 
      { 
        //------ Spit the number to the console 
        Console.Write(num.NUM+ " "); 
        return 0; 
      } 
      public double Visit(BinaryExpr bin) 
      { 
        //------ Traverse the Left Sub Tree followed 
        //------ By Right Sub Tree. We follow a Depth 
        //------ First Traversal 
        bin.Left.accept(this); 
        bin.Right.accept(this); 
        //-----  After Nodes has been processed, spit out 
        //-----  the Operator 
        if (bin.OP == OPERATOR.PLUS) 
          Console.Write(" + "); 
        else if (bin.OP == OPERATOR.MUL) 
          Console.Write(" * "); 
        else if (bin.OP == OPERATOR.DIV) 
          Console.Write(" / "); 
        else if (bin.OP== OPERATOR.MINUS) 
          Console.Write(" - "); 
        return Double.NaN; 
      } 
      public double Visit(UnaryExpr un) 
      { 
        //-------- In a Unary Expression we have got  
        //-------- only a sub tree, Traverse it 
        un.Right.accept(this); 
        //-------- Spit the operand to the Console. 
        if (un.OP == OPERATOR.PLUS) 
          Console.Write("  + "); 
        else if (un.OP == OPERATOR.MINUS) 
          Console.Write("  - "); 
        return Double.NaN; 
      } 
    } 
</pre>
        <p>The above class can be invoked as follows. We will show how one can convert the expression <span class="emphasis"><em>2+3*4</em></span> to <span class="emphasis"><em>2 3 4 * +</em></span>. Let us encode the expression using our expression hierarchy as follows:</p>
        <pre class="programlisting">    Expr r = new BinaryExpr(new Number(2), 
      new BinaryExpr( 
        new Number(3),  
        new Number(4),  
        OPERATOR.MUL), 
      OPERATOR.PLUS); 
</pre>
        <p>The expression hierarchy composed above can be traversed by <code class="literal">ReversePolishEvaluator</code> to produce <span class="emphasis"><em>2 3 4 * +</em></span> as follows:</p>
        <pre class="programlisting">    IExprVisitor visitor =  
      new ReversePolishEvaluator(); 
    second.accept(visitor); 
</pre>
        <p>The whole purpose of creating an expression tree to evaluate it. We will write a stack based expression evaluator to demonstrate the use of visitor pattern:</p>
        <pre class="programlisting">    /// &lt;summary&gt; 
    ///  A Visitor which evaluates the Infix expression using a Stack 
    ///  We will leverage stack implementation available with .NET  
    ///  collections API 
    /// &lt;/summary&gt; 
    public class StackEvaluator : IExprVisitor 
    { 
      //------- A stack to store double values 
      //------- .NET Framework has got a stack implementation! 
      private Stack&lt;double&gt; eval_stack = new Stack&lt;double&gt;(); 
      //---- return the computed value 
      //---- implementation does not do any error check 
      public double get_value() { return eval_stack.Pop(); } 
 
      public StackEvaluator() { eval_stack.Clear(); } 
      public double Visit(Number num) 
      { 
        //---- whenever we get an operand 
        //---- push it to the stack 
        eval_stack.Push(num.NUM); 
        return 0; 
      } 
      public double Visit(BinaryExpr bin) 
      { 
        bin.Left.accept(this); 
        bin.Right.accept(this); 
        //--- We have processed left and right sub tree 
        //--- Let us pop values, apply the operator 
        //--- and push it back 
        if (bin.OP == OPERATOR.PLUS) 
          eval_stack.Push(eval_stack.Pop() + eval_stack.Pop()); 
        else if (bin.OP == OPERATOR.MUL) 
          eval_stack.Push(eval_stack.Pop() * eval_stack.Pop()); 
        else if (bin.OP == OPERATOR.DIV) 
        { 
          double dval = eval_stack.Pop(); 
          if (dval == 0) 
          { 
            //--- handle division by zero error 
            //--- throw an exception 
          } 
          eval_stack.Push( eval_stack.Pop()/dval); 
        } 
        else if (bin.OP == OPERATOR.MINUS) 
          eval_stack.Push(eval_stack.Pop() - eval_stack.Pop()); 
        return Double.NaN; 
      } 
      public double Visit(UnaryExpr un) 
      { 
        un.Right.accept(this); 
        if (un.OP == OPERATOR.PLUS) 
          eval_stack.Push(eval_stack.Pop()); 
        else if (un.OP == OPERATOR.MINUS) 
          eval_stack.Push(-eval_stack.Pop()); 
        return Double.NaN; 
      } 
    } 
</pre>
        <p>The above stack evaluator can be invoked as follows:</p>
        <pre class="programlisting">    Expr third = new BinaryExpr(new Number(2), 
      new BinaryExpr( 
      new Number(3),  
      new Number(4),  
      OPERATOR.MUL), 
    OPERATOR.PLUS); 
 
    StackEvaluator seval = new StackEvaluator();  
    third.accept(seval);
    Console.WriteLine(seval.get_value()); 
    Console.WriteLine(); 
</pre>
        <p>We have finished our discussion on visitor and composite pattern. In the above example, we defined a small hierarchy to compose mathematical expressions and processed it using visitor classes which traversed the composite to produce RPN expression and evaluate it using a stack. This technique is widely used wherever one is supposed to process a hierarchy. Let us focus on how to create a document hierarchy and process it.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The composite pattern and document composition">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec33"></a>The composite pattern and document composition</h1>
            </div>
          </div>
        </div>
        <p>While representing part-whole hierarchies (tree-structured), the composite design pattern describes a group of objects to be treated in a uniform manner, as if the leaf node and interior nodes are instances of the same object. A document object can contain multiple tables, and we can nest tables as well. This is an instance of a part-whole hierarchy, and composite design pattern is a natural choice here. To create a composite, we need to declare a base class, and all objects should be derived from this base class:</p>
        <pre class="programlisting">    public abstract class TDocumentElement 
    { 
      public List&lt;TDocumentElement&gt; DocumentElements { get; set; } 
      //------ The method given below is for implementing Visitor     
      Pattern 
      public abstract void accept(IDocumentVisitor doc_vis); 
      //--- Code Omitted 
      public TDocumentElement() 
      { 
        DocumentElements = new List&lt;TDocumentElement&gt;(5); 
        this.Align = alignment.LEFT; 
        this.BackgroundColor = "0xFF000000L"; 
      } 
      //---- Code Omitted 
      public void addObject(TDocumentElement value) 
      { 
        if (value != null) 
        DocumentElements.Add(value); 
      } 
      public Boolean removeObject(TDocumentElement value) 
      { 
        if (value != null) 
        { 
          DocumentElements.Remove(value); 
          return true; 
        } 
        return false; 
      } 
      //----- Code Omitted 
    } 
</pre>
        <p>The <code class="literal">TDocumentElement</code> class acts as a base class for all the classes in the object model. Please note the following two important things about the <code class="literal">TDocumentElement</code> class:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">The first one is the <code class="literal">DocumentElements</code> property. Every <code class="literal">TDocumentElement</code> has a list of <code class="literal">TDocumentElement</code> to store its child objects. This means, we can insert a list of concrete objects which implements <code class="literal">TDcoumentElement</code> as a child. Using this technique, we can compose a document hierarchy of arbitrary complexity.</li>
            <li class="listitem" style="list-style-type: disc">The second thing is the presence of an abstract method called <code class="literal">accept</code>. The <code class="literal">accept</code> method is a mechanism by which we will be able to separate the operations on node and the node data structure. We will learn more about the semantics of the <code class="literal">accept</code> method in a later section.</li>
          </ul>
        </div>
        <p>The topmost class in the hierarchy is <code class="literal">TDocument</code>, which acts as a container for a hierarchical collection of the <code class="literal">TDocumentElement</code> derived class. The class will store all the child contents (concrete classes of base type <code class="literal">TDocumentElement</code>) to be embedded inside the document.</p>
        <pre class="programlisting">    public class TDocument : TDocumentElement 
    { 
      public string Title {get;set;} 
      public string BackGroundImage { get; set;} 
      public string TextColor { get; set;} 
      public string LinkColor {get;set;} 
      public string Vlink { get; set;} 
      public string Alink {get;set;} 
      public  int ColumnCount { get; set;} 
      public override void accept(IDocumentVisitor doc_vis) 
      { 
        doc_vis.visit(this); 
      } 
      public TDocument(int count=1) 
      { 
        this.ColumnCount = count; 
        this.Title = "Default Title"; 
      } 
    } 
</pre>
        <p>Application developers can leverage the <code class="literal">addObject</code> method available in the <code class="literal">TDocumentElement</code> class to add contents to <code class="literal">TDocument</code>. In our canned example, the most obvious choice is a list of tables. The <code class="literal">accept</code> method makes a call to the visitor's visit method with the <code class="literal">TDocument</code> instance (this) as a parameter. This will hit the <code class="literal">visit(TDocument)</code> method implemented in a class, which implements the <code class="literal">IDocumentVisitor</code> interface. More on visitor pattern and its implementation is available in a later section.</p>
        <p>The <code class="literal">TDocumentTable</code> models a table object, which can be embedded inside a document. Since the <code class="literal">TDocumentTable</code> object inherits from <code class="literal">TDocumentElement</code>, we can add any <code class="literal">TDocumentElement</code> derived class as a child. With this technique, we can embed objects of arbitrary complexity. But, for our library, an Instance of <code class="literal">TDocumentTable</code> is the natural choice as the first child of the <code class="literal">TDocument</code> object.</p>
        <pre class="programlisting">    public class TDocumentTable : TDocumentElement 
    { 
      public string  Caption {get;set; } 
      public int Width { get;set; } 
      public int Border { get; set; } 
      public int CellSpacing { get;set;} 
      public int Cellpadding { get; set; } 
      public Boolean PercentageWidth { get;set; } 
      public String bgColor {get; set; } 
 
      public int RowCount 
      { 
        get 
        { 
          return this.DocumentElements.Count; 
        } 
      } 
 
      public override void accept(IDocumentVisitor doc_vis) 
      { 
        doc_vis.visit(this); 
      } 
 
      public TDocumentTable() 
      { 
      } 
    } 
</pre>
        <p>Inside a table, we store data as a series of rows, and the class for storing information is appropriately named <code class="literal">TDocumentTableRow</code>. We can insert another table as a child as well. One can embed a table within a table. For the sake of brevity, we have not included that feature in the current implementation. If we need to support nested tables, we need to incorporate a data structure called scope tree. The listing of such an implementation cannot be conveniently included in a book.</p>
        <pre class="programlisting">    public class TDocumentTableRow : TDocumentElement 
    { 
      public TDocumentTableRow(){} 
      public override void accept(IDocumentVisitor doc_vis) 
      { 
        doc_vis.visit(this); 
      } 
    } 
</pre>
        <p>A row is a collection of cells, and inside each cell, we can store arbitrary text. It is possible to store an image as well, but, for the sake of brevity, we have limited the cell contents to text. The image or another content type can be incorporated very easily following the schema used for text.</p>
        <pre class="programlisting">    public class TDocumentTableCell : TDocumentElement 
    { 
      public int ColumnSpan { get; set; } 
      public alignment Horizontal { get; set; } 
      public alignment Vertical { get; set; } 
      public alignment Type { get; set; } 
      public TDocumentTableCell() 
      { 
        this.ColumnSpan = 1; 
        this.Horizontal = alignment.LEFT; 
        this.Vertical = alignment.MIDDLE; 
        this.Type = alignment.DATA; 
      } 
      public override void accept(IDocumentVisitor doc_vis) 
      { 
        doc_vis.visit(this); 
      } 
    } 
</pre>
        <p>Every cell in the table contains a text item for our implementation. We model the text using the <code class="literal">TDocumentText</code> class. In this class, the <code class="literal">Text</code> property is used to store and load text.</p>
        <pre class="programlisting">    public class TDocumentText : TDocumentElement 
    { 
      public string Text { set;get; } 
      public Boolean Bold {get;set;} 
      public Boolean Italic {get;set;} 
      public Boolean Underline { get; set; } 
      public Boolean Center {get;set;} 
      public Boolean Preformatted { get; set; } 
      public string Color { get; set; } 
      public Boolean Font  {get;set;} 
 
      public TDocumentText(string value = null) 
      { 
        this.Text = value; 
      } 
 
      public override void accept(IDocumentVisitor doc_vis) 
      { 
        doc_vis.visit(this); 
      } 
    } 
</pre>
        <p>Thus, we have defined our DOM. You can see the UML representation of the composite pattern in action in the following diagram:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_05_01.jpg" alt="The composite pattern and document composition"/>
        </div>
        <p>
</p>
        <p>Now we need to create a mechanism to traverse the hierarchy to produce the output of our choice.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Visitor pattern for document traversal">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec34"></a>Visitor pattern for document traversal</h1>
            </div>
          </div>
        </div>
        <p>The tree-structured DOM created by us needs to be traversed to produce the content in an output format like HTML, PDF, or SVG.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note24"></a>Note</h3>
            <p>The composite tree created by us can be traversed using the GoF visitor pattern. Wherever composite pattern is used for composing an hierarchy of objects, the visitor pattern is a natural choice for the traversal of the tree.</p>
          </div>
        </div>
        <p>In a visitor pattern implementation, every node in the composite tree will support a method called <code class="literal">accept</code>, which takes a visitor concrete class as a parameter. The job of the <code class="literal">accept</code> routine is to reflect the call to the appropriate visit method in the visitor concrete class. We declare an interface named <code class="literal">IDocumentVisitor</code> with methods for visiting each of the elements in our hierarchy as follows:</p>
        <pre class="programlisting">    public interface IDocumentVisitor 
    { 
      void visit(TDocument doc); 
      void visit(TDocumentTable table); 
      void visit(TDocumentTableRow row); 
      void visit(TDocumentTableCell cell); 
      void visit(TDocumentText txt); 
    } 
</pre>
        <p>The traversal of the tree should start from the top node of the tree. In our case, we start the traversal from the <code class="literal">TDocument</code> node. For each node in the hierarchy, we will add an <code class="literal">accept</code> method, which takes an instance of <code class="literal">IDocumentVisitor</code>. The signature of this function is as follows:</p>
        <pre class="programlisting">    public abstract class TDocumentElement 
    { 
      //--- code omitted 
      public abstract void accept(IDocumentVisitor doc_vis); 
      //--- code omitted 
    } 
</pre>
        <p>Each element of the document node which derives from <code class="literal">TDocumentElement</code> needs to have an implementation of this method. For example, the body of the <code class="literal">TDocument</code> class is as follows:</p>
        <pre class="programlisting">    public class TDocument : TDocumentElement 
    { 
      //----- code omitted 
      public override void accept(IDocumentVisitor doc_vis) 
      { 
        doc_vis.visit(this); 
      } 
      //------ code omitted
    } 
</pre>
        <p>In the <code class="literal">TDocument</code> class, the <code class="literal">accept</code> method will reflect the call to the <code class="literal">IDocumentVisitor visit(TDocument)</code> method implemented by the <code class="literal">Visitor</code> class. In the <code class="literal">Visitor</code> class, for each node inserted as a child, a call to the <code class="literal">accept</code> method of the respective nodes will be triggered. Each time the call gets reflected back to the appropriate visit method of the <code class="literal">Visitor</code> class. In this manner, the accept/visit pair processes the whole hierarchy.</p>
        <p>The traversal starts with the <code class="literal">TDocument accept</code> method, as follows:</p>
        <pre class="programlisting">    string filename = @"D:\ab\fund.pdf"; 
    ds.accept(new PDFVisitor(filename)); 
</pre>
        <p>The <code class="literal">ds</code> object is of type <code class="literal">TDocument</code>, and the <code class="literal">accept</code> method takes an instance of the <code class="literal">IDocumentVisitor</code> interface. In the document object, the call gets reflected to the <code class="literal">IDocumentVisitor visit(TDocument)</code> method.</p>
        <div class="section" title="PDFVisitor for PDF generation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch05lvl2sec31"></a>PDFVisitor for PDF generation</h2>
              </div>
            </div>
          </div>
          <p>We have defined our object hierarchy and an interface to traverse the hierarchy. Now we need to implement routines to traverse the tree. The <code class="literal">PDFVisitor</code> class implements the <code class="literal">IDocumentVisitor</code> interface, as shown in the following&#160;code snippet:</p>
          <pre class="programlisting">    public class PDFVisitor : IDocumentVisitor 
    { 
      private string file_name = null; 
      private PdfWriter writer = null; 
      private Document document = null; 
      private PdfPTable table_temp = null; 
      private FileStream fs = null; 
      private int column_count; 
 
      public PDFVisitor(string filename) 
      { 
        file_name = filename; 
        fs = new FileStream(file_name, FileMode.Create); 
        document = new Document(PageSize.A4, 25, 25, 30, 30); 
        writer = PdfWriter.GetInstance(document, fs); 
      } 
</pre>
          <p>The <code class="literal">visit</code> method, which takes <code class="literal">TDocument</code> as a parameter, adds some metadata to the PDF document being created. After this operation, the method inspects all the child elements of <code class="literal">TDocument</code>, and issues an <code class="literal">accept</code> method call with the current visitor instance. This invokes the <code class="literal">accept</code> method of the concrete class of <code class="literal">TDocumentElement</code> embedded as a child object:</p>
          <pre class="programlisting">    public void visit(TDocument doc) 
    { 
      document.AddAuthor(@"Praseed Pai &amp; Shine Xavier"); 
      document.AddCreator(@"iTextSharp Library"); 
      document.AddKeywords(@"Design Patterns Architecture"); 
      document.AddSubject(@"Book on .NET Design Patterns"); 
      document.Open(); 
      column_count = doc.ColumnCount; 
      document.AddTitle(doc.Title); 
 
      for (int x = 0; x &lt; doc.DocumentElements.Count; x++) 
      { 
        try 
        { 
          doc.DocumentElements[x].accept(this); 
        } 
        catch (Exception ex) 
        { 
          Console.Error.WriteLine(ex.Message); 
        } 
      } 
      document.Add(this.table_temp); 
      document.Close(); 
      writer.Close(); 
      fs.Close(); 
</pre>
          <p>The <code class="literal">TDocumentTable</code> object will be handled by the <code class="literal">visit</code> method in a similar fashion. Once we have worked with the node, all the children stored in <code class="literal">DocumentElements</code> will be processed by invoking the <code class="literal">accept</code> method of each of the node element embedded inside the table:</p>
          <pre class="programlisting">    public void visit(TDocumentTable table) 
    { 
      this.table_temp = new PdfPTable(column_count); 
      PdfPCell cell = new  
      PdfPCell(new Phrase("Header spanning 3 columns")); 
      cell.Colspan = column_count; 
      cell.HorizontalAlignment = 1;  
      table_temp.AddCell(cell); 
      for (int x = 0; x &lt; table.RowCount; x++) 
      { 
        try 
        { 
          table.DocumentElements[x].accept(this); 
        } 
        catch (Exception ex) 
        { 
          Console.Error.WriteLine(ex.Message); 
        } 
      } 
    } 
</pre>
          <p>Mostly, an instance of <code class="literal">TDocumentTableRow</code> is included as a child of <code class="literal">TDocumentTable</code>. For our implementation, we will navigate to all the children of a row object, issuing accept calls to the respective nodes:</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note25"></a>Note</h3>
              <p>A table is a collection of rows, and a row is a collection of cells. Each of the cells contains some text. We can add a collection of text inside a cell as well. Our implementation assumes that we will store only one text.</p>
            </div>
          </div>
          <pre class="programlisting">    public void visit(TDocumentTableRow row) 
    { 
      for (int I = 0; i &lt; row.DocumentElements.Count; ++i) 
      { 
        row.DocumentElements[i].accept(this); 
      } 
    } 
</pre>
          <p>To&#160;process&#160;<code class="literal">TDocumentTableCell</code>, we iterate through all the child elements of a cell, and these elements are instances&#160;<code class="literal">TDocumentText</code>. For the sake of brevity, we have included an attribute called <code class="literal">Text</code> to store the contents of a cell there:</p>
          <pre class="programlisting">    public void visit(TDocumentTableCell cell) 
    { 
      for (int i = 0; i &lt; cell.DocumentElements.Count; ++i) 
      { 
        cell.DocumentElements[i].accept(this); 
      } 
    } 
</pre>
          <p>The <code class="literal">TDocumentText</code> class has a property by the name of <code class="literal">Text</code>, where an application developer can store some text. That will be added to the table:</p>
          <pre class="programlisting">    public void visit(TDocumentText txt) 
    { 
      table_temp.AddCell(txt.Text); 
    } 
  } 
</pre>
        </div>
        <div class="section" title="HTMLVisitor for HTML generation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch05lvl2sec32"></a>HTMLVisitor for HTML generation</h2>
              </div>
            </div>
          </div>
          <p>The <code class="literal">HTMLVisitor</code> class produces HTML output by traversing the DOM. The skeleton implementation of <code class="literal">HTMLVisitor</code> is as follows:</p>
          <pre class="programlisting">    public class HTMLVisitor : IDocumentVisitor 
    { 
      private String file_name = null; 
      private StringBuilder document = null; 
      public HTMLVisitor(string filename) { 
        file_name = filename; 
      } 
      //--- Code omitted for all methods 
      public void visit(TDocument doc){} 
      public void visit(TDocumentTable table){} 
      public void visit(TDocumentTableRow row) {} 
      public void visit(TDocumentTableCell cell) {} 
      public void visit(TDocumentText txt) {} 
    }</pre>
          <p>The <code class="literal">HTMLVisitor</code> class can be leveraged as follows:</p>
          <pre class="programlisting">    string filename = @"D:\ab\fund.html"; 
    ds.accept(new HTMLVisitor(filename)); 
</pre>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The client program">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec35"></a>The client program</h1>
            </div>
          </div>
        </div>
        <p>A simple program which leverages the DOM is given next. We create a <code class="literal">TDocument</code> object as a top-level node, and add the rest of the document contents as child nodes to the respective classes:</p>
        <pre class="programlisting">    static void DocumentRender() 
    { 
      TDocument ds = new TDocument(3); 
      ds.Title = "Multiplication Table"; 
      TDocumentTable table = new TDocumentTable(); 
      table.Border = 1; 
      table.Width = 100; 
      table.BackgroundColor = "#EFEEEC"; 
      TDocumentTableRow row = null; 
      row = new TDocumentTableRow(); 
 
      TDocumentText headtxt = new TDocumentText("Multiplicand"); 
      headtxt.Font = true; 
      headtxt.Color = "#800000"; 
      TDocumentTableCell cell = null; 
      cell = new TDocumentTableCell(alignment.HEADING); 
      cell.addObject(headtxt); 
      row.addObject(cell); 
 
      headtxt = new TDocumentText("Multiplier"); 
      headtxt.Color = "#800000"; 
      cell = new TDocumentTableCell(alignment.HEADING); 
      cell.addObject(headtxt); 
      row.addObject(cell); 
      headtxt = new TDocumentText("Result"); 
      headtxt.Color = "#800000"; 
      cell = new TDocumentTableCell(alignment.HEADING); 
      cell.addObject(headtxt); 
      row.addObject(cell); 
      table.addObject(row); 
 
      int a = 16; 
      int j = 1; 
 
      while (j &lt;= 12) 
      { 
        row = new TDocumentTableRow(); 
        cell = new TDocumentTableCell(alignment.DATA); 
        cell.addObject(new TDocumentText(a.ToString())); 
        row.addObject(cell); 
        cell = new TDocumentTableCell(alignment.DATA); 
 
        cell.addObject(new TDocumentText(j.ToString())); 
        row.addObject(cell); 
        cell = new TDocumentTableCell(alignment.DATA); 
        int result = a * j; 
        cell.addObject(new TDocumentText(result.ToString())); 
        row.addObject(cell); 
        table.addObject(row); 
        j++; 
      } 
      ds.addObject(table); 
 
      string filename = 
      @"D:\ab\fund.pdf"; 
      ds.accept(new PDFVisitor(filename)); 
 
      string filename2 = 
      @"D:\ab\fund.html"; 
      ds.accept(new HTMLVisitor(filename2)); 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch05lvl1sec36"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we created a library for producing tabular reports in various formats. In the process, we learned about creating arbitrary hierarchies of objects in a tree-structured manner. We leveraged the composite pattern to implement our hierarchy. The composites were processed using the visitor pattern. We dealt with PDF and HTML output by writing <code class="literal">PDFVisitor</code> and <code class="literal">HTMLVisitor</code> classes. Incorporating a new output format is just a matter of writing a new visitor (say, <code class="literal">SVGVisitor</code>), where one needs to map the contents of the document to the appropriate SVG tags. In the next chapter, we will learn about the interpreter pattern and the observer pattern by implementing a library that will help us plot arbitrary expressions as graphs.</p>
      </div>
    </div>
</body>
</html>