- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Building Blocks of Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程的构建块
- en: Any programming language starts off looking like ancient Greek to the unaccustomed
    eye, and C# is no exception. The good news is beneath the initial mystery, all
    programming languages are made up of the same essential building blocks. Variables,
    methods, and classes (or objects) make up the DNA of conventional programming;
    understanding these simple concepts opens up an entire world of diverse and complex
    applications. After all, there are only four different DNA nucleobases in every
    person on earth; yet, here we are, every one of us a unique organism.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉的人来说，任何编程语言一开始看起来都像古希腊文，C#也不例外。好消息是，在最初的神秘感之下，所有编程语言都由相同的本质构建块组成。变量、方法和类（或对象）构成了传统编程的DNA；理解这些简单概念可以打开一个充满多样性和复杂应用的世界。毕竟，地球上每个人的DNA中只有四种不同的核苷酸；然而，我们每个人都是独特的生物体。
- en: If you are new to programming, there's going to be a lot of information coming
    at you in this chapter, and this could mark the first lines of code that you've
    ever written. The point is not to overload your brain with facts and figures;
    it's to give you a holistic look at the building blocks of programming using examples
    from everyday life.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触编程，那么在这一章中会有大量的信息向你涌来，这可能是你写的第一行代码。重点是不要让你的大脑被事实和数据压垮；而是通过日常生活的例子，给你一个对编程构建块的全面了解。
- en: 'This chapter is all about the high-level view of the bits and pieces that make
    up a program. Getting the hang of how things work before getting into the code
    directly will not only help you new coders find your feet, but it will also solidify
    the topics with easy-to-remember references. Ramblings aside, we''ll focus on
    the following topics throughout this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍构成程序的各种组件的高层次视图。在直接编写代码之前，了解事物的工作原理不仅可以帮助新程序员站稳脚跟，而且还可以通过易于记忆的参考来巩固这些主题。抛开闲话不谈，我们将在本章中关注以下主题：
- en: Defining variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量
- en: Understanding methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解方法
- en: Introducing classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍类
- en: Working with comments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注释
- en: Putting the building blocks together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将构建块组合起来
- en: Defining variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义变量
- en: 'Let''s start with a simple question: what is a variable? Depending on your
    point of view, there are a few different ways of answering that question:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个问题开始：什么是变量？根据你的观点，有几种不同的方式来回答这个问题：
- en: '**Conceptually**, a variable is the most basic unit of programming, as an atom
    is to the physical world (excepting string theory). Everything starts with variables,
    and programs can''t exist without them.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念上**，变量是编程中最基本的单元，就像原子对物理世界一样（除了弦理论）。一切从变量开始，没有变量程序就无法存在。'
- en: '**Technically**, a variable is a tiny section of your computer''s memory that
    holds an assigned value. Every variable keeps track of where its information is
    stored (this is called a memory address), its value, and its type (for instance,
    numbers, words, or lists).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，变量是计算机内存中一个包含分配值的微小部分。每个变量都跟踪其信息存储的位置（这被称为内存地址），其值和其类型（例如，数字、单词或列表）。'
- en: '**Practically**, a variable is a container. You can create new ones at will,
    fill them with stuff, move them around, change what they''re holding, and reference
    them as needed. They can even be empty and still be useful.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，变量是一个容器。你可以随意创建新的变量，填充内容，移动它们，改变它们所持有的内容，并在需要时引用它们。即使它们是空的，也可以是有用的。'
- en: You can find an in-depth explanation of variables in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在微软C#文档中找到对变量的深入解释，链接为[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables)。
- en: A practical real-life example of a variable is a mailbox—remember those?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的一个实际生活例子是邮箱——你还记得吗？
- en: '![](img/B17573_02_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_02_01.png)'
- en: 'Figure 2.1: Snapshot of a row of colorful mailboxes'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：一排五彩缤纷的邮箱快照
- en: 'They can hold letters, bills, a picture from your aunt Mabel—anything. The
    point is that what''s in a mailbox can vary: they can have names, hold information
    (physical mail), and their contents can even be changed if you have the right
    security clearance. Similarly, variables can hold different kinds of information.
    Variables in C# can hold strings (text), integers (numbers), and even Booleans
    (binary values that represent either true or false).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以存放字母、纸币、你阿姨 Mabel 的一张照片——任何东西。关键是邮箱里的内容可以变化：它们可以有名字，存放信息（实体邮件），如果你有适当的权限，其内容甚至可以更改。同样，变量可以存储不同类型的信息。C#
    中的变量可以存储字符串（文本）、整数（数字），甚至布尔值（代表真或假的二进制值）。
- en: Names are important
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称很重要
- en: 'Referring to *Figure 2.1*, if I asked you to go over and open the mailbox,
    the first thing you''d probably ask is: which one? If I said the Smith family
    mailbox, or the sunflower mailbox, or even the droopy mailbox on the far right,
    then you''d have the necessary context to open the mailbox I was referencing.
    Similarly, when you are creating variables, you have to give them unique names
    that you can reference later. We''ll get into the specifics of proper formatting
    and descriptive naming in *Chapter 3*,*Diving into Variables, Types, and Methods*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图 2.1，如果我问你过去打开邮箱，你可能会问的第一个问题是：哪一个？如果我说 Smith 家族的邮箱，或者向日葵邮箱，或者甚至是远处的低垂邮箱，那么你就有足够的上下文来打开我提到的邮箱。同样，当你创建变量时，你必须给它们起一个独特的名字，以便以后可以引用。我们将在第
    3 章*深入变量、类型和方法*中详细介绍适当的格式化和描述性命名。
- en: Variables act as placeholders
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量充当占位符
- en: 'When you create and name a variable, you are creating a placeholder for the
    value that you want to store. Let''s take the following simple math equation as
    an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建并命名一个变量时，你正在创建一个用于存储你想要存储的值的占位符。以下是一个简单的数学方程式作为例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Okay, no mystery here, but what if we wanted the number `9` to be its variable?
    Consider the following code block:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里没有秘密，但如果我们想让数字 `9` 成为它的变量呢？考虑以下代码块：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can use the variable name, `MyVariable`, as a substitute for `9` anywhere
    we need it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用变量名 `MyVariable` 代替 `9` 在任何需要的地方：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you're wondering whether variables have other rules or regulations, they
    do. We'll get to those in the next chapter, so sit tight.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道变量是否有其他规则或规定，它们确实有。我们将在下一章中介绍这些内容，所以请耐心等待。
- en: Even though this example isn't real C# code, it illustrates the power of variables
    and their use as placeholder references. In the next section you'll start creating
    variables of your own, so keep going!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子不是真正的 C# 代码，但它说明了变量的力量以及它们作为占位符引用的使用。在下一节中，你将开始创建自己的变量，所以继续前进吧！
- en: 'Alright, enough theory—let''s create a real variable in the `LearningCurve`
    script we created in *Chapter 1*, *Getting to Know Your Environment*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，理论就到这里——让我们在我们在第 1 章*了解你的环境*中创建的 `LearningCurve` 脚本中创建一个真正的变量：
- en: Double-click on `LearningCurve.cs` from the Unity project window to open it
    in Visual Studio.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 Unity 项目窗口中的 `LearningCurve.cs` 以在 Visual Studio 中打开它。
- en: 'Add a space between lines 6 and 7 and add the following line of code to declare
    a new variable:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 6 行和第 7 行之间添加一个空格，并添加以下代码行来声明一个新变量：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the `Start` method, add two debug logs to print out the following calculations:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Start` 方法内部，添加两个调试日志来打印出以下计算结果：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's break down the code we just added. First, we created a new variable called
    `CurrentAge` and assigned it a value of `30`. Then, we added two debug logs to
    print out the result of `30 + 1` and `CurrentAge + 1` to show how variables are
    storage for values. They can be used the exact same way as the values themselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们刚刚添加的代码。首先，我们创建了一个名为 `CurrentAge` 的新变量，并将其赋值为 `30`。然后，我们添加了两个调试日志来打印出
    `30 + 1` 和 `CurrentAge + 1` 的结果，以展示变量作为值的存储方式。它们可以像值本身一样使用。
- en: 'It''s also important to note that `public` variables appear in the Unity Inspector,
    while `private` ones don''t. Don''t worry about the syntax right now—just make
    sure your script is the same as the script that is shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，`public` 变量会出现在 Unity 检查器中，而 `private` 变量则不会。现在不必担心语法，只需确保你的脚本与以下截图所示的脚本相同：
- en: '![](img/B17573_02_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_02_02.png)'
- en: 'Figure 2.2: LearningCurve script open in Visual Studio'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：在 Visual Studio 中打开 LearningCurve 脚本
- en: To finish, save the file using **Editor** | **File** | **Save**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 **编辑器** | **文件** | **保存** 来保存文件。
- en: 'For scripts to run in Unity, they have to be attached to *GameObjects* in the
    scene. The sample scene in *Hero Born* has a camera and directional light by default,
    which provides the lighting for the scene, so let''s attach `LearningCurve` to
    the camera to keep things simple:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Unity 中运行脚本，它们必须附加到场景中的 *游戏对象* 上。*英雄降生* 中的示例场景默认包含一个摄像机和一个方向光，这为场景提供了照明，所以让我们将
    `LearningCurve` 附加到摄像机上以保持事情简单：
- en: Drag and drop `LearningCurve.cs` onto the **Main Camera**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LearningCurve.cs` 拖放到 **主摄像机** 上。
- en: Select the **Main Camera** so that it appears in the **Inspector** panel, and
    verify that the `LearningCurve.cs` (Script) component is attached properly.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **主摄像机**，使其出现在 **检查器** 面板中，并验证 `LearningCurve.cs`（脚本）组件是否正确附加。
- en: Click play and watch for the output in the **Console** panel:![](img/B17573_02_03.png)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并注意 **控制台** 面板中的输出：![img/B17573_02_03.png](img/B17573_02_03.png)
- en: 'Figure 2.3: Unity Editor window with callouts for dragging and dropping scripts'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.3：Unity 编辑器窗口，带有拖放脚本的提示
- en: 'The `Debug.Log()` statements printed out the result of the simple math equations
    we put in between the parentheses. As you can see in the following **Console**
    screenshot, the equation that used our variable, `CurrentAge`, worked the same
    as if it were a real number:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug.Log()` 语句打印出了我们放在括号之间的简单数学方程式的结果。正如你在下面的 **控制台** 截图中可以看到，使用了我们的变量 `CurrentAge`
    的方程式与使用真实数字时的效果相同：'
- en: '![](img/B17573_02_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17573_02_04.png](img/B17573_02_04.png)'
- en: 'Figure 2.4: Unity console with debug output from the attached script'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：Unity 控制台，带有附加脚本的调试输出
- en: We'll get into how Unity converts C# scripts into components at the end of this
    chapter, but first, let's work on changing the value of one of our variables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的末尾讨论 Unity 如何将 C# 脚本转换为组件，但首先，让我们来改变我们变量中的一个的值。
- en: 'Since `CurrentAge` was declared as a variable on line 7 as shown in *Figure
    2.2*, the value it stores can be changed. The updated value will then trickle
    down to wherever the variable is used in code; let''s see this in action:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `CurrentAge` 如 *图 2.2* 所示在第七行被声明为一个变量，因此它可以存储的值可以被改变。更新后的值将随后传播到代码中任何使用该变量的地方；让我们看看这个动作：
- en: Stop the game by clicking the **Pause** button if the scene is still running
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果场景仍在运行，请点击 **暂停** 按钮停止游戏
- en: Change **Current Age** to `18` in the **Inspector** panel and play the scene
    again, looking at the new output in the **Console** panel:![](img/B17573_02_05.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 面板中将 **当前年龄** 改为 `18`，然后再次播放场景，查看 **控制台** 面板中的新输出：![img/B17573_02_05.png](img/B17573_02_05.png)
- en: 'Figure 2.5: Unity console with debug logs and the LearningCurve script attached
    to Main Camera'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.5：Unity 控制台，带有调试日志和附加到主摄像机的 LearningCurve 脚本
- en: The first output will still be `31` because we didn't change anything in the
    script, but the second output is now `19` because we changed the value of `CurrentAge`
    in the Inspector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行输出仍然是 `31`，因为我们没有在脚本中做任何改变，但第二行输出现在是 `19`，因为我们改变了 `CurrentAge` 在检查器中的值。
- en: The goal here wasn't to go over variable syntax but to show how variables act
    as containers that can be created once and referenced elsewhere. We'll go into
    more detail in *Chapter 3*, *Diving into Variables, Types, and Methods*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标不是介绍变量语法，而是展示变量作为容器的作用，可以创建一次并在其他地方引用。我们将在 *第 3 章*，*深入变量、类型和方法* 中进行更详细的介绍。
- en: 'Now that we know how to create variables in C# and assign them values, we''re
    ready to dive into the next important programming building block: methods!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在 C# 中创建变量并为其赋值，我们就可以深入探讨下一个重要的编程构建块：方法了！
- en: Understanding methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解方法
- en: On their own, variables can't do much more than keep track of their assigned
    values. While this is vital, they are not very useful on their own in terms of
    creating meaningful applications. So, how do we go about creating actions and
    driving behavior in our code? The short answer is by using methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的变量除了跟踪其分配的值之外，不能做更多的事情。虽然这是至关重要的，但它们本身在创建有意义的应用程序方面并不太有用。那么，我们如何在我们的代码中创建动作并驱动行为呢？简短的答案是，通过使用方法。
- en: Before we get to what methods are and how to use them, we should clarify a small
    point of terminology. In the world of programming, you'll commonly see the terms
    *method* and *function* used interchangeably, especially in regards to Unity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论方法是什么以及如何使用它们之前，我们应该澄清一个小小的术语问题。在编程的世界里，你经常会看到术语 *方法* 和 *函数* 被互换使用，尤其是在
    Unity 中。
- en: Since C# is an object-oriented language (this is something that we'll cover
    in *Chapter 5*, *Working with Classes, Structs, and OOP*), we'll be using the
    term *method* for the rest of the book to conform to standard C# guidelines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C# 是一种面向对象的语言（这一点我们将在 *第五章* *使用类、结构和面向对象编程* 中进行讲解），因此本书余下部分我们将使用“方法”这个术语，以符合标准的
    C# 指南。
- en: When you come across the word function in the Scripting Reference or any other
    documentation, think method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在脚本参考或任何其他文档中遇到“函数”这个词时，请将其视为“方法”。
- en: Methods drive actions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法驱动动作
- en: 'Similarly to variables, defining programming methods can be tediously long-winded
    or dangerously brief; here''s another three-pronged approach to consider:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于变量，定义编程方法可以是冗长乏味的，或者危险地简短；这里有一个三方面的方法可以考虑：
- en: '**Conceptually**, methods are how work gets done in an application.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从概念上讲**，方法是在应用程序中完成工作的方式。'
- en: '**Technically**, a method is a block of code containing executable statements
    that run when the method is called by name. Methods can take in arguments (also
    called parameters), which can be used inside the method''s scope.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，方法是一块包含可执行语句的代码块，当通过名称调用该方法时运行。方法可以接受参数（也称为参数），这些参数可以在方法的作用域内使用。'
- en: '**Practically**, a method is a container for a set of instructions that run
    every time it''s executed. These containers can also take in variables as inputs,
    which can only be referenced inside the method itself.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，方法是一组指令的容器，每次执行时都会运行。这些容器也可以接受变量作为输入，这些变量只能在方法内部引用。'
- en: Taken all together, methods are the bones of any program—they connect everything
    and almost everything is built off of their structure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，方法是一切程序的骨架——它们连接一切，几乎所有东西都是基于它们的结构构建的。
- en: You can find an in-depth guide to methods in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Microsoft C# 文档中找到关于方法的深入指南，链接为 [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods)。
- en: Methods are placeholders too
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也是占位符
- en: 'Let''s take an oversimplified example of adding two numbers together to drive
    the concept home. When writing a script, you''re essentially laying down lines
    of code for the computer to execute in sequential order. The first time you need
    to add two numbers together, you could just add them like in the following code
    block:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个过于简化的例子来说明如何将两个数字相加，以加深这个概念。当你编写脚本时，你实际上是在为计算机执行按顺序排列的代码行。第一次需要将两个数字相加时，你可以在以下代码块中直接将它们相加：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But then you conclude that these numbers need to be added together somewhere
    else.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后你得出结论，这些数字需要在其他地方相加。
- en: 'Instead of copying and pasting the same line of code, which results in sloppy
    or "spaghetti" code and should be avoided at all costs, you can create a named
    method that will take care of this action:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是复制粘贴相同的代码行，这会导致混乱的或“意大利面”式的代码，应该尽量避免，你可以创建一个命名的方法来处理这个动作：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now `AddNumbers` is holding a place in memory, just like a variable; however,
    instead of a value, it holds a block of instructions. Using the name of the method
    (or calling it) anywhere in a script puts the stored instructions at your fingertips
    without having to repeat any code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `AddNumbers` 在内存中占有一个位置，就像一个变量一样；然而，它持有的不是值，而是一块指令。在脚本中的任何地方使用方法的名称（或调用它）都会将存储的指令放在你的指尖上，而不需要重复任何代码。
- en: If you find yourself writing the same lines of code over and over, you're likely
    missing a chance to simplify or condense repeated actions into common methods.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己一遍又一遍地编写相同的代码行，你很可能会错过将重复的动作简化或压缩成通用方法的机会。
- en: This produces what programmers jokingly call spaghetti code because it can get
    messy. You'll also hear programmers refer to a solution called the **Don't Repeat
    Yourself** (**DRY**) principle, which is a mantra you should keep in mind.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生程序员戏称为“意大利面代码”的东西，因为它可能会变得混乱。你也会听到程序员提到一个名为“不要重复自己”(**DRY**)原则的解决方案，这是一个你应该牢记的箴言。
- en: As before, once we've seen a new concept in pseudocode, it's best if we implement
    it ourselves, which is what we'll do in the next section to drive it home.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦我们在伪代码中看到了一个新概念，最好是亲自实现它，这正是我们将在下一节中做的，以便加深理解。
- en: 'Let''s open up `LearningCurve` again and see how a method works in C#. Just
    like with the variables example, you''ll want to copy the code into your script
    exactly as it appears in the following screenshot. I''ve deleted the previous
    example code to make things neater, but you can, of course, keep it in your script
    for reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开`LearningCurve`，看看C#中方法是如何工作的。就像变量示例一样，你希望将代码复制到你的脚本中，就像以下截图中显示的那样。我已经删除了之前的示例代码以使事情更整洁，但你当然可以在你的脚本中保留它以供参考：
- en: Open up `LearningCurve` in Visual Studio.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`LearningCurve`。
- en: 'Add a new variable to line 8:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第8行添加一个新变量：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a new method to line 16 that adds `CurrentAge` and `AddedAge` together
    and prints out the result:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第16行添加一个新方法，该方法将`CurrentAge`和`AddedAge`相加并打印出结果：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Call the new method inside `Start` with the following line:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行在`Start`中调用新方法：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Double-check that your code looks like the following screenshot before you
    run the script in Unity:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Unity中运行脚本之前，请确保你的代码看起来像以下截图：
- en: '![](img/B17573_02_06.png)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17573_02_06.png)'
- en: 'Figure 2.6: LearningCurve with new ComputeAge method'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.6：使用新的ComputeAge方法的学习曲线
- en: Save the file, and then go back and hit play in Unity to see the new **Console**
    output.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后返回Unity并播放以查看新的**控制台**输出。
- en: 'You defined your first method on lines 16 to 19 and called it on line 13\.
    Now, wherever `ComputeAge()` is called, the two variables will be added together
    and printed to the console, even if their values change. Remember, you set `CurrentAge`
    to `18` in the Unity Inspector, and the Inspector value will always override the
    value in a C# script:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第16到19行定义了第一个方法，并在第13行调用了它。现在，无论在哪里调用`ComputeAge()`，两个变量都会相加并打印到控制台，即使它们的值发生变化。记住，你在Unity检查器中将`CurrentAge`设置为`18`，检查器的值将始终覆盖C#脚本中的值：
- en: '![](img/B17573_02_07.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_07.png)'
- en: 'Figure 2.7: Console output from changing the variable value in the Inspector'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：在检查器中更改变量值时的控制台输出
- en: Go ahead and try out different variable values in the **Inspector** panel to
    see this in action! More details on the actual code syntax of what you just wrote
    are coming up in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**检查器**面板尝试不同的变量值，看看这个功能是如何工作的！关于你刚才编写的实际代码语法的更多细节将在下一章中介绍。
- en: With a bird's-eye view of methods under our belts, we're ready to tackle the
    biggest topic in the programming landscape—classes!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了方法的全景之后，我们准备好应对编程领域最大的主题——类！
- en: Introducing classes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍类
- en: 'We''ve seen how variables store information and how methods perform actions,
    but our programming toolkit is still somewhat limited. We need a way of creating
    a sort of super container, containing variables and methods that can be referenced
    from within the container itself. Enter classes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了变量如何存储信息以及方法如何执行操作，但我们的编程工具箱仍然有些有限。我们需要一种创建一种超级容器的方法，该容器包含可以在容器内部引用的变量和方法。这就是类的出现：
- en: '**Conceptually**, a class holds related information, actions, and behaviors
    inside a single container. They can even communicate with each other.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从概念上讲**，一个类在单个容器中持有相关的信息、操作和行为。它们甚至可以相互通信。'
- en: '**Technically**, classes are data structures. They can contain variables, methods,
    and other programmatic information, all of which can be referenced when an object
    of the class is created.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，类是数据结构。它们可以包含变量、方法和其他程序性信息，当创建类的对象时，所有这些都可以被引用。'
- en: '**Practically**, a class is a blueprint. It sets out the rules and regulations
    for any object (called an instance) created using the class blueprint.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，一个类是一个蓝图。它为使用该蓝图创建的任何对象（称为实例）设定了规则和条例。'
- en: You've probably realized that classes surround us not only in Unity but in the
    real world as well. Next, we'll take a look at the most common Unity class and
    how classes function in the wild.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，类不仅存在于Unity中，也存在于现实世界中。接下来，我们将查看最常用的Unity类以及类在现实世界中的功能。
- en: You can find an in-depth guide to classes in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Microsoft C#文档中找到关于类的深入指南，链接为[https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes)。
- en: A common Unity class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个常见的Unity类
- en: 'Before you wonder what a class looks like in C#, you should know that you''ve
    been working with a class this whole chapter. By default, every script created
    in Unity is a class, which you can see from the `class` keyword on line 5:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你好奇C#中的类看起来像什么之前，你应该知道，你整个章节都在使用类。默认情况下，在Unity中创建的每个脚本都是一个类，你可以从第5行的`class`关键字中看到：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MonoBehaviour` just means that this class can be attached to a GameObject
    in the Unity scene.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour`只是意味着这个类可以被附加到Unity场景中的GameObject上。'
- en: Classes can exist on their own, which we'll see when we create standalone classes
    in *Chapter 5*, *Working with Classes, Structs, and OOP*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以独立存在，我们将在第5章中看到这一点，即*使用类、结构体和面向对象编程*。
- en: The terms script and class are sometimes used interchangeably in Unity resources.
    For consistency, I'll be referring to C# files as scripts if they're attached
    to GameObjects and as classes if they are standalone.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity资源中，脚本和类有时可以互换使用。为了保持一致性，如果C#文件附加到GameObject上，我将将其称为脚本；如果它们是独立的，则称为类。
- en: Classes are blueprints
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类是蓝图
- en: For our last example, let's think about a local post office. It's a separate,
    self-contained environment that has properties, such as a physical address (a
    variable), and the ability to execute actions, such as sending out your mail (methods).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个例子，让我们思考一下当地邮局。它是一个独立、自包含的环境，具有诸如物理地址（一个变量）等属性，以及执行动作的能力，例如发送你的邮件（方法）。
- en: 'This makes a post office a great example of a potential class that we can outline
    in the following block of pseudocode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这使邮局成为一个很好的例子，我们可以用以下伪代码块来概述潜在的类：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The main takeaway here is that when information and behaviors follow a predefined
    blueprint, complex actions and inter-class communication become possible. For
    instance, if we had another class that wanted to send a letter through our `PostOffice`
    class, it wouldn''t have to wonder where to go to fire this action. It could simply
    call the `SendMail` function from the `PostOffice` class, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要启示是，当信息和行为遵循预定义的蓝图时，复杂的行为和类间通信成为可能。例如，如果我们有另一个类想要通过我们的`PostOffice`类发送信件，它就不必想知道在哪里执行这个动作。它可以直接调用`PostOffice`类的`SendMail`函数，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you could use it to look up the address of the post office so
    you know where to post your letters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以用它来查找邮局的地址，这样你就知道在哪里投递你的信件：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you're wondering about the use of periods (called dot notation) between words,
    we'll be diving into that in the next section—hold tight.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道单词之间点（称为点符号）的使用，我们将在下一节中深入探讨——请耐心等待。
- en: Communication among classes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类之间的通信
- en: Up until now, we've described classes and, by extension, Unity components as
    separate standalone entities; in reality, they are deeply intertwined. You'd be
    hard-pressed to create any kind of meaningful software application without invoking
    some kind of interaction or communication between classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们描述了类以及由此扩展的Unity组件作为独立的实体；实际上，它们是紧密相连的。你很难创建任何类型的有意义的应用软件而不需要调用某种类之间的交互或通信。
- en: 'If you remember the post office example from earlier, the example code made
    use of periods (or dots) to reference classes, variables, and methods. If you
    think of classes as directories of information, then dot notation is the indexing
    tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前提到的邮局例子，示例代码使用了点（或点）来引用类、变量和方法。如果你把类看作是信息目录，那么点符号就是索引工具：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Any variables, methods, or other data types within a class can be accessed with
    dot notation. This applies to nested, or subclass, information as well, but we'll
    tackle all those subjects when we get to *Chapter 5*, *Working with Classes, Structs,
    and OOP*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类内部的所有变量、方法或其他数据类型都可以使用点符号访问。这也适用于嵌套的或子类信息，但我们将所有这些主题留到第5章，即*使用类、结构体和面向对象编程*时再讨论。
- en: 'Dot notation is also what drives communication between classes. Whenever a
    class needs information about another class or wants to execute one of its methods,
    dot notation is used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 点符号也是驱动类之间通信的因素。每当一个类需要了解另一个类的信息或想要执行其方法时，就会使用点符号：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dot notation is sometimes referred to as the `.` operator, so don't be thrown
    off if you see it mentioned this way in documentation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点符号有时也被称为`.`运算符，所以如果你在文档中看到这种方式提到它，不要感到困惑。
- en: If dot notation doesn't quite click with you yet, don't worry, it will. It's
    the bloodstream of the entire programming body, carrying information and context
    wherever it's needed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有完全理解点符号，不要担心，你会的。它是整个编程身体的血液，携带信息和上下文到需要的地方。
- en: Now that you know a little more about classes, let's talk about the tool you'll
    use the most in your programming career—comments!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对类有了更多的了解，让我们来谈谈你在编程生涯中最常用的工具——注释！
- en: Working with comments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与注释一起工作
- en: You might have noticed that `LearningCurve` has an odd line of text (**10**
    in *Figure 2.6*) starting with two forward slashes, which were created by default
    with the script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`LearningCurve`中有一行奇怪的文本（*图2.6中的*第10行*）以两个斜杠开头，这些是在脚本中默认创建的。
- en: These are code comments! In C#, there are a few ways that you can use to create
    comments, and Visual Studio (and other code editing applications) will often make
    it even easier with built-in shortcuts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是代码注释！在C#中，你可以使用几种方法来创建注释，而Visual Studio（和其他代码编辑应用程序）通常会通过内置快捷方式使其更加容易。
- en: Some professionals wouldn't call commenting an essential building block of programming,
    but I'll have to respectfully disagree. Correctly commenting out your code with
    meaningful information is one of the most fundamental habits a new programmer
    can develop.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有些专业人士不会把注释称为编程的必要构建块，但我必须表示尊重地不同意。用有意义的信息正确注释代码是新手程序员可以培养的最基本的习惯之一。
- en: Single-line comments
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单行注释
- en: 'The following single-line comment is like the one we''ve included in `LearningCurve`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下单行注释就像我们在`LearningCurve`中包含的那样：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Visual Studio doesn't compile lines starting with two forward slashes (without
    empty space) as code, so you can use them as much as needed to explain your code
    to others or your future self.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 不会编译以两个斜杠开头（没有空格）的行作为代码，因此你可以根据需要尽可能多地使用它们来向他人或未来的自己解释代码。
- en: Multi-line comments
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多行注释
- en: 'Since it''s in the name, you''d be right to assume that single-line comments
    only apply to one line of code. If you want multi-line comments, you''ll need
    to use a forward slash and an asterisk, (`/*` and `*/` as opening and closing
    characters respectively) around the comment text:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它在名称中，所以你正确地假设单行注释仅适用于一行代码。如果你想使用多行注释，你需要在注释文本周围使用一个斜杠和一个星号（分别作为打开和关闭字符的`/*`和`*/`）：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also comment and uncomment blocks of code by highlighting them and using
    the `Cmd` + `/`shortcut on macOS and `Ctrl` + `K` + `C` on Windows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过突出显示代码块并使用macOS上的`Cmd` + `/`快捷键和Windows上的`Ctrl` + `K` + `C`快捷键来注释和取消注释代码块。
- en: Visual Studio also provides a handy auto-generated commenting feature; type
    in three forward slashes on the line preceding any line of code (variables, methods,
    classes, and more) and a summary comment block will appear.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 还提供了一个方便的自动生成注释功能；在代码（变量、方法、类等）之前的行中输入三个斜杠，就会显示一个摘要注释块。
- en: Seeing example comments is good, but putting them in your code is always better.
    It's never too early to start commenting!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看看示例注释是好的，但把它们放入你的代码中总是更好的。开始注释永远不会太早！
- en: Adding comments
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加注释
- en: 'Open up `LearningCurve` and add in three backslashes above the `ComputeAge()`
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LearningCurve`并在`ComputeAge()`方法上方添加三个反斜杠：
- en: '![](img/B17573_02_08.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_08.png)'
- en: 'Figure 2.8: Triple-line comment automatically generated for a method'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：为方法自动生成的三行注释
- en: You should see a three-line comment with a description of the method generated
    by Visual Studio from the method's name, sandwiched between two `<summary>` tags.
    You can, of course, change the text, or add new lines by hitting `Enter` just
    as you would in a text document; just make sure not to touch the `<summary>` tags
    or Visual Studio won't recognize the comments correctly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个由Visual Studio从方法名称生成的三行注释，其中包含对方法的描述，夹在两个`<summary>`标签之间。当然，你可以更改文本，或者通过按`Enter`键添加新行，就像在文本文档中做的那样；只是确保不要触摸`<summary>`标签，否则Visual
    Studio无法正确识别注释。
- en: 'The useful part about these detailed comments is clear when you want to know
    something about a method you''ve written. If you''ve used a triple forward slash
    comment, all you need to do is hover over the method name anywhere it''s called
    within a class or script, and Visual Studio will pop your summary:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想了解你编写的方法的某些内容时，这些详细注释的有用之处就变得很清晰。如果你使用了三斜杠注释，你只需要在任何地方将鼠标悬停在方法名称上（在类或脚本中调用时），Visual
    Studio 就会弹出你的摘要：
- en: '![](img/B17573_02_09.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_09.png)'
- en: 'Figure 2.9: Visual Studio pop-up info box with the comment summary'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：Visual Studio弹出信息框中的注释摘要
- en: Your basic programming toolkit is now complete (well, the theory drawer, at
    least). However, we still need to understand how everything we've learned in this
    chapter applies in the Unity game engine, which is what we'll be focusing on in
    the next section!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你的基本编程工具包现在已经完整（至少理论上是如此）。然而，我们仍然需要了解我们在这个章节中学到的所有内容如何在Unity游戏引擎中应用，这是我们将在下一节中关注的重点！
- en: Putting the building blocks together
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将构建块组合在一起
- en: With the building blocks squared away, it's time to do a little Unity-specific
    housekeeping before wrapping up this chapter. Specifically, we need to know more
    about how Unity handles C# scripts attached to game objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建块整理完毕后，是时候在结束这一章之前做一些Unity特定的家务了。具体来说，我们需要更多地了解Unity如何处理附加到游戏对象的C#脚本。
- en: For this example, we'll keep using our `LearningCurve` script and Main Camera
    GameObject.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将继续使用我们的`LearningCurve`脚本和主摄像机GameObject。
- en: Scripts become components
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本变成组件
- en: All GameObject components are scripts, whether they're written by you or the
    good people at Unity. The only difference is that Unity-specific components such
    as `Transform`, and their respective scripts just aren't supposed to be edited
    by users.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有GameObject组件都是脚本，无论是你自己编写的还是Unity团队编写的。唯一的区别是Unity特定的组件，如`Transform`及其相应的脚本，用户不应该对其进行编辑。
- en: The moment a script that you have created is dropped onto a GameObject, it becomes
    another component of that object, which is why it appears in the **Inspector**
    panel. To Unity, it walks, talks, and acts like any other component, complete
    with public variables underneath the component that can be changed at any time.
    Even though we aren't supposed to edit the components provided by Unity, we can
    still access their properties and methods, making them powerful development tools.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建的脚本被拖放到GameObject上时，它成为该对象的一个新组件，这就是为什么它出现在**检查器**面板中的原因。对于Unity来说，它就像任何其他组件一样行走、说话和行动，包括组件下可以随时更改的公共变量。尽管我们不应该编辑Unity提供的组件，但我们仍然可以访问它们的属性和方法，使它们成为强大的开发工具。
- en: Unity also makes some automatic readability adjustments when a script becomes
    a component. You might have noticed in *Figures 2.3* and *2.5* that when we added
    `LearningCurve` to Main Camera, Unity displayed it as `Learning Curve`, with `CurrentAge`
    changing to `Current Age`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本成为组件时，Unity也会进行一些自动的可读性调整。你可能已经注意到在*图2.3*和*2.5*中，当我们把`LearningCurve`添加到主摄像机时，Unity将其显示为`Learning
    Curve`，`CurrentAge`变为`Current Age`。
- en: 'We looked at how to update a variable in the **Inspector** panel in the *Variables
    act as placeholders* section, but it''s important to touch on how this works in
    more detail. There are three situations in which you can modify a property value:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何在**检查器**面板的*变量作为占位符*部分更新一个变量，但重要的是要详细说明其工作原理。你可以修改属性值的情况有以下三种：
- en: In **Play Mode** in the Unity Editor window
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity编辑器窗口的**播放模式**中
- en: In **Development Mode** in the Unity Editor window
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity编辑器窗口的**开发模式**中
- en: In the Visual Studio code editor
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio代码编辑器中
- en: Changes made in Play Mode take effect in real time, which is great for testing
    and fine-tuning gameplay. However, it's important to note that any changes made
    while in Play Mode will be lost when you stop the game and return to Development
    Mode.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放模式中做出的更改会实时生效，这对于测试和微调游戏玩法非常棒。然而，需要注意的是，在播放模式中做出的任何更改，当你停止游戏并返回到开发模式时将会丢失。
- en: When you're in Development Mode, any changes that you make to the variables
    will be saved by Unity. This means that if you were to quit Unity and then restart
    it, the changes would be retained.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发模式时，你对变量所做的任何更改都将由Unity保存。这意味着如果你退出Unity然后重新启动它，更改将被保留。
- en: The changes that you make to values in the **Inspector** panel while in Play
    Mode do not modify your script, but they will override any values you had assigned
    in your script when in Development Mode.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放模式中，你在**检查器**面板中对值所做的更改不会修改你的脚本，但它们将覆盖你在开发模式时在脚本中分配的任何值。
- en: 'Any changes made in Play Mode will always reset automatically when you stop
    Play Mode. If you need to undo any changes made in the **Inspector** panel, you
    can reset the script to its default (sometimes called initial) values. Click on
    the three vertical dots icon to the right of any component, and then select **Reset**,
    as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放模式中做出的任何更改，在停止播放模式时都会自动重置。如果你需要撤销在 **检查器** 面板中做出的更改，你可以将脚本重置为其默认值（有时也称为初始值）。点击任何组件右侧的三个垂直点图标，然后选择
    **重置**，如图下截图所示：
- en: '![](img/B17573_02_10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_10.png)'
- en: 'Figure 2.10: Script reset option in the Inspector'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：检查器中的脚本重置选项
- en: This should give you some peace of mind—if your variables get out of hand, there's
    always the hard reset.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能让你感到安心——如果你的变量失控了，总有硬重置的方法。
- en: A helping hand from MonoBehaviour
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自 MonoBehaviour 的援助之手
- en: Since C# scripts are classes, how does Unity know to make some scripts components
    and not others? The short answer is that `LearningCurve` (and any script created
    in Unity) inherits from `MonoBehaviour` (a default class provided by Unity). This
    tells Unity that the C# class can be transformed into a component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C# 脚本是类，Unity 如何知道将某些脚本作为组件而不是其他脚本？简短的答案是 `LearningCurve`（以及任何在 Unity 中创建的脚本）从
    `MonoBehaviour`（Unity 提供的默认类）继承。这告诉 Unity，C# 类可以被转换成组件。
- en: The topic of class inheritance is a bit advanced for this point of your programming
    journey; think of it as the `MonoBehaviour` class lending a few of its variables
    and methods to `LearningCurve`. *Chapter 5*, *Working with Classes, Struct, and
    OOP*, will cover class inheritance in practical detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承的话题对于你目前的编程旅程来说有点高级；把它想象成 `MonoBehaviour` 类向 `LearningCurve` 借用了一些变量和方法。*第五章*，*与类、结构体和面向对象编程一起工作*，将详细讲解类继承。
- en: The `Start()` and `Update()` methods that we've used belong to `MonoBehaviour`,
    which Unity runs automatically on any script attached to a GameObject. The `Start()`
    method runs once when the scene starts playing, while the `Update()` method runs
    once per frame (depending on the frame rate of your machine).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 `Start()` 和 `Update()` 方法属于 `MonoBehaviour`，Unity 会自动在任何附加到 GameObject
    的脚本上运行。`Start()` 方法在场景开始播放时运行一次，而 `Update()` 方法每帧运行一次（取决于你机器的帧率）。
- en: Now that your familiarity with Unity's documentation has gotten a nice bump,
    I've put together a short optional challenge for you to tackle!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 Unity 文档的熟悉度已经有所提高，我为你准备了一个简短的挑战，供你尝试！
- en: Hero's trial – MonoBehaviour in the Scripting API
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄的考验 – MonoBehaviour 在脚本 API 中
- en: 'Now it''s time for you to get comfortable using the Unity documentation on
    your own, and what better way than to look up some of the common `MonoBehaviour`
    methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让你自己熟悉使用 Unity 文档了，还有什么比查找一些常见的 `MonoBehaviour` 方法更好的方式呢：
- en: Try searching for the `Start()` and `Update()` methods in the Scripting API
    to gain a better understanding of what they do in Unity, and when
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在脚本 API 中搜索 `Start()` 和 `Update()` 方法，以更好地理解它们在 Unity 中的功能以及何时执行
- en: If you're feeling brave, go the extra step and have a look at the `MonoBehaviour`
    class in the manual for a more detailed explanation
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你感到勇敢，可以再进一步，查看手册中的 `MonoBehaviour` 类以获得更详细的解释
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've come a long way in a few short pages, but understanding the overarching
    theory of fundamental concepts such as variables, methods, and classes will give
    you a strong foundation to build on. Bear in mind that these building blocks have
    very real counterparts in the real world. Variables hold values like mailboxes
    hold letters; methods store instructions like recipes, to be followed for a predefined
    result; and classes are blueprints just like real blueprints. You can't build
    a house without a well-thought-out design to follow if you expect it to stay standing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在短短几页中我们已经走得很远了，但理解诸如变量、方法和类等基本概念的整体理论将为你打下坚实的基础。请记住，这些构建块在现实世界中都有非常真实的对应物。变量存储的值就像邮箱存储的信件一样；方法存储的指令就像食谱，需要遵循以获得预定义的结果；而类就像真正的蓝图。如果你希望房子能稳固地站立，那么没有经过深思熟虑的设计方案，你就不能建造房子。
- en: The rest of this book will take you on a deep dive into C# syntax from scratch,
    starting with more detail in the next chapter on how to create variables, manage
    value types, and work with simple and complex methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余部分将带你从零开始深入了解 C# 语法，下一章将更详细地介绍如何创建变量、管理值类型以及与简单和复杂方法一起工作。
- en: Pop quiz – C# building blocks
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验 – C# 基础知识
- en: What is the main purpose of a variable?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的主要用途是什么？
- en: What role do methods play in scripts?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法在脚本中扮演什么角色？
- en: How does a script become a component?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本是如何变成组件的？
- en: What is the purpose of dot notation?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点符号的作用是什么？
- en: JOIN us on Discord!
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上加入我们！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C# 专家以及哈里森·费罗内一起阅读这本书。提问，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，以及更多。
- en: Join Now!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code_9781801813945.png)'
