<html><head></head><body>
<div id="_idContainer034">
<h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.2.1">Optimizing Data Access with Entity Framework Core</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Before Entity Framework was introduced in 2008, developers used </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">ActiveX Data Objects</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">ADOs</span></strong><span class="koboSpan" id="kobo.7.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Object Linking and Embedding Database</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">OLE DB</span></strong><span class="koboSpan" id="kobo.11.1">) to access their data for applications. </span><span class="koboSpan" id="kobo.11.2">Since its introduction, Entity Framework has evolved over the years into a high-performance bridge between </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">object-oriented</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">OO</span></strong><span class="koboSpan" id="kobo.15.1">) systems and relational databases. </span><span class="koboSpan" id="kobo.15.2">It enables developers to use </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Language Integrated Query</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.18.1">LINQ</span></strong><span class="koboSpan" id="kobo.19.1">) syntax to perform complex queries using C#. </span><span class="koboSpan" id="kobo.19.2">However, some LINQ statements can be overwhelming for new developers. </span><span class="koboSpan" id="kobo.19.3">Since this is one of the most discussed topics when it comes to data access, we’ll cover various standards and implementations when using Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Framework Core.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">This chapter will be similar to </span><a href="B19493_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.22.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.23.1">, </span><em class="italic"><span class="koboSpan" id="kobo.24.1">CI/CD – Building Quality Software with Software</span></em><span class="koboSpan" id="kobo.25.1">, where we will review patterns for implementing Entity Framework Core to access data but also look at some common uses of Entity Framework Core in </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the industry.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">In this chapter, we’ll cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.29.1">Entity Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Core Implementations</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Common Entity Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Core </span></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">P</span></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">ractices</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Implementing the Theme </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Park Example</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">When you’ve finished reading this chapter, you’ll have a better understanding of the various design patterns and approaches you can use with Entity Framework Core and the various standards involved; we will end the chapter by applying these standards to a theme </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">park example.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Let’s get started by examining the various Entity Framework Core common implementations used by </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">many developers.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.41.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.42.1">I recommend using your favorite editor to view the GitHub repository. </span><span class="koboSpan" id="kobo.42.2">Our recommendations include </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.44.1">Visual Studio (preferably 2022 </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">or newer)</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Visual </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Studio Code</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.48.1">JetBrains Rider</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.49.1">The editor we’ll be using is Visual Studio Enterprise 2022, but any version (Community or Professional) will work with </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">We will also be using </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">SQL Server Management Studio</span></strong><span class="koboSpan" id="kobo.53.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.54.1">SSMS</span></strong><span class="koboSpan" id="kobo.55.1">) for our example at the end of the chapter. </span><span class="koboSpan" id="kobo.55.2">However, if you feel you don’t need to download another tool, you can view SQL Server data through Visual Studio 2022 as well without </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">installing SSMS.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.57.1">Downloading SQL Server Developer Edition</span></p>
<p class="callout"><span class="koboSpan" id="kobo.58.1">To run a local copy of SQL Server, download the Developer edition of SQL Server </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">from </span></span><a href="https://www.microsoft.com/en-us/sql-server/sql-server-downloads"><span class="No-Break"><span class="koboSpan" id="kobo.60.1">https://www.microsoft.com/en-us/sql-server/sql-server-downloads</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.61.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">The code for this chapter is located in Packt Publishing’s GitHub repository, which you can navigate to </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">here: </span></span><a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.64.1">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.65.1">.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.66.1">Entity Framework Core Implementations</span></h1>
<p><span class="koboSpan" id="kobo.67.1">Over the years, developers </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.68.1">have used Entity Framework Core in various ways. </span><span class="koboSpan" id="kobo.68.2">Some were </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">exceptionally </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.70.1">creative</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">In this section, we’ll discuss the following </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">architectural approaches:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">Repository/Unit </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">of Work</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.76.1">Specification</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.77.1">Extension Methods</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.78.1">While these implementations are based on real-world experiences, they are merely observations, and, as mentioned in </span><a href="B19493_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.79.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.80.1">, the decision will fall on teams and/or community members</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.81.1"> as to the right approach for the application and </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">trade-offs incurred.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.83.1">Repository/Unit of Work</span></h2>
<p><span class="koboSpan" id="kobo.84.1">While this implementation </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.85.1">has already caused some</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.86.1"> friction among developers, it’s a common pattern seen with early adopters of ASP.NET Entity Framework applications (including me). </span><span class="koboSpan" id="kobo.86.2">However, it’s been said by community members it’s not an efficient way to use Entity Framework architecturally because of the duplication </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">of repositories.</span></span></p>
<h3><span class="koboSpan" id="kobo.88.1">Implementation</span></h3>
<p><span class="koboSpan" id="kobo.89.1">Out of the</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.90.1"> box, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">DbContext</span></strong><span class="koboSpan" id="kobo.92.1"> follows</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.93.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">repository</span></strong><span class="koboSpan" id="kobo.95.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">unit of work</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.97.1">design pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">The repository design pattern is a class that manages objects between the business domain and the mapping of properties from the database using lists and single </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">domain objects.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Repositories are self-contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">DbContext</span></strong><span class="koboSpan" id="kobo.102.1">, which is considered a Unit of Work design pattern. </span><span class="koboSpan" id="kobo.102.2">A unit of work pattern manages a list of objects (as repositories do) using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">ChangeTracker</span></strong><span class="koboSpan" id="kobo.104.1"> to track changes in a transaction-like state and organizes how each change should be saved and how to resolve </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">concurrency problems.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">In Entity Framework, repositories are represented as </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">DbSet</span></strong><span class="koboSpan" id="kobo.108.1"> instances in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">DbContext</span></strong><span class="koboSpan" id="kobo.110.1"> where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">DbContext</span></strong><span class="koboSpan" id="kobo.112.1"> is the unit of </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">work itself.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">Let’s look at an example. </span><span class="koboSpan" id="kobo.114.2">We have a database called </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">ThemePark</span></strong><span class="koboSpan" id="kobo.116.1"> and it contains two tables: attractions and locations. </span><span class="koboSpan" id="kobo.116.2">We’ve also created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">ThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.118.1"> class to manage our entities. </span><span class="koboSpan" id="kobo.118.2">If you’ve worked with Entity Framework at any time, you’ve likely encountered the repository design pattern implemented in a </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">similar fashion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
public class AttractionRepository
{
    private readonly ThemeParkDbContext _context;
    public AttractionRepository(ThemeParkDbContext context)
    {
        _context = context;
    }
    public List&lt;Attraction&gt; GetAttractions()
    {
        return _context.Attractions.ToList();
    }
    public Attraction GetAttraction(int id)
    {
        return _context.Attractions.FirstOrDefault(e =&gt; e.Id == id,             null);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.121.1">What is wrong </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.122.1">with</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.123.1"> this implementation? </span><span class="koboSpan" id="kobo.123.2">While this does separate</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.124.1"> the</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.125.1"> business rules from the data access, it’s an unnecessary layer for applications when a repository layer already exists in </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">One of the jokes I love from the developer community is, “</span><em class="italic"><span class="koboSpan" id="kobo.130.1">What are the two hardest problems in computer science? </span><span class="koboSpan" id="kobo.130.2">Cache invalidation, naming things, and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.131.1">off-by-one errors.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">Consider this a case of naming things wrong. </span><span class="koboSpan" id="kobo.133.2">What if we changed the name to </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Service</span></strong><span class="koboSpan" id="kobo.135.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">like so?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">AttractionService</span></strong><span class="koboSpan" id="kobo.139.1">
{
    private readonly ThemeParkDbContext _context;
    public </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">AttractionService</span></strong><span class="koboSpan" id="kobo.141.1">(ThemeParkDbContext context)
    {
        _context = context;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.142.1">Why </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Service</span></strong><span class="koboSpan" id="kobo.144.1">? </span><span class="koboSpan" id="kobo.144.2">The repository pattern is already contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">DbContext</span></strong><span class="koboSpan" id="kobo.146.1"> as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">DbSet&lt;Attraction&gt;</span></strong><span class="koboSpan" id="kobo.148.1">. </span><span class="koboSpan" id="kobo.148.2">The service uses the repository pattern to retrieve the data and perform additional updates before returning the data. </span><span class="koboSpan" id="kobo.148.3">Changing the class name from </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Repository</span></strong><span class="koboSpan" id="kobo.150.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">Service</span></strong><span class="koboSpan" id="kobo.152.1"> signifies we don’t need a repository pattern on top of an already existing repository. </span><span class="koboSpan" id="kobo.152.2">When creating a service for individual repositories (</span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">DbSet</span></strong><span class="koboSpan" id="kobo.154.1"> instances), this provides </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.155.1">multiple</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.156.1"> benefits, </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">as follows:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">Logically partitioning data access</span></strong><span class="koboSpan" id="kobo.159.1">—While we’re isolating a repository to one service, that doesn’t mean we won’t need related entities from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">DbContext</span></strong><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">Add </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">.Include()</span></strong><span class="koboSpan" id="kobo.163.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">DbContext</span></strong><span class="koboSpan" id="kobo.165.1"> to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">related entities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.167.1">Flexibility</span></strong><span class="koboSpan" id="kobo.168.1">—The service dependency injects a </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">DbContext</span></strong><span class="koboSpan" id="kobo.170.1"> instance through the constructor, allowing for multiple approaches to accessing data including LINQ statements, stored procedures, or even call </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">raw SQL.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Additional processing</span></strong><span class="koboSpan" id="kobo.173.1">—When calling a data access service, there are times when the data requires more massaging before returning the results. </span><span class="koboSpan" id="kobo.173.2">While this is temporarily acceptable in this service, it may require refactoring to the appropriate </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.174.1">business</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.175.1"> entity or processing </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.176.1">through </span><a id="_idIndexMarker242"/><span class="No-Break"><span class="koboSpan" id="kobo.177.1">another class.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.178.1">The benefits seen through this approach could easily pivot the already existing repository naming convention to a </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">service moniker.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.180.1">The Specification Pattern</span></h2>
<p><span class="koboSpan" id="kobo.181.1">Developers are always looking</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.182.1"> to reuse </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.183.1">existing code and make it as flexible as possible for maintenance purposes; update a line of code and it could change the retrieval of </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">data required.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">The specification pattern is solving the problem of attaching requirements to an object with the rise of </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.187.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.188.1">TDD</span></strong><span class="koboSpan" id="kobo.189.1">) making it easier to understand the results retrieved </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.190.1">through a query. </span><span class="koboSpan" id="kobo.190.2">It uses a base class to retrieve data as either a list or a single entity while writing the least amount </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">of code.</span></span></p>
<h3><span class="koboSpan" id="kobo.192.1">Implementation</span></h3>
<p><span class="koboSpan" id="kobo.193.1">When creating a specification class, you need two classes: one for processing the request and the specification for what you need. </span><span class="koboSpan" id="kobo.193.2">The specification class is built exactly as the class implies: it defines the filter for a single entity or list of entities, sorting and grouping, and inclusion of various related entities. </span><span class="koboSpan" id="kobo.193.3">Everything you can do with a LINQ query can be defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">specification class.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">A sample specification’s contract (interface) could have the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">following structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
public interface ISpecification&lt;T&gt;
{
    Expression&lt;Func&lt;T, bool&gt;&gt; Filter { get; }
    Expression&lt;Func&lt;T, object&gt;&gt; OrderBy { get; }
    Expression&lt;Func&lt;T, object&gt;&gt; OrderByDescending { get; }
    List&lt;Expression&lt;Func&lt;T, object&gt;&gt;&gt; Includes { get; }
    Expression&lt;Func&lt;T, object&gt;&gt; GroupBy { get; }
}</span></pre> <p><span class="koboSpan" id="kobo.198.1">The implementation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">Specification</span></strong><span class="koboSpan" id="kobo.200.1"> class would look </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
public class Specification&lt;TEntity&gt;: ISpecification&lt;TEntity&gt; where TEntity: class
{
    public Expression&lt;Func&lt;TEntity, bool&gt;&gt; Filter { get; }
    public Expression&lt;Func&lt;TEntity, object&gt;&gt; OrderBy { get; set; } =         null!;
    public Expression&lt;Func&lt;TEntity, object&gt;&gt; OrderByDescending { get;         set; } = null!;
    public Expression&lt;Func&lt;TEntity, object&gt;&gt; GroupBy { get; set; } =         null!;
    public List&lt;Expression&lt;Func&lt;TEntity, object&gt;&gt;&gt; Includes { get; } =         null!;
    public Specification(Expression&lt;Func&lt;TEntity, bool&gt;&gt; filter)
    {
        Filter = filter;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.203.1">As mentioned at the start</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.204.1"> of this </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.205.1">section, the properties in the class represent all of the different aspects of retrieving data: filtering, including, sorting, </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">and grouping.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Once you have the specification defined, we need a way to build our query based on a specification. </span><span class="koboSpan" id="kobo.207.2">In this case, we’ll create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">SpecificationBuilder&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
public static class SpecificationBuilder&lt;TEntity&gt; where TEntity: class
{
    public static IQueryable&lt;TEntity&gt; GetQuery(IQueryable&lt;TEntity&gt; inputQuery,
        ISpecification&lt;TEntity&gt; specification)
    {
        var query = inputQuery;
        if (specification == null)
        {
            return query;
        }
        if (specification.Filter != null)
        {
            query = query.Where(specification.Filter);
        }
        if (specification.Includes != null
            &amp;&amp; specification.Includes.Any())
        {
            foreach (var include in specification.Includes)
            {
                query = query.Include(include);
            }
        }
        if (specification.OrderBy != null)
        {
            query = query
                .OrderBy(specification.OrderBy);
        }
        else if (specification.OrderByDescending != null)
        {
            query = query
                .OrderByDescending(specification.OrderByDescending);
        }
        if (specification.GroupBy != null)
        {
            query = query
                .GroupBy(specification.GroupBy)
                .SelectMany(x =&gt; x);
        }
        return query;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.211.1">In the preceding code</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.212.1"> snippet, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">SpecificationBuilder</span></strong><span class="koboSpan" id="kobo.214.1"> class </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.215.1">creates a LINQ query to retrieve the data. </span><span class="koboSpan" id="kobo.215.2">Since everything is self-contained and completely independent of itself, the class was marked </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">as static.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">With every specification class, we need a way to retrieve the data. </span><span class="koboSpan" id="kobo.217.2">We’ll make the class abstract and call </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">BaseSpecificationService&lt;TEntity&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
public abstract class BaseSpecificationService&lt;TEntity&gt; where TEntity : class
{
    private readonly ThemeParkDbContext _context;
    protected BaseSpecificationService(ThemeParkDbContext context)
    {
        _context = context;
    }
    protected ISpecification&lt;TEntity&gt; Specification { get; set; } =         null!;
    protected IQueryable&lt;TEntity&gt; GetQuery()
    {
        return SpecificationBuilder&lt;TEntity&gt;
            .GetQuery(_context.Set&lt;TEntity&gt;().AsQueryable(),                  Specification);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.222.1">In the preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">BaseSpecificationService</span></strong><span class="koboSpan" id="kobo.224.1"> is what we’ll use to create our specific data </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.225.1">needs. </span><span class="koboSpan" id="kobo.225.2">We require a specification</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.226.1"> property and a way to retrieve the query based on </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">that specification.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">With the specification pattern, the names of your classes are the specifications of the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">data required.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Let’s look at another example with a simple </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
public class Product
{
    public string Name { get; private set; }
    public int Price { get; private set; }
}</span></pre> <p><span class="koboSpan" id="kobo.234.1">If you need a list of all products below </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">$5.00</span></strong><span class="koboSpan" id="kobo.236.1">, a specification class would look like </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
public class GetProductsLessThanFiveDollars : BaseSpecificationService&lt;Product&gt;
{
    public GetProductsLessThanFiveDollars(InventoryDbContext context) : base(context)
    {
        Specification = new Specification&lt;Product&gt;(product =&gt; product.Price &lt;= 5);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.239.1">This code creates the specification and uses it to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">the results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
var productsBelowFiveDollarsSpecification = new GetProductsLessThanFiveDollars(_context);
var results = productsBelowFiveDollarsSpecification.GetQuery().ToList();</span></pre> <p><span class="koboSpan" id="kobo.242.1">The preceding code would generate a list of products of less than </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">5 dollars.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">While this is a simple</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.245.1"> example, there are more</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.246.1"> extensive libraries dedicated to this type of Entity Framework design pattern, such as Steve Smith’s specification library located </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">at </span></span><a href="https://specification.ardalis.com"><span class="No-Break"><span class="koboSpan" id="kobo.248.1">https://specification.ardalis.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.249.1">.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.250.1">Extension Methods</span></h2>
<p><span class="koboSpan" id="kobo.251.1">If we revisit the</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.252.1"> repository/unit of work method, the association between specific business logic and the data should be relatively close to </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">DbContext</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">Instead of creating service classes while passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">DbContext</span></strong><span class="koboSpan" id="kobo.256.1"> in, why not just attach your data access to the actual </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">DbSet</span></strong><span class="koboSpan" id="kobo.258.1"> instance itself as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">IQueryable</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.260.1">extension method?</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">The ability to add specific calls to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">DbContext</span></strong><span class="koboSpan" id="kobo.263.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">DbSet</span></strong><span class="koboSpan" id="kobo.265.1"> instance is extremely attractive because they can be placed anywhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">The extension method approach does require a bit of discipline where specific entities are concerned. </span><span class="koboSpan" id="kobo.267.2">For example, if you created a product entity, your </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">IQueryable</span></strong><span class="koboSpan" id="kobo.269.1"> extension methods should return only products and not order entities. </span><span class="koboSpan" id="kobo.269.2">Mixing order extension methods with product extension methods is usually </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">frowned upon.</span></span></p>
<h3><span class="koboSpan" id="kobo.271.1">Implementation</span></h3>
<p><span class="koboSpan" id="kobo.272.1">Extension methods allow </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.273.1">your code to be more direct when </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">accessing data.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Since we can attach extension methods to interfaces, let’s define a simple interface for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">ThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.277.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
public interface IThemeParkDbContext
{
    DbSet&lt;Attraction&gt; Attractions { get; set; }
    DbSet&lt;Location&gt; Locations { get; set; }
    DbSet&lt;TEntity&gt; Set&lt;TEntity&gt;() where TEntity : class;
    DatabaseFacade Database { get; }
}</span></pre> <p><span class="koboSpan" id="kobo.280.1">With our theme park idea, we built </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">AttractionExtensions</span></strong><span class="koboSpan" id="kobo.282.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">LocationExtensions</span></strong><span class="koboSpan" id="kobo.284.1"> files for data access, </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
public static class AttractionExtensions
{
    public static List&lt;Attraction&gt; GetAttractions(this IThemeParkDbContext context)
    {
        return context.Attractions.ToList();
    }
    public static Attraction GetAttraction(this IThemeParkDbContext context, int id)
    {
        return context.Attractions
            .Include(t =&gt; t.Location)
            .FirstOrDefault(e =&gt; e!.Id == id, null)!;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.287.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">AttractionExtensions</span></strong><span class="koboSpan" id="kobo.289.1"> file has only two methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">GetAttractions()</span></strong><span class="koboSpan" id="kobo.291.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">GetAttraction()</span></strong><span class="koboSpan" id="kobo.293.1">, which we attach to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">ThemeParkDbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">LocationExtensions</span></strong><span class="koboSpan" id="kobo.298.1"> file is </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.299.1">small and compact as well, as we can </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">see here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
public static class LocationExtensions
{
    public static List&lt;Location&gt; GetLocations(this IThemeParkDbContext context)
    {
        return context.Locations.ToList();
    }
    public static Location GetLocation(this IThemeParkDbContext context, int id)
    {
        return context.Locations.FirstOrDefault(e =&gt; e!.Id == id, null)!;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.302.1">In this section, we reviewed some of the more common Entity Framework Core design patterns used in real-world applications such as the repository and unit of work patterns, the specification pattern, and the extension methods approach to </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">accessing data.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">While these are common in the .NET community, there are other patterns available for Entity Framework Core allowing even easier access to your data, but they do have drawbacks. </span><span class="koboSpan" id="kobo.304.2">Let’s look at these </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">more closely:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.306.1">Partitioned DbContext instances</span></strong><span class="koboSpan" id="kobo.307.1">—One </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">DbContext</span></strong><span class="koboSpan" id="kobo.309.1"> instance would exist for each partitioned feature in the application; for example, one </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">DbContext</span></strong><span class="koboSpan" id="kobo.311.1"> instance for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">Books</span></strong><span class="koboSpan" id="kobo.313.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">BookAuthors</span></strong><span class="koboSpan" id="kobo.315.1"> tables and another </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">DbContext</span></strong><span class="koboSpan" id="kobo.317.1"> instance for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Orders</span></strong><span class="koboSpan" id="kobo.319.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Books</span></strong><span class="koboSpan" id="kobo.321.1"> tables. </span><span class="koboSpan" id="kobo.321.2">One drawback is possible state conflicts across multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">DbContext</span></strong><span class="koboSpan" id="kobo.323.1"> instances (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.324.1">NOT</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1"> recommended).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.326.1">Stored procedures</span></strong><span class="koboSpan" id="kobo.327.1">—Using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">DbContext</span></strong><span class="koboSpan" id="kobo.329.1"> instance as a conduit while making direct calls to stored procedures without using LINQ. </span><span class="koboSpan" id="kobo.329.2">One drawback occurs when changes are made to a stored procedure and the mapping code doesn’t reflect the results returned, causing </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">an error.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.331.1">In the next section, we’ll be </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.332.1">covering some common practices when using Entity Framework Core in </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">real-world applications.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.334.1">Common Entity Framework Core Practices</span></h1>
<p><span class="koboSpan" id="kobo.335.1">Even though Entity</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.336.1"> Framework patterns provide additional structure to your code, there are also common practices to keep in mind when building applications with </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">Entity Framework.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">In this section, we’ll review some of the more common uses of Entity Framework and their benefits: how </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">async</span></strong><span class="koboSpan" id="kobo.340.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">await</span></strong><span class="koboSpan" id="kobo.342.1"> can make your application more scalable, logging your queries to optimize SQL output, creating resource files to hold seed data for tables, learning about deferred execution, speeding up access with a read-only method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.344.1">, leveraging the database where it makes sense, and using AutoMapper to map source objects to </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">destination objects.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.346.1">Confirming Your Model</span></h2>
<p><span class="koboSpan" id="kobo.347.1">If you’re using the</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.348.1"> database-first approach (where</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.349.1"> you have an existing database to work with) to generate your models, confirm that all of your indexes, relationships, identity fields, and foreign keys represent your model accordingly before using </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Scaffold-DbContext</span></strong><span class="koboSpan" id="kobo.351.1">. </span><span class="koboSpan" id="kobo.351.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Scaffold-Database</span></strong><span class="koboSpan" id="kobo.353.1"> command creates your </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">DbContext</span></strong><span class="koboSpan" id="kobo.355.1"> instance based on an existing database. </span><span class="koboSpan" id="kobo.355.2">The command takes everything into account when creating the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">If your relationships aren’t correct, this will cause problems with navigation properties on your model when accessing them through your </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">DbContext</span></strong><span class="koboSpan" id="kobo.360.1"> instance. </span><span class="koboSpan" id="kobo.360.2">Essentially, your navigation properties will </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">be empty.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.362.1">Using Async/Await</span></h2>
<p><span class="koboSpan" id="kobo.363.1">For I/O-bound activities, such </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.364.1">as database </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.365.1">operations, it makes sense to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">async</span></strong><span class="koboSpan" id="kobo.367.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">await</span></strong><span class="koboSpan" id="kobo.369.1"> for creating scalable applications. </span><span class="koboSpan" id="kobo.369.2">While it may not be apparent when running the web application on a developer machine, the true benefits of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">async</span></strong><span class="koboSpan" id="kobo.371.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">await</span></strong><span class="koboSpan" id="kobo.373.1"> appear when you have hundreds of people hitting the website </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">The reason to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">async</span></strong><span class="koboSpan" id="kobo.377.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">await</span></strong><span class="koboSpan" id="kobo.379.1"> is to avoid blocking thread requests. </span><span class="koboSpan" id="kobo.379.2">When a request comes into a web server, the .NET Framework maintains a pool of threads to process those incoming requests. </span><span class="koboSpan" id="kobo.379.3">For each request, a thread is taken from the pool and used to process the request synchronously. </span><span class="koboSpan" id="kobo.379.4">While the thread is being used, nothing can use it until the process is completed (“blocking thread”). </span><span class="koboSpan" id="kobo.379.5">Once the process completes, the thread is released and returned to the thread pool for the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">next request.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">When you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">async</span></strong><span class="koboSpan" id="kobo.383.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">await</span></strong><span class="koboSpan" id="kobo.385.1">, you aren’t taking a thread from the thread pool. </span><span class="koboSpan" id="kobo.385.2">Anything in between </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">async</span></strong><span class="koboSpan" id="kobo.387.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">await</span></strong><span class="koboSpan" id="kobo.389.1"> doesn’t use a thread, which means you’re saving memory in the long run and allowing your application to </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">perform better.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">When it comes to making Entity Framework Core calls, it’s best to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">async</span></strong><span class="koboSpan" id="kobo.393.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">await</span></strong><span class="koboSpan" id="kobo.395.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">performance reasons.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.397.1">Logging Your Queries</span></h2>
<p><span class="koboSpan" id="kobo.398.1">Most </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">Database Administrators</span></strong><span class="koboSpan" id="kobo.400.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.401.1">DBA</span></strong><span class="koboSpan" id="kobo.402.1">) are</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.403.1"> averse</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.404.1"> to programmers using Entity Framework mainly because it allows ad hoc queries to be passed to the database and executed immediately. </span><span class="koboSpan" id="kobo.404.2">The reason for this is that most feel Entity Framework is a black box and can’t see what’s happening behind the scenes. </span><span class="koboSpan" id="kobo.404.3">A method was added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">OptionsBuilder</span></strong><span class="koboSpan" id="kobo.406.1"> class specifically for logging to help solve </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">this issue.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">For simple logging using Entity Framework, place a </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">.LogTo()</span></strong><span class="koboSpan" id="kobo.410.1"> method into your </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">DbContext</span></strong><span class="koboSpan" id="kobo.412.1"> instance’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">onConfiguring()</span></strong><span class="koboSpan" id="kobo.414.1"> method, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            optionsBuilder.LogTo(Console.WriteLine);
        }
    }</span></pre> <p><span class="koboSpan" id="kobo.417.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">.LogTo()</span></strong><span class="koboSpan" id="kobo.419.1"> method takes </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.420.1">either an action or a func on where to send the log data. </span><span class="koboSpan" id="kobo.420.2">In this snippet, we are simply logging to the </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">debug window.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Simple logging to the debug window is the easiest to implement because it’s a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Console.Write()</span></strong><span class="koboSpan" id="kobo.424.1"> method and doesn’t require any third-party packages, but there are other types of logging available that are just as easy to plug into Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">Framework Core.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.426.1">Additional logging options</span></p>
<p class="callout"><span class="koboSpan" id="kobo.427.1">For additional logging methods in Entity Framework Core, navigate to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">URL: </span></span><a href="https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/"><span class="No-Break"><span class="koboSpan" id="kobo.429.1">https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.430.1">.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.431.1">Using Resources for Large Seed Data</span></h2>
<p><span class="koboSpan" id="kobo.432.1">If you need initial seed</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.433.1"> data </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.434.1">with fewer than 20 records for your tables, it’s easy to just hand-code the records on the fly in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">DbContext</span></strong><span class="koboSpan" id="kobo.436.1"> instance </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">.HasData()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">But what if you have a table requiring hundreds of records seeded on the initial load? </span><span class="koboSpan" id="kobo.440.2">Hand-typing records can be painful </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">using code.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">One hidden gem in .NET is the use of resource files for storing simple strings (normally used for localization/translation), but it can also be used for populating </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">seed data.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">Let’s use our </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Attraction</span></strong><span class="koboSpan" id="kobo.446.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Location</span></strong><span class="koboSpan" id="kobo.448.1"> table example and show the steps for creating seed data in a </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">resource file:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.450.1">Open SQL Server </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">Management Studio.</span></span></li>
<li><span class="koboSpan" id="kobo.452.1">Confirm the seeded records are created the way you want them in each table (</span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Attraction</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.454.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.457.1">Perform a </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">SELECT</span></strong><span class="koboSpan" id="kobo.459.1"> operation with the JSON clause added to the end, as shown in the following </span><a id="_idIndexMarker268"/><span class="No-Break"><span class="koboSpan" id="kobo.460.1">SQL</span></span><span class="No-Break"><a id="_idIndexMarker269"/></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1"> snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.462.1">
SELECT
     [ID]
     ,[Name]
     ,[LocationID]
FROM [dbo].Attraction
FOR JSON AUTO, INCLUDE_NULL_VALUES</span></pre></li> <li><span class="koboSpan" id="kobo.463.1">Click on the result, and a new result pane will open with your JSON. </span><span class="koboSpan" id="kobo.463.2">The JSON will look </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.465.1">
[{
        "ID": 1,
        "Name": "Twirly Ride",
        "LocationID": 2
    }, {
        "ID": 2,
        "Name": "Mine car Coaster",
        "LocationID": 5
    }, {
        "ID": 3,
        "Name": "Haunted House",
        "LocationID": 3
    }, {
        "ID": 4,
        "Name": "Dragon Ride",
        "LocationID": 2
    }, {
        "ID": 5,
        "Name": "Gift Shop",
        "LocationID": 1
    }, {
        "ID": 6,
        "Name": "Space Ride",
        "LocationID": 4
    }, {
        "ID": 7,
        "Name": "Shootout at OK Corral\/Lazer Tag",
        "LocationID": 5
    }
]</span></pre></li> <li><span class="koboSpan" id="kobo.466.1">Copy the</span><a id="_idIndexMarker270"/> <span class="No-Break"><span class="koboSpan" id="kobo.467.1">JSON</span></span><span class="No-Break"><a id="_idIndexMarker271"/></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1"> returned.</span></span></li>
<li><span class="koboSpan" id="kobo.469.1">Open Visual Studio and add a resource file through Visual Studio. </span><span class="koboSpan" id="kobo.469.2">The following screenshot illustrates </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">the process:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 5.1 – Creating a resource file called SeedResource.resx in Visual Studio" src="image/Figure_5.01_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 5.1 – Creating a resource file called SeedResource.resx in Visual Studio</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.473.1">Your resource file will </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.474.1">automatically</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.475.1"> open. </span><span class="koboSpan" id="kobo.475.2">For our example, we’ll create the resource with the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">following parameters:</span></span><ol><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.477.1">Name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">AttractionRecords</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.480.1">Value</span></strong><span class="koboSpan" id="kobo.481.1">: &lt;Paste your </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">JSON here&gt;</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.483.1">Comment</span></strong><span class="koboSpan" id="kobo.484.1">: (These are optional, but added to identify for </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">other devs)</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.486.1">Access Modifier</span></strong><span class="koboSpan" id="kobo.487.1">: Change this </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.489.1">Internal</span></strong></span></li></ol></li>
</ol>
<p><span class="koboSpan" id="kobo.490.1">Your resource record should look </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.492.1"><img alt="Figure 5.2 – A sample record in the Resources.resx file containing JSON for the Attraction table" src="image/Figure_5.02_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.493.1">Figure 5.2 – A sample record in the Resources.resx file containing JSON for the Attraction table</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.494.1">Save your </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">resource file.</span></span></li>
<li><span class="koboSpan" id="kobo.496.1">Open your </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">AttractionConfiguration</span></strong><span class="koboSpan" id="kobo.498.1"> class and locate your </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">.HasData()</span></strong><span class="koboSpan" id="kobo.500.1"> attraction in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">DbContext</span></strong><span class="koboSpan" id="kobo.502.1"> instance and replace it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.504.1">
var records = JsonSerializer.Deserialize&lt;Attraction[]&gt;(
    SeedResource.AttractionRecords);
if (records != null)
{
    builder.HasData(records);
}</span></pre></li> <li><span class="koboSpan" id="kobo.505.1">Save and compile</span><a id="_idIndexMarker274"/> <span class="No-Break"><span class="koboSpan" id="kobo.506.1">your</span></span><span class="No-Break"><a id="_idIndexMarker275"/></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1"> code.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.508.1">If you require a large amount of seed data, it’s better to create resource files with JSON data instead of hand-coding all of the records into code. </span><span class="koboSpan" id="kobo.508.2">Finding long pages of large JSON strings in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">DbContext</span></strong><span class="koboSpan" id="kobo.510.1"> configuration may seem jarring to </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">some developers.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.512.1">Understanding Deferred Execution</span></h2>
<p><span class="koboSpan" id="kobo.513.1">Deferred execution when</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.514.1"> making</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.515.1"> Entity Framework calls means the LINQ query is delayed until the realized value </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">is required.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
var products = this.Products.ToList().Where(r =&gt; r.CategoryId == 15);</span></pre> <p><span class="koboSpan" id="kobo.520.1">While this will return the correct list of items, it’s not as performant as it could be. </span><span class="koboSpan" id="kobo.520.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">.ToList()</span></strong><span class="koboSpan" id="kobo.522.1"> method added after the Products </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">DbSet</span></strong><span class="koboSpan" id="kobo.524.1"> instance, the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Products</span></strong><span class="koboSpan" id="kobo.526.1"> table is loaded, and </span><em class="italic"><span class="koboSpan" id="kobo.527.1">then</span></em><span class="koboSpan" id="kobo.528.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">.Where()</span></strong><span class="koboSpan" id="kobo.530.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">is executed.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">A better approach to this call is shown in this </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
var products = this.Products.Where(r =&gt; r.CategoryId == 15).ToList();</span></pre> <p><span class="koboSpan" id="kobo.535.1">This will also return the correct list of products. </span><span class="koboSpan" id="kobo.535.2">However, the SQL query generated will contain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">WHERE</span></strong><span class="koboSpan" id="kobo.537.1"> clause as well to filter out and return the correct list of records. </span><span class="koboSpan" id="kobo.537.2">The difference here is the first query will return </span><em class="italic"><span class="koboSpan" id="kobo.538.1">all</span></em><span class="koboSpan" id="kobo.539.1"> of the records from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Products</span></strong><span class="koboSpan" id="kobo.541.1"> table and then filter out the resulting product list using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">.Where()</span></strong><span class="koboSpan" id="kobo.543.1"> LINQ method. </span><span class="koboSpan" id="kobo.543.2">Remember—LINQ can also work </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">with arrays.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">With the second query, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">WHERE</span></strong><span class="koboSpan" id="kobo.547.1"> clause is created when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">.ToList()</span></strong><span class="koboSpan" id="kobo.549.1"> method is encountered, and a subset of records is returned and “materialized” into entities, making this query </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">extremely faster.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">Deferred execution means you are building the query and not executing it immediately. </span><span class="koboSpan" id="kobo.551.2">When you are</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.552.1"> finished </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.553.1">building your query and want the results, end your LINQ query with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">.ToList()</span></strong><span class="koboSpan" id="kobo.555.1"> method. </span><span class="koboSpan" id="kobo.555.2">If you are looking for one entity, end your LINQ query with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">.Single()</span></strong><span class="koboSpan" id="kobo.557.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">.SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.559.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">.First()</span></strong><span class="koboSpan" id="kobo.561.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">FirstOrDefault()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1"> method.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.565.1">Using a Read-Only State with .AsNoTracking()</span></h2>
<p><span class="koboSpan" id="kobo.566.1">When retrieving</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.567.1"> data </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.568.1">using LINQ, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">DbContext</span></strong><span class="koboSpan" id="kobo.570.1"> instance has something called a </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">ChangeTracker</span></strong><span class="koboSpan" id="kobo.572.1">, which is updated when an entity’s state changes. </span><span class="koboSpan" id="kobo.572.2">This requires overhead—a small amount of overhead, but </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">overhead</span></span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">,</span></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1"> nonetheless.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">If you are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">DbSet</span></strong><span class="koboSpan" id="kobo.578.1"> in a read-only situation, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.580.1"> method at the beginning of a LINQ statement to make Entity Framework Core aware it doesn’t need to track the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">models returned.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">For example, the following LINQ query will retrieve an </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">Attraction</span></strong><span class="koboSpan" id="kobo.584.1"> object without updating </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">ChangeTracker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
public Attraction GetAttraction(int id)
{
    return _context.Attractions
        .AsNoTracking()
        .FirstOrDefault(e =&gt; e!.Id == id, null)!;
}</span></pre> <p><span class="koboSpan" id="kobo.589.1">In the previous snippet, we </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.590.1">place the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.592.1"> method right after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">DbSet</span></strong><span class="koboSpan" id="kobo.594.1"> instance, letting</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.595.1"> Entity Framework Core know not to </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">track anything.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.597.1">Leveraging the Database</span></h2>
<p><span class="koboSpan" id="kobo.598.1">While it’s tempting to</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.599.1"> create </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.600.1">everything in Entity Framework, there are times when it’s better to let the database perform </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">data-heavy operations.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">With one project, I was writing large LINQ queries in code to retrieve entities into memory. </span><span class="koboSpan" id="kobo.602.2">Then, I continued to write code to calculate a count of items, sum up totals, and finally relate all types of child entities to the main collection </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">of entities.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">I realized I could achieve all of this using a stored procedure and bypass Entity Framework altogether. </span><span class="koboSpan" id="kobo.604.2">A stored procedure took care of these details, and Entity Framework Core simply retrieved </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">the results.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">Sometimes, it makes sense to let the database do the heavy lifting of calculating data and provide the results to the application since that’s </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">its job.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.608.1">Avoiding the Manual Property Mapping</span></h2>
<p><span class="koboSpan" id="kobo.609.1">When sending entities </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.610.1">to </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.611.1">render on the client, it’s best to create </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">Data Transfer Objects</span></strong><span class="koboSpan" id="kobo.613.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.614.1">DTOs</span></strong><span class="koboSpan" id="kobo.615.1">). </span><span class="koboSpan" id="kobo.615.2">You only want to send the minimal amount of data relevant to the currently displayed </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">web page.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">However, it gets tiring writing manual left-to-right property assignments. </span><span class="koboSpan" id="kobo.617.2">One recommendation is to </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">use AutoMapper.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">AutoMapper enables the automation of mapping properties from one source object to a destination object. </span><span class="koboSpan" id="kobo.619.2">In the following example, we are taking an </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Attraction</span></strong><span class="koboSpan" id="kobo.621.1"> object and copying the properties over to a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">AttractionDto</span></strong><span class="koboSpan" id="kobo.623.1"> object. </span><span class="koboSpan" id="kobo.623.2">AutoMapper handles the heavy lifting for us by matching properties and copying the data over to the </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">destination object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
var config = new MapperConfiguration(cfg =&gt;
    cfg.CreateMap&lt;Attraction, AttractionDto&gt;());
IMapper mapper = new Mapper(config);
var dest = mapper.Map&lt;Attraction, AttractionDto&gt;(attractionObject);</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">AutoMapper</span></strong><span class="koboSpan" id="kobo.627.1"> is very flexible, fills a specific need, has been downloaded from NuGet over 400,000 times, and is used by over 100,000 developers in </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">the industry.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.629.1">AutoMapper Library</span></p>
<p class="callout"><span class="koboSpan" id="kobo.630.1">The previous functionality only</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.631.1"> scratches the surface of what AutoMapper is capable of doing for developers. </span><span class="koboSpan" id="kobo.631.2">To understand the full potential of AutoMapper, visit the fully documented website at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">URL: </span></span><a href="https://docs.automapper.org/"><span class="No-Break"><span class="koboSpan" id="kobo.633.1">https://docs.automapper.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.634.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">In this section, we</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.636.1"> learned about the common uses of Entity Framework Core in the industry. </span><span class="koboSpan" id="kobo.636.2">We learned it’s best to confirm your database before creating your database-first </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">DbContext</span></strong><span class="koboSpan" id="kobo.638.1"> instance, along with leveraging the capabilities of your database instead of hand-coding everything, and about how to perform read-only queries with </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.640.1">, why it’s best to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">async</span></strong><span class="koboSpan" id="kobo.642.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">await</span></strong><span class="koboSpan" id="kobo.644.1">, and why understanding deferred execution is important when writing LINQ queries. </span><span class="koboSpan" id="kobo.644.2">Finally, we examined how to log your queries, how to seed your tables using resource files, and avoiding manual left-to-right property mapping by </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">using AutoMapper.</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">In the next section, we’ll take a simple Entity Framework application and apply all of our standards, and even learn some new techniques </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">as well.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.648.1">Implementing the Theme Park Example</span></h1>
<p><span class="koboSpan" id="kobo.649.1">There is so much to digest</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.650.1"> when it comes to Entity Framework Core and all of its features. </span><span class="koboSpan" id="kobo.650.2">There are entire books on Entity Framework Core; this chapter will only scratch </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">the surface.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.652.1">Entity Framework Core Recommendation</span></p>
<p class="callout"><span class="koboSpan" id="kobo.653.1">For a deeper dive into Entity Framework Core, I would recommend Mastering Entity Framework Core 2.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">at </span></span><a href="https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133"><span class="No-Break"><span class="koboSpan" id="kobo.655.1">https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.656.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">In this section, we’ll update a small ASP.NET application that uses Entity Framework Core with all of the standards we discussed in the previous section, with a few additional techniques to help understand Entity Framework Core </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">even better.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.659.1">Overview</span></h2>
<p><span class="koboSpan" id="kobo.660.1">In this example, we’ll </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.661.1">use our previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">DbContext</span></strong><span class="koboSpan" id="kobo.663.1"> instance with </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">Attractions</span></strong><span class="koboSpan" id="kobo.665.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">Locations</span></strong><span class="koboSpan" id="kobo.667.1"> tables and create a database with </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">SQL Server.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.669.1">Running the Web Application</span></p>
<p class="callout"><span class="koboSpan" id="kobo.670.1">The application used for this section is found on the Packt Publishing GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">under </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">Ch5/EFApplication</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">We’ll keep our data access simple. </span><span class="koboSpan" id="kobo.674.2">We’ll use the services approach, accepting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">DbContext</span></strong><span class="koboSpan" id="kobo.676.1"> instance to retrieve our data and create our database from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">DbContext</span></strong><span class="koboSpan" id="kobo.678.1"> model in </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">SQL Server.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.680.1">Creating the Database</span></h2>
<p><span class="koboSpan" id="kobo.681.1">For our application to work, we</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.682.1"> need to create our database in SQL Server. </span><span class="koboSpan" id="kobo.682.2">Since we already have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">DbContext</span></strong><span class="koboSpan" id="kobo.684.1"> instance created (using the model-first approach), we can use Entity Framework Core migrations to build </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">our tables.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">To create your local version of the database, type the following into the Package Manager Console (navigate to this via </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">View</span></strong><span class="koboSpan" id="kobo.688.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">Other Windows</span></strong><span class="koboSpan" id="kobo.690.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">Package </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.692.1">Manager Console</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.694.1">
Update-Database</span></pre> <p><span class="koboSpan" id="kobo.695.1">Once you hit </span><em class="italic"><span class="koboSpan" id="kobo.696.1">Enter</span></em><span class="koboSpan" id="kobo.697.1">, Entity Framework Core will locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">DbContext</span></strong><span class="koboSpan" id="kobo.699.1"> instance, read the configuration file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.701.1">), and use the connection string to create our database and tables </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.702.1">with seed data </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">in it.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.704.1">Adding an Asynchronous Read-Only Mode</span></h2>
<p><span class="koboSpan" id="kobo.705.1">Our first matter at </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.706.1">hand is</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.707.1"> to apply </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">async</span></strong><span class="koboSpan" id="kobo.709.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">await</span></strong><span class="koboSpan" id="kobo.711.1"> to the correct services so that we can scale the application later. </span><span class="koboSpan" id="kobo.711.2">If you are working with an existing ASP.NET application with Entity Framework and want to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">async</span></strong><span class="koboSpan" id="kobo.713.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">await</span></strong><span class="koboSpan" id="kobo.715.1"> methods, it’s best to start with the database. </span><span class="koboSpan" id="kobo.715.2">If you are creating a “greenfield” project (meaning from scratch), use </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">async</span></strong><span class="koboSpan" id="kobo.717.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">await</span></strong><span class="koboSpan" id="kobo.719.1"> methods right away to save yourself </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">headaches later.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">AttractionService</span></strong><span class="koboSpan" id="kobo.723.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">LocationService</span></strong><span class="koboSpan" id="kobo.725.1"> classes, we can convert all LINQ calls </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
public List&lt;Attraction&gt; GetAttractions()
{
    return _context.Attractions
        .ToList();
}</span></pre> <p><span class="koboSpan" id="kobo.728.1">We convert them into the following </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">async</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">await</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.734.1">
public async Task&lt;List&lt;Attraction&gt;&gt; GetAttractionsAsync()
{
    return await _context.Attractions
        .ToListAsync();
}</span></pre> <p><span class="koboSpan" id="kobo.735.1">Also, since we’re not creating, updating, or deleting data, we can safely say this is a read-only query. </span><span class="koboSpan" id="kobo.735.2">So, we can apply a </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.737.1"> method to the query, </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.739.1">
public async Task&lt;List&lt;Attraction&gt;&gt; GetAttractionsAsync()
{
    return await _context.Attractions
        .AsNoTracking()
        .ToListAsync();
}</span></pre> <p><span class="koboSpan" id="kobo.740.1">As mentioned before, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.742.1"> method will reduce the Entity Framework </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.743.1">overhead</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.744.1"> since we aren’t tracking the model’s state but are simply populating </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">the model.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.746.1">Including Child Entities</span></h2>
<p><span class="koboSpan" id="kobo.747.1">When we query </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.748.1">our attractions, we </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.749.1">also want the attraction’s location. </span><span class="koboSpan" id="kobo.749.2">How do we include the location (stored in a separate table) in </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">our query?</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">As we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">GetAttractionsAsync()</span></strong><span class="koboSpan" id="kobo.753.1"> method, we place a </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">.Include()</span></strong><span class="koboSpan" id="kobo.755.1"> method to retrieve the related entity. </span><span class="koboSpan" id="kobo.755.2">Our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">GetAttractionsAsync()</span></strong><span class="koboSpan" id="kobo.757.1"> method is modified to match the </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
public async Task&lt;List&lt;Attraction&gt;&gt; GetAttractionsAsync()
{
    return await _context.Attractions
        .AsNoTracking()
        .Include(r=&gt; r.Location)
        .ToListAsync();
}</span></pre> <p><span class="koboSpan" id="kobo.760.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">.Include()</span></strong><span class="koboSpan" id="kobo.762.1"> method relies heavily on the database relationships you created when building your model. </span><span class="koboSpan" id="kobo.762.2">I’ll refer you back to the “confirming your model” best practice we previously</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.763.1"> discussed. </span><span class="koboSpan" id="kobo.763.2">Entity </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.764.1">Framework Core uses the model’s relationships to load </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">related entities.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.766.1">Extending your Model</span></h2>
<p><span class="koboSpan" id="kobo.767.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">Location</span></strong><span class="koboSpan" id="kobo.769.1"> model, we </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.770.1">need a </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.771.1">way to know how many attractions are available at a location; we need a new property </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">AttractionCount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">While this is a simple property added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">Location</span></strong><span class="koboSpan" id="kobo.777.1"> class, there are multiple decisions to be </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">made here.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">First, let’s create a new file under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">Partials</span></strong><span class="koboSpan" id="kobo.781.1"> folder with the same class </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">name, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.785.1">
namespace EFApplication.DataContext.Models;
public partial class Location
{
    public int AttractionCount { get; set; }
}</span></pre> <p><span class="koboSpan" id="kobo.786.1">In the preceding code snippet, something may look strange. </span><span class="koboSpan" id="kobo.786.2">Even though the file is located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">Partials</span></strong><span class="koboSpan" id="kobo.788.1"> folder, </span><em class="italic"><span class="koboSpan" id="kobo.789.1">the partial namespace has to be the same namespace as the entities’ primary model</span></em><span class="koboSpan" id="kobo.790.1"> for the partial to work. </span><span class="koboSpan" id="kobo.790.2">.NET projects typically follow the convention of namespaces matching </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">folder structures.</span></span></p>
<p><span class="koboSpan" id="kobo.792.1">When we run our application, we should experience a problem with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">Location</span></strong><span class="koboSpan" id="kobo.794.1"> model as it currently stands, as </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">represented here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.796.1"><img alt="Figure 5.3 – The error message when you create a property on an Entity Framework object" src="image/Figure_5.03_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.797.1">Figure 5.3 – The error message when you create a property on an Entity Framework object</span></p>
<p><span class="koboSpan" id="kobo.798.1">What Entity Framework Core is telling us is there isn’t an </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">AttractionCount</span></strong><span class="koboSpan" id="kobo.800.1"> field in the table and it can’t populate the property since it </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">doesn’t exist.</span></span></p>
<p><span class="koboSpan" id="kobo.802.1">We have three options here, </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.804.1">Place a </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">[NotMapped]</span></strong><span class="koboSpan" id="kobo.806.1"> attribute on the property so that it doesn’t try to populate the property and count our attractions </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">by hand.</span></span></li>
<li><span class="koboSpan" id="kobo.808.1">Create a SQL Server function to calculate a calculated property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">AttractionCount</span></strong><span class="koboSpan" id="kobo.810.1"> and return it so that it can populate our </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">extra property.</span></span></li>
<li><span class="koboSpan" id="kobo.812.1">Automatically count the number of attractions already in </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">the model.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.814.1">Let’s focus on </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.815.1">implementing </span><em class="italic"><span class="koboSpan" id="kobo.816.1">option 3</span></em><span class="koboSpan" id="kobo.817.1"> as </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.818.1">a quick hit </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">for success.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">While we do need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">[NotMapped]</span></strong><span class="koboSpan" id="kobo.822.1"> attribute so that Entity Framework Core doesn’t try to load it, we’ll change the property into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">expression-bodied</span></strong><span class="koboSpan" id="kobo.824.1"> property. </span><span class="koboSpan" id="kobo.824.2">We could make this an auto property ( </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">{get;set;}</span></strong><span class="koboSpan" id="kobo.826.1">), but we’re only using this as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">get</span></strong><span class="koboSpan" id="kobo.828.1"> property, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.830.1">
public partial class Location
{
    [NotMapped]
    public int AttractionCount =&gt; Attractions.Count;
}</span></pre> <p><span class="koboSpan" id="kobo.831.1">Keep in mind this is assuming you have a foreign-key relationship in your SQL Server instance created to load the attractions when a location is loaded. </span><span class="koboSpan" id="kobo.831.2">If you don’t have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">.Include()</span></strong><span class="koboSpan" id="kobo.833.1"> method, your attraction count will </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">be 0.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">In this section, we learned how to create databases using the model-first approach, how to add an asynchronous, read-only mode using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.837.1"> method so the state isn’t attached to the objects, how to include child entities when retrieving a parent model, and finally, how to extend your model using a partial class and attaching a </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">[NotMapped]</span></strong><span class="koboSpan" id="kobo.839.1"> attribute</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.840.1"> to properties, letting</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.841.1"> Entity Framework know whether it should map a field to </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">the property.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.843.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.844.1">In this chapter, we learned about three different Entity Framework Core patterns including Repository and Unit of Work, Specification, and Extension Methods and how to implement each one into your </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">own projects.</span></span></p>
<p><span class="koboSpan" id="kobo.846.1">Then, we examined some of the standards in the industry, such as confirming your model, adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">async</span></strong><span class="koboSpan" id="kobo.848.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">await</span></strong><span class="koboSpan" id="kobo.850.1"> to your LINQ calls, implementing logging, using resource files for seeding data, and understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">deferred execution.</span></span></p>
<p><span class="koboSpan" id="kobo.852.1">We also reviewed how to perform read-only queries and how to leverage the database by letting it perform </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">data-intensive procedures.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">Finally, we applied these standards to an existing application with a way to create our database using the model-first approach, then examined how to add an asynchronous, read-only mode using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.856.1"> method so that state isn’t attached to objects, how to include child entities when retrieving a parent model, and finally, how to extend your model while letting Entity Framework know which properties to populate and which properties </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">to ignore.</span></span></p>
<p><span class="koboSpan" id="kobo.858.1">In the next chapter, we’ll learn about UI standards with MVC, Razor Pages, ViewComponents, HTMLHelpers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">Task Runners.</span></span></p>
</div>
</body></html>