- en: Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"They are angry and they are hungry. Beware, the sweet-tooth pandas are getting
    closer for your delicious cake!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Animations and artificial intelligence are at the core of giving life to an
    **Non-Playing Characters** (**NPCs**) or complex objects in games. The former
    makes NPCs appear dynamic and not static; the latter gives them an intelligence,
    with which they can move and act into the world.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains how to use the animation system of Unity, with a particular
    focus on 2D animations. We will cover artificial intelligence and what it can
    do in video games later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the chapter will focus on the rich and sophisticated animation
    system of Unity (sometimes referred to as Mecanim). In explaining each part, we
    will bring, bit by bit, our evil pandas to life.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the second part of the chapter, we will give the evil pandas the
    possibility to move around the map, to trigger actions such as dying or eating
    so much cake that they will explode... *literally*!
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: Animation clips and how to create and handle them from Sprite Sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Animator and how to build a finite state machine for animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting objects with an Animator component to trigger animations and make
    the animation machine working
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a waypoint system to move the sweet-tooth pandas around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like all the other chapters of this book, you will find the *Homework* section
    at the end. It has a range of different exercises for you to do to improve your
    skills and implement a range of different functionalities in your game. So, let's
    get ready to learn how to bring our evil pandas to life.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The graphic package that we are using for this book contains an animation Sprite
    Sheet for our terrible sweet-tooth pandas. Therefore, be sure to have the Sprite
    Sheet imported as **Sprite** and to set **Sprite Mode** to **Multiple**. In fact,
    you should have all single frames in a different sprite. Remember to rename them
    so that you will be less confused later on. The same applies if you are using
    your own graphics.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00445.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An evil panda is looking forward to eat your cake
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life and all of its creatures are dynamic. We move, and our movements, even
    the subtlest of ones, express emotions. If we were to remove such things, even
    the tiniest smile, life would become dull and static. Animation effects can range
    from the simplest of things such as a flag waving to a dragon flying. Just look
    around you, inside and outside; something will be moving or will move from time
    to time. Even stones move, albeit with wind, something knocking them, or someone
    skipping them across water.
  prefs: []
  type: TYPE_NORMAL
- en: Unity has a complex animation system, also known as **Mecanim**, which requires
    time to get used to. It includes different components. Some of these are specifically
    for 3D animations; others can be used for both 2D and 3D. Usually, animating in
    3D is harder than in 2D since it requires tweaking of many parameters, and therefore
    much more practice is needed to master it. If you are interested in learning more
    about 3D animation in Unity, I suggest that you to read a specific book about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will focus on animating only in 2D. As such, our workflow
    becomes simple enough that it can be explained within this chapter. In particular,
    we will go through the following workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating some files called animation clips, to store our animations. We will
    do this starting from animation Sprite Sheets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a finite-state machine to control the flow of the animations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a script to control the finite-state machine triggers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically, in this section, we will see how to animate our terrible sweet-tooth
    pandas. In our graphic package, we can find the animation Sprite Sheets of the
    panda under the `Graphic/Enemies` folder. Of course, all the Sprite Sheets should
    already be sliced, as we have seen back in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity* and if you are using
    your own graphics, it is better if all the single sprites have the same dimensions.
    But before we go any further in exploring Mecanim, let's go through some background
    information about animation in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: A historical overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *animation* derives from the Latin word *animates*, which is the past
    participle of the verb *animare*; that means *give breath to*. The verb derives
    from the word *anima*, which means *life, breath*, originating from the Greek
    word *anemos*, literally *wind*, which in turn descend from the Sanskrit word
    *aniti*, meaning *breathes*. It was only during the 1742 that the verb *to animate*
    was used for the first time with the sense of *give life to*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern animations are based on the concept of motion. Therefore, it''s worthwhile
    to mention that the first studies of motion were conducted by the Greek Philosopher
    *Ζήνων ὁ Ἐλεάτης* (known in English as *Zeno of Elea*) during the 4th century
    B.C. We can read about many of his ideas in works by another Greek philosopher:
    *Ἀριστοτέλης* (known in English as *Aristotle*). Zeno is famous for conceiving
    many paradoxes about motion, exploring the problem to prove the inexistence of
    motion. One of these paradoxes is the arrow paradox (also known as **Fletcher''s
    paradox**). We can read a little bit about this from Aristotle''s book Physics
    IV, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If everything when it occupies an equal space is at rest, and if that which
    is in locomotion is always occupying such a space at any moment, the flying arrow
    is therefore motionless."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![A historical overview](img/image00446.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Zeno's Fletcher's paradox described by Aristotle. You don't see the arrow
    moving towards the target, but just moments in which the arrow is static, albeit
    in different positions. Therefore, motion is an illusion.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding picture, the paradox claims the motionlessness
    of the arrow, since in each instant the arrow is in a very particular position
    in space and it is static in that instant. Besides the many philosophical implications
    and solutions to the paradox, it's interesting to note that the same concept applies
    nowadays for animation. Animations in movies and video games (to name a few) are
    just a series of static frames, which, in a rapid succession, give the illusion
    of motion.
  prefs: []
  type: TYPE_NORMAL
- en: Animations in video games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animations help to bring our creations to life. They make the living more vibrant
    and the dead even creepier! The development of animation has come a long way since
    the pixel art graphics to what can only be described as an uncanny valley of movement.
    In some cases, the animations are so life like that for a moment we forget that
    we're in an alternate reality.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go back to the start of game animation. Space Invaders, Donkey Kong,
    and Tempest. If you have ever experienced one of these games, then you will know
    what I mean when a lot can be conveyed by very simple animation, whether it is
    translating side to side with Space Invaders, jumping to dodge barrels in Donkey
    Kong, or rotating in Tempest. However, as time progressed, so too did the animation
    techniques that we have become all too familiar with. With the introduction of
    3D games and consequently characters, we have seen animations enter another dimension...
    literally. But despite their polygonal bodies and ridged movements, such as the
    following image of Lara Croft (though not so much nowadays), animations allow
    us to simply interact with a game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations in video games](img/image00447.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Taken from the gameplay of Lara Croft in Tomb Raider I
  prefs: []
  type: TYPE_NORMAL
- en: One good philosophy behind including animation is to think of animations as
    a way of communicating with your audience. Sometimes, emotions such as love, excitement,
    and hate are great ways to communicate feelings, just like body movements such
    as running, jumping, and attacking are good ways to indicate a state that the
    player is currently experiencing. However, animation doesn't just include the
    player; objects such as trees, and animals, and those who are not playing, or
    NPC, also interact and move about the game space, sometimes just as any controlled
    player would. Some of the most prolific examples of the use of animation with
    NPCs are in **Role Playing Games** (**RPGs**).
  prefs: []
  type: TYPE_NORMAL
- en: Many characters that you interact with develop a feeling about you. For example,
    if you constantly answer them with an abrupt response, they are likely to display
    facial expressions of despise, or shock like the next image. Where, on the other
    hand, if you're warm, friendly, and offer a helping hand, then their facial expressions
    are likely to be more welcoming.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations in video games](img/image00448.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shepard, clearly not laughing at a joke (Mass Effect series)
  prefs: []
  type: TYPE_NORMAL
- en: Timing is everything, so when it comes to animations, make sure that they happen
    when they are supposed to. Pressing ***X*** to jump and the jump happening only
    3 seconds later is not going to end well, for your game or the player. It is not
    enough to just animate a character or an object, but you've to add them up to
    create an immersive environment. The importance of being immersed within a game
    is vital if you want your player to come back for more. If you have clunky animation
    that causes frustration, chances are that the player won't be persistent, unless
    perhaps the story is extremely intriguing. Even the trees in most games animate,
    even with subtle swaying or leaves flickering with the wind. In this way, it's
    better than having giant poles of static wood sticking out from the ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to consider when it comes to animation is the frame rate and,
    in turn, the hardware. You may have a wonderful animation sequence, such as the
    epic cut scene like the fight in Crisis Core: Final Fantasy VII between Sephiroth,
    Genesis, and Angeal (as shown in the following image); another example is the
    gameplay while you''re killing enemies in Battlefield 4\. But if there were a
    delay, well, it would have been pretty much nothing! When creating games for Unity,
    it is very important to consider this, especially when you are targeting mobile
    devices. While many mobile devices have the ability to play some resource-heavy
    media, not all do. Therefore, if your ultimate device won''t be able to keep up,
    your intense efforts are likely to go in vain, unless of course you find another
    device to target. This is mostly the case with 3D games on mobile devices, and
    you can find out more here in the official Unity documentation: [https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I recommend that you visit the preceding link once you've finished the chapter
    so as to have a better understanding of the animation system in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations in video games](img/image00449.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Gameplay screenshot of Genesis and Sephiroth fighting in Crisis Core: Final
    Fantasy VII'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out this site for some great tips for using animation in mobile games:
    [www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging](http://www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an overview of animations in video games, let's head back to
    Unity to discover what it handles with animations, starting with the general workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow for animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have understood why animations are so important for video games,
    let's give them a closer look. Unity's animation system is based on the concept
    of animation clips; we will explore this in more detail in the next section. As
    the name suggests, they are just clips containing data for a single animation
    (with a few exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: Animation clips are organized into a structure that is similar to a flowchart
    system, where different nodes are connected to others (like the next screenshot).
    This system is called an Animator Controller and it acts as a state machine. It
    keeps track of which clip should currently be played and determines when the animations
    should change or blend together.
  prefs: []
  type: TYPE_NORMAL
- en: '![Workflow for animations](img/image00450.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A very simple Animator Controller might only contain a small amount of clips.
    For example, one clip may be an object breaking, the other a fan rotating. On
    the other hand, a more advanced Animator Controller is likely to contain a lot
    more animations, for instance, all actions related to the main character, such
    as running, walking, idling, dying, and so on. In addition, animations may blend
    between multiple clips in order to look more fluid-like and less robotic, unless
    of course that is your intention!
  prefs: []
  type: TYPE_NORMAL
- en: Unity's animation system also has many special features, especially when using
    humanoid characters. These features allow you to retarget human-like or humanoid
    animations from any source, such as motion capture, the Unity asset store, or
    software such as Maya or Blender, and then apply them to your own character model.
    In addition to applying these animations, you are also able to adjust muscle definitions
    on characters. These special features are enabled by Unity's Avatar system, where
    humanoid characters are mapped to a common internal format (we won't see this
    in detail, but you can learn more in the optional section at the end of the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the animation clips, the Animator Controller, and the Avatar, are
    brought together on a gameObject via the Animator Component. This component references
    an Animator Controller and (if required) the Avatar for the model in question.
    The Animator Controller in turn contains the references to the animation clips
    it uses.
  prefs: []
  type: TYPE_NORMAL
- en: Animations clips and the Animator component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of Unity's animation system, there are Animation Clips. These components
    contain information that relate to an object's animation, such as whether or not
    they need to change their translation (position), their rotation, and so on, as
    the animation takes place. Animation clips can be 2D or 3D and are often made
    in programs such as 3D Studio Max, Flash, Maya, Blender, and even Photoshop. In
    addition to using software, animations can be created manually, such as rigging
    a 3D character (giving it a skeleton to move) or creating movement-by-movement
    sprites where each movement is drawn out. Remember the old Disney cartoons? Well
    they used similar processes to bring us some of our most beloved memories. However,
    if your game requires something that isn't too complex such as opening and closing
    doors, you are able to do this in Unity. Unity offers a tool known as the the
    Animation window (more about this later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of 2D, these animation clips can contain an arbitrary sequence of
    sprites, like single frames in a movie, and change them over time so to give the
    illusion of motion. Usually, in 2D game development, sprite sheets are used for
    these purposes (like we anticipated in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A
    Flat World in Unity"), *A Flat World in Unity*). As such, our graphic package
    contains these animation sprite sheets as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations clips and the Animator component](img/image00451.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Another useful way to think about Animation clips is to pretend that they are
    actions, such as pick up an object, walk, or jump.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most advanced cases, Animation clips can contain part of an action that can
    be blended or merged with other animation clips.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our pandas, we have the following animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Walk**: When our panda will move along the path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Die**: When the player''s cupcake towers will take the panda down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hit**: When the player''s cupcake towers will hit the panda'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eat**: When the panda reaches the end of the level and eats a slice of the
    player''s cake'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As such, we need to create four different animation clips, one for each of these.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Animation clips with a controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The method explained in this section is a rapid way to start to create the first
    Animation clip, starting from a sprite sheet, and as a side effect, a controller
    will be created. However, we will deal with it later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, create an empty game object in the scene, and rename it to `Panda`
    (or if you prefer, `Sweet-Tooth_Panda`). Eventually, you'll want to store it,
    once finished working on it, inside a prefab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in the project panel, if we select `animation_panda_sprite_sheet` and expand
    it, we will have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Animation clips with a controller](img/image00452.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All the single Sprites/frames of the animation should be the same size. By ensuring
    this in the beginning, it allows you to avoid many headaches later on. Therefore,
    if the Sprite Sheet is well done, it should be sliced without difficultly with
    the **Grid By Cell Count** mode in the Sprite Editor, as we did in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity*. In our package,
    our Sprite Sheet is already good to go with each Sprite distributed evenly, but
    if you're using your own graphic and the Sprite Sheet doesn't have all the frames
    of the same size, you might want to modify it within a graphics program (such
    as Photoshop or Gimp) so that the sprites are distributed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the final result in the Sprite Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Animation clips with a controller](img/image00453.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if you move the slider at the bottom part of the project panel (as
    we learned in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in
    Unity"), *A Flat World in Unity*), you are able to see all the single sprites,
    as the following image shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Animation clips with a controller](img/image00454.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select all the Sprites that belong to the animations of the walking Panda,
    and drag them onto the **Panda** game object we have created before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Animation clips with a controller](img/image00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In our case, we have 11 sprites for the Walking animation, then 5 sprites for
    the Hit animation, 10 for the Die animation, and finally 16 for the Eat animation
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may happen that the last Sprite is equal to the first one. Depending on the
    case, you might not want it because it is likely to cause a disruption in the
    animation, such as a delay in a walking sequence. In that case, you can just select
    all the sprites but the last one.
  prefs: []
  type: TYPE_NORMAL
- en: Unity will ask you where to save the animation clip and under which name. We
    can name it `Panda_Walk_Animation` and save it in our `Animation` folder. If you
    don't have it, you can create it under the `Asset` folder. In this way, as we
    discussed in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in
    Unity"), *A Flat World in Unity*, we keep our project clean and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: When we select the `Panda` object, we can notice that in the Inspector two components
    have been added. One is a **Sprite Renderer**, which we have already discussed
    in previous chapters. The other is an **Animator** component. Let's see it in
    detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Animation clips with a controller](img/image00456.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you navigate in the **Animation** folder, other than the animation file we
    have just created, you will also find an Animator controller called `Panda` (or
    `Sweet-Tooth_Panda`, since the name is taken from the Game Object). For our purposes,
    it's better to rename it as something that describes it better, such as `PandaAnimatorController`.
    We will learn more about this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Animator component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main function of the Animator component is to hold a reference to an Animator
    Controller, which defines how our animation clips should be played. Furthermore,
    it controls when and how to blend and/or transition between them. We will explore
    the controller in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Animator component has some parameters that can adjusted. Let''s see the
    main ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller**: This is the reference to the Animator Controller, and it''s
    the most important variable. If not set, the Animator component can''t work. In
    the previous picture, the controller is set to `Panda` (or `PandaAnimatorController`
    if you have renamed it), which is a controller we just created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avatar**: A parameter only for 3D Humanoid characters, so you can ignore
    it (however, if you are interested in learning more, check out the *More about
    Animations* section later in the chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apply Root Motion**: You can ignore this too (however, if you are interested
    in the learning more, check out the *More about Animations* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update Mode**: Specifies when the Animator is updated and which timescale
    it should use. The **Normal** mode updates the controller in sync with the update
    calls, and the Animator''s speed matches the current timescale. If the timescale
    is slowed, animations will slow down to match. The **Animate Physics** mode instead
    updates the Animator in sync with the **FixedUpdate** calls, which are used by
    the Physic engine. This is useful when the object you are animating has a physical
    interaction, for instance, if a character needs to push or pull a rigid body (more
    about Physics in the next chapter). Finally, the **Unscaled Time** mode updates
    the Animator in sync with the Update calls, like the **Normal** mode, but the
    current timescale is ignored and it always plays at 100% of its speed. For instance,
    this mode is useful when you pause the game but you still want to animate part
    of the UI or the pause menu itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Culling Mode**: Specifies the culling mode for animations (more on this in
    the *More about Animations* section later in the chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, at the bottom of the Animator component, there is an information
    box with some useful information about the Animator controller we are using. For
    now, the only information that is relevant is **Clip Count**, which tells you
    how many animation clips are used by the controller. You can find out more about
    this information box in the *More about Animations* section.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator component](img/image00457.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the other animation clips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we need to create the remaining animation clips respectively for when the
    pandas die, eat or get hit. This time, we want to do it without generating the
    controller. We have two choices. In the first, we still keep dragging and dropping
    the other groups of Sprites onto the **Panda** game object as we did previously.
    As a result, Unity will still ask to give a name and a location for the animation
    clip, but it won't generate another controller. This is the fastest way. However,
    there is another one. It involves the **Animation** window, but for the sake of
    learning we will use this second method to create the remaining Animation clips.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, open the **Animation** windows (click on the top bar menu on **Window**
    | **Animation** or use the shortcut *Ctrl* + **6**). Then, select your **Panda**
    from the **Hierarchy** panel. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the other animation clips](img/image00458.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Animation** window allows you to create animations within Unity. It uses
    interpolation techniques between key frames to compute the position and rotation
    (along with other parameters) between each frame. It also supports a recording
    functionality as well as a curve editor. In 2D game development, this is not much
    used if animation Sprite Sheets are available, like our case (unless you need
    to fine-tune the animation). Yet, this is an important tool that avoids the need
    for third-party programs to create your animations. Also, it is useful for prototyping
    animations. Unfortunately, we don''t have enough room in this chapter to talk
    in detail about the **Animation** window, but you can read more about it in the
    official documentation here: [https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html](https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, however, we will use it just to create and save animation clips
    starting from our Sprites. As we can notice from the preceding picture, there
    is already the Walk animation created in the last section. To create a new animation
    clip, click on **Panda_Walk_Animation** and a drop-down menu like the following
    should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the other animation clips](img/image00459.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Create New Clip...** and Unity will ask you where to save this new
    file and its name. We can name it `Panda_Die_Animation` and save it within the
    `Animations` folder. As a result, the **Animation** window should now be cleared,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the other animation clips](img/image00460.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can select the Sprites of the die animation, and drag and drop them
    within the window. Thus, the Sprite animation is loaded within the animation file,
    as we can see from the Animation window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the other animation clips](img/image00461.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to repeat the process to create the Hit and Eat animations. At the
    end, you should have the following files in the `Animations` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the other animation clips](img/image00462.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One more thing. If you click on one of them, in the **Inspector**, you can see
    some options about whether the animation can be played in loop and how, along
    with an information box with some the amount of certain kind of data for the animation,
    such as how many muscles (but this is for 3D animation, and we won't use this
    information).
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the other animation clips](img/image00463.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Not all our animations are supposed to be played in loop. In fact, all but
    the walk animations are not supposed to loop. Therefore, for them, just uncheck
    the **Loop Time** variable in the **Inspector**, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the other animation clips](img/image00464.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So far so good. Before you proceed, I advise you to create a new prefab in the
    `Prefab` folder, called `PandaPrefab`, and drag your **Panda** there.
  prefs: []
  type: TYPE_NORMAL
- en: The Animator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine all of the different types of actions that you perform throughout the
    day-from the moment you wake up, to making coffee, having a shower, and getting
    ready for work. Each of these would have a different animation. The same goes
    for characters. In most games, characters or other animated objects (animals,
    trees, and so on) have a range of animations. Just like our example before, each
    animation will correspond to a different moment during gameplay. For example,
    when a character is just standing and being idle, they aren't doing much, but
    it is likely that they are still breathing. In some games, if characters remain
    idle for an extended period of time, other animation sequences are then triggered,
    such as impatient foot tapping or something completely unexpected. In first-person
    shooters, objects within the game environment may have the ability to be affected
    by things such as bullets or force (such as running hard into a wall), and as
    a result, they might break, crack, open, or even close. Mecanim uses a visual
    layout system similar to a flowchart to represent a state machine and enable you
    to control and sequence the animation clips that you want to use on your character
    or object. We will discuss this in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The Animator window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Animator window allows you to create, view, and modify Animator Controller
    assets within Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all our animation files, we need to embed them within the
    Animator Controller in a meaningful way. If you double-click on `PandaAnimatorController`,
    the **Animator** window opens, and you should have a screen similar to the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator window](img/image00465.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you don't see your panda animations within rectangles, like the preceding
    image, it is probably because you have created the animation clips without having
    the animation window linked to a controller. That is not a problem; you just need
    to select the animation clips you want in the controller and drag them into the
    **Animator** window, and they will be added.
  prefs: []
  type: TYPE_NORMAL
- en: The **Animator** window is divided into two sections. The main section with
    the dark gray grid is the layout area. You can use this area to create, arrange,
    and connect states in your Animator Controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can right-click on the grid to create a new state node. Using the middle
    mouse button or ***Alt*** /Option, drag to pan the view around. Click to select
    state nodes, so as to edit them in the **Inspector**, and click and drag state
    nodes to rearrange the layout of your state machine, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator window](img/image00466.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this way, our state machine will be clearer and tidy for what we are going
    to do. The second section of the **Animator** window is the left-hand pane, which
    can be switched between the **Parameters** tab and **Layers** tab (if you want
    to learn more about layers, you can read the optional section of this chapter,
    **Layers** in the **Animator**, inside the *More about Animations* section). The
    **Parameters** tab allows you to create, view, and edit the Animator Controller
    parameters. These are variables that you define, which will then act as inputs
    into the state machine. We will see them in detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: Also, toggling the eye icon on or off (highlighted in the next image to easily
    locate it) will show or hide the **Parameters** and **Layers** side pane, allowing
    you more room to see and edit your state machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator window](img/image00467.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Furthermore, if we enable the lock icon (as in the next image) in the top-right
    corner, we are able to keep the **Animator** window focused on the current state
    machine. If the lock icon is disabled, clicking on a new Animator asset or a Game
    Object with an Animator component will switch the **Animator** window. As a result,
    we are then able to show that item's state machine. The benefit of locking the
    window is that it allows us to keep the **Animator** window from showing the same
    state machine, regardless of what assets or Game Objects are selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator window](img/image00468.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last useful toggle (located just below the lock icon) is **Auto Live Link**,
    which allows us to see the machine in action at runtime. For your convenience,
    it is highlighted in the following image, but we will talk more about it when
    we need to test the machine we are building up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator window](img/image00469.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Animator state machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we already have mentioned, the Animator controller is a flowchart system;
    specifically it is a kind of finite-state machine. But what is a finite-state
    machine? From Wikipedia, we can read:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata),
    or simply a state machine, is a mathematical model of computation used to design
    both computer programs and sequential logic circuits. It is conceived as an abstract
    machine that can be in one of a finite number of states. The machine is in only
    one state at a time; the state it is in at any given time is called the current
    state. It can change from one state to another when initiated by a triggering
    event or condition; this is called a transition. A particular FSM is defined by
    a list of its states, its initial state, and the triggering condition for each
    transition."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our specific cases, the states will be the animations. So, saying that our
    Animator is a specific state means that the Game Object with that Animator controller
    is playing that specific animation. If it is not completely clear right now, it
    will be a while before we explain the different parts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will explore finite-state machines a bit more in detail later in the book,
    when we deal with Artificial Intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Unity generated an Animator controller for us when we created the first Animation
    clip. But if you need to manually create it, here's how to do it. From the **Project**
    panel (possibly within a meaningful folder, such as `Animations`), right-click
    and select **Create** | **Animator Controller**. Once renamed, double-click on
    it to open it in the **Animator** window. Contrary to the automatically generated
    controller, which already contains all the states of our Panda animation, here
    there are no such states. In fact, we need to manually import them. In the case
    of our Pandas, we just need to select the animations file that we have created
    before from the **Project** panel and drag them into the grid of the **Animator**
    window. If you remember, we stored them inside the `Animations` folder. Always
    remember that you can move any state just by dragging it. This is useful, because
    you can reorganize states so as to have a visual order and improve the readability
    of your work.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to dig deeper and see how to actually build an animation machine
    for our pandas. If you created a new Animator controller, discard it, and let's
    take the one we had before.
  prefs: []
  type: TYPE_NORMAL
- en: The Animator states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Animations bring characters to life, and therefore Animation states provide
    the foundations for the Animation State Machine within Unity. Each state contains
    an individual animation sequence (or blend tree), such as running, walking, climbing,
    jumping, and so on. All these animation sequences will then be triggered and subsequently
    played when the character is in that respective state. When an event in the game
    triggers a state transition, such as the player jumps over a ledge while running,
    the character will be left in a new state whose animation sequence will then take
    over.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you select a state in the Animator Controller, you will see the properties
    for that state in the inspector, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator states](img/image00470.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These properties and their functions are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: Is just how the state will be referred in the Animator, and it is
    also the name showed on top of the state. If it is automatically generated from
    an animation, as a default, it will have the same name of the animation clip.
    In fact, our four panda states have the same names as their respectively animation
    clips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tag**: Just another way to identify a state or a set of them. It is useful
    when you need to control animation machines from a script. For our purposes, we
    can leave it in blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motion**: This is the animation clip assigned to this state, for example,
    one of the animation clips that we have created before, such as `Panda_Walk_Animation`
    or `Panda_Die_Animation` (actually, it can also be a blending tree; see the optional
    section *More about animations* later in the chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: The default speed of the animation. For example, the default speed
    of an animation may be too slow, such as a running animation, and therefore, the
    speed needs to be increased. By changing the value of **Speed**, the animation
    is able to player faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplier**: A number that is multiplied by **Speed** to increase it or
    decrease it. Next to it, there is the parameter checkbox. This allows us to transform
    this number into an animator parameter (please also note that the multiplier cannot
    have an independent value, but just be linked to a float parameter). In this way,
    we can control the speed of some animations, without touching the **Speed** settings
    (given that all of them are linked to the same parameter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mirror**: Should the state be mirrored, which means if the animation clip
    should be played like in a mirror, exchanging left with right and vice versa.
    This is only applicable to 3D humanoid animations, and therefore we won''t deal
    with it. Note that can be transformed into a parameter Boolean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cycle Offset**: Determines if the animation loop should start to a different
    point, and the value indicates the offset from the beginning of the animation.
    Also this acts as a **Multiplier** and can be set to be a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foot IK**: Should **Foot IK** be respected for this state? This is applicable
    to 3D humanoid animations, so we won''t deal with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write Defaults**: This decides whether or not AnimatorStates writes back
    the default values for properties that are not animated by its motion. By default,
    it is set to true, but unchecking it means that the non-animated properties of
    a state will keep the value they had previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitions**: The list of transitions originating from this state. It is
    equivalent to identify under which conditions this state changes into another
    one. We will see transitions in detail in a couple of sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add Behaviour**: For the description of this button see the optional section
    *More about Animations* later in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default state, displayed in brown, is the state that the machine will be
    in when it is first activated. If you want, you are able to change the default
    state of the state machine by right-clicking on another state and selecting **Set
    As Layer Default State** from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Animator states](img/image00471.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In our case, the default state is the **Panda_Walk_Animation** state, so be
    sure that it is selected as the default state. In addition, to add a new state,
    right-click on an empty space in the **Animator Controller** window and navigate
    to **Create State** | **Empty** from the context menu. Another way to create a
    state, as we have already pointed out, is to drag an animation into the **Animator
    Controller** window, and as a result, you will create a state containing that
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: As far as our panda's animation states are concerned, we don't have particular
    needs or settings to tweak. After all, what we are building is a relatively simple
    finite state machine compared to big, complex 3D animation machines. But, if at
    any moment you feel that one of the four animations that we have is too fast or
    too slow, just select it and change its speed. In that case, you can do it at
    the end, when we finish the state machine, so as to have better and complete vision
    of the panda animation as a whole, and tweak these values to improve it. For instance,
    I slowed down the walking, hit, and eat animation to 25%, which means a speed
    of 0.25, whereas for the die animation, I used 0.2\. Usually you find these values
    by trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you can only drag Mecanim animations into the controller; non-Mecanim
    animations will be rejected. Moreover, states do not necessarily contain single
    animation clips. In fact, they could also contain Blend Trees. You can read more
    about them in the optional section, *More about Animations*, later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Special states
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An animator machine also has some special states, which are presented in this
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Special states](img/image00472.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Any State** is a special state that is always present. **Any State** implies
    that it cannot be the end point of a transition. For example, jumping to *any
    state* cannot be used as a way to pick a random state to enter the next. **Any
    State** exists for the situation where you want to go to a specific state regardless
    of which state you are currently in. This is a simpler way of adding the same
    outward transition to all states in your machine. **Entry** and **Exit** are states
    that determine the beginning and the end of the Animation State Machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other special states to handle sub-machines. For more information,
    check out the *More about Animation* section later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The animator parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we already introduced before, on the left-hand side of the **Animator**
    window, there are two tabs: **Layers**, which we won''t deal with here (but I
    remind you that you can read the optional *Layers in the Animator* section), and
    **Parameters**, which we will learn in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The animator parameters](img/image00473.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Animation **Parameters** are variables that are defined within an **Animator
    Controller**. These parameters can be accessed and their values assigned from
    scripts. As a result, scripts can control or affect the flow of the state machine.
    For example, a script can set a parameter that indicates how fast an animation
    should be played, such as running or walking; these can be the same animation,
    just played at different speed. In a more sophisticated behavior, the same parameter
    can be a condition to switch between a proper walking animation and a running
    one, based on the player's input.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a parameter, click on the small + button, as highlighted in this picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The animator parameters](img/image00474.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, if you want to delete a parameter, select the parameter in the lists
    and press the *Delete* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'A drop-down menu appears, asking which kind of parameter we want to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The animator parameters](img/image00475.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'They can be of four basic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int`: An integer (whole number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`: A number with a decimal part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bool`: A true or false value (represented by a checkbox)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trigger`: A Boolean parameter that is reset by the controller when consumed
    by a transition (represented by a circle button)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters can be assigned values from a script using functions in the `Animator`
    class, specifically with the following self-explanatory functions: `SetFloat()`,
    `SetInt()`, `SetBool()`, `SetTrigger()`, and `ResetTrigger()`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we have already seen, parameters can be linked to transition conditions or
    even to state variables (such as the speed multiplier), and then be controlled
    by scripts. To give an example, imagine the heroine of your game is riding a horse.
    A script can change a float parameter, which is linked to the speed multiplier
    of the galloping horse animation, based on how much the player spurs the horse.
    As a result, the animation of the horse will change in real time, based on the
    player input (if the player is controlling your heroine), and the horse will move
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for our Tower Defense game, we just need triggers, in particular,
    three: one for when the panda is hit, another one when it reaches the end and
    eats the cake, and the last one when it dies under sprinkles hit. We can respectively
    name them `HitTrigger`, `EatTrigger`, and `DieTrigger`. At the end, you should
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The animator parameters](img/image00476.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, this is not the only way to implement this system. Refer to the *State
    machine behaviours* section later to learn how to use behaviours within a state
    so that in the *Homework* section you can test yourself with this new technique
    in order to implement this kind of behaviours in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: The animator transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transitions allow us to change from one state of the Finite State Machine into
    another one. They can be triggered when certain conditions are met. As the name
    suggests, they handle how the current state transits into the destination state
    and how these two should be merged to have a smooth transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are represented as mono-directional arrows between two states. To create
    a new transition between two state, right-click from the state where the transition
    should start (in our case, `Panda_Walk_Animation`) and select **Make Transition**,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The animator transitions](img/image00477.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then click on another state to make the transition between them. In this example,
    we are doing a transition from `Panda_Walk_Animation` to `Panda_Hit_Animation`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The animator transitions](img/image00478.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Transition settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you click on the arrow, you can see the transition settings/properties in
    the **Inspector**, like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transition settings](img/image00479.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you wish, you can assign a name to the transition, by typing it in the field
    shown next (you need to press *Enter* to confirm your choice):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transition settings](img/image00480.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a result, its name will be shown in the state that contains that transition
    (for instance, in our example, within the `Panda_Walk_Animation` state):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transition settings](img/image00481.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Renaming transition is your choice. Someone prefers to give proper names, someone
    else references to it as initial and final state, which is the default name. However,
    if you decide to rename them, remember to give meaningful names; it doesn't matter
    if they are long.
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover in detail each of these settings so as to have a better understanding
    of what they mean. Keep in mind that some of them refer to certain conditions,
    which we will explore soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Has Exit Time**: If this is set to true, the transition can only happen at
    the time specified in the **Exit Time** variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exit Time**: If **Has Exit Time** is enabled, this value represents the exact
    time for the transition to take effect. This is represented in normalized time
    (percentage value); so, for example, an exit time of 0.65 means that on the first
    frame where 65% of the animation has played, the **Exit Time** condition will
    be true. On the next frame, the condition will be false. For looped animations,
    transitions with exit times smaller than 1 will be evaluated on every loop, so
    you can use this to time your transition with the proper timing in the animation,
    for every loop. Transitions with exit times greater than 1 will be evaluated only
    once, so they can be used to exit at a specific time-after a fixed number of loops.
    For example, a transition with an exit time of 4.5 will be evaluated once, after
    four and a half loops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixed Duration**: If enabled, the transition time is interpreted in seconds;
    otherwise, it is interpreted in a percentage between 0 and 1 (normalized time),
    such as 0.5, which would represent 50%.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transition Duration**: This is the duration of the transition. This will
    also determine the length between the two blue markers in the Transition Graph
    (see the next section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transition Offset**: This is the offset of the time where the animation (in
    the destination state that is transitioned to) begins to play. For example, a
    value of 0.4 would mean the target state will begin playing at 40% of the way
    through its own timeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupt Source**: This allows you to control the circumstances that allow
    a transition to interrupt the current one. In particular, you can select five
    different modes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None** won''t allow anything to interrupt the transition.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current State** allows only transitions, within the current state, to interrupt
    the transition.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next State** allows the transition to be interrupted by other transitions,
    but only if those are within the destination state. Therefore, if the destination
    state has a transition that is ready to fire, it will interrupt this one and will
    be triggered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current State then Next State** allows the transition to be interrupted by
    transitions from either the current or the destination state. However, if the
    conditions of a transition becomes true on both the current state and the destination
    one, then the former will take the priority. For example, if two transitions are
    ready to fire but one is on the current state and another one on the destination
    one, the first transition will be triggered and will interrupt the current playing
    transition.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next State then Current State** still allows the transition to be interrupted
    by either transitions of the current or destination state. But in contrast to
    **Current State then Next State**, if the condition of a transition becomes true
    on both the current state and the destination one, then the latter will take priority.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordered Interruption**: This determines whether the current transition can
    be interrupted by other transitions independently of their order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you can make transitions, remember to rearrange often your finite state
    machine so as to improve readability. You should always place the states in such
    a way that all the transitions are nicely visible, and ideally they shouldn't
    cross each other much.
  prefs: []
  type: TYPE_NORMAL
- en: Transition graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity also provides a useful way to tweak these properties (listed just now)
    in a visual way, through the transition graph, which is located just below the
    settings of the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The transition settings can be adjusted either manually by entering numbers
    into the fields that we saw before, or by using the transition diagram, which
    will modify the values when the visual elements are manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transition graph](img/image00482.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Transition Graph with a clear timeline; we can tweak how the transition
    will happen in a visual way
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, you can do one of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the duration of the transition by dragging the *out* marker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the duration of the transition and the exit time by dragging the *in*
    marker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjust the transition offset by dragging the animation clips shown in the bottom
    part of the graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview the transition by dragging the playback marker and navigate frame by
    frame to adjust how the animation clips blend together. The preview window is
    located at the bottom of the inspector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Transition graph](img/image00483.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is the preview window, where you can rotate, scale and play animations,
    as well as display their pivot point (or center of mass in the case of 3D models)
    and change the time scale to which you want to play the preview
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the transition involves a blending tree as one of the two states (or both),
    the blend tree parameters will also appear in the transition graph. You can find
    a bit more about blending trees in the *More about Animations* section later in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Transition conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far we have seen many settings for our transitions, but when are they actually
    triggered? That''s why, at the bottom of the settings, there are the transition
    conditions. You can see them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transition conditions](img/image00484.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To add a condition, press the **+** button. To remove, select one of them and
    click on the **-** button. Besides, you can reorder them by dragging their left
    handle. However, the order doesn't affect the logic behind the transition (just
    the implementation of it, and maybe the readability of your project).
  prefs: []
  type: TYPE_NORMAL
- en: These conditions can be checked against the parameters. For `int` and `float`
    parameters, we can check them against a fixed number. So if the value in the parameter
    is **Greater** or **Less** than the fixed number. For `int` parameters, we can
    also check whether they are **Equals** or **NotEqual** compared to the fixed number.
    Bools, instead, can be checked to find out whether they are true or false. Finally,
    triggers cannot be checked against something, but the condition checks whether
    they fire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of conditions using all of the four kinds of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transition conditions](img/image00485.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Please note that the transition is executed/performed only if all the conditions
    are verified in that moment. A transition without conditions is triggered at the
    time specified in **Exit Time**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If **Has Exit Time** is not checked and the transition has no condition as well,
    then the transition is ignored by Unity. So it is as if the transition didn't
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to set a transition, we will explore some useful
    functionalities to test them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two useful functionalities to know about if you need to test the
    transitions. The first one is **Solo** and second is **Mute**. If you select a
    transition, you can see them at the top of the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing transitions](img/image00486.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, I suggest you to set **Solo** and **Mute** in another way. In fact,
    if we select a state, we can find in the **Inspector** all the transitions from
    that state with the **Solo** and **Mute** functionalities. As a result, we will
    have a handy view, since we can look at and set all the transitions from that
    state in one go, shown as follows (all the transitions in this picture will be
    made in the next section):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing transitions](img/image00487.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the **Mute** checkbox is selected, that specific transition will be ignored
    completely. Whereas, when the **Solo** checkbox is selected, all the other transitions
    will be considered muted. Furthermore, in the **Animator** window, it is possible
    to see **Mute** transitions in red, whereas **Solo** transitions are in green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing transitions](img/image00488.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of Solo and Mute transitions
  prefs: []
  type: TYPE_NORMAL
- en: If you have the hard copy of this book (so without colors), the transition that
    goes from `Panda_Walk_Animation` to `Panda_Hit_Animation` is a **Mute** transition,
    so the arrow is red. Both the transitions from `Panda_Walk_Animation` to `Panda_Die_Animation`
    and `Panda_Eat_Animation` are **Solo** transitions, and the arrow is green. The
    remaining one is neither a **Mute** nor **Solo** transition, and therefore it
    is white. However, this is just an example; feel free to test in the best way
    that suits you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, from the official documentation we can read a rule of thumb about
    **Solo** and **Mute** functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The basic rule of thumb is that if one Solo is ticked, the rest of the transitions
    from that state will be muted. If both Solo and Mute are ticked, then Mute takes
    precedence."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finally, it''s worthy to keep in mind that at the time I''m writing this sentence,
    there is a known issue (always from the official documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The controller graph currently doesn''t always reflect the internal mute
    states of the engine."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The panda's Animation State Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we learnt a bit more about how to use Mecanim system, we will do what
    we started-have a complete controller for the animations of our pandas. This is
    how the controller should look once finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The panda''s Animation State Machine](img/image00489.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are four transitions, and we''ve got only one. But we
    still need to properly set all of them. Therefore, create and complete the transitions
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Panda_Walk_Animation` to `Panda_Hit_Animation`: When the panda is walking
    and a sprinkle hits it, the panda will play the Hit animation. Therefore, let''s
    add `HitTrigger` as a condition and uncheck **Has Set Time** to trigger the transition
    at any moment during the walk loop. Furthermore, to make the transition instantaneous,
    let''s set **Transition Duration** to zero to make it start playing the Hit animation
    from the first frame set **Transition Offset** to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Panda_Hit_Animation` to `Panda_Walk_Animation`: After the panda has been hit,
    he will then keep walking again towards the player''s cake. As a result, we need
    to recover the panda from the `Panda_Hit_Animation` state as soon as the animation
    finishes. So, let''s set **Has Exit Time** to true and **Transition Duration**
    and **Transition Offset** to zero, since we want the transition to be instantaneous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Panda_Walk_Animation` to `Panda_Eat_Animation`: When the panda finally arrives
    to the player''s cake, the panda will eat so much of it that he will explode!
    Therefore, the transition needs to be triggered with `EatTrigger`, so add it to
    the conditions and uncheck **Has Exit Time**. Moreover, as all the transitions
    of the panda should be immediate, set both **Transition Duration** and **Transition
    Offset** to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Panda_Walk_Animation` to `Panda_Die_Animation`: Being under fire by sprinkles
    is tough for our panda. If it cannot hold anymore, it will die, leaving the player''s
    cake untouched. This is a transition triggered by `DieTrigger`, which we need
    to add to the conditions. Again, for the same reasons as before, uncheck **Has
    Exit Time** and set both **Transition Duration** and **Transition Offset** to
    zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Panda_Die_Animation` to `Exit`: Once the panda is dead, we want to get rid
    of it. Going in the `Exit` state, actually (since we don''t have any sub-machines),
    will make the controller start again from the enter state/node. However, we will
    see how to destroy the panda before this happens. It doesn''t matter if this animation
    goes in any other state, but choosing exit makes more sense, and so it helps in
    the readability of your controller. Once more, we want the transition to be instantaneous,
    so we set both **Transition Duration** and **Transition Offset** to zero; but
    we want to trigger this transition as soon as the animation finishes, which means
    having **Has Exit Time** set to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Panda_Eat_Animation` to `Exit`: The same reasons we said for the previous
    transition hold for this too. The panda will eat so much cake that it will explode,
    and again the panda will be removed from the scene. Check **Has Exit Time** and
    set **Transition Duration** and **Transition Offset** to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the panda's Animation State Machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we move on to the next section, we should check whether what we have
    done so far works. However, the whole system will be completed only when we finish
    the game. Therefore, we need to find a smart and fast way to test the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way is to create a new scene and drag and drop the panda Prefab
    into it. Then, build an UI interface with three buttons. Change their text so
    that you will have `Trigger Die Animation`, `Trigger Hit Animation`, and `Trigger
    Eat Animation`, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the panda''s Animation State Machine](img/image00490.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we learnt in the previous chapter, the buttons have the **On Click ()** event,
    which allows us to call some functions when the button is pressed. However, we
    didn't have chance to use this functionality. In fact, we will work more on UI
    events in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, you can select all the three buttons, and click on the small **+**
    button in the bottom-right corner of the **On Click ()** event. We can see this
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the panda''s Animation State Machine](img/image00491.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A new event appears, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the panda''s Animation State Machine](img/image00492.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag the panda from the **Hierarchy** panel, into the object variable, so that
    you will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the panda''s Animation State Machine](img/image00493.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the drop-down menu, navigate to **Animator** | **Set Trigger (string)**.
    In this way, we can set the triggers of our Animator. So at the end, you should
    have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the panda''s Animation State Machine](img/image00494.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, select each button separately, and assign to each one of them the respective
    trigger. For instance, in the **Trigger Die Animation** button, you should write
    `DieTrigger`, as shown in this picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the panda''s Animation State Machine](img/image00495.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `Set Trigger (string)` function is not the best option, since it involves
    the use of strings. But for testing purposes, it's more than fine. In the next
    section, when we build a script that controls the Animator, we will see how to
    use hashes to refer to Animator parameters as numbers, and improve efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, each one of those buttons now acts as a trigger for our panda.
    Therefore, we can press **Play**, and finally see our panda walking. Then, by
    clicking on the buttons, we can trigger the transitions in the Animator and see
    the panda changing state/animation. As a result, we can test if the transitions
    work well or not. Feel free to tweak any parameters you want, such as the speed
    of an animation or the transition graph of one of the transitions to suit your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember the **Auto live link** toggle when we talked about the **Animator**
    window? Once you are in **Play** mode, that is the right moment to activate it.
    As a result, you will be able to have a visual representation on your **Animator**
    window of the state of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the following screenshot, the walk loop is performed and it
    also shows a bar with the progress of the animation. This can help you a lot to
    tweak the Animator controller.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the panda''s Animation State Machine](img/image00496.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, once you are happy with your changes and you have applied them, save the
    scene if you want, but come back to our main scene. Then, we are ready to create
    a script, or two, for our pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we''ve got all the animations for our pandas and a controller that
    changes them based on some triggers. However, so far nothing will ever set a trigger
    of the Animator (except our UI test buttons in the other scene). Therefore, we
    need to create the script for the panda, which will not only include the behaviour
    of the panda, but it will also trigger the right animations. In the next section,
    we will learn how to tweak the parameters of an Animator within a script. But
    before we get there, let me to introduce you a very powerful tool: State Machine
    Behaviours!'
  prefs: []
  type: TYPE_NORMAL
- en: State machine behaviours
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each state of the animation machines can contain one or more behaviours. These
    are scripts that extend the `StateMachineBehaviour` class, which include the following
    functions/events, with self-explanatory names regarding when they are called/triggered:
    `OnStateEnter()`, `OnStateExit()`, `OnStateIK()`, `OnStateMove()`, and `OnStateUpdate()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, you need to override these functions from the mother class,
    and they take as input three parameters. The first is the Animator itself, the
    second is an `AnimatorStateInfo` that stores information about the current state,
    and finally we have an integer that represents the layer. In our case, since we
    won''t use any other layer than the base one, it will be always zero. They have
    the following signature (take `OnStateEnter()` for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we can control everything within a state. In fact, State Machine
    Behaviours are a very powerful tool. Once you have created a script that extends
    the `StateMachineBehaviour` class, select the state where you want to add it.
    Then, click on the **Add Behaviour** button at the bottom of the **Inspector**,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State machine behaviours](img/image00497.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If your class contains variables, they are shown in the **Inspector** as for
    any other script, and they can be configured for that specific state. Here is
    a State Machine Behaviour that contains some variables and how they are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State machine behaviours](img/image00498.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when using static variables, because they are shared among all the
    instances of the State Machine Behaviour among all the controllers! In fact, it's
    good practice to not use static variables in this context.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that the hero of your game that has the ability to carry and hold
    different weapons. In this case, with a machine behaviour, you can check which
    weapon the character is holding, and if it matches with the legendary fire sword,
    add a fire particle effect when our hero slashes an enemy. Another example could
    be where some characters share the same animation machine, since they are really
    similar, but some of them can glide after a jump. As such, you'd want to check
    this and, in some way, modify some parameters of your animation machines.
  prefs: []
  type: TYPE_NORMAL
- en: To put simply, the only limit is your imagination (and computational power),
    and you can enhance your animation machine. Of course, all that you can achieve
    with State Machine Behaviour can be done in other ways, but they offer a simple
    and quite intuitive way to do it. It doesn't take much to get used and learn how
    to deal with this tool.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a State Machine Behaviours is, let's make one for our
    panda!
  prefs: []
  type: TYPE_NORMAL
- en: The destroy behaviour
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When our panda is killed either by a terrible rain of sprinkles or by eating
    too much cake, in some way we need to make the panda disappear from the scene.
    However, we need to do it, after that the death animation is played, and eventually
    also after we have updated the gameplay (which we will see later in the book).
  prefs: []
  type: TYPE_NORMAL
- en: That's why we have created two extra transitions from the **Die** and **Eat**
    animations into the **Exit** state. These transitions will be executed once the
    respective animation has finished playing. Moreover, these animations are triggered
    by us in a separate script (see the next section), so before the panda dies, we
    have a chance to update the gameplay, such as the amount of sugar or health of
    the player.
  prefs: []
  type: TYPE_NORMAL
- en: A State Machine Behaviour allows us to have this level of control, that is to
    destroy the panda when it finishes to play that particular animation. Therefore,
    we can create a new script and call it something meaningful, such as `StateMachineBehaviour_DestroyOnExit`.
    Now, double-click on the script to open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to extend `StateMachineBehaviour` and not `MonoBehaviour`.
    We can just replace the latter with the former. Since the script doesn''t extend
    `MonoBehaviour` anymore, we can also remove the `Start()` and `Update()` functions.
    At the end, we should come up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to override one of the aforementioned functions of a State Machine
    Behaviour. In particular we want to override the `OnExit()` function. So every
    time the state changes to another (which in the case of the **Die** and **Eat** states
    means immediately after their animations are played), the panda will be destroyed.
    We can do this easily, since one of the parameters of the function is the Animator
    itself, and from it, we can retrieve the gameObject to which the Animator is attached
    and destroy it. Therefore, we can just add this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and select the **Die** and **Eat** states. From there, click
    on **Add Behaviour** and select `StateMachineBehaviour_DestroyOnExit`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done all of this, we are done! Now, every time the **Die** or
    **Eat** animations are played, on their completion, the panda will be destroyed.
    The next step is to see how to actually trigger the states within the controller.
  prefs: []
  type: TYPE_NORMAL
- en: The panda script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to create a new script, and this time let it be derived from `MonoBehaviour`.
    We can call it `PandaScript`. Then, we can start to create some variables inside
    it. Let''s start with a public variable to keep track of the panda''s life and
    another one for its speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a variable to store the reference to the Animator. So, we can
    use this variable when we need to trigger an animation in the Animator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned in the *Animator Parameter* section, there are different methods
    to set parameters within the Animator. However, there are two versions of them:
    one refers to the parameter with an ID or Hash, the other one as a string. The
    latter is for sure the most intuitive, but since it relies on string processing,
    it''s a bit slower than the first one. As such, whenever this is possible, it''s
    better to use a hash (see the information box) to refer to a specific parameter
    within the Animator. Therefore, we can store these hashes inside some variable,
    so to fast use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In computer science when we need to map data of an arbitrary size onto data
    of a fixed size, we use a `Hash` function. The result of this function is called
    *hash values*, *hash codes*, *digests*, or simply *hashes*. The main uses of these
    `Hash` functions are in cryptography and digital security. Whenever you digitally
    sign a document, behind the scenes there is a `Hash` function somewhere too. However,
    they are also used in other contexts, such as to optimize, as in the case of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In our very specific case, we have a set of parameters, which need an integer
    ID so that they can be referred to quickly in the Animator. A `Hash` function
    is applied from the name of the parameter, which is a string, and so potentially
    with infinite combinations, since a string can be long arbitrary, onto a finite
    set of the Integers which may be expressed with a single `int` variable (so only
    up to two billion, one hundred and forty-seven million, four hundred and eighty-three
    thousand, six hundred and forty-seven). So every time in your video game use an
    `int` variable for storing money or lives, like we did in the last chapter, `2,147,483,647`
    is the maximum amount. Usually for video games, this limit is more than fine for
    any integer parameters you may want, although it is possible to overcome it if
    needed with special data structures. As a result, from the name of the parameter
    of the Animator, we can have a number with which we can refer to the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: These hashes are Animator independent, since they are based only on the name
    of the parameter itself. So they can be calculated or retrieved from the static
    function `Animator.StringToHash()`, which takes as input the name of the parameter
    and returns as output it's numerical representation to use in an Animator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our specific case, we have the three triggers, and we can store their hashes
    in the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to get the reference to the Animator controller in the `Start()`
    function, so to be used in the other functions. We can achieve this by using the
    `GetComponent()` function, which returns the component specified as `Type` attached
    to the same gameObject of this script. Therefore, we can simply add this line
    in the `Start()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, as for a modular workflow, we can create some private functions to implement
    the logic behind controlling the state machine. However, we will deal with them
    when we need to call them later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, we need a function that allows our panda to move towards a point in
    the map. This function takes a `Vector3` as input parameter, which is the destination
    point on the map. Based on the speed variable, it creates a step for our panda.
    Then, using the `MoveTowards()` function, it moves the panda of one step towards
    the destination point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another function will be called when the panda is hit by a sprinkle from one
    of the player''s cupcake towers. It has as input a float, which is the amount
    of damage the panda has taken from the hit. So, the function subtracts this value
    to the health of the panda, and then checks if the health is less than zero. If
    so, the function triggers the Die Animation by set the `DieTrigger` parameter.
    We don''t need to then destroy the panda because once death is triggered, the
    state machine behaviour will take care of it. On the other hand, if the panda
    is not dead yet, the function, instead, plays the Hit Animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'One last function we need to add is for when the panda reaches the end of its
    path and it''s standing in front of the player''s cake. Here the function just
    triggers the `Eat animation`. How to damage the player is something that we will
    deal in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can save the script for now. It should appear like this in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The panda script](img/image00499.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: No need to worry now about how to set the speed and the health! We will see
    this when we will talk about gameplay programming.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you want to read the next optional section, which will guide you through
    more advanced topics, we can say that we have finished with animation. If you
    don't want to read the next section, or want to come back to it later, maybe once
    you've finished the whole book, you can skip directly to the homework and summary
    sections. Otherwise, take a break and continue with the next section.
  prefs: []
  type: TYPE_NORMAL
- en: More about Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen a lot about the Animation workflow in Unity, yet a lot has been
    left out. This section presents some relatively advanced topics of the Animation
    workflow in Unity, and they are not needed to develop our Tower Defense Game.
    In fact, some of these applies only on 3D, but I feel that it's worthwhile to
    mention them to have a rough, but complete picture of the whole workflow for Animations
    in Unity. Therefore, feel free to skip this section, or read without focus to
    understand completely what's written. You can always come back here later, maybe
    when you've finished the book, for a deeper look to its content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the following sections are not intended to explain in detail how to use
    these tools in Unity, but rather to be aware of their existence and functionalities
    so as to learn them later on when you are a bit more practical with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Avatars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the case of 3D characters, and especially for humanoids, you need to *rig*
    your character, which means to match all bones of the 3D model into a Unity Avatar.
    If the model is well done and optimized for Unity, this process can be automatized;
    otherwise it needs to be done by hand, as shown in this picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Avatars](img/image00500.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the scene view, there is your 3D model, from which you can drag and drop
    the parts of his/her/its body in the avatar.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, Unity stores additional information about the 3D model. It stores
    not only the matching bones, but also muscles. The main reason is that by doing
    it in this way it is possible to perform retargeting, which means using the same
    animations for different character. Suppose you have a beautiful walking animation,
    and you want to apply it to all your characters. But some of them are tall. Others
    are fat or full of muscles. The Avatar stores this additional information to overcome
    the problem and adapt the walking animation to each character.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Unity also allows masking, which means to discard part of the Animation
    clip data and uses specific parts only. For instance, imagine you have a beautiful
    walking animation and an animation of someone drinking a glass of water. Suppose
    you want to make your character to drink a glass of water while he or she keeps
    walking. By masking the drinking animation, we are able to crop it just onto the
    upper body part. As a result, we can leave the walking animation playing on the
    legs, while the drinking one is playing on the upper body of the character.
  prefs: []
  type: TYPE_NORMAL
- en: If you imagine a complex game, where the characters can do many things while
    walking (such as shoot, reload or talk) this functionality is really helpful.
    Keep in mind that masking can be done to different levels. For instance, you can
    merge more than two animations together with respect to different body parts,
    as well as sub-masking. The possibilities are endless!
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why Unity offers also a more detailed mapping when required, for instance,
    for the head or the hands, as the next picture shows, where we can see the mapping
    for the left hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Avatars](img/image00501.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All of this is really powerful when used in combination with sub-state machines,
    state-behaviors and Layers in the Animator.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-state machines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, we have seen that the Animator is a finite state machine with different
    states, each one of them as an animation clip. But in actual fact, not all of
    the states are animation clips. Some of them can be something else, such as sub-state
    machines. This means, that a state can contain another whole finite state machine!
  prefs: []
  type: TYPE_NORMAL
- en: '![Sub-state machines](img/image00502.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A sub-state machine appears into the upper level like a state, though with a
    slightly different shape. In fact, transitions can both start or end on a sub-state
    machine like any other state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can recognize a sub-state machine since the shape around the name is slightly
    different.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the exit state/node becomes important, because it allows us
    to finish/exit from the sub-state machine and continue in the next state. Of course,
    also a sub-machine can be interrupted if set to do so when some conditions are
    met. Needless to say, being able to nest animation machines is indeed a very powerful
    tool to build very complex Animators.
  prefs: []
  type: TYPE_NORMAL
- en: The hierarchical location menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen, states can contain sub-states and trees and these structures
    can be nested repeatedly. When drilling down into sub-states, the hierarchy of
    parent states and the current state can be viewed on the top bar (highlighted
    in the following picture):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The hierarchical location menu](img/image00503.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the parent states allows you to jump back up to parent states or
    go straight back to the base layer of the state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Layers in the Animator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, if we want to create, view, or edit layers within our Animator Controller,
    we need to make sure that the left-hand pane is set to Layers view, like this
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layers in the Animator](img/image00504.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This allows you to have multiple layers of animation within a single animation
    controller. All these layers are then able to run at the same time, where each
    layer is controlled by a separate state machine. This process is commonly used
    when, for instance, you have a separate layer playing upper-body animations over
    a base layer that controls the general movement animations for a character (to
    use in combination with Avatar Masks).
  prefs: []
  type: TYPE_NORMAL
- en: To begin, click on the plus icon to add a layer. On the other hand, to delete
    a layer, select the layer and press the *Delete* key.
  prefs: []
  type: TYPE_NORMAL
- en: Blending trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides Animation clips and sub-state machines, a state in the Animator can
    be also a blending tree. A common process to apply between different frames of
    an animation is to blend two or more similar motions, so that it feels like one
    fluid animation. For example, walking and running animations may require that
    key frames are blended between one another according to the character's speed.
    Ideally, you want the player to be slower if they are walking and faster if they
    are running. In some cases, the speed of how fast a player runs can also be increased
    again with game elements such as items (speed boosts). Another typical example
    is to lean the character left or right while they are turning to achieve a more
    realist behaviors. This can be obtained with blend trees, which are able to *blend*
    animation clips.
  prefs: []
  type: TYPE_NORMAL
- en: '![Blending trees](img/image00505.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of a very common blending tree; Here the walking animation is split
    in three animation clips, so the character can lean to the left or right as he/she
    turns during the walk
  prefs: []
  type: TYPE_NORMAL
- en: In fact, they use linear interpolation, which can be controlled by some weights
    and parameters. Unity supports both 1D and 2D interpolation for blending trees.
  prefs: []
  type: TYPE_NORMAL
- en: '![Blending trees](img/image00506.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 2D interpolation of Blending trees. Numbers and animation clips are placed at
    random, the aim of the figure it's showing the 2D interpolation in the upper part,
    where the diamond shapes are the different animation clips and the circle shape
    is the 2D value that controls the blending among the clips.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go further into blending trees, but keep in mind that they can be used
    to blend more animations together in real time to achieve incredibly real behaviors
    and smoother animations.
  prefs: []
  type: TYPE_NORMAL
- en: Animator Override Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you have just created a beautiful Animation State Machine, full
    of layers and transitions, since it is super detailed. Your character has states
    that allows her to cast a spell, to grab a coffee or to swing a sword. However,
    now, you need to consider that also a Goblin can do that. And even the Ogre of
    your second level as well as the elf that your protagonist has to fight later
    on in your game. Should you create again a very similar Animation Machine for
    each one of them, but just changing the Animation clips? And what if later on
    you decide to slightly change the controller, do you have to slightly change all
    of them? Thank God, Unity offers an easier way, called the **Animator Override
    Controller**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an **Animator Override Controller** by right-clicking on the
    project panel and navigate to **Create** | **Animator Override Controller**. It
    will be an asset as the others Animator controllers. However, you cannot open
    it in the **Animator** window. If you select it in the **Inspector**, you will
    see that you can link a normal Animator controller to it, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animator Override Controller](img/image00507.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Just for the sake of learning, we drag and drop the only controller that we
    have in our project, the panda controller. As a result, all the Animator states
    we used will appear in a list, and we can assign a different animation clip from
    the original controller.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animator Override Controller](img/image00508.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this way, you don't need to replicate the Animator controller but just assign
    new animation clips. Once the Animator controller changes, all the **Animator
    Override Controllers** will change accordingly, updating all the characters in
    your game that use that controller. Not bad, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Culling Mode in the Animator component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a moment now, picture a beautiful animation of a shiny coin. It is so beautiful
    that you decide to include many coins in your game. As a result, it might be computationally
    heavy to make rotate thousands of coins if then the player can see just three
    on his or her screen.
  prefs: []
  type: TYPE_NORMAL
- en: Consider, instead, this other case. The player just turned a switch that triggers
    a really heavy and slow door. So, while the door is opening, the player explores
    a bit the environment. When he or she comes back, the player would expect that
    the animation of the door is complete and so the door is open. This means that
    the animation of the door should run also when it is not visible, whereas the
    coin is not needed to be animated in any moment, for instance when it is off screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To optimize this issue, Unity offers an option in the Animator component, the
    **Culling Mode**. This allows us to specify when the object should animate. The
    possible values are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always Animate**: The most expensive, although realistic, solution. As the
    name suggests, the object is always animated, so in the case of the door also,
    when it is off screen, it will keep opening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cull Update Transforms**: This is a mid-solution; it disables only some parts,
    such as Retargeting and IK, to improve performance, but still has a certain degree
    of realism when needed, without paying too much in computational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cull Completely**: This is the cheapest from a computational point of view,
    since the object stops being animated completely when it is off screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root motion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some animations, in theory, should displace the character, such as walking but
    not drinking a glass of water. So in order to fix this issue in Unity, you can
    either move the character with a script, as we did in our case, or use root motion.
    As the name suggests, this allows the animation itself to move the root of the
    character (or object or creature) achieving a more realistic motion in space.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is not straightforward and has some drawbacks. For instance, it
    is more expensive from a computational point of view, and as such, many characters
    with root motions on low-end devices could be prohibitive. Furthermore, it requires
    different tweaks, especially if the animation is not really well done.
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Kinematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inverse Kinematic is something relatively new in video games. It allows you
    to have a target into the animation, and sometimes compute in real time an animation
    that suits the target. For instance, imagine a character who just wants to rest
    his or her hands on the wall. The Inverse Kinematic should allow you to control
    the animation to place the hand on the wall, regardless of whether the wall is
    1 centimeter further or closer.
  prefs: []
  type: TYPE_NORMAL
- en: Usually animations use what is called Direct Kinematic (or Forward Kinematic).
    Based on the position and rotation of the joints, it is possible to determine
    the position of each part of the skeleton. So imagine having an arm, and based
    on the positions and rotations of your shoulder, elbow, and wrist, you can determine
    the position and rotation of your hand. In fact, these techniques come from robotic
    research.
  prefs: []
  type: TYPE_NORMAL
- en: The inverse problem, known as Inverse Kinematic, is to determine the positions
    and rotations of your shoulder, elbow, and wrist starting from the position and
    rotation of your hand. However, this problem is not uniquely determined, since
    it might have infinite solutions. Therefore, solving this problem wasn't straightforward.
    In any case, different techniques (which in the case of robotics may involve inverting
    the Jacobian matrix) were developed to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with having different solutions is that some of them may lead to
    very unusual poses. Following again the example of the arm, a solution that, in
    order to rest the hand to the wall, brings the elbow up to the eye is not really
    believable (see the next image, on the left). Whereas this might be a relative
    problem if applied to robotics, in animation this is indeed a big problem, because
    we want our characters to be believable.
  prefs: []
  type: TYPE_NORMAL
- en: So, other techniques have been developed to solve the problem, and the study
    of social behaviors (for humanoid characters) have been conducted to understand
    why some poses are more realistic than others. For instance, the pose in the preceding
    picture is tiring; nobody will ever rest his hand on the wall in such way. In
    fact, this also deals with physics, since our brain tries to control our body
    in such a way to spend as less energy as possible. This results in an unconscious
    behavior that we recognize in other people, and our videogame characters need
    it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity implements some of these techniques, and Mecanim supports some kind of
    Inverse Kinematic for humanoid characters, given that they have a correct configured
    avatar. However, we don''t want to dig any deeper in this. I just leave the most
    curious reader with the link to the Official Documentation here: [https://docs.unity3d.com/Manual/InverseKinematics.html](https://docs.unity3d.com/Manual/InverseKinematics.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another example where Inverse Kinematic is studied and used is for virtual presence
    in virtual reality. The recent Oculus Touch allows you to have your hands within
    the Rift Headset, but not your elbow and/or shoulder. While implementing inverse
    kinematic-even taking into account the believability and the less energy pose-the
    software is yet not able to precisely map your arm positions in space, because
    you will feel awkward. However, in multiplayer games, you can see other people
    in the virtual world but not in reality (or feel their bodies like they do), and
    therefore Inverse Kinematic can be applied. Although it won't give the exact position
    of the elbows of the other players in the game, it is close enough to be believable.
    A game that uses this mechanism is for instance Dead and Buried. As you can see
    from the next picture, you can see only your hands, but of the other players,
    you can see their whole bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inverse Kinematic](img/image00509.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Animator component information box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we already mentioned before, the Animator component has an information box
    at the bottom, which may contain some useful data. Here is a picture of the information
    box again, for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animator component information box](img/image00510.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Besides the **Clip Count** that we already have seen, here is a briefly list
    of the other information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pos**, **Rot**, and **Scale**: These indicate the total number of curves
    used respectively for the position, rotation and scale. The animation window,
    the one we didn''t see in detail, allows you to create such curves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Muscles**: The number of muscles used in the Animator in case of Humanoid
    characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic**: The number of numeric curves used by the Animator to animate other
    properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PPtr**: The total count of sprite animation curves; it is useful when we
    work in 2D.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Curves Count**: The total combined number of animation curves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant**: The number of animation curves that are optimized as constant
    values. Unity selects this automatically if your animation files contain curves
    with unchanging values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dense**: The number of animation curves that are optimized using the *dense*
    method of storing data (discrete values, which are interpolated between linearly).
    This method uses less significantly less memory than the *stream* method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream**: The number of animation curves using the *stream* method of storing
    data (values with time and tangent data for curved interpolation). This data occupies
    significantly more memory than the *dense* method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simpler animation system was used by Unity prior to the introduction of Mecanim
    (in year 2012, with Unity 4.0). Given that some time has passed since then, backward
    compatibility is still available. As a result, it is still possible to continue
    working on older projects without having to update Mecanim or worrying about other
    issues arising from the software.
  prefs: []
  type: TYPE_NORMAL
- en: Some people find the Legacy animation system useful for fast prototyping and/or
    testing animation clips, especially when the object has only one animation clip.
    This is because it was based on the Animation component (picture given next),
    and it should not be confused with the Animator component that we have seen before
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Legacy animation](img/image00511.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can find out more about the Legacy animation system here in the official
    documentation: [https://docs.unity3d.com/Manual/Animations.html](https://docs.unity3d.com/Manual/Animations.html).'
  prefs: []
  type: TYPE_NORMAL
- en: So, unless you have a specific need for it, you can completely ignore the Legacy
    Animation system, but it was worthwhile to mention it so that you don't get confused
    in case you found the Animation component and didn't know what it was.
  prefs: []
  type: TYPE_NORMAL
- en: In saying that, and while the legacy animation is still available, it is not
    recommended that you use it for new projects with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Get animated!!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One practical example to do that takes you outside of Unity is to think about
    the movement involved in animation. For example, when you are walking, typing,
    drinking, eating, any kind of movement, do it in slow motion. What you begin to
    notice is how subtle movements can make animations distinct and give it character.
    For each animation, such as drinking a glass of water for instance, do it in a
    different way. Pick up the cup, perhaps with a different grip such as using your
    whole hand or a few fingers around the handle. As you begin to become more conscious
    about movement, you should be able to gain some insight into how you might need
    to adjust an animation in Unity when something doesn't quite feel right. To get
    a better idea again, search for videos, even books to explore the uses of animation
    and some of their underpinnings. While this book is in no way a how to on animation,
    understanding the fundamentals not only help you to improve your own understanding
    about animations, but also help you to better understand the role of an animator
    and what it entails. This kind of information will be valuable to you later if
    you ever work or need to work with an animator.
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we faced many aspects of Animation clips and Animator controllers.
    However, before we go to the next chapter, I invite you to give a look to these
    exercises to improve your skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Becoming an animation designer**: Think of five games that you play, and
    select a part of each game such as the tutorial level, fighting a boss, walking
    through a forest, or even the main menu. Now, write down a list of animations
    that each of them have. Next, remove some animations, or even add some and think
    how it would alter the experience. Does it improve it, or does it change the atmosphere
    entirely? Could you make a relatively happy atmosphere really dark by changing
    some of the animations, and vice versa? By doing this, you will begin to understand
    the importance that animations play on not only providing life to your game, but
    also emotion and setting the atmosphere.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Drawing an animation (Part I)**: Imagine that you need to create an animation;
    you can do this simply in a graphics program. Begin by blocking out the arm; you
    can use a square for the hand, a rectangle for the forearm, and a longer rectangle
    for the upper arm. Now, move each one so that it performs a swing animation. It
    would be ideal to set it up like the Sprite Sheets that we have used so far. Then,
    import them inside Unity and test it out.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Drawing an animation (Part II)**: Now, add details to your animation, or
    other body parts such as legs. Moreover, feel free to add some special effects,
    like the Hit animation of the panda. Once you have you animation ready, try to
    create a second and a third one. Then, import them all, set them up, and build
    an Animator controller to see how they are animated. Furthermore, you can polish
    your animations in order to improve the transitions between them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A less dauntless Panda (Part I)**: As we have scripted, when the panda is
    hit, it keeps moving forward. However, the panda should be a little stunned. Only
    when the animation finishes, the panda should continue its advance towards the
    player''s cake. Fix this problem with any technique you come up, so you can modify
    the **Panda Script** or create Machine State Behaviours.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A less dauntless Panda (Part II)**: If you have done the previous exercise
    and found a solution to the fix, it''s time to make your code a bit more robust.
    Add a Boolean value in the **Panda Script** and stop the panda from moving when
    it is hit, but only if the Boolean is set to true. In this way, we can expose
    this variable in the **Inspector** and give more possibilities of which kind of
    panda the player has to face (continued in the next chapter).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**State Machine Behaviour as a listener**: We have implemented the **Panda
    Script** in such a way that triggers are set in the Animator controller to change
    animations. Now, remove both the Hit and Die triggers from the **Panda Script**
    and implement other Machine State Behaviours that retrieve the value of panda''s
    health and respectively trigger the Hit animation when health is decreased from
    the last time or the Die animation if it is below zero.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Explore the Animation window**: Even if we didn''t deal with the animation
    window, you can try to explore it, maybe by following the link to the official
    documentation provided. Then, try to make some animations for our sprinkles so
    that they can rotate while they are flying towards an evil Panda. Maybe you can
    also create a collision animation. Wrap these animations within an Animator controller
    and modify the Projectile script if needed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus, we created four different animation clips for our panda, one for each
    of its possible actions: Walk, Die, Hit, and Eat. Then, we wrapped them within
    a controller and built a finite state machine to define how these animation clips
    are linked, through transitions. Finally, we wrote a script to trigger the different
    states of the machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to animate our Pandas, it's time to move on to the
    next chapter, maybe after a coffee break.
  prefs: []
  type: TYPE_NORMAL
