- en: Decoupling Components with the Observer Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式解耦组件
- en: A common challenge in Unity development is to find elegant ways to decouple
    components from each other. It's a significant hurdle to overcome when writing
    code in the engine as it offers us so many ways to reference components through
    the API and the Inspector directly. But this flexibility can come with a price,
    and it can make your code fragile since, in some instances, it can take a single
    missing reference to break your game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity开发中，一个常见的挑战是找到优雅的方法来解耦组件。在引擎中编写代码时，这是一个重大的障碍，因为它为我们提供了通过API和直接在检查器中引用组件的多种方式。但这种灵活性可能会带来代价，并且可能会使你的代码变得脆弱，因为在某些情况下，一个缺失的引用就足以破坏你的游戏。
- en: So, in this chapter, we will use the Observer pattern to set up relationships
    with core components. These relationships will be mapped by assigning objects
    the role of the Subject or Observer. This approach will not altogether remove
    coupling between our components but will loosen it up and organize it logically.
    It will also establish an event handling system with a one-to-many structure,
    which is precisely what we need to implement in the use case presented in this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将使用观察者模式来设置与核心组件的关系。这些关系将通过分配对象作为主题或观察者的角色来映射。这种方法不会完全消除我们组件之间的耦合，但会将其放松并逻辑化组织。它还将建立一个具有一对一结构的处理系统，这正是本章用例中需要实现的内容。
- en: If you are looking for a way to decouple objects from each other with events
    in a many-to-many relationship, please check out [Chapter 6](75ba1c8b-0c32-4001-ae33-d9d79e276408.xhtml), *Managing
    Game Events with the Event Bus*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一种使用事件在多对多关系中解耦对象的方法，请查看第6章，*使用事件总线管理游戏事件*。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Observer pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解观察者模式
- en: Decoupling core components with the Observer pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用观察者模式解耦核心组件
- en: Implementing the Observer pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现观察者模式
- en: Reviewing alternative solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查替代方案
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09)。
- en: Check out the following video to see the code in action: [https://bit.ly/3xDlBDa](https://bit.ly/3xDlBDa).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/3xDlBDa](https://bit.ly/3xDlBDa)。
- en: Understanding the Observer pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解观察者模式
- en: The core purpose of the Observer pattern is to establish a one-to-many relationship
    between objects in which one acts as the subject while the others take the role
    of observers. The subject then assumes the responsibility of notifying the observers
    when something inside itself changes and might concern them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的核心目的是在对象之间建立一对一的关系，其中一个充当主题，而其他则充当观察者。然后，主题承担通知观察者的责任，当其内部发生变化并可能影响它们时。
- en: It's somewhat similar to a publisher and subscriber relationship, in which objects
    subscribe and listen for specific event notifications. The core difference is
    that the subject and observers are aware of each other in the Observer pattern,
    so they are still lightly coupled together.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它与发布者和订阅者关系有些相似，其中对象订阅并监听特定事件通知。核心区别在于观察者模式中，主题和观察者彼此知晓对方，因此它们仍然轻度耦合在一起。
- en: 'Let''s review a UML diagram of a typical implementation of the Observer pattern
    to see how this might work when implemented in code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个典型观察者模式实现的UML图，看看它在代码中实现时可能如何工作：
- en: '![](img/03b549cd-caed-4ef5-a6f2-951802a723de.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03b549cd-caed-4ef5-a6f2-951802a723de.png)'
- en: Figure 9.1 – UML diagram of the Observer pattern
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 观察者模式的UML图
- en: 'As you can see, the Subject and the Observer both have respective interfaces
    that they implement, but the most important one to analyze is `ISubject`, which
    includes the following methods:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主题和观察者都有自己的接口实现，但最重要的一个是`ISubject`，它包括以下方法：
- en: '`AttachObserver()`: This method allows you to add an observer object to the
    list of observers to notify.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AttachObserver()`: 此方法允许你将观察者对象添加到要通知的观察者列表中。'
- en: '`DetachObserver()`: This method removes an observer from the list of observers.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetachObserver()`: 此方法从观察者列表中移除一个观察者。'
- en: '`NotifyObservers()`: This method notifies all the objects that have been added
    to the subject''s list of observers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotifyObservers()`: 此方法通知所有已添加到主题观察者列表中的对象。'
- en: An object that takes the role of Observer must implement a public method called
    `Notify()`, which will be used by the subject to notify it when it changes states.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 扮演观察者的对象必须实现一个名为 `Notify()` 的公共方法，该方法将由主题用于在它改变状态时通知它。
- en: Benefits and drawbacks of the Observer pattern
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式的优缺点
- en: 'These are some of the benefits of the Observer pattern:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是观察者模式的一些好处：
- en: '**Dynamism**: The Observer permits the Subject to add as many objects as it
    necessitates as Observers. But it can also remove them dynamically at runtime.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态性**: 观察者允许主题根据需要添加任意数量的观察者对象。但也可以在运行时动态地移除它们。'
- en: '**One-to-Many**: The main benefit of the Observer pattern is that it elegantly
    solves the problem of implementing an event handling system in which there''s
    a one-to-many relationship between objects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**: 观察者模式的主要好处是它优雅地解决了实现一个事件处理系统的问题，其中对象之间存在一对一的关系。'
- en: 'The following are some potential drawbacks of the Observer pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些观察者模式的潜在缺点：
- en: '**Disorder**: The Observer pattern doesn''t guarantee the order in which Observers
    get notified. So, if two or more Observer objects share dependencies and must
    work together in a specific sequence, the Observer pattern, in its native form,
    is not designed to handle that type of execution context.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无序性**: 观察者模式不保证通知观察者的顺序。因此，如果有两个或更多观察者对象共享依赖项并且必须按特定顺序一起工作，那么观察者模式在其原生形式中并不是为处理这种执行上下文而设计的。'
- en: '**Leaking**:The Observer can cause memory leaks as the subject holds strong
    references to its observers. If it''s implemented incorrectly and the Observer
    objects are not correctly detached and disposed of when they are not needed anymore,
    it could cause issues with garbage collection, and some resources will not be
    liberated.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泄漏**: 观察者可能导致内存泄漏，因为主题对其观察者持有强引用。如果实现不当，并且观察者对象在不再需要时没有正确地分离和释放，它可能会引起垃圾收集问题，并且某些资源将不会被释放。'
- en: 'To understand the potential memory leaking drawback indicated here, I recommend
    reading the following Wikipedia article on the subject matter: [https://en.wikipedia.org/wiki/Lapsed_listener_problem](https://en.wikipedia.org/wiki/Lapsed_listener_problem).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解此处指出的潜在内存泄漏缺陷，我建议阅读以下关于该主题的维基百科文章：[https://en.wikipedia.org/wiki/Lapsed_listener_problem](https://en.wikipedia.org/wiki/Lapsed_listener_problem)。
- en: But take into account that, like anything related to optimization, it's contextual,
    so you should profile your code before optimizing for potential performance issues.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，与任何与优化相关的内容一样，它是上下文相关的，因此你应该在优化潜在的性能问题之前对代码进行性能分析。
- en: When to use the Observer pattern
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用观察者模式
- en: The advantage of the Observer pattern is that it solves specific problems related
    to one-to-many relationships between objects. So, if you have a core component
    that often changes states and has many dependencies that need to react to those
    changes, then the Observer pattern permits you to define a relationship between
    those entities and a mechanism that enables them to be notified.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的优势在于它解决了与对象之间一对一关系相关的特定问题。因此，如果你有一个核心组件经常改变状态并且有许多依赖项需要对这些变化做出反应，那么观察者模式允许你定义这些实体之间的关系以及一个使它们能够被通知的机制。
- en: Therefore, if you are unsure when to use the Observer pattern, you should analyze
    the relationship between your objects to determine if this pattern is well-suited
    for the problem you are trying to solve.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你不确定何时使用观察者模式，你应该分析你对象之间的关系，以确定这种模式是否适合你试图解决的问题。
- en: Decoupling core components with the Observer pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用观察者模式解耦核心组件
- en: The core ingredient of our game is the racing bike. It's the entity in our scene
    that changes states and updates its properties the most often as it's under the
    player's control while traveling around the world and interacting with other entities.
    It has several dependencies to manage, such as the main camera that follows it
    and the HUD that displays its current speed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的核心元素是赛车。它是场景中状态变化最频繁的实体，因为它在玩家控制下在世界各地移动并与其他实体交互时，经常更新其属性。它有多个依赖项需要管理，例如跟随它的主摄像头和显示其当前速度的用户界面。
- en: The racing bike is the main subject of our game, and many systems must observe
    it so that they can update themselves when it changes states. For instance, every
    time the bike collides with an obstacle, the HUD must update the current value
    of the shield's health, and the camera displays a full screen shader that darkens
    the edges of the screen to showcase the diminishing endurance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 竞速自行车是我们游戏的主要主题，许多系统必须观察它，以便在它状态改变时更新自己。例如，每次自行车与障碍物碰撞时，HUD 必须更新护盾当前的健康值，而相机则显示一个全屏着色器，使屏幕边缘变暗，以展示减少的耐力。
- en: This type of behavior is easy to implement in Unity. We could have `BikeController`
    tell `HUDController` and `CameraController` what to do when it takes damage. But
    for this approach to work, `BikeController` must be aware of the public methods
    to call on each controller.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中实现这种行为很容易。我们可以让 `BikeController` 告诉 `HUDController` 和 `CameraController`
    当它受到伤害时应该做什么。但为了使这种方法有效，`BikeController` 必须知道在各个控制器上调用哪些公共方法。
- en: As you can imagine, this doesn't scale well since as the complexity of `BikeController`
    grows, the more calls to its dependencies we will have to manage. But with the
    Observer pattern, we are going to break this coupling between the controllers.
    First, we will give each component a role; `BikeController` will become a subject
    and be responsible for managing a list of dependencies and notifying them when
    necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这并不容易扩展，因为随着 `BikeController` 的复杂性增加，我们需要管理的对其依赖的调用也会增多。但有了观察者模式，我们将打破控制器之间的这种耦合。首先，我们将给每个组件分配一个角色；`BikeController`
    将成为主题，并负责管理依赖列表并在必要时通知它们。
- en: The HUD and Camera controllers will act as observers of `BikeController`. Their
    core responsibility will be to listen for notifications coming from `BikeController`
    and act accordingly. `BikeController` doesn't tell them what to do; it just tells
    them something has changed and lets them react to it at their discretion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: HUD 和相机控制器将作为 `BikeController` 的观察者。它们的核心责任是监听来自 `BikeController` 的通知并相应地行动。`BikeController`
    并不告诉它们做什么；它只是告诉它们有变化发生，并让它们自行决定如何反应。
- en: 'The following diagram illustrates the concept we just reviewed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了我们刚刚讨论的概念：
- en: '![](img/da2d43e3-3686-46c3-aafa-57d46f4aaa09.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da2d43e3-3686-46c3-aafa-57d46f4aaa09.png)'
- en: Figure 9.2 – Illustration of the controllers observing a subject
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 控制器观察主题的示意图
- en: As we can see, we can have as many controllers observing the bike (subject)
    as we need. In the next section, we will take these concepts and translate them
    into code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以有任意数量的控制器观察自行车（主题）。在下一节中，我们将把这些概念转化为代码。
- en: Implementing the Observer pattern
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现观察者模式
- en: 'Now, let''s implement the Observer pattern in a simple way that can be reused
    in various contexts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以简单且可重用的方式实现观察者模式，以便在各种场景中使用：
- en: 'We are going to start this code example by implementing the two elements of
    the pattern. Let''s begin with the `Subject` class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从这个代码示例开始，实现模式的两个元素。让我们从 `Subject` 类开始：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Subject` abstract class has three methods. The first two, `Attach()` and
    `Detach()`, are responsible for adding or removing an observer object from a list
    of observers, respectively. The third method, `NotifyObservers()` has the responsibility
    of looping through the list of observer objects and calling their public method,
    called `Notify()`. This will make sense when we implement concrete observer classes
    in the upcoming steps.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 抽象类有三个方法。前两个方法，`Attach()` 和 `Detach()`，分别负责将观察者对象添加到观察者列表或从列表中移除。第三个方法
    `NotifyObservers()` 负责遍历观察者对象列表，并调用它们的公共方法，即 `Notify()`。在接下来的步骤中实现具体的观察者类时，这一点将变得有意义。'
- en: 'Next up is the `Observer` abstract class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `Observer` 抽象类：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Classes that wish to become observers have to inherit this `Observer` class
    and implement the abstract method named `Notify()`, which receives the subject
    as a parameter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 希望成为观察者的类必须继承这个 `Observer` 类并实现名为 `Notify()` 的抽象方法，该方法接收主题作为参数。
- en: 'Now that we have our core ingredients, let''s write a skeleton `BikeController`
    class that will act as our subject. However, because it''s so long, we will split
    it into three segments. The first segment is just initialization code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了核心成分，让我们编写一个作为主题的 `BikeController` 类的骨架。然而，因为它太长了，我们将将其分成三个部分。第一部分只是初始化代码：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following segment is important because we are attaching our observers when
    `BikeController` is enabled but also detaching them when it''s disabled; this
    avoids us having to hold on to references we don''t need anymore:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分很重要，因为我们是在 `BikeController` 启用时附加我们的观察者，并在它禁用时解除它们；这避免了我们保留不再需要的引用：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And for the final part, we have some basic implementations of core behaviors.
    Note that we only notify the observers when the bike''s parameters get updated
    when it takes damage, or when its turbocharger is activated:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一部分，我们有一些核心行为的初步实现。请注意，我们只在自行车参数更新时通知观察者，例如它受到伤害或涡轮增压器激活时：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`BikeController` never calls `HUDController` or `CameraController` directly;
    it only notifies them that something has changed – it never tells them what to
    do. This is important because the observers can independently choose how to behave
    when being notified.  Therefore, they have been decoupled from the subject to
    a certain degree.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`BikeController` 从不直接调用 `HUDController` 或 `CameraController`；它只通知它们有变化——它从不告诉它们该做什么。这很重要，因为观察者可以独立选择在收到通知时的行为。因此，它们在一定程度上与主题解耦。'
- en: 'Now, let''s implement some observers and see how they behave when the subject
    signals them. We''ll begin with `HUDController`, which has the responsibility
    of displaying the user interface:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现一些观察者并观察它们在主题发出信号时的行为。我们将从 `HUDController` 开始，它负责显示用户界面：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Notify()` method of `HUDController` receives a reference to the subject
    that notified it. Therefore, it can access its properties and choose which one
    to display in the interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`HUDController` 的 `Notify()` 方法接收一个指向通知它的主题的引用。因此，它可以访问其属性并选择在界面中显示哪一个。'
- en: 'Lastly, we are going to implement `CameraController`. The expected behavior
    of the camera is to start shaking when the turbo booster of the bike is activated:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现 `CameraController`。相机的预期行为是在自行车涡轮增压器激活时开始晃动：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`CameraController` checks the public Boolean property of the subject that just
    notified it and if it''s true, it starts shaking the camera until it gets notified
    again by `BikeController` and confirms that the turbo toggle is off.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraController` 检查刚刚通知它的主题的公共布尔属性，如果为真，则开始晃动相机，直到再次被 `BikeController` 通知并确认涡轮增压开关关闭。'
- en: The main takeaway of this implementation to keep in mind is that `BikeController`
    (**subject**) is not aware of how the HUD and Camera controller (**observers**)
    will behave once they are notified. Hence, it's at the discretion of the observers
    to choose how they will react as the subject alerts them of a change.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的要点是记住，`BikeController`（**主题**）并不知道一旦它们被通知，HUD 和相机控制器（**观察者**）会如何行为。因此，观察者可以选择如何响应主题的变更通知。
- en: This approach decouples these controller components from each other. Therefore,
    it's way easier to implement and debug them individually.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将这些控制器组件彼此解耦。因此，单独实现和调试它们要容易得多。
- en: Testing the Observer pattern implementation
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试观察者模式实现
- en: 'To test our implementation, we have to do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的实现，我们必须做以下事情：
- en: Open an empty Unity scene but make sure it includes at least one camera and
    one light.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个空的 Unity 场景，但确保它至少包含一个相机和一个光源。
- en: Add a 3D GameObject, such as a cube, to the scene and make it visible to the
    camera.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个 3D GameObject，例如一个立方体，添加到场景中，并使其对相机可见。
- en: Attach the `BikeController` script as a component to the new 3D object.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BikeController` 脚本作为组件附加到新的 3D 对象。
- en: Attach the `CameraController` script to the main scene camera.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CameraController` 脚本附加到主场景相机。
- en: 'Create an empty GameObject, add the following `ClientObserver` script to it,
    and then start the scene:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 GameObject，将其添加以下 `ClientObserver` 脚本，然后开始场景：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should see GUI buttons and labels on the screen, similar to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在屏幕上看到类似于以下内容的 GUI 按钮和标签：
- en: '![](img/168bc28d-38b6-45bb-b13c-e144af66e6ba.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/168bc28d-38b6-45bb-b13c-e144af66e6ba.png)'
- en: Figure 9.3 – The GUI elements in a running Unity scene
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 运行中的 Unity 场景中的 GUI 元素
- en: If we press the Toggle Turbo button, we will see the camera shake and the HUD
    display the status of the turbo booster.  The Damage Bike button will reduce the
    health of the bike.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下涡轮增压按钮，我们会看到相机晃动，HUD 显示涡轮增压器的状态。而“损坏自行车”按钮会减少自行车的健康值。
- en: There are many different ways you can implement the Observer pattern, each with
    its intrinsic benefits. I can't cover them all in this chapter. Due to this, I
    wrote the code example in this chapter for educational purposes in mind. Hence,
    it's not the most optimized approach but one that's easy to understand.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实现观察者模式有许多不同的方法，每种方法都有其固有的优点。我无法在本章中涵盖所有这些方法。因此，出于教育目的，我编写了本章中的代码示例。因此，这并不是最优化方法，但是一种易于理解的方法。
- en: Reviewing alternative solutions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查替代解决方案
- en: An alternative to the Observer pattern is the native C# event system. One of
    the significant advantages of this event system is that it's more granular than
    the Observer pattern because objects can listen to specific events that another
    emits, instead of getting a general notification from a subject.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的替代方案是本地的 C# 事件系统。这个事件系统的一个显著优点是它比观察者模式更细粒度，因为对象可以监听另一个对象发出的特定事件，而不是从主体获得一般通知。
- en: A native event system should always be considered if you need to have components
    interact through events, especially if you don't need to establish a specific
    relationship between them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要组件通过事件进行交互，尤其是如果您不需要在它们之间建立特定关系时，应始终考虑使用本地事件系统。
- en: Unity has its own native event system; it's very similar to the C# version but
    with added engine features, such as the ability to wire events and actions through
    the Inspector. To learn more, go to [https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html](https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 有自己的本地事件系统；它与 C# 版本非常相似，但增加了引擎功能，例如通过检查器连接事件和动作的能力。要了解更多信息，请访问 [https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html](https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html)。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the Observer pattern to decouple `BikeController`
    from its dependencies by assigning them the roles of subject or observer. Our
    code is now easier to manage and extend as we can easily have `BikeController`
    interact with other controllers with minimal coupling.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过将它们分配为主体或观察者的角色来使用观察者模式将`BikeController`与其依赖项解耦。现在我们的代码更容易管理和扩展，因为我们能够轻松地将`BikeController`与其他控制器进行交互，而耦合度最小。
- en: In the next chapter, we will explore the Visitor pattern, one of the most challenging
    patterns to learn. We will use it to build power-ups, a core mechanic and ingredient
    of our game.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨访问者模式，这是最难学习的一种模式。我们将使用它来构建增强功能，这是我们游戏的核心机制和成分。
