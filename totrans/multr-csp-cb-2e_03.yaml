- en: Chapter 3. Using a Thread Pool
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 使用线程池
- en: 'In this chapter, we will describe the common techniques that are used for working
    with shared resources from multiple threads. You will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述用于从多个线程中处理共享资源的常用技术。你将学习以下配方：
- en: Invoking a delegate on a thread pool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程池上调用委托
- en: Posting an asynchronous operation on a thread pool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程池上发布异步操作
- en: A thread pool and the degree of parallelism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池和并行度
- en: Implementing a cancellation option
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: Using a wait handle and timeout with a thread pool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程池的等待句柄和超时
- en: Using a timer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器
- en: Using the `BackgroundWorker` component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BackgroundWorker`组件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, we discussed several ways to create threads and organize
    their cooperation. Now, let's consider another scenario where we will create many
    asynchronous operations that take very little time to complete. As we discussed
    in the *Introduction* section of [Chapter 1](ch01.html "Chapter 1. Threading Basics"),
    *Threading Basics*, creating a thread is an expensive operation, so doing this
    for each short-lived, asynchronous operation will include a significant overhead
    expense.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了几种创建线程和组织它们合作的方法。现在，让我们考虑另一种场景，我们将创建许多耗时很小的异步操作。正如我们在[第1章](ch01.html
    "第1章。线程基础")的*简介*部分所讨论的，创建线程是一个昂贵的操作，因此对每个短暂、异步操作都这样做将包括显著的开销。
- en: To deal with this problem, there is a common approach called **pooling** that
    can be successfully applied to any situation when we need many short-lived, expensive
    resources. We allocate a certain amount of these resources in advance and organize
    them into a resource pool. Each time we need a new resource, we just take it from
    the pool, instead of creating a new one, and return it to the pool after the resource
    is no longer needed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有一个常见的称为**池化**的方法，可以成功应用于任何我们需要许多短暂、昂贵资源的情况。我们预先分配一定数量的这些资源，并将它们组织成一个资源池。每次我们需要新的资源时，我们只需从池中取出，而不是创建一个新的，在资源不再需要时将其返回到池中。
- en: The **.NET thread pool** is an implementation of this concept. It is accessible
    via the `System.Threading.ThreadPool` type. A thread pool is managed by the .NET
    **Common** **Language Runtime** (**CLR**), which means that there is one instance
    of a thread pool per CLR. The `ThreadPool` type has a `QueueUserWorkItem` static
    method that accepts a **delegate**, representing a user-defined, asynchronous
    operation. After this method is called, this delegate goes to the internal queue.
    Then, if there are no threads inside the pool, it creates a new **worker thread**
    and puts the first delegate in the queue on it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET线程池**是这个概念的实现。它可以通过`System.Threading.ThreadPool`类型访问。线程池由.NET **公共**
    **语言运行时**（**CLR**）管理，这意味着每个CLR有一个线程池实例。`ThreadPool`类型有一个`QueueUserWorkItem`静态方法，它接受一个**委托**，代表用户定义的异步操作。在调用此方法后，这个委托进入内部队列。然后，如果没有线程在池中，它将创建一个新的**工作线程**并将第一个委托放入队列中。'
- en: If we put new operations on a thread pool, after the previous operations are
    completed, it is possible to reuse this one thread to execute these operations.
    However, if we put new operations faster, the thread pool will create more threads
    to serve these operations. There is a limit to prevent creating too many threads,
    and in that case, new operations wait in the queue until the worker threads in
    the pool become free to serve them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将新的操作放入线程池，在之前的操作完成后，可以重新使用这个线程来执行这些操作。然而，如果我们更快地放入新的操作，线程池将创建更多的线程来服务这些操作。存在一个限制以防止创建过多的线程，在这种情况下，新的操作将等待在队列中，直到池中的工作线程空闲出来服务它们。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is very important to keep operations on a thread pool shortlived! Do not
    put long-running operations on a thread pool or block worker threads. This will
    lead to all worker threads becoming busy, and they will no longer be able to serve
    user operations. This, in turn, will lead to performance problems and errors that
    are very hard to debug.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 保持线程池上的操作短暂是非常重要的！不要将长时间运行的操作放入线程池或阻塞工作线程。这将导致所有工作线程变得忙碌，它们将无法再服务用户操作。这反过来会导致性能问题和难以调试的错误。
- en: When we stop putting new operations on a thread pool, it will eventually remove
    threads that are no longer needed after being idle for some time. This will free
    up any operating system resources that are no longer required.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们停止向线程池添加新操作时，它最终会在一段时间空闲后移除不再需要的线程。这将释放不再需要的任何操作系统资源。
- en: I would like to emphasize once again that a thread pool is intended to execute
    short-running operations. Using a thread pool lets us save operating system resources
    at the cost of reducing the degree of parallelism. We use fewer threads, but execute
    asynchronous operations more slowly than usual, batching them by the number of
    worker threads available. This makes sense if operations complete rapidly, but
    this will degrade the performance if we execute many long-running, compute-bound
    operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次强调，线程池旨在执行短运行时操作。使用线程池可以在减少并行度的代价下节省操作系统资源。我们使用更少的线程，但执行异步操作的速度比通常慢，通过可用的工作线程数量进行批处理。如果操作完成得很快，这样做是有意义的，但如果执行许多长时间运行的计算密集型操作，这将降低性能。
- en: Another important thing to be very careful of is using a thread pool in ASP.NET
    applications. The ASP.NET infrastructure uses a thread pool itself, and if you
    waste all worker threads from a thread pool, a web server will no longer be able
    to serve incoming requests. It is recommended that you use only input/output-bound
    asynchronous operations in ASP.NET because they use different mechanics called
    **I/O threads**. We will discuss I/O threads in [Chapter 9](ch09.html "Chapter 9. Using
    Asynchronous I/O"), *Using Asynchronous I/O*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的事情是要非常小心地在 ASP.NET 应用程序中使用线程池。ASP.NET 基础设施本身使用线程池，如果你浪费了线程池中的所有工作线程，那么
    Web 服务器将无法再处理传入的请求。建议你在 ASP.NET 中仅使用输入/输出绑定的异步操作，因为它们使用不同的机制称为 **I/O 线程**。我们将在
    [第 9 章](ch09.html "第 9 章。使用异步 I/O") 中讨论 I/O 线程，*使用异步 I/O*。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that worker threads in a thread pool are background threads. This means
    that when all of the threads in the foreground (including the main application
    thread) are complete, then all the background threads will be stopped.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，线程池中的工作线程是后台线程。这意味着当所有前台线程（包括主应用程序线程）完成时，所有后台线程都将停止。
- en: In this chapter, you will learn to use a thread pool to execute asynchronous
    operations. We will cover different ways to put an operation on a thread pool
    and how to cancel an operation and prevent it from running for a long time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用线程池来执行异步操作。我们将介绍将操作放入线程池的不同方法，以及如何取消操作并防止其长时间运行。
- en: Invoking a delegate on a thread pool
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程池上调用委托
- en: This recipe will show you how to execute a delegate asynchronously on a thread
    pool. In addition, we will discuss an approach called the **Asynchronous Programming**
    **Model** (**APM**), which was historically the first asynchronous programming
    pattern in .NET.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向你展示如何在线程池上异步执行委托。此外，我们还将讨论一种称为 **异步编程模型** （**APM**）的方法，这是历史上 .NET 中的第一个异步编程模式。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个食谱，你需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在 `BookSamples\Chapter3\Recipe1`
    中找到。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to invoke a delegate on a thread pool, perform the following
    steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在线程池上调用委托，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code inside the `Main` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program runs, it creates a thread in the old-fashioned way and then
    starts it and waits for its completion. Since a thread constructor accepts only
    a method that does not return any result, we use a **lambda expression** to wrap
    up a call to the `Test` method. We make sure that this thread is not from the
    thread pool by printing out the `Thread.CurrentThread.IsThreadPoolThread` property
    value. We also print out a managed thread ID to identify a thread on which this
    code was executed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它以传统的方式创建一个线程，然后启动它并等待其完成。由于线程构造函数只接受不返回任何结果的函数，我们使用**lambda表达式**来包装对`Test`方法的调用。我们确保这个线程不是来自线程池，通过打印出`Thread.CurrentThread.IsThreadPoolThread`属性值。我们还打印出一个托管线程ID，以识别执行此代码的线程。
- en: Then, we define a delegate and run it by calling the `BeginInvoke` method. This
    method accepts a callback that will be called after the asynchronous operation
    is complete and a user-defined state to pass into the callback. This state is
    usually used to distinguish one asynchronous call from another. As a result, we
    get a `result` object that implements the `IAsyncResult` interface. The `BeginInvoke`
    method returns the result immediately, allowing us to continue with any work while
    the asynchronous operation is being executed on a worker thread of the thread
    pool. When we need the result of an asynchronous operation, we use the `result`
    object returned from the `BeginInvoke` method call. We can poll on it using the
    `IsCompleted` result property, but in this case, we use the `AsyncWaitHandle`
    result property to wait on it until the operation is complete. After this is done,
    to get a result from it, we call the `EndInvoke` method on a delegate, passing
    the delegate arguments and our `IAsyncResult` object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个委托并通过调用`BeginInvoke`方法来运行它。此方法接受一个回调，该回调将在异步操作完成后被调用，以及一个用户定义的状态，该状态将被传递到回调中。这个状态通常用于区分一个异步调用与另一个异步调用。因此，我们得到一个实现`IAsyncResult`接口的`result`对象。`BeginInvoke`方法立即返回结果，允许我们在异步操作在线程池的工作线程上执行时继续进行任何工作。当我们需要异步操作的结果时，我们使用从`BeginInvoke`方法调用返回的`result`对象。我们可以使用`IsCompleted`结果属性对其进行轮询，但在这个情况下，我们使用`AsyncWaitHandle`结果属性来等待它，直到操作完成。完成这些后，为了从它获取结果，我们在委托上调用`EndInvoke`方法，传递委托参数和我们的`IAsyncResult`对象。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, using `AsyncWaitHandle` is not necessary. If we comment out `r.AsyncWaitHandle.WaitOne`,
    the code will still run successfully because the `EndInvoke` method actually waits
    for the asynchronous operation to complete. It is always important to call `EndInvoke`
    (or `EndOperationName` for other asynchronous APIs) because it throws any unhandled
    exceptions back to the calling thread. Always call both the `Begin` and `End`
    methods when using this kind of asynchronous API.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用`AsyncWaitHandle`是不必要的。如果我们注释掉`r.AsyncWaitHandle.WaitOne`，代码仍然可以成功运行，因为`EndInvoke`方法实际上会等待异步操作完成。始终调用`EndInvoke`（或其他异步API的`EndOperationName`）总是很重要的，因为它会将任何未处理的异常抛回到调用线程。始终在使用此类异步API时调用`Begin`和`End`方法。
- en: When the operation completes, a callback passed to the `BeginInvoke` method
    will be posted on a thread pool, more specifically, a worker thread. If we comment
    out the `Thread.Sleep` method call at the end of the `Main` method definition,
    the callback will not be executed. This is because when the main thread is completed,
    all the background threads will be stopped, including this callback. It is possible
    that both asynchronous calls to a delegate and a callback will be served by the
    same worker thread, which is easy to see by a worker thread ID.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作完成时，传递给`BeginInvoke`方法的回调将被发布到线程池中，更具体地说，是一个工作线程。如果我们注释掉`Main`方法定义末尾的`Thread.Sleep`方法调用，回调将不会执行。这是因为当主线程完成时，所有后台线程都将停止，包括这个回调。可能异步调用委托和回调将由同一个工作线程服务，这可以通过工作线程ID很容易地看到。
- en: This approach of using the `BeginOperationName`/`EndOperationName` method and
    the `IAsyncResult` object in .NET is called the Asynchronous Programming Model
    or the APM pattern, and such method pairs are called asynchronous methods. This
    pattern is still used in various .NET class library APIs, but in modern programming,
    it is preferable to use the **Task** **Parallel Library** (**TPL**) to organize
    an asynchronous API. We will cover this topic in [Chapter 4](ch04.html "Chapter 4. Using
    the Task Parallel Library"), *Using the Task Parallel Library*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，使用`BeginOperationName`/`EndOperationName`方法和`IAsyncResult`对象的方法称为异步编程模型或
    APM 模式，这样的方法对称为异步方法。这种模式仍在各种 .NET 类库 API 中使用，但在现代编程中，更倾向于使用**任务并行库**（**TPL**）来组织异步
    API。我们将在[第 4 章](ch04.html "第 4 章。使用任务并行库") *使用任务并行库* 中介绍这个主题。
- en: Posting an asynchronous operation on a thread pool
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程池上发布异步操作
- en: This recipe will describe how to put an asynchronous operation on a thread pool.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述如何将异步操作放在线程池上。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe2`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个食谱，你需要 Visual Studio 2015。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter3\Recipe2`中找到。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to post an asynchronous operation on a thread pool, perform
    the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在线程池上发布异步操作，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we define the `AsyncOperation` method that accepts a single parameter
    of the `object` type. Then, we post this method on a thread pool using the `QueueUserWorkItem`
    method. Then, we post this method once again, but this time, we pass a `state`
    object to this method call. This object will be passed to the `AsynchronousOperation`
    method as the `state` parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个接受单个`object`类型参数的`AsyncOperation`方法。然后，我们使用`QueueUserWorkItem`方法将此方法发布到线程池。然后，我们再次发布此方法，但这次，我们向此方法调用传递一个`state`对象。此对象将被传递给`AsynchronousOperation`方法作为`state`参数。
- en: Making a thread sleep for 1 second after these operations allows the thread
    pool to reuse threads for new operations. If you comment on these `Thread.Sleep`
    calls, most certainly the thread IDs will be different in all cases. If not, probably
    the first two threads will be reused to run the following two operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些操作之后让线程休眠 1 秒，这允许线程池重用线程来执行新的操作。如果你注释掉这些`Thread.Sleep`调用，大多数情况下线程 ID 都会不同。如果不是，可能前两个线程将被重用来执行接下来的两个操作。
- en: First, we post a lambda expression to a thread pool. Nothing special here; instead
    of defining a separate method, we use the lambda expression syntax.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将一个 lambda 表达式发布到线程池。这里没有特别之处；我们不是定义一个单独的方法，而是使用 lambda 表达式语法。
- en: Secondly, instead of passing the state of a lambda expression, we use **closure**
    mechanics. This gives us more flexibility and allows us to provide more than one
    object to the asynchronous operation and static typing for those objects. So,
    the previous mechanism of passing an object into a method callback is really redundant
    and obsolete. There is no need to use it now when we have closures in C#.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们不是传递 lambda 表达式的状态，而是使用**闭包**机制。这为我们提供了更多的灵活性，并允许我们向异步操作提供多个对象，并为这些对象提供静态类型。因此，将对象传递到方法回调的先前机制实际上是多余的，已经过时。现在我们有了
    C# 中的闭包，就没有必要使用它了。
- en: A thread pool and the degree of parallelism
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池和并行度
- en: This recipe will show you how a thread pool works with many asynchronous operations
    and how it is different from creating many separate threads.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将展示线程池如何与许多异步操作一起工作，以及它与创建多个单独线程的不同之处。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found in `BookSamples\Chapter3\Recipe3`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个食谱，你需要 Visual Studio 2015。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter3\Recipe3`中找到。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how a thread pool works with many asynchronous operations and how
    it is different from creating many separate threads, perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解线程池如何与许多异步操作一起工作，以及它与创建许多单独线程的不同之处，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, we create many different threads and run an operation
    on each one of them. This operation prints out a thread ID and blocks a thread
    for 100 milliseconds. As a result, we create 500 threads running all these operations
    in parallel. The total time on my machine is about 300 milliseconds, but we consume
    many operating system resources for all these threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，我们创建了多个不同的线程，并在每个线程上运行一个操作。这个操作打印出线程ID并阻塞线程100毫秒。结果，我们创建了500个线程，并行运行所有这些操作。在我的机器上，总时间大约是300毫秒，但我们消耗了大量的操作系统资源。
- en: Then, we follow the same workflow, but instead of creating a thread for each
    operation, we post them on a thread pool. After this, the thread pool starts to
    serve these operations; it begins to create more threads near the end; however,
    it still takes much more time, about 12 seconds on my machine. We save memory
    and threads for operating system use but pay for it with application performance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遵循相同的流程，但不是为每个操作创建一个线程，而是将它们发布到线程池。之后，线程池开始服务这些操作；它开始在接近结束时创建更多线程；然而，它仍然需要更多的时间，在我的机器上大约是12秒。我们为操作系统使用节省了内存和线程，但以应用程序性能为代价。
- en: Implementing a cancellation option
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: This recipe shows an example on how to cancel an asynchronous operation on a
    thread pool.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何在一个线程池上取消异步操作的示例。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found in `BookSamples\Chapter3\Recipe4`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter3\Recipe4`中找到。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To understand how to implement a cancellation option on a thread, perform the
    following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在线程上实现取消选项，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we introduce the `CancellationTokenSource` and `CancellationToken` constructs.
    They appeared in .NET 4.0 and now are the de facto standard to implement asynchronous
    operation cancellation processes. Since the thread pool has existed for a long
    time, it has no special API for cancellation tokens; however, they can still be
    used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了`CancellationTokenSource`和`CancellationToken`构造。它们出现在.NET 4.0中，现在已成为实现异步操作取消过程的实际标准。由于线程池已经存在很长时间，它没有为取消令牌提供特殊的API；然而，它们仍然可以使用。
- en: In this program, we see three ways to organize a cancellation process. The first
    is just to poll and check the `CancellationToken.IsCancellationRequested` property.
    If it is set to `true`, this means that our operation is being cancelled and we
    must abandon the operation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们看到有三种组织取消过程的方法。第一种只是轮询并检查`CancellationToken.IsCancellationRequested`属性。如果它被设置为`true`，这意味着我们的操作正在被取消，我们必须放弃操作。
- en: The second way is to throw an `OperationCancelledException` exception. This
    allows us to control the cancellation process not from inside the operation, which
    is being canceled, but from the code on the outside.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是抛出`OperationCancelledException`异常。这允许我们从被取消操作的外部代码中控制取消过程。
- en: The last option is to register a **callback** that will be called on a thread
    pool when an operation is canceled. This will allow us to chain cancellation logic
    into another asynchronous operation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种选项是在线程池中注册一个**回调**，当操作被取消时将被调用。这将允许我们将取消逻辑链入另一个异步操作。
- en: Using a wait handle and timeout with a thread pool
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池的等待句柄和超时
- en: This recipe will describe how to implement a timeout for thread pool operations
    and how to wait properly on a thread pool.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述如何实现线程池操作的超时以及如何在线程池上正确等待。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe5`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个食谱，你需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在 `BookSamples\Chapter3\Recipe5`
    中找到。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To learn how to implement a timeout and how to wait properly on a thread pool,
    perform the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何实现超时以及如何在线程池上正确等待，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加以下 `using` 指令：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE13]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A thread pool has another useful method: `ThreadPool.RegisterWaitForSingleObject`.
    This method allows us to queue a callback on a thread pool, and this callback
    will be executed when the provided wait handle is signaled or a timeout has occurred.
    This allows us to implement a timeout for thread pool operations.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池还有一个有用的方法：`ThreadPool.RegisterWaitForSingleObject`。此方法允许我们在线程池上排队一个回调，并且当提供的等待句柄被信号或发生超时时，此回调将被执行。这允许我们为线程池操作实现超时。
- en: 'First, we register the timeout handling asynchronous operation. It will be
    called when one of the following events take place: on receiving a signal from
    the `ManualResetEvent` object, which is set by the worker operation when it is
    completed successfully, or when a timeout has occurred before the first operation
    is completed. If this happens, we use `CancellationToken` to cancel the first
    operation.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们注册超时处理异步操作。当以下事件之一发生时，它将被调用：在接收到 `ManualResetEvent` 对象的信号时，该对象由工作操作在成功完成时设置，或者当第一个操作完成之前发生超时时。如果发生这种情况，我们使用
    `CancellationToken` 来取消第一个操作。
- en: Then, we queue a long-running worker operation on a thread pool. It runs for
    6 seconds and then sets a `ManualResetEvent` signaling construct, in case it completes
    successfully. In other case, if the cancellation is requested, the operation is
    just abandoned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在线程池上排队一个长时间运行的工作操作。它运行 6 秒，然后设置一个 `ManualResetEvent` 信号构造函数，以防它成功完成。在其他情况下，如果请求取消，操作将被放弃。
- en: Finally, if we provide a 5-second timeout for the operation, that would not
    be enough. This is because the operation takes 6 seconds to complete, and we'd
    need to cancel this operation. So, if we provide a 7-second timeout, which is
    acceptable, the operation completes successfully.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们为操作提供 5 秒的超时，这还不够。这是因为操作需要 6 秒才能完成，我们需要取消这个操作。所以，如果我们提供一个 7 秒的超时，这是可以接受的，操作将成功完成。
- en: There's more…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This is very useful when you have a large number of threads that must wait in
    the `blocked` state for some multithreaded event construct to signal. Instead
    of blocking all these threads, we are able to use the thread pool infrastructure.
    It will allow us to free up these threads until the event is set. This is a very
    important scenario for server applications, which require scalability and performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有大量线程必须等待在 `blocked` 状态，等待某些多线程事件构造函数发出信号时，这非常有用。我们不需要阻塞所有这些线程，我们可以使用线程池基础设施。这将允许我们在事件设置之前释放这些线程。这对于需要可扩展性和性能的服务器应用程序来说是一个非常重要的场景。
- en: Using a timer
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计时器
- en: This recipe will describe how to use a `System.Threading.Timer` object to create
    periodically-called asynchronous operations on a thread pool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述如何使用 `System.Threading.Timer` 对象在线程池上创建周期性调用的异步操作。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe6`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个食谱，你需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在 `BookSamples\Chapter3\Recipe6`
    中找到。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To learn how to create periodically-called asynchronous operations on a thread
    pool, perform the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在线程池上创建周期性调用的异步操作，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we create a new `Timer` instance. The first parameter is a lambda expression
    that will be executed on a thread pool. We call the `TimerOperation` method, providing
    it with a start date. We do not use the user `state` object, so the second parameter
    is null; then, we specify when are we going to run `TimerOperation` for the first
    time and what will be the period between calls. So, the first value actually means
    that we start the first operation in 1 second, and then, we run each of them in
    2 seconds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的 `Timer` 实例。第一个参数是一个将在线程池上执行的表达式。我们调用 `TimerOperation` 方法，并给它提供一个开始日期。我们不使用用户
    `state` 对象，因此第二个参数为 null；然后，我们指定何时第一次运行 `TimerOperation` 以及调用之间的周期。所以，第一个值实际上意味着我们将在
    1 秒后开始第一次操作，然后，我们每 2 秒运行一次。
- en: After this, we wait for 6 seconds and change our timer. We start `TimerOperation`
    in a second after calling the `_timer.Change` method, and then run each of them
    for 4 seconds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们等待 6 秒并更改我们的计时器。在调用 `_timer.Change` 方法后 1 秒启动 `TimerOperation`，然后每个操作运行
    4 秒。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A timer could be more complex than this!**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时器可能比这更复杂！**'
- en: It is possible to use a timer in more complicated ways. For instance, we can
    run the timer operation only once, by providing a timer period parameter with
    the `Timeout.Infinite` value. Then, inside the timer asynchronous operation, we
    are able to set the next time when the timer operation will be executed, depending
    on some custom logic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以更复杂的方式使用计时器。例如，我们可以通过提供一个具有 `Timeout.Infinite` 值的计时器周期参数来仅运行计时器操作一次。然后，在计时器异步操作内部，我们可以根据某些自定义逻辑设置计时器操作下一次执行的时间。
- en: Lastly, we wait for the *Enter* key to be pressed and to finish the application.
    While it is running, we can see the time passed since the program started.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待按下 *Enter* 键并结束应用程序。在它运行时，我们可以看到自程序开始以来经过的时间。
- en: Using the BackgroundWorker component
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BackgroundWorker 组件
- en: This recipe describes another approach to asynchronous programming via an example
    of a `BackgroundWorker` component. With the help of this object, we are able to
    organize our asynchronous code as a set of events and event handlers. You will
    learn how to use this component for asynchronous programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱通过一个 `BackgroundWorker` 组件的示例描述了异步编程的另一种方法。借助此对象，我们可以将异步代码组织成一系列事件和事件处理器。您将学习如何使用此组件进行异步编程。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe7`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入此食谱，您需要 Visual Studio 2015。没有其他先决条件。此食谱的源代码可在 `BookSamples\Chapter3\Recipe7`
    中找到。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how to use the `BackgroundWorker` component, perform the following
    steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用 `BackgroundWorker` 组件，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE18]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE19]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE20]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the program.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program starts, we create an instance of a `BackgroundWorker` component.
    We explicitly state that we want our background worker to support cancellation
    and notifications on the operation's progress.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，我们创建一个 `BackgroundWorker` 组件的实例。我们明确表示我们希望我们的后台工作线程支持取消操作和操作进度的通知。
- en: Now, this is where the most interesting part comes into play. Instead of manipulating
    with a thread pool and delegates, we use another C# idiom called **events**. An
    event represents a *source* of notifications and a number of *subscribers* ready
    to react when a notification arrives. In our case, we state that we will subscribe
    for three events, and when they occur, we call the corresponding **event handlers**.
    These are methods with a specially defined signature that will be called when
    an event notifies its subscribers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最有趣的部分来了。我们不是使用线程池和委托来操作，而是使用另一种C#习语，称为**事件**。事件代表一个**通知源**和多个**订阅者**，当通知到达时，它们准备做出反应。在我们的情况下，我们声明我们将订阅三个事件，当它们发生时，我们调用相应的**事件处理器**。这些是具有特别定义签名的函数，当事件通知其订阅者时将被调用。
- en: Therefore, instead of organizing an asynchronous API in a pair of `Begin`/`End`
    methods, it is possible to just start an asynchronous operation and then subscribe
    to different events that could happen while this operation is executed. This approach
    is called an **Event-based** **Asynchronous Pattern** (**EAP**). It was historically
    the second attempt to structure asynchronous programs, and now, it is recommended
    to use TPL instead, which will be described in [Chapter 4](ch04.html "Chapter 4. Using
    the Task Parallel Library"), *Using the Task Parallel Library*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是在`Begin`/`End`方法对中组织异步API，而是可以直接启动异步操作，然后订阅在操作执行期间可能发生的事件。这种方法被称为**基于事件的异步模式**（**EAP**）。这在历史上是第二次尝试结构化异步程序，而现在，推荐使用TPL（Task
    Parallel Library），这将在[第4章](ch04.html "第4章。使用任务并行库")中描述，*使用任务并行库*。
- en: So, we subscribed to three events. The first of them is the `DoWork` event.
    A handler of this event will be called when a background worker object starts
    an asynchronous operation with the `RunWorkerAsync` method. The event handler
    will be executed on a thread pool, and this is the main operating point where
    work is canceled if cancellation is requested and where we provide information
    on the progress of the operation. At last, when we get the result, we set it to
    event arguments, and then, the `RunWorkerCompleted` event handler is called. Inside
    this method, we find out whether our operation has succeeded, there were some
    errors, or it was canceled.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们订阅了三个事件。其中第一个是`DoWork`事件。当后台工作对象使用`RunWorkerAsync`方法启动异步操作时，将调用此事件的处理器。事件处理器将在线程池上执行，这是工作取消请求时取消工作以及我们提供操作进度信息的主要操作点。最后，当我们得到结果时，我们将它设置到事件参数中，然后调用`RunWorkerCompleted`事件处理器。在这个方法内部，我们找出我们的操作是否成功，是否有错误发生，或者是否被取消。
- en: Besides this, a `BackgroundWorker` component is actually intended to be used
    in **Windows Forms** **Applications** (**WPF**). Its implementation makes working
    with UI controls possible from a background worker's event handler code directly,
    which is very comfortable as compared to the interaction of worker threads in
    a thread pool with UI controls.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`BackgroundWorker`组件实际上旨在用于**Windows Forms** **应用程序**（**WPF**）。其实现使得从后台工作的事件处理器代码中直接操作UI控件成为可能，与线程池中的工作线程与UI控件交互相比，这非常方便。
