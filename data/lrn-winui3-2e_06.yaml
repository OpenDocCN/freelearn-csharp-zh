- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Leveraging Data and Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用数据和服务的优势
- en: Managing data is central to the operation of most applications. Learning how
    to load, maintain, and save that data is an important aspect of WinUI development.
    Two of the most important aspects of data management are **state management**
    and the **service locator pattern**. We will be covering these concepts and putting
    some of them to use in our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数据是大多数应用程序操作的核心。学习如何加载、维护和保存这些数据是 WinUI 开发的一个重要方面。数据管理的两个最重要的方面是 **状态管理**
    和 **服务定位器模式**。我们将介绍这些概念，并在我们的应用程序中应用其中的一些。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding the WinUI application lifecycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 WinUI 应用程序生命周期
- en: Learning to use **SQLite** to store application data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 **SQLite** 存储应用程序数据
- en: Learning to use the **object-relational mapper** (**ORM**) **Dapper** to quickly
    map objects in a data service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 **对象关系映射器**（**ORM**）**Dapper** 快速映射数据服务中的对象
- en: Continuing to explore the service locator pattern and implementing it with our
    data service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续探索服务定位器模式，并使用我们的数据服务实现它
- en: By the end of this chapter, you will have a working understanding of the WinUI
    application lifecycle and will know how to manage data and state in your projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备对 WinUI 应用程序生命周期的实际理解，并知道如何在项目中管理数据和状态。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    required:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，需要以下软件：
- en: Windows 10 version 1803 (version 17134) or newer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10 版本 1803（版本 17134）或更高版本
- en: Visual Studio 2022 or newer, with the .NET desktop development workload configured
    for Windows App SDK development
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 或更高版本，已配置 .NET 桌面开发工作负载以进行 Windows App SDK 开发
- en: The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06)。
- en: Managing application state with app lifecycle events
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序生命周期事件管理应用程序状态
- en: Before working with data in any application, it is important to understand the
    application lifecycle for the target application platform. We have touched on
    these concepts briefly, but now, it’s time to take a deeper dive into the Windows
    application lifecycle for **WinUI on** **Desktop** applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中处理数据之前，了解目标应用程序平台的应用程序生命周期非常重要。我们简要地提到了这些概念，但现在，是时候更深入地了解桌面应用程序的 WinUI
    应用程序生命周期了。
- en: Exploring Windows application lifecycle events
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Windows 应用程序生命周期事件
- en: 'WinUI on desktop applications has a slightly different set of lifecycle events
    than other desktop .NET applications. WPF and **Windows Forms** (**WinForms**)
    applications are either running or they’re not. There are several events that
    occur while launching and shutting down WPF and WinForms applications:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他桌面 .NET 应用程序相比，桌面应用程序的 WinUI 具有一套不同的生命周期事件。WPF 和 **Windows 表单**（**WinForms**）应用程序要么正在运行，要么没有运行。在启动和关闭
    WPF 和 WinForms 应用程序时，会发生几个事件：
- en: "![Figure 6.1 – WPF and WinForms application life\uFEFFcycle events](img/B20908_06_01.jpg)"
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – WPF 和 WinForms 应用程序生命周期事件](img/B20908_06_01.jpg)'
- en: Figure 6.1 – WPF and WinForms application lifecycle events
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – WPF 和 WinForms 应用程序生命周期事件
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We won’t go into the details here, as our primary focus is building WinUI 3
    applications. However, for the two WPF events that fall outside of the launch
    and close, their sequences are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细介绍，因为我们的主要重点是构建 WinUI 3 应用程序。然而，对于在启动和关闭之外的两个 WPF 事件，它们的顺序如下：
- en: '1\. `FrameworkElement.Unloaded`: This event fires when an element is removed
    from the WPF visual tree. It does not fire during application shutdown.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '1\. `FrameworkElement.Unloaded`: 当一个元素从 WPF 可视树中移除时，此事件被触发。它不会在应用程序关闭时触发。'
- en: '2\. `Application.SessionEnding`: This event fires when the current Windows
    user logs off or shuts down Windows. In the event handler, you can request that
    Windows cancels the process by setting the `SessionEndingCancelEventArgs.Cancel`
    property to `true`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. `Application.SessionEnding`: 当当前 Windows 用户注销或关闭 Windows 时，此事件被触发。在事件处理程序中，你可以通过将
    `SessionEndingCancelEventArgs.Cancel` 属性设置为 `true` 来请求 Windows 取消进程。'
- en: Lifecycle events of WinUI applications
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinUI 应用程序的生命周期事件
- en: Let’s talk about the WinUI lifecycle. Lifecycle events give you a chance to
    initialize any data and state when your application starts execution, and this
    allows you to clean up or save the state when the application is closed. In UWP
    applications, you also had the ability to handle events when the application was
    suspended or resumed because of a user or operating system action. WinUI, like
    other .NET desktop applications, doesn’t have this ability.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈 WinUI 的生命周期。生命周期事件在应用程序开始执行时为你提供了初始化任何数据和状态的机会，这允许你在应用程序关闭时清理或保存状态。在 UWP
    应用程序中，你也有能力处理由于用户或操作系统操作而使应用程序挂起或恢复时的事件。WinUI，就像其他 .NET 桌面应用程序一样，没有这个能力。
- en: 'In the `Application` and `Window` classes, there are only a couple of events
    that can be handled. Every `Application` class overrides the `OnLaunched` method.
    This method will be invoked exactly once, when the application is launched either
    by a user or the operating system. We’ve already worked with the `OnLaunched`
    method in our sample application. It’s where `MainWindow` is created and where
    we added a call to the method to configure our IOC container. In a new WinUI application,
    the `OnLaunched` method will look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Application` 和 `Window` 类中，只有几个事件可以被处理。每个 `Application` 类都重写了 `OnLaunched`
    方法。这个方法将在应用程序被用户或操作系统启动时恰好被调用一次。我们已经在我们的示例应用程序中使用了 `OnLaunched` 方法。这是创建 `MainWindow`
    的地方，也是我们添加调用方法来配置我们的 IOC 容器的地方。在一个新的 WinUI 应用程序中，`OnLaunched` 方法看起来是这样的：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Application` and `Window` classes only inherit from the .NET `Object` class,
    so there are no inherited events to leverage either. This is not the case with
    the `Page` class, which we will discuss shortly. First, we’re going to discuss
    `Window`, which has a couple of events we can leverage when managing an app’s
    lifecycle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application` 和 `Window` 类只继承自 .NET 的 `Object` 类，因此没有可利用的继承事件。但 `Page` 类的情况并非如此，我们将在稍后讨论。首先，我们将讨论
    `Window`，它有几个我们可以在管理应用程序生命周期时利用的事件。'
- en: The `Window` class in WinUI does not have a `Loaded` event, which is used in
    a WPF `Window` class to indicate that the window and its contents are loaded and
    available for interaction. The `Window.Activated` event can be used in place of
    a `Loaded` event, but the `Activated` event fires every time the window receives
    focus. If this is your only option, you will need to add a flag to check whether
    it’s the first time that `Activated` has fired.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 中的 `Window` 类没有 `Loaded` 事件，这个事件在 WPF 的 `Window` 类中用来指示窗口及其内容已加载并可供交互。可以使用
    `Window.Activated` 事件来代替 `Loaded` 事件，但 `Activated` 事件会在窗口每次获得焦点时触发。如果这是你的唯一选择，你将需要添加一个标志来检查
    `Activated` 是否是第一次触发。
- en: The other lifecycle event in `Window` is the `Closed` event, which fires when
    the window has closed. If it is the last remaining window, usually `MainWindow`,
    the application will end after the window closes. This is where you should save
    any application data and state information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window` 中的另一个生命周期事件是 `Closed` 事件，当窗口关闭时触发。如果是最后一个剩余的窗口，通常是 `MainWindow`，则在窗口关闭后应用程序将结束。这是你应该保存任何应用程序数据和状态信息的地方。'
- en: This is the extent of the application lifecycle events provided out of the box
    by the `Application` and `Window` classes. However, you can tap into some other
    events provided by `FrameworkElement`, which is a base class of `Page` and all
    the other controls in WinUI.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `Application` 和 `Window` 类提供的应用程序生命周期事件的全部内容。然而，你可以利用由 `FrameworkElement`
    提供的一些其他事件，它是 `Page` 和 WinUI 中所有其他控件的基础类。
- en: Additional lifecycle events with FrameworkElement objects
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FrameworkElement 对象的附加生命周期事件
- en: Every control in WinUI inherits from `Control`, which inherits from `FrameworkElement`.
    Even the `Page` control, which we added to the `Control`, through its inheritance
    from `UserControl`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 中的每个控件都继承自 `Control`，而 `Control` 继承自 `FrameworkElement`。即使是添加到 `Control`
    中的 `Page` 控件，也是通过从 `UserControl` 继承而来的。
- en: 'The `FrameworkElement` class provides three useful events that developers can
    leverage for the application lifecycle:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameworkElement` 类提供了三个有用的事件，开发者可以利用这些事件来处理应用程序生命周期：'
- en: '`Loading`: This event occurs when the loading process has started. This event
    can be leveraged to start fetching and processing data from services or other
    sources. You could also start loading data sooner, in the constructor of the current
    `Window` or `Page`, or even in `Application.OnLoaded`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Loading`：当加载过程开始时，将发生此事件。可以利用此事件开始从服务或其他来源获取和处理数据。你也可以在当前 `Window` 或 `Page`
    的构造函数中，甚至在 `Application.OnLoaded` 中更早地开始加载数据。'
- en: '`Loaded`: The `Loaded` event is invoked when the current element and all its
    children are loaded and ready for interaction. Do not try to manipulate these
    elements before they are loaded, or the app will raise a runtime exception.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Loaded`：当当前元素及其所有子元素加载并准备好交互时，将调用 `Loaded` 事件。在它们加载之前不要尝试操作这些元素，否则应用将引发运行时异常。'
- en: '`Unloaded`: This event is fired when the current element has been unloaded
    and removed from the `Page`, you can use this to clean up resources or save any
    state for the page.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unloaded`：当当前元素被卸载并从 `Page` 中移除时，将触发此事件。你可以使用此事件来清理资源或保存页面的任何状态。'
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We haven’t discussed the WinUI visual tree up to this point. The concept of
    trees, physical and logical, in WinUI is the same as in other XAML frameworks.
    We will discuss the physical tree and logical tree in more detail when we discuss
    debugging WinUI applications in [*Chapter 11*](B20908_11.xhtml#_idTextAnchor330),
    *Debugging WinUI Apps with Visual Studio*. To learn more now, Microsoft Learn
    has a great WPF article about trees: [https://learn.microsoft.com/dotnet/desktop/wpf/advanced/trees-in-wpf](https://learn.microsoft.com/dotnet/desktop/wpf/advanced/trees-in-wpf).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论 WinUI 的视觉树。WinUI 中的树的概念（物理和逻辑）与其他 XAML 框架中的相同。当我们在 [*第 11 章*](B20908_11.xhtml#_idTextAnchor330)
    中讨论使用 Visual Studio 调试 WinUI 应用程序时，我们将更详细地讨论物理树和逻辑树。要了解更多信息，请参阅 Microsoft Learn
    上的关于树的优秀 WPF 文章：[https://learn.microsoft.com/dotnet/desktop/wpf/advanced/trees-in-wpf](https://learn.microsoft.com/dotnet/desktop/wpf/advanced/trees-in-wpf)。
- en: You can handle the `Loaded` event for any control in your current view, whether
    it’s `Window` or `Page`, but always keep performance in mind. The `Loaded` event
    for the topmost `FrameworkElement` in the visual tree will not be fired until
    those of all its children have been completed. Network and filesystem operations
    can be expensive, so try to minimize and consolidate the calls to load the data
    needed to present your view whenever possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以处理当前视图中任何控件的 `Loaded` 事件，无论是 `Window` 还是 `Page`，但始终要考虑性能。视觉树中最顶层的 `FrameworkElement`
    的 `Loaded` 事件将在其所有子元素的 `Loaded` 事件完成之后才会触发。网络和文件系统操作可能很昂贵，因此尽可能最小化和合并加载以呈现视图所需数据的调用。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about handling lifecycle events, read the following Microsoft
    Learn page: [https://learn.microsoft.com/windows/apps/windows-app-sdk/applifecycle/applifecycle](https://learn.microsoft.com/windows/apps/windows-app-sdk/applifecycle/applifecycle).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于处理生命周期事件的信息，请阅读以下 Microsoft Learn 页面：[https://learn.microsoft.com/windows/apps/windows-app-sdk/applifecycle/applifecycle](https://learn.microsoft.com/windows/apps/windows-app-sdk/applifecycle/applifecycle)。
- en: Now that you have a solid understanding of WinUI’s lifecycle, let’s start working
    with some real data that will need to be persisted between user sessions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 WinUI 的生命周期有了坚实的理解，让我们开始处理一些需要在用户会话之间持久化的真实数据。
- en: Creating a SQLite data store
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SQLite 数据存储
- en: Until this point, the **My Media Collection** project has only worked with data
    stored inside in-memory collections. This means that every time the application
    is closed, all the user’s data is lost. It has also meant calling a method to
    populate all the lists with hardcoded seed data each time the application is launched.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，**我的媒体收藏**项目只与存储在内存集合中的数据进行交互。这意味着每次应用程序关闭时，所有用户数据都会丢失。这也意味着每次应用程序启动时，都需要调用一个方法来用硬编码的种子数据填充所有列表。
- en: In the previous chapter, we took the first step in creating a maintainable data
    service for the application. By creating a data service class that implements
    `IDataService`, no changes will be required in the `ViewModel` classes when we
    start loading data from a database. This section will focus on creating a new
    `SqliteDataService` class so that we can use **SQLite** for data access. The starting
    code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06/Start](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06/Start).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为应用程序创建了一个可维护的数据服务的第一步。通过创建一个实现 `IDataService` 的数据服务类，当我们开始从数据库加载数据时，不需要在
    `ViewModel` 类中进行任何更改。本节将重点创建一个新的 `SqliteDataService` 类，以便我们可以使用 **SQLite** 进行数据访问。本章的起始代码可以在
    GitHub 上找到，链接为 [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06/Start](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06/Start)。
- en: What is SQLite?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 SQLite？
- en: '**SQLite** (found at [https://sqlite.org/](https://sqlite.org/)) is a SQL-based
    database that is frequently used by mobile apps and simple desktop applications.
    It is a popular choice because it is small, fast, and self-contained in a single
    file. There are SQLite libraries available for virtually every platform. We will
    use Microsoft’s **Microsoft.Data.Sqlite** ADO.NET provider for SQLite.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLite**（位于[https://sqlite.org/](https://sqlite.org/)）是一个基于SQL的数据库，常被移动应用和简单的桌面应用程序使用。它是一个受欢迎的选择，因为它体积小、速度快，并且包含在一个单独的文件中。几乎每个平台都有SQLite库可用。我们将使用Microsoft的**Microsoft.Data.Sqlite**
    ADO.NET提供程序来处理SQLite。'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about Microsoft’s SQLite provider, you can read [https://learn.microsoft.com/dotnet/standard/data/sqlite/](https://learn.microsoft.com/dotnet/standard/data/sqlite/).
    To learn more about using SQLite with WinUI projects, check out this Microsoft
    Learn article: [https://learn.microsoft.com/windows/apps/develop/data-access/sqlite-data-access](https://learn.microsoft.com/windows/apps/develop/data-access/sqlite-data-access).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Microsoft的SQLite提供程序的更多信息，您可以阅读[https://learn.microsoft.com/dotnet/standard/data/sqlite/](https://learn.microsoft.com/dotnet/standard/data/sqlite/)。要了解更多关于在WinUI项目中使用SQLite的信息，请查看这篇Microsoft
    Learn文章：[https://learn.microsoft.com/windows/apps/develop/data-access/sqlite-data-access](https://learn.microsoft.com/windows/apps/develop/data-access/sqlite-data-access)。
- en: Adding SQLite as a data service
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加SQLite作为数据服务
- en: 'Follow these steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Start by adding the **Microsoft.Data.Sqlite** NuGet package to the **MyMediaCollection**
    project by opening **Package Manager Console** from **View** | **Other Windows**
    | **Package Manager Console** and running the following command. Also, make sure
    the **MyMediaCollection** project is selected in the **Package Manager Console**
    window’s project dropdown before running this command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过从**视图** | **其他窗口** | **包管理控制台**打开**包管理控制台**，然后运行以下命令，将**Microsoft.Data.Sqlite**
    NuGet包添加到**MyMediaCollection**项目中。在运行此命令之前，请确保在**包管理控制台**窗口的项目下拉菜单中选择了**MyMediaCollection**项目：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running this command is equivalent to finding and adding the package from the
    `SqliteDataService` in the `DataService` class into it as a starting point.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此命令相当于从`DataService`类中的`SqliteDataService`查找并添加包作为起点。
- en: 'Now, open `using` statements to the top of the file:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`using`语句添加到文件顶部：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `System.IO` and `Windows.Storage` namespaces will be used when we initialize
    the SQLite database file, and we’ll need the `System.Threading.Tasks` namespace
    imported to work with some `async` tasks.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们初始化SQLite数据库文件时，将使用`System.IO`和`Windows.Storage`命名空间，并且我们需要导入`System.Threading.Tasks`命名空间以处理一些`async`任务。
- en: 'Next, add a new constant to the class to hold the database’s filename:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向类中添加一个新的常量来保存数据库的文件名：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s create a private method to create or open the database file, create
    a `SqliteConnection` class for the database, open it, and return it to the caller.
    This method can be used throughout the class whenever a new database connection
    is needed. The database file will be created in the user’s `LocalFolder`, which
    means the application’s data will be saved with the user’s local Windows profile
    data:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个私有方法来创建或打开数据库文件，为数据库创建一个`SqliteConnection`类，打开它，并将其返回给调用者。此方法可以在整个类中用于需要新数据库连接的任何时候。数据库文件将创建在用户的`LocalFolder`中，这意味着应用程序的数据将与用户的本地Windows配置文件数据一起保存：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we have declared this method as `async` and that it uses the `await`
    keyword when opening or creating the file. It is a good practice to use async/await
    when using external resources such as files, network connections, or databases
    to keep your application responsive.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们已经将此方法声明为`async`，并且在打开或创建文件时使用`await`关键字。当使用外部资源，如文件、网络连接或数据库时，使用async/await是一种良好的实践，以保持应用程序的响应性。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To find out more about async/await with C# and .NET, Microsoft Learn has a
    great article to get you started: [https://learn.microsoft.com/dotnet/csharp/asynchronous-programming/](https://learn.microsoft.com/dotnet/csharp/asynchronous-programming/).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于C#和.NET中的async/await的信息，Microsoft Learn有一篇很好的文章可以帮助您入门：[https://learn.microsoft.com/dotnet/csharp/asynchronous-programming/](https://learn.microsoft.com/dotnet/csharp/asynchronous-programming/)。
- en: 'Next, create two methods that will create the `MediaItems` and `Mediums` tables
    in the database. These will be called each time the app launches, but the SQL
    code only creates the tables if they do not exist. The `SqliteCommand` object
    accepts the `tableCommand` query string and `SqliteConnection`. It has several
    methods it can use to execute the command, depending on whether any data is expected
    to be returned by the query. In our case, no return values are expected, so `ExecuteNonQueryAsync`
    is the best of the async options for these two methods:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建两个方法来在数据库中创建`MediaItems`和`Mediums`表。这些方法将在每次应用程序启动时被调用，但SQL代码只会在表不存在时创建表。`SqliteCommand`对象接受`tableCommand`查询字符串和`SqliteConnection`。它有几个方法可以用来执行命令，具体取决于查询是否预期返回任何数据。在我们的情况下，不期望返回任何值，所以`ExecuteNonQueryAsync`是这两个方法的最佳异步选项：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, create a method for the `Mediums` table to insert a row into the table:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为`Mediums`表创建一个方法来插入一行到表中：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we need another method that will read all the rows from the `Mediums`
    table:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要另一种方法来读取`Mediums`表中的所有行：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s a bit of code needed for these two simple operations. The insert method
    needs to add parameters for each property to be saved in the table, and the select
    method uses a `while` loop to add each table’s record to the collection. Let’s
    see whether we can simplify this in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些两个简单的操作需要一些代码。插入方法需要为要保存到表中的每个属性添加参数，而选择方法使用`while`循环将每个表的记录添加到集合中。让我们看看我们是否可以在下一节中简化这一点。
- en: Before we implement the remaining methods for the **Create, Read, Update, Delete**
    (**CRUD**) operations, a new library must be added to the project to simplify
    the data access code we will write.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现剩余的**创建、读取、更新、删除**（**CRUD**）操作的方法之前，必须向项目中添加一个新的库来简化我们将要编写的数据库访问代码。
- en: Leveraging a Micro ORM to simplify data access
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用微ORM简化数据访问
- en: As you saw in the previous section, writing data access code for even the simplest
    application can take some time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中看到的，为即使是简单的应用程序编写数据访问代码也可能需要一些时间。
- en: ORMs, such as **Entity Framework Core** (**EF Core**), can greatly simplify
    and reduce the code required, but they can be overkill for a small app with just
    a handful of tables. In this chapter, we’ll look at a **Micro ORM**. Micro ORMs
    are lightweight frameworks that handle mapping data between objects and data queries.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ORM，如**Entity Framework Core**（**EF Core**），可以极大地简化并减少所需的代码，但对于只有几个表的简单应用程序来说可能有些过度。在本章中，我们将探讨**微ORM**。微ORM是轻量级的框架，用于处理对象和数据查询之间的数据映射。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: EF Core is a popular ORM for .NET developers. If you want to learn more about
    how to use EF Core with your projects, you can view the Packt video *Entity Framework
    Core – a Full Tour* at [https://www.packtpub.com/product/entity-framework-core-a-full-tour-net-5-and-up-video/9781803242231](https://www.packtpub.com/product/entity-framework-core-a-full-tour-net-5-and-up-video/9781803242231).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core是.NET开发者中流行的ORM。如果你想了解更多关于如何在项目中使用EF Core的信息，你可以观看Packt的视频*Entity Framework
    Core – a Full Tour*，链接为[https://www.packtpub.com/product/entity-framework-core-a-full-tour-net-5-and-up-video/9781803242231](https://www.packtpub.com/product/entity-framework-core-a-full-tour-net-5-and-up-video/9781803242231)。
- en: 'The framework we will be using for data access in our project, Dapper, is an
    open source .NET Micro ORM that was created by the developers at **Stack Overflow**.
    You can learn more about Dapper at [https://dapperlib.github.io/Dapper/](https://dapperlib.github.io/Dapper/)
    and get the package on NuGet: [https://www.nuget.org/packages/Dapper](https://www.nuget.org/packages/Dapper).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目中用于数据访问的框架，Dapper，是由Stack Overflow的开发者创建的开源.NET微ORM。你可以在[https://dapperlib.github.io/Dapper/](https://dapperlib.github.io/Dapper/)了解更多关于Dapper的信息，并在NuGet上获取包：[https://www.nuget.org/packages/Dapper](https://www.nuget.org/packages/Dapper)。
- en: Dapper is popular within the .NET community. While it doesn’t offer some of
    the features of EF Core, such as model generation or entity change tracking, it
    does make it very easy to write a fast, slim data layer. When you add the `Dapper.Contrib`
    library ([https://www.nuget.org/packages/Dapper.Contrib](https://www.nuget.org/packages/Dapper.Contrib))
    into the mix, it is even easier to write the CRUD methods needed for your applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper在.NET社区中很受欢迎。虽然它不提供EF Core的一些功能，如模型生成或实体变更跟踪，但它确实使得编写快速、精简的数据层变得非常容易。当你将`Dapper.Contrib`库（[https://www.nuget.org/packages/Dapper.Contrib](https://www.nuget.org/packages/Dapper.Contrib)）添加到其中时，编写应用程序所需的CRUD方法就更加容易了。
- en: Adding Dapper to the project
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Dapper添加到项目中
- en: 'Let’s dive right into it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入正题：
- en: 'Start by adding `Dapper` and `Dapper.Contrib` to the **MyMediaCollection**
    project. Open the **Package Manager Console** window again and add the two packages
    to your project:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`Dapper`和`Dapper.Contrib`添加到**MyMediaCollection**项目中。再次打开**包管理器控制台**窗口，并将这两个包添加到项目中：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, revisit the `InsertMediaAsync` method. If we use the `QueryAsync` method
    provided by Dapper, we can reduce the code from our original method to this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新审视`InsertMediaAsync`方法。如果我们使用Dapper提供的`QueryAsync`方法，我们可以将原始方法中的代码减少到如下：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code we wrote to set the values of the query parameters is now gone. Dapper
    maps them for us from the `medium` object, which is passed into its `QueryAsync`
    method. You must ensure that the parameter names in the SQLite query match the
    property names on our object for Dapper’s automatic mapping to work.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们之前编写的设置查询参数值的代码现在已删除。Dapper会从传入其`QueryAsync`方法的`medium`对象中为我们映射它们。你必须确保SQLite查询中的参数名称与我们的对象上的属性名称匹配，以便Dapper的自动映射能够正常工作。
- en: 'As a bonus, we can also get the generated ID back from the `QueryAsync` call
    by adding the following SQLite code, which will return it after the `INSERT` operation
    completes:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为额外奖励，我们还可以通过添加以下SQLite代码从`QueryAsync`调用中获取生成的ID，该代码在`INSERT`操作完成后返回它：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, update the code for `GetAllMediumsAsync` to use Dapper:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`GetAllMediumsAsync`的代码以使用Dapper：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve gone from 14 lines of code to only 2\. Note, in the highlighted part of
    the query, how we use an alias of `MediaType` for the `MediumType` field. This
    is an easy way to map data to an object property that doesn’t match the database
    field name, by simply renaming the field that’s returned as part of the SQL select
    statement. Dapper has also helped us by directly returning a list of our `Medium`
    objects, instead of us having to use a `while` loop to iterate over the result
    set.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经从14行代码减少到只有2行。注意，在查询的高亮部分，我们如何使用`MediaType`的别名作为`MediumType`字段。这是一个简单地将数据映射到不匹配数据库字段名的对象属性的方法，只需简单地将作为SQL选择语句返回的字段重命名即可。Dapper还帮助我们直接返回我们的`Medium`对象列表，而不是我们不得不使用`while`循环来遍历结果集。
- en: 'Next, create a query that will get all the media items to populate the main
    `ListView` control. This query is a little more complex because we join two tables,
    `MediaItems` and `Mediums`, on `MediumId` and return the data to be mapped to
    two corresponding objects, `item` and `medium`. These types are indicated by the
    first two generic types provided to the `QueryAsync` method. To perform this mapping,
    we give Dapper a lambda expression that directs it to set `medium` as the `MediumInfo`
    property of the item for each row that’s returned from the query. The type of
    the returned object is defined by the third generic type provided to the `QueryAsync`
    method. The remaining parameters will be mapped automatically by Dapper based
    on their property names:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个查询，以获取所有媒体项以填充主`ListView`控件。这个查询稍微复杂一些，因为我们根据`MediumId`在`MediaItems`和`Mediums`两个表上进行了连接，并将数据返回以映射到两个相应的对象，`item`和`medium`。这些类型由提供给`QueryAsync`方法的前两个泛型类型指示。为了执行此映射，我们给Dapper一个lambda表达式，指示它将`medium`设置为每个从查询返回的行的`item`的`MediumInfo`属性。返回对象的类型由提供给`QueryAsync`方法的第三个泛型类型定义。其余参数将由Dapper根据它们的属性名称自动映射：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, add the code to create the insert and update methods for our media items:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加创建媒体项的插入和更新方法的代码：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code in `InsertMediaItemAsync` should look familiar. It’s very similar to
    what we did when we inserted data into the `Mediums` table. The code to update
    a row in `MediaItems` is technically only one line now, thanks to Dapper.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`InsertMediaItemAsync`中的代码应该看起来很熟悉。它与我们将数据插入`Mediums`表时所做的操作非常相似。由于Dapper，更新`MediaItems`表中一行代码现在技术上只有一行。'
- en: 'There’s one new read-only property that’s been added to the `MediaItem` object
    in our model. This property allows Dapper to map `MediumId` to the `MediaItems`
    table:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的模型中，`MediaItem`对象已添加了一个新的只读属性。这个属性允许Dapper将`MediumId`映射到`MediaItems`表：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the `Computed` attribute to the `MediaItem.MediumInfo` property. This
    tells Dapper to ignore the property when we attempt to insert or update rows in
    the database. We only need to have `MediumId` saved. Users are unable to make
    changes to the rows in the `Mediums` table:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`Computed`属性添加到`MediaItem.MediumInfo`属性。这告诉Dapper在我们尝试在数据库中插入或更新行时忽略该属性。我们只需要保存`MediumId`。用户无法更改`Mediums`表中的行：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let’s create a method that will delete items from the `MediaItems`
    table. This code is a little different, thanks to `Dapper.Contrib`. We don’t need
    to write any parameterized SQL in the code because `Dapper.Contrib` has a `DeleteAsync`
    method that generates the code to delete from `MediaItems`, based on the `Id`
    property of the `MediaItem` class provided:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个方法来从 `MediaItems` 表中删除项目。这段代码因 `Dapper.Contrib` 而有所不同。我们不需要在代码中编写任何参数化
    SQL，因为 `Dapper.Contrib` 有一个 `DeleteAsync` 方法，可以根据提供的 `MediaItem` 类的 `Id` 属性生成删除
    `MediaItems` 的代码：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To make this work, you must decorate the primary key properties of your model
    classes with `Key` attributes:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使这生效，您必须使用 `Key` 属性装饰模型类的主键属性：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make sure that every model class that uses one of the `Dapper.Contrib` attributes
    adds a `using` statement for `Dapper.Contrib.Extensions`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用 `Dapper.Contrib` 属性的每个模型类都添加一个 `using` 语句为 `Dapper.Contrib.Extensions`。
- en: Before we update all the public CRUD methods of the `SqliteDataService` class
    to call these private methods, we will complete the code that initializes the
    service when the application launches.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 `SqliteDataService` 类的所有公共 CRUD 方法更新为调用这些私有方法之前，我们将完成在应用程序启动时初始化服务的代码。
- en: Updating the data service’s initialization
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据服务的初始化
- en: 'Let’s get started:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'First, create a version of the `DataService.PopulateMediums` method in `Sqlite``     DataService`, make it `async`, and rename it `PopulateMediumsAsync`. Update this
    method so that it fetches the data from SQLite. The method will also create any
    required data if this is the first time the application has been launched for
    the current user:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `SqliteDataService` 中创建 `DataService.PopulateMediums` 方法的版本，将其改为 `async`
    并重命名为 `PopulateMediumsAsync`。更新此方法以便从 SQLite 获取数据。如果这是应用程序首次为当前用户启动，该方法还将创建所需的数据：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Second, remove `PopulateItems` from `SqliteDataService`, `DataService`, and
    `IDataService`. It will not be needed because we now persist all data between
    sessions. You can also remove the `_items` private variable.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，从 `SqliteDataService`、`DataService` 和 `IDataService` 中移除 `PopulateItems`。由于我们现在在会话之间持久化所有数据，所以它将不再需要。您还可以移除
    `_items` 私有变量。
- en: 'Now, take the code from the `SqliteDataService` constructor, move it to a new
    public method named `InitializeDataAsync`, and update the code so that it uses
    the new private initialization methods. Don’t forget to remove the call to populate
    the items collection. The `SqliteConnection` object should always be part of a
    `using` block to ensure that the connection is closed and the object is disposed
    of:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `SqliteDataService` 构造函数中的代码移至一个名为 `InitializeDataAsync` 的新公共方法中，并更新代码以便它使用新的私有初始化方法。别忘了移除填充项目集合的调用。`SqliteConnection`
    对象应始终作为 `using` 块的一部分，以确保连接被关闭并且对象被释放：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This new initialization method will need to be added to `IDataService` to make
    it available to objects that resolve the service through our DI container. If
    you keep the original `DataService` class in your project, you will need to add
    an implementation of `InitializeDataAsync` so that the project will compile:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个新的初始化方法需要添加到 `IDataService` 中，以便通过我们的 DI 容器解析服务的对象可以使用它。如果您在项目中保留原始的 `DataService`
    类，您将需要添加 `InitializeDataAsync` 的实现，以便项目可以编译：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After changing the location of the code that initializes `SqliteDataService`,
    the `RegisterComponents` method in `App.xaml.cs` will need to be updated to use
    the new `SqliteDataService` and call `InitializeDataAsync`. While we’re at it,
    rename the method to reflect its new async status:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改初始化 `SqliteDataService` 的代码位置后，`App.xaml.cs` 中的 `RegisterComponents` 方法需要更新以使用新的
    `SqliteDataService` 并调用 `InitializeDataAsync`。在此过程中，我们将方法重命名为反映其新的异步状态：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Don’t forget to update `OnLaunched` so that it’s `async` and await the call
    to the renamed `RegisterComponentsAsync`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新 `OnLaunched` 以使其为 `async` 并等待对重命名的 `RegisterComponentsAsync` 的调用。
- en: Now that the application initializes the data service when it launches, it’s
    time to update the public CRUD methods so they use the async private methods we
    created to fetch data from SQLite.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序在启动时初始化数据服务，是时候更新公共 CRUD 方法，以便它们使用我们创建的从 SQLite 获取数据的异步私有方法了。
- en: Retrieving data via services
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过服务检索数据
- en: 'Let’s start retrieving and saving SQLite data with our service methods. It
    will only be necessary to update the create, update, and delete operations. All
    the media items are stored in `List<MediaItem>` in `DataService`, so the public
    methods used to retrieve items can remain as they were in the previous chapter.
    Let’s get started:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用我们的服务方法检索和保存 SQLite 数据。只需更新创建、更新和删除操作。所有媒体项目都存储在 `DataService` 中的 `List<MediaItem>`
    中，因此用于检索项目的公共方法可以保持与上一章相同。让我们开始吧：
- en: 'Start by updating the create, update, and delete methods for the media items
    in `SqliteDataService.cs`. Each of these will get an open connection to the database
    from `GetOpenConnectionAsync` and call its corresponding private method asynchronously:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新 `SqliteDataService.cs` 中媒体项目的创建、更新和删除方法。每个方法都将从 `GetOpenConnectionAsync`
    获取数据库的打开连接并异步调用其相应的私有方法：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the public methods that fetch items to be async:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '更新获取项目的公共方法，使其变为异步:'
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to do a lot of filtering when querying data, Entity Framework is
    a more robust ORM that can provide more extensive options. SQLite is best suited
    for simpler applications. Note that, in the preceding code, `GetItemAsync` queries
    all the items and then filters to the item that matches the provided ID by using
    a lambda expression.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在查询数据时需要进行大量过滤，Entity Framework 是一个更健壮的 ORM，可以提供更广泛的选择。SQLite 最适合简单的应用程序。注意，在前面的代码中，`GetItemAsync`
    查询所有项目，然后使用 lambda 表达式过滤到与提供的 ID 匹配的项目。
- en: 'The method names have been updated to include `Async`, all uses of the `_items`
    collection have been removed, and each method has been changed to return `Task`.
    So, update the `IDataService` interface members to reflect the same changes. Also,
    either remove `DataService` from the project or update its methods to also be
    async. It’s best to try and anticipate that data access methods will need to be
    async when you set out, thus preventing breaking changes to your interfaces:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法名称已更新为包含 `Async`，已移除 `_items` 集合的所有使用，并且每个方法都已更改为返回 `Task`。因此，更新 `IDataService`
    接口成员以反映相同的更改。也可以从项目中移除 `DataService` 或更新其方法以也变为异步。最好在开始时尝试预测数据访问方法需要异步，从而防止接口出现破坏性更改：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: private async Task DeleteAsync()
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private async Task DeleteAsync()
- en: '{'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: await _dataService.DeleteItemAsync(SelectedMediaItem);
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: await _dataService.DeleteItemAsync(SelectedMediaItem);
- en: Items.Remove(SelectedMediaItem);
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Items.Remove(SelectedMediaItem);
- en: allItems.Remove(SelectedMediaItem);
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: allItems.Remove(SelectedMediaItem);
- en: '}'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the `PopulateData` method so that it’s named `PopulateDataAsync`, and
    use the async method of getting items:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `PopulateData` 方法，将其命名为 `PopulateDataAsync`，并使用获取项目的异步方法：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you will have to update the `MainViewModel` constructor to call to `PopulateDataAsync`
    at the end of the constructor:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您必须更新 `MainViewModel` 构造函数，在构造函数末尾调用 `PopulateDataAsync`：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Some similar changes will be needed in `ItemDetailsViewModel`. Update the `Save`
    method so that it’s async and awaits the data service calls to `AddItemAsync`,
    `GetItemAsync`, and `UpdateItemAsync`. Don’t forget to rename `Save` to `SaveAsync`
    and add a `using` statement for the `System.Threading.Tasks` namespace:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `ItemDetailsViewModel` 中也需要进行一些类似的更改。更新 `Save` 方法，使其变为异步并等待数据服务对 `AddItemAsync`、`GetItemAsync`
    和 `UpdateItemAsync` 的调用。别忘了将 `Save` 重命名为 `SaveAsync` 并添加一个 `using` 语句用于 `System.Threading.Tasks`
    命名空间:'
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, update the `SaveItemAndReturn` and `SaveAndContinue` methods so that
    they also use async/await:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，更新 `SaveItemAndReturn` 和 `SaveAndContinue` 方法，使它们也使用 async/await:'
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, update `ItemDetailsViewModel.xaml` so that the save buttons use the
    async methods when they bind their `Click` methods:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新 `ItemDetailsViewModel.xaml`，以便保存按钮在绑定它们的 `Click` 方法时使用异步方法：
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have any issues with the `ComboBox` not populating on the main page after
    adding or editing a media item, update `Mode` of its `ItemsSource` data binding
    to `OneWay`. The completed source code in GitHub has been updated to reflect this
    change.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在添加或编辑媒体项目后，主页面上的 `ComboBox` 无法填充，请更新其 `ItemsSource` 数据绑定的 `Mode` 为 `OneWay`。GitHub
    上的完整源代码已更新以反映此更改。
- en: 'That’s it. Run the application and see how it works. Since we’re no longer
    creating any dummy data for the media items list, the media collection in `ListView`
    will be empty when the app launches for the first time:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。运行应用程序并查看其工作情况。由于我们不再为媒体项目列表创建任何虚拟数据，当应用程序首次启动时，`ListView` 中的媒体集合将是空的：
- en: '![Figure 6.2 – Launching with a database for the first time](img/B20908_06_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 首次使用数据库启动](img/B20908_06_02.jpg)'
- en: Figure 6.2 – Launching with a database for the first time
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 首次使用数据库启动
- en: 'Try adding, updating, and removing some items. Then, close the application
    and run it again. You should see the same items on the list that were there when
    you closed it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加、更新和删除一些项目。然后，关闭应用程序并再次运行。你应该看到当你关闭它时列表上相同的项：
- en: '![Figure 6.3 – Relaunching with saved data](img/B20908_06_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 使用保存的数据重新启动](img/B20908_06_03.jpg)'
- en: Figure 6.3 – Relaunching with saved data
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 使用保存的数据重新启动
- en: Users can now retain their saved data. If you would like to browse your SQLite
    data outside your app, there are tools you can use to connect to a local `db`
    and inspect it. One of them is **DB Browser for SQLite**. Covering this tool is
    beyond the scope of this book, but you can explore it for yourself at [https://sqlitebrowser.org/](https://sqlitebrowser.org/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以保留他们的保存数据。如果你想在应用程序之外浏览SQLite数据，你可以使用一些工具来连接到本地`db`并检查它。其中之一是**DB Browser
    for SQLite**。本书的范围不包括此工具的介绍，但你可以在[https://sqlitebrowser.org/](https://sqlitebrowser.org/)自行探索。
- en: Let’s wrap up and review what we’ve learned about working with data in a WinUI
    application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结并回顾一下我们在WinUI应用程序中处理数据所学到的内容。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have covered a lot of important material in this chapter. You learned how
    to read and write data to a local SQLite database. Then, you learned how to simplify
    your data access code by leveraging Dapper, an ORM for .NET developers. Using
    an ORM will save you time creating boilerplate mapping code in your data access
    layers for WinUI projects (or any other .NET projects). All this data access code
    was made async to keep the UI responsive for the user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的重要内容。你学习了如何读取和写入本地SQLite数据库中的数据。然后，你学习了如何通过利用Dapper（一个.NET开发者的ORM）来简化你的数据访问代码。使用ORM将为你节省在WinUI项目（或任何其他.NET项目）的数据访问层中创建样板映射代码的时间。所有这些数据访问代码都被设置为异步，以保持用户界面的响应性。
- en: In the next chapter, we will learn how to create a beautiful **Fluent UI** with
    Microsoft’s Fluent UI design principles.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用微软的Fluent UI设计原则创建一个美丽的**Fluent UI**。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When will Windows put a WinUI 3 app into a suspended state?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows何时将WinUI 3应用程序置于挂起状态？
- en: When should you save the app state to ensure it is not lost if an application
    is closed?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么时候保存应用程序状态，以确保在应用程序关闭时不会丢失？
- en: What is the event you can handle on a `Page` class to perform some logic when
    every element on a page has finished loading?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`Page`类上处理哪个事件，以便在页面上的每个元素都加载完成后执行一些逻辑？
- en: What is a Micro ORM?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Micro ORM？
- en: What is the name of the Dapper package that adds CRUD helpers such as `Delete`
    and `DeleteAsync`?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加CRUD辅助工具（如`Delete`和`DeleteAsync`）的Dapper包叫什么名字？
- en: What is one of the powerful features of some more full-featured ORMs, such as
    Entity Framework?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些功能更全面的ORM（如Entity Framework）中哪一个功能非常强大？
- en: What is the name of a tool that can be used to inspect data in a SQLite database?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有什么工具可以用来检查SQLite数据库中的数据？
- en: Part 2:Extending WinUI and Modernizing Applications
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：扩展WinUI和现代化应用程序
- en: In this part, you will build on what you have learned about WinUI application
    development and expand on it, with design concepts, platform options, and open
    source libraries. The Fluent design system that is native to WinUI controls provides
    Windows application users with a familiar look and feel. You will also learn how
    to integrate app notifications with the Windows App SDK. Then, you will explore
    the Windows Community Toolkit and .NET Community Toolkit, a set of open source
    packages that offer controls and helpers to WinUI developers. Finally, Template
    Studio will give WinUI developers a head-start with best practices when starting
    a new project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将基于你关于WinUI应用程序开发的所学知识进行扩展，包括设计概念、平台选项和开源库。WinUI控件本地的Fluent设计系统为Windows应用程序用户提供了熟悉的外观和感觉。你还将学习如何将应用通知与Windows
    App SDK集成。然后，你将探索Windows Community Toolkit和.NET Community Toolkit，这是一套为WinUI开发者提供控件和辅助工具的开源包。最后，Template
    Studio将为WinUI开发者提供在新项目开始时遵循最佳实践的起点。
- en: 'This part has the following chapters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B20908_07.xhtml#_idTextAnchor152), *Fluent Design System for
    Windows Applications*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20908_07.xhtml#_idTextAnchor152)，*Windows应用程序的Fluent设计系统*'
- en: '[*Chapter 8*](B20908_08.xhtml#_idTextAnchor197), *Adding Windows Notifications
    to WinUI Applications*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20908_08.xhtml#_idTextAnchor197)，*将Windows通知添加到WinUI应用程序*'
- en: '[*Chapter 9*](B20908_09.xhtml#_idTextAnchor209), *Enhancing Applications with*
    *the Windows* *Community Toolkits*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20908_09.xhtml#_idTextAnchor209), *使用Windows社区工具包增强应用*'
- en: '[*Chapter 10*](B20908_10.xhtml#_idTextAnchor315), *Accelerating App Development
    with Template Studio*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B20908_10.xhtml#_idTextAnchor315), *使用模板工作室加速应用开发*'
