- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: ASP.NET Core Fundamentals (Part 1)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 基础知识（第 1 部分）
- en: In the previous chapter, we learned how to create a basic REST API using ASP.NET
    Core. ASP.NET Core provides a lot of features that make it easy to build web APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 ASP.NET Core 创建基本的 REST API。ASP.NET Core 提供了许多功能，使得构建 Web API
    变得容易。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Configuration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: '**Routing** is used to map incoming requests to the corresponding controller
    actions. We will discuss how to use attribute routing to configure the routing
    for ASP.NET Core web APIs. **Configuration** is used to provide the initial settings
    for an application on its startup, such as database connection strings, API keys,
    and other settings. Configuration is often used with **environments**, such as
    development, staging, and production. At the conclusion of this chapter, you will
    have the skills to create RESTful routes for your ASP.NET Core web APIs and utilize
    the ASP.NET Core configuration framework to manage configurations for different
    environments.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由**用于将传入的请求映射到相应的控制器操作。我们将讨论如何使用属性路由来配置 ASP.NET Core Web API 的路由。**配置**用于在应用程序启动时提供初始设置，例如数据库连接字符串、API
    密钥和其他设置。配置通常与**环境**一起使用，例如开发、测试和发布。在本章结束时，你将具备创建 ASP.NET Core Web API 的 RESTful
    路由以及利用 ASP.NET Core 配置框架管理不同环境配置的技能。'
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8)找到。
- en: You can use Visual Studio 2022 or **VS Code** to open the solutions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Visual Studio 2022 或**VS Code**打开解决方案。
- en: Routing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068)*,* we introduced how to create
    a simple ASP.NET Core web API project using the default controller-based template.
    The project uses some attributes, such as `[Route("api/controller")]`, `[HttpGet]`,
    and so on, to map incoming requests to the corresponding controller actions. These
    attributes are used to configure the routing for the ASP.NET Core web API project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B18971_02.xhtml#_idTextAnchor068)*中，我们介绍了如何使用默认的基于控制器的模板创建一个简单的 ASP.NET
    Core Web API 项目。该项目使用一些属性，如 `[Route("api/controller")]`、`[HttpGet]` 等，将传入的请求映射到相应的控制器操作。这些属性用于配置
    ASP.NET Core Web API 项目的路由。
- en: 'Routing is a mechanism that monitors incoming requests and determines which
    action method is to be invoked for those requests. ASP.NET Core provides two types
    of routing: conventional routing and attribute routing. Conventional routing is
    typically used for ASP.NET Core MVC applications, while ASP.NET Core web APIs
    use attribute routing. In this section, we will discuss attribute routing in more
    detail.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是一种监控传入请求并确定对这些请求应调用哪个操作方法的机制。ASP.NET Core 提供两种类型的路由：传统路由和属性路由。传统路由通常用于 ASP.NET
    Core MVC 应用程序，而 ASP.NET Core Web API 使用属性路由。在本节中，我们将更详细地讨论属性路由。
- en: You can download the `RoutingDemo` sample project from `/samples/chapter3/RoutingDemo/`
    in the chapter's GitHub repository.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从章节的 GitHub 仓库中的`/samples/chapter3/RoutingDemo/`下载`RoutingDemo`示例项目。
- en: What is attribute routing?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性路由是什么？
- en: 'Open the `Program.cs` file in the `RoutingDemo` project. You will find the
    following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RoutingDemo`项目中的`Program.cs`文件。你会找到以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line of code adds endpoints for controller actions to the `IEndpointRouteBuilder`
    instance without specifying any routes. To specify the routes, we need to use
    the `[Route]` attribute on the controller class and the action methods. The following
    code shows how to use the `[Route]` attribute on the `WeatherForecastController`
    class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将控制器操作的端点添加到`IEndpointRouteBuilder`实例中，而不指定任何路由。要指定路由，我们需要在控制器类和操作方法上使用`[Route]`属性。以下代码展示了如何在`WeatherForecastController`类上使用`[Route]`属性：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, the `[controller]` token is a placeholder for the controller
    name. In this case, the controller name is `WeatherForecast`, so the `[controller]`
    route template is replaced with `WeatherForecast`. That means the route for the
    `WeatherForecastController` class is `/WeatherForecast`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`[controller]`标记是一个用于控制器名称的占位符。在这种情况下，控制器名称是`WeatherForecast`，因此`[controller]`路由模板被替换为`WeatherForecast`。这意味着`WeatherForecastController`类的路由是`/WeatherForecast`。
- en: ASP.NET Core has some built-in route tokens, such as `[controller]`, `[action]`,
    `[area]`, `[page]`, and so on. These tokens are enclosed in square brackets (`[]`)
    and will be replaced with the corresponding values. Note that these tokens are
    reserved route parameter names and should not be used as a route parameter like
    `{controller}`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 有一些内置的路由标记，例如 `[controller]`、`[action]`、`[area]`、`[page]` 等。这些标记用方括号
    `[]` 包围，并将被替换为相应的值。请注意，这些标记是保留的路由参数名称，不应像 `{controller}` 一样用作路由参数。
- en: 'In ASP.NET Core REST web APIs, we usually use a `[Route("api/[controller]")]`
    template to represent API endpoints. You can find the `PostsController` class
    in the `Controllers` folder. The following code shows the routing attribute of
    the `PostsController` class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core REST Web API 中，我们通常使用 `[Route("api/[controller]")]` 模板来表示 API
    端点。您可以在 `Controllers` 文件夹中找到 `PostsController` 类。以下代码显示了 `PostsController` 类的路由属性：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The route for the `PostsController` class is `/api/Posts`. This is an indication
    that the endpoint is a REST API endpoint. Whether you use `/api` as the route
    prefix or not is up to you. There is no standard for this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostsController` 类的路由是 `/api/Posts`。这表明端点是 REST API 端点。是否使用 `/api` 作为路由前缀由您决定。对此没有标准。'
- en: 'Some developers prefer to use lowercase for route templates, such as `/api/posts`.
    To achieve this, the route value can be explicitly specified; for example, `[Route("api/posts")]`.
    However, it seems a bit tedious to specify the route value for each controller
    class. Fortunately, ASP.NET Core provides a way to configure the route value globally.
    Add the following code to the `Program.cs` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者更喜欢使用小写字母作为路由模板，例如 `/api/posts`。为了实现这一点，可以显式指定路由值；例如，`[Route("api/posts")]`。然而，为每个控制器类指定路由值似乎有些繁琐。幸运的是，ASP.NET
    Core 提供了一种全局配置路由值的方法。将以下代码添加到 `Program.cs` 文件中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code converts all route templates to lowercase. Actually, the
    text matching in ASP.NET Core routing is case-insensitive. So, this change only
    affects the generated paths’ URLs, such as the URLs in Swagger UI and the `/api/Posts`
    or `/api/posts` to hit the same controller route.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将所有路由模板转换为小写。实际上，ASP.NET Core 路由中的文本匹配是不区分大小写的。因此，此更改仅影响生成的路径 URL，例如 Swagger
    UI 中的 URL 和 `/api/Posts` 或 `/api/posts` 以访问相同的控制器路由。
- en: 'Multiple routes can be applied to one controller class. The following code
    shows how to apply multiple routes to the `PostsController` class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将多个路由应用于一个控制器类。以下代码显示了如何将多个路由应用于 `PostsController` 类：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, the `PostsController` class has two routes: `/api/posts` and
    `/api/some-posts-whatever`. It is not recommended to have multiple routes for
    the same controller class as this can lead to confusion. If you require multiple
    routes for the same controller class, please ensure that you have strong reasons
    for doing so.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`PostsController` 类有两个路由：`/api/posts` 和 `/api/some-posts-whatever`。不建议为同一控制器类使用多个路由，因为这可能会导致混淆。如果您需要为同一控制器类使用多个路由，请确保您有充分的理由这样做。
- en: In ASP.NET Core REST APIs, we usually do not use the `[action]` token because
    the action name is not included in the route template. Similarly, do not use the
    `[Route]` attribute for action methods. Instead, we use the HTTP method to distinguish
    action methods. We will discuss this in the following section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core REST API 中，我们通常不使用 `[action]` 标记，因为操作名称不包括在路由模板中。同样，也不要为操作方法使用
    `[Route]` 属性。相反，我们使用 HTTP 方法来区分操作方法。我们将在下一节中讨论这一点。
- en: Mapping HTTP methods to action methods
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 HTTP 方法映射到操作方法
- en: 'REST APIs are centered on resources. When we design a REST API, we need to
    map the CRUD operations to the HTTP methods. In ASP.NET Core, we can use the following
    HTTP verb attributes to map HTTP methods to action methods:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 以资源为中心。当我们设计 REST API 时，需要将 CRUD 操作映射到 HTTP 方法。在 ASP.NET Core 中，我们可以使用以下
    HTTP 动词属性将 HTTP 方法映射到操作方法：
- en: '`[HttpGet]` maps an HTTP `GET` method to an action method'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpGet]` 将 HTTP `GET` 方法映射到操作方法'
- en: '`[HttpPost]` maps an HTTP `POST` method to an action method'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpPost]` 将 HTTP `POST` 方法映射到操作方法'
- en: '`[HttpPut]` maps an HTTP `PUT` method to an action method'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpPut]` 将 HTTP `PUT` 方法映射到操作方法'
- en: '`[HttpDelete]` maps an HTTP `DELETE` method to an action method'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpDelete]` 将 HTTP `DELETE` 方法映射到操作方法'
- en: '`[HttpPatch]` maps an HTTP `PATCH` method to an action method'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpPatch]` 将 HTTP `PATCH` 方法映射到操作方法'
- en: '`[HttpHead]` maps an HTTP `HEAD` method to an action method'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpHead]` 将 HTTP `HEAD` 方法映射到操作方法'
- en: 'The following code shows how to use the `[HttpGet]` attribute to map the HTTP
    `GET` method to the `GetPosts()` action method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 `[HttpGet]` 属性将 HTTP `GET` 方法映射到 `GetPosts()` 动作方法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In ASP.NET Core REST APIs, each action must have an HTTP verb attribute. If
    you do not specify an HTTP verb attribute, the framework cannot determine which
    method should be invoked for the incoming request. In the preceding code, a `GET`
    request to the `/api/posts` endpoint is mapped to the `GetPosts()` action method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core REST API 中，每个动作都必须有一个 HTTP 动词属性。如果您没有指定 HTTP 动词属性，框架无法确定应该调用哪个方法来处理传入的请求。在前面的代码中，对
    `/api/posts` 端点的 `GET` 请求被映射到 `GetPosts()` 动作方法。
- en: 'The following code shows how to use the `[HttpGet]` attribute to map the HTTP
    `GET` method to the `GetPost()` action method with a route template:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 `[HttpGet]` 属性将 HTTP `GET` 方法映射到带有路由模板的 `GetPost()` 动作方法：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding `HttpGet` attribute has an `{id}` route template, which is a route
    parameter. The route parameter is enclosed in curly braces ( `{}`). The route
    parameter is used to capture the value from the incoming request. For example,
    a `GET` request to the `/api/posts/1` endpoint is mapped to the `GetPost(int id)`
    action method, and the value `1` is captured by the `{id}` route parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `HttpGet` 属性有一个 `{id}` 路由模板，这是一个路由参数。路由参数被括号 `{}` 包围。路由参数用于捕获传入请求的值。例如，对
    `/api/posts/1` 端点的 `GET` 请求被映射到 `GetPost(int id)` 动作方法，值 `1` 被由 `{id}` 路由参数捕获。
- en: 'The following code shows how to use the `[HttpPut]` attribute to publish a
    post:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 `[HttpPut]` 属性来发布一个帖子：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding `HttpPut` attribute has an `{id}/publish` route template. The
    `publish` literal is used to match the `publish` literal in the incoming request.
    So, a `PUT` request to the `/api/posts/1/publish` endpoint is mapped to the `PublishPost(int
    id)` action method, and the value `1` is captured by the `{id}` route parameter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `HttpPut` 属性有一个 `{id}/publish` 路由模板。`publish` 文本用于匹配传入请求中的 `publish` 文本。因此，对
    `/api/posts/1/publish` 端点的 `PUT` 请求被映射到 `PublishPost(int id)` 动作方法，值 `1` 被由 `{id}`
    路由参数捕获。
- en: 'When defining a route template, please make sure there are no conflicts. For
    example, we want to add a new action method to get posts by a user ID. If we use
    the following code, it will not work:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义路由模板时，请确保没有冲突。例如，我们想要添加一个新的动作方法来通过用户 ID 获取帖子。如果我们使用以下代码，它将不会工作：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is because we already have a `GetPost()` action method that uses `[HttpGet("{id}")]`.
    When sending a `GET` request to the `/api/posts/1` endpoint, the request matches
    multiple actions, so you will see a `500` error as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们已经有了一个使用 `[HttpGet("{id}")]` 的 `GetPost()` 动作方法。当向 `/api/posts/1` 端点发送
    `GET` 请求时，请求匹配多个动作，因此您将看到一个如下所示的 `500` 错误：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To fix it, we need to specify a different template, such as `[HttpGet("user/{userId}")]`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复它，我们需要指定一个不同的模板，例如 `[HttpGet("user/{userId}")]`。
- en: Route constraints
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由约束
- en: In the previous section, we introduced how to use a route parameter to capture
    the value from an incoming request. A `[HttpGet("{id}")]` attribute can match
    a `GET` request to the `/api/posts/1` endpoint. But what if the request is a `GET`
    request to the `/``api/posts/abc` endpoint?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了如何使用路由参数来捕获传入请求的值。一个 `[HttpGet("{id}")]` 属性可以匹配对 `/api/posts/1`
    端点的 `GET` 请求。但如果请求是对 `/api/posts/abc` 端点的 `GET` 请求呢？
- en: As the `id` parameter is of type `int`, the framework will try to convert the
    captured value to an `int` value. If the conversion fails, the framework will
    return a `400 Bad Request` response. So, a `GET` request to the `/api/posts/abc`
    endpoint will fail and return a `400 Bad` `Request` response.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `id` 参数的类型是 `int`，框架将尝试将捕获的值转换为 `int` 值。如果转换失败，框架将返回一个 `400 Bad Request`
    响应。因此，对 `/api/posts/abc` 端点的 `GET` 请求将失败并返回一个 `400 Bad Request` 响应。
- en: 'We can add route constraints to route parameters to restrict the values of
    the route parameters. For example, we can add a route constraint to the `id` parameter
    to ensure that the `id` parameter is an integer. The following code shows how
    to add a route constraint to the `id` parameter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向路由参数添加路由约束来限制路由参数的值。例如，我们可以向 `id` 参数添加一个路由约束以确保 `id` 参数是一个整数。以下代码展示了如何向
    `id` 参数添加路由约束：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the `id` parameter must be an integer. A `GET` request to the `/api/posts/abc`
    endpoint will return a `404 Not Found` response because the route does not match.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`id` 参数必须是一个整数。对 `/api/posts/abc` 端点的 `GET` 请求将返回一个 `404 Not Found` 响应，因为路由不匹配。
- en: 'ASP.NET Core provides a set of built-in route constraints, such as the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一套内置的路由约束，例如以下内容：
- en: '`int`: The parameter must be an integer value.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：参数必须是一个整数值。'
- en: '`bool`: The parameter must be a Boolean value.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：参数必须是一个布尔值。'
- en: '`datetime`: The parameter must be a DateTime value.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime`：参数必须是一个DateTime值。'
- en: '`decimal`: The parameter must be a `decimal` value. Similarly, there are `double`,
    `float`, `long`, and so on.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`：参数必须是一个`decimal`值。同样，还有`double`、`float`、`long`等。'
- en: '`guid`: The parameter must be a GUID value.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guid`：参数必须是一个GUID值。'
- en: '`minlength(value)`: The parameter must be a string with a minimum length; for
    example, `{name:minlength(6)}`, which means the `name` parameter must be a string
    and the length of the string must be at least 6 characters. Similarly, there are
    `maxlength(value)`, `length(value)`, `length(min, max)`, and so on.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minlength(value)`：参数必须是一个具有最小长度的字符串；例如，`{name:minlength(6)}`，这意味着`name`参数必须是一个字符串，且字符串的长度必须至少为6个字符。同样，还有`maxlength(value)`、`length(value)`、`length(min,
    max)`等。'
- en: '`min(value)`: The parameter must be an integer with a minimum value; for example,
    `{id:min(1)}`, which means the `id` parameter must be an integer and the value
    must be greater than or equal to 1\. Similarly, there are `max(value)`, `range(min,`
    `max)`, and so on.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min(value)`：参数必须是一个具有最小值的整数；例如，`{id:min(1)}`，这意味着`id`参数必须是一个整数，且其值必须大于或等于1。同样，还有`max(value)`、`range(min,
    max)`等。'
- en: '`alpha`: The parameter must be a string with one or more letters.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`：参数必须是一个包含一个或多个字母的字符串。'
- en: '`regex(expression)`: The parameter must be a string that matches the regular
    expression.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regex(expression)`：参数必须是一个与正则表达式匹配的字符串。'
- en: '`required`: The parameter must be provided in the route; for example, `{id:required}`,
    which means the `id` parameter must be provided in the route.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`：参数必须在路由中提供；例如，`{id:required}`，这意味着`id`参数必须在路由中提供。'
- en: If the value of the route parameter does not match the route constraint, the
    action method will not accept the request, and a `404 Not Found` response will
    be returned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由参数的值不符合路由约束，则操作方法将不接受请求，并返回一个`404 Not Found`响应。
- en: 'Multiple route constraints can be applied together. The following code shows
    how to apply multiple route constraints to the `id` parameter, which means the
    `id` parameter must be an integer and the value must be greater than or equal
    to 1 and less than or equal to 100:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时应用多个路由约束。以下代码展示了如何将多个路由约束应用于`id`参数，这意味着`id`参数必须是一个整数，且其值必须大于或等于1且小于或等于100：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Route constraints can be used to make a route more specific. However, they should
    not be used to validate the input. If the input is invalid, the API should return
    a `400 Bad Request` response rather than a `404 Not` `Found` response.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 路由约束可以用来使路由更加具体。然而，它们不应该用来验证输入。如果输入无效，API应该返回一个`400 Bad Request`响应，而不是`404 Not
    Found`响应。
- en: Binding source attributes
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定源属性
- en: 'We can define parameters in the action. See the following action method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在操作中定义参数。请参见以下操作方法：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `GetPost()` method has a parameter named `id`, which matches the parameter
    in the `{id}` route template. So, the value of `id` will come from the route,
    such as 1 in the `/api/posts/1` URL. This is called parameter inference.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPost()`方法有一个名为`id`的参数，它与`{id}`路由模板中的参数相匹配。因此，`id`的值将来自路由，例如在`/api/posts/1`
    URL中的1。这被称为参数推断。'
- en: 'ASP.NET Core offers the following binding source attributes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了以下绑定源属性：
- en: '`[FromBody]`: The parameter is from the request body'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromBody]`：参数来自请求体'
- en: '`[FromForm]`: The parameter is from the form data in the request body'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromForm]`：参数来自请求体中的表单数据'
- en: '`[FromHeader]`: The parameter is from the request header'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromHeader]`：参数来自请求头'
- en: '`[FromQuery]`: The parameter is from the query strings in the request'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromQuery]`：参数来自请求中的查询字符串'
- en: '`[FromRoute]`: The parameter is from the route path'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromRoute]`：参数来自路由路径'
- en: '`[FromServices]`: The parameter is from the **DI** container'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromServices]`：参数来自**DI**容器'
- en: 'For example, we can define a pagination action method as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个分页操作方法如下：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code means the `pageIndex` parameter and the `pageSize` parameter
    should be from query strings in the URL, such as `/api/posts/paged?pageIndex=1&pageSize=10`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码意味着`pageIndex`参数和`pageSize`参数应来自URL中的查询字符串，例如`/api/posts/paged?pageIndex=1&pageSize=10`。
- en: 'When an `[ApiController]` attribute is applied to a controller class, a set
    of default inference rules will be applied, so we do not need to explicitly add
    these binding source attributes. For example, the following code shows a `POST`
    action method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `[ApiController]` 属性应用于控制器类时，将应用一组默认推断规则，因此我们不需要显式添加这些绑定源属性。例如，以下代码显示了一个 `POST`
    动作方法：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `keyword` parameter is a simple type, so `[FromQuery]` inferred that the
    `keyword` parameter should be from the query strings in the URL, such as `/api/posts/search?keyword=xyz`.
    If we want to force the `keyword` parameter to be from the request body, we can
    use the `[FromBody]` attribute as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyword` 参数是简单类型，所以 `[FromQuery]` 推断 `keyword` 参数应该来自 URL 中的查询字符串，例如 `/api/posts/search?keyword=xyz`。如果我们想强制
    `keyword` 参数来自请求体，我们可以使用以下 `[FromBody]` 属性：'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, the `keyword` parameter must be from the request body. Note that this
    is a bad example because we usually do not use the request body to pass a simple
    type parameter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`keyword` 参数必须来自请求体。请注意，这是一个不好的例子，因为我们通常不会使用请求体来传递简单类型参数。
- en: 'The default inference rules of those binding source attributes are listed next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定源属性的默认推断规则如下：
- en: For complex type parameters, if the type is registered in the DI container,
    `[FromServices]` is inferred.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于复杂类型参数，如果类型已在 DI 容器中注册，则 `[FromServices]` 是推断的。
- en: For complex type parameters that are not registered in the DI container, `[FromBody]`
    is inferred. It does not support multiple `[``FromBody]` parameters.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于未在 DI 容器中注册的复杂类型参数， `[FromBody]` 是推断的。它不支持多个 `[FromBody]` 参数。
- en: For types such as `IFormFile` and `IFormFileCollection`, `[FromForm]` is inferred.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `IFormFile` 和 `IFormFileCollection` 等类型， `[FromForm]` 是推断的。
- en: For any parameters that appear in the route, `[FromRoute]` is inferred.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于出现在路由中的任何参数， `[FromRoute]` 是推断的。
- en: For any parameters of simple types, such as `int`, `string`, and so on, `[FromQuery]`
    is inferred.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何简单类型的参数，例如 `int`、`string` 等， `[FromQuery]` 是推断的。
- en: If a parameter can be inferred based on these rules, the binding source attribute
    can be omitted. Otherwise, we need to explicitly specify the binding source attribute.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以根据这些规则推断参数，则可以省略绑定源属性。否则，我们需要显式指定绑定源属性。
- en: Routing is a very important concept in REST APIs. Ensure that routes are well
    designed, intuitive, and easy to understand. This will help the consumers of your
    REST APIs use them easily.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是 REST API 中一个非常重要的概念。确保路由设计良好、直观且易于理解。这将有助于您的 REST API 的消费者轻松使用它们。
- en: Next, we will check the configuration in ASP.NET Core.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查 ASP.NET Core 中的配置。
- en: Configuration
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: ASP.NET Core provides a comprehensive configuration framework that makes it
    easy to work with configuration settings. A configuration is considered a key-value
    pair. These configuration settings are stored in a variety of sources, such as
    JSON files, environment variables, and command-line arguments, or in the cloud,
    such as Azure Key Vault. In ASP.NET Core, these sources are referred to as **configuration
    providers**. Each configuration provider is responsible for loading configuration
    settings from a specific source.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一个全面的配置框架，使得与配置设置一起工作变得容易。配置被视为键值对。这些配置设置存储在多种来源中，例如 JSON 文件、环境变量、命令行参数，或者在云中，例如
    Azure Key Vault。在 ASP.NET Core 中，这些来源被称为 **配置提供者**。每个配置提供者负责从特定来源加载配置设置。
- en: 'ASP.NET Core supports a set of configuration providers, such as the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 支持一组配置提供者，例如以下：
- en: The file configuration provider, such as, `appsettings.json`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件配置提供者，例如，`appsettings.json`
- en: The User secrets
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户密钥
- en: The environment variables configuration provider
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量配置提供者
- en: The command-line configuration provider
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行配置提供者
- en: The Azure App Configuration provider
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 应用配置提供者
- en: The Azure Key Vault configuration provider
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 密钥保管库配置提供者
- en: The configuration of ASP.NET Core is provided by the `Microsoft.Extension.Configuration`
    NuGet package. You do not need to install this package explicitly as it is already
    installed with the default ASP.NET Core template, which provides several built-in
    configuration providers, such as `appsettings.json`. These configuration providers
    are configured in priority order. We will discuss this in more detail in the *Understanding
    the priorities of configuration and environment variables* section. First, let
    us look at how to use `appsettings.json`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的配置由 `Microsoft.Extension.Configuration` NuGet 包提供。您不需要显式安装此包，因为它已经包含在默认的
    ASP.NET Core 模板中，该模板提供了几个内置配置提供程序，例如 `appsettings.json`。这些配置提供程序按优先级顺序配置。我们将在
    *理解配置和环境的优先级* 部分中详细讨论这一点。首先，让我们看看如何使用 `appsettings.json`。
- en: 'Run the following command to create a new ASP.NET Core web API project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的 ASP.NET Core Web API 项目：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can download the example project named `ConfigurationDemo` from the `/samples/chapter3/ConfigurationDemo`
    folder in the chapter's GitHub repository.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从章节的 GitHub 仓库中的 `/samples/chapter3/ConfigurationDemo` 文件夹下载名为 `ConfigurationDemo`
    的示例项目。
- en: Using appsettings.json
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 appsettings.json
- en: 'By default, ASP.NET Core apps are configured to read configuration settings
    from `appsettings.json` using `JsonConfigurationProvider`. The `appsettings.json`
    file is located in the project’s root directory, which is a JSON file that contains
    key-value pairs. The following code shows the default content of the `appsettings.json`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ASP.NET Core 应用程序配置为使用 `JsonConfigurationProvider` 从 `appsettings.json`
    读取配置设置。`appsettings.json` 文件位于项目的根目录中，它是一个包含键值对的 JSON 文件。以下代码显示了 `appsettings.json`
    文件的默认内容：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will find another `appsettings.Development.json` file, which will be used
    for the development environment. We will introduce the environment in the following
    section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您将找到另一个 `appsettings.Development.json` 文件，它将用于开发环境。我们将在下一节介绍环境。
- en: 'Let us add a `"MyKey": "MyValue"` key-value pair to the `appsettings.json`
    file. This key-value pair is an example configuration that we will read in the
    code using `JsonConfigurationProvider`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们在 `appsettings.json` 文件中添加一个 `"MyKey": "MyValue"` 键值对。这个键值对是我们将在代码中使用 `JsonConfigurationProvider`
    读取的示例配置：'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new controller named `ConfigurationController` in the `Controllers`
    folder. In this controller, we will read the configuration value from the `appsettings.json`
    file and return it as a string. The following code shows the `ConfigurationController`
    class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Controllers` 文件夹中创建一个名为 `ConfigurationController` 的新控制器。在这个控制器中，我们将从 `appsettings.json`
    文件中读取配置值并将其作为字符串返回。以下代码显示了 `ConfigurationController` 类：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To access the configuration settings, we need to inject the `IConfiguration`
    interface into the constructor of the controller. The `IConfiguration` interface
    represents a set of key/value application configuration properties. The following
    code shows how to access the configuration settings:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问配置设置，我们需要将 `IConfiguration` 接口注入到控制器的构造函数中。`IConfiguration` 接口表示一组键值应用配置属性。以下代码显示了如何访问配置设置：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the application and send a request to the `/Configuration/my-key` endpoint.
    You can use any HTTP client, such as Postman, Thunder Client in VS Code, or HttpRepl.
    The following code shows how to use HttpRepl:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/Configuration/my-key` 端点发送请求。您可以使用任何 HTTP 客户端，例如 Postman、VS Code
    中的 Thunder Client 或 HttpRepl。以下代码显示了如何使用 HttpRepl：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will see the following response:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下响应：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The configuration supports hierarchical settings. For example, consider the
    following configuration settings:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 配置支持分层设置。例如，考虑以下配置设置：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To access the `Type` and `ConnectionString` properties, we can use the following
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `Type` 和 `ConnectionString` 属性，我们可以使用以下代码：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we use a colon (`:`) to separate the hierarchical settings.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用冒号 (`:`) 来分隔分层设置。
- en: 'Run the application and send a request to the `/Configuration/database-configuration`
    endpoint. If you use HttpRepl, you can use the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/Configuration/database-configuration` 端点发送请求。如果您使用 HttpRepl，可以使用以下命令：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following code shows a response from HttpRepl:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了 HttpRepl 的响应：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the `IConfiguration` interface, we can access the configuration settings
    with the `configuration[key]` format. However, hardcoding the keys is not a good
    practice. To avoid hardcoding, ASP.NET Core supports the options pattern, which
    can provide a strongly typed way to access hierarchical settings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IConfiguration` 接口，我们可以使用 `configuration[key]` 格式访问配置设置。然而，硬编码键不是一种好的做法。为了避免硬编码，ASP.NET
    Core 支持选项模式，它可以提供一种强类型的方式来访问分层设置。
- en: Using the options pattern
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选项模式
- en: 'To use the options pattern, we need to create a class that represents the configuration
    settings. The following code shows how to create a class named `DatabaseOption`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用选项模式，我们需要创建一个表示配置设置的类。以下代码显示了如何创建一个名为 `DatabaseOption` 的类：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `SectionName` field is used to specify the section name in the `appsettings.json`
    file. This field is not mandatory. But if we do not define it here, we will need
    to pass a hardcoded string for the section name when we bind the configuration
    section. To better leverage the strong typing, we can define a `SectionName` field.
    The `Type` and `ConnectionString` properties are used to represent the `Type`
    and `ConnectionString` fields in the `appsettings.json` file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`SectionName` 字段用于指定 `appsettings.json` 文件中的部分名称。此字段不是必需的。但如果我们没有在这里定义它，当我们绑定配置部分时，我们需要传递一个硬编码的字符串作为部分名称。为了更好地利用强类型，我们可以定义一个
    `SectionName` 字段。`Type` 和 `ConnectionString` 属性用于表示 `appsettings.json` 文件中的 `Type`
    和 `ConnectionString` 字段。'
- en: Note that an option class must be non-abstract with a public parameterless constructor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，选项类必须是非抽象的，并且具有公共的无参构造函数。
- en: There are multiple ways to use the options pattern. Let's continue.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以使用选项模式。让我们继续。
- en: Using the ConfigurationBinder.Bind() method
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ConfigurationBinder.Bind() 方法
- en: First, Let's use the `ConfigurationBinder.Bind()` method, which attempts to
    bind a given object instance to configuration values by recursively matching property
    names against configuration keys.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 `ConfigurationBinder.Bind()` 方法，该方法尝试通过递归匹配属性名称与配置键来将给定的对象实例绑定到配置值。
- en: 'In the `ConfigurationController` class, add the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ConfigurationController` 类中添加以下代码：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the application and send a request to the `/Configuration/database-configuration-with-bind`
    endpoint. You will see the same response as in the previous section, *Using appsettings.json*.
    In this way, we can use the strongly typed option class to access the configuration
    settings, such as `databaseOption.Type`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/Configuration/database-configuration-with-bind` 端点发送请求。您将看到与上一节中相同的响应，*使用
    appsettings.json*。这样，我们可以使用强类型选项类来访问配置设置，例如 `databaseOption.Type`。
- en: Using the ConfigurationBinder.Get<TOption>() method
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ConfigurationBinder.Get<TOption>() 方法
- en: 'We can also use the `ConfigurationBinder.Get<TOption>()` method, which attempts
    to bind the configuration instance to a new instance of type `T`. If this configuration
    section has a value, then that value will be used; otherwise, it attempts to bind
    the configuration instance by matching property names against configuration keys
    recursively. The code is shown next:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `ConfigurationBinder.Get<TOption>()` 方法，该方法尝试将配置实例绑定到类型 `T` 的新实例。如果此配置部分有值，则使用该值；否则，它尝试通过递归匹配属性名称与配置键来绑定配置实例。以下代码显示了如何实现：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the application and send a request to the `/Configuration/database-configuration-with-generic-type`
    endpoint. You will see the same response as in the *Using* *appsettings.json*
    section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/Configuration/database-configuration-with-generic-type` 端点发送请求。您将看到与
    *使用* *appsettings.json* 部分相同的响应。
- en: Using the IOptions<TOption> interface
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IOptions<TOption> 接口
- en: 'ASP.NET Core provides built-in DI support for the options pattern. To use DI,
    we need to register the `DatabaseOption` class in the `Services.Configure()` method
    of the `Program.cs` file. The following code shows how to register the `DatabaseOption`
    class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 为选项模式提供了内置的依赖注入支持。要使用依赖注入，我们需要在 `Program.cs` 文件的 `Services.Configure()`
    方法中注册 `DatabaseOption` 类。以下代码显示了如何注册 `DatabaseOption` 类：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we can use DI to inject the `IOptions<DatabaseOption>` interface into
    the `ConfigurationController` class. The following code shows how to inject the
    `IOptions<DatabaseOption>` interface:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用依赖注入将 `IOptions<DatabaseOption>` 接口注入到 `ConfigurationController` 类中。以下代码显示了如何注入
    `IOptions<DatabaseOption>` 接口：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the application and send a request to the `/Configuration/database-configuration-with-ioptions`
    endpoint. You will see the same response as in the *Using* *appsettings.json*
    section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/Configuration/database-configuration-with-ioptions` 端点发送请求。你会看到与
    *使用* *appsettings.json* 部分相同的响应。
- en: Using other options interfaces
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他选项接口
- en: We have introduced several ways to use the options pattern. What differences
    do they have?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了几种使用选项模式的方法。它们有什么区别？
- en: Run the application and test the preceding endpoints. You will see all responses
    are the same, which contains a `Type` property with the value `SQL Server`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并测试前面的端点。你会看到所有响应都是相同的，其中包含一个值为 `SQL Server` 的 `Type` 属性。
- en: 'Keep the application running. Let''s make a change to the `appsettings.json`
    file. Change the `Type` property from `SQL Server` to `MySQL`. Save the file and
    send the requests to these endpoints again. You will find the following results:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 保持应用程序运行。让我们更改 `appsettings.json` 文件。将 `Type` 属性从 `SQL Server` 更改为 `MySQL`。保存文件并再次向这些端点发送请求。你会发现以下结果：
- en: '`database-configuration` returns the *new* value `MySQL`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database-configuration` 返回新的值 `MySQL`'
- en: '`database-configuration-with-bind` returns the *new* value `MySQL`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database-configuration-with-bind` 返回新的值 `MySQL`'
- en: '`database-configuration-with-generic-type` returns the *new* value `MySQL`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database-configuration-with-generic-type` 返回新的值 `MySQL`'
- en: '`database-configuration-with-ioptions` returns the *old* value `SQL Server`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database-configuration-with-ioptions` 返回旧的值 `SQL Server`'
- en: 'Let''s try to use the `IOptionsSnapshot<T>` interface to replace the `IOptions<TOption>`
    interface. The `IOptionsSnapshot<TOption>` interface provides a snapshot of options
    for the current request. The following code shows how to use the `IOptionsSnapshot<TOption>`
    interface:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `IOptionsSnapshot<T>` 接口替换 `IOptions<TOption>` 接口。`IOptionsSnapshot<TOption>`
    接口提供了当前请求的选项快照。以下代码显示了如何使用 `IOptionsSnapshot<TOption>` 接口：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run the application again. Change the `Type` property in the `appsettings.json`
    file. Send requests to the `/Configuration/database-configuration-with-ioptions-snapshot`
    endpoint. You will find the response is the *new* value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序。更改 `appsettings.json` 文件中的 `Type` 属性。向 `/Configuration/database-configuration-with-ioptions-snapshot`
    端点发送请求。你会发现响应是新的值。
- en: 'Okay, we now know the difference between the `IOptions<TOption>` interface
    and the `IOptionsSnapshot<TOption>` interface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在知道了 `IOptions<TOption>` 接口和 `IOptionsSnapshot<TOption>` 接口之间的区别：
- en: The `IOptions<TOption>` interface provides a way to access options, but it cannot
    get the latest value if the setting value has been changed when the application
    is running.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptions<TOption>` 接口提供了一种访问选项的方式，但如果在应用程序运行时设置值已更改，则它无法获取最新值。'
- en: The `IOptionsSnapshot<TOption>` interface provides a snapshot of options for
    the current request. The `IOptionsSnapshot<TOption>` interface is useful when
    we want to get the latest options for the current request.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptionsSnapshot<TOption>` 接口提供了当前请求的选项快照。当我们需要获取当前请求的最新选项时，`IOptionsSnapshot<TOption>`
    接口非常有用。'
- en: But why?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么呢？
- en: 'The ASP.NET Core framework provides built-in support for `appsetting.json`
    using `JsonConfigurationProvider`, which reads the configuration values from the
    `appsettings.json` file. When the framework registers `JsonConfigurationProvider`,
    the code looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 框架使用 `JsonConfigurationProvider` 内置支持 `appsetting.json`，它从 `appsettings.json`
    文件中读取配置值。当框架注册 `JsonConfigurationProvider` 时，代码看起来像这样：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `reloadOnChange` parameter is set to `true`, which means the configuration
    values will be reloaded if the `appsettings.json` file has been changed. So, the
    `ConfigurationBinder.Bind()` method and the `ConfigurationBinder.Get<TOption>()`
    method can get the latest value.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`reloadOnChange` 参数设置为 `true`，这意味着如果 `appsettings.json` 文件已更改，则配置值将被重新加载。因此，`ConfigurationBinder.Bind()`
    方法和 `ConfigurationBinder.Get<TOption>()` 方法可以获取最新值。'
- en: However, when the `IOptions<TOption>` interface is registered by the ASP.NET
    Core framework, it is registered as a *singleton* service, which means an instance
    of `IOption<TOption>` will be created only once. You can inject it into any service
    lifetime, but it cannot read the latest value if the setting value has been changed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当 ASP.NET Core 框架注册 `IOptions<TOption>` 接口时，它被注册为一个 *单例* 服务，这意味着 `IOption<TOption>`
    的实例只会创建一次。你可以将其注入到任何服务生命周期中，但如果设置值已更改，则它无法读取最新值。
- en: In contrast, the `IOptionsSnapshot<TOption>` interface is registered as a *scoped*
    service, so it cannot be injected into a singleton service. It is useful in scenarios
    if you want to get the latest options for each request.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`IOptionsSnapshot<TOption>`接口注册为*作用域*服务，因此不能注入到单例服务中。如果您想为每个请求获取最新的选项，它很有用。
- en: It looks like `IOptionsSnapshot<TOption>` is better than `IOptions<TOption>`.
    Not really. `IOptionsSnapshot<TOption>` can only cache options for the current
    request. It may cause performance issues because it is recomputed per request.
    So, you need to choose the interface to use wisely. If the options are not changed,
    you can use the `IOptions<TOption>` interface. If the options are changed frequently
    and you want to ensure the app gets the latest value per request, you can use
    the `IOptionsSnapshot<TOption>` interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`IOptionsSnapshot<TOption>`比`IOptions<TOption>`更好。实际上并不是。`IOptionsSnapshot<TOption>`只能缓存当前请求的选项。因为它会根据请求重新计算，所以可能会引起性能问题。因此，您需要明智地选择要使用的接口。如果选项没有变化，您可以使用`IOptions<TOption>`接口。如果选项经常变化，并且您想确保应用程序在每个请求中都能获取到最新的值，您可以使用`IOptionsSnapshot<TOption>`接口。
- en: 'There is another options interface called `IOptionsMonitor<TOption>`. It is
    a combination of the `IOptions<TOption>` and the `IOptionsSnapshot<TOption>` interfaces.
    It provides the following features:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项接口叫做`IOptionsMonitor<TOption>`。它是`IOptions<TOption>`和`IOptionsSnapshot<TOption>`接口的组合。它提供了以下功能：
- en: It is a singleton service, which can be injected into any service lifetime
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个单例服务，可以被注入到任何服务生命周期
- en: It supports reloadable configuration
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持可重载的配置
- en: 'Here is an example of using the `IOptionsMonitor<TOption>` interface:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`IOptionsMonitor<TOption>`接口的一个示例：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `IOptionsMonitor<TOption>` interface provides the `CurrentValue` property
    to get the latest value. It also provides the `OnChange(Action<TOption, string>
    listener)` method to register a listener that will be called whenever the options
    are reloaded. Normally, you do not need to use the `OnChange()` method unless
    you want to do something when the options are reloaded.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOptionsMonitor<TOption>`接口提供了`CurrentValue`属性来获取最新值。它还提供了`OnChange(Action<TOption,
    string> listener)`方法来注册一个监听器，该监听器将在选项重新加载时被调用。通常，除非您想在选项重新加载时执行某些操作，否则您不需要使用`OnChange()`方法。'
- en: Using named options
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命名选项
- en: 'Sometimes, we need to use multiple database instances in our application. Consider
    the following scenario:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在应用程序中使用多个数据库实例。考虑以下场景：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Rather than creating two classes to represent the two database options, we
    can use the named options feature. The following code shows how to use the named
    options feature for each section:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建两个类来表示两个数据库选项，我们可以使用命名选项功能。以下代码展示了如何为每个部分使用命名选项功能：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, register the named options feature in the `Program.cs` file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Program.cs`文件中注册命名选项功能：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following code shows how to access the named options:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何访问命名选项：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the application and send a request to the `/Configuration/database-configuration-with-named-options`
    endpoint. You will find the response contains the two database options, as shown
    next:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向`/Configuration/database-configuration-with-named-options`端点发送请求。您会发现响应包含两个数据库选项，如下所示：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, Let''s summarize the options feature in ASP.NET Core:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下ASP.NET Core中的选项功能：
- en: '|  | **Server lifetime** | **Reloadable** **configuration** | **Named options**
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  | **服务器生命周期** | **可重载** **配置** | **命名选项** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `IOptions<TOption>` | Singleton | No | No |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `IOptions<TOption>` | 单例 | 否 | 否 |'
- en: '| `IOptionsSnapshot<TOption>` | Scope | Yes | Yes |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsSnapshot<TOption>` | 作用域 | 是 | 是 |'
- en: '| `IOptionsMonitor<TOption>` | Singleton | Yes | Yes |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsMonitor<TOption>` | 单例 | 是 | 是 |'
- en: Table 3.1 – Summary of the options feature in `ASP.NET` Core
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 – `ASP.NET` Core中选项功能的总结
- en: Next, we will discuss how to register a group of options to make the `Program.cs`
    file cleaner.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何注册一组选项以使`Program.cs`文件更简洁。
- en: Group options registration
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组选项注册
- en: 'In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068), we introduced how to use
    group registration to register multiple services in an extension method. The group
    registration feature is also available for the options feature. The following
    code shows how to use the group registration feature to register multiple options:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18971_02.xhtml#_idTextAnchor068)中，我们介绍了如何在扩展方法中使用分组注册来注册多个服务。分组注册功能也适用于选项功能。以下代码展示了如何使用分组注册功能来注册多个选项：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, register the options in the `Program.cs` file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Program.cs` 文件中注册选项：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, the `Program.cs` file is much cleaner.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Program.cs` 文件变得更加简洁。
- en: Other configuration providers
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他配置提供者
- en: We mentioned that ASP.NET Core supports multiple configuration providers. The
    configuration provider for reading the `appsettings.json` file is `JsonConfigurationProvider`,
    which is derived from the `FileConfigurationProvider` base class. There are some
    other implementations of the `FileConfigurationProvider` base class, such as `IniConfigurationProvider`,
    `XmlConfigurationProvider`, and so on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到 ASP.NET Core 支持多个配置提供者。用于读取 `appsettings.json` 文件的配置提供者是 `JsonConfigurationProvider`，它继承自
    `FileConfigurationProvider` 基类。还有一些其他 `FileConfigurationProvider` 基类的实现，例如 `IniConfigurationProvider`、`XmlConfigurationProvider`
    等。
- en: 'Besides `JsonConfigurationProvider`, the ASP.NET Core framework automatically
    registers the following configuration providers:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `JsonConfigurationProvider`，ASP.NET Core 框架还会自动注册以下配置提供者：
- en: A `Development` environment
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Development` 环境
- en: A **non-prefixed environment variables configuration provider** is used to read
    environment variables that do not have a prefix
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非前缀环境变量配置提供者**用于读取没有前缀的环境变量'
- en: A **command-line configuration provider** is used to read command-line arguments
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行配置提供者**用于读取命令行参数'
- en: Let us see more details about these configuration providers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这些配置提供者。
- en: User secrets configuration provider
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户密钥配置提供者
- en: It is not a good practice to store sensitive information in the `appsettings.json`
    file. For example, if the database connection string is stored in the `appsettings.json`
    file, developers may accidentally commit the database connection string (or other
    sensitive information, secrets, and so on) to the source control system, which
    will cause security issues.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将敏感信息存储在 `appsettings.json` 文件中不是一种好的做法。例如，如果数据库连接字符串存储在 `appsettings.json`
    文件中，开发者可能会意外地将数据库连接字符串（或其他敏感信息、密钥等）提交到源代码控制系统，这将会引起安全问题。
- en: Instead, we can use the user secrets feature to store sensitive information
    in the local secrets file. The user secrets feature is only available in the `Development`
    environment. By default, the ASP.NET Core framework registers the user secrets
    configuration provider after the JSON configuration provider. Therefore, the user
    secrets configuration provider has higher priority than the JSON configuration
    provider, so it will override the JSON configuration provider if the same configuration
    key exists in both providers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用用户密钥功能将敏感信息存储在本地密钥文件中。用户密钥功能仅在 `Development` 环境中可用。默认情况下，ASP.NET Core
    框架在 JSON 配置提供者之后注册用户密钥配置提供者。因此，用户密钥配置提供者的优先级高于 JSON 配置提供者，如果两个提供者中存在相同的配置键，它将覆盖
    JSON 配置提供者。
- en: 'To use user secrets, we need to use the Secret Manager tool to store the secrets
    in a local secrets file. Run the following command in the project folder to initialize
    a local secrets file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用用户密钥，我们需要使用 Secret Manager 工具将密钥存储在本地密钥文件中。在项目文件夹中运行以下命令以初始化本地密钥文件：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding command creates a `UserSecretsId` property in the `.csproj` file.
    By default, the value of the `UserSecretsId` property is a GUID, such as the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在 `.csproj` 文件中创建了一个 `UserSecretsId` 属性。默认情况下，`UserSecretsId` 属性的值是一个GUID，例如以下内容：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we can use the Secret Manager tool to store secrets in the local secrets
    file. Run the following command from the project folder to store secrets:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 Secret Manager 工具将密钥存储在本地密钥文件中。从项目文件夹中运行以下命令以存储密钥：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After running the preceding commands, a `secrets.json` file is created in the
    `%APPDATA%\Microsoft\UserSecrets\<UserSecretsId>` folder. The `secrets.json` file
    contains the following content:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，在 `%APPDATA%\Microsoft\UserSecrets\<UserSecretsId>` 文件夹中创建了一个 `secrets.json`
    文件。该 `secrets.json` 文件包含以下内容：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that the JSON structure is flattened.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 JSON 结构已被扁平化。
- en: Location of the secrets.json file
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`secrets.json` 文件的位置'
- en: If you use Linux or macOS, the `secrets.json` file is created in the `~/.``microsoft/usersecrets/<UserSecretsId>`
    folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Linux 或 macOS，`secrets.json` 文件将创建在 `~/.microsoft/usersecrets/<UserSecretsId>`
    文件夹中。
- en: Run `dotnet run` to run the application and send a request to the `/Configuration/database-configuration`
    endpoint. You will find the response contains the database options from the user
    secrets, which overrides the database options from the `appsettings.json` file
    and contains a PostgreSQL database type.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `dotnet run` 来运行应用程序并向 `/Configuration/database-configuration` 端点发送请求。你会发现响应包含来自用户密钥的数据库选项，它覆盖了
    `appsettings.json` 文件中的数据库选项，并包含 PostgreSQL 数据库类型。
- en: The local secrets file is out of the project folder and not committed to the
    source control system. Keep in mind that the Secret Manager tool is only for development
    purposes. Developers should have the responsibility to protect the local secrets
    file.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本地密钥文件位于项目文件夹之外，并且未提交到源代码控制系统。请记住，Secret Manager 工具仅用于开发目的。开发者应负责保护本地密钥文件。
- en: 'There are some commands to operate the local secrets file. You need to run
    the following commands from the project folder:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些命令用于操作本地密钥文件。你需要从项目文件夹中运行以下命令：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Important note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you download the code example for this section, the secrets file is not included
    in the repository. You need to run the `dotnet user-secrets init` command to initialize
    the secrets file on your local machine.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你下载本节的代码示例，密钥文件不会包含在存储库中。你需要运行 `dotnet user-secrets init` 命令来在你的本地机器上初始化密钥文件。
- en: Environment variables configuration provider
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量配置提供程序
- en: .NET and ASP.NET Core define some environment variables that can be used to
    configure the application. These specific variables have a prefix of `DOTNET_`,
    `DOTNETCORE_`, or `ASPNETCORE_`. Variables that have the `DOTNET_` or `DOTNETCORE_`
    prefix are used to configure the .NET runtime. Variables that have the `ASPNETCORE_`
    prefix are used to configure ASP.NET Core. For example, the `ASPNETCORE_ENVIRONMENT`
    variable is used to set the environment name. We will discuss the environment
    in the *Environments* section.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 和 ASP.NET Core 定义了一些可以用于配置应用程序的环境变量。这些特定的变量具有 `DOTNET_`、`DOTNETCORE_` 或
    `ASPNETCORE_` 前缀。具有 `DOTNET_` 或 `DOTNETCORE_` 前缀的变量用于配置 .NET 运行时。具有 `ASPNETCORE_`
    前缀的变量用于配置 ASP.NET Core。例如，`ASPNETCORE_ENVIRONMENT` 环境变量用于设置环境名称。我们将在 *环境* 部分讨论环境。
- en: 'For those environment variables that do not have the `ASPNETCORE_` prefix,
    ASP.NET Core can also use the environment variables configuration provider to
    read them. Environment variables have a higher priority than the `appsettings.json`
    file. For example, we have the following configuration in the `appsettings.json`
    file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有 `ASPNETCORE_` 前缀的环境变量，ASP.NET Core 也可以使用环境变量配置提供程序来读取它们。环境变量的优先级高于 `appsettings.json`
    文件。例如，我们在 `appsettings.json` 文件中有以下配置：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we set the `Database__Type` environment variable to `MySQL`, the `Database__Type`
    value in the `appsettings.json` file will be overridden by the environment variable
    value. The following code shows how to access an environment variable in PowerShell:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `Database__Type` 环境变量设置为 `MySQL`，`appsettings.json` 文件中的 `Database__Type`
    值将被环境变量值覆盖。以下代码展示了如何在 PowerShell 中访问环境变量：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To represent the hierarchical keys of environment variables, it is recommended
    to use `__` (double underscore) as a separator because it is supported by all
    platforms. Please do not use `:` because it is not supported by Bash.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示环境变量的分层键，建议使用 `__`（双下划线）作为分隔符，因为它被所有平台支持。请勿使用 `:`，因为它不被 Bash 支持。
- en: 'You can use the following command to set an environment variable in PowerShell:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在 PowerShell 中设置环境变量：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To check if the environment variable is set correctly, run the following command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查环境变量是否设置正确，请运行以下命令：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Important note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you use Bash, you need to use the following command to set the environment
    variable:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Bash，你需要使用以下命令来设置环境变量：
- en: '`export Database__Type="SQLite"`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`export Database__Type="SQLite"`'
- en: For more information, please refer to [https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/](https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 [https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/](https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/)。
- en: Also, please note that, unlike in Windows, environment variable names are case-sensitive
    on macOS and Linux.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，与 Windows 不同，在 macOS 和 Linux 上环境变量名称是区分大小写的。
- en: You will see the output is `SQLite`. Now, in the same PowerShell session, you
    can use `dotnet run` to run the application and send a request to the `/Configuration/database-configuration`
    endpoint. You will find the response contains the `SQLite` value, even though
    the `appsettings.json` file contains the `SQL Server` value. That means the environment
    variable value overrides the `appsettings.json` file value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到输出是 `SQLite`。现在，在同一个 PowerShell 会话中，您可以使用 `dotnet run` 来运行应用程序并向 `/Configuration/database-configuration`
    端点发送请求。您会发现响应包含 `SQLite` 值，即使 `appsettings.json` 文件包含 `SQL Server` 值。这意味着环境变量值覆盖了
    `appsettings.json` 文件值。
- en: Command-line configuration provider
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行配置提供程序
- en: Command-line arguments have a higher priority than environment variables. By
    default, the configuration settings set on the command line override values set
    with other configuration providers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数的优先级高于环境变量。默认情况下，命令行上设置的配置设置会覆盖其他配置提供程序设置的值。
- en: 'Following the example in the previous section, the `Database__Type` value is
    set to `SQL Server` in the `appsettings.json` file. We also set the `Database__Type`
    environment variable to `SQLite`. Now, let us change the value to `MySQL` in the
    command-line argument using the following command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一节的示例，`Database__Type` 值在 `appsettings.json` 文件中设置为 `SQL Server`。我们还设置了 `Database__Type`
    环境变量为 `SQLite`。现在，让我们使用以下命令将命令行参数中的值更改为 `MySQL`：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Send a request to the `/Configuration/database-configuration` endpoint. You
    will find the response contains the `MySQL` value, which means the command-line
    argument value overrides the environment variable value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `/Configuration/database-configuration` 端点发送请求。您会发现响应包含 `MySQL` 值，这意味着命令行参数值覆盖了环境变量值。
- en: 'Command-line arguments can also be set in the following ways:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数还可以按以下方式设置：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If `--` or `/` is used for the key, the value can follow a space. Otherwise,
    the value must follow the `=` sign. Please do not mix the two ways in the same
    command.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `--` 或 `/` 作为键，则值可以跟在空格后面。否则，值必须跟在 `=` 符号后面。请勿在同一个命令中混合两种方式。
- en: Azure Key Vault configuration provider
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Key Vault 配置提供程序
- en: Azure Key Vault is a cloud-based service that provides secure storage for secrets,
    such as passwords, certificates, and keys. The Azure Key Vault configuration provider
    is used to read the secrets from an Azure Key Vault. It is a good choice for running
    the application in production.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Key Vault 是一种基于云的服务，它为密码、证书和密钥等机密提供安全存储。Azure Key Vault 配置提供程序用于从 Azure
    Key Vault 读取机密。它是运行生产应用程序的好选择。
- en: 'To use it, you need to install the following NuGet packages:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，您需要安装以下 NuGet 包：
- en: '`Azure.Extensions.AspNetCore.Configuration.Secrets`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Azure.Extensions.AspNetCore.Configuration.Secrets`'
- en: '`Azure.Identity`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Azure.Identity`'
- en: 'Azure App Configuration is a cloud-based service that provides a centralized
    configuration store for managing application settings and feature flags. App Configuration
    complements Azure Key Vault. It aims to simplify tasks of working with complex
    application settings. You need to install the following NuGet packages to use
    the Azure App Configuration provider:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Azure App Configuration 是一种基于云的服务，它为管理应用程序设置和功能标志提供了一个集中的配置存储库。App Configuration
    补充了 Azure Key Vault。它的目标是简化处理复杂应用程序设置的任务。您需要安装以下 NuGet 包来使用 Azure App Configuration
    提供程序：
- en: '`Microsoft.Azure.AppConfiguration.AspNetCore`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Azure.AppConfiguration.AspNetCore`'
- en: 'We will not cover details of the Azure Key Vault and Azure App Configuration
    providers in this book. For more information, please refer to the following links:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中涵盖 Azure Key Vault 和 Azure App Configuration 提供程序的详细信息。有关更多信息，请参阅以下链接：
- en: '[https://learn.microsoft.com/en-us/azure/key-vault/general/](https://learn.microsoft.com/en-us/azure/key-vault/general/)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/azure/key-vault/general/](https://learn.microsoft.com/en-us/azure/key-vault/general/)'
- en: '[https://docs.microsoft.com/en-us/azure/azure-app-configuration/](https://docs.microsoft.com/en-us/azure/azure-app-configuration/)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/azure-app-configuration/](https://docs.microsoft.com/en-us/azure/azure-app-configuration/)'
- en: Environments
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: In the previous section, we introduced how to read the configuration settings
    from various resources, including the `appsettings.json` file, user secrets, environment
    variables, and command-line arguments. In this section, we will discuss environments
    in more detail.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了如何从各种资源中读取配置设置，包括 `appsettings.json` 文件、用户机密、环境变量和命令行参数。在本节中，我们将更详细地讨论环境变量。
- en: 'Run the following command to create a new ASP.NET Core web API project:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的ASP.NET Core Web API项目：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can download the example project named `EnvironmentDemo` from the `/samples/chapter3/EnvironmentsDemo`
    folder in the chapter's GitHub repository.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从章节的GitHub仓库中`/samples/chapter3/EnvironmentsDemo`文件夹下载名为`EnvironmentDemo`的示例项目。
- en: We have mentioned the default ASP.NET Core web API template contains an `appsettings.json`
    file and an `appsettings.Development.json` file. When we run the application using
    `dotnet run`, the application runs in the `Development` environment. So the configuration
    settings in the `appsettings.Development.json` file override the configuration
    settings in the `appsettings.json` file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，默认的ASP.NET Core Web API模板包含一个`appsettings.json`文件和一个`appsettings.Development.json`文件。当我们使用`dotnet
    run`运行应用程序时，应用程序在`Development`环境中运行。因此，`appsettings.Development.json`文件中的配置设置会覆盖`appsettings.json`文件中的配置设置。
- en: 'Add the following section to the `appsettings.Development.json` file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下部分添加到`appsettings.Development.json`文件中：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, add the following section to the `appsettings.Development.json` file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下部分添加到`appsettings.Development.json`文件中：
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Important note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that user secrets have higher priority than the `appsettings.Development.json`
    file. So, if you configured the local user secrets in the previous section, please
    clear the secrets.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用户密钥高于`appsettings.Development.json`文件。因此，如果你在上一节中配置了本地用户密钥，请清除密钥。
- en: 'Create a new controller named `ConfigurationController.cs` and add the following
    code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ConfigurationController.cs`的新控制器，并添加以下代码：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Run the application using `dotnet run`. Send the request to the `/Configuration/database-configuration`
    endpoint. You will find the response contains a `LocalDB` value, which means the
    `appsettings.Development.json` file overrides the `appsettings.json` file.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dotnet run`运行应用程序。向`/Configuration/database-configuration`端点发送请求。你会发现响应包含一个`LocalDB`值，这意味着`appsettings.Development.json`文件覆盖了`appsettings.json`文件。
- en: So, where is the environment name `Development` set?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，环境名称`Development`在哪里设置？
- en: Understanding the launchSettings.json file
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`launchSettings.json`文件
- en: 'Open the `launchSettings.json` file in the `Properties` folder. You will find
    the `ASPNETCORE_ENVIRONMENT` environment variable is set to `Development`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Properties`文件夹中打开`launchSettings.json`文件。你会找到`ASPNETCORE_ENVIRONMENT`环境变量设置为`Development`：
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `launchSettings.json` file is used to configure the local development environment.
    It is not deployable. The default `launchSettings.json` file contains three profiles:
    `http`, `https`, and `IIS Express`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`launchSettings.json`文件用于配置本地开发环境。它不可部署。默认的`launchSettings.json`文件包含三个配置文件：`http`、`https`和`IIS
    Express`：'
- en: The `http` profile is used to run the application with the HTTP protocol
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`配置文件用于使用HTTP协议运行应用程序'
- en: The `https` profile is used to run the application with the HTTPS protocol
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https`配置文件用于使用HTTPS协议运行应用程序'
- en: The `IIS Express` profile is used to run the application in IIS Express
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIS Express`配置文件用于在IIS Express中运行应用程序'
- en: The `commandName` field in the `http` and `https` profiles is `Project`, which
    means the Kestrel server is launched to run the application. Similarly, the `IISExpress`
    value in the `IIS Express` profile means the application expects IIS Express to
    be the web server.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`http`和`https`配置文件中的`commandName`字段是`Project`，这意味着Kestrel服务器被启动以运行应用程序。同样，`IISExpress`在`IIS
    Express`配置文件中的值意味着应用程序期望IIS Express作为Web服务器。'
- en: What is the Kestrel server?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Kestrel服务器？
- en: Kestrel is a cross-platform web server for ASP.NET Core. Kestrel is included
    and enabled by default in ASP.NET Core project templates. ASP.NET Core can also
    be hosted in IIS (or IIS Express), but IIS is not cross-platform. So, Kestrel
    is the preferred web server for ASP.NET Core applications.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Kestrel是一个跨平台的ASP.NET Core Web服务器。Kestrel默认包含并启用在ASP.NET Core项目模板中。ASP.NET Core也可以在IIS（或IIS
    Express）中托管，但IIS不是跨平台的。因此，Kestrel是ASP.NET Core应用程序的首选Web服务器。
- en: 'When running `dotnet run`, the first profile with the `commandName` value,
    `Project`, is used. For the demo project, the `http` profile is used. The `ASPNETCORE_ENVIRONMENT`
    environment variable is set to `Development` in the `http` profile. So, the application
    runs in the `Development` environment. You can see the output in the console:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`dotnet run`时，使用具有`commandName`值`Project`的第一个配置文件。对于演示项目，使用`http`配置文件。在`http`配置文件中，将`ASPNETCORE_ENVIRONMENT`环境变量设置为`Development`。因此，应用程序在`Development`环境中运行。你可以在控制台中看到输出：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can specify the profile to use when running the application using the `--``launch-profile`
    argument:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `--launch-profile` 参数指定运行应用程序时要使用的配置文件：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that this approach is only available for Kestrel profiles. You cannot use
    this argument to run the application in IIS Express.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法仅适用于 Kestrel 配置文件。你不能使用此参数在 IIS Express 中运行应用程序。
- en: 'If you use VS 2022 to open the project, you can choose which profile to use,
    like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 VS 2022 打开项目，你可以选择要使用的配置文件，如下所示：
- en: "![Figure 3.1 – Choosing a profile to \uFEFFuse in Visual Studio 2022](img/Figure_3.1_B18971.jpg)"
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 在 Visual Studio 2022 中选择要使用的配置文件](img/Figure_3.1_B18971.jpg)'
- en: Figure 3.1 – Choosing a profile to use in Visual Studio 2022
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 在 Visual Studio 2022 中选择要使用的配置文件
- en: Next, let's explore how to configure the application to run in the `Production`
    environment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索如何配置应用程序以在 `Production` 环境中运行。
- en: Setting the environment
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'There are several ways to change the environment. Let''s create a new file
    named `appsettings.Production.json`. This configuration file will be used for
    the `Production` environment. Add the following section to the file:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以更改环境。让我们创建一个名为 `appsettings.Production.json` 的新文件。此配置文件将用于 `Production`
    环境。将以下部分添加到文件中：
- en: '[PRE60]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Next, we will specify the environment as `Production` to apply this configuration.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将指定环境为 `Production` 以应用此配置。
- en: Using the launchSettings.json file
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `launchSettings.json` 文件
- en: 'For development purposes, we can create a new profile in the `launchSettings.json`
    file, which specifies the `ASPNETCORE_ENVIRONMENT` variable as `Production`. Add
    the following section to the `launchSettings.json` file:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发目的，我们可以在 `launchSettings.json` 文件中创建一个新的配置文件，该文件指定 `ASPNETCORE_ENVIRONMENT`
    变量为 `Production`。将以下部分添加到 `launchSettings.json` 文件中：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use the following command to run the application in the `Production` environment:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在 `Production` 环境中运行应用程序：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You will see in the console that the application runs in the `Production` environment:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在控制台中看到应用程序在 `Production` 环境中运行：
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It looks good. Let's try to access the `/Configuration/database-configuration`
    endpoint. You will see the response is from the `appsettings.Production.json`
    file.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。让我们尝试访问 `/Configuration/database-configuration` 端点。你会看到响应来自 `appsettings.Production.json`
    文件。
- en: Using the ASPNETCORE_ENVIRONMENT environment variable
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ASPNETCORE_ENVIRONMENT 环境变量
- en: 'You can also set the `ASPNETCORE_ENVIRONMENT` environment variable to `Production`
    in the current session, as shown next:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在当前会话中将 `ASPNETCORE_ENVIRONMENT` 环境变量设置为 `Production`，如下所示：
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Furthermore, you can set the environment variable globally in your system.
    Use the following command to set the environment variable globally:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在系统中全局设置环境变量。使用以下命令全局设置环境变量：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `Machine` argument sets the environment variable globally. You can also
    set the environment variable for the current user by using the `User` argument.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine` 参数设置全局环境变量。你也可以使用 `User` 参数为当前用户设置环境变量。'
- en: Using the --environment argument
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 --environment 参数
- en: 'Another way is to set the environment with the `--``environment` argument:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `--environment` 参数设置环境：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Using the launch.json file in VS Code
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 VS Code 中的 `launch.json` 文件
- en: 'If you use VS Code to open the project, you can set the environment in the
    `launch.json` file in the `.vscode` folder. When you open an ASP.NET Core project,
    VS Code will prompt you to add required assets to debug the project. A `launch.json`
    file and a `tasks.json` file will be added to the `.vscode` folder. If you do
    not see the prompt, you can open the Command Palette and run the **.NET: Generate
    Assets for Build and** **Debug** command.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你使用 VS Code 打开项目，你可以在 `.vscode` 文件夹中的 `launch.json` 文件中设置环境。当你打开一个 ASP.NET
    Core 项目时，VS Code 将提示你添加调试项目所需资源。将在 `.vscode` 文件夹中添加一个 `launch.json` 文件和一个 `tasks.json`
    文件。如果你没有看到提示，你可以打开命令面板并运行 **.NET: Generate Assets for Build and Debug** 命令。'
- en: 'Open the `launch.json` file and you will find the following content:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `launch.json` 文件，你将看到以下内容：
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can add a new configuration following the existing one. Change the `ASPNETCORE_ENVIRONMENT`
    field to `Production` and use `.NET Core Launch (Production)` as the name. Save
    the file. You can now run the application in the `Production` environment by clicking
    the green arrow in the debug panel:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照现有配置添加一个新的配置。将 `ASPNETCORE_ENVIRONMENT` 字段更改为 `Production` 并使用 `.NET Core
    Launch (Production)` 作为名称。保存文件。你现在可以通过在调试面板中点击绿色箭头来在 `Production` 环境中运行应用程序：
- en: '![Figure 3.2 – Running the application in a specific environment in VS Code](img/Figure_3.2_B18971.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 在VS Code中运行特定环境中的应用程序](img/Figure_3.2_B18971.jpg)'
- en: Figure 3.2 – Running the application in a specific environment in VS Code
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 在VS Code中运行特定环境中的应用程序
- en: Important note
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `launch.json` file is only used in VS Code `dotnet` `run` command.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch.json`文件仅在VS Code `dotnet` `run`命令中使用。'
- en: Using the launchSettings.json file in Visual Studio 2022
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中使用launchSettings.json文件
- en: 'Visual Studio 2022 provides a **Launch Profiles** dialog to set up the environment
    variables. You have multiple ways to open the **Launch** **Profiles** dialog:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022提供了一个**启动配置文件**对话框来设置环境变量。你有多种方式打开**启动配置文件**对话框：
- en: Open the **Debug** menu | *<Your project name>* **Debug Properties**.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开**调试**菜单 | *<您的项目名称>* **调试属性**。
- en: Click the arrow next to the green arrow in the debug panel and select *<Your
    project name>* **Debug Properties**.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击调试面板中绿色箭头旁边的箭头，并选择 *<您的项目名称>* **调试属性**。
- en: Right-click the project in the **Solution Explorer** window and select **Properties**.
    In the **Debug / General** tab, click the **Open debug launch profiles** **UI**
    link.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击**解决方案资源管理器**窗口中的项目，并选择**属性**。在**调试/常规**选项卡中，单击**打开调试启动配置文件** **UI**链接。
- en: 'Then, you can see the **Launch** **Profiles** dialog:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以看到**启动配置文件**对话框：
- en: '![Figure 3.3 – The Launch Profiles dialog in Visual Studio 2022](img/Figure_3.3_B18971.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – Visual Studio 2022中的启动配置文件对话框](img/Figure_3.3_B18971.jpg)'
- en: Figure 3.3 – The Launch Profiles dialog in Visual Studio 2022
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – Visual Studio 2022中的启动配置文件对话框
- en: If you make changes here, you need to restart the application to apply the changes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此处进行更改，则需要重新启动应用程序以应用更改。
- en: We have learned how to set the environment. With the environment set, we can
    use different configurations for different environments.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何设置环境。设置环境后，我们可以为不同的环境使用不同的配置。
- en: Understanding the priorities of configuration and environment variables
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解配置和环境变量的优先级
- en: We introduced quite a few different ways to read configuration values and environment
    variables. Let us see how configuration and environment variables are prioritized.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了多种读取配置值和环境变量的不同方法。让我们看看配置和环境变量的优先级是如何确定的。
- en: 'The following table shows the priorities of the configuration sources (the
    lowest number has the highest priority):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了配置来源的优先级（数字越小，优先级越高）：
- en: '| **Source** | **Priority** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **来源** | **优先级** |'
- en: '| --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Command-line arguments | 1 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 命令行参数 | 1 |'
- en: '| Non-prefixed environment variables | 2 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 无前缀的环境变量 | 2 |'
- en: '| User secrets (`Development` environment only) | 3 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 用户密钥（仅限`Development`环境） | 3 |'
- en: '| `appsettings.{Environment}.json` | 4 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `appsettings.{Environment}.json` | 4 |'
- en: '| `appsettings.json` | 5 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `appsettings.json` | 5 |'
- en: Table 3.2 – Priorities of configuration sources
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 – 配置来源的优先级
- en: If other configuration providers are registered in the `Program.cs` file, the
    later registered providers have higher priority than the earlier registered providers.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`Program.cs`文件中注册了其他配置提供程序，则较晚注册的提供程序比较早注册的提供程序具有更高的优先级。
- en: 'In terms of environment variables such as `ASPNETCORE_ENVIRONMENT`, the following
    table shows the priorities:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ASPNETCORE_ENVIRONMENT`等环境变量方面，以下表格显示了优先级：
- en: '| **Source** | **Priority** |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| **来源** | **优先级** |'
- en: '| Command-line arguments | 1 |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 命令行参数 | 1 |'
- en: '| `launchSettings.json` (development purposes only) | 2 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `launchSettings.json`（仅限开发目的） | 2 |'
- en: '| Environment variable in the current process | 3 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 当前进程中的环境变量 | 3 |'
- en: '| System environment variable | 4 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 系统环境变量 | 4 |'
- en: Table 3.3 – Priorities of environment variables
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3 – 环境变量的优先级
- en: Note that there are some other ways to configure the environment that are not
    listed in the preceding table. For example, if you deploy the ASP.NET Core application
    to Azure App Service, you can set the `ASPNETCORE_ENVIRONMENT` environment variable
    in the App Service configuration. For Linux apps and container apps, Azure App
    Service passes these settings to the container using the `--env` flag to set the
    environment variable in the container.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一些其他配置环境的方法没有在前面的表中列出。例如，如果您将ASP.NET Core应用程序部署到Azure App Service，您可以在App
    Service配置中设置`ASPNETCORE_ENVIRONMENT`环境变量。对于Linux应用程序和容器应用程序，Azure App Service使用`--env`标志将这些设置传递到容器中，以在容器中设置环境变量。
- en: Checking the environment in the code
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码中的环境
- en: 'Keep running the application in the `Production` environment. Let''s try to
    access the Swagger UI page: `http://localhost:5161/swagger`. You will find it
    shows a `404 Not Found` error. Why?'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `生产` 环境中继续运行应用程序。让我们尝试访问 Swagger UI 页面：`http://localhost:5161/swagger`。您会发现它显示了一个
    `404 Not Found` 错误。为什么？
- en: 'This is because the Swagger UI page is only enabled in the `Development` environment.
    You can see the code in the `Program.cs` file:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Swagger UI 页面仅在 `开发` 环境中启用。您可以在 `Program.cs` 文件中查看代码：
- en: '[PRE68]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding code means that the Swagger UI page is enabled for the development
    environment only.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表示 Swagger UI 页面仅对开发环境启用。
- en: 'The three environment names, `Development`, `Staging`, and `Production`, are
    predefined in the ASP.NET Core framework, as shown next:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 框架中预定义了三个环境名称，`开发`、`预发布`和`生产`，如下所示：
- en: '[PRE69]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `app.Environment.IsDevelopment()` method checks the current environment.
    If the current environment is `Development`, the Swagger UI page is enabled. Otherwise,
    it is disabled.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.Environment.IsDevelopment()` 方法检查当前环境。如果当前环境是 `开发`，则 Swagger UI 页面被启用。否则，它被禁用。'
- en: 'To set the environment in code, use the following code when creating `WebApplicationBuilder`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中设置环境，在创建 `WebApplicationBuilder` 时使用以下代码：
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The environment name is stored in the `IHostEnvironment.EnvironmentName` property.
    You can define your own environment names. For example, you can define an environment
    name such as `Test`. But the framework provides built-in methods, such as `IsDevelopment()`,
    `IsStaging()`, and `IsProduction()`, to check the environment. If you define your
    own environment names, you can use the `IHostEnvironment.IsEnvironment(string
    environmentName)` method to check the environment.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 环境名称存储在 `IHostEnvironment.EnvironmentName` 属性中。您可以定义自己的环境名称。例如，您可以定义一个名为 `测试`
    的环境名称。但是，框架提供了内置方法，例如 `IsDevelopment()`、`IsStaging()` 和 `IsProduction()`，来检查环境。如果您定义了自己的环境名称，您可以使用
    `IHostEnvironment.IsEnvironment(string environmentName)` 方法来检查环境。
- en: 'We can use the `System.Environment` class to get the environment variable in
    the code, such as `ASPNETCORE_ENVIRONMENT`. Add the following code to the `Program.cs`
    file:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `System.Environment` 类在代码中获取环境变量，例如 `ASPNETCORE_ENVIRONMENT`。将以下代码添加到
    `Program.cs` 文件中：
- en: '[PRE71]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the application, and you can see the `ASPNETCORE_ENVIRONMENT` environment
    variable in the console:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您可以在控制台看到 `ASPNETCORE_ENVIRONMENT` 环境变量：
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: What should we do for different environments?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的环境，我们应该做什么？
- en: 'For the development environment, we can enable the Swagger UI page, show detailed
    error messages, output debugging information, and so on. For the production environment,
    we should configure the application for best performance and maximum security.
    Consider the following points for the production environment:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发环境，我们可以启用 Swagger UI 页面，显示详细错误信息，输出调试信息等。对于生产环境，我们应该配置应用程序以获得最佳性能和最高安全性。以下是为生产环境考虑的要点：
- en: Disable the Swagger UI page.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用 Swagger UI 页面。
- en: Disable detailed error messages.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用详细错误信息。
- en: Show a friendly error message.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示友好的错误信息。
- en: Do not output debugging information.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要输出调试信息。
- en: Enable cache.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用缓存。
- en: Enable HTTPS.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 HTTPS。
- en: Enable the response compression.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用响应压缩。
- en: Enable monitoring and logging.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用监控和日志记录。
- en: Summary
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored three important components of ASP.NET Core: routing,
    configuration, and environments. We discussed how to configure routing for an
    ASP.NET Core web API application and how to read parameters from the request.
    Additionally, we learned how to read configuration values from various sources,
    such as `appsettings.json`, environment variables, and command-line arguments.
    We also explored how to read configurations based on the environment, allowing
    us to enable different features for different environments.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 ASP.NET Core 的三个重要组件：路由、配置和环境。我们讨论了如何为 ASP.NET Core Web API 应用程序配置路由以及如何从请求中读取参数。此外，我们还学习了如何从各种来源读取配置值，例如
    `appsettings.json`、环境变量和命令行参数。我们还探讨了如何根据环境读取配置，使我们能够为不同的环境启用不同的功能。
- en: 'In the next chapter, we will learn about two more essential components of ASP.NET
    Core: logging and middleware.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 ASP.NET Core 的两个更多重要组件：日志记录和中间件。
