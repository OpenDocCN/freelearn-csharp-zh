- en: Introducing Dependency Injection in .NET Core 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a first approach in the implementation of .NET Core Dependency
    Injection technologies in the most recent version of .NET Core (2.0). Its main
    features, functionalities, and the namespaces holding the set of classes support
    these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk about the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: In all, we'll talk about how .NET Core includes support for several of the SOLID
    principles in general and those related to Dependency Injection in particular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start with the main characteristics of .NET Core and its installation
    and usage from Visual Studio, especially focusing on the latest version, Visual
    Studio 2017, together with the distinct types of deployment that this version
    allows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we'll get into the Dependency Injection in .NET Core, the `ActivatorUtilities`
    class, and the `Microsoft.Extensions.DependencyInjection` container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later on, we'll see some demos related to the implementation of an object's
    lifetime and how to map interfaces to instance classes, as well as a brief reminder
    of some more aspects of the Scope when applied to services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll see how this DI functionality is also implemented inside some
    .NET Core services, especially those related to logging with plenty of demos showing
    how to use it in pure .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main characteristics of .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've explained the basics of the architecture proposal of .NET Core in [Chapter
    1](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml), *The SOLID Principles of Software
    Design* and how it pretends to be a game-changer, since it offers the possibility
    of creating code in the same language (C# or VB.NET), capable of executing on
    any device or platform.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that VB.NET support of new features always goes behind the advances
    you'll see in the C# language, so, in case you try some new feature using this
    language, you should make sure that it has been implemented for the version we're
    using in this book.
  prefs: []
  type: TYPE_NORMAL
- en: This capability also extends to mobile applications, thanks to the incorporation
    of the Xamarin environment (and IDE) to the set of tools related to .NET Core
    development.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantages of .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look at this framework from a more developer-like point of view, we could
    say that what makes .NET Core different from other choices can be summarized in
    the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-platform:** This means execution on Windows, macOS and Linux, and also
    its portability to other operating systems. You can check the list of supported
    operating systems on various sites, such as [https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md),
    and you should bear in mind that CPUs and application scenarios will keep growing,
    whether they are provided by Microsoft or other companies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility:** .NET Core is not only compatible with the .NET Framework,
    but also with Xamarin and Mono, thanks to the .NET Standard Library. As the official
    documentation states, the .NET Standard Library is,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"a formal specification of .NET APIs that are intended to be available on all
    .NET runtimes. The motivation behind the Standard Library is establishing greater
    uniformity in the .NET ecosystem. ECMA 335 continues to establish uniformity for
    .NET runtime behavior, but there is no similar spec for the .NET Base Class Libraries
    (BCL) for .NET library implementations."'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment:** Perhaps the most interesting feature about runtime is that
    it can be deployed inside an application or installed in a side-by-side user-or
    machine-wide basis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distinct command-line options:** All distinct scenarios can be used at the
    command-line tools (and that''s extensible to the rest of the platforms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source:** The .NET Core platform is open source, since its inception.
    It uses MIT and Apache 2 licenses, and the documentation is licensed under Creative
    Commons 4.0 (CC-BY, see [https://creativecommons.org/licenses/by/4.0/](https://creativecommons.org/licenses/by/4.0/)).
    Besides that, .NET Core is a .NET Foundation ([http://www.dotnetfoundation.org/](http://www.dotnetfoundation.org/))
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft''s support:** .NET Core is completely supported by Microsoft, and
    you''ll find plenty of documentation, videos, forums, and so on in promotion sites
    that the company usually encourages as it is indicated in .NET Core Support ([https://www.microsoft.com/net/core/support/](https://www.microsoft.com/net/core/support/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of .NET Core in the IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml), *The SOLID Principles
    of Software Design*, we mentioned that you could use .NET Core (and ASP.NET Core)
    with any IDE of your choice. However, in this book, I'm using Visual Studio 2017
    due to its integration tools and facilities, and its degree of optimization for
    .NET Core projects.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, and due to its youth, there's no common installation path for
    all versions of Visual Studio and, depending on the one you use, you'll find two
    different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Installation path for .NET Core in Visual Studio 2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to use Visual Studio 2015, you should have Update 3.3 installed.
    It''s available from this link: [https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs](https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs).
    In this site, you''ll see how the update is related to NET Core 1.0.0 and .NET
    Core 1.0.0 SDK Preview 2.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're not sure about this version, just check the About Microsoft Visual
    Studio in the Help menu and make sure the version number is 14.0.25424.00 or higher,
    and includes Update 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also need:'
  prefs: []
  type: TYPE_NORMAL
- en: The **NuGet Manager** extension for Visual Studio (you know, NuGet is the official
    package manager for Microsoft development, and we can be sure that it includes
    .NET Core in all its versions). You need NuGet 3.5.0-beta or higher to build .NET
    Core apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .**NET Core Tooling Preview 2+**, which takes care of project templates and
    other tools for Visual Studio 2015, and you can find it at [https://go.microsoft.com/fwlink/?LinkID=827546](https://go.microsoft.com/fwlink/?LinkID=827546).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core in Visual Studio 2017
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The case for Visual Studio 2017 is quite different, since it takes care of the
    installation of prerequisites, as long as you have selected the .NET Core and
    Docker workload during the initial installation process (remember that, in V.
    Studio 2017, installation is made in a modular fashion, so, by default, it only
    installs a minimum set of features).
  prefs: []
  type: TYPE_NORMAL
- en: As it happens in the previous case, if you want to make sure about the installed
    version, just check in the Help/About Visual Studio menu, and see if you have
    version 15.0.26020.0 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Types of deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've mentioned how .NET Core allows using two distinct kinds of deployment
    for your apps--**Framework Dependent Deployment** (**FDD**), and **Self-Contained
    Deployment (SCD).** Which one to choose? That will depend on the target system
    and the amount of knowledge and management control that we might have about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly remind ourselves about the main differences between these two
    types of deployment and its implications facing the management and structure of
    the assemblies resulted from any .NET Core compilation process:'
  prefs: []
  type: TYPE_NORMAL
- en: Framework Dependent relies on a shared version of .NET Core that should be installed
    on the target system. If this is the case, the application is portable between
    installations of .NET Core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that, in this case, the app contains only its own code and any third-party
    dependencies that are outside of the .NET Core libraries. This is because FDDs
    contain `.dll` files that can be launched by means of the `dotnet` utility from
    the command line. Remember that if you launch, for example, the command `dotnet``application1.dll`,
    that's enough to run an application named `application1.dll`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other side, SCD apps don't rely on any external code installed on the
    destination system. That is, all components, (and that includes both .NET Core
    libraries and the .NET Core runtime), are included in the final, installable package,
    and are isolated from other .NET Core applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consequently, SCDs include an executable (something like `app1.exe` on Windows
    platforms for an app of that name). This is a renamed version of the platform-specific
    .NET Core host, and a DLL file (such as `app.dll`), which is the actual application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, you're deploying a concrete version of .NET Core as the executable together
    with your application, that will always adopt the form of a DLL, and it will run
    inside the context created by the executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, it is a very different approach, and perhaps, the first time
    that we can generate totally independent executable applications with .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Checking other dependencies in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we keep on walking through the .NET Core features, it is wise to keep
    in mind that dependency is not only a matter of classes' relations but also about
    the components used to build applications, and the IDE might help us when defining
    and visually analyzing those dependencies even when the application is already
    compiled.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially important in a framework where these components, are always
    downloaded from NuGet (or any other valid repository) and updated in our projects
    within Visual Studio 2017 in a dynamic manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not taking care of these aspects, might lead to several problems. Among them,
    I''d like to highlight the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License misuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwanted dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to help developers to prevent dependency's issues, from version 2010
    of Visual Studio, the IDE offers the ability to create layer diagrams, which have
    evolved continuously since that version.
  prefs: []
  type: TYPE_NORMAL
- en: With these diagrams, you can express dependencies between layers, and these
    dependencies are not just shown through the diagrams hints but, starting in the
    latest version (2017), in the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you design one of these diagrams, you can express dependencies using symbols
    provided by the designer that include single and bi-directional dependency, layers,
    and simple shapes, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a19ce2c-cefb-4ede-b3ed-6e210595a7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This diagram is created using the new menu option related to the Architecture
    menu in the IDE, which also presents some features related to code analysis, such
    as Code Map generation, the possibility to create graphs of those external files
    (graph of `Include Files`), and other features. In all, that option presents the
    following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/331d0368-7f23-41b6-918c-c77efcda6d18.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that this Architecture menu is only available in V.Studio 2017 Enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: One of this menu's options is the new Dependency Validation diagram, which launches
    a new editing window, where we can drag and drop elements from the solution, including
    folders, files (C# and VB.NET) and even assemblies. We could consider these features
    as other implementations that the IDE offers to study any applications' dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This technique, has been rebuilt from scratch using Roslyn (refer my book *Mastering
    C# and .NET Framework* also by Pack, for more details and demos about this feature),
    and it allows the coder to configure the editor's behavior in a totally customized
    manner, programming how the IDE should respond when encountering any of these
    features in code (or even in other assemblies, since the tool accepts drag and
    drop already-compiled pieces too).
  prefs: []
  type: TYPE_NORMAL
- en: Once you establish relations and dependencies in the diagram, this new Intellisense
    will be able to validate the existing code, advising the programmer about the
    conflicting areas inside different application domains.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, you can activate these features in the configuration in a such a way,
    that, as soon as a problem is detected, you will see a squiggle highlighting your
    offending code, together with an indication of the root of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can establish which classes are allowed to live in every application''s
    namespace. If a single class is moved to a namespace forbidden by the dependency
    diagram, a hint will be presented in the code editor itself and, also, in the
    Error List window (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84aa0679-a0fb-4a0d-8f76-410e81044608.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, this behavior is also configurable, and these features are independent
    from other options we find in the Analyze menu in relation with Code Metrics,
    Performance Profilers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with the proper features related to Dependency Injection in .NET
    Core, there are a bunch of previous approaches to consider. One of those is the
    mantra `new` is glue, which we often hear as an advice.
  prefs: []
  type: TYPE_NORMAL
- en: This means that whenever you create a new instance of a class (you use the `new`
    keyword), there's some code cohesion behind the scenes. You're establishing that
    the class that defines that instance is going to have a dependency on the instantiated
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to get rid of that problem via factories, or using third-party
    libraries focused on the DI problem and how they can be used, but, in this chapter,
    we're going to rely on those features provided by the framework itself to achieve
    the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, that's something that we could define and, once the definition is registered,
    every time we need an instance of any of the predefined classes, something else
    should take care of providing that instance.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the behavior we've seen related to other DI containers should
    (more or less) be present here as well, and cover the most important features
    that those veteran containers offer, including an object's lifetime, registration,
    and definition of generic classes and interfaces, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: DI Architecture and Object's Lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering the preceding points, and even knowing that we''re dealing with
    an initial version of the frameworks, the .NET Core team designed Dependency Injection
    features based on two ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: On one side, there was already existing functionality, that could be perfectly
    extended to work inside .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other side, they thought that it would be wise to include the most used
    features present in other initiatives, (either Microsoft's or external) like those
    present in Prism Patterns & Practices or third party DI Containers (remember the
    four containers we saw in previous chapters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consequently (following these ideas), when dealing with an object's lifetime,
    .NET Core presents three types, depending on the way instances will be configured
    and used--Singleton, Scoped, and Transient.
  prefs: []
  type: TYPE_NORMAL
- en: These options do not only have influence in the way we define them, but also
    in the way we can use them, and in some cases, thread safe precautions, and other
    aspects should be considered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Singleton option, a unique instance of the object is used (meaning that
    we only manage a reference to the object). Any further request uses the same instance,
    according to the singleton pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scoped version is local to the context in which it is used and doesn't extend
    beyond that context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the Transient option creates a new instance of the class every time
    is requested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although included in the ASP.NET Core documentation, Microsoft provides the
    following diagram in relation to these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f55299db-672f-4987-ac1d-d401ea3d01b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Since, in the real world, this functionality is mainly linked to ASP.NET Core
    apps, services and middleware show up with functionality that helps in the task
    (that's why those references are to the *request*). But it actually works equally
    well in pure .NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning, a big part of this functionality is related
    to the `Microsoft.Extensions.DependencyInjection` namespace, included in a DLL
    of the same name, which can work in conjunction with another helper DLLs such
    as `Microsoft.Extensions.DependencyInjection.Abstractions` and others.
  prefs: []
  type: TYPE_NORMAL
- en: Concretely, the `IServiceCollection` interface is the base of a set of classes
    that provide methods to instantiate objects (usually called services in this context)
    via DI using these three options. We'll see this in action in the next sections,
    but also in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency
    Injection in ASP.NET Core,* dedicated to ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: The class ActivatorUtilities and other helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the demos, keep in mind that the number of classes included
    in this namespace is pretty large, since it pretends to offer a wide coverage
    while still being multi-platform.
  prefs: []
  type: TYPE_NORMAL
- en: One of these cases is the class `ActivatorUtilities` class, also included in
    the `Microsoft.Extensions.DependencyInjection` library, which contains static
    methods to help in the configuration and implementation of services, instances,
    and factories that ease DI management and control.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in case you find yourself missing some feature or functionality, take
    a look at the documentation at [http://docs.microsoft.com](http://docs.microsoft.com),
    but, keep in mind that you'll find that it is related to ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: This means that most of the implementations that you will see (on the internet
    and other sources) are not going to be linked to .NET Core apps, but to ASP.NET
    Core apps, in which, much of this functionality is implemented by default for
    different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there's much more inside those classes that we cannot cover in a
    single chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea of the possibilities linked to this class, I''m including
    a summary of its functionality presented in the official documentation, reminding
    you of each method and its main purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods summary** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| [CreateFactory(Type, Type[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateFactory_System_Type_System_Type___)
    | Create a delegate that will instantiate a type with constructor arguments provided
    directly and/or from a `System.IServiceProvider`. |'
  prefs: []
  type: TYPE_TB
- en: '| [CreateInstance(IServiceProvider, Type, Object[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance_System_IServiceProvider_System_Type_System_Object___)
    | Instantiate a type with constructor arguments provided directly and/or from
    a `System.IServiceProvider`. |'
  prefs: []
  type: TYPE_TB
- en: '| <p>[CreateInstance<T>(IServiceProvider, Object[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance__1_System_IServiceProvider_System_Object___)
    | Instantiate a type with constructor arguments provided directly and/or from
    a `System.IServiceProvider`. |'
  prefs: []
  type: TYPE_TB
- en: '| [GetServiceOrCreateInstance(IServiceProvider, Type)](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance_System_IServiceProvider_System_Type_)
    | Retrieve an instance of the given type from the service provider. If one is
    not found, then instantiate it directly. |'
  prefs: []
  type: TYPE_TB
- en: '| [GetServiceOrCreateInstance<T>(IServiceProvider)](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance__1_System_IServiceProvider_)
    | Retrieve an instance of the given type from the service provider. If one is
    not found, then instantiate it directly. |'
  prefs: []
  type: TYPE_TB
- en: It's now time to start working with the main classes related to DI inside the
    `**Microsoft.Extensions.DependencyInjection**` and `**Microsoft.Extensions.DependencyInjection.Abstractions**`
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft.Extensions.DependencyInjection container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the samples that you'll see on the internet about Dependency Injection
    and .NET Core will reference to ASP.NET Core applications since it comes by default
    when you use the predefined template inside Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: However, the use of ASP.NET Core applications is not mandatory if you want to
    see how DI works from scratch. That being said, we will have to configure the
    registering of our services manually. This implies certain extra aspects such
    as severity levels, an object's lifetime, and disposable features if we want this
    architecture to work seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET Core offers its own container linked to the external library `Microsoft.Extensions.DependencyInjection`
    (now, in version 2.0), we'll have to reference it via NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a first demo, we can create a simple .NET Core Console application, reference
    the library using the NuGet package plug-in, and look for its name online. You''ll
    observe that when you filter for that name, the NuGet Package Manager, presents
    several versions of the library (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b65efcfb-babb-4daf-81f2-c70983dd38e3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see, other libraries are also declared as complementary (`Microsoft.Extensions.DependencyInjection.Abstractions`,
    and `Microsoft.Extensions.DependencyInjection.Specification.Tests`). The first
    one (the `Abstractions`) should also appear as referenced inside our project once
    the installation is completed. But for now, let's focus on the main library.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, don't be scared of the following dialog box. It will tell you
    that a whole bunch of libraries is going to be updated, and another set of libraries
    will be installed anew. The reason for this might be double--on one side, the
    use of the latest versions of this library implies updating other previously referenced
    libraries according to an internal library dependency manager that Visual Studio
    2017 uses.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, installation of some new libraries, like this one, might
    imply other dependencies, so we end up with two distinct areas of updates (go
    to the Dependencies section in the Solution Explorer after installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio 2017 will offer a list of every library being updated and if
    you scroll down a bit, also the list of all the dependent libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5e0f7ef-5266-4279-b903-81b9dde13c74.png)'
  prefs: []
  type: TYPE_IMG
- en: After this dialog box, you'll be presented another one with the License Acceptance
    of each one of the libraries. Once completed, another entry in your Dependencies
    section of the Solution Explorer will show up, pointing to NuGet. That's where
    you'll find all that new stuff.
  prefs: []
  type: TYPE_NORMAL
- en: A further look at those new entries will reveal all the main and dependent libraries
    linked to that DependencyInjection reference, which might be a few.
  prefs: []
  type: TYPE_NORMAL
- en: Since, initially, we just want to make a test of how this namespace works, we'll
    start testing it in a very simple manner (Legit is to say that I was inspired
    by Jurgen Gustch's blog's entry Using Dependency Injection in .NET Core Console
    Apps, because, for this initial approach, I found it especially suitable and explanatory).
  prefs: []
  type: TYPE_NORMAL
- en: So, I've modified those ideas to create a couple of classes, in which the first
    one happens to have dependencies on the other (that is, the first class references
    the second).
  prefs: []
  type: TYPE_NORMAL
- en: Just for the matter of completeness, I included an extra method to check the
    right moment in which it was invoked, and also implemented the `IDisposable` interface
    to be able to convey information about disposal by the Garbage Collector (more
    about that later).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I ended with this code (outside of the class `Program` class that the template
    creates by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice also that `DependencyClass1` takes care of disposing `DependencyClass2`,
    once it's done with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it comes when the `DependencyInjection` classes are needed. First, we make
    a reference to the corresponding namespace on top of our code (only two namespaces
    are required for this simple demo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, inside the `Program` class, we need to register and use these classes.
    The first step is performed using a new instance of the `ServiceCollection` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside that class, we find methods to register all required services in a way
    that at the same time, configures the object''s lifetime mentioned previously,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73ac9339-cc80-4532-b126-17912c57a125.png)'
  prefs: []
  type: TYPE_IMG
- en: As we will see further on, we're provided with two versions of every method--generic
    and a non-generic. This gives us more flexibility to integrate different classes
    and services into our DI architecture.
  prefs: []
  type: TYPE_NORMAL
- en: For this initial version, we're using the `AddTransient` generic version of
    the methods, which will return new instances of every class, every time we make
    a reference in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Once our classes are registered, a provider has to be built with that definition.
    That's something we perform with a call to `BuildServiceProvider()` on the `ServicesCollection`
    class just created (we'll go back to service providers later on). But, for now,
    suffice to say that an instance of the `IServiceProvider` interface will be created
    and configured to manage any request for one of the classes previously registered
    using the `Add*` method.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to point out is that the way objects are instantiated follows
    the lazy creation pattern that you, reader, which you might already know from
    other contexts, such as LINQ. That means until the first instance of a DI Object
    is requested, nothing gets created.
  prefs: []
  type: TYPE_NORMAL
- en: So, even if we don't do anything (useful) with these classes, once the `DependencyClass1`
    is requested, the entire dependency injection mechanism is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is modified in the class `Program` class to configure this
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following output, everything works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b31ea530-6e2e-4210-bb84-25a5dc0278c6.png)'
  prefs: []
  type: TYPE_IMG
- en: The code shows how whenever we need an instance of a class, we issue a call
    to the generic `GetService()` method and we can start using it in the next sentence.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to notice is that the reference to `DependencyClass2` goes first,
    and so it does its disposal. Remember that the constructor of `DependencyClass1`
    receives an instance of `DependencyClass2`, so, it doesn't finish until the latter
    is totally created.
  prefs: []
  type: TYPE_NORMAL
- en: Also, before disposing of the first class, we call on `Dispose` of the second,
    that's why the order is inverted.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the object's lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important aspect of this architecture that we should consider carefully,
    is the way our instances are obtained from the point of view of its lifetime.
    Let's see the differences in this very demo, adding references and changing the
    way they are registered into the `IServiceProvider` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we create another instance of the first class? As expected,
    when we change the `using` block of code to include another instance of `DependencyClass1`,
    such as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output changes noticeably since we''re forcing the engine to create a new
    instance, instead of reusing the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71199e7d-4332-42c9-8a8b-bdf7818bd845.png)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the preceding screenshot, we're making the DI engine call the constructor
    twice, because we're using the `AddTransient()` version of the `services` configuration
    object.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this scenario, if we change the registration method for `AddScoped`
    of `AddSingleton`, we would be reusing the same instance of the objects, and therefore,
    saving memory and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, by just changing those two lines of code in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the different creation behavior with a simple look at the corresponding
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/375fd621-ba77-41e2-93b5-ac9f6ca12f07.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `CurrentTime` function is still called twice, but the number
    of instances in use is only one.
  prefs: []
  type: TYPE_NORMAL
- en: And, in this case, we would get exactly the same output using the `AddSingleton<>()`
    methods, since, in this scenario, there is a coincidence and no more than one
    instance is going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting aspect of the functionality provided by this service is
    that being a generic collection itself, it is possible to add/remove/clear instances
    of services at runtime, so we can always have total control of what it is inside
    the collection and the order in which is defined and instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: To that purpose, we find methods such as `Clear()`, `Contains()`, `IndexOf()`,
    `Insert()`, `InsertAt()`, `Remove` and `RemoveAt()`, just like we would find in
    any other generic collection.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping interfaces to instance classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous demo is simple enough to understand the basics of DI inside the
    `Microsoft.Extensions.DependencyInjection` library, but, most likely, in a real
    application, you will have some interfaces defined and a series of classes that
    implement those interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, it is more convenient to be able to map interfaces to classes
    that implement them, so you just have to ask for an implementation of the corresponding
    interface, thinking on the functionality the interface provides (the business
    problem to be solved), rather than in the concrete class that implements it.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that we're able to change the definitions at runtime (remember,
    it's a collection where we can add/remove items), so it is perfectly possible
    to redefine any previous mapping to a new one, according to our applications'
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the preceding demo, we''re using a very simple approach to see this in
    action. I''ve created two interfaces, and two classes that implement them, with
    a single method that writes a basic message to the `Console`. This is the initial
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is a correspondence between classes and interfaces, so we can now refer
    to the interface and let the DI engine decide which class instance is returned
    to us. This is quite similar to the demos we saw in the previous chapter when
    using third-party DI containers.
  prefs: []
  type: TYPE_NORMAL
- en: With that purpose, the `ServiceCollection` class supports an alternative way
    of defining references in which you can pass (generic signature) an interface
    name and the class that maps such interface when a `GetService<Interface>()` is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of requesting one of these implementations, we will ask for an instance
    of the predefined interface, rather than a concrete class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also have an alternative way to ask for a service by means of the
    `GetRequiredService<Interface>()` method, that throws an exception if the service
    type isn't registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming this change, the implementation of the demo is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous case, we don't ask for a given class, but the class implements
    the required interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is, again, as expected (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8eb2f516-7118-402d-a140-fc036cdb5850.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the registration works in a similar way to what we already saw in
    other DI containers. That is, if we use this syntax, that latest registered mapping
    is the one returned, although that can be changed dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Another very useful feature is the `GetServices<Interface>` method, since it
    allows us to recover all registered services and invoke them at will.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prove this by adding a couple of new classes that implement the same
    interfaces and register them together with the previous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After these definitions, we register both classes under the same Interface
    contracts, so they can be accessed altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since we're using the defined interface functionality, we know all of them will
    implement the `WriteXML()` function, even if they do it differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can appreciate the different calls in the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf46316e-d5cd-4b7f-ba67-9aa2e14c886d.png)'
  prefs: []
  type: TYPE_IMG
- en: Another alternative way to get the whole list of services is, of course, from
    the `services` collection itself. To perform this, we need another helper class
    also provided by the `Microsoft.Extensions.DependencyInjection` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the procedure is to create a `ServiceDescriptor` collection that
    holds the information of all services in our `ServiceCollection` class. We use
    an enumerator and the `CopyTo()` method (which expects a `ServiceCollection` as
    the first argument) to create such a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the collection is copied to the `ServiceDescriptor` collection, we can
    see at least five interesting properties that might, later on, be used to determine
    the service we need in a given scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6b2b26e-c182-48c3-8ab1-81c0b127b75e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that here we''re asking for the `ImplementationType` property to obtain
    all defined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99b1f3a4-c3c8-418d-81de-acb1b0149376.png)'
  prefs: []
  type: TYPE_IMG
- en: This gives us a clue on how to select a single service independently of its
    position in the collection. Another helper method linked to this functionality
    is the simple `Contains()` that asks for a `ServiceDescriptor` object as its unique
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another easy way to get information about the currently registered components
    in our services container is by iterating through it directly, using a simple
    `foreach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that depending on the way the services are registered and other programming
    features, not all the properties will have a value (in this case, it only makes
    sense asking for the interfaces (`ServiceType`), the implementations (`Types`)
    and their lifetimes).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also useful when we have more than a class that implements the same
    interface, because we can decide which one we need based on these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76036b1f-e60a-49f7-b72d-93e854a66e4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, it's possible to use some helper classes linked to the namespaces
    here implied, to perform registrations `a posteriori`. For instance, the `ServiceProviderServiceExtensions`
    class contains a static method capable of obtaining a given `ServiceType` linked
    to a certain provider.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, you can get an instance of a registered service without using
    the `ServiceCollection` that registered it, as long as you can pass the corresponding
    provider as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: I've created a variant of the previous demo, this time including a read-only
    property in each of the `*writer` classes to hold a unique identifier (a `GUID`),
    so it is easy to determine if we're using the same or another instance of the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code (a variant of the previous demo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re using two distinct approaches to get the same instance
    (identified by its `GUID`). We can test it by comparing both outputs (see the
    following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76e66637-4315-42cd-b072-4ebfcd7403b3.png)'
  prefs: []
  type: TYPE_IMG
- en: This could be especially useful in situations in which, for whatever reason,
    a call to services is not suitable or convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Providers can also be obtained via helper classes, besides the `BuildServiceProvider`
    method of `ServiceCollection`. To do so, we can use the `CreateDefaultServiceProvider`
    class, which also has instance methods to create, either a provider or a `Builder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the time being, those two are the only possibilities available to that
    class, but it can also be quite useful in certain scenarios where we prefer the
    service collection not to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be316783-9b1c-4f05-af4f-579fb1b2ed8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code has the provider created via the `DefaultServiceProvider`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I omit the output here, since it's exactly the same as in the previous demos,
    and you can check it yourself within the code accompanying this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way in which we can obtain a service provider. Yes, there's
    another one, linked to the static method `BuildServiceProvider` of the `ServiceCollectionContainerBuilderExtensions`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, programming it is even easier, since we don''t need any instance
    of the class, and the code gets reduced to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Just to get exactly the same results as we did before (again, I omit the output).
  prefs: []
  type: TYPE_NORMAL
- en: The concept of Scope Applied to services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with services and other DI-related functionality, an important
    point to define is its scope. DI documentation defines the scope of a service
    closely related to its lifetime, and therefore, with the moment in which that
    service should be disposed of by the Garbage Collector.
  prefs: []
  type: TYPE_NORMAL
- en: We have talked about the Transient and Singleton lifetimes previously, but the
    Scope lifetime is, indeed, a bit more confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Concretely, the `IServiceDispose` interface, which implements the `IDispose`
    interface, holds the method `Disposed of()`, method which, when called, ends the
    scope lifetime. It is included inside the `Microsoft.Extensions.DependencyInjection.Abstractions.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, the documentation states: "*Once this is disposed of, any scoped
    services that have been resolved from the* *M**icrosoft.Extensions.DependencyInjection.IServiceScope.ServiceProvider
    will also be disposed of"*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Its declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you remember in the first demos of this chapter, our `DependencyClass1` and
    `DependencyClass2` classes implemented the `IDisposable` interface, so we could
    call those methods after the classes' main operations were finished.
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency
    Injection in ASP.NET Core,* this concept adapts especially well to some internet
    applications' scenarios in which it makes a lot of sense to have a specific control
    for the lifetime of some services, and always have access to the execution context
    in the form of an instance class.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency Injection
    in ASP.NET Core*, you'll see that this feature can be important to face performance
    issues, resources of the server, scalability issues, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Other extensions with DI functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linked to the `Microsoft.Extensions` global namespace, we find related namespaces
    that are becoming popular among developers, because they help in different areas
    of the application's lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most used are `Microsoft.Extensions.Logging` and `Microsoft.Extensions.Logging.Console`,
    which you can use to configure and code logging services using the techniques
    of Dependency Injection that we've seen in this chapter. They offer functionality
    similar to other popular frameworks, such as Serilog, Log4Net or NLog.
  prefs: []
  type: TYPE_NORMAL
- en: I'm talking about `ILoggerFactory` and `ILogger<T>`, mainly used (especially
    in ASP.NET Core apps) to emit information at runtime, with the ability to redirect
    that information to different targets (console, output window, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: But they can also be used to monitor and debug applications in .NET Core, and,
    even not offering the whole set of resources we find in those, more specialized,
    frameworks, they can be, many times, enough to cover our needs.
  prefs: []
  type: TYPE_NORMAL
- en: A reflection on the structure of .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's quite interesting to see how .NET Core creators have designed this technology
    based on the Dependency Injection principles. That's why, besides its value as
    a tool for the developer, we can see the extra value of seeing DI really implemented
    by default in .NET Core libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Both classes are available inside the `Microsoft.Extensions.Logging` namespace,
    but other complementary namespaces, such as `Microsoft.Extensions.Logging.Console`
    and `Microsoft.Extensions.Logging.Debug`, also permit extended logging functionality
    that we'll use in the next demo. They can be easily referenced via NuGet packages,
    as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: To keep on demoing things with the simplest possible code, I'll use a simplified
    version of the previous demo, only this time using a single external class `XMLWriter`
    and its corresponding interface, with slight changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with the `DependencyInjection` namespace, `Microsoft.Extensions.Logging`
    appears next to `Configuration` and `Dependency` libraries when filtering for
    this criterion in the Search box (notice that we''ll need a total of four extra
    libraries, including `Logging.Console` and `Logging.Debug`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1db817ef-3a61-47fd-a814-8191e9bc8896.png)'
  prefs: []
  type: TYPE_IMG
- en: After installing those libraries, if you're curious about these API's possibilities,
    you can also inspect the references that will show up in the `Solution Explorer`,
    next to the NuGet references' entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionality provided by these logging services include the ability to
    write to the `Console`, using distinct types of messages (depending on the nature
    of the output: debug, information, warning, or error) and using several colors
    and formats to express these categories.'
  prefs: []
  type: TYPE_NORMAL
- en: Mark Michaelis clearly explains in his MSDN article *Essential .NET - Dependency
    Injection with .NET Core* some of the advantages of these DI implementations that
    we find linked to .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: He points out that, when you want to switch between different implementations
    of some service and avoid hard-coding a reference to any service implementation,
    it is much more extensible and maintainable to ask for a factory of such instance,
    just like we did in other demos. The `ILoggerFactory` implements that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'He goes even further, highlighting that: "*you ask for an interface (such as
    ILoggerFactory**) with the expectation that the service provider (in this case,
    NLog, Log4Net or Serilog) will implement the interface"*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, `ILoggerFactory` is extensible even with third-party libraries! He also
    remarks that: "*the result is that while the client will directly reference the
    abstract assembly (Logging.Abstractions), defining the service interface, no references
    to the direct implementation will be needed"*.'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, you may have noticed that the `ServiceCollection` itself owns a method
    called `AddLogging()`, which is a convenient method to activate logging functionality
    for the collection. This call is really translated to an internal registry of
    the `ILoggerFactory` service as part of the services collection we are configuring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering that we can also concatenate calls to configure our service collections,
    let''s see the first part of our new `Main()` method, including that call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, we enable logging inside the `ServiceCollection` via `AddLogging()`.
    So, what happened? Let''s check the new members that our collection now has, by
    iterating through the resulting services object, like in a previous demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll obtain a collection containing three services (see the following output),
    because the `AddLogging()` method has, indeed, registered a `LoggingFactory` class
    with the `ILoggingFactory` interface, and another generic one, `ILogger<>`. That
    `ILogger<>` class will later be configured to provide any other class with the
    ability to send logging messages to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66c9e26a-bf30-486b-a816-6289e9dbd476.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, the next step is to obtain an `ILoggerFactory` object and link that
    object to the `Console`, which we perform with a call to `AddConsole()` in this
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you see, `AddConsole` expects some additional configuration in the form of
    an `enum` value of type `LogLevel`, which determines the minimum level of severity
    the runtime will filter when sending messages to the console--whenever the logging
    system receives an entry, it will ignore it if it is below that level.
  prefs: []
  type: TYPE_NORMAL
- en: LogLevels Severity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LogLevel` enumeration also establishes the priority of messages (pretty
    useful in case we want to distinguish low-level from high-level messages, and
    even redirect them to different output windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the official documentation these levels are organized as follows
    (it goes from least to highest severity):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace = 0**: For information that is valuable only to a developer debugging
    an issue. These messages may contain sensitive application data and so should
    not be enabled in a production environment. Disabled by default. For example,
    credentials: `{"User":"someuser", "Password":"P@ssword"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug = 1**: For information that has short-term usefulness during development
    and debugging. For example, entering the `Configure` method with fl the g set
    to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information = 2**: For tracking the general flow of the application. These
    logs typically have some long-term value. For example, the request received for
    path `/``api/todo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning = 3**: For abnormal or unexpected events in the application flow.
    These may include errors or other conditions that do not cause the application
    to stop, but which may need to be investigated. Handled exceptions are a common
    place to use the warning log level. For example, `FileNotFoundException` for file
    `quotes.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error = 4**: For errors and exceptions that cannot be handled. These messages
    indicate a failure in the current activity or operation (such as the current HTTP
    request), not an application-wide failure. For example, log message: `Cannot insert
    record due to duplicate key violation`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Critical = 5**: For failures that require immediate attention. For example,
    data loss scenarios, out of disk space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The IDE also shows those levels through the IntelliSense services, together
    with an explanation of each purpose and functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f7d1638-39ba-41ce-9149-55c0adae1e7f.png)'
  prefs: []
  type: TYPE_IMG
- en: In this way, the returned `ILoggerFactory` service we get when asking for a
    reference will redirect any output to the console using the debug level configuration,
    if not instructed otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The `ILogger` and `ILoggerFactory` interfaces are located in `Microsoft.Extensions.Logging.Abstractions`,
    and default implementations of them are in `Microsoft.Extensions.Logging`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want both classes (`XMLWriter` and `Program`) to use these logging
    services, we need an `ILogger` instance for each one. We''ll start creating one
    for `Program` and presenting a first set of messages in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the creation of the logger class implies calling the `CreateLogger<Program>()`
    generic method. Once instantiated, the logger has methods to declare different
    scopes, (marking the beginning and the end of each scope) and to send six different
    types of messages to the console, each one representing a different severity level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the output, we can appreciate the differences between
    those messages'' formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/606837b0-ae76-44ad-804d-dc8669814a7a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the different messages' severity levels generate different formats
    in the output using distinct colors and prefixes to denote its `LogLevel` category.
    But, wait a minute! There's one missing (the `Trace` message).
  prefs: []
  type: TYPE_NORMAL
- en: Well, not quite. What happens is that the `Trace` `LogLevel` doesn't output
    to the console, and it is prepared to be used mainly in web applications in which
    the trace switch is enabled (we will see more on that in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml),
    *Dependency Injection in ASP.NET Core*).
  prefs: []
  type: TYPE_NORMAL
- en: So, all that said, how can we use this architecture and logging services from
    our `XMLWriter` class? Let's change the implementation, so we use one of the DI
    patterns that we saw in the previous chapter--the constructor dependency model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use that model, we have to change our `XMLWriter` class a little to include
    a read-only property that holds the `ILogger<>` instance and assign its value
    in the class'' constructor. So, the final format of our, this time, unique `XMLWriter`
    classes will be (the interface definition is not affected yet, so it''s just the
    same as in previous demos):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only thing remaining is to use the `logger` instead of the previous calls
    to `Console` and call one of the `Log*` methods to generate the intended output.
    And that's it.
  prefs: []
  type: TYPE_NORMAL
- en: We have totally replaced the functionality provided by the `Console` class with
    the logging services delivered by the `ILogginFactory` and `ILogger` objects,
    and we can also configure the severity level to generate distinct output formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with all that in mind, we end up with a final version of our `Main` method
    with this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the final output (see the following screenshot), all messages
    are presented in the console in the same sequence they''re invoked, using the
    predefined formats that .NET Core configures, and including our `XMLWriter` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d65f85e-fa1c-4fc9-8e55-3a85320b9fdf.png)'
  prefs: []
  type: TYPE_IMG
- en: This is not all. We still have other options available that allow us to separate
    and filter the output message destination. This possibility is correlated to the
    `Microsoft.Extensions.Logging.Debug` library, which should also be referenced
    just like the others we're using here.
  prefs: []
  type: TYPE_NORMAL
- en: One of the features included in this library is the `AddDebug()` method of `ILoggerFactory`.
    Once activated, it permits us to send messages to the Debug window, enabling a
    separation of messages conditional to its severity level, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this functionality, we''ll make a few changes in our definitions of
    the `IXMLWriter` interface and update the implementation accordingly. Our new
    interface will have another method that also sends messages to the predefined
    output (which, in this case, will show up in several places at runtime):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the updated code of XMLWriter will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we have two distinct methods to write messages. To test this functionality,
    we can configure the `ILoggerService` object in the `Main()` method (which, remember,
    is of type `ILoggerFactory`). Once the new namespace is loaded and available,
    we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, we allow sending messages to the `Debug` or `Output` windows,
    either for console or web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to test different options, changing the types of severity levels
    used in the calls to this method, and the already existing ones. For example,
    we can make a call to `WriteXMLWithSeverityLevel()` and observe the two outputs
    (now we have two), that are generated during execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On one side, the output now presents the new message (nothing unexpected):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/324caea3-87c7-41a9-9eb7-285ad3cf41e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But, now, we have more messages. If we take a look at the `Output` window,
    we''ll see the new entries depending on the `LogLevel` we configure--some of them
    will be presented, and others, ignored (as you can see, in this version, only
    the first four messages are replicated in the Output window, and all XMLWriter
    messages are ignored):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d33a0f69-0e87-4e06-ae02-edc6de0e2883.png)'
  prefs: []
  type: TYPE_IMG
- en: This is only a first approach to some of the services that adopt the DI architecture
    and that are available inside .NET Core. We will see much more on these implementations
    when dealing with ASP.NET Core coding, in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml),
    *Dependency Injection in ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have made a first approach to how Dependency Injection technologies
    are supported and implemented in the current version of the .NET Core (2.0) and
    how we can use them, even outside of ASP.NET projects.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we've seen the main characteristics of NET Core and its installation
    and usage from Visual Studio, especially focused on the latest version, Visual
    Studio 2017, together with the distinct types of deployment linked to this version
    of the framework, along with the main features and functionality included in the
    namespaces related to DI and, especially, inside the `Microsoft.Extensions.DependencyInjection`
    and `Microsoft.Extensions.Logging` containers.
  prefs: []
  type: TYPE_NORMAL
- en: We've also analyzed the classes and interfaces related to this architecture,
    together with its implementation through a bunch of samples, ending with some
    real implementations, that are already part of .NET Core 2.0, such as the logging
    services, and how to use them, from any class.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency Injection
    in ASP.NET Core*, our approach will be more real, since it deals with web applications
    and how the new architecture and configuration of websites manage these new concepts,
    such as middleware and services configuration, in which DI plays an important
    role since the very beginning.
  prefs: []
  type: TYPE_NORMAL
