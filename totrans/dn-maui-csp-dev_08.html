<html><head></head><body>
		<div><h1 id="_idParaDest-137" class="chapter-number"><a id="_idTextAnchor144"/>8</h1>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor145"/>Storing and Retrieving Data</h1>
			<p>You now have all the fundamentals to create and navigate pages, layouts, and the controls used to populate pages. Congratulations! You are now a .NET MAUI programmer.</p>
			<p>This chapter begins the intermediate section of the book, in which you will see how to store and retrieve data and then create unit tests – both critical aspects of writing real-world and, especially, enterprise apps.</p>
			<p>Programs interact with data, and most need to store that data after an app closes and restore it as needed when the app resumes. In this chapter, we will consider two variations on this – long-term persistence of user preferences and long-term database storage.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Storing user preferences</li>
				<li>Storing to a database on your device</li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor146"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need Visual Studio. You will also install another <code>NuGet</code> package, as shown later in this chapter.</p>
			<p>The source code for the finished code in this chapter can be found here: <a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence</a>. To follow along, you will need to use the code from the previous chapter.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor147"/>Storing user preferences</h1>
			<p>Most apps allow a <a id="_idIndexMarker330"/>user to set preferences that can be stored on a phone and retrieved, typically when the app starts. .NET MAUI provides a service for this, easily storing <em class="italic">key/value pairs</em>, such as theme preferences, the last date used, the login name, and so on.</p>
			<p>.NET MAUI provides the <code>IPreferences</code> interface to help store these preferences. With this, and the associated <code>Preferences</code> class (both in the <code>Microsoft.Maui.Storage</code> namespace), you can store string keys and values of any of the following types:</p>
			<ul>
				<li><code>Boolean</code></li>
				<li><code>Double</code></li>
				<li><code>Int</code> (<code>int32</code>, <code>single</code>, and <code>int64</code>)</li>
				<li><code>String</code></li>
				<li><code>DateTime</code></li>
			</ul>
			<p class="callout-heading">Persisting DateTime</p>
			<p class="callout"><code>DateTime</code> values are stored as 64-bit integers and use the <code>ToBinary</code> and <code>FromBinary</code> methods to encode and decode respectively.</p>
			<p>Let’s create a <code>UserPreferences</code> page with a short form to gather a user’s preferences. We’ll also add <code>Button</code>, which will display all the saved preferences and allow the user to delete one or all of them.</p>
			<p class="callout-heading">Name collisions</p>
			<p class="callout">We have a preferences page, which may cause a problem because we want to use the built-in <code>Preferences</code> object. To solve this, go to <code>PreferencesViewModel</code> and rename <code>List&lt;Preference&gt;</code> <code>preferenceList</code>. There should be no other conflicts. The safest way to rename is to use the Visual Studio rename functionality, which you can get to by putting your cursor on the name and entering <code>Control-R R</code>. After you rename, you may have to manually rename <code>ObservableProperties</code>, depending on the latest update to Visual Studio.</p>
			<p>The<a id="_idIndexMarker331"/> new <code>UserPreferences</code> page will gather three preferences from the user, which are as follows:</p>
			<ul>
				<li>The user’s display name</li>
				<li>The preferred theme</li>
				<li>Whether the app can be used on cellular or Wi-Fi only</li>
			</ul>
			<p class="callout-heading">Light and dark themes</p>
			<p class="callout">It has become common in apps to offer a user light and dark themes. In .NET MAUI, you can offer the user the choice, or if you are ambitious, you can create your own themes.</p>
			<p class="callout">We will gather but not implement a user’s preferences relating to light and dark themes.</p>
			<p>Here is the <code>UserPreferences</code> page:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
    Title="User Preferences"
    x:Class="ForgetMeNotDemo.View.UserPreferencesPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Grid
            ColumnDefinitions="*,*"
            RowDefinitions="*,*,*,*"&gt;
            &lt;Label
                Grid.Column="0"
                Grid.Row="0"
                Text="Display Name" /&gt;
            &lt;Entry
                Grid.Column="1"
                Grid.Row="0"
                Placeholder="Your name as you want it
                   displayed"
                Text="{Binding DisplayName}" /&gt;</pre>
			<p>Having <a id="_idIndexMarker332"/>gathered the user’s display name, we can go on to ask them which of the two mutually exclusive themes they’d like. To do so, we will use <code>RadioButtonGroup</code> and two <code>RadioButtons</code>, initializing <code>Light</code> to be selected:</p>
			<pre class="source-code">
            &lt;Label
                Grid.Column="0"
                Grid.Row="1"
                Text="Theme" /&gt;
            &lt;HorizontalStackLayout
                Grid.Column="1"
                Grid.Row="1"
                RadioButtonGroup.GroupName="{Binding
                    ThemeGroupName}" [1]
                RadioButtonGroup.SelectedValue="{Binding
                    ThemeSelection}"&gt; [2]
                &lt;RadioButton Content="Dark" /&gt;
                &lt;RadioButton
                    Content="Light"
                    IsChecked="True" /&gt; [3]
            &lt;/HorizontalStackLayout&gt;</pre>
			<p>We now<a id="_idIndexMarker333"/> want to ask the user whether the app should only be used when connected to Wi-Fi. We can do this with a switch control, where <code>on</code> indicates <code>WiFi only</code> is <code>true</code>:</p>
			<pre class="source-code">
            &lt;Label
                Grid.Column="0"
                Grid.Row="2"
                Text="Wifi Only?" /&gt;
            &lt;Switch                  [4]
                Grid.Column="1"
                Grid.Row="2"
                HorizontalOptions="Start"
                IsToggled="{Binding WifiOnly}"
                OnColor="Green"
                ThumbColor="Blue" /&gt;
            &lt;Button
                Command="{Binding SavePreferencesCommand}"
                Grid.Column="0"
           Grid.ColumnSpan="2"
                Grid.Row="3"
                HorizontalOptions="Center"
                Text="Save" /&gt;
        &lt;/Grid&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre>
			<p><code>[1]</code> Here, we<a id="_idIndexMarker334"/> introduce a new control, <code>RadioButton</code>. Radio buttons are in either implicit or explicit groups. Implicit groups are created by putting all the <code>RadioButtons</code> into the same container (for example, <code>VerticalStackLayout</code>). Explicit groups are given <code>GroupName</code>, as we see here.</p>
			<p><code>[2]</code> The user’s choice is recorded by the <code>SelectedValue</code> property.</p>
			<p><code>[3]</code> When defining <code>RadioButtons</code>, you can (and should) set exactly one to <code>IsChecked=true</code>.</p>
			<p><code>[4]</code> The switch control toggles off and on (<code>false</code> and <code>true</code>).</p>
			<p>Now that we know how to gather the information the user wants to save, let’s take a look at the lightweight mechanism provided by .NET MAUI to do so.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor148"/>UserPreferencesViewModel</h2>
			<p>As you <a id="_idIndexMarker335"/>might expect, the first thing we’ll do is create properties for the bound controls:</p>
			<pre class="source-code">
[ObservableObject]
public partial class UserPreferencesViewModel
{
  [ObservableProperty] private string displayName;
  [ObservableProperty] private string themeSelection;
  [ObservableProperty] private bool wifiOnly;
  public string ThemeGroupName =&gt; "Theme";</pre>
			<p>Next, we need to handle the <code>SavePreferences</code> command. We do this using the .NET MAUI <code>Preferences</code> object, calling the static <code>Set</code> method:</p>
			<pre class="source-code">
[RelayCommand]
public async Task SavePreferences()
{
  Preferences.Default.Set("DisplayName", displayName);
  Preferences.Default.Set("ThemeSelection",
    themeSelection);
  Preferences.Default.Set("WifiOnly", wifiOnly);
}</pre>
			<p>.NET MAUI will <a id="_idIndexMarker336"/>handle the persistence for us.</p>
			<p>Now that we’ve created the page, let’s set up navigation to get to it.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor149"/>Navigating to UserPreferences</h2>
			<p>We need a way to <a id="_idIndexMarker337"/>get to our new page. A typical place to put this would be an <code>Button</code> as the last item in <code>VerticalStackLayout</code>:</p>
			<pre class="source-code">
&lt;Button
    Command="{Binding OpenPreferencesCommand}"
    Text="Preferences"
    WidthRequest="150"
    Margin="10,50,10,0"/&gt;</pre>
			<p>The <code>OnPreferences</code> command simply navigates to our new page:</p>
			<pre class="source-code">
[RelayCommand]
public async Task OpenPreferences()
{
  await Shell.Current.GoToAsync("userpreferences");
}</pre>
			<p>Make sure you register the <code>userpreferences</code> page in <code>AppShell</code> before invoking this method.</p>
			<p>The page isn’t pretty, but it is ready to gather a user’s preferences, as shown in the following figure:</p>
			<div><div><img src="img/Figure_8.1_B19723.jpg" alt="Figure 8.1 – The preferences page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The preferences page</p>
			<p>A user is <a id="_idIndexMarker338"/>now able to set their preferences. The next time they start up the app, we’ll want to retrieve those preferences and set the app accordingly.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor150"/>Retrieving the preferences</h2>
			<p>When a <a id="_idIndexMarker339"/>user closes the app, the preferences are preserved. The next time we return to the preferences page, we should see the preferences restored. We accomplish this using the <code>Get</code> method on <code>Preferences.Default</code>.</p>
			<p>The <code>Get</code> method takes two parameters, the <em class="italic">key</em> and <em class="italic">a default value</em>. We’ll put this in the <code>ViewModel</code> constructor so that the preferences page is populated when it is displayed:</p>
			<pre class="source-code">
public UserPreferencesViewModel()
{
  displayName = Preferences.Default.Get("DisplayName",
    "Unknown");
  themeSelection = Preferences.Default.Get
    ("ThemeSelection", "Light");
  wifiOnly = Preferences.Default.Get("WifiOnly", false);
}</pre>
			<p>Note that the <a id="_idIndexMarker340"/>first argument to <code>Get</code> is the key, as defined in the <code>Set</code> method in the <code>SavePreferences</code> method. The second argument is the default value that will be provided if the key is not present.</p>
			<p class="callout-heading">Checking for a key</p>
			<p class="callout">While you don’t have to check that a key exists before trying to retrieve it, there are times when you’ll want to differentiate between the value you get back being the default value or the value that is actually stored (for example, is <code>WiFiOnly</code> <code>false</code> because it really is <code>false</code>, or because that key doesn’t exist and you received the default value?).</p>
			<p class="callout">To manage this, you can use the <code>ContainsKey</code> method on <code>Preferences.Default</code>:</p>
			<p class="callout"><code>bool knowsWifi = </code><code>Preferences.DefaultContainsKey("WifiOnly");</code></p>
			<p>The user can now store their preferences, and in theory, they can be restored. Let’s make sure that this is working.</p>
			<h3>Testing the persistence</h3>
			<p>To see that <a id="_idIndexMarker341"/>this works, navigate to the <code>UserPreferences</code> page by way of the <code>UserPreferences</code> page, you should see that your entered values have been restored.</p>
			<p class="callout-heading">Clear</p>
			<p class="callout">If you want to clear a specific <code>UserPreference</code>, use the <code>Remove</code> method:</p>
			<p class="callout"><code>Preferences.Default.Remove("DisplayName");</code></p>
			<p class="callout">To remove them all, use the <code>Clear</code> method:</p>
			<p class="callout"><code>Preferences.Default.Clear()</code></p>
			<p>The <code>Preferences</code> interface<a id="_idIndexMarker342"/> is designed to hold simple data in key/value pairs. Microsoft warns against storing long strings, as it may negatively affect performance. If you need to store more complex or larger data, you’ll want to use a database, and the database of choice for many .NET MAUI developers<a id="_idIndexMarker343"/> is <strong class="bold">SQLite</strong>.</p>
			<p>The lightweight persistence mechanism is great for storing relatively short strings and other primitives, but if you are going to store substantial data, you’ll need a real database.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor151"/>Storing to a database on your device</h1>
			<p>There are a <a id="_idIndexMarker344"/>couple of contenders for storing data on your device. The most popular is SQLite, which is an open source, small, fast, and highly reliable database. It is the most used database in the world and is built into all mobile phones and most computers.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor152"/>Installing SQLite</h2>
			<p>To get started, install <a id="_idIndexMarker345"/>the latest version of the <strong class="bold">sqlite-net-pcl</strong> NuGet package, as shown in <em class="italic">Figure 8</em><em class="italic">.2</em>.</p>
			<div><div><img src="img/Figure_8.2_B19723.jpg" alt="Figure 8.2 – Installing sqlite-net-pcl&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Installing sqlite-net-pcl</p>
			<p class="callout-heading">Installing the correct package</p>
			<p class="callout">There are a number of SQLite packages available on NuGet. The one you want is <strong class="bold">sqlite-net-pcl</strong> and has the author <strong class="bold">SQLite-net</strong>, as shown in <em class="italic">Figure 8</em><em class="italic">.3</em>.</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/Figure_8.3_B19723.jpg" alt="Figure 8.3 – The author should be SQLite-net&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The author should be SQLite-net</p>
			<p>Once <code>sqlitepclraw.bundle_green</code> and if it is not automatically installed, manually install <strong class="bold">SQLitePCLRaw.bundle_green</strong>, as shown in <em class="italic">Figure 8</em><em class="italic">.4</em>.</p>
			<div><div><img src="img/Figure_8.4_B19723.jpg" alt="Figure 8.4 – Installing SQLitePCLRaw.bundle_green&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Installing SQLitePCLRaw.bundle_green</p>
			<p>With the packages installed, you are ready to set up your program to create and use an SQLite database.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor153"/>Getting started with SQLite</h2>
			<p>To create <a id="_idIndexMarker347"/>your database, you’ll need to store the database filename and its path among other constant values. To do so, right-click on your project and create a <code>Constants.cs</code> file. For convenience, I’ll create a <code>Database</code> folder <a id="_idIndexMarker348"/>and place it there:</p>
			<pre class="source-code">
namespace ForgetMeNotDemo.Database;
public static class Constants
{
  public const string DatabaseFilename =
    "ForgetMeNotDemo.db3"; [1]
  public const SQLite.SQLiteOpenFlags Flags = [2]
    SQLite.SQLiteOpenFlags.ReadWrite |
    SQLite.SQLiteOpenFlags.Create |
    SQLite.SQLiteOpenFlags.SharedCache;
  public static string DatabasePath =&gt;
    Path.Combine(FileSystem.AppDataDirectory,
      DatabaseFilename); [3]
}</pre>
			<p><code>[1]</code> Set the name for your database. Feel free to use the name as shown or rename it to whatever you like.</p>
			<p><code>[2]</code> Set the flags for how the file should be managed. Here, we’ve set it to read/write mode, to create the database if it doesn’t exist, and finally, to enable multithreaded database access.</p>
			<p><code>[3]</code> Append the <a id="_idIndexMarker349"/>database filename we created earlier to the directory name for the app.</p>
			<p>With these constants established, we’re ready to create the database. We’ll encapsulate that work in a class.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor154"/>The Database class</h2>
			<p>It is a <a id="_idIndexMarker350"/>common pattern to wrap a database access layer in a class, abstracting it away and decoupling it from the rest of the app. We’ll put all the query logic into this class. This centralization of database concerns will help make our app scalable over time.</p>
			<p>The class will need an <code>Init()</code> method to create the database and our first table. To get us started, let’s create a table to hold all our preferences:</p>
			<pre class="source-code">
using ForgetMeNotDemo.Database;
using ForgetMeNotDemo.Model;
using SQLite;
namespace ForetMeNotDemoDatabase;
public class ForgetMeNotDemoDatabase
{
    private SQLiteAsyncConnection Database;  [1]
    private async Task Init()
    {
        if (Database is not null)  [2]
            return;
        Database = new SQLiteAsyncConnection(  [3]
              Constants.DatabasePath,
              Constants.Flags);
        await Database.CreateTableAsync&lt;Preference&gt;(); [4]
    }
}</pre>
			<p><code>[1]</code> Declare an object of type <code>SQLiteAsyncConnection</code> and name it <code>Database</code>.</p>
			<p><code>[2]</code> If it already exists, then return (that is, treat it as a singleton).</p>
			<p><code>[3]</code> Create <code>SQliteAsyncConnection</code>, passing in the path and flags from the <code>constant</code> class.</p>
			<p><code>[4]</code> Create our first table, declaring<a id="_idIndexMarker351"/> the type of object we’ll store in the table (the <code>Preference</code> objects).</p>
			<p>We are ready to start using the database, to add and manipulate our table.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor155"/>CRUD</h2>
			<p>As is true for virtually all databases, we’ll want to support <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>). For now, let’s just implement the methods to create and read records. The method to create<a id="_idIndexMarker352"/> is typically combined with the update method.</p>
			<h3>Create/update</h3>
			<p>We’re <a id="_idIndexMarker353"/>going to want to know whether a <code>Preference</code> is already in the table so that we know, when given a <code>Preference</code> record, whether to add it or update it. It will need a unique ID. Fortunately, SQLite is very good at providing IDs.</p>
			<p>Start by opening <code>Preference.cs</code> in the <code>Model</code> folder and adding an <code>id</code> property:</p>
			<pre class="source-code">
[ObservableObject]
public partial class Preference
{
    [ObservableProperty] private int id;
    [ObservableProperty] private string preferencePrompt;
    [ObservableProperty] private string preferenceValue;
}</pre>
			<p>Next, return to <code>ForgetMeNotDemoDatabase.cs</code> and add the <code>SavePreference</code> method:</p>
			<pre class="source-code">
public async Task&lt;int&gt; SavePreference(Preference
    preference) [1]
{
    await Init();  [2]
    if (preference.Id != 0) [3]
    {
        return await Database.UpdateAsync(preference);
    }
    else
    {
        return await Database.InsertAsync(preference);
    }
}</pre>
			<p><code>[1]</code> Our <code>SavePreference</code> method <a id="_idIndexMarker354"/>takes the type (<code>Preference</code>) as an argument and returns the number of rows updated (in this case, zero or one).</p>
			<p><code>[2]</code> Call <code>Init</code> on the database each time you take an action.</p>
			<p><code>[3]</code> Check to see whether the <code>Preference</code> object has <code>Id</code>. Since <code>Id</code> is an <code>int</code> type, it defaults to zero, so if it is not zero, we need to do an update; otherwise, we need to do an insert.</p>
			<p>Now that we can create (or update) a record, let’s write code to read that data out of the database.</p>
			<h3>Read</h3>
			<p>We’ll <a id="_idIndexMarker355"/>want to be able to get all our preferences back from the database. For that, we’ll create a <code>GetPreferences</code> method that returns a list of <code>Preference</code> objects:</p>
			<pre class="source-code">
public async Task&lt;List&lt;Preference&gt;&gt; GetPreferences()
{
    await Init();
    return await Database.Table&lt;Preference&gt;();
}</pre>
			<p class="callout-heading">Soft deletion</p>
			<p class="callout">When we write our <code>Delete</code> method, we probably will want to do a <em class="italic">soft</em> deletion – that is, mark it as deleted rather than actually removing it. For this to work, you’ll need to add another property to <code>Preference</code>, <code>Deleted</code>, and also <code>int</code>. Our read statement will then take a <code>where</code> clause, checking that the <code>Deleted</code> property is equal to zero.</p>
			<p>Once you have a database design, you need to decide whether you are going to keep the database locally on a device or in the cloud, accessed through your API.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor156"/>Local or remote?</h1>
			<p>A <a id="_idIndexMarker356"/>design question for this app is whether we want to store our preferences, buddies, invitations, and so forth in tables on a device, or instead use a web service and database in the cloud.</p>
			<p>To facilitate a secure interaction when sending and receiving invitations and lists of preferences, we’ve decided to move all the database operations to the cloud. However, everything in this chapter is not only relevant to <code>ForgetMeNotDemo</code>; it will be of use to you if you decide to store data locally on a phone or computer.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor157"/>Summary</h1>
			<p>In this chapter, we reviewed two ways of storing data. The simplest and most lightweight is to use the preferences facilities of .NET MAUI. This is great if all you need is to store primitives and short strings that are targeted at persisting a user’s preferences for a program.</p>
			<p>If you need to persist more substantial data, you’ll need a database, and by far the most popular type for on-device storage is SQLite. We examined the CRUD functionality of SQLite and then pointed out the alternative of not storing everything on a device but, rather, storing in the cloud and gaining access through a program’s API.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor158"/>Quiz</h1>
			<ol>
				<li>What is the class that handles simple storage of user data in key/value pairs?</li>
				<li>What two values do we pass to the <code>Get</code> method to retrieve the stored value?</li>
				<li>Which <code>NuGet</code> packages do we need to work with SQLite in .NET MAUI?</li>
				<li>What type of object do we use to create a table?</li>
			</ol>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor159"/>You try it</h1>
			<p>Add the remaining CRUD operations to the <code>Preference</code> table (for example, delete and get by ID).</p>
		</div>
		<div><div></div>
		</div>
	</body></html>