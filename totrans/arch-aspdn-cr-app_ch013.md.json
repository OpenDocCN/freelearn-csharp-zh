["```cs\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services\n    .AddSingleton<SearchMachine>(x\n        => new LinearSearchMachine(1, 10, 5, 2, 123, 333, 4))\n    .AddSingleton<SearchMachine>(x\n        => new BinarySearchMachine(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n;\nvar app = builder.Build();\napp.MapGet(\"/\", (IEnumerable<SearchMachine> searchMachines) =>\n{\n    var sb = new StringBuilder();\n    var elementsToFind = new int[] { 1, 10, 11 };\n    foreach (var searchMachine in searchMachines)\n    {\n        var typeName = searchMachine.GetType().Name;\n        var heading = $\"Current search machine is {typeName}\";\n        sb.AppendLine(\"\".PadRight(heading.Length, '='));\n        sb.AppendLine(heading);\n        foreach (var value in elementsToFind)\n        {\n            var index = searchMachine.IndexOf(value);\n            var wasFound = index.HasValue;\n            if (wasFound)\n            {\n                sb.AppendLine($\"The element '{value}' was found at index {index!.Value}.\");\n            }\n            else\n            {\n                sb.AppendLine($\"The element '{value}' was not found.\");\n            }\n        }\n    }\n    return sb.ToString();\n});\napp.Run(); \n```", "```cs\nnamespace TemplateMethod;\npublic abstract class SearchMachine\n{\n    protected int[] Values { get; }\n    protected SearchMachine(params int[] values)\n    {\n        Values = values ?? throw new ArgumentNullException(nameof(values));\n    }\n    public int? IndexOf(int value)\n    {\n        if (Values.Length == 0) { return null; }\n        var result = Find(value);\n        return result;\n    }\n    protected abstract int? Find(int value);\n}\n```", "```cs\nnamespace TemplateMethod;\npublic class LinearSearchMachine : SearchMachine\n{\n    public LinearSearchMachine(params int[] values)\n        : base(values) { }\n    protected override int? Find(int value)\n    {\n        for (var i = 0; i < Values.Length; i++)\n        {\n            if (Values[i] == value) { return i; }\n        }\n        return null;\n    }\n}\n```", "```cs\nnamespace TemplateMethod;\npublic class BinarySearchMachine : SearchMachine\n{\n    public BinarySearchMachine(params int[] values)\n        : base(values.OrderBy(v => v).ToArray()) { }\n    protected override int? Find(int value)\n    {\n        var index = Array.BinarySearch(Values, value);\n        return index < 0 ? null : index;\n    }\n}\n```", "```cs\n=============================================\nCurrent search machine is LinearSearchMachine\nThe element '1' was found at index 0.\nThe element '10' was found at index 1.\nThe element '11' was not found.\n=============================================\nCurrent search machine is BinarySearchMachine\nThe element '1' was found at index 0.\nThe element '10' was found at index 9.\nThe element '11' was not found.\n```", "```cs\nnew LinearSearchMachine(1, 10, 5, 2, 123, 333, 4)\nnew BinarySearchMachine(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```", "```cs\nnamespace TemplateMethod;\npublic class LinearSearchMachineTest\n{\n    public class IndexOf\n    {\n        [Theory]\n        [InlineData(1, 0)]\n        [InlineData(2, 4)]\n        [InlineData(3, 2)]\n        [InlineData(7, null)]\n        public void Should_return_the_expected_result(\n            int value, int? expectedIndex)\n        {\n            // Arrange\n            var sorter = new LinearSearchMachine(1, 5, 3, 4, 2);\n            // Act\n            var index = sorter.IndexOf(value);\n            // Assert\n            Assert.Equal(expectedIndex, index);\n        }\n    }\n}\n```", "```cs\nnamespace TemplateMethod;\npublic class BinarySearchMachineTest\n{\n    public class IndexOf\n    {\n        [Theory]\n        [InlineData(1, 0)]\n        [InlineData(8, 5)]\n        [InlineData(3, 2)]\n        [InlineData(7, null)]\n        public void Should_return_the_expected_result(int value, int? expectedIndex)\n        {\n            // Arrange\n            var sorter = new BinarySearchMachine(1, 2, 3, 4, 5, 8);\n            // Act\n            var index = sorter.IndexOf(value);\n            // Assert\n            Assert.Equal(expectedIndex, index);\n        }\n    }\n}\n```", "```cs\nnamespace ChainOfResponsibility;\npublic record class Message(string Name, string? Payload);\n```", "```cs\nnamespace ChainOfResponsibility; \npublic interface IMessageHandler\n{\n    void Handle(Message message);\n}\n```", "```cs\nnamespace ChainOfResponsibility;\npublic class AlarmTriggeredHandler : IMessageHandler\n{\n    private readonly IMessageHandler? _next;\n    public AlarmTriggeredHandler(IMessageHandler? next = null)\n    {\n        _next = next;\n    }\n    public void Handle(Message message)\n    {\n        if (message.Name == \"AlarmTriggered\")\n        {\n            // Do something clever with the Payload\n        }\n        else\n        {\n            _next?.Handle(message);\n        }\n    }\n}\npublic class AlarmPausedHandler : IMessageHandler\n{\n    private readonly IMessageHandler? _next;\n    public AlarmPausedHandler(IMessageHandler? next = null)\n    {\n        _next = next;\n    }\n    public void Handle(Message message)\n    {\n        if (message.Name == \"AlarmPaused\")\n        {\n            // Do something clever with the Payload\n        }\n        else\n        {\n            _next?.Handle(message);\n        }\n    }\n}\npublic class AlarmStoppedHandler : IMessageHandler\n{\n    private readonly IMessageHandler? _next;\n    public AlarmStoppedHandler(IMessageHandler? next = null)\n    {\n        _next = next;\n    }\n    public void Handle(Message message)\n    {\n        if (message.Name == \"AlarmStopped\")\n        {\n            // Do something clever with the Payload\n        }\n        else\n        {\n            _next?.Handle(message);\n        }\n    }\n}\n```", "```cs\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddSingleton<IMessageHandler>(\n    new AlarmTriggeredHandler(\n        new AlarmPausedHandler(\n            new AlarmStoppedHandler())));\n```", "```cs\nvar app = builder.Build();\napp.MapPost(\n    \"/handle\",\n    (Message message, IMessageHandler messageHandler) =>\n    {\n        messageHandler.Handle(message);\n        return $\"Message '{message.Name}' handled successfully.\";\n    });\napp.Run();\n```", "```cs\nMessage 'AlarmTriggered' handled successfully.\n```", "```cs\npublic class DefaultHandler : IMessageHandler\n{\n    public void Handle(Message message)\n    {\n        throw new NotSupportedException(\n            $\"Messages named '{message.Name}' are not supported.\");\n    }\n}\n```", "```cs\nbuilder.Services.AddSingleton<IMessageHandler>(\n    new AlarmTriggeredHandler(\n        new AlarmPausedHandler(\n            new AlarmStoppedHandler(\n                new DefaultHandler()\n            ))));\n```", "```cs\nSystem.NotSupportedException: Messages named 'SomeUnhandledMessageName' are not supported.\n   at ChainOfResponsibility.DefaultHandler.Handle(Message message) in C12\\src\\ChainOfResponsibility\\DefaultHandler.cs:line 7\n   at ChainOfResponsibility.AlarmStoppedHandler.Handle(Message message) in C12\\src\\ChainOfResponsibility\\AlarmStoppedHandler.cs:line 19\n   at ChainOfResponsibility.AlarmPausedHandler.Handle(Message message) in C12\\src\\ChainOfResponsibility\\AlarmPausedHandler.cs:line 19\n   at ChainOfResponsibility.AlarmTriggeredHandler.Handle(Message message) in C12\\src\\ChainOfResponsibility\\AlarmTriggeredHandler.cs:line 19\n   at Program.<>c.<<Main>$>b__0_0(Message message, IMessageHandler messageHandler) in C12\\src\\ChainOfResponsibility\\Program.cs:line 22\n   at lambda_method1(Closure, Object, HttpContext, Object)\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.<>c__DisplayClass100_2.<<HandleRequestBodyAndCompileRequestDelegateForJson>b__2>d.MoveNext()\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)\nHEADERS\n=======\nHost: localhost:10001\nContent-Type: application/json\ntraceparent: 00-5d737fdbb1018d5b7d060b74baf26111-2805f137fe1541af-00\nContent-Length: 77\n```", "```cs\napp.MapPost(\n    \"/handle\",\n    (Message message, IMessageHandler messageHandler) =>\n    {\n        try\n        {\n            messageHandler.Handle(message);\n            return $\"Message '{message.Name}' handled successfully.\";\n        }\n        catch (NotSupportedException ex)\n        {\n            return ex.Message;\n        }\n    });\n```", "```cs\nMessages named 'SomeUnhandledMessageName' are not supported.\n```", "```cs\nnamespace ImprovedChainOfResponsibility; \npublic abstract class MessageHandlerBase : IMessageHandler\n{\n    private readonly IMessageHandler? _next;\n    public MessageHandlerBase(IMessageHandler? next = null)\n    {\n        _next = next;\n    }\n    public void Handle(Message message)\n    {\n        if (CanHandle(message))\n        {\n            Process(message);\n        }\n        else if (HasNext())\n        {\n            _next.Handle(message);\n        }\n    }\n    [MemberNotNullWhen(true, nameof(_next))]\n    private bool HasNext()\n    {\n        return _next != null;\n    }\n    protected virtual bool CanHandle(Message message)\n    {\n        return message.Name == HandledMessageName;\n    }\n    protected abstract string HandledMessageName { get; }\n    protected abstract void Process(Message message);\n}\n```", "```cs\npublic class AlarmTriggeredHandler : MessageHandlerBase\n{\n    protected override string HandledMessageName => \"AlarmTriggered\";\n    public AlarmTriggeredHandler(IMessageHandler? next = null)\n        : base(next) { }\n    protected override void Process(Message message)\n    {\n        // Do something clever with the Payload\n    }\n}\npublic class AlarmPausedHandler : MessageHandlerBase\n{\n    protected override string HandledMessageName => \"AlarmPaused\";\n    public AlarmPausedHandler(IMessageHandler? next = null)\n        : base(next) { }\n    protected override void Process(Message message)\n    {\n        // Do something clever with the Payload\n    }\n}\npublic class AlarmStoppedHandler : MessageHandlerBase\n{\n    protected override string HandledMessageName => \"AlarmStopped\";\n    public AlarmStoppedHandler(IMessageHandler? next = null)\n        : base(next) { }\n    protected override void Process(Message message)\n    {\n        // Do something clever with the Payload\n    }\n}\n```", "```cs\nnamespace FinalChainOfResponsibility;\npublic interface IMessageHandler\n{\n    void Handle(Message message);\n}\npublic abstract class MessageHandlerBase : IMessageHandler\n{\n    private readonly IMessageHandler? _next;\n    public MessageHandlerBase(IMessageHandler? next = null)\n    {\n        _next = next;\n    }\n    public void Handle(Message message)\n    {\n        if (CanHandle(message))\n        {\n            Process(message);\n        }\n        else if (HasNext())\n        {\n            _next.Handle(message);\n        }\n    }\n    [MemberNotNullWhen(true, nameof(_next))]\n    private bool HasNext()\n    {\n        return _next != null;\n    }\n    protected abstract bool CanHandle(Message message);\n    protected abstract void Process(Message message);\n}\n```", "```cs\npublic abstract class SingleMessageHandlerBase : MessageHandlerBase\n{\n    public SingleMessageHandlerBase(IMessageHandler? next = null)\n        : base(next) { }\n    protected override bool CanHandle(Message message)\n    {\n        return message.Name == HandledMessageName;\n    }\n    protected abstract string HandledMessageName { get; }\n}\n```", "```cs\nnamespace FinalChainOfResponsibility;\npublic class AlarmPausedHandler : SingleMessageHandlerBase\n{\n    protected override string HandledMessageName => \"AlarmPaused\";\n    public AlarmPausedHandler(IMessageHandler? next = null)\n        : base(next) { }\n    protected override void Process(Message message)\n    {\n        // Do something clever with the Payload\n    }\n}\npublic class AlarmStoppedHandler : SingleMessageHandlerBase\n{\n    protected override string HandledMessageName => \"AlarmStopped\";\n    public AlarmStoppedHandler(IMessageHandler? next = null)\n        : base(next) { }\n    protected override void Process(Message message)\n    {\n        // Do something clever with the Payload\n    }\n}\npublic class AlarmTriggeredHandler : SingleMessageHandlerBase\n{\n    protected override string HandledMessageName => \"AlarmTriggered\";\n    public AlarmTriggeredHandler(IMessageHandler? next = null)\n        : base(next) { }\n    protected override void Process(Message message)\n    {\n        // Do something clever with the Payload\n    }\n}\n```", "```cs\npublic abstract class MultipleMessageHandlerBase : MessageHandlerBase\n{\n    public MultipleMessageHandlerBase(IMessageHandler? next = null)\n        : base(next) { }\n    protected override bool CanHandle(Message message)\n    {\n        return HandledMessagesName.Contains(message.Name);\n    }\n    protected abstract string[] HandledMessagesName { get; }\n}\n```", "```cs\nnamespace FinalChainOfResponsibility;\npublic class SomeMultiHandler : MultipleMessageHandlerBase\n{\n    public SomeMultiHandler(IMessageHandler? next = null)\n        : base(next) { }\n    protected override string[] HandledMessagesName\n        => new[] { \"Foo\", \"Bar\", \"Baz\" };\n    protected override void Process(Message message)\n    {\n        // Do something clever with the Payload\n    }\n}\n```"]