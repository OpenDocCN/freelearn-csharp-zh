- en: Censored - Various Sensor Data and Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保密 - 各种传感器数据和插件
- en: I hope you'll excuse the cheeky pun in the title. In this chapter, we will discuss
    the various sensors that we can access through the various SDKs provided to us.
    This includes ARKit, Vuforia, ARCore, Swift API, and the Java API. Now, the reason
    we will be going with this route is because there are some things in the core
    APIs that are not exposed in the SDKs provided to Unity but that we can leverage
    using native plugins with wrapper calls in C#. To break this up, to be a little
    more succinct without going outside of the bounds of this book, I will not be
    teaching the syntax of the Java or Swift programming languages; there are already
    some fantastic books that have been written by other Packt authors that cover
    this material, such as *Beginning Swift* ([https://www.packtpub.com/application-development/beginning-swift](https://www.packtpub.com/application-development/beginning-swift))
    and *Java Programming for Beginners (*[https://www.packtpub.com/application-development/java-programming-beginners](https://www.packtpub.com/application-development/java-programming-beginners)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您能原谅标题中的俏皮双关语。在本章中，我们将讨论我们可以通过提供的各种 SDK 访问的各种传感器。这包括 ARKit、Vuforia、ARCore、Swift
    API 和 Java API。现在，我们将采取这条路线的原因是，核心 API 中有一些内容在提供给 Unity 的 SDK 中没有暴露，但我们可以通过使用
    C# 中的包装调用原生插件来利用这些内容。为了简化说明，不超出本书的范围，我将不会教授 Java 或 Swift 编程语言的语法；已经有其他 Packt 作者编写了一些关于这些材料的优秀书籍，例如
    *《Swift 入门》* ([https://www.packtpub.com/application-development/beginning-swift](https://www.packtpub.com/application-development/beginning-swift))
    和 *《Java 编程入门》* ([https://www.packtpub.com/application-development/java-programming-beginners](https://www.packtpub.com/application-development/java-programming-beginners))。
- en: 'This chapter will be broken down into several main sections, as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主要部分，具体如下：
- en: Leveraging sensors with Plugins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用插件利用传感器
- en: Writing Unity Plugins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Unity 插件
- en: C# Language Plugin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 语言插件
- en: C++ Language Plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 语言插件
- en: Swift Language Plugin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 语言插件
- en: Objective-C Language Plugin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C 语言插件
- en: Java Language Plugin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 语言插件
- en: By breaking the chapter down into these distinct sections, we can make it much
    easier for you to find the specific section you want.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些章节划分为不同的部分，我们可以让您更容易找到您想要的特定部分。
- en: Project overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: We will create basic plugins in C#, C++, Swift, Objective-C, and Java. Each
    one will be an implementation of a basic mathematical return value. Writing the
    plugins in their native code should take no more than 10 minutes to complete for
    each native code snippet. You must have a working test in Unity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 C#、C++、Swift、Objective-C 和 Java 创建基本的插件。每个插件都将是一个基本数学返回值的实现。使用原生代码编写插件，每个代码片段的完成时间不应超过
    10 分钟。您必须在 Unity 中有一个可工作的测试。
- en: Getting started
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: When dealing with AR Applications and games, there are bound to be prerequisites,
    and with this book this will be no different.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 AR 应用程序和游戏时，必然会有先决条件，而本书也不例外。
- en: 'The following are the requirements for an Apple Mac computer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 Apple Mac 计算机的要求：
- en: macOS 11
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 11
- en: Xcode 9
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xcode 9
- en: Mono Framework **5.14.0**
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono 框架 **5.14.0**
- en: Unity 2017
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 2017
- en: ARKit
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARKit
- en: It is suggested that you have a 2013 or later model Mac computer, as older versions
    do not support the Metal API for graphics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用 2013 年或更晚的型号的 Mac 计算机，因为旧版本不支持图形的 Metal API。
- en: When you install Unity on a Mac, it will install Visual Studio for Mac as well;
    the catch is it requires Mono Framework to run, so be sure to download and install
    everything.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Mac 上安装 Unity 时，它还会安装 Visual Studio for Mac；但要注意，它需要 Mono 框架才能运行，因此请确保下载并安装所有内容。
- en: 'Here are the requirements for a Windows computer:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Windows 计算机的要求：
- en: Windows 10
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10
- en: 8 GB of RAM or more
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 GB 或更多 RAM
- en: Unity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity
- en: ARCore
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARCore
- en: JDK 8 or higher
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 或更高版本
- en: Visual Studio
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: Android Studio
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio
- en: 'For more information, click on these links:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请点击以下链接：
- en: '[https://store.unity.com/](https://store.unity.com/)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://store.unity.com/](https://store.unity.com/)'
- en: '[https://developer.apple.com/arkit/](https://developer.apple.com/arkit/)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/arkit/](https://developer.apple.com/arkit/)'
- en: '[http://www.mono-project.com/download/stable/#download-mac](http://www.mono-project.com/download/stable/#download-mac)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.mono-project.com/download/stable/#download-mac](http://www.mono-project.com/download/stable/#download-mac)'
- en: '[https://www.visualstudio.com/](https://www.visualstudio.com/)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.visualstudio.com/](https://www.visualstudio.com/)'
- en: '[https://developer.Android.com/studio/](https://developer.android.com/studio/)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.Android.com/studio/](https://developer.android.com/studio/)'
- en: Sensors
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传感器
- en: 'First things first, we need to get a good grasp of what sensors are and what
    they can be used for, before we get into the various mini projects that will coincide
    with each of the SDKs we will be using. This list of sensors is by no means a
    complete list and are some of the most common ones that we can leverage in AR
    applications and games:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对传感器是什么以及它们可以用于什么有一个良好的理解，然后我们才能进入与我们将要使用的每个SDK相关的各种小型项目。这个传感器列表绝对不是完整的列表，而是我们在AR应用和游戏中可以利用的一些最常见的传感器：
- en: Fingerprint Sensor
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指纹传感器
- en: Radiation Sensor
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辐射传感器
- en: Heart Rate Monitor
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 心率监测器
- en: Pedometer
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步数计
- en: Air Humidity Sensor
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气湿度传感器
- en: Thermometer
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度计
- en: Barometer
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气压计
- en: Light Sensor
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光传感器
- en: Proximity Sensor
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离传感器
- en: Magnetometer
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁力计
- en: Gyroscope
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陀螺仪
- en: Accelerometer
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计
- en: Ambient Light Sensor
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境光传感器
- en: Iris Scanner
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 眼睛扫描仪
- en: IR Blaster
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红外遥控发射器
- en: Touch Sensor
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸传感器
- en: Microphone
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦克风
- en: Camera
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像头
- en: GNSS
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全球导航卫星系统（GNSS）
- en: NFC
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近场通信（NFC）
- en: Laser
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光
- en: Air Gesture Sensor
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气手势传感器
- en: Signal Receiver
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号接收器
- en: LiFi
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LiFi
- en: Clock
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟
- en: In this section, we will describe what each of these sensors is and what they
    can be used for, besides their native functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述这些传感器各自是什么，以及除了它们的基本功能外，它们还可以用于什么。
- en: '**Proximity Sensor**: The proximity sensor can detect when the cellphone is
    within a certain range of objects and manipulate software or hardware to react
    in a certain way, once the sensor’s trigger has been tripped. It is generally
    used to reduce the total amount of battery consumption by dimming the backlight
    of the cellphone when it reaches a certain range of the user’s ear or pocket.
    Theoretical usage in AR games and applications requires a little bit of thinking
    outside the box. We know that a proximity sensor can’t detect the difference between
    objects, so what we could do is detect whether there are multiple objects near
    the device and register an event based on that.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**距离传感器**：距离传感器可以检测手机是否在特定范围内，并操纵软件或硬件以某种方式做出反应，一旦传感器被触发。它通常用于在手机达到用户耳朵或口袋的特定范围时降低电池消耗总量。在AR游戏和应用中的理论使用需要一点跳出思维定势。我们知道距离传感器不能检测物体之间的差异，因此我们可以做的是检测设备附近是否有多个物体，并基于此注册事件。'
- en: '**Gyroscope**: The gyroscope is a sensor designed to read and output the direction
    of a cellphone or device with the sensor installed. It is generally used to power
    apps and detect the orientation of the device to determine whether the UI should
    be displayed in landscape or portrait mode. Theoretical usage in AR games and
    applications could be to use the device to act as a compass for traversing the
    game world.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**陀螺仪**：陀螺仪是一种传感器，用于读取和输出安装了传感器的手机或设备的方向。它通常用于为应用程序供电并检测设备的方向，以确定UI是否应以横幅或纵向模式显示。在AR游戏和应用中的理论使用可以是使用设备作为穿越游戏世界的指南针。'
- en: '**Fingerprint scanner sensor**: The fingerprint scanner sensor is a sensor
    designed to detect whether pressure has been added to a special plate and to read
    the input data from the plate.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**指纹扫描传感器**：指纹扫描传感器是一种传感器，用于检测是否对特殊板施加了压力，并从板上读取输入数据。'
- en: It is generally used to add an additional layer of security over a login password.
    It is much more secure and harder to bypass than most standard passwords, even
    with AES encryption with salting.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于在登录密码之上增加一层额外的安全措施。与大多数标准密码相比，它更加安全且难以绕过，即使是在加盐的AES加密下也是如此。
- en: '**Camera**: The camera is itself a sensor. It is able to able to digitize waves
    of light and the electromagnetic radiation emitted so that a device can interpret
    the information and display it in a way that is understandable to the user. It
    is generally used to take pictures to store and retrieve.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**摄像头**：摄像头本身就是一个传感器。它能够将光波和发射的电磁辐射数字化，以便设备可以解释信息并以用户可理解的方式显示。它通常用于拍照存储和检索。'
- en: '**Barometer**: The barometer sensor is designed to detect changes in the atmospheric
    pressure, which in turn means it can effectively act as a means of forecasting
    the weather.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**气压计**：气压计传感器旨在检测大气压力的变化，这反过来意味着它可以有效地作为预测天气的手段。'
- en: It is generally used to determine the weather in the general vicinity where
    the user is located.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常用于确定用户所在的一般地区的天气。
- en: '**Thermometer**: The thermometer sensor is a sensor used to detect changes
    in temperature and store/send that information to be displayed or acted upon.
    It is generally used to keep track of and measure the temperature of sensitive
    components in the device.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**温度计**: 温度计传感器是一种用于检测温度变化并将该信息存储/发送以供显示或处理的传感器。它通常用于跟踪和测量设备中敏感组件的温度。'
- en: '**Accelerometer**: The accelerometer is a sensor designed to detect the momentum
    of the device, and, by extension, detect the momentum of the user. It is generally
    used to determine the speed in which the user is travelling while in possession
    of the device.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**加速度计**: 加速度计是一种用于检测设备动量的传感器，并且通过扩展，可以检测用户的动量。它通常用于确定用户在持有设备时的移动速度。'
- en: '**Pedometer**: The pedometer is a sensor that is designed to take the user’s
    momentum within the confines of human speed limits and convert it into steps walked.
    It is generally used to calculate the user’s daily step count and display it at
    a specific time for the user to review.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**计步器**: 计步器是一种传感器，它设计为将用户的动量转换为步行步数。它通常用于计算用户的每日步数，并在特定时间显示给用户查看。'
- en: '**Touch sensor**: The touch sensor is designed to detect when a user’s finger
    touches the device’s screen and return the position and length of time the finger
    was in that location.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**触摸传感器**: 触摸传感器设计为检测用户的手指何时触摸设备的屏幕，并返回手指在该位置的位置和时间长度。'
- en: It is generally used to activate and manipulate all the basic and advanced usage
    for the device.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常用于激活和操作设备的所有基本和高级用法。
- en: '**Microphone**: The microphone is a sensor designed to detect sound waves and
    convert them into digital information that the device can understand and store.
    It is generally used to pick up the sound waves during a phone call and transmit
    that data to a connected device remotely.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**麦克风**: 麦克风是一种传感器，设计为检测声波并将它们转换为设备可以理解和存储的数字信息。它通常用于在电话通话期间拾取声波并将这些数据传输到远程连接的设备。'
- en: '**Ambient light sensor**: The ambient light sensor is designed to react to
    a variety of light conditions in such a way that it mimics how the human eyes
    would perceive and react to those different light scenarios. It is generally used
    for power saving by adjusting the backlight intensity levels (lighten or darken
    the screen), based on the lighting of the area around the device.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境光传感器**: 环境光传感器设计为能够对各种光照条件做出反应，以模仿人类眼睛对这些不同光照场景的感知和反应。它通常用于通过调整背光亮度级别（使屏幕变亮或变暗）来节省电力，这取决于设备周围的光照。'
- en: '**Iris Scanner sensor**: The iris scanner sensor is designed to create high-resolution
    images of the eye. It is used mainly for security purposes. It is considered a
    form of biometric security, as it will only accept data from a specific eye for
    unlocking the device.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**虹膜扫描传感器**: 虹膜扫描传感器设计为创建眼睛的高分辨率图像。它主要用于安全目的。它被认为是一种生物识别安全形式，因为它只会接受用于解锁设备的特定眼睛的数据。'
- en: '**Air gesture sensor**: The air gesture sensor is able to detect via infrared
    sensors — movements from hands in front of the device’s screen. It is generally
    used to add basic control of the device without needing to use the touch screen,
    for example, activating the screen or applications.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**空气手势传感器**: 空气手势传感器能够通过红外传感器检测设备屏幕前的手势运动。它通常用于在不使用触摸屏的情况下添加对设备的基本控制，例如激活屏幕或应用程序。'
- en: '**Heart rate monitor sensor**: The heart rate monitor sensor is a sensor designed
    to be able to track someone''s heartbeat using a combination of algorithms, green
    LEDs, and the accelerometer to measure blood flow, and store this information.
    It is generally used to accurately measure your heartbeat during exercise.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**心率监测传感器**: 心率监测传感器是一种通过结合算法、绿色LED和加速度计来测量血流量并存储该信息的传感器。它通常用于在运动期间准确测量心率。'
- en: '**Air Humidity Sensor**: The air humidity sensor is a thermal conductivity
    sensor that utilizes aspects of the temperature sensor to be able to detect humidity.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**空气湿度传感器**: 空气湿度传感器是一种热导率传感器，它利用温度传感器的某些方面来检测湿度。'
- en: '**Light sensor**: There are many different types of light sensors that could
    be photoresistors, photodiodes, or even phototransistors. They are designed to
    detect whether there is light in a given area and, if so, how much light is available.
    A light sensor generally works in tandem with the ambient light sensor to give
    accurate light assessment for taking pictures.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**光传感器**: 存在许多不同类型的光传感器，可能是光敏电阻、光电二极管，甚至是光电晶体管。它们被设计用来检测特定区域是否存在光线，以及如果存在，有多少光线可用。光传感器通常与环境光传感器协同工作，以提供准确的拍照光线评估。'
- en: '**Magnetometer**: The magnetometer is a sensor designed for measuring magnetic
    forces. Magnetometers are generally used for treasure-finder apps.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**磁力计**: 磁力计是一种用于测量磁力的传感器。磁力计通常用于寻宝应用。'
- en: '**IR Blaster sensor**: The IR Blaster sensor is a sensor designed to emulate
    an infrared remote control. It is generally used to create a universal remote
    control app for a variety of devices.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**红外遥控发射器传感器**: 红外遥控发射器传感器是一种设计用来模拟红外遥控器的传感器。它通常用于为各种设备创建通用遥控器应用。'
- en: '**GNSS** (**Global Navigation Satellite System**): GNSS is a sensor designed
    to pick up signals from multiple satellites for better accuracy, availability,
    and redundant data collection.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**GNSS**（**全球导航卫星系统**）：GNSS是一种传感器，旨在接收来自多个卫星的信号，以实现更高的精度、可用性和冗余数据收集。'
- en: It is generally used to poll for a user's location in order to give more accurate
    results in a GPS app.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常用于轮询用户的位置，以便在GPS应用中提供更准确的结果。
- en: '**NFC** (**Near-Field Communication**): NFC sensors are designed to be wireless
    data transferers for proximity-based communication. They are generally used for
    using services such as Apple Pay and Apple Wallet payments.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**NFC**（**近场通信**）：NFC传感器被设计为基于近距离通信的无线数据传输器。它们通常用于使用如Apple Pay和Apple Wallet支付等服务。'
- en: '**Signal receiver sensor**: The signal receiver sensor is a sensor designed
    to receive radio waves and convert them into a digital form that the device can
    understand. It is generally used for telephone calls or for playing music from
    the radio.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号接收器传感器**: 信号接收器传感器是一种设计用来接收无线电波并将它们转换为设备可以理解的数字形式的传感器。它通常用于电话通话或从收音机播放音乐。'
- en: '**LiFi sensor**: LiFi sensors, also known as *Light Fidelity Sensors,* use
    **Light-emitting diodes**  (**LEDs**) to transmit data. They are generally used
    for areas that cannot use Wi-Fi, such as power plants, to send and receive data.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**LiFi传感器**: LiFi传感器，也称为*光 fidelity传感器*，使用**发光二极管**（**LEDs**）来传输数据。它们通常用于无法使用Wi-Fi的区域，如发电厂，以发送和接收数据。'
- en: '**Clock**: The **Real-Time Clock** or **RTC** is designed to accurately keep
    track of the time.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**时钟**: **实时时钟**（**RTC**）被设计用来准确跟踪时间。'
- en: It is a clock that shows the exact time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示确切时间的时钟。
- en: Leveraging sensors with plugins
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用插件利用传感器
- en: As previously stated, we can access the information provided by any exposed
    piece of hardware and send that information to our applications and/or games we
    create within Unity. The catch is that if there isn’t an implementation within
    Unity or the SDKs we are using for AR applications, we will need to create a plugin
    with a wrapper to access that sensor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以访问任何暴露的硬件提供的信息，并将这些信息发送到我们在Unity中创建的应用程序和/或游戏中。问题是，如果Unity或我们用于AR应用的SDK中没有实现，我们需要创建一个带有包装器的插件来访问该传感器。
- en: This is also heavily dependent on which devices we want to target and whether
    we want to target both iOS and Android-based devices without any implementations
    done for us. If so, then we need to create the plugin ourselves. We can’t just
    write a plugin in C#, though; we would need native plugins to call upon these
    sensors to do our bidding. This means that we will need to utilize the Java and
    Swift languages for their respective operating systems. For Android, the native-level
    code would be Java or C++, and for iOS, the native-level code would be Swift,
    Objective-C, or C++.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这也高度依赖于我们想要针对哪些设备，以及我们是否想要针对iOS和Android设备而不进行任何实现。如果是这样，那么我们需要自己创建插件。我们不能仅仅用C#编写插件；我们需要本地插件来调用这些传感器以完成我们的任务。这意味着我们需要利用Java和Swift语言为它们各自的操作系统。对于Android，本地级代码将是Java或C++，而对于iOS，本地级代码将是Swift、Objective-C或C++。
- en: It is extremely important that we first understand how the sensor values are
    returned to us from the JDK and Apple SDKs. The JDK breaks all of the sensors
    down into specific categories. The accelerometer, the gyroscope, and the pedometer
    are all in the motion sensors category; the temperature sensor is located within
    the environment sensors category.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 极其重要的是，我们首先了解传感器值是如何从JDK和Apple SDK返回给我们的。JDK将所有传感器分解为特定类别。加速度计、陀螺仪和计步器都属于运动传感器类别；温度传感器位于环境传感器类别中。
- en: There is an imperative distinction to be made between the categories that need
    to be fully understood. The environment sensors category returns a single sensor
    value for each sensor event; meanwhile, the motion sensors category will return
    a multi-dimensional array of each sensor event that occurs. With this tidbit of
    information out of the way, let's move on to the next section, where we will learn
    how to write and dissect basic plugins for Unity in C++, C#, Java, Swift, and
    Objective-C.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确区分需要完全理解的类别。环境传感器类别为每个传感器事件返回单个传感器值；而运动传感器类别将返回每个发生的事件的多维数组。有了这些信息，让我们继续下一部分，我们将学习如何用C++、C#、Java、Swift和Objective-C编写和剖析基本的Unity插件。
- en: Writing unity plugins
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Unity插件
- en: The first thing we need to do is gain an understanding of what a plugin is for
    Unity before we can create and dissect a very simple plugin for Unity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要了解Unity中插件是什么，这样我们才能创建并剖析一个非常简单的Unity插件。
- en: '**What is a plugin?**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是插件？**'
- en: A *plugin* is a dll file that stores code written in a different programming
    language that is a base implementation of some event that needs to be executed
    or in the same language that gives the base implementation of core code that functions
    as a library or non-changeable event.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *插件* 是一个dll文件，它存储了用不同编程语言编写的代码，这是某些需要执行的事件的基础实现，或者是在相同语言中提供核心代码基础实现，这些代码作为库或不可更改的事件。
- en: Now, this is a very simplistic definition, but we can do better by explaining
    what they can do for the developer, or a developer who wants to utilize code you
    have written. Plugins allow a developer to extend existing code without having
    to trudge through the source library by accessing methods and properties that
    are made public to them, which adds new features to the game engine that is not
    natively present, separates operating system-specific code, and they can reduce
    the size of an application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个非常简单的定义，但我们可以通过解释它们能为开发者或想要利用你编写的代码的开发者做什么来做得更好。插件允许开发者通过访问对它们公开的方法和属性来扩展现有代码，而不必通过源库进行艰难的搜索，从而为游戏引擎添加不是原生存在的功能，分离特定操作系统的代码，并且可以减小应用程序的大小。
- en: For Unity specifically, plugins allow us to directly interface with native calls
    and use them as we wish in our application or games. Many developers tend to create
    plugins with native system calls to extend the render pipeline or for enhancing
    shaders.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Unity来说，插件允许我们直接与本地调用进行接口交互，并在我们的应用程序或游戏中按需使用它们。许多开发者倾向于创建使用本地系统调用的插件来扩展渲染管线或增强着色器。
- en: It is important to note that there are two very distinct plugin types available
    to use in Unity. Those two types are **Native Plugins** and **Managed Plugins**.
    A very simplified explanation of the difference between native and managed plugins
    is that native plugins are for low-level calls, and managed plugins are an easy
    way to hide source code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在Unity中有两种非常不同的插件类型可供使用。这两种类型是**本地插件**和**托管插件**。对本地插件和托管插件之间差异的非常简化的解释是，本地插件用于低级调用，而托管插件是隐藏源代码的一种简单方法。
- en: There is, however, a more nuanced differentiation between them than this old
    adage.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们之间的区别比这个古老的谚语要微妙得多。
- en: A managed plugin can and will easily hide source code from prying eyes when
    a developer wants to sell something in the asset store. It can also be used to
    include libraries and frameworks that are not otherwise readily available to Unity.
    For example, a developer could import the Entity Framework dll files into Unity
    and utilize the Entity Framework to create, manage, and handle database code with
    Unity. The final thing that a managed plugin can do is allow a developer to utilize
    some .NET languages and compilers that are not supported by Unity, such as F#,
    JScript, IronPython, ClosureCLR, or even Powershell. For example, a developer
    could create a plugin for Unity that allows for scripting in IronPython, or they
    could write game code using IronPython and import it as a plugin and use it without
    issues.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 管理插件可以在开发者想在资产商店出售东西时轻松隐藏源代码。它还可以用于包含其他情况下无法轻易获得的库和框架。例如，开发者可以将 Entity Framework
    dll 文件导入 Unity，并利用 Entity Framework 在 Unity 中创建、管理和处理数据库代码。管理插件还能做的最后一件事是允许开发者利用
    Unity 不支持的某些 .NET 语言和编译器，例如 F#、JScript、IronPython、ClosureCLR 或甚至 Powershell。例如，开发者可以为
    Unity 创建一个插件，允许使用 IronPython 进行脚本编写，或者他们可以使用 IronPython 编写游戏代码，将其作为插件导入并使用而不会出现问题。
- en: A native plugin, on the other hand, is profoundly more powerful. A native plugin
    normally consists of using Java, Swift, Objective-C, or C++ to access the direct
    hardware of their respective devices and provide functionality that a developer
    could otherwise not have access to within Unity. Let’s say a developer is working
    with a device that connects to a smartphone that is not normally present in smartphones;
    in this case, we will go with the **BACtrack Mobile Pro** as our example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，本地插件的功能强大得多。本地插件通常由使用 Java、Swift、Objective-C 或 C++ 访问各自设备的直接硬件，并提供开发者在其他情况下无法在
    Unity 中访问的功能。假设一个开发者正在与一个连接到智能手机的设备合作，而这个设备通常不在智能手机中；在这种情况下，我们将以 **BACtrack Mobile
    Pro** 作为我们的例子。
- en: The BACtrack Mobile pro is a police-grade breathalyzer that can check a user’s
    blood alcohol content and send that information to a device via Bluetooth connections.
    This developer wants to make a drinking-style AR game, and they want to make the
    game harder, the higher the end user’s BAC level is. This developer would need
    to use a native plugin to gain access to the BACtrack device’s sensors' results.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: BACtrack Mobile pro 是一款警用级别的酒精测试仪，可以检测用户的血液酒精含量，并通过蓝牙连接将信息发送到设备。这位开发者想制作一款饮酒风格的
    AR 游戏，并希望游戏难度随着最终用户血液酒精含量（BAC）水平的升高而增加。这位开发者需要使用本地插件来访问 BACtrack 设备传感器的结果。
- en: Now that a firm understanding should have been gained from this explanation,
    we can finally start looking at the structure of a plugin for C++, Swift, C#,
    and Java. What we will do is create a very simple plugin that will simply add
    two numbers together. This is to keep things simple and allow for the flow of
    steps for the overall workflow to be much more easy to follow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该已经从这一解释中获得了牢固的理解，我们最终可以开始查看 C++、Swift、C# 和 Java 插件的结构。我们将创建一个非常简单的插件，该插件将简单地相加两个数字。这是为了保持简单，并使整体工作流程的步骤更容易遵循。
- en: 'There is a list of file types that Unity will automatically recognize as plugins.
    It is very important that we familiarize ourselves with these file formats:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 会自动识别一系列文件类型作为插件。我们熟悉这些文件格式非常重要：
- en: '`.dll`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dll`'
- en: '`.winmd`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.winmd`'
- en: '`.so`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.so`'
- en: '`.JAR`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.JAR`'
- en: '`.aar`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.aar`'
- en: '`.xex`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xex`'
- en: '`.def`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.def`'
- en: '`.suprx`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.suprx`'
- en: '`.prx`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.prx`'
- en: '`.sprx`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sprx`'
- en: '`.rpl`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rpl`'
- en: '`.cpp`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cpp`'
- en: '`.cc`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cc`'
- en: '`.c`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.c`'
- en: '`.h`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.h`'
- en: '`.jslib`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.jslib`'
- en: '`.jspre`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.jspre`'
- en: '`.bc`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bc`'
- en: '`.a`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.a`'
- en: '`.m`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.m`'
- en: '`.mm`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mm`'
- en: '`.swift`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.swift`'
- en: '`.xib`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xib`'
- en: 'Then there are also folder types that are treated as single plugins; they are
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些文件夹类型被视为单个插件；它们如下所示：
- en: '`.framework`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.framework`'
- en: '`.bundle`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bundle`'
- en: '`` `.plugin` ``'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `.plugin` ``'
- en: With native plugins for Unity, you can run into C linkage issues that will cause
    a phenomenon called **Name Mangling**. Name mangling is also called *name decoration,*
    which is essentially a process that gives each function in a program a unique
    name; this is so that the linkers can separate common names in the language. The
    issue comes from the fact that there is no standard for this, and they typically
    don’t work well with C compilers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Unity 的本地插件时，可能会遇到导致称为 **名称混淆** 的现象的链接问题。名称混淆也称为 *名称装饰*，它本质上是一个为程序中的每个函数赋予唯一名称的过程；这样，链接器就可以区分语言中的常见名称。问题在于没有标准，它们通常与
    C 编译器不兼容。
- en: C# language plugin
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 语言插件
- en: 'Let’s get started by creating our first plugin with C#:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始用 C# 创建我们的第一个插件：
- en: 'We need to begin by opening Visual Studio and creating a new project. This
    new project type will be inside the Windows Desktop subfolder of Visual C# and
    will need to be a Class Library (.NET Framework):'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要首先打开 Visual Studio 并创建一个新的项目。这个新项目类型将位于 Visual C# 的 Windows Desktop 子文件夹中，并且需要是一个类库
    (.NET Framework)：
- en: '![](img/3d0e6c5b-eeb5-4b97-90f3-0c1d4d3188f5.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d0e6c5b-eeb5-4b97-90f3-0c1d4d3188f5.png)'
- en: Project type
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 项目类型
- en: 'The project name will be `CSharpManagedPlugin`, and the Framework version will
    be `.NET Framework 3.5`. Select the OK button:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目名称将是 `CSharpManagedPlugin`，框架版本将是 `.NET Framework 3.5`。选择 OK 按钮：
- en: '![](img/e8779b8f-379e-45ae-ba88-5d9b4cbb622f.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8779b8f-379e-45ae-ba88-5d9b4cbb622f.png)'
- en: Project setup
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置
- en: Making sure to change the Framework version to 3.5 is extremely important, as
    we need to make sure that Unity can utilize our plugin without experimental support.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将框架版本更改为 3.5 非常重要，因为我们需要确保 Unity 可以利用我们的插件而不需要实验性支持。
- en: 'Now that we have created our solution, we can change the class name from `Class1`
    to `Addition`. Now, add an integer method called `addify` with the parameters
    of `a` and `b`, and then return `a` plus `b`. Your code should look as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的解决方案，我们可以将类名从 `Class1` 改为 `Addition`。现在，添加一个名为 `addify` 的整数方法，参数为
    `a` 和 `b`，然后返回 `a` 加 `b`。你的代码应该如下所示：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now build the solution that will generate the dll file we need. We can
    now open Unity and see how we can utilize this plugin with Unity:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建解决方案，这将生成我们需要的 dll 文件。现在我们可以打开 Unity，看看我们如何使用这个插件：
- en: 'Load Unity, and let’s begin by creating a new project. The project will be
    of type 3D, and the name I will give it is `Packtpub`. I will start by creating
    two folders; the first one will be called `Plugins`*,* and the other will be called
    `PluginWrappers`. This will allow us to keep our project organized:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 Unity，让我们首先创建一个新的项目。项目类型将是 3D，我将给它命名为 `Packtpub`。我将首先创建两个文件夹；第一个将命名为 `Plugins`，另一个将命名为
    `PluginWrappers`。这将使我们能够保持项目整洁：
- en: '![](img/8392a826-8df7-46e9-9a41-b37f86176cf1.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8392a826-8df7-46e9-9a41-b37f86176cf1.png)'
- en: Project setup
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'We will start by taking the C# dll file we created and dragging it into the
    `Plugins` folder. I named my dll file `CSharpManagedPlugin` to make it a bit easier
    to differentiate between the different plugins we have at the end:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将我们创建的 C# dll 文件拖放到 `Plugins` 文件夹中。我将我的 dll 文件命名为 `CSharpManagedPlugin`，以便在最后区分我们拥有的不同插件：
- en: '![](img/43972a9a-fd7a-4f2e-9601-37de0e59e1cd.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43972a9a-fd7a-4f2e-9601-37de0e59e1cd.png)'
- en: Plugin added
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 插件已添加
- en: 'If you click on the `CSharpManagedPlugin`, in the inspector, you will see more
    information:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击 `CSharpManagedPlugin`，在检查器中，你会看到更多信息：
- en: '![](img/36356fdf-ce23-4dcd-870d-53efdbaaef10.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36356fdf-ce23-4dcd-870d-53efdbaaef10.png)'
- en: Inspector
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器
- en: As long as the target version of .NET is the same or lower than that of Unity,
    you should receive no errors and should be able to use it in the editor, standalone,
    in WebGL, Linux, Windows, and Mac OS.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要目标 .NET 版本与 Unity 的相同或更低，你就不会收到错误，并且应该能够在编辑器、独立应用、WebGL、Linux、Windows 和 Mac
    OS 中使用它。
- en: What we can do now is move over to our `PluginWrappers` folder and get this
    bad boy up and running.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以转到我们的 `PluginWrappers` 文件夹，并让这个家伙运行起来。
- en: 'Create a new script; mine will be called `CSharpWrapper`. We can now open the
    script in Visual Studio:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本；我的脚本将命名为 `CSharpWrapper`。现在我们可以用 Visual Studio 打开这个脚本：
- en: '![](img/ee6e760c-e9ac-4fa7-a322-314c89947dd0.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee6e760c-e9ac-4fa7-a322-314c89947dd0.png)'
- en: Script
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本
- en: 'Managed plugins are the easiest, and all we need to do is call our plugin directly,
    just as if it were a non-monobehavior script. Your code should look as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理插件是最简单的，我们只需要直接调用我们的插件，就像它是一个非 Monobehavior 脚本一样。你的代码应该如下所示：
- en: '[PRE1]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we called our plugin as if it were just another namespace in
    the assembly. We can now attach this Unity class to a GameObject, and we will
    see the results of step 7 appear in the console window of the Unity Editor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们像调用程序集中的另一个命名空间一样调用我们的插件。现在我们可以将这个 Unity 类附加到一个 GameObject 上，我们将在 Unity
    编辑器的控制台中看到第 7 步的结果。
- en: C++ language plugin
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 语言插件
- en: 'Moving on to C++, we will use Visual Studio once more to create this project:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Visual Studio 再次创建这个项目：
- en: 'This project type will be in Visual C++ | Windows Desktop | Dynamic-Link Library
    (DLL):'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目类型将在 Visual C++ | Windows Desktop | 动态链接库 (DLL)：
- en: '![](img/3e4de19e-d199-4a64-98b3-b6a522ea0c5b.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e4de19e-d199-4a64-98b3-b6a522ea0c5b.png)'
- en: The name of this project will be `NativeWindowsPlugin`, and C++ will be slightly
    different than the managed plugins, due to name mangling, which we will learn
    how to avoid next.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目的名称将是`NativeWindowsPlugin`，由于名称修饰，C++将与托管插件略有不同，我们将在下一部分学习如何避免这种情况。
- en: 'So, to get around this problem of name mangling, we need to create a header
    and cpp file. Take a look at this code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了解决名称修饰的问题，我们需要创建一个头文件和cpp文件。看看这段代码：
- en: '[PRE2]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Essentially, what is happening when we use the `__declspec, dllexport` call
    is that we are avoiding the usage of a `.def` file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，当我们使用`__declspec, dllexport`调用时，我们是在避免使用`.def`文件。
- en: Now that our header has been created, we need to fill out the information in
    our cpp file.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了头文件，我们需要填写cpp文件中的信息。
- en: 'Make sure to include the header for the native windows plugin, and fill out
    the function details of `addify` here. Your code should look as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保包含本地Windows插件的头文件，并填写`addify`函数的详细信息。你的代码应该如下所示：
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Click on Build Solution*,* and we will be ready to jump into Unity.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建解决方案**，我们将准备好跳入Unity。
- en: 'Load Unity, and let’s open our `Packtpub` project:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 加载Unity，然后打开我们的`Packtpub`项目：
- en: 'Like we did previously, we will be using our `Plugins` and `PluginWrappers`
    folders for keeping things organized. Copy the `CPlusPlusPlugin` into the `Plugins`
    folder:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们将使用我们的`Plugins`和`PluginWrappers`文件夹来保持事物有序。将`CPlusPlusPlugin`复制到`Plugins`文件夹中：
- en: '![](img/42a685f6-75bd-4e2c-b74b-b37048bfb1d1.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42a685f6-75bd-4e2c-b74b-b37048bfb1d1.png)'
- en: Folder structure
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: If you take a look at the plugin in the inspector, you will notice that it is
    only available for Windows. That is because we only had our if directive set for
    Windows and no other operating system. This is something you should keep in mind
    when wanting to work with multiple operating systems with C++.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看检查器中的插件，你会注意到它仅适用于Windows。这是因为我们只设置了if指令针对Windows，没有其他操作系统。当你想用C++在多个操作系统上工作时应记住这一点。
- en: 'Now, we can create a new C# class in the `PluginWrappers` folder called `CPlusPlusWrapper`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`PluginWrappers`文件夹中创建一个新的C#类，名为`CPlusPlusWrapper`：
- en: '![](img/4983c9bb-ad1a-4789-996d-58249dba21e5.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4983c9bb-ad1a-4789-996d-58249dba21e5.png)'
- en: CPlusPlusWrapper
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: CPlusPlusWrapper
- en: The code here will be different than what we used for the native plugin. We
    will need to import the dll file using a very special attribute called `DllImport`.
    This attribute requires the string name of the plugin we used and then underneath
    the attribute, we need to make sure it is a **Public Static Extern Method**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的代码将与我们用于本地插件的代码不同。我们需要使用一个称为`DllImport`的非常特殊的属性来导入dll文件。这个属性需要我们使用的插件的字符串名称，然后在属性下面，我们需要确保它是一个**公共静态外部方法**。
- en: 'Public static extern method types designate that the method call we want to
    use will be static, public, and loaded from an external assembly. To use the DLL
    Import attribute, we need to use the System.Runtime.InteropServices namespace.
    Your code should look as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共静态外部方法类型指定了我们想要使用的方法调用将是静态的、公共的，并且从外部程序集加载。要使用DLL导入属性，我们需要使用System.Runtime.InteropServices命名空间。你的代码应该如下所示：
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After we do that, the call is essentially the same from there on out. It is
    a little bit different, and a little more involved, but, overall, it is very easy
    once you understand how it works. You can now attach this C# script to a GameObject
    and run it to test the results.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，后续的调用基本上是相同的。它有点不同，也稍微复杂一些，但一旦你理解了它是如何工作的，总体来说是非常简单的。你现在可以将这个C#脚本附加到一个GameObject上并运行它来测试结果。
- en: Swift language plugin
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift语言插件
- en: '**Swift Language Plugins** have the extension of .swift and have a completely
    different structure than C#, Java, and C++, which is to be expected, as Swift
    is only available on macOS devices. The language itself has elements from a variety
    of sources, and while I will not go into greater details of the finer points of
    the language, I will say that I like the methodologies they incorporated into
    the language structure.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift语言插件**的扩展名为.swift，与C#、Java和C++的结构完全不同，这是可以预料的，因为Swift仅在macOS设备上可用。这种语言本身融合了多种来源的元素，虽然我不会深入探讨语言的细微之处，但我可以说我喜欢他们融入语言结构中的方法。'
- en: Swift and Objective-C require the usage of Xcode, and while the basic setup
    is very similar, there are some key differences. Swift plugins require you to
    utilize both Objective-C and Swift to create a plugin that boils down to the implementation
    in Swift and you call that Swift code in Objective-C. This exceeds the parameters
    of this section, as the nuances of both languages need to be explored further.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 和 Objective-C 需要使用 Xcode，尽管基本设置非常相似，但也有一些关键区别。Swift 插件要求你同时使用 Objective-C
    和 Swift 来创建一个插件，该插件最终归结为 Swift 的实现，并在 Objective-C 中调用这些 Swift 代码。这超出了本节的内容，因为两种语言的细微差别需要进一步探索。
- en: Objective-C language plugin
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C 语言插件
- en: 'Objective-C plugins are similar in some ways to Swift plugins and many of the
    basic steps are the same. Objective-C has been around for quite a long time and
    was Apple''s version of the C language family. While Swift has been designed to
    be Objective-C''s successor, Apple has not depreciated the language and is still
    a powerful tool to use and know:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 插件在某些方面与 Swift 插件相似，许多基本步骤都是相同的。Objective-C 已经存在很长时间了，它是苹果的 C 语言家族版本。虽然
    Swift 被设计成 Objective-C 的继任者，但苹果并没有废弃这种语言，它仍然是一个强大且值得使用和了解的工具：
- en: 'To start, open Xcode, and get ready to have some fun:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 Xcode，准备享受乐趣：
- en: '![](img/02cf291a-2b58-4b98-b851-abbf323b0d58.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02cf291a-2b58-4b98-b851-abbf323b0d58.png)'
- en: Click on Create a new Xcode project and we'll have a big list of items to choose
    from.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建一个新的 Xcode 项目”，我们将有一个长长的项目列表可供选择。
- en: Go over to macOS and select Library.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 macOS 并选择库。
- en: Although the Library is not available with iOS projects, you can also go with
    Bundle or Cocoa Framework Library types as well for this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然库在 iOS 项目中不可用，但你也可以选择使用 Bundle 或 Cocoa 框架库类型。
- en: 'Select Library and click Next:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择库并点击下一步：
- en: '![](img/cdfc05e8-8ae9-422f-bed8-e43e2bb8fe4e.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cdfc05e8-8ae9-422f-bed8-e43e2bb8fe4e.png)'
- en: 'Set the product name to `ObjectiveCPlugin`; this keeps us in line with how
    the projects have been developed thus far:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将产品名称设置为 `ObjectiveCPlugin`；这使我们保持与迄今为止项目开发的方式一致：
- en: '![](img/f9bf4e6a-1cc1-4df3-898d-cc0a7d5c57a2.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9bf4e6a-1cc1-4df3-898d-cc0a7d5c57a2.png)'
- en: 'Now, before we continue, let''s look at the various Frameworks that are available
    for us in the drop-down menu:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们继续之前，让我们看看下拉菜单中可用的各种框架：
- en: '![](img/8629d8ad-3026-4712-a912-90dff864ff40.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8629d8ad-3026-4712-a912-90dff864ff40.png)'
- en: We have Cocoa, STL, and None. Cocoa gives us what we need for Objective C and
    Swift, **STL** is the **Standard Template Library** for C++, and None is a blank
    C++ and C project, with no Standard Libraries attached to it. We will stick with
    Cocoa.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 Cocoa、STL 和 None。Cocoa 为我们提供了 Objective C 和 Swift 所需的一切，**STL** 是 C++ 的
    **标准模板库**，而 None 是一个不带标准库的空白 C++ 和 C 项目。我们将坚持使用 Cocoa。
- en: 'Next, we should take a look at what is available to us with Type:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该看看类型选项中有什么可用：
- en: '![](img/819fa5cb-25f7-42a4-b1f2-3df4cf0d13ff.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/819fa5cb-25f7-42a4-b1f2-3df4cf0d13ff.png)'
- en: 'Type gives us the choice between Dynamic and Static, which would be a **Dynamic
    Library** or a **Static Library**. A static library is a library that is resolved
    at compile time and copied into a target application that produces an object file
    and an executable. A dynamic library is the opposite. It is resolved at runtime
    and only produces the header and source file that can be called in another application
    or program. We will stick with dynamic here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供了动态和静态的选择，这将是一个 **动态库** 或 **静态库**。静态库是一个在编译时解析并复制到目标应用程序中的库，该应用程序生成一个目标文件和一个可执行文件。动态库则相反。它在运行时解析，只生成可以在其他应用程序或程序中调用的头文件和源文件。我们将坚持使用动态库。
- en: '![](img/658e962e-05f8-46be-abc2-dd556684fd2e.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/658e962e-05f8-46be-abc2-dd556684fd2e.png)'
- en: 'Our base Library file has a `.h` and `.m` file already created for us, so all
    we have to do is fill in the code that is needed. Let''s go ahead and fill in
    the header file. Look at this code:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的库基础文件已经为我们创建了一个 `.h` 和 `.m` 文件，所以我们只需填写所需的代码。让我们先填写头文件。看看这段代码：
- en: '[PRE5]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Right away, we can see that it looks very similar to C++, with the slight difference
    of syntax. Next up, let''s take a look at the `.m` file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立刻，我们可以看到它与 C++ 非常相似，只是语法略有不同。接下来，让我们看看 `.m` 文件：
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And, again, it''s pretty much the same as C++, where we just fill in what the
    method actually does. We can now build the project and get ready to import it
    into Unity:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，它与 C++ 几乎相同，我们只需填写方法实际执行的内容。现在我们可以构建项目，并准备好将其导入到 Unity 中：
- en: '![](img/6f427f6e-f87c-4f8b-863a-c1b534d2e344.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f427f6e-f87c-4f8b-863a-c1b534d2e344.png)'
- en: 'Now, we can open Unity after the project has been built and get ready for the
    fun part. Inside the `Plugins` folder that we previously created, create a new
    folder called `iOS`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在项目构建完成后，我们可以打开Unity并准备好进入有趣的部分。在之前创建的`Plugins`文件夹中，创建一个名为`iOS`的新文件夹：
- en: '![](img/48f0b748-900e-4ff9-a52e-d363d170ff1f.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48f0b748-900e-4ff9-a52e-d363d170ff1f.png)'
- en: 'Inside the `iOS` folder, copy the `.h` and `.m` files that were created:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`iOS`文件夹中，复制创建的`.h`和`.m`文件：
- en: '![](img/4855414b-c518-409b-9d80-ceccecf3b430.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4855414b-c518-409b-9d80-ceccecf3b430.png)'
- en: 'Now, go over to the `PluginWrappers` folder and create a new script called
    `ObjectiveCWrapper`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到`PluginWrappers`文件夹并创建一个名为`ObjectiveCWrapper`的新脚本：
- en: '![](img/fb37579b-135c-4c58-9cad-1bd1b4e5a0c3.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb37579b-135c-4c58-9cad-1bd1b4e5a0c3.png)'
- en: 'We can now open the class in C# and add our code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在C#中打开类并添加我们的代码：
- en: '[PRE7]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The nice thing about Objective-C is that it does not have the name mangling
    issues that C++ has, so we don't need to worry about doing the `extern` method
    before. Instead, due to the way code is compiled for iOS devices, we have to call
    `__internal`, instead of the name of the plugin.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C的好处是它没有C++那样的名称混淆问题，所以我们不需要担心在之前做`extern`方法。相反，由于iOS设备编译代码的方式，我们必须调用`__internal`，而不是插件的名称。
- en: To finish, we would have to build this for iOS and open it in Xcode to finish
    the compile process and either run it on an iPhone or the iPhone Simulator to
    test the results.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为iOS构建这个项目并在Xcode中打开它来完成编译过程，然后在iPhone或iPhone模拟器上运行以测试结果。
- en: Java language plugin
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语言插件
- en: For the Java language plugin, we have two choices that work just fine. We have
    the Java Library, which compiles to a JAR file, and the Android Library, which
    compiles to AAR format. To access Android-specific functions, we need to create
    the Android Library, and for pure Java language usage, we would create the Java
    library.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java语言插件，我们有两种选择都可以正常工作。我们有Java库，它编译成JAR文件，还有Android库，它编译成AAR格式。要访问Android特定的功能，我们需要创建Android库，而对于纯Java语言的使用，我们会创建Java库。
- en: 'There is a major distinction between the two, and this should be discussed.
    Consider the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间有一个主要区别，这一点应该被讨论。考虑以下内容：
- en: Android Library projects contain native and Java code along with resource files
    and an Android Manifest. They will include the `.class` files and `.jar` files
    that need to be precompiled into the Android Studio project, before being imported
    into Unity.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android库项目包含本地和Java代码以及资源文件和AndroidManifest。它们将包括需要预编译到Android Studio项目中的`.class`文件和`.jar`文件，然后导入到Unity中。
- en: Java Library projects are built directly to be JAR files, and they can be imported
    into Unity.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java库项目直接构建为JAR文件，并且可以导入到Unity中。
- en: Both of these plugins need to be run on an Android device; this means you cannot
    test them in the editor; you must build and run on an emulator or on an actual
    device. If you want to get the best from plugins, using the Java Language. Android
    Library projects offer the most bang for your buck.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个插件都需要在Android设备上运行；这意味着你无法在编辑器中测试它们；你必须构建并在模拟器或实际设备上运行。如果你想从插件中获得最佳效果，使用Java语言。Android库项目提供了最大的性价比。
- en: 'With that being said, let’s open Android Studio and create our basic library:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们打开Android Studio并创建我们的基本库：
- en: 'Click on File, highlight New, and locate New Module. The Module options window
    will open in a new window:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件，高亮显示新建，并定位到新建模块。模块选项窗口将在新窗口中打开：
- en: '![](img/03dda026-b9fa-43d8-b119-3674436d52b6.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03dda026-b9fa-43d8-b119-3674436d52b6.png)'
- en: Android Studio
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio
- en: 'Here, we have the option of selecting a Java Library or Android Library. As
    discussed previously, it is much more advantageous to use the Android Library,
    so select that one and click Next:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们有选择Java库或Android库的选项。正如之前讨论的那样，使用Android库更有优势，所以选择它并点击下一步：
- en: '![](img/96588a2f-a48a-44b1-b671-aca0e05ea9c3.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96588a2f-a48a-44b1-b671-aca0e05ea9c3.png)'
- en: Library choices
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 库选择
- en: Now, we can name and configure our module. I will set the library name to be
    `AndroidLibrary`; the module name will automatically be made to be the name of
    the library in lowercase.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以命名和配置我们的模块。我将设置库名为`AndroidLibrary`；模块名将自动设置为库的小写名称。
- en: 'The package name will be changed to `com.packtpub.Androidlibrary`, and the
    Minimum SDK version will be `API 21: Android 5.0 (Lolipop)`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '包名将更改为`com.packtpub.Androidlibrary`，最小SDK版本为`API 21: Android 5.0 (Lollipop)`：'
- en: '![](img/9c04678d-5647-4b02-870c-a00d50d17d11.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c04678d-5647-4b02-870c-a00d50d17d11.png)'
- en: Module setup
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 模块设置
- en: Once that has been set up, click Finish.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置好，点击“完成”。
- en: 'On the left-hand side of the Android Studio Editor, we can see the layout of
    the project:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio编辑器的左侧，我们可以看到项目的布局：
- en: '![](img/fe0571f2-5362-4b6d-bfd4-b15ef6710f20.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe0571f2-5362-4b6d-bfd4-b15ef6710f20.png)'
- en: Layout
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 布局
- en: 'The main area we want to focus on is the `java` folder with the name of `com.packtpub.Androidlibrary`.
    We need to right-click on this specific one and add a new Java class to it. This
    will open a brand-new window to set up the class:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要关注的主要区域是名为`com.packtpub.Androidlibrary`的`java`文件夹。我们需要右键单击这个特定的文件夹，并向其中添加一个新的Java类。这将打开一个全新的窗口来设置类：
- en: '![](img/a388bc86-6e29-444e-b764-b0e52068f1c1.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a388bc86-6e29-444e-b764-b0e52068f1c1.png)'
- en: New class
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 新类
- en: I will name the class `Additions` to specify that we are just making a simple
    math library and then select the OK button.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将把类命名为`Additions`以指定我们只是创建一个简单的数学库，然后选择“确定”按钮。
- en: 'The procedure is the same for C#: we will just add a public `int` with the
    name of `AddMe` with the parameters of `int a` and `int b`, with the return being
    `a + b`. Your code should look as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于C#，过程是相同的：我们只需添加一个名为`AddMe`的公共`int`，参数为`int a`和`int b`，返回值为`a + b`。你的代码应该如下所示：
- en: '[PRE9]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Click on the Build button at the top of the editor window, and click on Make
    Project. This will build the project for us.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击编辑器窗口顶部的“构建”按钮，然后点击“构建项目”。这将为我们构建项目。
- en: 'Let’s take a quick look at the output folder of the project:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速查看一下项目的输出文件夹：
- en: '![](img/51ffa1e3-1328-44f0-bd68-eecfac0893a8.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51ffa1e3-1328-44f0-bd68-eecfac0893a8.png)'
- en: Building the project folder
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目文件夹
- en: We can see here that we have quite a few folders and other miscellaneous files.
    The AAR file we need is located in the `AndroidLibrary` folder. The exact location
    would be Android library, Build, Outputs, AAR.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里有很多文件夹和其他杂项文件。我们需要的AAR文件位于`AndroidLibrary`文件夹中。确切的位置是Android library，Build，Outputs，AAR。
- en: The AAR file is technically a zip file, so you can unzip and look at its contents
    by using "7zip"; however, this is the exact file we need to use in Unity. Now,
    it is time to open Unity and see how we can get Unity to interact with this file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: AAR文件在技术上是一个zip文件，因此你可以使用“7zip”解压并查看其内容；然而，这正是我们在Unity中需要使用的文件。现在，是时候打开Unity，看看我们如何让Unity与这个文件交互了。
- en: 'Load up Unity, and let’s open our `Packtpub` project:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Unity，并打开我们的`Packtpub`项目：
- en: 'Like we did previously, we will be using our `Plugins` and `PluginWrappers`
    folders for keeping things organized. Copy the AAR file into the `Plugins` folder:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们将使用我们的`Plugins`和`PluginWrappers`文件夹来保持组织有序。将AAR文件复制到`Plugins`文件夹：
- en: '![](img/ea9c9eb2-8d3c-41f2-8db2-2e896f677935.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea9c9eb2-8d3c-41f2-8db2-2e896f677935.png)'
- en: Plugins folder
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 插件文件夹
- en: In the `PluginWrappers` folder, create a C# class called `JavaWrapper`, and
    then open it in Visual Studio.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PluginWrappers`文件夹中，创建一个名为`JavaWrapper`的C#类，然后在Visual Studio中打开它。
- en: The code is slightly different than the C# and other native implementations.
    We will need a preprocessor directive to check whether this code is being executed
    in Android.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码与C#和其他本地实现略有不同。我们需要一个预处理指令来检查此代码是否在Android上执行。
- en: Then, we will create a new Android Java Object with the string name of the class
    we created in Java.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的Android Java对象，其字符串名称为我们创建的Java类中的字符串名称。
- en: 'We will follow that up with a call of that class with the string value of the
    method we want, followed by the parameters. Your code should look as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用该类，使用我们想要的方法的字符串值，然后是参数。你的代码应该如下所示：
- en: '[PRE10]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we can’t test this code in the Unity Editor, but we can build the project
    out and test it on an Android device, after attaching it to a game object to run.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们无法在Unity编辑器中测试这段代码，但我们可以构建项目并在连接到游戏对象后，在Android设备上测试它。
- en: Creating a sensor driver in Java
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中创建传感器驱动程序
- en: Now, what if we wanted to implement our own sensor from the hardware provided?
    As it turns out, Google has already thought of that and has a very in-depth tutorial
    on creating and registering your own driver which can be viewed at [https://developer.Android.com/things/sdk/drivers/location](https://developer.android.com/things/sdk/drivers/location).
    I will go over a few of the items specified, but it is best to read what they
    wrote.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想从提供的硬件中实现自己的传感器呢？实际上，谷歌已经想到了这一点，并有一个非常深入的教程，关于创建和注册自己的驱动程序，可以在[https://developer.Android.com/things/sdk/drivers/location](https://developer.android.com/things/sdk/drivers/location)查看。我将简要介绍其中的一些项目，但最好阅读他们所写的内容。
- en: 'In short, we will just look at the sample code provided that will make it so
    that we can convert GPS data as a plugin. The basic structure is exactly the same
    as the one we used to create our basic plugin in Java. The next step will be to
    write our code so that it returns the data so that it can be passed from the native
    plugin to Unity. Take a look at this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们只需查看提供的示例代码，这样我们就可以将其作为插件转换 GPS 数据。其基本结构与我们在 Java 中创建基本插件时使用的结构完全相同。下一步将是编写我们的代码，以便它返回数据，这样它就可以从本地插件传递到
    Unity。看看这个：
- en: '[PRE11]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, all you need to do is compile the plugin as specified in the previous section
    and add it to Unity in exactly the same way.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要做的就是按照上一节中指定的方式编译插件，并将其以完全相同的方式添加到 Unity 中。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed various sensors that are generally available
    to us from mobile market devices. We have discussed how to create a basic plugin
    in the major languages for the different platforms at our disposal, and we now
    have all of the basic knowledge we need to get started making AR applications
    and games with Unity.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了通常可以从移动市场设备中获得的各种传感器。我们讨论了如何为不同平台创建基本插件的主要语言，我们现在拥有开始使用 Unity 制作 AR
    应用程序和游戏所需的所有基本知识。
- en: In the next chapter, we will take what we have learned so far and create a prototype
    project that will allow us to incorporate sound as the basis for an AR application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们学到的东西应用到创建一个原型项目中，这个项目将使我们能够将声音作为 AR 应用程序的基础。
- en: Have a go hero
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下，英雄
- en: Before continuing to the next chapter, I would suggest taking the time to read
    some of the references I have provided in the further reading section that will
    give you insights on how to access various sensors for Android and Apple devices.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一章之前，我建议花时间阅读我在进一步阅读部分提供的参考资料，这些资料将为你提供有关如何访问 Android 和 Apple 设备上各种传感器的见解。
- en: 'This will be extremely instrumental in you being able to solve the coding challenges
    presented in the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这将极大地帮助你解决以下提出的编码挑战：
- en: Create a simple C++ plugin that works with Linux, Windows, and Mac desktop environments
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的 C++ 插件，该插件与 Linux、Windows 和 Mac 桌面环境兼容
- en: Create a plugin in Java that will allow the device to actively read the temperature
    for 10 seconds and display it on your device's screen
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Java 插件，允许设备主动读取 10 秒钟的温度并在你的设备屏幕上显示
- en: Create a C# plugin that can access your web camera on your laptop, and send
    that information to the Unity Editor
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 C# 插件，可以访问你的笔记本电脑上的网络摄像头，并将这些信息发送到 Unity 编辑器
- en: 'The following set of challenges are for those that have access to a Mac computer
    (if you don''t, you can modify these to be for Windows or Android):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下挑战是为那些能够访问 Mac 计算机的人准备的（如果你没有，你可以修改这些以适用于 Windows 或 Android）：
- en: Create a Swift plugin that will read a finger press on the screen and log the
    exact location of the finger press either via text or via display colors on the
    screen
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Swift 插件，该插件将读取屏幕上的手指按压，并通过文本或通过屏幕上的显示颜色记录手指按压的确切位置
- en: Create an Objective-C plugin that takes the information from the camera sensor
    and logs it in a text file in binary format
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Objective-C 插件，该插件从摄像头传感器获取信息，并以二进制格式将其记录在文本文件中
- en: Questions
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Unity is able to utilize plugins from C++:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity 能够使用从 C++ 插件：
- en: A.) True
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'You create your own implementations for handling sensors to inject into Unity
    via plugins:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你为自己的传感器实现创建自己的实现，并通过插件注入到 Unity 中：
- en: A.) True
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'You can use ARKit to create an Objective-C plugin for Unity:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 ARKit 创建一个 Objective-C 插件用于 Unity：
- en: A.) True
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'You can build Java plugins to be used with Unity that are targeted at iOS devices:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以构建针对 iOS 设备的 Java 插件，用于与 Unity 一起使用：
- en: A.) True
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'Swift plugins are easier to develop than Objective-C plugins for Unity:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swift 插件比 Objective-C 插件更容易为 Unity 开发：
- en: A.) True
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'The Fingerprint sensor is only available on Android devices:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指纹传感器仅在 Android 设备上可用：
- en: A.) True
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'A camera is technically a sensor:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摄像头在技术上是一个传感器：
- en: A.) True
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'A gyroscope is used all the time in iOS and Android devices:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 iOS 和 Android 设备上始终使用陀螺仪：
- en: A.) True
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'A thermometer sensor is used to keep track of and measure the temperature of
    sensitive components:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用温度传感器来跟踪和测量敏感组件的温度：
- en: A.) True
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: 'An accelerometer is not a sensor designed to detect the momentum of the device:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加速度计不是一种用于检测设备动量的传感器：
- en: A.) True
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: A.) 正确
- en: B.) False
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: B.) 错误
- en: Further reading
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official documentation is always the best place to learn more about the
    sensors. Check out the following link for more information:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档始终是了解更多关于传感器的最佳地点。查看以下链接获取更多信息：
- en: '[https://developer.Android.com/guide/topics/sensors/sensors_overview](https://developer.android.com/guide/topics/sensors/sensors_overview)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.Android.com/guide/topics/sensors/sensors_overview](https://developer.Android.com/guide/topics/sensors/sensors_overview)'
- en: '[https://developer.apple.com/documentation/coremotion](https://developer.apple.com/documentation/coremotion)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/documentation/coremotion](https://developer.apple.com/documentation/coremotion)'
- en: '[https://developer.apple.com/documentation/coremotion/cmsensorrecorder](https://developer.apple.com/documentation/coremotion/cmsensorrecorder)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/documentation/coremotion/cmsensorrecorder](https://developer.apple.com/documentation/coremotion/cmsensorrecorder)'
