- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roslyn Compiler Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roslyn compiler extensions offer a powerful way to modify and extend the behavior
    of the C# compiler. With the Roslyn compiler, developers can write code that analyzes
    and modifies C# code at compile-time, opening new possibilities for code generation,
    code transformation, and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the technical setup of a Roslyn compiler extension
    project. The chapter itself is not focused on metaprogramming, but rather, on
    the technical setup for the two following chapters. We’ll delve into the process
    of packaging a Roslyn compiler extension for reuse. We’ll explore the different
    packaging options available, such as NuGet packages, and discuss best practices
    for making your extension easy to consume by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up a project and its moving parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to package your extension for reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how to set
    up a Roslyn compiler extension project and package it for reuse. You’ll be equipped
    with the knowledge and tools needed to start building powerful and flexible extensions
    that can significantly enhance the functionality of the C# compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub, ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15))
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  prefs: []
  type: TYPE_NORMAL
- en: How to set up a project and its moving parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C# compiler, powered by the Roslyn framework ([https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/)),
    provides a mechanism to load and use custom extensions in the form of analyzer
    and code fix providers. These extensions can be packaged as NuGet packages or
    included as project references, and they are loaded into the compilation process
    to analyze or modify the source code being compiled.
  prefs: []
  type: TYPE_NORMAL
- en: When the C# compiler encounters a project that includes a reference to a Roslyn
    extension, it uses .NET’s **AssemblyLoadContext** to load the extension’s assembly
    into the compilation process. This allows the extension’s code to be executed
    during the compilation process and participate in the analysis and transformation
    of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The Roslyn extensions are loaded into the compiler as analyzers, or source generators.
    Analyzers are responsible for examining the source code and reporting diagnostics,
    which are warnings, errors, or suggestions about potential issues in the code.
    Code fix providers provide suggestions or automated fixes to resolve the reported
    issues and are used by your code editor. Source generators, on the other hand,
    generate additional source code during compilation based on specific rules or
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: The C# compiler scans the loaded assemblies for types that implement interfaces
    defined by the Roslyn framework for different extension points. It then creates
    instances of these types and invokes their methods to perform the analysis and
    transformation of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The loading of Roslyn extensions occurs dynamically at compile-time, allowing
    for flexibility in adding or removing extensions without modifying the compiler
    itself, a great example of how the open / closed principle can be applied.. This
    dynamic loading also enables the reuse of extensions across different projects
    and solutions, as they can be packaged and distributed as NuGet packages or shared
    as project references.
  prefs: []
  type: TYPE_NORMAL
- en: What can they do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roslyn compiler extensions provide a robust and flexible platform for metaprogramming
    in C#. With Roslyn, you have full access to the syntax tree and semantic model
    of the code being compiled, giving you deep insights into the structure, syntax,
    and semantics of the code. This allows you to perform sophisticated code analysis,
    generate code based on patterns or conventions, and apply transformations to the
    code to achieve various goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some ways in which Roslyn compiler extensions can be powerful tools
    for metaprogramming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code generation**: Roslyn compiler extensions allow you to generate code
    during compilation. This can be used to automatically generate repetitive code
    patterns, such as data access layers, serialization code, or boilerplate code
    for repetitive tasks. You can also generate code based on conventions, configuration,
    or metadata, making it easy to create reusable and customizable code-generation
    tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code analysis**: Roslyn compiler extensions enable you to perform custom
    code analysis during compilation. This can help you catch potential issues, enforce
    coding standards, and provide automated code review feedback. For example, you
    can use a Roslyn extension to identify and flag code smells, security vulnerabilities,
    or other code quality issues early in the development process, helping you maintain
    a high level of code quality in your projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-Specific Language** (**DSL**): Roslyn compiler extensions can be used
    to create DSLs that provide specialized syntax and semantics tailored to specific
    problem domains. This allows you to define your own DSL and use it in your projects
    to improve expressiveness and maintainability. With a Roslyn extension, you can
    create custom syntax, create custom semantic rules, and enforce domain-specific
    conventions, making it easier to work with complex domain-specific concepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tooling and productivity**: Roslyn compiler extensions can be used to create
    custom tools and productivity features for development environments such as Visual
    Studio or VSCode. For example, you can create code refactoring tools, code completion
    providers, or diagnostics and quick fixes to streamline development workflows
    and catch common mistakes. With a Roslyn extension, you can create tailored tooling
    that fits your team’s specific needs and development practices, enhancing productivity
    and code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experimentation and innovation**: Roslyn compiler extensions provide a platform
    for experimentation and innovation in the field of programming languages and compilers.
    You can use a Roslyn extension to prototype new language features, experiment
    with different programming paradigms, or implement novel programming techniques.
    This allows you to push the boundaries of what’s possible with C# and explore
    new ideas in the field of software development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roslyn compiler extensions are a valuable tool in the toolbox of any C# developer
    interested in metaprogramming and pushing the boundaries of what’s possible with
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: Setting it up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Visual Studio and other IDEs, you have project templates that allow you to
    create a Roslyn compiler extension easily. An extension is nothing more than a
    class library with the correct package references, depending on what type of extension
    you are creating.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re not targeting a specific IDE, we’ll be doing this from scratch with
    the .NET CLI and configuring the different files manually.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we’ll need is a project folder. Since we’re going to be reusing
    the extension project for the following chapters, let’s create a folder called
    **Roslyn.Extensions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **Roslyn.Extensions** folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should now get two files called **Roslyn.Extensions.csproj** and **Class1.cs**.
    Delete the **Class1.cs** file, as you won’t be needing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Roslyn.Extensions.csproj** file in your editor. It should look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to change this up a little bit for it to work with the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The change of **TargetFramework** is necessary for it to work. The C# compiler
    won’t be able to load it otherwise. However, you might still want to write your
    extension using the latest C# edition, so you set **LangVersion** to reflect the
    version of C# you want. You keep **ImplicitUsings** and **Nullable** if that is
    desirable. A project containing analyzers or source generators needs also to set
    **EnforceExtendedAnalyzerRules** to **true**.
  prefs: []
  type: TYPE_NORMAL
- en: For developing analyzers or source code generators, we’re going to have to add
    a couple of NuGet package references. As mentioned earlier, the goal of this chapter
    is to set up a common package for the chapters following this one, so we’ll be
    including what we want for those and a little bit more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **<Project>** tag of the **Roslyn.Extensions.csproj** file, after
    the initial **<PropertyGroup>** add the following **<****ItemGroup>** block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first three packages are for the development of analyzers and source code
    generators. While the next two packages are analyzers, we want to be used to making
    sure our code adheres to standards.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **PrivateAssets** attribute used in the packages is for dependencies for
    the project they’re added to, and anyone referencing this will not inherit these
    dependencies directly. This is important for when we package this project as a
    NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want all the package references to be private to this package, you can
    do a neat little MSBuild trick by adding the following **ItemGroup** code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By doing that, you don’t have to have the **PrivateAssets="All"** attribute
    for all your references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the version of your .NET installation, the version numbers of
    referenced packages might be different. You can read more about which version
    is right for you here: [https://github.com/dotnet/roslyn/blob/main/docs/wiki/NuGet-packages.md](https://github.com/dotnet/roslyn/blob/main/docs/wiki/NuGet-packages.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding common rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the great things about how the .NET compiler and the underlying MSBuild
    engine that handles all the building works is that you can have a project with
    all your rules for how you want things. Every project that references it will
    then inherit this.
  prefs: []
  type: TYPE_NORMAL
- en: EditorConfig ([https://editorconfig.org](https://editorconfig.org)) is one of
    these items that can be reused among projects. Most IDEs and code editors out
    there honor the configuration of EditorConfig, which is great, because you can
    have a team using all kinds of editors, and they all adhere to the same settings.
  prefs: []
  type: TYPE_NORMAL
- en: At the root of a repository, you can place a file called **.editorconfig**,
    which contains the common setup of rules that apply to every file within your
    project. The rules can be anything from formatting, tabs versus spaces, indentation
    levels, and specific rules picked up by compilers such as the C# compiler.
  prefs: []
  type: TYPE_NORMAL
- en: This is great to get consistency in your codebase, avoid potential problems,
    and increase the maintainability of the source code. With .NET, we can go one
    further by packaging it in a project and making it so that every project that
    references it will get these rules. The benefit of this is that you can then reuse
    it outside the realms of your repository, which we’ll come back to a little bit
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a file called **.globalconfig** in the **Roslyn.Extensions** folder.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This configuration sets **is_global** to **true** to indicate it should be a
    global settings file. It then goes on to specify how the end of the line is, the
    indentation style, and size, and then the charset used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then go on and specify different rules specific to .NET. There are
    quite a few settings and rules you can configure, and I recommend reading more
    [about it all here: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options)-style-rule-options.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the GitHub repository for this book, you’ll find a more complete **.globalconfig**
    file with a lot of .NET and C#-specific rules specified. Be aware that the rules
    put in place are a reflection of how I personally like the code to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you added a dependency to **StyleCop**, we can also configure global
    options for it. Add a file called **stylecop.json** in the **Roslyn.Extensions**
    folder and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it duplicates the indentation style, which is recommended.
    It then goes on to specify specific rules for how you want the code to look. In
    this case, it specifies that the **using** directives should be sorted with those
    prefixed with **System** first. Then, it says that the using directives should
    be outside the namespace blocks and then omit any blank lines between using groups.
    These and more option[s can be found here: https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documenta](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md)tion/Configuration.md.'
  prefs: []
  type: TYPE_NORMAL
- en: Common project settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a set of configuration properties you want for all your projects,
    you can create a common **.props** file that will automatically be picked up and
    used. All you need is a file called the same as the project with a **.props**
    extension. In our case, the project name is **Roslyn.Extensions**, so the file
    needed would be called **Roslyn.Extensions.props**.
  prefs: []
  type: TYPE_NORMAL
- en: A props file is basically just an MSBuild project file as the **.csproj** file.
    MSBuild has a convention of automatically importing this file from a common extension
    project like this into consumers of the extension package.
  prefs: []
  type: TYPE_NORMAL
- en: Within a common project settings file, you can do more than just add properties.
    You can include files, add package references, or do anything that you can do
    in a regular **.csproj** file. That is super powerful when you want to apply and
    enforce common settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **Roslyn.Extensions.props** to the **Roslyn.Extensions**
    project and put the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The properties added configure first a couple of standard C# compiler settings.
    It enables **Nullable** and then tells the compiler to be strict and treat any
    warnings as errors. Then, it tells the MSBuild engine to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: Since we included code analysis, the next section configures it to force the
    compiler to run analyzers during the build and enable them all.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it sets up the style cop analyzers to specifically not treat errors
    as warnings and enforces it during build.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing you’re going to need is to make sure the **.globalconfig** file
    and **stylecop.json** file get used in any projects referencing this one. This
    is done by adding **ItemGroup** after **PropertyGroup** in the **Roslyn.Extensions.props**
    file, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This lets the compiler know about the two files for configuring static code
    analysis and code styles. It uses a variable called **MSBuildThisFileDirectory**,
    which is a well-known MSBuild variable that gets set to the folder of the file
    it is processing. Omitting this would make it look for this file relative to the
    current directory, which would be different for every project referencing this
    common project.
  prefs: []
  type: TYPE_NORMAL
- en: To this point, all you’ve done is wrap up common things in a common project
    that can, within a repository, be referenced and automatically configure all projects
    referencing it. Sometimes, you want to go beyond the boundaries of a single repository
    and publish the common project as a package that can then be reused by other projects
    and get the same benefits.
  prefs: []
  type: TYPE_NORMAL
- en: How to package your extension for reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the key advantages of Roslyn compiler extensions is their potential
    for reuse across different projects and solutions. Once you have developed a Roslyn
    extension, you can package it for reuse and share it with other developers or
    teams, providing a number of benefits and advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code consistency**: Reusing Roslyn extensions can help enforce consistent
    coding practices across different projects and solutions. You can create Roslyn
    extensions that encapsulate coding standards, conventions, or best practices,
    and share them across your organization. This ensures that all projects adhere
    to the same coding guidelines, reducing inconsistencies and improving code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Productivity**: Reusing Roslyn extensions can enhance developer productivity
    by automating repetitive tasks and providing productivity features. For example,
    you can create Roslyn extensions that generate boilerplate code, automate code
    refactoring, or provide custom code completion providers. By reusing such extensions,
    you can save time and effort, and improve overall development productivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Reusing Roslyn extensions can improve code maintainability
    by encapsulating complex logic or code generation patterns. You can create Roslyn
    extensions that encapsulate DSLs, custom syntax, or semantic rules, and share
    them across projects. This makes it easier to maintain and update the codebase,
    as changes can be made in a central location and propagated to all projects using
    the shared extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: Reusing Roslyn extensions can make your codebase more extensible
    by providing hooks or extension points for other developers. You can create Roslyn
    extensions that provide extensibility points, such as custom code generation templates
    or code analysis rules, which can be extended or customized by other developers
    as needed. This promotes collaboration and enables other teams or developers to
    extend the functionality of your codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Innovation**: Reusing Roslyn extensions can foster innovation by sharing
    new ideas, techniques, or approaches with the community. If you have developed
    a novel or innovative Roslyn extension, sharing it with the community can encourage
    others to build upon your work, leading to new discoveries, solutions, or techniques.
    This contributes to the growth and advancement of the Roslyn ecosystem, benefiting
    the entire community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By sharing and reusing Roslyn extensions, you can improve code quality, enhance
    productivity, and foster collaboration, contributing to a more robust and vibrant
    Roslyn ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Roslyn extensions can be a powerful tool for metaprogramming, which involves
    writing code that generates or manipulates other code. By creating and packaging
    Roslyn extensions, you can leverage metaprogramming techniques to automate repetitive
    tasks, enforce coding standards, or apply compliance rules such as **General Data
    Protection Regulation** (**GDPR**) across different projects and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a scenario where you have multiple projects that need
    to comply with GDPR by ensuring that certain data handling practices are followed
    consistently. Instead of manually checking and updating each project’s codebase,
    you can create a Roslyn extension that encapsulates the compliance rules and distributes
    them across the projects. This way, you can ensure that the same compliance rules
    are applied uniformly in all projects, saving time and effort and reducing the
    risk of human error.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Roslyn extensions can also provide powerful metaprogramming capabilities
    to generate code or refactor existing code based on specific requirements. For
    instance, you can create a Roslyn extension that generates code snippets for common
    patterns or templates, such as implementing design patterns, handling common scenarios,
    or generating boilerplate code. By packaging and sharing this extension across
    projects, you can ensure that the generated code adheres to your organization’s
    coding standards or follows specific patterns, promoting consistency and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Common package properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All NuGet packages can have additional metadata. This metadata is very useful
    when published to a NuGet package repository [such as the off](https://nuget.org)icial
    one at [https://nuget.org](https://nuget.org). This metadata is typically then
    displayed on the information page of a package. The metadata you add contains
    information about the authors, copyright notices, where the project is located,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add all the properties for the metadata. Open the **Roslyn.Extensions.csproj**
    file and add the following code, typically after the first **<PropertyGroup>**
    instance within the **<****Project>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you can set all these properties to what is right for your project.
    It includes also **logo.png** and a **README.md** file. If you don’t have these,
    you can just take these out. Having a **README.md** file is, however, recommended
    when publishing to a package repository. Putting information into this file about
    how to use the package and what it is for would then be very helpful for the consumer
    of the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The metadata only points to the **logo.png** file and **README.md** file, but
    they have to be explicitly added for them to be part of the package. Add the following
    **ItemGroup** text after the **PropertyGroup** metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the **PackagePath** attribute. This instructs the NuGet packager
    which target path to put the file into. For the **README.md** file, it will be
    put at the root of the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the common code properties, code analysis, and code style rules you added
    to the project earlier, they also need to be explicitly added to the package for
    them to work. Add another **ItemGroup** block for these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For the **Roslyn.Extensions.props** file to work when used as a package reference,
    it needs to sit inside a folder called **build** within the package. Since we
    referred to the common files with a path prefixed with the **MSBuildThisFileDirectory**
    MSBuild variable, it means that the common files also have to be in the **build**
    path within the package.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last piece of the puzzle is for the analyzer itself. For it to work, it
    needs to be within a specific part of the NuGet package, in a directory called
    **analyzers/dotnet/cs**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another **ItemGroup** block to the **Roslyn.Extensions.csproj** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**ItemGroup** adds the DLL file of the project based on **OutputPath**, which
    will vary depending on whether you’re building a debug or release version. Typically,
    for a release version, it would be **bin/Release/netstandard2.0** and then the
    **AssemblyName** variable reflects the output assembly name, which, in our case,
    would be **Roslyn.Extensions**.'
  prefs: []
  type: TYPE_NORMAL
- en: Running **dotnet pack -c release** in a terminal from the root of the **Roslyn.Extensions**
    project should now create a package with all the artifacts in place.
  prefs: []
  type: TYPE_NORMAL
- en: The package will be output to the **bin/release** folder and called **Roslyn.Extensions.1.0.0.nupkg**.
  prefs: []
  type: TYPE_NORMAL
- en: We can investigate the content of the package to see that everything we wanted
    it to include is included and in the correct locations. The NuGet package is nothing
    more than a compressed ZIP file. That means we can open it with your favorite
    ZIP utility and see whether the content is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content should be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Checking package content
  prefs: []
  type: TYPE_NORMAL
- en: This package would now be ready to be published to a centralized package manager
    such as NuGet. You can read more about how to package NuGet packages at Microsoft’s
    official documentation for this ([https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package](https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package)).
  prefs: []
  type: TYPE_NORMAL
- en: That is pretty much it. You’ve now configured everything for a Roslyn extension
    and also put in common properties you want for every project referencing the package
    you have just created.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the technical setup of a Roslyn compiler extension
    project, covering the key moving parts of a Roslyn compiler extension. We discussed
    the various ways in which a Roslyn compiler extension can modify C# code.
  prefs: []
  type: TYPE_NORMAL
- en: We also delved into the process of packaging a Roslyn compiler extension for
    reuse, exploring the different packaging options available and discussing best
    practices for making your extension easy to consume by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on generating code with Roslyn compiler extensions.
    We’ll explore techniques for generating new code based on existing code, and we’ll
    discuss best practices for ensuring that the generated code is of high quality
    and conforms to established conventions and standards. With the knowledge gained
    in this chapter and the next, you’ll be well on your way to building powerful
    and flexible Roslyn compiler extensions that can significantly enhance the functionality
    of the C# compiler.
  prefs: []
  type: TYPE_NORMAL
