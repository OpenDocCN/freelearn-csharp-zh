- en: An Introduction to Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: 'The focus of this chapter is to get you acquainted with microservices. We will
    start with a brief introduction. Then, we will define their predecessors: monolithic
    architecture and **Service-Oriented Architecture** (**SOA**). After this, we will
    see how microservices fare against both SOA and the monolithic architecture. We
    will then compare the advantages and disadvantages of each one of these architectural
    styles. This will enable us to identify the right scenario for these styles. We
    will understand the problems that arise from having a layered monolithic architecture.
    We will discuss the solutions available to these problems in the monolithic world.
    At the end, we will be able to break down a monolithic application into a microservice
    architecture. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是让您熟悉微服务。我们将从简要介绍开始。然后，我们将定义它们的先辈：单体架构和**面向服务的架构**（**SOA**）。在此之后，我们将看到微服务如何与SOA和单体架构相媲美。然后，我们将比较这些架构风格的优缺点。这将使我们能够确定这些风格的正确场景。我们将了解分层单体架构产生的问题。我们将讨论在单体世界中解决这些问题的方案。最后，我们将能够将单体应用程序分解为微服务架构。本章将涵盖以下主题：
- en: Origin of microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的起源
- en: Discussing microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论微服务
- en: Understanding the microservice architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微服务架构
- en: Advantages of microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的优势
- en: SOA versus microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOA与微服务的比较
- en: Understanding the problems with the monolithic architectural style
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单体架构风格的问题
- en: Challenges in standardizing a .NET stack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化.NET堆栈的挑战
- en: Overview of Azure Service Fabric
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure服务 Fabric概述
- en: Origin of microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的起源
- en: The term *microservices* was used for the first time in mid-2011 at a workshop
    on software architects. In March 2012, James Lewis presented some of his ideas
    about *microservices*. By the end of 2013, various groups from the IT industry
    started having discussions about *microservices*, and by 2014, they had become
    popular enough to be considered a serious contender for large enterprises.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务”这个术语首次在2011年中期的一个软件架构师研讨会上被使用。2012年3月，詹姆斯·刘易斯（James Lewis）提出了一些关于**微服务**的想法。到2013年底，IT行业的各个群体开始就**微服务**进行讨论，到2014年，它们已经足够流行，被视为大型企业的一个严肃的竞争者。
- en: 'There is no official introduction available for *microservices*. The understanding
    of the term is purely based on the use cases and discussions held in the past.
    We will discuss this in detail, but before that, let''s check out the definition
    of microservices as per Wikipedia ([https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices)),
    which sums it up as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**微服务**，没有官方的介绍。对这个术语的理解纯粹基于过去的使用案例和讨论。我们将详细讨论这个问题，但在那之前，让我们看看维基百科（[https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices)）对微服务的定义，它将其总结如下：
- en: '"Microservices is a specialization of and implementation approach for SOA used
    to build flexible, independently deployable software systems."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务是SOA的一个专业化和实现方法，用于构建灵活的、可独立部署的软件系统。”
- en: 'In 2014, James Lewis and Martin Fowler came together and provided a few real-world
    examples and presented *microservices *(refer to [http://martinfowler.com/microservices/](http://martinfowler.com/microservices/))
    in their own words and further detailed it as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，詹姆斯·刘易斯（James Lewis）和马丁·福勒（Martin Fowler）共同提供了一些实际案例，用自己的话介绍了**微服务**（参考[http://martinfowler.com/microservices/](http://martinfowler.com/microservices/)），并进一步详细说明如下：
- en: '"The microservice architectural style is an approach to developing a single
    application as a suite of small services, each running in its own process and
    communicating with lightweight mechanisms, often an HTTP resource API. These services
    are built around business capabilities and independently deployable by fully automated
    deployment machinery. There is a bare minimum of centralized management of these
    services, which may be written in different programming languages and use different
    data storage technologies."'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务架构风格是一种将单个应用程序作为一系列小型服务开发的方法，每个服务都在自己的进程中运行，并通过轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务能力构建，并且可以由完全自动化的部署机器独立部署。对这些服务的集中式管理最少，这些服务可能使用不同的编程语言，并使用不同的数据存储技术。”
- en: It is very important that you see all the attributes Lewis and Fowler defined
    here. They defined it as an architectural style that developers could utilize
    to develop a single application with the business logic spread across a bunch
    of small services, each having their own persistent storage functionality. Also,
    note its attributes—it can be independently deployable, can run in its own process,
    is a lightweight communication mechanism, and can be written in different programming
    languages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到Lewis和Fowler在这里定义的所有属性非常重要。他们将单体架构定义为一种开发者可以利用的架构风格，以开发一个业务逻辑分布在多个小型服务中的应用程序，每个服务都有自己的持久化存储功能。同时，注意其属性——它可以独立部署，可以在自己的进程中运行，是一种轻量级通信机制，并且可以用不同的编程语言编写。
- en: We want to emphasize this specific definition since it is the crux of the whole
    concept. And as we move along, it will come together by the time we finish this
    book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要强调这个特定的定义，因为它整个概念的精髓。随着我们继续前进，当我们完成这本书的时候，它将会逐渐显现。
- en: Discussing microservices
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论微服务
- en: We have gone through a few definitions of *microservices*; now, let's discuss
    *microservices* in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过几个关于*微服务*的定义；现在，让我们详细讨论*微服务*。
- en: In short, a microservice architecture removes most of the drawbacks of SOAs.
    It is more code-oriented (we will discuss this in detail in the coming sections)
    than SOA services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，微服务架构消除了SOA的大部分缺点。它比SOA服务更注重代码（我们将在接下来的章节中详细讨论这一点）。
- en: Slicing your application into a number of services is neither SOA nor microservices.
    However, combining service design and best practices from the SOA world along
    with a few emerging practices, such as isolated deployment, semantic versioning,
    providing lightweight services, and service discovery in polyglot programming,
    is microservices. We implement microservices to satisfy business features and
    implement them with reduced time to market and greater flexibility.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序切割成多个服务既不是SOA也不是微服务。然而，结合SOA世界的服务设计和最佳实践，以及一些新兴实践，如隔离部署、语义版本化、提供轻量级服务和多语言编程中的服务发现，就是微服务。我们实现微服务以满足业务功能，并以更短的时间上市和更大的灵活性来实现它们。
- en: 'Before we move on to understanding the architecture, let''s discuss the two
    important architectures that led to its existence:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续了解架构之前，让我们讨论一下导致其存在的两个重要架构：
- en: The monolithic architecture style
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构风格
- en: SOA
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOA
- en: Most of us would be aware of the scenario where, during the life cycle of an
    enterprise application development, a suitable architectural style is decided.
    Then, at various stages, the initial pattern is further improved and adapted with
    changes that cater to various challenges, such as deployment complexity, large
    code base, and scalability issues. This is exactly how the monolithic architecture
    style evolved into SOA, further leading up to microservices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人都会意识到，在企业应用程序开发的生命周期中，在各个阶段，都会决定一个合适的架构风格。然后，随着各种挑战的出现，如部署复杂性、大型代码库和可伸缩性问题，初始模式会进一步改进和适应。这正是单体架构风格演变成SOA，进而发展到微服务的过程。
- en: Monolithic architecture
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构
- en: 'The monolithic architectural style is a traditional architecture type and has
    been widely used in the industry. The term *monolithic* is not new and is borrowed
    from the UNIX world. In UNIX, most of the commands exist as a standalone program
    whose functionality is not dependent on any other program. As seen in the following
    image, we can have different components in the application, such as:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构风格是一种传统的架构类型，在业界得到了广泛的应用。术语*单体*并不新鲜，它借用了UNIX世界的概念。在UNIX中，大多数命令都存在作为独立程序，其功能不依赖于任何其他程序。如图所示，我们可以有应用程序中的不同组件，例如：
- en: 'User interface: This handles all of the user interaction while responding with
    HTML or JSON or any other preferred data interchange format (in the case of web
    services).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面：它处理所有用户交互，同时以HTML或JSON或其他任何首选的数据交换格式（在Web服务的情况下）进行响应。
- en: 'Business logic: All the business rules applied to the input being received
    in the form of user input, events, and database exist here.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑：所有应用于以用户输入、事件和数据库形式接收的输入的业务规则都存在于这里。
- en: 'Database access: This houses the complete functionality for accessing the database
    for the purpose of querying and persisting objects. A widely accepted rule is
    that it is utilized through business modules and never directly through user-facing
    components.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库访问：这包含了用于查询和持久化对象的数据库访问的完整功能。一个普遍接受的规则是，它通过业务模块使用，而不是直接通过面向用户的组件使用。
- en: 'Software built using this architecture is self-contained. We can imagine a
    single .NET assembly that contains various components, as described in the following
    diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此架构构建的软件是自包含的。我们可以想象一个包含各种组件的单个 .NET 程序集，如以下图所示：
- en: '![](img/79da4a6a-3b49-4218-92ab-53786ce242e2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79da4a6a-3b49-4218-92ab-53786ce242e2.png)'
- en: As the software is self-contained here, its components are interconnected and
    interdependent. Even a simple code change in one of the modules may break a major
    functionality in other modules. This would result in a scenario where we'd need
    to test the whole application. With the business depending critically on its enterprise
    application frameworks, this amount of time could prove to be very critical.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件是自包含的，其组件是相互关联和相互依赖的。即使在某个模块中进行的简单代码更改也可能破坏其他模块中的主要功能。这会导致我们需要测试整个应用程序的情况。由于业务严重依赖其企业应用程序框架，这段时间可能会非常关键。
- en: Having all the components tightly coupled poses another challenge—whenever we
    execute or compile such software, all the components should be available or the
    build will fail; refer to the preceding diagram that represents a monolithic architecture
    and is a self-contained or a single .NET assembly project. However, monolithic
    architectures might also have multiple assemblies. This means that even though
    a business layer (assembly, data access layer assembly, and so on) is separated,
    at runtime, all of them will come together and run as one process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件紧密耦合提出了另一个挑战——无论何时执行或编译此类软件，所有组件都应可用，否则构建将失败；参考前面的图示，它代表了一个单体架构，是一个自包含的或单个
    .NET 程序集项目。然而，单体架构可能也有多个程序集。这意味着尽管业务层（程序集、数据访问层程序集等）是分离的，但在运行时，它们将一起运行作为一个进程。
- en: A user interface depends on other components' direct sales and inventory in
    a manner similar to all other components that depend upon each other. In this
    scenario, we will not be able to execute this project in the absence of any one
    of these components. The process of upgrading any one of these components will
    be more complex as we may have to consider other components that require code
    changes too. This results in more development time than required for the actual
    change.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面以与其他组件类似的方式直接依赖其他组件的销售和库存。在这种情况下，如果没有任何一个组件，我们将无法执行此项目。升级任何一个组件的过程将更加复杂，因为我们可能需要考虑其他也需要代码更改的组件。这会导致比实际更改所需更多的发展时间。
- en: Deploying such an application will become another challenge. During deployment,
    we will have to make sure that each and every component is deployed properly;
    otherwise, we may end up facing a lot of issues in our production environments.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 部署此类应用程序将变成另一个挑战。在部署过程中，我们必须确保每个组件都得到正确部署；否则，我们可能会在我们的生产环境中遇到许多问题。
- en: 'If we develop an application using the monolithic architecture style, as discussed
    previously, we might face the following challenges:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前讨论的单体架构风格开发应用程序，我们可能会面临以下挑战：
- en: 'Large code base: This is a scenario where the code lines outnumber the comments
    by a great margin. As components are interconnected, we will have to bear with
    a repetitive code base.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型代码库：这是一个代码行数远多于注释的情况。由于组件是相互关联的，我们将不得不忍受重复的代码库。
- en: 'Too many business modules: This is in regard to modules within the same system.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务模块太多：这是关于同一系统内的模块。
- en: 'Codebase complexity: This results in a higher chance of code-breaking due to
    the fix required in other modules or services.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库复杂性：这导致由于在其他模块或服务中进行的修复而出现代码破坏的可能性更高。
- en: 'Complex code deployment: You may come across minor changes that would require
    whole system deployment.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂代码部署：你可能会遇到需要整个系统部署的微小更改。
- en: 'One module failure affecting the whole system: This is in regard to modules
    that depend on each other.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块的故障影响整个系统：这是关于相互依赖的模块。
- en: 'Scalability: This is required for the entire system and not just the modules
    in it.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性：这是整个系统所需，而不仅仅是其中的模块。
- en: 'Intermodule dependency: This is due to tight coupling.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块间依赖：这是由于紧密耦合造成的。
- en: 'Spiraling development time: This is due to code complexity and interdependency.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发时间螺旋上升：这是由于代码复杂性和相互依赖性造成的。
- en: 'Inability to easily adapt to a new technology: In this case, the entire system
    would need to be upgraded.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以轻松适应新技术：在这种情况下，整个系统都需要升级。
- en: As discussed earlier, if we want to reduce development time, ease of deployment,
    and improve maintainability of software for enterprise applications, we should
    avoid the traditional or monolithic architecture.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们想减少企业应用程序的开发时间、部署的便捷性和可维护性，我们应该避免传统的或单体架构。
- en: Service-Oriented architecture
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: In the previous section, we discussed the monolithic architecture and its limitations.
    We also discussed why it does not fit into our enterprise application requirements.
    To overcome these issues, we should take a modular approach where we can separate
    the components such that they should come out of the self-contained or single
    .NET assembly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了单体架构及其局限性。我们还讨论了为什么它不符合我们的企业应用程序需求。为了克服这些问题，我们应该采取模块化方法，这样我们可以将组件分开，使它们从自包含或单个.NET组件中分离出来。
- en: The main difference between SOA and monolithic is not one or multiple assemblies.
    As the service in SOA runs as a separate process, SOA scales better compared to
    monolithic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SOA与单体架构的主要区别不在于一个或多个组件。由于SOA中的服务作为一个独立的过程运行，因此与单体架构相比，SOA具有更好的可扩展性。
- en: Let's discuss the modular architecture, that is, SOA. This is a famous architectural
    style where enterprise applications are designed as a collection of services.
    These services may be RESTful or ASMX Web Services. To understand SOA in more
    detail, let's discuss *service* first.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论模块化架构，即SOA。这是一种著名的架构风格，其中企业应用程序被设计为一组服务的集合。这些服务可能是RESTful或ASMX Web服务。为了更详细地了解SOA，让我们首先讨论*服务*。
- en: What is a service?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是服务？
- en: 'Service, in this case, is an essential concept of SOA. It can be a piece of
    code, program, or software that provides functionality to other system components.
    This piece of code can interact directly with the database or indirectly through
    another service. Furthermore, it can be consumed by clients directly, where the
    client may be a website, desktop app, mobile app, or any other device app. Refer
    to the following diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，服务是SOA的一个基本概念。它可能是一段代码、程序或软件，为其他系统组件提供功能。这段代码可以直接与数据库交互，或者通过另一个服务间接交互。此外，它可以直接被客户端消费，客户端可能是一个网站、桌面应用程序、移动应用程序或任何其他设备应用程序。请参考以下图表：
- en: '![](img/2fd7f13f-89ce-4f72-a4aa-9a9213a26e40.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fd7f13f-89ce-4f72-a4aa-9a9213a26e40.png)'
- en: Service refers to a type of functionality exposed for consumption by other systems
    (generally referred to as **clients/client applications**). As mentioned earlier,
    it can be represented by a piece of code, program, or software. Such services
    are exposed over the HTTP transport protocol as a general practice. However, the
    HTTP protocol is not a limiting factor, and a protocol can be picked as deemed
    fit for the scenario.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '服务是指一种为其他系统（通常称为**客户端/客户端应用程序**）消费的功能类型。如前所述，它可以由一段代码、程序或软件表示。这类服务通常通过HTTP传输协议公开。然而，HTTP协议并不是限制因素，可以选择适合场景的协议。 '
- en: In the following image, **Service - direct selling** is directly interacting
    with **Database**, and three different clients, namely **Web**, **Desktop**, and
    **Mobile**, are consuming the service. On the other hand, we have clients consuming
    **Service - partner selling**, which is interacting with **Service - channel partners** for
    database access.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，**服务 - 直接销售**直接与**数据库**交互，并且三个不同的客户端，即**Web**、**桌面**和**移动**，正在消费该服务。另一方面，我们有消费**服务
    - 合作销售**的客户端，该服务正在与**服务 - 渠道合作伙伴**交互以访问数据库。
- en: A product selling service is a set of services that interacts with client applications
    and provides database access directly or through another service, in this case,
    **Service – Channel partners**. In the case of **Service – direct selling**, shown
    in the preceding image, it is providing functionality to a web store, a desktop
    application, and a mobile application. This service is further interacting with
    the database for various tasks, namely fetching and persisting data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 产品销售服务是一组与客户端应用程序交互并提供数据库直接访问或通过另一个服务（在这种情况下，**服务-渠道合作伙伴**）的服务。在**服务-直销**的情况下，如前图所示，它为网店、桌面应用程序和移动应用程序提供功能。此服务还与数据库进行交互，执行各种任务，即获取和持久化数据。
- en: 'Normally, services interact with other systems via some communication channel,
    generally the HTTP protocol. These services may or may not be deployed on the
    same or single servers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务通过某种通信渠道与其他系统交互，通常是HTTP协议。这些服务可能部署在相同的服务器上，也可能不在同一服务器上：
- en: '![](img/3141c324-dfe8-495b-9c05-28436ac2d7df.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3141c324-dfe8-495b-9c05-28436ac2d7df.png)'
- en: 'In the preceding image, we have projected an SOA example scenario. There are
    many fine points to note here, so let''s get started. First, our services can
    be spread across different physical machines. Here, **Service - direct selling** is
    hosted on two separate machines. It is possible that instead of the entire business
    functionality, only a part of it will reside on **Server 1** and the remaining
    on **Server 2**. Similarly, **Service - partner selling** appears to be having
    the same arrangement on **Server 3** and **Server 4**. However, it doesn''t stop
    **Service - channel partners** being hosted as a complete set on both the servers:
    **Server 5** and **Server 6**.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图像中，我们展示了一个SOA示例场景。这里有许多需要注意的细微之处，所以让我们开始吧。首先，我们的服务可以分布在不同的物理机器上。在这里，**服务-直销**托管在两个独立的机器上。可能的情况是，整个业务功能不是全部都驻留在**服务器1**上，而是部分驻留在**服务器2**上。同样，**服务-合作伙伴销售**似乎在**服务器3**和**服务器4**上有相同的安排。然而，这并不妨碍**服务-渠道合作伙伴**作为一个完整的集合托管在两个服务器上：**服务器5**和**服务器6**。
- en: A system that uses a service or multiple services in a fashion mentioned in
    the preceding diagram is called **SOA**. We will discuss SOA in detail in the
    following sections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述图中提到的方式使用服务或多个服务的系统称为**SOA**。我们将在以下部分详细讨论SOA。
- en: 'Let''s recall the monolithic architecture. In this case, we did not use it
    because it restricts code reusability; it is a self-contained assembly, and all
    the components are interconnected and interdependent. For deployment, in this
    case, we will have to deploy our complete project after we select the SOA (refer
    to the preceding diagram and subsequent discussion). Now, because of the use of
    this architectural style, we have the benefit of code reusability and easy deployment.
    Let''s examine this in the wake of the preceding diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下单体架构。在这种情况下，我们没有使用它，因为它限制了代码的可重用性；它是一个自包含的组件，所有组件都是相互连接和相互依赖的。在部署方面，在这种情况下，在选择了SOA（参见图表和后续讨论）之后，我们必须部署我们的完整项目。现在，由于使用了这种架构风格，我们有了代码可重用性和易于部署的好处。让我们在前述图表的基础上进行考察：
- en: 'Reusability: Multiple clients can consume the service. The service can also
    be simultaneously consumed by other services. For example, *OrderService* is consumed
    by web and mobile clients. Now, *OrderService* can also be used by the Reporting
    Dashboard UI.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性：多个客户端可以消费服务。服务也可以同时被其他服务消费。例如，*OrderService*被Web和移动客户端消费。现在，*OrderService*也可以被报告仪表板UI使用。
- en: 'Stateless: Services do not persist any state between requests from the client,
    that is, the service doesn''t know, nor care that the subsequent request has come
    from the client that has/hasn''t made the previous request.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态：服务不会在客户端请求之间持久化任何状态，也就是说，服务不知道，也不关心后续请求是否来自已经/没有发出先前请求的客户端。
- en: 'Contract-based: Interfaces make it technology-agnostic on both sides of implementation
    and consumption. It also serves to make it immune to the code updates in the underlying
    functionality.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于契约：接口在实现和消费的两端都使技术无关。它还用于使底层功能代码更新免疫。
- en: 'Scalability: A system can be scaled up; SOA can be individually clustered with
    appropriate load balancing.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩性：系统可以扩展；SOA可以单独进行集群，并使用适当的负载均衡。
- en: 'Upgradation: It is very easy to roll out new functionalities or introduce new
    versions of the existing functionality. The system doesn''t stop you from keeping
    multiple versions of the same business functionality.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级：推出新功能或引入现有功能的新的版本非常容易。系统不会阻止你保留同一业务功能的多个版本。
- en: Understanding the microservice architecture
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务架构
- en: The microservice architecture is a way to develop a single application containing
    a set of smaller services. These services are independent of each other and run
    in their own processes. An important advantage of these services is that they
    can be developed and deployed independently. In other words, we can say that microservices
    are a way to segregate our services so they can be handled completely independent
    of each other in the context of design, development, deployment, and upgrades.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种开发包含一组较小服务单一应用程序的方法。这些服务相互独立，并在它们自己的进程中运行。这些服务的一个重要优势是它们可以独立开发和部署。换句话说，我们可以认为微服务是一种将我们的服务分割开来的方法，以便在设计、开发、部署和升级的背景下完全独立地处理。
- en: 'In a monolithic application, we have a self-contained assembly of a user interface,
    direct sales, and inventory. In the microservice architecture, the services part
    of the application changes to the following depiction:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序中，我们有一个包含用户界面、直接销售和库存的自包含组件。在微服务架构中，应用程序的服务部分变为以下描述：
- en: '![](img/685a7b9b-bfd8-4e3b-a27d-1e3708c96738.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/685a7b9b-bfd8-4e3b-a27d-1e3708c96738.png)'
- en: 'Here, business components have been segregated into individual services. These
    independent services now are the smaller units that existed earlier within the
    self-contained assembly, in the monolithic architecture. Both direct sales and
    inventory services are independent of each other, with the dotted lines depicting
    their existence in the same ecosystem yet not bound within a single scope. Refer
    to the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，业务组件已经被分割成独立的服务。这些独立的服务现在是之前在自包含组件中存在的较小单元，在单体架构中。直接销售服务和库存服务相互独立，虚线表示它们存在于同一生态系统中，但并未被限制在单一范围内。请参考以下图表：
- en: '![](img/6a664f69-b2ed-4f90-9ad9-9d49d4f2a857.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a664f69-b2ed-4f90-9ad9-9d49d4f2a857.png)'
- en: From the preceding diagram, it's clear that our user interface can interact
    with any of the services. There is no need to intervene in any service when a
    UI calls a service. Both the services are independent of each other, without being
    aware of when the other one would be called by the user interface. Both services
    are liable for their own operations and not for any other part in the whole system.
    Although much closer to the microservice architecture, the preceding visualization
    is not entirely a complete visualization of the intended microservice architecture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中可以看出，我们的用户界面可以与任何服务进行交互。当UI调用服务时，无需干预任何服务。这两个服务相互独立，且不知道用户界面何时会调用另一个服务。两个服务都对其自身的操作负责，而不是对整个系统中的任何其他部分负责。尽管与微服务架构非常接近，但前面的可视化并不是完全完整的微服务架构可视化。
- en: In the microservice architecture, services are small, independent units with
    their own persistent stores.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务是小型、独立的单元，拥有自己的持久存储。
- en: 'Now let''s bring this final change so that each service will have its own database
    persisting the necessary data. Refer to the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们引入这一最终变化，以便每个服务都将拥有自己的数据库，用于持久化必要的数据。请参考以下图表：
- en: '![](img/25cb67e0-199e-49d8-84e7-c8ba9a718792.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25cb67e0-199e-49d8-84e7-c8ba9a718792.png)'
- en: Here, **User interface** is interacting with those services that have their
    own independent storage. In this case, when a user interface calls a service for
    direct sales, the business flow for direct sales is executed independently of
    any data or logic contained within the inventory service.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，**用户界面**正在与那些拥有独立存储的服务进行交互。在这种情况下，当用户界面调用直接销售服务时，直接销售的业务流程将独立于库存服务中的任何数据或逻辑执行。
- en: 'The solution that the use of microservices provides has a lot of benefits,
    as discussed next:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务提供的解决方案具有许多好处，以下将进行讨论：
- en: 'Smaller codebase: Each service is small, and therefore, easier to develop and
    deploy as a unit'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更小的代码库：每个服务都很小，因此作为单元开发和应用部署更为容易
- en: 'Ease of independent environment: With the separation of services, all developers
    work independently, deploy independently, and no one is bothered about any module
    dependency'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立环境的便利性：随着服务的分离，所有开发者都可以独立工作，独立部署，没有人会因任何模块依赖而感到困扰
- en: With the adoption of the microservice architecture, monolithic applications
    are now harnessing the associated benefits, as it can now be scaled easily and
    deployed using a service independently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务架构的采用，单体应用现在正在利用相关的优势，因为它现在可以轻松扩展并独立部署。
- en: Messaging in microservices
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的消息传递
- en: It is very important to carefully consider the choice of the messaging mechanism
    when dealing with the microservice architecture. If this one aspect is ignored,
    then it can compromise the entire purpose of designing using the microservice
    architecture. In monolithic applications, this is not a concern as the business
    functionality of the components gets invoked through function calls. On the other
    hand, this happens via a loosely coupled web service level messaging feature,
    where services are primarily based on SOAP.  In the case of the microservice messaging
    mechanism, it should be simple and lightweight.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理微服务架构时，仔细考虑消息机制的选择非常重要。如果忽略了这个方面，那么它可能会损害使用微服务架构的整个目的。在单体应用中，这不是一个问题，因为组件的业务功能是通过函数调用来调用的。另一方面，这是通过松散耦合的基于SOAP的Web服务级别消息功能来实现的。在微服务消息机制的情况下，它应该是简单且轻量级的。
- en: There are no set rules for making a choice between various frameworks or protocols
    for a microservice architecture. However, there are a few points worth considering
    here. First, it should be simple enough to implement, without adding any complexity
    to your system. Second, it should be lightweight enough, keeping in mind the fact
    that the microservice architecture could heavily rely on interservice messaging.
    Let's move ahead and consider our choices for both synchronous and asynchronous
    messaging along with the different messaging formats.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务架构，没有固定的规则来选择各种框架或协议。然而，这里有一些值得考虑的点。首先，它应该足够简单，以便实现，而不会给您的系统增加任何复杂性。其次，它应该足够轻量级，考虑到微服务架构可能会大量依赖服务间消息。让我们继续前进，考虑我们同步和异步消息以及不同消息格式的选择。
- en: Synchronous messaging
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步消息
- en: When a timely response is expected from a service by a system and the system
    waits on it until a response is received from the service, which is synchronous
    messaging. What's left is the most sought-after choice in the case of microservices.
    It is simple and supports HTTP request-response, thereby leaving little room to
    look for an alternative. This is also one of the reasons that most implementations
    of microservices use HTTP (API-based styles).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统期望从服务中获得及时响应，并且系统会等待直到收到服务的响应，这就是同步消息。剩下的就是微服务中最受欢迎的选择。它是简单且支持HTTP请求-响应，因此几乎没有寻找替代方案的空间。这也是为什么大多数微服务的实现都使用HTTP（基于API的风格）的原因之一。
- en: Asynchronous messaging
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步消息
- en: When a system is not immediately expecting a timely response from the service
    and the system can continue processing without blocking on that call, which is
    asynchronous messaging.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统不立即期望从服务中获得及时响应，并且系统可以在不阻塞该调用的情况下继续处理，这就是异步消息。
- en: 'Let''s incorporate this messaging concept into our application and see how
    it would change and look:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个消息概念融入到我们的应用程序中，看看它会如何改变和看起来：
- en: '![](img/638f247e-d806-47ad-a269-0688d56b6108.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/638f247e-d806-47ad-a269-0688d56b6108.png)'
- en: Message formats
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息格式
- en: Over the past few years, working with MVC and the like has got me hooked on
    the JSON format. You could also consider XML. Both formats would be fine on HTTP
    with the API style resource. Binary message formats are also easily available
    in case you need to use one. We are not recommending any particular format; you
    can go ahead with any of the selected message formats.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，使用MVC等工具让我对JSON格式产生了依赖。您也可以考虑XML。这两种格式在API风格资源上都是可以接受的。如果您需要使用二进制消息格式，它们也容易获得。我们不推荐任何特定的格式；您可以选择任何选定的消息格式。
- en: Why should we use microservices?
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么应该使用微服务？
- en: Tremendous patterns and architectures have been explored with some gaining popularity;
    there are others, though, that are losing the battle of internet traffic. With
    each solution having its own advantages and disadvantages, it has become increasingly
    important for companies to quickly respond to fundamental demands, such as scalability,
    high performance, and easy deployment. Any single aspect failing to be fulfilled
    in a cost-effective manner could easily impact large businesses negatively, making
    a big difference between a profitable and non-profitable venture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 已经探索了大量的模式和架构，其中一些获得了流行；然而，还有一些正在失去互联网流量的竞争。由于每个解决方案都有其自身的优缺点，因此公司迅速响应基本需求（如可扩展性、高性能和易于部署）变得越来越重要。任何单一方面未能以成本效益的方式得到满足，都可能对大型企业产生负面影响，从而在盈利和非盈利企业之间造成巨大差异。
- en: This is where we see *microservices* coming to the rescue of enterprise system
    architects. They can ensure their designs against problems mentioned previously,
    with the help of this architectural style. It is also important to consider the
    fact that this objective is met in a cost-effective manner while respecting the
    time involved.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在哪里看到*微服务*帮助企业系统架构师摆脱困境的地方。他们可以利用这种架构风格确保其设计不受先前提到的问题的影响。同时，考虑到所涉及的时间，以成本效益的方式实现这一目标也很重要。
- en: How does the microservice architecture work?
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构是如何工作的？
- en: 'Until now, we have discussed various things about the microservice architecture,
    and we can now depict how the microservice architecture works; we can use any
    combination as per our design approach or bet on a pattern that would fit in it.
    Here are a few points that favor the working of the microservice architecture:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了关于微服务架构的各个方面，现在我们可以描绘微服务架构是如何工作的；我们可以根据我们的设计方法使用任何组合，或者押注一个适合它的模式。以下是一些有利于微服务架构工作的要点：
- en: It's programming of the modern era, where we are expected to follow all SOLID
    principles. It's **object-oriented programming **(**OOP**).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是现代编程，我们期望遵循所有SOLID原则。它是**面向对象编程**（**OOP**）。
- en: It is the best way is to expose the functionality to other or external components
    in a way so that any other programming language will be able to use the functionality
    without adhering to any specific user interfaces, that is, services (web services,
    APIs, rest services, and so on).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是将功能暴露给其他或外部组件的最佳方式，以便任何其他编程语言都能使用该功能，而无需遵循任何特定的用户界面，即服务（Web服务、API、REST服务等）。
- en: The whole system works as per a type of collaboration that is not interconnected
    or interdependent.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个系统按照一种非互联或相互依赖的协作方式工作。
- en: Every component is liable for its own responsibilities. In other words, components
    are responsible for only one functionality.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件都对其自身的责任负责。换句话说，组件只负责一个功能。
- en: It segregates code with a separation concept, and segregated code is reusable.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过分离概念来隔离代码，并且隔离的代码是可重用的。
- en: Advantages of microservices
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的优势
- en: 'Now let''s try to quickly understand where microservices takes a leap ahead
    of the SOA and monolithic architectures:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速了解微服务是如何在SOA和单体架构中取得飞跃的：
- en: 'Cost effective to scale: You don''t need to invest a lot to make the entire
    application scalable. In terms of a shopping cart, we could simply load balance
    the product search module and the order-processing module while leaving out less
    frequently used operation services, such as inventory management, order cancellation,
    and delivery confirmation.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本效益高的扩展性：您不需要投入大量资金来使整个应用具有可扩展性。就购物车而言，我们可以简单地负载均衡产品搜索模块和订单处理模块，同时排除使用频率较低的运营服务，例如库存管理、订单取消和交货确认。
- en: 'Clear code boundaries: This action should match an organization''s departmental
    hierarchies. With different departments sponsoring product development in large
    enterprises, this can be a huge advantage.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的代码边界：这一行动应与组织的部门层级相匹配。在大型企业中，不同的部门资助产品开发，这可以是一个巨大的优势。
- en: 'Easier code changes: The code is done in a way that it is not dependent on
    the code of other modules and is only achieving isolated functionality. If it
    were done right, then the chances of a change in a microservice affecting another
    microservice are very minimal.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的代码更改：代码是以一种方式编写的，它不依赖于其他模块的代码，并且只实现隔离的功能。如果做得正确，那么微服务中的更改影响另一个微服务的可能性非常小。
- en: 'Easy deployment: Since the entire application is more like a group of ecosystems
    that are isolated from each other, deployment could be done one microservice at
    a time, if required. Failure in any one of these would not bring the entire system
    down.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单部署：由于整个应用程序更像是一组相互隔离的生态系统，如果需要，可以一次部署一个微服务。任何一个微服务的失败都不会导致整个系统崩溃。
- en: 'Technology adaptation: You could port a single microservice or a whole bunch
    of them overnight to a different technology without your users even knowing about
    it. And yes, hopefully, you don''t expect us to tell you that you need to maintain
    those service contracts, though.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术适应性：你可以在一夜之间将单个微服务或一大堆微服务迁移到不同的技术，而用户甚至可能都不知道。是的，我们希望你不要期望我们告诉你你需要维护那些服务合同。
- en: 'Distributed system: This comes as implied, but a word of caution is necessary
    here. Make sure that your asynchronous calls are used well and synchronous ones
    are not really blocking the whole flow of information. Use data partitioning well.
    We will come to this a little later, so don''t worry for now.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统：这一点是隐含的，但在这里需要提醒一下。确保你的异步调用被正确使用，而同步调用不会真正阻塞整个信息流。合理使用数据分区。我们稍后会提到这一点，所以现在不用担心。
- en: 'Quick market response: The world being competitive is a definite advantage; as
    otherwise, users tend to quickly lose interest if you are slow to respond to new
    feature requests or adoption of a new technology within your system.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速市场响应：世界竞争激烈是一个明显的优势；否则，如果你对新的功能请求或系统内新技术的采用反应迟缓，用户可能会迅速失去兴趣。
- en: SOA versus microservices
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOA与微服务
- en: You'll get confused between microservices and SOA if you don't have a complete
    understanding of both. On the surface of it, microservices' features and advantages
    sound almost like a slender version of SOA, with many experts suggesting that
    there is, in fact, no need for an additional term, such as **microservices**,
    and that SOA can fulfill all the attributes laid out by microservices. However,
    this is not the case. There is enough difference to isolate them technologically.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完全理解微服务和SOA，你会在两者之间感到困惑。从表面上看，微服务的特性和优势听起来几乎像是SOA的一个精简版本，许多专家建议实际上没有必要使用额外的术语，如**微服务**，SOA可以满足微服务所列出的所有属性。然而，事实并非如此。它们之间有足够的差异，可以在技术上区分开来。
- en: 'The underlying communication system of SOA inherently suffers from the following
    problems:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SOA的底层通信系统固有的存在以下问题：
- en: The fact that a system developed in SOA depends upon its components, which are
    interacting with each other. So no matter how hard you try, it is eventually going
    to face a bottleneck in the message queue.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实是，在SOA中开发出的系统依赖于其相互交互的组件。所以无论你多么努力，它最终都会在消息队列中遇到瓶颈。
- en: Another focal point of SOA is imperative monogramming. With this, we lose the
    path to make a unit of code reusable with respect to OOP.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOA的另一个焦点是命令式单例编程。因此，我们失去了使用面向对象编程（OOP）使代码单元可重用的途径。
- en: We all know that organizations are spending more and more on infrastructure.
    The bigger the enterprise is, the more complex the question of the ownership of
    the application being developed. With an increasing number of stakeholders, it
    becomes impossible to accommodate all of their ever-changing business needs. This
    is where microservices clearly stand apart. Although cloud development is not
    in the current scope of our discussion, it won't harm us to say that the scalability,
    modularity, and adaptability of the microservice architecture can be easily extended
    further with the use of cloud platforms. It's time for a change.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，组织在基础设施上的投入越来越多。企业越大，正在开发的应用程序的所有权问题就越复杂。随着利益相关者的数量不断增加，满足他们不断变化的企业需求变得不可能。这正是微服务明显区别于其他地方的地方。尽管云开发不在我们讨论的当前范围内，但说云平台可以轻松扩展微服务架构的可扩展性、模块化和适应性，并不会对我们造成伤害。是时候改变一下了。
- en: Prerequisites of the microservice architecture
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的先决条件
- en: It is important to understand the resulting ecosystem from the microservice
    architecture implementation. The impact of microservices is not just preoperational
    in nature. So profound will the changes in any organization opting for the microservice
    architecture be that, if they are not well-prepared to handle it, it won't be
    long before advantages turn into disadvantages.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 理解微服务架构实施后的结果生态系统非常重要。微服务的影响不仅仅是预操作性的。对于任何选择微服务架构的组织来说，变化将是如此深刻，以至于如果他们没有做好充分准备来应对，优势很快就会变成劣势。
- en: 'After the adoption of the microservice architecture is agreed upon, it would
    be wise to have the following prerequisites in place:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在同意采用微服务架构之后，明智的做法是确保以下先决条件已经到位：
- en: 'Deployment and QA: Requirements will become more demanding, with a quicker
    turnaround from development requirements. It would require you to deploy and test
    as quickly as possible. If it is just a small number of services, then it would
    not be a problem. However, if the number of services is going up, it could very
    quickly challenge the existing infrastructure and practices. For example, your
    QA and staging environment may no longer suffice to test the number of builds
    that would come back from the development team.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和QA：需求将变得更加严格，开发需求周转速度更快。这要求你尽可能快地进行部署和测试。如果只是少数服务，那么这不会成为问题。然而，如果服务的数量在增加，这可能会很快对现有的基础设施和实践构成挑战。例如，你的QA和预发布环境可能不再足以测试开发团队返回的构建数量。
- en: 'A collaboration platform for the development and operations team: As the application
    goes to the public domain, it won''t be long before the age-old script of dev
    versus QA is played out again. The difference this time would be that the business
    will be at stake. So, you need to be prepared to quickly respond in an automated
    manner to identify the root cause when required.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和运维团队的协作平台：随着应用程序进入公共领域，很快就会再次上演古老的开发与QA之间的对决。这次的不同之处在于，业务将受到威胁。因此，你需要准备好在需要时以自动化的方式快速响应，以确定根本原因。
- en: 'A monitoring framework: With the increasing number of microservices, you would
    quickly need a way to monitor the functioning and health of the entire system
    for any possible bottlenecks or issues. Without any means of monitoring the status
    of the deployed microservices and the resultant business function, it would be
    impossible for any team to take a proactive deployment approach.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控框架：随着微服务数量的增加，你很快就需要一种方法来监控整个系统的运行状况和健康，以发现任何可能的瓶颈或问题。如果没有任何手段来监控已部署微服务的状态和结果业务功能，任何团队都无法采取主动部署方法。
- en: Understanding the problems with the monolithic architectural style
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单体架构风格的问题
- en: 'In this section, we will discuss all the problems with the monolithic .NET
    stack-based application. In a monolithic application, the core problem is this:
    scaling monolithic is difficult. The resultant application ends up having a very
    large code base and poses challenges in regard to maintainability, deployment,
    and modifications.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论基于单体.NET堆栈的应用程序所遇到的所有问题。在单体应用程序中，核心问题是这样的：单体扩展很困难。结果应用程序最终拥有一个非常大的代码库，并在可维护性、部署和修改方面提出了挑战。
- en: Challenges in standardizing a .NET stack
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化.NET堆栈的挑战
- en: 'In monolithic application technology, stack dependency stops the introduction
    of the latest technologies from the outside world. The present stack poses challenges
    as a web service itself suffers from some challenges:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序技术中，堆栈依赖阻止了从外部世界引入最新技术。当前的堆栈本身作为一个网络服务也面临一些挑战：
- en: 'Security: There is no way to identify the user via web services (no clear consensus
    on a strong authentication scheme). Just imagine a banking application sending
    unencrypted data containing user credentials without encryption. All airports,
    cafes, and public places offering free Wi-Fi could easily become victims of increased
    identity theft and other cybercrimes.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性：无法通过网络服务识别用户（没有关于强认证方案的明确共识）。想象一下，一个银行应用程序发送未加密的数据，其中包含用户凭据，而没有加密。所有提供免费Wi-Fi的机场、咖啡馆和公共场所都很容易成为身份盗窃和其他网络犯罪的受害者。
- en: 'Response time: Though the web services themselves provide some flexibility
    in the overall architecture, it quickly diminishes due to the high processing
    time taken by the service itself. So, there is nothing wrong with the web service
    in this scenario. It is a fact that a monolithic application involves huge code;
    complex logic makes the response time of a web service high, and therefore, unacceptable.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间：尽管网络服务本身在整体架构中提供了一些灵活性，但由于服务本身的高处理时间，这种灵活性很快就会减少。因此，在这种场景下，网络服务本身并没有错。事实上，单体应用程序涉及大量的代码；复杂的逻辑使得网络服务的响应时间很高，因此，这是不可接受的。
- en: 'Throughput rate: This is on the higher side, and as a result, hampers subsequent
    operations. A checkout operation relying on a call to the inventory web service
    that has to search for a few million records is not a bad idea. However, when
    the same inventory service feeds the main product searching/browsing for the entire
    portal, it could result in a loss of business. One service call failure out of
    ten calls would mean a 10% lower conversion rate for the business.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量：这处于较高水平，因此会阻碍后续操作。依赖于调用库存网络服务并需要搜索数百万条记录的结账操作并非坏事。然而，当相同的库存服务为整个门户的产品搜索/浏览提供数据时，可能会导致业务损失。在十次调用中，如果有一次服务调用失败，则意味着业务转化率降低10%。
- en: 'Frequent downtime: As the web services are part of the whole monolith ecosystem,
    they are bound to be down and unavailable each time there is an upgrade or an
    application failure. This means that the presence of any B2B dependency from the
    outside world on the application''s web services would further complicate decision-making,
    thereby seeking downtime. This absolutely makes the smaller upgrades of the system
    look expensive; thus, it further increases the backlog of the pending system upgrades.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常性停机：由于网络服务是整个单体生态系统的一部分，它们在每次升级或应用程序故障时必然会出现停机且不可用。这意味着外部世界对应用程序网络服务的任何B2B依赖都会进一步复杂化决策过程，从而寻求停机时间。这绝对使得系统的较小升级看起来成本高昂；因此，它进一步增加了待处理的系统升级积压。
- en: 'Technology adoption: In order to adopt or upgrade a technology stack, it would
    require the whole application to be upgraded, tested, and deployed, since modules
    are interdependent and the entire code base of the project is affected. Consider
    the payment gateway module using a component that requires a compliance-related
    framework upgrade. The development team has no option but to upgrade the framework
    itself and carefully go through the entire code base to identify any code breaks
    preemptively. Of course, this would still not rule out a production crash, but
    this can easily make even the best of the architects and managers sweat and lose
    some sleep.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术采用：为了采用或升级技术堆栈，需要整个应用程序进行升级、测试和部署，因为模块是相互依赖的，整个项目的代码库都会受到影响。考虑使用需要合规性相关框架升级的组件的支付网关模块。开发团队别无选择，只能升级框架本身，并仔细检查整个代码库以预防性地识别任何代码冲突。当然，这仍然不能排除生产崩溃的可能性，但这很容易让即使是最好的架构师和管理者都感到焦虑，甚至失眠。
- en: '**Availability**: A percentage of time during which a service is operating.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用性**：服务运行的时间百分比。'
- en: '**Response** **time**: The time a service takes to respond.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应时间**：服务响应所需的时间。'
- en: '**Throughput**: The rate of processing requests.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**吞吐量**：处理请求的速率。'
- en: Fault tolerance
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容错性
- en: Monolithic applications have high module interdependency as they are tightly
    coupled. The different modules utilize functionality in such an intramodule manner
    that even a single module failure brings the system down due to the cascading
    effect, which is very similar to dominoes falling. We all know that a user not
    getting results for a product search would be far less severe than the entire
    system coming down to its knees.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序具有高度模块间依赖性，因为它们紧密耦合。不同的模块以这种方式利用模块内的功能，以至于即使是单个模块的故障也会由于级联效应而使整个系统崩溃，这与多米诺骨牌倒下的情况非常相似。我们都知道，用户在产品搜索中得不到结果会比整个系统崩溃要轻微得多。
- en: 'Decoupling using web services has been traditionally attempted at the architecture
    level. For database-level strategies, ACID has been relied upon for a long time.
    Let''s examine both these points further:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络服务进行解耦在传统上是在架构层面尝试的。对于数据库级别的策略，长期以来一直依赖于ACID。让我们进一步探讨这两个点：
- en: 'Web services: In the current monolithic application, customer experience is
    degraded due to this very reason. Even as a customer tries to place an order,
    reasons such as the high response time of web services or even a complete failure
    of the service itself results in a failure to place the order successfully. Not
    even a single failure is acceptable, as users tend to remember their last experience
    and assume a possible repeat. Not only does this result in the loss of possible
    sales, but also the loss of future business prospects. Web services'' failures
    can cause a cascading failure in the systems that rely on them.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网服务：在当前的单体应用中，由于这个原因，客户体验受到了影响。即使客户试图下订单，像互联网服务的高响应时间或服务本身的完全失败这样的原因，都会导致无法成功下单。任何一次失败都是不可接受的，因为用户往往会记住他们的最后一次体验并假设可能的重现。这不仅会导致潜在销售的损失，还会导致未来商业前景的损失。互联网服务的故障可能导致依赖它们的系统出现级联故障。
- en: 'ACID: ACID is the acronym for atomicity, consistency, isolation, and durability;
    it''s an important concept in databases. It is in place, but whether it''s a boon
    or bane is to be judged by the sum total of the combined performance. It takes
    care of failures at the database level, and there is no doubt that it does provide
    some insurance against the database errors that creep in. At the same time, every
    ACID operation hampers/delays operations by other components/modules. The point
    at which it causes more harm than benefit needs to be judged very carefully.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACID：ACID是原子性、一致性、隔离性和持久性的缩写；它是数据库中的一个重要概念。它已经到位，但它是福是祸需要根据综合性能来判断。它负责处理数据库级别的故障，并且毫无疑问，它确实提供了一些防范数据库错误的能力。同时，每个ACID操作都会阻碍/延迟其他组件/模块的操作。它造成更多伤害而不是益处的点需要非常仔细地判断。
- en: Scaling
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: Factors such as availability of different means of communication, easy access
    to information, and open world markets are resulting in businesses growing rapidly
    and diversifying at the same time. With this rapid growth of business, there is
    an ever-increasing need to accommodate an increasing client base. Scaling is one
    of the biggest challenges that any business faces while trying to cater to an
    increased user base.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如不同通信手段的可用性、信息的便捷获取和开放的世界市场等因素导致企业迅速增长并多样化。随着业务的快速增长，满足不断增长的客户基础的需求也在不断增加。扩展是任何企业在尝试满足增加的用户基础时面临的最大挑战之一。
- en: '**Scalability** is nothing but the capability of a system/program to handle
    the growth of work better. In other words, scalability is the ability of a system/program
    to scale.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展性**不过是系统/程序更好地处理工作增长的能力。换句话说，可扩展性是系统/程序扩展的能力。'
- en: Before starting the next section, let's discuss and understand scaling in detail,
    as this will be an integral part of our exercise as we work on transitioning from
    monolithic to microservices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下一节之前，让我们详细讨论和理解扩展，因为这将是我们从单体过渡到微服务时的一个重要组成部分。
- en: Scalability of a system is its capability to handle an increasing/increased
    load of work. There are two main strategies or types of scalability in which we
    can scale our application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可扩展性是其处理不断增加/增加的工作负载的能力。我们可以通过两种主要策略或可扩展性类型来扩展我们的应用程序。
- en: Vertical scaling or scale up
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直扩展或向上扩展
- en: In vertical scaling, we analyze our existing application to find the parts of
    the modules that cause the application to slow down due to higher execution time.
    Making the code more efficient could be one strategy so that less memory is consumed.
    This exercise of reducing memory consumption could be for a specific module or
    the whole application. On the other hand, due to obvious challenges involved with
    this strategy, instead of changing the application, we could add more resources
    to our existing IT infrastructure, such as upgrading the RAM or adding more disk
    drives. Both these paths in vertical scaling have a limit for the extent to which
    they can be beneficial. After a specific point in time, the resulting benefit
    will plateau. It is important to keep in mind that this kind of scaling requires
    downtime.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直扩展中，我们分析现有应用程序，以找到由于执行时间较长而使应用程序变慢的模块部分。使代码更高效可能是一种策略，这样就可以消耗更少的内存。这种减少内存消耗的练习可能针对特定的模块或整个应用程序。另一方面，由于这种策略涉及明显的挑战，我们可以在不更改应用程序的情况下，向现有的IT基础设施添加更多资源，例如升级RAM或添加更多磁盘驱动器。垂直扩展的这两条路径都有其有益程度的限制。在某个时间点之后，产生的利益将达到平台期。重要的是要记住，这种类型的扩展需要停机时间。
- en: Horizontal scaling or scale out
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平扩展或扩展到外部
- en: In horizontal scaling, we dig deep into modules that show a higher impact on
    the overall performance for factors such as high concurrency; so this will enable
    our application to serve our increased user base, which is now reaching the million
    mark. We also implement load balancing to process a greater amount of work. The
    option of adding more servers to the cluster does not require downtime, which
    is a definite advantage. Each case is different, so whether the additional costs
    of power, licenses, and cooling are worthwhile, and up to what point, will be
    evaluated on a case-by-case basis.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在水平扩展中，我们深入分析那些由于高并发等因素而对整体性能影响较大的模块；因此，这将使我们的应用程序能够服务不断增长的用户基础，现在用户数量已达到百万级别。我们还实施了负载均衡来处理更多的工作量。向集群中添加更多服务器的选项不需要停机时间，这无疑是一个优势。每个案例都是不同的，因此是否值得投入额外的电力、许可证和冷却成本，以及到什么程度，将根据每个案例进行评估。
- en: Scaling will be covered in detail inChapter 8, *Scaling Microservices*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展将在第8章“扩展微服务”中详细讨论。
- en: Deployment challenges
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署挑战
- en: The current application also has deployment challenges. It is designed as a
    monolithic application, and any change in the order module would require the entire
    application to be deployed again. This is time-consuming and the whole cycle will
    have to be repeated with every change. This means this could be a frequent cycle.
    Scaling could only be a distant dream in such a scenario.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当前应用程序也存在部署挑战。它被设计为一个单体应用程序，任何对顺序模块的更改都要求重新部署整个应用程序。这是耗时且每次更改都必须重复整个周期。这意味着这可能会是一个频繁的周期。在这种情况下，扩展可能只是一个遥远的梦想。
- en: 'As discussed about scaling regarding current applications having deployment
    challenges that require us to deploy the entire assembly, the modules are interdependent,
    and it is a single assembly application of .NET. The deployment of the entire
    application in one go also makes it mandatory to test the entire functionality
    of our application. The impact of such an exercise would be huge:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如同讨论的关于扩展当前应用程序的部署挑战，需要我们部署整个组件，模块之间相互依赖，这是一个单一的.NET组件应用程序。一次性部署整个应用程序也使得测试我们应用程序的整个功能成为强制性的。这种练习的影响将是巨大的：
- en: 'High-risk deployment: Deploying an entire solution or application in one go
    poses a high risk as all modules are going to be deployed even for a single change
    in one of the modules.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高风险部署：一次性部署整个解决方案或应用程序存在高风险，因为即使是对某个模块的单个更改，所有模块都将被部署。
- en: 'Higher testing time: As we have to deploy the complete application, we will
    have to test the functionality of the entire application. We can''t go live without
    testing. Due to higher interdependency, the change might cause a problem in some
    other module.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高的测试时间：由于我们必须部署完整的应用程序，因此我们必须测试整个应用程序的功能。没有测试，我们不能上线。由于高度依赖性，更改可能会在其他模块中引起问题。
- en: 'Unplanned downtime: Complete production deployment needs code to be fully tested
    and hence we need to schedule our production deployment. This is a time-consuming
    task that results in high downtime. Although planned downtime, during this time,
    both business and customers will be affected due to the unavailability of the
    system; this could cause revenue loss to the business.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划外停机时间：完整的生产部署需要代码被完全测试，因此我们需要安排我们的生产部署。这是一个耗时的工作，导致高停机时间。尽管在这个时间段内，由于系统不可用，业务和客户都会受到影响，这可能导致业务收入损失。
- en: 'Production bugs: A bug-free deployment would be the dream of any project manager.
    However, this is far from reality and every team dreads this possibility. Monolithic
    applications are no different from this scenario and the resolution of production
    bugs is easier said than done. The situation can only become more complex with
    some previous bug remaining unresolved.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产中的错误：任何项目经理的梦想都是无错误的部署。然而，这远非现实，每个团队都害怕这种可能性。单体应用程序与这种场景并无不同，生产错误的解决比说起来容易做起来难。如果一些之前的错误尚未解决，情况可能会变得更加复杂。
- en: Organizational alignment
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织对齐
- en: In a monolithic application, having a large code base is not the only challenge
    that you'll face. Having a large team to handle such a code base is one more problem
    that will affect the growth of the business and application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序中，拥有庞大的代码库并不是你将面临的唯一挑战。拥有一个庞大的团队来处理这样的代码库也是另一个会影响业务和应用程序增长的问题。
- en: 'Same goal: In a team, all the team members have the same goal, which is timely
    and bug-free delivery at the end of each day. However, having a large code base
    and current, the monolithic architectural style will not be a comfortable feeling
    for the team members. With team members being interdependent due to the interdependent
    code and associated deliverables, the same effect that is experienced in the code
    is present in the development team as well. Here, everyone is just scrambling
    and struggling to get the job done. The question of helping each other out or
    trying something new does not arise. In short, the team is not a self-organizing
    team.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样的目标：在一个团队中，所有团队成员都有相同的目标，那就是在每天结束时及时且无错误地交付。然而，拥有庞大的代码库和当前的单一架构风格，对于团队成员来说并不会感到舒适。由于代码和相关的交付成果相互依赖，开发团队中也会出现同样的效果。在这里，每个人都只是在匆忙和努力地完成工作。互相帮助或尝试新事物的想法不会出现。简而言之，这个团队不是一个自我组织的团队。
- en: 'Roy Osherove defined three stages of a team in his book, *Teamleader*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伊·奥斯霍夫在他的书《团队领导者》中定义了团队的三个阶段：
- en: '**Survival phase**: No time to learn.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**生存阶段**：没有时间学习。'
- en: '**Learning phase**: Learning to solve your own problems.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习阶段**：学习解决自己的问题。'
- en: '**Self-organizing phase**: Facilitate, experiment.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**自我组织阶段**：促进，实验。'
- en: 'A different perspective: The development team takes too much time for deliverables
    due to reasons, such as feature enhancement, bug fixes, or module interdependency
    stopping easy development. The QA team is dependent upon the development team
    and the dev team has its own problems. The QA team is stuck once developers start
    working on bugs, fixes, or feature enhancements. There is no separate environment
    or build available for QA to proceed with their testing. This delay hampers overall
    delivery, and customers or end users would not get the new features or fixes on
    time.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的视角：由于功能增强、错误修复或模块相互依赖等原因，开发团队花费太多时间来完成交付成果。QA团队依赖于开发团队，而开发团队也有自己的问题。当开发人员开始处理错误、修复或功能增强时，QA团队就会陷入困境。没有为QA提供单独的环境或构建来进行测试。这种延迟阻碍了整体交付，客户或最终用户将无法及时获得新功能或修复。
- en: Modularity
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化
- en: In respect to our monolithic application, where we may have an Order module,
    a change in the module *Orders* affects the module *Stock* and so on. It is the
    absence of modularity that has resulted in such a condition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的单体应用程序而言，我们可能有一个订单模块，模块*订单*的变化会影响模块*库存*等等。正是模块化的缺失导致了这种状况。
- en: This also means that we can't reuse the functionality of a module within another
    module. The code is not decomposed into structured pieces that could be reused
    to save time and effort. There is no segregation within the code modules, and
    hence, no common code is available.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们无法在另一个模块中重用模块的功能。代码没有被分解成可以重用以节省时间和精力的结构化部分。代码模块之间没有隔离，因此没有可用的通用代码。
- en: Business is growing and its customers are growing by leaps and bounds. New or
    existing customers from different regions have different preferences when it comes
    to the use of the application. Some like to visit the website, but others prefer
    to use mobile apps. The system is structured in a way that we can't share the
    components across a website and a mobile app. This makes introducing a mobile/device
    app for the business a challenging task. Business is affected as in such scenarios
    the company loses out on customers who prefer mobile apps.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 业务正在增长，其客户也在飞速增长。来自不同地区的新的或现有客户在应用的使用上有着不同的偏好。有些人喜欢访问网站，但其他人更喜欢使用移动应用。系统结构是这样的，我们无法在网站和移动应用之间共享组件。这使得为业务引入移动/设备应用成为一项挑战性任务。在这种情况下，公司会失去那些偏好移动应用的客户。
- en: The difficulty in replacing the component's application is using third-party
    libraries, an external system such as payment gateways, and an external order-tracking
    system. It is a tedious job to replace the old components in the currently styled
    monolithic architectural application. For example, if we consider upgrading the
    library of our module that is consuming an external order-tracking system, then
    the whole change would prove to be very difficult. Also, it would be an intricate
    task to replace our payment gateway with another one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 替换组件应用中的困难在于使用第三方库、外部系统（如支付网关）和外部订单跟踪系统。在目前风格的单体架构应用中替换旧组件是一项繁琐的工作。例如，如果我们考虑升级我们模块的库，该库正在消耗外部订单跟踪系统，那么整个变更将证明是非常困难的。此外，用另一个支付网关替换我们的支付网关也将是一项复杂的任务。
- en: In any of the preceding scenarios, whenever we upgraded the components, we upgraded
    everything within the application, which called for a complete testing of the
    system and required a lot of downtime. Apart from this, the upgrade would possibly
    result in the form of production bugs, which would require you to repeat the whole
    cycle of development, testing, and deployment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何上述场景中，每次我们升级组件时，都会升级应用程序中的所有内容，这要求对系统进行完全测试，并需要大量的停机时间。除此之外，升级可能会以生产中的错误形式出现，这将需要你重复整个开发、测试和部署的周期。
- en: Big database
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大型数据库
- en: 'Our current application has a mammoth database containing a single schema with
    plenty of indexes. This structure poses a challenging job when it comes down to
    fine-tuning the performance:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的应用程序拥有一个庞大的数据库，包含单一架构和大量的索引。这种结构在调整性能时提出了挑战：
- en: 'Single schema: All the entities in the database are clubbed under a single
    schema named *dbo*. This again hampers business due to the confusion with the single
    schema regarding various tables that belong to different modules; for example,
    customer and supplier tables belong to the same schema, that is, *dbo*.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一架构：数据库中的所有实体都被归类到一个名为 *dbo* 的单一架构下。这又因为与单一架构相关的各种表属于不同的模块而阻碍了业务；例如，客户和供应商表属于同一个架构，即
    *dbo*。
- en: 'Numerous stored procedures: Currently, the database has a large number of stored
    procedures, which also contain a sizeable chunk of the business logic. Some of
    the calculations are being performed within the stored procedures. As a result,
    these stored procedures prove to be a baffling task to tend to when the time comes
    to optimize them or break them down into smaller units.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量众多的存储过程：目前，数据库中拥有大量的存储过程，这些过程也包含了相当一部分的业务逻辑。一些计算是在存储过程中进行的。因此，当需要优化或将其分解成更小的单元时，这些存储过程变得难以处理。
- en: Whenever deployment is planned, the team will have to look closely at every
    database change. This, again, is a time-consuming exercise and many times would
    turn out to be even more complex than the build and deployment exercise itself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在计划部署时，团队必须仔细审查每一个数据库变更。这又是一项耗时的工作，很多时候甚至比构建和部署本身还要复杂。
- en: Prerequisites for microservices
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的先决条件
- en: To understand better, let's take up an imaginary example of FlixOne Inc. With
    this example as our base, let's discuss all the concepts in detail and see what
    it looks like to be ready for microservices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们以 FlixOne Inc. 的一个虚构例子为例。以这个例子为基础，让我们详细讨论所有概念，并看看为微服务做好准备是什么样的。
- en: 'FlixOne is an e-commerce player (selling books) that is spread all over India.
    They are growing at a very fast pace and diversifying their business at the same
    time. They have built their existing system on the .NET framework, and it is traditional
    three-tier architecture. They have a massive database that is central to this
    system, and there are peripheral applications in their ecosystem. One such application
    is for their sales and logistics team, and it happens to be an Android app. These
    applications connect to their centralized data center and face performance issues.
    FlixOne has an in-house development team supported by external consultants. Refer
    to the following diagram:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne是一家遍布印度的电子商务玩家（销售书籍）。他们以非常快的速度增长，并在同时多元化他们的业务。他们基于.NET框架构建了现有的系统，这是一个传统的三层架构。他们有一个庞大的数据库，是这个系统的核心，并且在其生态系统中还有外围应用。其中一个应用是为他们的销售和物流团队设计的，碰巧是一个Android应用。这些应用连接到他们的集中数据中心，并面临性能问题。FlixOne有一个内部开发团队，并得到外部顾问的支持。参看以下图表：
- en: '![](img/d11753da-6849-4002-b694-3c4fdbd1e65f.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![应用功能概述](img/d11753da-6849-4002-b694-3c4fdbd1e65f.png)'
- en: 'The preceding diagram depicts a broader sense of our current application, which
    is a single .NET assembly application. Here we have the user interfaces we use
    for search, order, products, tracking order, and checkout. Now look at the following
    diagram:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描述了我们对当前应用的更广泛的理解，这是一个单一的.NET程序集应用。在这里，我们有用于搜索、订单、产品、跟踪订单和结账的用户界面。现在看看下面的图表：
- en: '![](img/4a389244-b808-4d0d-a43b-8e892ac8df1c.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![FlixOne应用架构](img/4a389244-b808-4d0d-a43b-8e892ac8df1c.png)'
- en: The preceding diagram depicts our **Shopping** **cart** module only. The application
    is built with C#, MVC5, and Entity Framework, and it has a single project application.
    This image is just a pictorial overview of the architecture of our application.
    This application is web-based and can be accessed from any browser. Initially,
    any request that uses the HTTP protocol will land on the user interface that is
    developed using MVC5 and JQuery. For cart activities, the UI interacts with the
    **Shopping cart** module, which is nothing but a business logic layer that further
    talks with the database layer (written in C#); data is persisted within the database
    (SQL Server 2008R2).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表仅描述了我们的**购物车**模块。该应用是用C#、MVC5和Entity Framework构建的，并且是一个单一项目应用。这张图片只是我们应用架构的示意图。这个应用是基于Web的，可以通过任何浏览器访问。最初，任何使用HTTP协议的请求都会落在使用MVC5和JQuery开发的用户界面上。对于购物车活动，UI与**购物车**模块交互，该模块实际上是一个业务逻辑层，它进一步与数据库层（用C#编写）通信；数据在数据库（SQL
    Server 2008R2）中持久化。
- en: Functional overview of the application
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用功能概述
- en: 'Here we are going to understand the functional overview of the FlixOne bookstore
    application. This is only for the purpose of visualizing our application. The
    following is the simplified functional overview of the application until Shopping
    cart:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将了解FlixOne书店应用的功能概述。这只是为了可视化我们的应用。以下是从购物车到简化的功能概述的应用。
- en: '![](img/00ff0f90-44cd-479f-a584-90d81d3bf0fc.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![应用架构概述](img/00ff0f90-44cd-479f-a584-90d81d3bf0fc.png)'
- en: In the current application, the customer lands on the home page, where they
    see featured/highlighted books. They have the option to search for a book item
    if they do not get their favorite one. After getting the desired result, the customer
    can choose book items and add them to their shopping cart. Customers can verify
    the book items before the final checkout. As soon as the customer decides to check
    out, the existing cart system redirects them to an external payment gateway for
    the specified amount you need to pay for the book items in the shopping cart.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的应用中，客户首先进入主页，在那里他们可以看到特色/突出显示的书籍。如果他们没有找到喜欢的书籍，他们可以选择搜索书籍项目。在得到期望的结果后，客户可以选择书籍项目并将它们添加到他们的购物车中。在最终结账之前，客户可以验证书籍项目。一旦客户决定结账，现有的购物车系统就会将他们重定向到外部支付网关，以支付购物车中所需支付的书籍项目的金额。
- en: As discussed previously, our application is a monolithic application; it is
    structured to be developed and deployed as a single unit. This application has
    a large code base that is still growing. Small updates need to deploy the whole
    application at once.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的应用是一个单体应用；它被构建为作为一个单一单元开发和部署。这个应用有一个庞大的代码库，仍在增长。小的更新需要一次性部署整个应用。
- en: Solutions for current challenges
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前挑战的解决方案
- en: Business is growing rapidly, so we decide to open our e-commerce website in
    20 more cities; however, we are still facing challenges with the existing application
    and struggling to serve the existing user base properly. In this case, before
    we start the transition, we should make our monolithic application ready for its transition
    to microservices.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 业务正在迅速增长，因此我们决定在另外20个城市开设我们的电子商务网站；然而，我们仍在面对现有应用程序的挑战，并且难以适当地服务现有用户群。在这种情况下，在我们开始过渡之前，我们应该使我们的单体应用程序准备好向微服务过渡。
- en: 'In the very first approach, the **Shopping cart** module will be segregated
    into smaller modules, then you''ll be able to make these modules interact with
    each other as well as external or third-party software:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方法中，**购物车**模块将被分割成更小的模块，然后你将能够使这些模块相互交互，以及与外部或第三方软件交互：
- en: '![](img/a4add087-5d56-44cd-aecc-1553d1a1ae19.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4add087-5d56-44cd-aecc-1553d1a1ae19.png)'
- en: This proposed solution is not sufficient for our existing application, though
    developers would be able to divide the code and reuse it. However, the internal
    processing of the business logic will remain the same without any change in the
    way it would interact with the UI or the database. The new code will interact
    with the UI and the database layer with the database still remaining as the same
    old single database. With our database remaining undivided and as tightly coupled
    layers, the problems of having to update and deploy the whole code base will still
    remain. So this solution is not suitable for resolving our problem.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开发人员能够分割代码并重用它，但这个提出的解决方案并不足以解决我们现有的应用程序问题。然而，业务逻辑的内部处理将保持不变，而不会改变它与UI或数据库交互的方式。新的代码将与UI和数据库层交互，而数据库仍然保持为同一个旧的单一数据库。由于我们的数据库保持未分割并且紧密耦合的层，必须更新和部署整个代码库的问题仍然存在。因此，这个解决方案不适合解决我们的问题。
- en: Handling deployment problems
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理部署问题
- en: In the preceding section, we discussed the deployment challenges we will face
    with the current .NET monolithic application. In this section, let's take a look
    at how we can overcome these challenges by making or adapting a few practices
    within the same .NET stack.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了我们将面临的当前.NET单体应用程序的部署挑战。在本节中，让我们看看我们如何通过在同一个.NET堆栈内创建或适应一些实践来克服这些挑战。
- en: With our .NET monolithic application, our deployment is made up of XCOPY deployments.
    After dividing our modules into different submodules, we can adapt to deployment
    strategies with the help of these. We can simply deploy our business logic layer
    or some common functionality. We can adapt to continuous integration and deployment.
    The XCOPY deployment is a process where all the files are copied to the server,
    mostly used for web projects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的.NET单体应用程序中，我们的部署由XCOPY部署组成。在将我们的模块划分为不同的子模块后，我们可以借助这些策略适应部署策略。我们可以简单地部署我们的业务逻辑层或一些通用功能。我们可以适应持续集成和部署。XCOPY部署是一个将所有文件复制到服务器的过程，主要用于Web项目。
- en: Making much better monolithic applications
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作更好的单体应用程序
- en: We understand all the challenges with our existing monolithic application. We
    have to serve better with our new growth. As we are growing widely, we can't miss
    the opportunity to get new customers. If we miss fixing any challenge, then we
    would lose business opportunities as well. Let's discuss a few points to solve
    these problems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解我们现有单体应用程序的所有挑战。我们必须以更好的方式为新增长服务。随着我们广泛地增长，我们不能错过吸引新客户的机会。如果我们错过解决任何挑战，那么我们就会失去商业机会。让我们讨论一些解决这些问题的观点。
- en: Introducing dependency injections
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍依赖注入
- en: Our modules are interdependent, so we are facing issues, such as reusability
    of code and unresolved bugs, due to changes in one module. These are deployment
    challenges. To tackle these issues, let's segregate our application in such a
    way that we will be able to divide modules into submodules. We can divide our
    `Order` module in such a way that it would implement the interface, and this can
    be initiated from the constructor. Here is a small code snippet that shows how
    we can apply this in our existing monolithic application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模块相互依赖，因此由于一个模块的变化，我们面临着诸如代码重用性和未解决的错误等问题。这些都是部署挑战。为了解决这些问题，让我们将应用程序分割成这样的方式，以便我们可以将模块划分为子模块。我们可以将我们的`订单`模块分割成这样的方式，使其能够实现接口，并且这可以从构造函数中启动。以下是一个小的代码片段，展示了我们如何在现有的单体应用程序中应用这一点。
- en: 'Here is a code example that shows our `Order` class, where we use the constructor
    injection:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，展示了我们的`Order`类，其中我们使用了构造函数注入：
- en: '[PRE0]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The inversion of control, or IoC, is nothing but a way in which objects do not
    create other objects on whom they rely to do their work.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转，或IoC，不过是对象不创建它们依赖来完成工作的其他对象的一种方式。
- en: In the preceding code snippet, we abstracted our `Order` module in such a way
    that it could use the `IOrder` interface. Afterward, our `Order` class implements
    the `IOrder` interface, and with the use of inversion of control, we create an
    object, as this is resolved automatically with the help of inversion of control.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们以这种方式抽象了我们的`Order`模块，使其能够使用`IOrder`接口。之后，我们的`Order`类实现了`IOrder`接口，并且通过使用控制反转，我们创建了一个对象，因为这是通过控制反转自动解决的。
- en: 'Furthermore, the code snippets of `IOrderRepository` and `OrderRepository` are
    as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`IOrderRepository`和`OrderRepository`的代码片段如下：
- en: '[PRE1]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we are trying to showcase how our `Order` module gets abstracted. In the
    preceding code snippet, we return default values for our order just to demonstrate
    the solution to the actual problem.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们试图展示我们的`Order`模块是如何被抽象的。在前面的代码片段中，我们只为订单返回默认值，只是为了演示实际问题的解决方案。
- en: 'Finally, our presentation layer (the MVC controller) will use the available
    methods, as shown in the following code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的表示层（MVC控制器）将使用以下代码片段中所示的方法：
- en: '[PRE2]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is a class diagram that depicts how our interfaces and classes
    are associated with each other and how they expose their methods, properties,
    and so on:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类图展示了我们的接口和类是如何相互关联的，以及它们如何公开它们的方法、属性等等：
- en: '![](img/e9cc6a5f-cd04-4cdc-b38b-9ebc6f37e301.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9cc6a5f-cd04-4cdc-b38b-9ebc6f37e301.png)'
- en: Here again, we used the constructor injection, where `IOrder` passed and got
    the `Order` class initialized; hence, all the methods are available within our
    controller.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用了构造函数注入，其中`IOrder`传递并初始化了`Order`类；因此，所有方法都在我们的控制器中可用。
- en: 'By achieving this, we would overcome a few problems, such as:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这一点，我们将克服一些问题，例如：
- en: 'Reduced module dependency: With the introduction of `IOrder` in our application,
    we are reducing the interdependency of the `Order` module. This way, if we are
    required to add or remove anything to/from this module, then other modules would
    not be affected, as `IOrder` is only implemented by the `Order` module. Let''s
    say we want to make an enhancement to our `Order` module; it would not affect
    our `Stock` module. This way, we reduce module interdependency.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少模块依赖：在我们的应用程序中引入`IOrder`后，我们正在减少`Order`模块的相互依赖性。这样，如果我们需要向此模块添加或从中删除任何内容，则其他模块不会受到影响，因为`IOrder`仅由`Order`模块实现。比如说，我们想要增强我们的`Order`模块；这不会影响我们的`Stock`模块。这样，我们减少了模块间的依赖性。
- en: 'Introducing code reusability: If you are required to get the order details
    of any of the application modules, you can easily do so using the `IOrder` type.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入代码复用：如果您需要获取任何应用程序模块的订单详情，您可以使用`IOrder`类型轻松做到这一点。
- en: 'Improvements in code maintainability: We have divided our modules into submodules
    or classes and interfaces now. We can now structure our code in such a manner
    that all the types, that is, all the interfaces, are placed under one folder and
    follow the suit for the repositories. With this structure, it would be easier
    for us to arrange and maintain code.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可维护性的改进：我们现在已经将我们的模块划分为子模块或类和接口。现在我们可以以这种方式组织我们的代码，即所有类型，即所有接口，都放在一个文件夹下，并为存储库遵循同样的模式。有了这种结构，我们将更容易安排和维护代码。
- en: 'Unit Testing: Our current monolithic application does not have any kind of
    unit testing. With the introduction of interfaces, we can now easily perform unit
    testing and adopt the system of test-driven development with ease.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：我们当前的单一应用程序没有任何类型的单元测试。随着接口的引入，我们现在可以轻松地进行单元测试，并轻松采用测试驱动开发系统。
- en: Database refactoring
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库重构
- en: 'As discussed in the preceding section, our application database is huge and
    depends on a single schema. This huge database should be considered while refactoring.
    We will go for this as:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的应用程序数据库很大，依赖于单一模式。在重构时，应考虑这个庞大的数据库。我们将这样做：
- en: 'Schema correction: In general practice (not required), our schema depicts our
    modules. As discussed in previous sections, our huge database has a single schema,
    that is *dbo* now, and every part of the code or table should not be related to
    *dbo*. There might be several modules that will interact with specific tables.
    For example, our `Order` module should contain some related schema name, such
    as `Order`. So whenever we need to use the table, we can use them with their own
    schema instead of a general *dbo* schema. This will not impact any functionality
    related to how data would be retrieved from the database. But it will have structured
    or arranged our tables in such a way that we would be able to identify and correlate
    each and every table with their specific modules. This exercise will be very helpful
    while we are in the stage of transitioning a monolithic application to microservices. Refer
    to the following image:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式修正：在一般实践中（不是必需的），我们的模式描述了我们的模块。如前所述，我们庞大的数据库有一个单一的方案，即现在的*dbo*，代码或表的每一部分都不应与*dbo*相关。可能有几个模块将与特定的表交互。例如，我们的`Order`模块应包含一些相关的模式名称，如`Order`。因此，每次我们需要使用表时，我们可以使用它们自己的模式而不是通用的*dbo*模式。这不会影响任何与从数据库中检索数据相关的功能。但它将以结构化或组织的方式排列我们的表，这样我们就能识别并关联每个表及其特定的模块。当我们处于将单体应用过渡到微服务阶段时，这项练习将非常有帮助。参见图示：
- en: '![](img/a1b50f7f-e505-439c-9769-d9a94c28a4ca.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1b50f7f-e505-439c-9769-d9a94c28a4ca.png)'
- en: In the preceding figure, we see how the database schema is separated logically.
    It is not separated physically—our **Order Schema** and **Stock Schema** belong
    to the same database. So here we separate the database schema logically, not physically.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到数据库模式是如何在逻辑上分离的。它并不是在物理上分离——我们的**订单模式**和**库存模式**属于同一个数据库。因此，在这里我们在逻辑上而不是在物理上分离数据库模式。
- en: We can also take an example of our users—not all users are admin or belong to
    a specific zone, area, or region. But our user table should be structured in such
    a way that we should be able to identify the users by the table name or the way
    they are structured. Here we can structure our user table on the basis of regions.
    We should map our user table to a region table in such a way it should not impact
    or lay any changes in the existing code base.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以我们的用户为例——并非所有用户都是管理员或属于特定的区域、地区或区域。但我们的用户表应该以这样的方式组织，即我们应该能够通过表名或它们的结构来识别用户。在这里，我们可以根据地区来组织我们的用户表。我们应该将用户表映射到区域表，这样它就不会影响或对现有的代码库造成任何变化。
- en: 'Moving business logic to code from stored procedures: In the current database,
    we have thousands of lines of Stored Procedure with a lot of business logic. We
    should move the business logic to our codebase. In our monolithic application,
    we are using Entity Framework; here we can avoid the creation of stored procedures.
    We can incorporate all of our business logic to code.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将业务逻辑从存储过程迁移到代码：在当前数据库中，我们有数千行存储过程，其中包含大量的业务逻辑。我们应该将业务逻辑移动到我们的代码库中。在我们的单体应用中，我们使用Entity
    Framework；在这里，我们可以避免创建存储过程。我们可以将所有的业务逻辑整合到代码中。
- en: Database sharding and partitioning
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库分片和分区
- en: 'Between database sharding and partitioning, we can go with database sharding,
    where we will break it into smaller databases. These smaller databases will be
    deployed on a separate server:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库分片和分区之间，我们可以选择数据库分片，这样我们将将其分解成更小的数据库。这些较小的数据库将部署在单独的服务器上：
- en: '![](img/08fd7ec2-279c-422a-b8dc-812dfe6127b2.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08fd7ec2-279c-422a-b8dc-812dfe6127b2.png)'
- en: In general, database sharding is simply defined as a *shared-nothing* partitioning
    scheme for large databases. This way, we can achieve a new level of high performance
    and scalability. Sharding comes from *shard* and spreading, which means dividing
    a database into chunks (shards) and spreading to different servers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据库分片被简单地定义为大型数据库的*无共享*分区方案。这样，我们可以达到一个新的高性能和可扩展性水平。分片来自*shard*（碎片）和分散，这意味着将数据库分成块（碎片）并分散到不同的服务器。
- en: 'The preceding diagram is a pictorial overview of how our database is divided
    into smaller databases. Take a look at the following diagram:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示概述了我们的数据库是如何被划分为更小的数据库的。请看以下图示：
- en: '![](img/c8dc4d8d-b6ef-4f07-9a30-cc7e5eaa49a1.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8dc4d8d-b6ef-4f07-9a30-cc7e5eaa49a1.png)'
- en: DevOps culture
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps文化
- en: 'In the preceding sections, we discussed the challenges and problems with the
    team. Here, we propose a solution to the DevOps team: the collaboration of the
    development team with another operational team should be emphasized. We should
    set up a system where development, QA, and the infrastructure teamwork in collaboration.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了团队面临的挑战和问题。在这里，我们为 DevOps 团队提出一个解决方案：强调开发团队与其他运营团队的协作。我们应该建立一个系统，其中开发、质量保证和基础设施团队可以协作工作。
- en: Automation
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化
- en: Infrastructure setup can be a very time-consuming job; developers would remain
    idle while the infrastructure is being readied for them. They will take some time
    before joining the team and contributing. The process of infrastructure setup
    should not stop a developer from becoming productive, as it would reduce overall
    productivity. This should be an automated process. With the use of Chef or PowerShell,
    we can easily create our virtual machines and quickly ramp up the developer count
    as and when required. This way, our developer can be ready to start the work on
    day one of joining the team.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施设置可能是一个非常耗时的工作；当基础设施为他们准备时，开发者将保持空闲。他们将在加入团队并做出贡献之前花费一些时间。基础设施设置的过程不应该阻止开发者变得高效，因为这会降低整体生产力。这应该是一个自动化的过程。使用
    Chef 或 PowerShell，我们可以轻松创建我们的虚拟机，并在需要时快速增加开发者数量。这样，我们的开发者可以在加入团队的当天开始工作。
- en: Chef is a DevOps tool that provides a framework to automate and manage your
    infrastructure.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 是一个 DevOps 工具，它提供了一个框架来自动化和管理你的基础设施。
- en: PowerShell can be used to create our Azure machines and to set up TFS.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 可以用来创建我们的 Azure 机器并设置 TFS。
- en: Testing
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'We are going to introduce automated testing as a solution to our prior problems,
    those we faced while testing during deployment. In this part of the solution,
    we have to divide our testing approach as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算将自动化测试作为解决我们先前问题的方案，这些问题是在部署期间测试时遇到的。在这个解决方案的部分，我们必须将我们的测试方法划分为以下几方面：
- en: Adopt **Test-Driven Development **(**TDD**). With TDD, a developer is required
    to test his or her own code. The test is nothing but another piece of code that
    could validate whether the functionality is working as intended. If any functionality
    is found to not satisfy the test code, the corresponding unit test fails. This
    functionality can be easily fixed, as you know this is where the problem is. In
    order to achieve this, we can utilize frameworks such as MS test or unit tests.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用 **测试驱动开发（TDD**）。使用 TDD，开发者需要测试自己的代码。测试不过是一段代码，可以验证功能是否按预期工作。如果发现任何功能不符合测试代码，相应的单元测试就会失败。由于你知道问题所在，因此可以轻松修复此功能。为了实现这一点，我们可以利用如
    MS 测试或单元测试等框架。
- en: The QA team can use scripts to automate their tasks. They can create scripts
    by utilizing QTP or the Selenium framework.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量保证团队可以使用脚本来自动化他们的任务。他们可以通过使用 QTP 或 Selenium 框架来创建脚本。
- en: Versioning
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: The current system does not have any kind of versioning system, so there is
    no way to revert if something happens during a change. To resolve this issue,
    we need to introduce a version control mechanism. In our case, this should be
    either TFS or Git. With the use of version control, we can now revert to our change
    in case it is found to break some functionality or introduce any unexpected behavior
    in the application. We now have the capability of tracking the changes being made
    by the team members working on this application, at an individual level. However,
    in the case of our monolithic application, we did not have the capability of doing
    this.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当前系统没有任何版本控制系统，因此在变更过程中发生问题时无法回滚。为了解决这个问题，我们需要引入版本控制机制。在我们的情况下，这应该是 TFS 或 Git。使用版本控制，我们现在可以在发现更改破坏了某些功能或引入了任何意外行为时回滚更改。我们现在有能力跟踪在此应用程序上工作的团队成员所做的更改，达到个人层面。然而，在我们的单体应用程序中，我们没有这种能力。
- en: Deployment
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: In our application, deployment is a huge challenge. To resolve this, we introduce
    **Continuous Integration **(**CI**). In this process, we need to set up a CI server.
    With the introduction of CI, the entire process is automated. As soon as the code
    is checked in by any team member, using version control TFS or Git, in our case,
    the CI process kicks into action. It ensures that the new code is built and unit
    tests are run along with the integration test. In either scenarios of a successful
    build or otherwise, the team is alerted to the outcome. This enables the team
    to quickly respond to the issue.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，部署是一个巨大的挑战。为了解决这个问题，我们引入了**持续集成（CI**）。在这个过程中，我们需要设置一个 CI 服务器。随着 CI
    的引入，整个过程实现了自动化。一旦任何团队成员通过版本控制 TFS 或 Git（在我们的案例中）将代码提交，CI 过程就会启动。它确保新代码被构建，并且运行单元测试以及集成测试。在成功构建或失败的情况下，团队都会被通知结果。这使得团队能够快速响应问题。
- en: Next we move to continuous deployment. Here we introduce various environments,
    namely a development environment, staging environment, QA environment, and so
    on. Now, as soon as the code is checked in by any team member, CI kicks into action.
    It invokes the unit/integration test suits, builds the system, and pushes it out
    to the various environments we have set up. This way, the turnaround time of the
    development team to provide a suitable build for QA is reduced to minimal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向持续部署。在这里，我们引入了各种环境，例如开发环境、预发布环境、QA 环境，等等。现在，一旦任何团队成员将代码提交，CI 就会启动。它调用单元/集成测试套件，构建系统，并将其推送到我们已设置的各种环境中。这样，开发团队提供适合
    QA 的构建的周转时间就缩短到了最小。
- en: Identifying decomposition candidates within monolithic
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单体架构中识别分解候选者
- en: We have now clearly identified the various problems that the current FlixOne
    application architecture and its resultant code are posing for the development
    team. Also, we understand which business challenges the development team is not
    able to take up and why.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经清楚地识别出当前 FlixOne 应用程序架构及其产生的代码对开发团队所提出的各种问题。此外，我们也理解了开发团队无法承担哪些商业挑战以及原因。
- en: 'It is not that the team is not capable enough—it is just the code. Let''s move
    ahead and check what would be the best strategy to zero in on for the various
    parts of the FlixOne application that we need to move to the microservice-styled
    architecture. You should know that you have a candidate with a monolith architecture,
    which poses problems in one of the following areas:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 并非团队能力不足——问题在于代码。让我们继续前进，看看针对我们需要迁移到微服务架构的 FlixOne 应用程序各个部分的最佳策略是什么。你应该知道，你有一个单体架构的候选者，它会在以下某个领域引起问题：
- en: 'Focused deployment: Although this comes at the final stage of the whole process,
    it demands more respect and rightly so. It is important to understand here that
    this factor shapes and defines the whole development strategy from the very initial
    stages of identification and design. Here''s an example of this: the business
    is asking you to resolve two problems of equal importance. One of the issues might
    require you to perform testing for many more associated modules, and the resolution
    for the other might allow you to get away with limited testing. Having to make
    such a choice would be wrong. A business shouldn''t have the option of making
    such a choice.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点部署：尽管这在整个过程的最后阶段，但它确实需要更多的尊重，这是理所当然的。在这里，重要的是要理解这个因素从识别和设计的初始阶段开始就塑造和定义了整个开发策略。以下是一个例子：业务要求你解决两个同等重要的问题。其中一个问题可能需要你对更多相关模块进行测试，而另一个问题的解决方案可能允许你进行有限的测试。做出这样的选择是错误的。业务不应该有做出这种选择的权利。
- en: 'Code complexity: Having smaller teams is the key here. You should be able to
    assign small development teams for a change that is associated with a single functionality.
    Small teams comprise one or two members. Any more than this and a project manager
    will be needed. This means that something is more interdependent across modules
    than it should be.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂性：这里的关键是拥有较小的团队。你应该能够为与单个功能相关的更改分配小型开发团队。小型团队由一到两名成员组成。如果超过这个规模，就需要项目经理。这意味着模块之间的相互依赖性比应有的要强。
- en: 'Technology adoption: You should be able to upgrade components to a newer version
    or a different technology without breaking stuff. If you have to think about the
    components that depend on it, you have more than one candidate. Even if you have
    to worry about the modules that this component depends upon, you still have more
    than one candidate. I remember one of my clients who had a dedicated team to test
    out whether the technology being released was a suitable candidate for their needs.
    I learned later that they would actually port one of the modules and measure the
    performance impact, effort requirement, and turnaround time of the whole system.
    I don''t agree with this, though.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术采用：你应该能够升级组件到新版本或不同技术，而不会破坏其他东西。如果你必须考虑依赖它的组件，你就有不止一个候选者。即使你必须担心这个组件所依赖的模块，你仍然有不止一个候选者。我记得我的一个客户有一个专门的团队来测试即将发布的技术是否适合他们的需求。后来我了解到，他们实际上会移植其中一个模块，并测量整个系统的性能影响、努力需求和周转时间。不过，我并不认同这一点。
- en: 'High resources: In my opinion, everything in a system, from memory, CPU time,
    and I/O requirements, should be considered a module. If any one of the modules
    spends more time, and/or more frequently, it should be singled out. In any operation
    that involves higher-than-normal memory, the processing time blocks the delay
    and the I/O keeps the system waiting; this would be good in our case.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高资源消耗：在我看来，系统中的每一件事，从内存、CPU 时间和 I/O 需求，都应该被视为一个模块。如果任何一个模块花费的时间更多，并且/或者更频繁，它应该被单独指出。在任何涉及高于正常内存的操作中，处理时间会阻塞延迟，I/O
    会使系统等待；在我们的情况下，这将是好的。
- en: 'Human dependency: If moving team members across modules seems like too much
    work, you have more candidates. Developers are smart, but if they struggle with
    large systems, it is not their fault. Break the system down into smaller units,
    and the developers will be both more comfortable and more productive.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人力资源依赖：如果跨模块移动团队成员似乎工作量太大，你就有更多的候选者。开发者很聪明，但如果他们在大系统中遇到困难，这不是他们的错。将系统分解成更小的单元，开发者将感到更加舒适和高效。
- en: Important microservices advantages
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的微服务优势
- en: We have performed the first step of identifying our candidates for moving to
    microservices. It will be worthwhile going through the corresponding advantages
    that microservices provide.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了将候选者迁移到微服务的第一步。了解微服务提供的相应优势将是有价值的。
- en: Technology independence
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术独立性
- en: With each one of the microservices being independent of each other, we now have
    the power to use different technologies for each microservice. The Payment gateway
    could be using the latest .NET framework, whereas the product search could be
    shifted to any other programming language.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个微服务都是相互独立的，我们现在可以为每个微服务使用不同的技术。支付网关可以使用最新的 .NET 框架，而产品搜索可以转移到任何其他编程语言。
- en: The entire application could be based on an SQL server for data storage, whereas
    the inventory could be based on NoSQL. The flexibility is limitless.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序可以基于 SQL 服务器进行数据存储，而库存则可以基于 NoSQL。这种灵活性是无限的。
- en: Interdependency removal
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除相互依赖
- en: Since we try to achieve isolated functionality within each microservice, it
    is easy to add new features, fix bugs, or upgrade technology within each one.
    This will have no impact on other microservices. Now you have vertical code isolation
    that enables you to perform all of this and still be as fast with the deployments.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们试图在每个微服务中实现隔离的功能，因此很容易添加新功能、修复错误或升级技术。这将对其他微服务没有影响。现在你有了垂直代码隔离，这使你能够在保持快速部署的同时完成所有这些操作。
- en: This doesn't end here. The FlixOne team now has the ability to release a new
    option for the Payment gateway alongside the existing one. Both the Payment gateways
    could coexist until the time that both the team and the business owners are satisfied
    with the reports. This is where the immense power of this architecture comes into
    play.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这还没有结束。FlixOne 团队现在有能力在现有的支付网关旁边发布一个新的支付网关选项。这两个支付网关可以共存，直到团队和业务所有者都对报告感到满意。这就是这种架构巨大力量的体现。
- en: Alignment with business goals
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与业务目标对齐
- en: It is not necessarily a forte of business owners to understand why a certain
    feature would be more difficult or time-consuming to implement. Their responsibility
    is to keep driving the business and keep growing it. The development team should
    become a pivot to the business goal and not a roadblock.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 商业主不一定擅长理解为什么某个功能更难或耗时更长来实现。他们的责任是不断推动业务并使其增长。开发团队应该成为业务目标的支点，而不是障碍。
- en: It is extremely important to understand that the capability to quickly respond
    to business needs and adapt to marketing trends is not a by-product of microservices,
    but their goal.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 极其重要的是要理解，能够快速响应业务需求并适应市场趋势的能力不是微服务的副产品，而是其目标。
- en: The capability to achieve this with smaller teams only makes it more suitable
    to business owners.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 只有较小的团队能够实现这一点，这使得它更适合商业主。
- en: Cost benefits
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成本效益
- en: Each microservice becomes an investment for the business since it can easily
    be consumed by other microservices without having to redo the same code again
    and again. Every time a microservice is reused, time is saved by avoiding the
    testing and deployment of that part.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都成为业务的投资，因为它可以很容易地被其他微服务消费，而无需一次又一次地重写相同的代码。每次微服务被重用时，都可以通过避免测试和部署该部分来节省时间。
- en: User experience is enhanced since the downtime is either eliminated or reduced
    to minimal.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于停机时间要么被消除要么减少到最小，用户体验得到了提升。
- en: Easy scalability
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易于扩展
- en: With vertical isolation in place and each microservice rendering a specific
    service to the whole system, it is easy to scale. Not only is the identification
    easier for the scaling candidates, but the cost is less. This is because we only
    scale a part of the whole microservice ecosystem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直隔离已经实施，并且每个微服务向整个系统提供特定服务的情况下，扩展变得容易。不仅扩展候选者的识别更容易，而且成本更低。这是因为我们只扩展整个微服务生态系统的一部分。
- en: This exercise can be cost-intensive for the business; hence, prioritization
    of which microservice should be scaled first can now be a choice for the business
    team. This decision no longer has to be a choice for the development team.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这种练习可能对业务来说成本高昂；因此，优先考虑哪个微服务应该首先扩展现在可以成为业务团队的选择。这个决定不再需要是开发团队的选择。
- en: Security
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is similar to what is provided by the traditional layered architecture;
    microservices can be secured as easily. Different configurations can be used to
    secure different microservices. You can have a part of the microservice ecosystem
    behind firewalls and another part for user encryption. Web-facing microservices
    could be secured differently from the rest of the microservices. You can suit
    your needs as per choice, technology, or budget.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性与传统分层架构提供的安全性相似；微服务可以同样容易地得到保护。可以使用不同的配置来保护不同的微服务。你可以将微服务生态系统的一部分放在防火墙后面，另一部分用于用户加密。面向Web的微服务可以与其他微服务不同地得到保护。你可以根据自己的需求、技术或预算来选择。
- en: Data management
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据管理
- en: It is common to have a single database in the majority of monolithic applications.
    And almost always, there is a database architect or a designated owner responsible
    for its integrity and maintenance. The path to any application enhancement that
    requires a change in the database has to go through this route. For me, it has
    never been an easy task. This further slows down the process of application enhancement,
    scalability, and technology adoption.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数单体应用中，通常只有一个数据库。几乎总是有一个数据库架构师或指定的负责人负责其完整性和维护。任何需要更改数据库的应用增强路径都必须经过这条路线。对我来说，这从来都不是一件容易的任务。这进一步减缓了应用增强、可扩展性和技术采用的过程。
- en: Because each microservice has its own *independent* database, the decision-making
    related to changes required in the database can be easily delegated to the respective
    team. We don't have to worry about the impact on the rest of the system, as there
    will not be any.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个微服务都有自己的**独立**数据库，与数据库更改相关的决策可以很容易地委派给相应的团队。我们不必担心对整个系统的影响，因为不会有的。
- en: At the same time, this separation of the database brings forth the possibility
    for the team to become self-organized. They can now start experimenting.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，这种数据库的分离为团队实现自我组织提供了可能性。他们现在可以开始尝试了。
- en: For example, the team can now consider using the Azure Table storage or Azure
    Redis Cache to store the massive product catalog instead of the database, as is
    being done currently. Not only can the team now experiment, their experience could
    easily be replicated across the whole system as required by other teams in the
    form of a schedule convenient to them.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，团队现在可以考虑使用Azure Table存储或Azure Redis Cache来存储庞大的产品目录，而不是像目前那样使用数据库。团队现在不仅可以进行实验，他们的经验还可以很容易地根据其他团队的需求以对他们方便的时间表进行复制。
- en: 'In fact, nothing is stopping the FlixOne team now from being innovative and
    using a multitude of technologies available at the same time, then comparing performance
    in the real world and making a final decision. Once each microservice has its
    own database, this is how FlixOne will look:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，现在没有任何东西阻止FlixOne团队创新并同时使用多种技术，然后在现实世界中比较性能并做出最终决定。一旦每个微服务都有自己的数据库，FlixOne将看起来是这样的：
- en: '![](img/35e9fcee-fb33-4950-80fb-39ffd76fdebc.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35e9fcee-fb33-4950-80fb-39ffd76fdebc.png)'
- en: Integrating monolithic
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成单体架构
- en: Whenever a choice is made to move away from the monolithic architecture in favor
    of the microservice-styled architecture, the time and cost axis of the initiative
    will pose some resistance. A business evaluation might rule against moving some
    parts of the monolithic application that do not make a business case for the transition.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每当选择从单体架构转向微服务风格的架构时，该活动的时序和成本轴将产生一些阻力。商业评估可能会反对迁移那些没有为过渡提供商业案例的单体应用程序的部分。
- en: It would have been a different scenario if we were developing the application
    from the beginning. However, this is also the power of microservices, in my opinion.
    A correct evaluation of the entire monolithic architecture can safely identify
    the monolithic parts to be ported later.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从一开始就开发应用程序，情况将会有所不同。然而，这也是我认为微服务的力量所在。对整个单体架构的正确评估可以安全地识别出以后要移植的单体部分。
- en: However, to ensure that these isolated parts do not cause a problem to other
    microservices in future, we must take one safeguard against the risk.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了确保这些隔离的部分不会在未来对其他微服务造成问题，我们必须采取一种防范措施来降低风险。
- en: The goal for these parts of the monolithic application is to make them communicate
    in the same way as that of other microservices. Doing this involves various patterns
    and you utilize the technology stack in which the monolithic application was developed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单体应用程序的这些部分的目标是使它们以与其他微服务相同的方式进行通信。这样做涉及各种模式，并且你利用单体应用程序开发中使用的整个技术堆栈。
- en: If you use the event-driven pattern, make sure that the monolithic application
    can publish and consume events, including a detailed modification of the source
    code to make these actions possible. This process can also be performed by creating
    an event proxy that publishes and consumes events. The event proxy can then translate
    these events to the monolithic application in order to keep the changes in the
    source code to a minimum. Ultimately, the database would remain the same.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用事件驱动模式，请确保单体应用程序能够发布和消费事件，包括对源代码的详细修改以使这些操作成为可能。此过程也可以通过创建一个发布和消费事件的代理来完成。然后，事件代理可以将这些事件转换为单体应用程序，以将源代码中的更改保持在最低限度。最终，数据库将保持不变。
- en: If you plan to use the API gateway pattern, be sure that your gateway is able
    to communicate with the monolithic application. To achieve this, one option is
    to modify the source code of the application to expose RESTful services that can
    be consumed easily by the gateway. This can also be achieved by the creation of
    a separate microservice to expose the monolithic application procedures as REST
    services. The creation of a separate microservice avoids big changes in the source
    code. However, it demands the maintenance and deployment of a new component.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用API网关模式，请确保你的网关能够与单体应用程序通信。为了实现这一点，一个选项是修改应用程序的源代码以暴露RESTful服务，这些服务可以很容易地被网关消费。这也可以通过创建一个单独的微服务来实现，该微服务将暴露单体应用程序过程作为REST服务。创建一个单独的微服务可以避免对源代码进行大的更改。然而，它需要维护和部署一个新的组件。
- en: Overview of Azure Service Fabric
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Service Fabric概述
- en: While we were talking about microservices in .NET Core world, Azure Service
    Fabric is the name that is widely used for microservices. In this section, we
    will discuss Fabric services.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在.NET Core世界中谈论微服务时，Azure Service Fabric是广泛使用的微服务名称。在本节中，我们将讨论Fabric服务。
- en: This is a platform that helps us with easy packaging, deployment and managing
    scalable and reliable microservices (the container is also like Docker, and so
    on). Sometimes it is difficult to focus on your main responsibility as a developer,
    due to complex infrastructural problems, and such. With the help of Azure service
    fabric, developers need not worry about the infrastructural issues.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个帮助我们轻松打包、部署和管理可扩展且可靠的微服务的平台（容器也类似于 Docker 等）。有时，由于复杂的架构问题，作为开发人员很难专注于您的核心职责，借助
    Azure 服务 fabric，开发者无需担心架构问题。
- en: This bundles and has the power of Azure SQL Database, Cosmos DB, Microsoft Power
    BI, Azure Event Hubs, Azure IoT Hub, and many more core services.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这捆绑了 Azure SQL 数据库、Cosmos DB、Microsoft Power BI、Azure 事件中心、Azure IoT Hub 以及许多其他核心服务的功能。
- en: As per official documentation ([https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview))[:](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如官方文档所述 ([https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview))[:](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview)
- en: 'Service fabric—any OS, any cloud: You just need to create a cluster of service
    fabric and this cluster runs on Azure (cloud) or on premises, on Linux, or on
    a Windows server. Moreover, you can also create clusters on other public clouds.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务 fabric——任何操作系统，任何云：您只需创建一个服务 fabric 集群，这个集群可以在 Azure（云）或本地运行，在 Linux 或 Windows
    服务器上运行。此外，您还可以在其他公共云上创建集群。
- en: 'Service fabric - stateless and stateful microservices: Yes, with the help of
    service fabric you can build applications as stateless and/or stateful.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务 fabric - 无状态和有状态微服务：是的，借助服务 fabric，您可以构建无状态和/或有状态的应用程序。
- en: '"As per official documentation ([https://docs.microsoft.com/en-us/azure/service-fabric/](https://docs.microsoft.com/en-us/azure/service-fabric/))
    of microservices:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: “如官方文档 ([https://docs.microsoft.com/en-us/azure/service-fabric/](https://docs.microsoft.com/en-us/azure/service-fabric/))
    中所述的微服务：
- en: Stateless microservices (such as protocol gateways and web proxies) do not maintain
    a mutable state outside a request and its response from the service. Azure Cloud
    Services worker roles are an example of a stateless service. Stateful microservices
    (such as user accounts, databases, devices, shopping carts, and queues) maintain
    a mutable, authoritative state beyond the request and its response."
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态微服务（如协议网关和 Web 代理）不维护请求及其响应之外的可变状态。Azure 云服务工作角色是一个无状态服务的例子。有状态微服务（如用户账户、数据库、设备、购物车和队列）在请求及其响应之外维护可变、权威的状态。
- en: 'Full support to application life-cycle management: With the help of service
    fabric, get the support of a full application lifecycle that includes development
    deployment, and so on.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持应用程序生命周期管理：借助服务 fabric，获得包括开发、部署等在内的完整应用程序生命周期的支持。
- en: You can develop a scalable application. For more information refer to: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle).
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以开发可扩展的应用程序。更多信息请参考：[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle).
- en: You can develop highly reliable, stateless and stateful microservices.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以开发高度可靠、无状态和有状态的微服务。
- en: There are different service fabric programming models available that are beyond
    the scope of this chapter. For more information, refer to: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-choose-framework](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-choose-framework).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的服务 fabric 编程模型有多种，但本章范围之外。更多信息请参考：[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-choose-framework](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-choose-framework).
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the microservice architectural style in detail,
    its history, and how it differs from its predecessors, monolithic and SOA. We
    further defined the various challenges that monolithic faces when dealing with
    large systems. Scalability and reusability are some definite advantages that SOA
    provides over monolithic. We also discussed the limitations of the monolithic
    architecture, including scaling problems, by implementing a real-life monolithic
    application. The microservice architecture style resolves all of these issues
    by reducing code interdependency and isolating the dataset size that any one of
    the microservices works upon. We utilized dependency injection and database refactoring
    for this. We further explored automation, CI, and deployment. These easily allow
    the development team to let the business sponsor choose what industry trends to
    respond to first. This results in cost benefits, better business response, timely
    technology adoption, effective scaling, and removal of human dependency. Finally,
    we discussed Azure Service Fabric and got an idea about service fabric and its
    different programming models.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了微服务架构风格，其历史以及它与前辈（单体和SOA）的不同之处。我们进一步定义了单体在处理大型系统时所面临的各项挑战。可扩展性和可重用性是SOA相对于单体提供的一些明确优势。我们还通过实现一个真实的单体应用程序来讨论了单体架构的局限性，包括扩展问题。微服务架构风格通过减少代码依赖性和隔离任何微服务工作的数据集大小来解决了所有这些问题。我们利用依赖注入和数据库重构实现了这一点。我们还进一步探讨了自动化、持续集成和部署。这些使得开发团队能够让业务赞助商首先选择响应哪些行业趋势。这导致了成本效益、更好的业务响应、及时的技术采用、有效的扩展和消除对人类的依赖。最后，我们讨论了Azure服务网格，并了解了服务网格及其不同的编程模型。
- en: In the next chapter, we will go ahead and transition our existing application
    to the microservice-style architecture and put our knowledge to the test.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续将现有的应用程序过渡到微服务风格的架构，并检验我们的知识。
