- en: '*Chapter 3*: Predefined Data Types and Memory Allocations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about **C#** predefined (that is, *built-in*)
    data types and C# object types, along with the different types of **memory allocations**.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic requirement for improving the performance of your application
    is to understand the predefined data types and their sizes. There may be times
    when the memory usage of your applications is critical. Knowing the size of data
    types and the values they hold can help you make accurate memory usage estimates,
    as do memory profiling tools such as **dotTrace** and **dotMemory**, which are
    developed by **JetBrains**. We will be discussing the use of dotTrace and dotMemory
    in the next chapter. It also makes sense to know the different types of memory
    allocations and how they affect your code performance. Here, we will be benchmarking
    the performance of various operations using **BenchmarkDotNet**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the predefined .NET data types**: In this section, we will
    perform a review of the C# value and object types that are built into the C# programming
    language. Understanding these types and their size in bytes is useful when you
    need to provide memory usage estimates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding the various types of memory used in C#**: In this section,
    we delve into the different types of memory used in C#, including the *stack*,
    *heap*, *small object heap*, and *large object heap*. It is useful to know what
    data gets stored in memory and how it gets stored. This can have a big effect
    on the performance of your applications. For instance, did you know that value
    types do not always get stored on the stack?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passing by value and passing by reference**: In this section, we will cover
    the differences between passing values by value and by reference, and the effects
    this has on the original variables. You will also understand how passing by value
    and by reference work in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boxing and unboxing:** In this section, we will discuss what happens in memory
    when we *box* and *unbox* a variable, and we will explore how boxing and unboxing
    negatively impact the performance of programs. You will use the disassembler to
    view the intermediate language commands that perform the boxing and unboxing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have the skills to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You will understand the different value type sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will understand the different reference types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will understand the different types of memory and how they are allocated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will understand the difference between passing by values and passing by
    references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will understand how boxing and unboxing negatively impact performance and
    why.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first look at the technical requirements for following along with this
    chapter, then, we will move on to look at the various predefined C# data types.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Required: **Microsoft** **Visual Studio** **2022**, latest version – preview'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Required: BenchmarkDotNet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03)'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to clone the git repository and do a release build. The compiled
    executable will be found under C:\Development\perfview\src\PerfView\bin\Release\net45.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the predefined .NET data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of predefined data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference types are objects and strings. The value types consist of enumeration
    and struct types. Struct types are aggregated of simple types. Simple types consist
    of Boolean, char, and numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main numeric types: decimal types, floating-point types, and
    integer types. Floating-point types consist of decimals, doubles, and floats.
    The integer types consist of bytes shorts, integers, longs, value tuples, and
    characters.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to mention the stack and the heap in more detail later in the chapter.
    But for now, we should understand that the stack is *unmanaged* memory, and the
    heap is *managed* memory.
  prefs: []
  type: TYPE_NORMAL
- en: Value types live on the stack. Value types in arrays live on the heap. And reference
    types live on the heap, with their pointers living on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even if arrays are not ideal for some scenarios, in most cases, arrays will
    often perform faster than lists and other data structures. Array contents are
    placed contiguously on the heap. The variable for the array will be placed on
    the stack, and its contents on the stack will be a pointer to the memory address
    of the array on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The stack and the heap are the two main types of memory in **.NET**, and as
    mentioned, we will be covering them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the predefined value types in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the predefined value types in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will describe each predefined value type and its size in
    bytes. This is important for being able to choose the right data type to improve
    the memory performance of your applications. For those who are new to C#, you
    should know that *signed* data types are those data types that can have *positive*
    and *negative* values, whereas *unsigned* data types are those that can have only
    *positive* values.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 3.1* describes the different value types, their memory size, whether
    they are nullable, and their default, minimum, and maximum values, as well as
    providing notes where applicable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.1 – The predefined value data types in C#'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_3.1_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.1 – The predefined value data types in C#
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `enum` data type is 4 bytes (that is, 32 bits) in size, nullable, and has
    a minimum value of `0`. You can measure the size of a value type using `sizeof(Type
    type)`. Custom structs can be measured using `Marshal.SizeOf(typeof(NameOfCustomStruct))`.
    The `ValueTuple` data type is 1 byte (8 bits) in size and grows with each type
    parameter. For example, `ValueTuple<double, double, double>` is 24 bytes (192
    bytes) in size.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at understanding the predefined reference types in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the predefined reference types in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **reference type** is a type that is placed in managed memory called the **managed
    heap**. The four predefined reference types in C# are the object type, string
    type, delegate type, and dynamic type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, with reference types, you cannot use `sizeof` (which is of the
    object type) to get the size of a reference type, and the `BinaryFormatter` class
    has been made obsolete. That means that you cannot serialize an object into binary,
    save it into a memory stream, and get its size from the memory stream's position.
  prefs: []
  type: TYPE_NORMAL
- en: We are, however, recommended to serialize and deserialize objects using **JSON**.
    We can then assign the JSON to a memory stream, and in doing so, the length of
    the memory stream will give us the size of our object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each of these in turn in terms of memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the object reference type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The .NET `System.Object` type is aliased as object in C#. All types in C# either
    directly or indirectly inherit from `System.Object`. This includes predefined
    and user types (such as classes, enums, and structs), reference types, and value
    types. Objects can be nullable.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the memory size of your objects programmatically, serialize them to
    **XML** or JSON and load them into a memory stream, and the length of the memory
    stream will give you your object size in bytes. Alternatively, you can profile
    the memory of your application using a tool such as dotMemory to profile your
    application's memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the string reference type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `string` type uses 2 bytes (16 bits) for each character. So, our famous little
    `string`, *Hello, World!*, which uses 13 characters, is 13 x 2 bytes long, which
    equates to 26 bytes (208 bits) of memory. Strings can be nullable, and they can
    be empty.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are immutable in .NET. But what do we mean by this?
  prefs: []
  type: TYPE_NORMAL
- en: When you create a `string` type, it is added to the heap. A variable is added
    to the stack that has an address pointer to the string's location on the heap.
    If you add the `string` type to another variable, that variable will be placed
    on the stack, and it will hold a copy of the address of the same string on the
    heap. But if you append an existing `string` type with another `string` type,
    a new `string` type is created in memory to hold the existing `string` type, plus
    the `string` type to be appended. The address pointer for the `string` type is
    updated on the stack to point to this new location.
  prefs: []
  type: TYPE_NORMAL
- en: Building an immutable string example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are going to write a simple `CH03_StringsAreImmutable`. Then, update the
    `Main(string[] _)` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We output a header to the console, and then we set the `greeting1` `string`
    type to `"Hello, world!"`. Then, we assign `greeting1` to the `string` `greeting2`
    type. The contents of both `string` variables are output to the console window.
    We then amend `greeting1` by appending `" Isn''t life grand!"` to the end of it.
    Next, we output the contents of both `greeting1` and `greeting2`. Run the program,
    and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The immutable strings example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The immutable strings example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, although we assigned `greeting1` to `greeting2` and then updated
    `greeting1`, `greeting2` remains unchanged. So, we now have two strings on the
    heap. We have `"Hello, world!"`, and we have `"Hello, world! Isn't life grand!"`.
    And so, from our little example, we can see that strings are indeed immutable.
    And now, we will describe the `delegate` reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the delegate reference type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `delegate` type must have the same signature and return type. When you compile
    code that uses delegates, a private sealed class is created for the delegate that
    inherits from `System.MulticastDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check *section I.8.9.3* in the following link for more information on
    delegates: [https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: We will now describe the `dynamic` reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the dynamic reference type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type checking is performed at compile time. This ensures type safety when your
    applications are executed at runtime. Type safety aims to prevent erroneous or
    undesirable program behavior that is caused by discrepancies between types.
  prefs: []
  type: TYPE_NORMAL
- en: Types that are defined as `dynamic` bypass type checking at compile time, as
    they and the members are resolved at runtime. The advantage of the `dynamic` type
    is that it simplifies our access to COM APIs (such as the **Office Automation**
    API) to dynamic APIs (such as the **IronPython** libraries) and to the HTML **Document
    Object Model** (**DOM**).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic types are compiled as objects and exist as objects at runtime. A `dynamic`
    type only exists at compile time and not at runtime. When a `dynamic` type is
    compiled, it becomes an `object` type. Later in this section, and after we have
    written and built our console application, we will use ILDASM to show the IL type
    of a compiled dynamic variable.
  prefs: []
  type: TYPE_NORMAL
- en: When the object runs for the first time, it is correctly resolved by the runtime.
    This resolution incurs a performance penalty that can be considerable depending
    upon the type being resolved. Since `dynamic` is compiled into an object, boxing
    and unboxing take place. And as you know, boxing costs processor cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate the performance difference when using different variations
    of `var` and `dynamic` when we are declaring variables and assigning values to
    them, compared to using the correct types and assigning them without having to
    use casting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new .NET 6 console application called `CH03_DynamicPerformance`.  You
    will need the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new member variable at the top of the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable declaration will be investigated by using ILDASM after we have
    run our benchmarks. Next, update the `Main(string[] _)` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are running the benchmarking tests in a class called `BenchmarkTests`. Add
    a new class called `BenchmarkTests` by using the same statements as the preceding
    example. Then, add the `MeasureVarUsage()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This method assigns a `double` object to the `x` variable of a type that will
    be resolved at runtime. Next, add the `MeasureVarDynamicUsage()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are still assigning a number to the `x` variable of a type that will
    be resolved at runtime. But this time, we prefix the number with the `(dynamic)`
    cast. Remember that the `dynamic` keyword only exists at compile time. When compiled,
    `dynamic` types become the `object` type. Now, add the `MeasureTypeDynamicUsage()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we declare the variable as `double` and cast the assigned number
    as `(dynamic)`. At runtime, this number will be boxed in an `object` type, and
    so it will need to be unboxed. And for our final method, add the `MeasureTypeTypeUsage()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we declare a `double` type and assign a `double` type. Compile
    the project in Release mode. Then, open a command line and navigate to your release
    folder. Type the name of the executable and press *Enter*. This will cause BenchmarkDotNet
    to detect the benchmarks within the project and sequentially run through them.
    You should see a summary similar to the following, albeit with different mean
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The variable type declaration and the assignment''s benchmarked
    mean timings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – The variable type declaration and the assignment's benchmarked
    mean timings
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.2* shows us that there are differences in performance when we declare
    variables and assign values depending on the methods we use. The fastest combination
    of declaration and assignment is `var variableName = (dynamic)value`.'
  prefs: []
  type: TYPE_NORMAL
- en: Well, we have run our benchmark tests. So, let's view the IL code for the dynamic
    variable. Open the developer command prompt, then type `ildasm.exe` and press
    *Enter*. This will start the ILDASM application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Core** and **.NET 6** applications are compiled differently from previous
    versions of the **.NET Framework**. Previously, ILDASM would open the compiled
    executable. But .NET Core and .NET 6 applications get compiled into a **dynamic-link
    library** (**DLL**), and a native executable is produced to run the code in the
    resulting DLL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your compiled DLL. Expand the `CH03_DynamicPerformance` node and then
    expand the `CH03_DynamicPerformance.Program` node. Then, locate the `_dynamicType
    : private object` line call, as shown in *Figure 3.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – ILDASM showing us that the compiler converts a dynamic type
    into an object type at compile time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – ILDASM showing us that the compiler converts a dynamic type into
    an object type at compile time
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our `dynamic` type gets compiled into an `object` type. As a
    little exercise, play about with the ILDASM settings and view the code for the
    `BenchmarkTests` class for yourself. Now, let's look at static types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET versions earlier than .NET Core and **.NET** **5.0**, when you compile
    and run your applications, they run in their own application domains. If you run
    your applications multiple times, each running instance of your application will
    have its own app domain. In **ASP.NET**, you use multiple app domains for a single
    application. This becomes important when using static types in ASP.NET applications.
    In a single app domain, there will only be one instance of a static type. The
    runtime must create an instance of the static type before it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `AppDomain` object has its own static heap. Static value and reference types
    will be placed on the static heap and managed by the app domain. Static types
    are considered by the garbage collector, but they are never collected. The reason
    the garbage collector considers them is that they may have references to objects
    on other heaps. Static types and variables in other app domains are isolated from
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: In `AssemblyLoadContext` class for the dynamic loading of assemblies. By *processes
    and/or containers*, Microsoft means that you should split your single applications/modules
    into separate, interacting applications/modules/processes/containers. So, you
    are encouraged by Microsoft to refactor code using microservices so that you no
    longer need to use application domains.
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Runtime.Loader.AssemblyLoadContext` object represents a load context.
    A *load context* creates a scope for loading, resolving, and unloading assemblies.
    For more information on the `AssemblyLoadContext` class, see the official Microsoft
    documentation at [https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0](https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0).
  prefs: []
  type: TYPE_NORMAL
- en: Static classes are instantiated only once by the runtime. You cannot instantiate
    a static class yourself. Static constructors are executed at the time the class
    is loaded into memory. If a non-static class has a static constructor and an instance
    constructor, the static constructor will be called before the instance constructor.
    Static constructors are parameterless, and there can only be one static constructor
    per class. Static constructors do not have access modifiers. Memory is allocated
    for static variables when a class loads and deallocated when a class is unloaded.
    Variables, constructors, and methods belong to the class and not to instantiated
    objects. So, modifying variables will modify the variable across all instances
    of a class.
  prefs: []
  type: TYPE_NORMAL
- en: On the call stack, static methods tend to be faster to call than instance methods.
    The compiler emits a nonvirtual call sites static members. Nonvirtual call sites
    prevent runtime checks that ensure the current object pointer is non-null. Although
    you may not see any visual performance improvements, performance gains can be
    measured for performance-sensitive code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the various predefined C# data types, it is time to
    look at C# memory and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the various types of memory used in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main types of memory in C#: the stack and the heap. The heap
    is further broken down into the *small object heap* and the *large object heap*.
    In terms of physical memory, there is no difference between the stack or heap,
    as they are both stored in physical memory. Their differences are in their implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When your application starts up, it is allocated a portion of memory. A pointer
    will be assigned to your application that will be your application''s memory starting
    point. Above the pointer will be the stack, and below the pointer will be the
    heap. The heap will grow downwards, and the stack will grow upwards, as shown
    in *Figure 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The stack, heap, and application starting point memory address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – The stack, heap, and application starting point memory address
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visually represents the stack and heap for a simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The stack and heap at work'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – The stack and heap at work
  prefs: []
  type: TYPE_NORMAL
- en: To understand the different types of memory in C#, first, we'll look at the
    stack and how it operates.
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *stack* is used to store value types and pointers to memory locations on
    the heap. When you call a method, it is added to a stack frame on the stack. Then,
    within that frame, the value types are added to the stack. If there are any reference
    types in the method, these are placed on the heap, and a variable is placed on
    the stack and assigned a pointer to a memory address for the reference type on
    the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even though we can state that value types are added to the stack, this is not
    always true. For example, if you have an array of integers, the array – by virtue
    of being a reference type – will be added to the heap, and each of the integers
    that belong to the array will be added contiguously to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: If a `struct` object has a reference type, the struct is placed on the stack,
    the reference type is placed on the heap, and a pointer to the address of the
    reference type on the heap is stored in the variable on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The stack is faster than the heap. It is arranged like a stack data structure.
    When you execute a method, the method is added to the stack in a stack frame.
    The local variables are then added to the stack frame on top of each other. When
    the method has completed execution, the memory is reclaimed immediately. The heap,
    however, must keep track of memory allocations, pointers, and reference counters,
    whereas the stack does not have to manage itself in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: With the stack, you can simply pop things on and off the stack. To increase
    the performance of your applications, look for heap usage in your applications.
    Measure the performance when using the stack and using the heap. If the stack
    is faster, then replace heap usage with stack usage.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the cost of using memory is not at the time of allocation
    but at the point of deallocation. The deallocation of items on the stack is more
    predictable than the deallocation of items on the heap. In some cases, the garbage
    collector is doing similar pointer arithmetic when *freeing* memory in generation
    0 or generation 1.
  prefs: []
  type: TYPE_NORMAL
- en: Memory calls are also expensive because they are placed on the stack but may
    also reference the heap. Method performance is affected by code that does not
    execute. Therefore, you should refactor your methods to be as small as possible
    and remove any code that will not be executed, such as dead code that is no longer
    used. This will reduce the number of local variables in use and thereby reduce
    the stack size. And so, you will eliminate performance loss.
  prefs: []
  type: TYPE_NORMAL
- en: The heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *heap* is used to store reference types. They are called reference types
    because they are reference-counted. To be reference-counted means that a count
    of variables referencing the allocated reference type is being kept by the runtime.
    When the reference count diminishes to zero, the reference type is deallocated
    by the garbage collector. For example, if I have a product object in memory and
    two variables on the stack pointing to that object, the product object has a reference
    count of two.
  prefs: []
  type: TYPE_NORMAL
- en: You may be surprised to learn that the allocation of objects in C# can sometimes
    be faster than in **C++**. The price is paid in C# when it comes to garbage collection.
    So, instantiating many objects does not cost us much at all, but the cleanup of
    those objects does. This means that the more objects you create, the harder the
    garbage collector must work, which negatively impacts your application's performance.
    Therefore, avoid using reference types if alternative value types can be used.
    Do not create objects if you do not need to.
  prefs: []
  type: TYPE_NORMAL
- en: When a new object is instantiated, it is placed on the heap. The variable is
    placed on the stack and is assigned a pointer to the address of the object on
    the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays of reference types are placed on the heap. The variable that references
    the array will be placed on the stack and it will be assigned to the memory address
    of the array on the heap. The array itself will contain a contiguous list of memory
    addresses, as shown in *Figure 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The heap displaying objects on the heap and their memory addresses
    within an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – The heap displaying objects on the heap and their memory addresses
    within an array
  prefs: []
  type: TYPE_NORMAL
- en: These memory addresses are pointers to the memory addresses of reference type
    address locations on the heap. This is because when an array is placed on the
    heap that contains reference types, each of the reference types in the array is
    assigned to its own area of memory. The memory addresses of the reference types
    are then placed inside the array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Array performance has been prioritized, followed by string performance. Arrays
    are often faster than lists and other data structures. But it is best to use benchmarks
    to decide which is better for your situation and choose the data structure that
    performs best for you.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to maximizing the performance of memory usage, you need to ensure
    that objects on the heap are placed as close to their reference pointers as possible.
    The reason for this is to reduce the required CPU cycles when locating the memory
    that is being referenced by the pointer. The rule of thumb for memory performance
    is that the further memory is from its pointer, the more it costs you in CPU performance.
    Although, it must be said that predictive memory access reduces this greatly,
    and memory usage can be dependent on the system page file setup.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The order in which you instantiate arrays, instantiate objects, assign values
    to objects, and assign values and objects to arrays affects the performance of
    your applications. This will be down to the placement of those items within memory.
    Remember that items on the heap should be close to their memory pointers, which
    may be stored either on the heap or on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: As already stated, object deallocation on the heap is slower than deallocation
    on the stack. The more objects you add to the heap, the slower your performance
    will be. The reason for this is that you give the garbage collector more work
    to do due to the frequent allocation and deallocation. It is this cycle of allocation
    and deallocation that causes the performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two heaps within the main heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Small object heap**: When a new object is instantiated, it is placed on the
    small object heap as generation 0 if it is less than 80,000 bytes in size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large object heap**: When a new object is instantiated that is 80,000 bytes
    or larger in size, it is added to the large object heap. Large objects are always
    allocated in generation 2 because they are only garbage collected during a generation
    2 collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be looking at the heap in more detail when we look at garbage collection
    in [*Chapter 4*](B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072), *Memory Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Building a stack versus building a heap (example project)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will write a simple project that will get the number of ticks for object
    and struct instantiation with and without reference type properties. Start by
    adding a new .NET 6 console application called `CH03_StackAndHeap`. Then, add
    the `BenchmarkDotNet nuget` package. You will need to use the following `using`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the `Main(string[] _)` method as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the method, we are calling the `BenchmarkTests` class that contains our
    benchmarks. Now, add the `ClassNoReference` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has three value type properties and no reference type properties.
    Add the `ProcessClassNoReferences()` method in the `BenchmarkTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProcessClassNoReferences()` method declares a new instance of the `ClassNoReferences`
    class. It will be used as a benchmarking method. Add the `StructNoReferences`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This struct has three value type properties and no reference types. Let''s
    add the `ProcessStructNoReferences()` method to the `BenchmarkTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProcessStructNoReferences()` method will be used as a benchmark, and it
    creates a new `StructNoReferences` struct. Next, add the `ClassWithReferences`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has value and reference type properties. Now, we will add the `ProcessClassWithReferences()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProcessClassWithReferences()` method will be used as a benchmark, and
    it creates an instance of `ClassWithReferences`. Next, we will add the `StructWithReferences`
    struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'This struct has value and reference types. And now, we will add our final method,
    `ProcessStructWithReferences()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The `ProcessStructWithReferences()` method will be used as a benchmark, and
    it creates a new `StructureWithReferences` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the code in release mode. Then, run the executable. Your code will
    then be benchmarked, and you will see the following benchmark report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The benchmark report comparing structs and classes with and
    without references'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The benchmark report comparing structs and classes with and without
    references
  prefs: []
  type: TYPE_NORMAL
- en: 'The benchmark results reveal the following insights:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing a class with no references is faster than processing a struct with
    no references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing a class with references is slower than processing a struct with references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the benchmark results show, depending on the scenario, a struct can be faster
    than a class and vice versa. This is a good reason for benchmarking code, as you
    could be thinking your code is optimal when in fact it is slow.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you choose whether to use a struct or a class?
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between a struct and a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a rule of thumb, Microsoft recommends that we define our types as classes.
    If a type is embedded in other objects or if it is short-lived, then consider
    using a struct. When defining a struct, it should have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Logically, the struct represents a single value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The struct instance size is under 16 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The struct is immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The struct is not frequently boxed and unboxed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *struct* is a *value type*. Value types are allocated on the stack or inline
    inside containing types. A value type will be deallocated when the stack is unwound
    or during the deallocation of the containing type. Value types are not garbage
    collected. The allocation and deallocation of value types on the stack are considered
    cheap. However, when a value type is boxed, it is wrapped in a reference type
    or cast to an interface, and this causes a performance slowdown. A performance
    slowdown is also experienced when a value type is unwrapped from inside a reference
    type, which is known as *unboxing*. You should do your best to avoid boxing and
    unboxing value types for performance reasons. When you assign value types, a complete
    copy of the value is passed into the assignment. The assignment of large value
    types can be more expensive than the assignment of large reference types.
  prefs: []
  type: TYPE_NORMAL
- en: A *class* is a *reference type*. Reference types are objects allocated on the
    heap with a pointer to the memory location placed on the stack. When a reference
    type comes to the end of its life, it is garbage-collected. The allocation and
    deallocation of reference types on the heap are considered expensive when compared
    with the allocation and deallocation of value types on the stack. Unlike value
    types, no boxing occurs when casting reference types. When you assign a reference
    type, a copy of the reference is passed to the assigned variable. The assignment
    of large reference types can be cheaper than the assignment of large value types.
  prefs: []
  type: TYPE_NORMAL
- en: An array of reference types contains pointers to the actual types on the heap.
    An array of value types contains the actual values of those reference types. The
    allocation and deallocation of value type arrays are cheap, and they have better
    locality when compared to arrays of reference types, as the value type values
    are inline.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to look at *passing by value* and *passing by reference*.
  prefs: []
  type: TYPE_NORMAL
- en: Passing by value and passing by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When passing values into a method or constructor, there are two ways to do
    this. They are *passing by value* and *passing by reference*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing by value**: By default, all value types are passed by value into
    constructors and methods using *copy semantics*. This means that a copy is made
    of the value being passed in. The original value remains unchanged, and it is
    the copy that is used with the constructor or method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passing by reference**: When a reference type is passed into a constructor
    or method, a variable is made on the stack that points to the same object on the
    heap. So, both the variable that is passed in and the copied variable used inside
    the constructor or method operate on the same object in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what passing by value and passing by reference are, let's write
    a simple program that demonstrates what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Building a pass-by-reference example program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to write a very simple program that demonstrates the effects of
    passing by value and passing by reference. Add a new .NET 6 console application
    called `CH03_PassByValueAndReference`. Then, modify the `Main(string[] _)` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have declared an integer called `x` and assigned it a value of `0`.
    Some text is output to the console window, and we call two methods and output
    the value of `x` after they have been called. Let''s add the first method that
    is called – the `AddByValue(int x)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is a very simple method that increments the value for the
    variable passed in. Now, let''s repeat the same process, but this time, we will
    pass the value by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program, and you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The value of x after incrementing using pass by value and pass
    by reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – The value of x after incrementing using pass by value and pass
    by reference
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the original value is not updated when we pass by value. But
    it is updated when we pass by reference. We will now extend the application to
    cover the `in` parameter modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguments passed with the `in` keyword are passed by reference. However, `in`
    arguments cannot be modified. Let''s demonstrate this – add a new method called
    `InParameterModifier()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `InParameterModifier()` method, we create an integer and assign to it
    a value of `13`. We then call a method of the same name and pass in the variable
    as an argument. Then, we print out the value to the console window. Now, we will
    write the `InParameterModifier(in int argument)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The code is commented out because if we assign a value to the argument, we will
    get the compiler warning you see in the comment. Call the method from the `Main(string[]
    _)` object and run the program. You will see that the variable remains at `13`,
    as the compiler prevented us from being able to change it in the called method.
    Finally, in the next part of our program, we will look at the `out` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: An `out` argument does not have to be initialized before being passed in. This
    is different from a ref value that must be initialized before it is passed in.
    All `out` parameters are passed by reference. Any operation carried out on the
    argument inside the method becomes available to the external code that can see
    the argument. An example will make this easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be adding two methods to demonstrate how the `out` parameter works.
    Add a new method called `OutParameterModifier()` to the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declare an integer variable. Then, we call a method
    that has an `out` parameter and we pass in our integer with its default value
    of `0`. Next, we print out the value of the integer once the method has returned.
    Now, add the `outParameter(out x)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are simply setting the argument to `123` and exiting. Call the `OutParameterModifier()`
    method from `Main(string[] _)`. If you run the code, you will see that our integer
    was updated to the value of `123` inside the method that we called. This is shown
    in *Figure 3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Our integer has been updated inside the method we passed it
    into'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Our integer has been updated inside the method we passed it into
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will look at *boxing* and *unboxing*.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and unboxing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Boxing* and *unboxing* variables negatively impact the performance of your
    applications. To improve your application''s code, you should do your best to
    avoid boxing and unboxing – especially when your code is mission-critical. In
    this section, we will look at what happens when you package (that is, box) a type.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing boxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a variable is boxed, you are wrapping it in an object that gets stored
    on the heap. As you know, objects on the heap incur costs, as they must be managed
    by the runtime. On top of this, you also increase the memory used by the variable,
    as well as the number of CPU cycles needed to process the variable.
  prefs: []
  type: TYPE_NORMAL
- en: An empty `class` definition is 12 bytes on a 32-bit operating system and 24
    bytes on a 64-bit operating system. This may not sound like a lot. But if a value
    type is boxed that does not need to be boxed, you will be wasting 12 or 24 bytes
    of memory unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at what happens when you unbox a variable
  prefs: []
  type: TYPE_NORMAL
- en: Performing unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variable is copied to the evaluation stack that references an object on the
    heap. The variable is then unboxed (that is, unpacked) and the variable is placed
    on the evaluation stack. Then, whatever needs to be done with the unboxed variable
    can be done. Once all the work has been done with the variable, it then must be
    boxed up again and placed on the heap. This will create a new object on the heap,
    and the variable on the stack will be updated with its memory location.
  prefs: []
  type: TYPE_NORMAL
- en: Building a boxing-and-unboxing example program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we will write a simple .NET 6 console application that shows the time
    difference between not boxing and boxing/unboxing on performance using `BenchmarkDotNet`.
    First, start a new .NET 6 console application and call it `CH03_BoxingAndUnboxing`.
    You will need to add the `BenchmarkDotNet` package and the following two namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'We need these namespaces to perform benchmarking. In the `Main(string[] _)`
    method, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code starts the benchmarks running. Next, add a new class called
    `BoxingAndUnboxingBenchmarkTests`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'This class will hold two benchmarking methods called `NonBoxingUnboxingTest()`
    and `BoxingUnboxingTest()`. Add the `NonBoxingUnboxingTest()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we declare and assign three integers: `z = 0`, `a = 1`, and
    `b = 6`. We then add `a` and `b` together and assign the resulting value to `z`.
    Now, add the `BoxingUnboxingTest()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we declare and assign two objects: `a = 4` and `b = 4`. We also
    declare an integer: `z`. Then, we cast `a` and `b` to integers, add them together,
    and assign the result to the `z` integer variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform a release build of your code. Then, open a command line and navigate
    to your executable. Run your executable from the command line, and you should
    see the following summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The boxing-and-unboxing example project addition output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – The boxing-and-unboxing example project addition output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the screenshot in *Figure 3.10*, unboxing does add overhead
    to the performance of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `ILDASM`, this will load the intermediate language disassembler.
    Open the DLL file in your build folder, and expand the tree until you see the
    `Main : void(string[])` line, as shown in *Figure 3.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The Intermediate Language Disassembler (ILDASM)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – The Intermediate Language Disassembler (ILDASM)
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the `Main` method. This will bring up the window that shows the
    disassembled intermediate language for our `Main(string[] _)` method, as shown
    in *Figure 3.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The disassembled intermediate language for our Main(string[]
    _) method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – The disassembled intermediate language for our Main(string[] _)
    method
  prefs: []
  type: TYPE_NORMAL
- en: Study the disassembled code. When you see the `box` command, the value type
    is being wrapped inside of an object, which is a reference type that gets placed
    on the heap. And when you see the `unbox.any` command, the value type is being
    unwrapped from the object and assigned to an int value type that belongs on the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: You now understand why boxing and unboxing affect the performance of your applications,
    and now we have come to the end of the chapter. In the next chapter, we will be
    focusing on how the garbage collector works and what we can do to improve its
    performance. But first, let's summarize what we have learned. You are then encouraged
    to answer the questions that follow and further your reading on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter by looking at the various predefined .NET data types.
    First, we described the various value types, and then we moved on to the predefined
    reference types. Then, we concluded our discussion of predefined .NET data types
    by exploring static types.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that value types live on the stack. But if they are part of an array,
    they are placed on the heap with the array that happens to be a reference type.
    You also learned that reference types live on the heap and that they have pointers
    to them in the form of variables that live on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at the different types of memory used in C#. First, we looked
    at the stack. Then, we looked at the heap, which consists of the small object
    heap and the large object heap. After looking at the differences between the stack
    and the heap, we saw that the stack performs much faster than the heap. The reason
    for this is that the stack memory does not have to be managed by the runtime.
    It is simply popped onto the stack when it is needed and popped off the stack
    when it is not needed. In contrast, the heap must be managed by the runtime that
    allocates the objects – it keeps a reference count of all the variables that reference
    those objects, and then it deallocates the objects when they are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at passing by value and passing by reference. Values passed by
    value have a copy taken of them that is passed into the constructor or method.
    This copy is utilized, and the original value remains untouched. When passed by
    reference, a copy of a value is made and placed on the stack, and it is assigned
    the memory location of the object on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the boxing and unboxing of variables and why this negatively
    impacts your application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: With all that you have learned in this chapter, you can reduce the amount of
    memory your applications use by using the right types, and you can reduce the
    number of ticks per operation by avoiding boxing and unboxing. And now that you
    know how memory allocations work, you can improve performance by keeping methods
    small and using the stack instead of the heap when it is practical to do so.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning more about garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List the predefined .NET value types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the predefined reference types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the runtime have to do before a static type can be accessed and utilized?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a physical difference in the memory that is used that makes the stack
    run faster than the heap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the stack faster than the heap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain why strings are immutable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the approximate size of objects placed on the small object heap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the approximate size of objects placed on the large object heap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The C# type system*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C# Different Types of Heap Memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://vivekcek.wordpress.com/tag/stub-heap/](https://vivekcek.wordpress.com/tag/stub-heap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx](https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Passing Parameters (C# Programming Guide)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boxing and Unboxing (C# Programming Guide)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The large object heap on Windows systems*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Memory Allocations and Performance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=aylUPfOVM90](https://www.youtube.com/watch?v=aylUPfOVM90)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replacing AppDomain in .NET Core*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/](https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
