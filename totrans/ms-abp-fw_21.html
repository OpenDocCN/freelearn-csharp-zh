<html><head></head><body>
		<div id="_idContainer132">
			<h1 id="_idParaDest-333"><em class="italic"><a id="_idTextAnchor457"/>Chapter 16</em>: Implementing Multi-Tenancy</h1>
			<p>Multi-tenancy is a common pattern to create <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>) solutions, where a single deployment can concurrently serve multiple customers. Multi-tenancy is one of the fundamental design principles of ABP Framework, so all other framework features are multi-tenancy compatible.</p>
			<p>In this chapter, we will start with understanding what a multi-tenant system is and how ABP provides a multi-tenant solution to us. Then, we will continue with the ABP infrastructure to understand, build, and control the multi-tenancy in our applications. We will also learn to design specific application features and make different tenants use different application features. At the end of this chapter, you will understand the basics of multi-tenancy and will be able to build multi-tenant applications using ABP Framework.</p>
			<p>Here is a list of the main topics covered in this chapter:</p>
			<ul>
				<li>Understanding multi-tenancy</li>
				<li>Working with the ABP multi-tenancy infrastructure</li>
				<li>Using the feature system</li>
				<li>When to use multi-tenancy</li>
			</ul>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor458"/>Technical requirements</h1>
			<p>If you want to follow the examples in this chapter, you need to have an IDE/editor that supports ASP.NET Core development.</p>
			<p>You can download the example application from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>. It contains some of the examples given in this chapter.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor459"/>Understanding multi-tenancy</h1>
			<p>In this section, you will understand the SaaS and multi-tenancy concepts, the main benefits of creating a SaaS solution, and what ABP<a id="_idIndexMarker1028"/> provides us as a multi-tenant-aware framework. Let's start by understanding what a SaaS system provides.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor460"/>What is SaaS?</h2>
			<p>Building, deploying, and licensing software<a id="_idIndexMarker1029"/> solutions with the SaaS model has become quite popular. Customers typically purchase a SaaS solution with a subscription model and use it online without requiring them to download and install<a id="_idIndexMarker1030"/> it on their own servers, which is called on-premises deployment.</p>
			<p>Building a SaaS solution has these benefits<a id="_idIndexMarker1031"/> when hosting:</p>
			<ul>
				<li>You can utilize your resources at the maximum level since customers can share servers, databases, and other resources.</li>
				<li>It is extremely easy and typically automated to add a new customer (tenant) to the system.</li>
				<li>It is easier to maintain and upgrade the system compared to separate deployment for each customer.</li>
			</ul>
			<p>On the other hand, using a SaaS solution benefits customers as well. They pay less for software and hosting than with an on-premises deployment. They can pay based on how much they use it. They also don't need to care about maintenance and upgrades as long as they pay the service costs.</p>
			<p>While the SaaS solution benefits hosting, creating a SaaS solution comes with some development costs and runtime considerations.</p>
			<p>SaaS solutions typically share the resources between customers. Some of the major shared resources are database, cache, and application servers. Data isolation, security, and performance are the main concerns that we should care about when sharing resources between customers.</p>
			<p>In addition to shared resources, application settings, features, and permissions should be customized per customer without affecting each other.</p>
			<p>As we now understand the benefits and challenges of building SaaS solutions, let's talk a bit about multi-tenancy.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor461"/>What is multi-tenancy?</h2>
			<p>Multi-tenancy is an architectural pattern<a id="_idIndexMarker1032"/> to create SaaS solutions. It defines and controls how customers access resources securely and efficiently and how the application is customized per customer easily.</p>
			<p>ABP Framework provides a complete multi-tenancy infrastructure. It defines how your application and domain code should be designed, how you access shared resources (such as databases and caches), how you customize the application configuration per customer, and so on. It not only defines but automates wherever possible.</p>
			<p>There are two sides of a multi-tenant system:</p>
			<ul>
				<li><strong class="bold">Tenant</strong>: A customer<a id="_idIndexMarker1033"/> that uses the system and pays for it. A customer has its own users and data, which are isolated from other tenants.</li>
				<li><strong class="bold">Host</strong>: The company that manages<a id="_idIndexMarker1034"/> the system and the tenants.</li>
			</ul>
			<p>You can have separate applications for tenant and host users, or you can build a single application that makes some application features available only for tenant users or only for host users. The ABP startup solution template uses the second approach since it is easier to develop and deploy.</p>
			<p>The next section discusses how databases are shared or separated for different tenants.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor462"/>The database architecture</h2>
			<p>One of the most fundamental design<a id="_idIndexMarker1035"/> decisions of a multi-tenant system is how to share or separate the databases of different tenants. There are three common approaches:</p>
			<ul>
				<li><strong class="bold">Single database</strong>: All data of all tenants<a id="_idIndexMarker1036"/> is stored in a single, shared database. In this case, you should take care when isolating data of different tenants since the database tables are shared.</li>
				<li><strong class="bold">Database (or schema) per tenant</strong>: Every tenant has its own dedicated database. You should dynamically connect<a id="_idIndexMarker1037"/> to the database for the tenant of the current user.</li>
				<li><strong class="bold">Hybrid</strong>: A mixed approach where some tenants<a id="_idIndexMarker1038"/> have their own database while others are grouped in one or more databases.</li>
			</ul>
			<p>ABP supports the hybrid approach at the framework level by allowing every tenant to have a separate database connection string. However, the startup template and the open source tenant management module come with the single-database model. If you want to use the database per tenant or the hybrid approach, you should customize the tenant management module.</p>
			<p>The following figure visualizes the main components<a id="_idIndexMarker1039"/> of the ABP multi-tenancy infrastructure:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/Figure_16.1_B17287.jpg" alt="Figure 16.1 – ABP Framework multi-tenancy in brief&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – ABP Framework multi-tenancy in brief</p>
			<p>ABP Framework's goal<a id="_idIndexMarker1040"/> is to automate the multi-tenancy-related logic as much as possible and make your application code multi-tenancy-unaware. ABP resolves the current tenant from the HTTP request. It can determine the tenant from the domain (or subdomain) name, cookie, HTTP header, and other parameters. Then, it uses the current tenant information to automatically select the right connection if the tenant has a separate connection string. If the tenant uses a shared database, it automatically filters the data so that a tenant doesn't accidentally access another tenant's data.</p>
			<p>We can now start working with the ABP multi-tenancy infrastructure, as we've learned about multi-tenancy and ABP's fundamental multi-tenancy logic overall.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor463"/>Working with the ABP multi-tenancy infrastructure</h1>
			<p>In this section, we will explore<a id="_idIndexMarker1041"/> the basic infrastructure and features of the ABP multi-tenancy system. You will learn how ABP understands the current tenant and isolates the tenant data, how you can get information about the current<a id="_idIndexMarker1042"/> tenant, and how to switch between tenants. But first, we will start with how you can disable multi-tenancy if you don't need it.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor464"/>Enabling and disabling multi-tenancy</h2>
			<p>The ABP startup solution<a id="_idIndexMarker1043"/> template comes with multi-tenancy enabled by default. The startup<a id="_idIndexMarker1044"/> solution has a single point that you can use to easily enable or disable multi-tenancy. Find the <strong class="source-inline">MultiTenancyConsts</strong> class inside the <strong class="source-inline">.Domain.Shared</strong> project:</p>
			<p class="source-code">public static class MultiTenancyConsts</p>
			<p class="source-code">{</p>
			<p class="source-code">    public const bool IsEnabled = true;</p>
			<p class="source-code">}</p>
			<p>You can set the <strong class="source-inline">IsEnabled</strong> value to <strong class="source-inline">false</strong> to disable multi-tenancy. This constant is used in a few places in the solution. It is used to set the <strong class="source-inline">AbpMultiTenancyOptions.IsEnabled</strong> option in the <strong class="source-inline">.Domain</strong> project's module class:</p>
			<p class="source-code">Configure&lt;AbpMultiTenancyOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.IsEnabled = MultiTenancyConsts.IsEnabled;</p>
			<p class="source-code">});</p>
			<p>ABP uses <strong class="source-inline">AbpMultiTenancyOptions.IsEnabled</strong> to enable or disable multi-tenancy-related features, pages, and components. If you set <strong class="source-inline">MultiTenancyConsts.IsEnabled</strong> to <strong class="source-inline">false</strong> and run the application, you won't see the tenant switch box on the login form and the tenant management page on the main menu anymore. However, the multi-tenancy-related database tables are not removed. The next section explains how to do it.</p>
			<h3>Removing multi-tenancy tables</h3>
			<p>Disabling multi-tenancy doesn't remove the multi-tenancy-related database<a id="_idIndexMarker1045"/> tables from the database. You can leave this as it is (they will already be empty/not used). This way, you can easily enable it for your application later.</p>
			<p>If you don't want the multi-tenancy-related tables in your database, find the following line in the <strong class="source-inline">DbContext</strong> class in the <strong class="source-inline">.EntityFramework</strong> project and remove it:</p>
			<p class="source-code">builder.ConfigureTenantManagement();</p>
			<p>Then, remove the implementation of the <strong class="source-inline">ITenantManagementDbContext</strong> interface from your <strong class="source-inline">DbContext</strong> class. You need to remove the <strong class="source-inline">Tenants</strong> and <strong class="source-inline">TenantConnectionStrings</strong> <strong class="source-inline">DbSet</strong> properties from the class. Finally, remove the <strong class="source-inline">[ReplaceDbContext(typeof(ITenantManagementDbContext))]</strong> attribute from the <strong class="source-inline">DbContext</strong> class declaration. These changes remove the tenant management module's tables from your database schema.</p>
			<p>You can add a new database migration to remove the tables from the database. Run the following command in the root directory of the <strong class="source-inline">.EntityFramework</strong> project:</p>
			<p class="source-code">dotnet ef migrations add Removed_TenantManagement</p>
			<p>Then, run the following command to apply changes to the database:</p>
			<p class="source-code">dotnet ef database update</p>
			<p>In this way, your database won't include multi-tenancy-related tables. You can also remove the <strong class="source-inline">Volo.Abp.TenantManagement.*</strong> NuGet packages from the projects in the solution and the code parts using these packages. However, all these are optional. I suggest you keep them if you think you may enable multi-tenancy for your application later because they have no functionality as long as the <strong class="source-inline">AbpMultiTenancyOptions.IsEnabled</strong> option is set to <strong class="source-inline">false</strong>.</p>
			<p>As you've seen, enabling/disabling multi-tenancy with ABP Framework is just a single line of change. If you decide to develop your application as multi-tenancy-enabled, you can continue with the next section to understand how ABP determines the current tenant from HTTP requests.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor465"/>Determining the current tenant</h2>
			<p>If you look at <em class="italic">Figure 16.1</em> again, you will see that<a id="_idIndexMarker1046"/> all the requests coming from the users are passing through the tenant resolution<a id="_idIndexMarker1047"/> component before executing the application code. This way, the current tenant becomes known inside your application.</p>
			<p>Intercepting the incoming requests is done with ABP's multi-tenancy middleware component. All the hosting projects in the startup solution template contain the following lines in the <strong class="source-inline">OnApplicationInitialization</strong> method of the ABP module class:</p>
			<p class="source-code">if (MultiTenancyConsts.IsEnabled)</p>
			<p class="source-code">{</p>
			<p class="source-code">    app.UseMultiTenancy();</p>
			<p class="source-code">}</p>
			<p>This middleware is added after the authentication middleware (because the user's authentication ticket is used on tenant resolution) and before the authorization middleware (because ABP authorizes users based on their tenants).</p>
			<p>The multi-tenancy middleware resolves the current tenant from the HTTP request and sets the <strong class="source-inline">ICurrentTenant</strong> properties that are used to obtain the current tenant information. The <strong class="source-inline">ICurrentTenant</strong> interface will be explained in the next section, but we should first understand how ABP determines the current tenant from the HTTP request.</p>
			<p>The current tenant information is obtained from the current HTTP request using<a id="_idIndexMarker1048"/> request parameters<a id="_idIndexMarker1049"/> in the following order:</p>
			<ol>
				<li>If the user (or client) has authenticated, then the current tenant's ID and name are extracted from the claims in the authentication ticket (either in the cookie or in the header, based on the authentication method).</li>
				<li>If <strong class="source-inline">AbpTenantResolveOptions</strong> is configured, the tenant's name is determined from the domain (or subdomain) name.</li>
				<li>The <strong class="source-inline">__tenant</strong> query string parameter is used to get the tenant's name or ID if the current HTTP request contains that parameter.</li>
				<li>The <strong class="source-inline">__tenant</strong> route parameter is used to get the tenant's name or ID if the current HTTP request contains that parameter.</li>
				<li>The <strong class="source-inline">__tenant</strong> HTTP header is used to get the tenant's name or ID if the current HTTP request contains that parameter.</li>
				<li>The <strong class="source-inline">__tenant</strong> cookie's value is used to get the tenant's name or ID if the current HTTP request contains that parameter.</li>
			</ol>
			<p>If ABP determines the tenant in any of the preceding steps, it doesn't continue to other steps as you might expect. If none of the information is found in the HTTP request, then it is assumed that the current user is a host user. All the options are already preconfigured and working when you create a new solution, so you typically do not make many configurations for your solution. You should only care about the domain name resolution, which is suggested in the production environment.</p>
			<p>The following example shows how to configure the domain name resolver in the <strong class="source-inline">ConfigureServices</strong> method of your module class:</p>
			<p class="source-code">Configure&lt;AbpTenantResolveOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.AddDomainTenantResolver("{0}.yourdomain.com");</p>
			<p class="source-code">});</p>
			<p>The <strong class="source-inline">AddDomainTenantResolver</strong> method accepts a domain format where the <strong class="source-inline">{0}</strong> part matches the tenant name. This means<a id="_idIndexMarker1050"/> if your tenant's name (the <strong class="source-inline">Name</strong> property of the <strong class="source-inline">Tenant</strong> class) is <strong class="source-inline">acme</strong>, then the <strong class="source-inline">acme</strong> users should use<a id="_idIndexMarker1051"/> the <strong class="source-inline">acme.yourdomain.com</strong> URL to enter the application.</p>
			<p>Once ABP resolves the tenant, we can work with the current tenant, as explained in the next section.</p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor466"/>Working with the current tenant</h2>
			<p>ABP determines the tenant<a id="_idIndexMarker1052"/> before executing our application<a id="_idIndexMarker1053"/> code, as we've learned in the previous section. We can get the current tenant's information using the <strong class="source-inline">ICurrentTenant</strong> service. The following example demonstrates how to use the <strong class="source-inline">ICurrentTenant</strong> service in an arbitrary class:</p>
			<p class="source-code">public class MyService : ITransientDependency</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly ICurrentTenant _currentTenant;</p>
			<p class="source-code">    public MyService(ICurrentTenant currentTenant)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _currentTenant = currentTenant;</p>
			<p class="source-code">    }</p>
			<p class="source-code">        </p>
			<p class="source-code">    public async Task DoItAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Guid? tenantId = _currentTenant.Id;</p>
			<p class="source-code">        string tenantName = _currentTenant.Name;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We've injected the <strong class="source-inline">ICurrentTenant</strong> service and accessed the <strong class="source-inline">Id</strong> and <strong class="source-inline">Name</strong> properties in the example method. The <strong class="source-inline">Id</strong> and <strong class="source-inline">Name</strong> properties return <strong class="source-inline">null</strong> if the current user<a id="_idIndexMarker1054"/> is a host user (which means that the tenant is not available). Some ABP base<a id="_idIndexMarker1055"/> classes already pre-inject the <strong class="source-inline">ICurrentTenant</strong> service, so you can directly use the <strong class="source-inline">CurrentTenant</strong> property, as shown in the following example:</p>
			<p class="source-code">public class MyAppService : ApplicationService</p>
			<p class="source-code">{</p>
			<p class="source-code">    public async Task DoItAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Guid? tenantId = CurrentTenant.Id;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Since the <strong class="source-inline">ApplicationService</strong> base class already has the <strong class="source-inline">CurrentTenant</strong> property (of the <strong class="source-inline">ICurrentTenant</strong> type), we can use it directly without manual injection.</p>
			<p><strong class="source-inline">ICurrentTenant</strong> has no more important properties. If you need to get more information/data for the current tenant, you have the tenant's <strong class="source-inline">Id</strong> property to query from the database.</p>
			<p>Most of the time, your application code<a id="_idIndexMarker1056"/> will work with the current tenant. But sometimes, you<a id="_idIndexMarker1057"/> may need to change the current tenant, as explained in the next section.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor467"/>Switching between tenants</h2>
			<p>The <strong class="source-inline">ICurrentTenant</strong> service is also used by ABP Framework to isolate the current tenant's data automatically<a id="_idIndexMarker1058"/> so that you don't accidentally access other tenant data. However, in some cases, you may need to work with another tenant's data in the same HTTP request and temporarily switch the tenant. The <strong class="source-inline">ICurrentTenant</strong> service is not only used to get information about the current tenant but also to switch to the desired tenant. See the following example:</p>
			<p class="source-code">public class MyAppService : ApplicationService</p>
			<p class="source-code">{</p>
			<p class="source-code">    public async Task DoItAsync(Guid tenantId)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Before the using block</p>
			<p class="source-code">        using (CurrentTenant.Change(tenantId))</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Inside the using block</p>
			<p class="source-code">            // CurrentTenant.Id equals to tenantId </p>
			<p class="source-code">        }</p>
			<p class="source-code">        // After the using block</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If you use the <strong class="source-inline">CurrentTenant.Id</strong> property before the <strong class="source-inline">using</strong> block, you get the tenant's ID that was resolved, as explained in the <em class="italic">Determining the current tenant</em> section. The <strong class="source-inline">CurrentTenant.Change</strong> method changes the current tenant to a given value, so you get the desired tenant's ID when using the <strong class="source-inline">CurrentTenant.Id</strong> property inside the <strong class="source-inline">using</strong> block. For example, if you perform a database query from a shared database inside the <strong class="source-inline">using</strong> block, ABP will retrieve the desired tenant's data instead of the one resolved by the multi-tenancy middleware. Once the <strong class="source-inline">using</strong> block completes, <strong class="source-inline">CurrentTenant.Id</strong> is automatically restored to the previous value. You can safely use the <strong class="source-inline">CurrentTenant.Change</strong> method in a nested way when you rarely need it. If you want to switch to the host context, you can pass a <strong class="source-inline">null</strong> value to the <strong class="source-inline">Change</strong> method. Always use the <strong class="source-inline">Change</strong> method with a <strong class="source-inline">using</strong> block, as in this example, to not affect<a id="_idIndexMarker1059"/> the surrounding context of your method.</p>
			<p>In addition to switching to the desired tenant, it is also possible to completely disable the tenant isolation.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor468"/>Disabling the data isolation</h2>
			<p>Data isolation is critical in a multi-tenant<a id="_idIndexMarker1060"/> application. It guarantees<a id="_idIndexMarker1061"/> to query only the current tenant's data. However, in some cases, your application may require querying from the entire database, including all tenants' data.</p>
			<p>We explored the ABP's data filtering<a id="_idIndexMarker1062"/> system in the <em class="italic">Using the data filtering system</em> section of <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>. ABP uses the same data-filtering system to filter data of the current tenant. So, we can use the same data-filtering API to disable the multi-tenancy filter temporarily:</p>
			<p class="source-code">public class ProductAppService : ApplicationService</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IRepository&lt;Product, Guid&gt;</p>
			<p class="source-code">        _productRepository;</p>
			<p class="source-code">    public ProductAppService(</p>
			<p class="source-code">        IRepository&lt;Product, Guid&gt; productRepository)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _productRepository = productRepository;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public async Task&lt;long&gt; GetTotalProductCountAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        using (DataFilter.Disable&lt;IMultiTenant&gt;())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            return await</p>
			<p class="source-code">                _productRepository.GetCountAsync();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we are getting the total number of products owned by all the tenants in the database. The multi-tenancy data filter is disabled in the <strong class="source-inline">using</strong> block, so the repository works with all the records in the database.</p>
			<p>While disabling the multi-tenancy<a id="_idIndexMarker1063"/> filter is pretty easy, there is an important<a id="_idIndexMarker1064"/> limitation – it only works with the single database approach. It cannot query a tenant's data if the tenant has a dedicated database. Currently, there is no direct way to perform a query on multiple databases and aggregate the query results as a single result set.</p>
			<p>Besides the technical<a id="_idIndexMarker1065"/> limitation, there is also a design problem with querying all tenants' data. Ideally, multi-tenant software should be designed so that all tenants have their on-premises deployment with separate database<a id="_idIndexMarker1066"/> and application servers. We will return to this discussion later in the <em class="italic">When to use multi-tenancy</em> section of this chapter.</p>
			<p>We've learned the ways to access and change the current tenant. In the next section, we will see how to design our entities to be multi-tenancy-compatible.</p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor469"/>Designing the domain as multi-tenant</h2>
			<p>ABP aims to make your application code multi-tenancy-unaware<a id="_idIndexMarker1067"/> and automate things wherever possible. Designing an entity class as multi-tenant<a id="_idIndexMarker1068"/> is very simple. Just implement the <strong class="source-inline">IMultiTenant</strong> interface for your entity, as shown in the following example:</p>
			<p class="source-code">public class Product : AggregateRoot&lt;Guid&gt;, IMultiTenant</p>
			<p class="source-code">{</p>
			<p class="source-code">    public Guid? TenantId { get; set; }</p>
			<p class="source-code">    public string Name { get; set; }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Product</strong> aggregate root entity in this example implements the <strong class="source-inline">IMultiTenant</strong> interface and defines a <strong class="source-inline">TenantId</strong> property. The tenant identifier type is always <strong class="source-inline">Guid</strong> in ABP Framework. The <strong class="source-inline">TenantId</strong> property is nullable, making the <strong class="source-inline">Product</strong> entity available both for the tenant and the host side. If the <strong class="source-inline">TenantId</strong> property is <strong class="source-inline">null</strong>, that entity belongs to the host side. It also allows us to easily convert our application to a single-tenant, on-premises application where the <strong class="source-inline">TenantId</strong> property is always <strong class="source-inline">null</strong>.</p>
			<p>ABP automatically sets the <strong class="source-inline">TenantId</strong> value using the <strong class="source-inline">ICurrentTenant.Id</strong> property when you create a new entity object (a <strong class="source-inline">Product</strong> object for this example). ABP is also responsible for saving it to the right database and querying from the right database, or filtering the tenant data if you are using a single database.</p>
			<p>We've learned the fundamental points of building a multi-tenant solution with ABP Framework. The next section introduces the ABP feature system that can be used to restrict application functionalities for tenants.</p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor470"/>Using the feature system</h1>
			<p>Most SaaS solutions<a id="_idIndexMarker1069"/> provide different packages to the customers. Every package has a different set of application features and is subscribed at a different price. ABP provides a feature system used to define such application features, and then disable or enable these features for individual tenants. Let's start by defining a feature.</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor471"/>Defining the features</h2>
			<p>It is required to define a feature before using it. Create a new class deriving from the <strong class="source-inline">FeatureDefinitionProvider</strong> class (typically in the <strong class="source-inline">.Application.Contracts</strong> project<a id="_idIndexMarker1070"/> in the startup solution) and override the <strong class="source-inline">Define</strong> method, as shown in the following example:</p>
			<p class="source-code">public class MyAppFeatureDefinitionProvider :</p>
			<p class="source-code">    FeatureDefinitionProvider</p>
			<p class="source-code">{</p>
			<p class="source-code">    public override void Define(</p>
			<p class="source-code">        IFeatureDefinitionContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var myGroup = context.AddGroup("MyApp");        </p>
			<p class="source-code">        myGroup.AddFeature(</p>
			<p class="source-code">            "MyApp.StockManagement",</p>
			<p class="source-code">            defaultValue: "false",</p>
			<p class="source-code">            displayName: L("StockManagement"),</p>
			<p class="source-code">            isVisibleToClients: true);        </p>
			<p class="source-code">        myGroup.AddFeature(</p>
			<p class="source-code">            "MyApp.MaxProductCount", </p>
			<p class="source-code">            defaultValue: "100",</p>
			<p class="source-code">            displayName: L("MaxProductCount"));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private ILocalizableString L(string name)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return </p>
			<p class="source-code">            LocalizableString.Create&lt;MtDemoResource&gt;(name);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Features are grouped to create more modular systems (where every module defines its own group). In this example, I created a feature group for the final application. Then, I defined two features under that group. This example defines<a id="_idIndexMarker1071"/> the two features:</p>
			<ul>
				<li>The first one is used to enable or disable the stock management feature for tenants.</li>
				<li>The second one is used to limit the product entity count.</li>
			</ul>
			<p>Feature values are actually just strings, such as <strong class="source-inline">false</strong> and <strong class="source-inline">100</strong> in this example. However, Boolean values (<strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>) can be used for conditional checks by convention.</p>
			<p>ABP automatically discovers classes derived from the <strong class="source-inline">FeatureDefinitionProvider</strong> class, so you don't need to register it somewhere. After defining a feature, we can check its value for the current tenant (we will see how to assign features to tenants later, in the <em class="italic">Managing tenant features</em> section).</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor472"/>Checking for the features</h2>
			<p>I will show you how to enable, disable, or set<a id="_idIndexMarker1072"/> the value of a feature for a tenant in the <em class="italic">Managing tenant features</em> section. But first, I want to show you how we check a feature's value for a tenant.</p>
			<p>There are several ways to check a feature's value for the current tenant. The easiest way is to use the <strong class="source-inline">RequiresFeature</strong> attribute that can be used on methods or classes.</p>
			<h3>Using the RequiresFeature attribute</h3>
			<p>The following example<a id="_idIndexMarker1073"/> uses the <strong class="source-inline">RequiresFeature</strong> attribute to restrict a class's usage for the current tenant:</p>
			<p class="source-code">[RequiresFeature("MyApp.StockManagement")]</p>
			<p class="source-code">public class StockAppService : ApplicationService,</p>
			<p class="source-code">    IStockAppService</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>This way, the <strong class="source-inline">MyApp.StockManagement</strong> feature's value is automatically checked in every method call for the <strong class="source-inline">StockAppService</strong> service, and an exception is thrown for unauthorized access.</p>
			<p>The <strong class="source-inline">RequiresFeature</strong> attribute can also be used on a method. See the following example:</p>
			<p class="source-code">public class ProductAppService : ApplicationService</p>
			<p class="source-code">{</p>
			<p class="source-code">    ...    </p>
			<p class="source-code">    [RequiresFeature("MyApp.StockManagement")]</p>
			<p class="source-code">    public async Task&lt;long&gt; GetStockCountAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return await _productRepository.GetCountAsync();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this case, only the <strong class="source-inline">GetStockCountAsync</strong> method is restricted, and the other methods of <strong class="source-inline">ProductAppService</strong> without the <strong class="source-inline">RequiresFeature</strong> attribute are not affected.</p>
			<p>The <strong class="source-inline">RequiresFeature</strong> attribute is easy to use but limited to Boolean features (with <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong> values). For detailed<a id="_idIndexMarker1074"/> usage, we should use the <strong class="source-inline">IFeatureChecker</strong> service.</p>
			<h3>Using the IFeatureChecker service</h3>
			<p>The <strong class="source-inline">IFeatureChecker</strong> service allows<a id="_idIndexMarker1075"/> us to get and check the feature values programmatically. You can inject it just like any other service. The following example checks whether the <strong class="source-inline">MyApp.StockManagement</strong> feature is enabled for the current tenant:</p>
			<p class="source-code">public async Task&lt;long&gt; GetStockCountAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (await FeatureChecker</p>
			<p class="source-code">             .IsEnabledAsync("MyApp.StockManagement"))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return await _productRepository.GetCountAsync();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // TODO: Your fallback logic or error message</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">IsEnabled</strong> method returns <strong class="source-inline">true</strong> only if the feature's value is <strong class="source-inline">true</strong> (as <strong class="source-inline">string</strong>). If you have fallback logic (when the tenant doesn't have that feature enabled), then using <strong class="source-inline">IsEnabledAsync</strong> is a good approach. However, if you only want to check whether a feature is enabled and should throw an exception otherwise, use the <strong class="source-inline">CheckEnabledAsync</strong> method, as shown in the following example:</p>
			<p class="source-code">public async Task&lt;long&gt; GetStockCountAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    await FeatureChecker.CheckEnabledAsync("MyApp.StockManagement");</p>
			<p class="source-code">    return await _productRepository.GetCountAsync();</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">CheckEnabledAsync</strong> method throws <strong class="source-inline">AbpAuthorizationException</strong> if the given feature is not enabled for the current tenant. However, if you need to simply check whether a feature is enabled or disabled at the beginning of the method, using the <strong class="source-inline">RequiresFeature</strong> attribute would be simpler.</p>
			<p>Using the <strong class="source-inline">IFeatureChecker</strong> service is especially useful when you want to get the value of non-Boolean features. For example, the <strong class="source-inline">MyApp.MaxProductCount</strong> feature introduced in the <em class="italic">Defining the features</em> section is a numeric feature. We can't simply check whether it is enabled or disabled. We need to know its value for the current user.</p>
			<p>The following example checks<a id="_idIndexMarker1076"/> the maximum allowed product count for the current tenant before creating a new product:</p>
			<p class="source-code">public async Task CreateAsync(string name)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var currentProductCount = await</p>
			<p class="source-code">        _productRepository.GetCountAsync();</p>
			<p class="source-code">    var maxProductCount = await</p>
			<p class="source-code">           FeatureChecker.GetAsync&lt;int&gt;(</p>
			<p class="source-code">               "MyApp.MaxProductCount");</p>
			<p class="source-code">    if (currentProductCount &gt;= maxProductCount)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // TODO: Throw a business exception</p>
			<p class="source-code">    }    </p>
			<p class="source-code">    // TODO: Continue to create the product</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">FeatureChecker.GetAsync&lt;T&gt;</strong> method returns the value of the given feature by converting to the given generic type argument. Here, <strong class="source-inline">MyApp.MaxProductCount</strong> is a numeric feature, so I am converting to <strong class="source-inline">int</strong> and then comparing it with the current product count of the current tenant. <strong class="source-inline">IFeatureChecker</strong> also defines the <strong class="source-inline">GetOrNullAsync</strong> method that returns the string value of the feature or returns <strong class="source-inline">null</strong> if the feature has no value defined for the current tenant.</p>
			<p class="callout-heading">Checking the Feature of Another Tenant</p>
			<p class="callout">The <strong class="source-inline">IFeatureChecker</strong> service works for the current tenant. If you want to check a feature's value for another tenant when you have the other tenant's ID, first switch to the target tenant, as explained in the <em class="italic">Switching between tenants</em> section, and then use the <strong class="source-inline">IFeatureChecker</strong> service as normal.</p>
			<p>The <strong class="source-inline">RequiresFeature</strong> attribute and the <strong class="source-inline">IFeatureChecker</strong> service are used on the server side, but we also need to get<a id="_idIndexMarker1077"/> and check feature values in our client applications.</p>
			<h3>Checking features on the client side</h3>
			<p>When you define a feature, you will need to know its value on the client side. For example, if the <strong class="source-inline">MyApp.StockManagement</strong> feature is not enabled for the current tenant, you generally want to hide<a id="_idIndexMarker1078"/> the related UI elements from the application pages and disable the client-to-server HTTP API calls for this feature.</p>
			<p>ABP provides multiple UI options, and each one provides a different API to check the features on the client side. For example, the ABP MVC/Razor Pages UI provides the global <strong class="source-inline">abp.features</strong> JavaScript API to check the features, as shown in the following code block:</p>
			<p class="source-code">if (abp.features.isEnabled('MyApp.StockManagement'))</p>
			<p class="source-code">{</p>
			<p class="source-code">  // TODO: ...</p>
			<p class="source-code">}</p>
			<p>Please see the <em class="italic">Checking the tenant features</em> section of <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>, for more details about the <strong class="source-inline">abp.features</strong> JavaScript API.</p>
			<p>The ABP Blazor UI, on the other<a id="_idIndexMarker1079"/> hand, uses the same <strong class="source-inline">IFeatureChecker</strong> service on the client side. For other UI types, please<a id="_idIndexMarker1080"/> refer to ABP's documentation: <a href="https://docs.abp.io/en/abp/latest/Features">https://docs.abp.io/en/abp/latest/Features</a>.</p>
			<p>You've now learned how to get and check a feature's value for the current tenant. The next section explains how you can set the value of a feature for a tenant.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor473"/>Managing tenant features</h2>
			<p>At a framework level, ABP doesn't care where the feature values are stored and how they are changed. It just defines<a id="_idIndexMarker1081"/> an interface, <strong class="source-inline">IFeatureStore</strong>, that can be implemented to obtain the current value of a feature. However, it would not be good to leave its implementation to every developer because, most of the time, the implementation will be similar, and we don't want to waste our time re-implementing it again and again.</p>
			<p>ABP Framework provides the <strong class="bold">Feature Management</strong> module, which implements<a id="_idIndexMarker1082"/> the <strong class="source-inline">IFeatureStore</strong> interface and provides a UI and API to modify the feature values for the tenants. The Feature Management module is already installed when you create a new solution using ABP's startup solution template. The following sections explain the Feature Management UI modal and the API to manage the feature values.</p>
			<h3>Using the Feature Management UI modal</h3>
			<p>The Feature Management module can automatically<a id="_idIndexMarker1083"/> create the modal dialog to set the feature values. However, we need to define the value type for each feature. Return to <strong class="source-inline">MyFeatureDefinitionProvider</strong> and update the feature definitions as follows:</p>
			<p class="source-code">myGroup.AddFeature(</p>
			<p class="source-code">    "MyApp.StockManagement",</p>
			<p class="source-code">    defaultValue: "false",</p>
			<p class="source-code">    displayName: L("StockManagement"),</p>
			<p class="source-code">    isVisibleToClients: true,</p>
			<p class="source-code">    valueType: new ToggleStringValueType());</p>
			<p class="source-code">myGroup.AddFeature(</p>
			<p class="source-code">    "MyApp.MaxProductCount", </p>
			<p class="source-code">    defaultValue: "100",</p>
			<p class="source-code">    displayName: L("MaxProductCount"),</p>
			<p class="source-code">    valueType: new FreeTextStringValueType(</p>
			<p class="source-code">                   new NumericValueValidator()));</p>
			<p>I added <strong class="source-inline">valueType</strong> parameters to the <strong class="source-inline">AddFeature</strong> methods. The first one is <strong class="source-inline">ToggleStringValueType</strong>, which indicates that the feature has an on/off style (Boolean) value. The second one is <strong class="source-inline">FreeTextStringValueType</strong>, which indicates that the feature has a value that should be changed with a textbox. <strong class="source-inline">NumericValueValidator</strong> specifies the validation rule for the value.</p>
			<p>Once we have defined<a id="_idIndexMarker1084"/> the value types properly, the Feature Management module can automatically render the necessary UI to set the feature values. To open the Feature Management dialog, log in to the application as an authorized host user, navigate to the tenant management page from the main menu, click the <strong class="bold">Actions</strong> button, and select the <strong class="bold">Features</strong> action, as shown in the following figure:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/Figure_16.2_B17287.jpg" alt="Figure 16.2 – The Features action on the tenant management page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.2 – The Features action on the tenant management page</p>
			<p>This action will open a modal dialog, as shown in the following figure:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/Figure_16.3_B17287.jpg" alt="Figure 16.3 – The Feature Management dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.3 – The Feature Management dialog</p>
			<p>We can see the group name on the left side (you can also localize the group's display name). When we click the <strong class="bold">MyApp</strong> group, we can see the form<a id="_idIndexMarker1085"/> elements to set the values of the features. The UI has been dynamically created by the Feature Management module.</p>
			<p>The <strong class="source-inline">MyApp.StockManagement</strong> feature becomes a checkbox on the UI, while a numeric textbox is shown for the <strong class="source-inline">MyApp.MaxProductCount</strong> feature. This way, you can easily set the feature values for any tenant. In addition to the UI, it is also possible to programmatically<a id="_idIndexMarker1086"/> set the feature values using the Feature Management API.</p>
			<h3>Using the Feature Management API</h3>
			<p>The Feature Management module<a id="_idIndexMarker1087"/> provides the <strong class="source-inline">IFeatureManager</strong> service to set a feature's value for a tenant programmatically. The following example enables the <strong class="source-inline">MyApp.StockManagement</strong> feature for the given tenant:</p>
			<p class="source-code">public class MyCustomerService : DomainService</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IFeatureManager _featureManager;</p>
			<p class="source-code">    public MyCustomerService(IfeatureManager</p>
			<p class="source-code">                             featureManager)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _featureManager = featureManager;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    public async Task EnableStockManagementAsync(Guid</p>
			<p class="source-code">                                                 tenantId)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        await _featureManager.SetForTenantAsync(</p>
			<p class="source-code">            tenantId,</p>
			<p class="source-code">            "MyApp.StockManagement",</p>
			<p class="source-code">            "true"</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We are injecting the <strong class="source-inline">IFeatureManager</strong> service into our class's constructor, just like any other service. Then, we use the <strong class="source-inline">SetForTenantAsync</strong> method to set <a id="_idIndexMarker1088"/>the value to <strong class="source-inline">true</strong> for the given tenant.</p>
			<h1 id="_idParaDest-350"><a id="_idTextAnchor474"/>When to use multi-tenancy</h1>
			<p>Multi-tenancy is a great pattern to create<a id="_idIndexMarker1089"/> SaaS solutions, and ABP Framework provides a complete infrastructure to create multi-tenant applications. However, not all applications should be SaaS, and not all SaaS applications should be multi-tenant. ABP's multi-tenancy system has some assumptions, and we've made some design decisions while building it. In this section, I want to talk about these assumptions and decisions to help you to decide whether ABP's multi-tenancy system fits into your solution.</p>
			<p>ABP multi-tenant applications should be developed by assuming that each tenant will have a separated and isolated production environment. If you make this assumption, then you will have some<a id="_idIndexMarker1090"/> restrictions. Here are a few example restrictions:</p>
			<ul>
				<li>You should not perform database queries from multiple tenants at once. If you do this, you assume that you will have a shared tenant database because it is technically not straightforward to query from multiple databases from different (and probably isolated) environments.</li>
				<li>A tenant's user cannot log in to the system with another tenant. This means you can't assign multiple tenants to a single user since users are completely isolated. ABP allows using the same email address or user name in different tenants, but they will actually be different users with different passwords and identifiers in the database, without any relation.</li>
				<li>You cannot share roles (and their permissions) between different tenants.</li>
			</ul>
			<p>These are natural restrictions if you assume that two tenants have different production environments and can't access each other's environment. ABP assumes that the same application can be deployed on-premises for a customer without any code change (except the <strong class="source-inline">AbpMultiTenancyOptions.IsEnabled</strong> option).</p>
			<p>These assumptions don't mean that the tenants cannot share data at all. If an entity doesn't implement the <strong class="source-inline">IMultiTenant</strong> interface, it is naturally shared among all tenants and always stored in the central (host) database. In addition, you can switch between tenants to temporarily access a tenant's data from another tenant user. However, you should think about how this logic will work in an on-premises environment, or you can drop the on-premises deployment support from your solution.</p>
			<p>Most of the confusion comes from thinking about the multi-tenancy only from a technical perspective but not thinking about its purpose of design. For example, think of an electronic marketplace where vendors manage and sell their products. Individual customers list and search products, add to a cart, and make a payment. This application may seem like a multi-tenant system if you assume that the vendors have their own products and vendor back-office users manage these products. If you use ABP's multi-tenancy system, all the isolation will be automatically done, right? </p>
			<p>While it has some requirements similar to a multi-tenant system from a technical perspective, the marketplace is likely to have parts that are integrated as a unified platform. In a multi-tenant system, a customer (tenant) behaves as if it owns the entire system. In a marketplace, a vendor is not a tenant. It does not use an application in isolation, as in an on-premises system. So, if you start with multi-tenancy, you will later have to deal with the problems of data sharing and integrations because shared/integrated parts are much<a id="_idIndexMarker1091"/> more than the isolated parts in such a system.</p>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor475"/>Summary</h1>
			<p>In this chapter, we've explored the fundamental infrastructure provided by ABP Framework. We've learned how ABP determines the current tenant and isolates the data between the tenants. We also learned how to switch to another tenant or completely disable the data isolation when needed.</p>
			<p>Another great ABP feature is the feature system. We've defined features by creating a feature provider class and learned different ways of checking the value of a feature for the current user.</p>
			<p>You are now able to work on a multi-tenant application's development where the tenants can have different rights on the application features.</p>
			<p>The next chapter introduces different levels of automated testing and explains how you can create unit and integration tests for your ABP-based solutions.</p>
		</div>
	</body></html>