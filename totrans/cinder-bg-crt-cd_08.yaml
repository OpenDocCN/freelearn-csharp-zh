- en: Chapter 8. Adding Depth – Cinder 3D Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to the basic 3D aspects and practical methods
    as well as the 3D primitives that can be drawn with Cinder. We will start by making
    a transition from 2D coordinate system to 3D, and continue with basic problems
    and solutions that we are going to face in the 3D graphics programming world from
    now on. We will also add basic animation during the walkthrough to demonstrate
    the basic approach of adding movement to the otherwise static objects.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the 3D space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Cinder with 3D we need to understand a bit about 3D computer graphics.
    First thing that we need to know is that 3D graphics are created in a three-dimensional
    space that exists somewhere in the computer and is transformed into a two-dimensional
    image that can be displayed on our computer screens afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Usually there is a projection (frustrum) that has different properties which
    are similar to the properties of cameras we have in the real world. **Frustrum**
    takes care of rendering all the 3D objects that are visible in frustrum. It is
    responsible for creating the 2D image that we see on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the 3D space](img/9564_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, all objects inside the frustrum are
    being rendered on the screen. Objects outside the view frustrum are being ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL (that is being used for drawing in Cinder) relies on the so called rendering
    pipeline to map the 3D coordinates of the objects to the 2D screen coordinates.
    Three kind of matrices are used for this process: the model, view, and projection
    matrices. The model matrix maps the 3D object''s local coordinates to the world
    (or global) space, the view matrix maps it to the camera space, and finally the
    projection matrix takes care of the mapping to the 2D screen space. Older versions
    of OpenGL combine the model and view matrices into one—the **modelview** matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters we used 2D coordinates (x and y coordinate axes) to
    place different kinds of objects and graphics on the screen. Now we will take
    advantage of the third dimension—the z axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinate system in Cinder starts from the top-left corner of the screen.
    Any object placed there has the coordinates 0, 0, 0 (these are values of x, y,
    and z respectively). The x axis extends to the right, y to the bottom, but z extends
    towards the viewer (us), as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the 3D space](img/9564_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, the coordinate system in Cinder is a
    bit different from the one in OpenGL. The built-in OpenGL drawing functions in
    Cinder takes care of the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing in 3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to draw something by taking into account that there is a third dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Create another project by using **TinderBox** and name it `Basic3D`. Open the
    project file (`xcode/Basic3D.xcodeproj` on Mac or `vc10\Basic3D.sln` on Windows).
    Open `Basic3DApp.cpp` in the editor and navigate to the `draw()` method implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `gl::clear()` method add the following line to draw a cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter defines the position of the center of the cube, the second
    defines its size. Note that we use the `Vec3f()` variables to define position
    and size within three (x, y and z) dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project. This will draw a solid cube at the top-left corner
    of the screen. We are able to see just one quarter of it because the center of
    the cube is the reference point. Let''s move it to the center of the screen by
    transforming the previous line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we are positioning the cube in the middle of the screen no matter what the
    window's width or height is, because we pass half of the window's width (`getWindowWidth()/2`)
    and half of the window's height (`getWindowHeight()/2`) as values for the x and
    y coordinates of the cube's location. Compile and run the project to see the result.
    Play around with the size parameters to understand the logic behind it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want to rotate the cube a bit. There is a built-in `rotate()` function
    that we can use. One of the things that we have to remember, though, is that we
    have to use it before drawing the object. So add the following line before `gl::drawCube()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the project. You should see a strange rotation animation around
    the y axis. The problem here is that the `rotate()` function rotates the whole
    3D world of our application including the object in it and it does so by taking
    into account the scene coordinates. As the center of the 3D world (the place where
    all axes cross and are zero) is in the top-left corner, all rotation is happening
    around this point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing in 3D](img/9564_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To change that we have to use the `translate()` function. It is used to move
    the scene (or canvas) before we `rotate()` or `drawCube()`. To make our cube rotate
    around the center of the screen, we have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `translate()` function to translate the 3D world to the center of the
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `rotate()`function to rotate the 3D world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the object (`drawCube()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `translate()`function to translate the scene back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have to use the `translate()` function to translate the scene back to the
    location, because each time we call `translate()` values are added instead of
    being replaced. In code it should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So now we get a smooth rotation of the cube around the y axis. The rotation
    angle around y axis is increased in each frame by 1 degree as we pass the `Vec3f::yAxis()*1`
    value to the `rotate()` function. Experiment with the rotation values to understand
    this a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want the cube to be in a constant rotated position? We have to remember
    that the `rotate()` function works similar to the translate function. It adds
    values to the rotation of the scene instead of replacing them. Instead of rotating
    the object back, we will use the `pushMatrices()` and `popMatrices()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation and translation are transformations. Every time you call `translate()`
    or `rotate()`, you are modifying the modelview matrix. If something is done, it
    is sometimes not so easy to undo it. Every time you transform something, changes
    are being made based on all previous transformations in the current state.
  prefs: []
  type: TYPE_NORMAL
- en: So what is this state? Each state contains a copy of the current transformation
    matrices. By calling `pushModelView()` we enter a fresh state by making a copy
    of the current modelview matrix and storing it into the stack. We will make some
    crazy transformations now without worrying about how we will undo them. To go
    back, we call `popModelView()` that pops (or deletes) the current modelview matrix
    from the stack, and returns us to the state with the previous modelview matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s try this out by adding the following code after the `gl::clear()`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run our program now, you should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing in 3D](img/9564_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, before doing anything, we create a copy of the current state
    with `pushModelView()`. Then we do the same as before, translate our scene to
    the middle of the screen, rotate it (this time `35` degrees around x axis and
    `20` degrees around y axis), and finally draw the cube! To reset the stage to
    the state it was before, we have to use just one line of code, `popModelView()`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nested states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to create nested states by using the previously discussed functions.
    By using two `pushModelView()` calls in a row, we are storing two different states.
    By calling one `popModelView()` afterwards, we pop just the last pushed modelview
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our `draw()` method implementation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `gl::pushModelView()` and `gl::popModelView()`. Compile and
    run the project, you should see a ring of smaller cubes surrounding the one we
    saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try to move the `gl::rotate()` call before the `for` loop and after the
    `gl::translate()` call. Compile and run the project. You should see a bit of a
    different image than the one you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding nested states](img/9564_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a simple demonstration of nested states. Try to experiment in the way
    we just did, by adding extra transformations and changing their order. Furthermore,
    OpenGL is not limited to just two levels of nested states. You could try to add
    orbiting objects around each of the small squares by adding more `pushModelView()`
    and `popModelView()` functions inside another `for` loop, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Handling depth sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the 3D primitive drawing functions that are built into
    Cinder. There are not a lot of them but as Cinder is meant to be a bit more low
    level than other similar tools, you should continue to learn some OpenGL afterwards
    to get the most out of Cinder and drawing in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with changing the single colored cube into something more colorful
    and adding some constant rotation to it as it was before. To do that, we will
    have to replace the `drawCube()` function call with `drawColorCube()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run and compile the application, you will see that the cube is drawn
    somehow strange. This is the effect of inappropriate depth sorting. A 3D model
    consists of vertices that are placed at different depths in the current projection.
    These vertices form faces that also have different depth information that is taken
    into account when transforming them into pixels at different depths. If these
    vertices are not sorted and drawn in appropriate order according to their depth
    information, we get an image where the faces and objects behind in the back of
    the scene are drawn in front and the opposite. To avoid this, we have to enable
    the depth read feature of the OpenGL. Add these lines of code in the `setup()`
    method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After you compile and run the project, the cube should look just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling depth sorting](img/9564_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With that done, let''s add some rotation animation. To do this we will need
    to declare some variables that will take care of storing the rotation variables.
    Then we will need to assign initial values to them in the `setup()` method, change
    them in the `update()` method, and finally draw in the `draw()` method implementation.
    Let''s start with declaring the variables. Add these lines just after the `setup()`,
    `update()`, and `draw()` method declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using one `float` variable for the current and increment rotation
    angle around each axis we are using the `Vec3f` datatype to be able to store the
    rotation values in one variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to assign the initial values to these variables now. Go to the `setup()`
    method implementation and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, go to the `update()` method implementation and add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will increment the rotation around all the three axis on each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we have to make use of the `currentRotation` variable while drawing.
    Change the parameter of the `gl::rotate()` function before the `gl::drawColorCube()`
    call to `currentRotation` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now the rotation values will be increased and updated on each frame. Compile
    and run the project to see for yourself! You should get a nice rotation animation.
    Try to do the same with the location and size of the cube for better understanding
    of how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other Cinder 3D primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s try out the different 3D primitives that Cinder supplies it''s own
    functions for. We just tried to draw a different kind of cube, so let''s continue
    with something equally classic, a sphere. Replace the `gl::drawColorCube()` function
    call with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of this function defines the center of the sphere and the
    second defines the radius. There is a third (optional) parameter `int` that controls
    the number of segments the sphere is made of. The default value is 12, but you
    might want to change it to a higher value to increase the smoothness of the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project. You should see an image similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other Cinder 3D primitives](img/9564_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem here is that it does not look quite 3D. As you might have already
    guessed, the problem is that there is no light. To add light to the scene, add
    the following lines in the `setup()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These are OpenGL functions that are responsible for turning the light on. The
    first one enables light as such, the second is turning on the first light or `GL_LIGHT0`.
    There are ways of positioning and changing it's parameters, but we won't dig into
    this as it is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project to see the sphere with lights turned on. You should
    get a result that is similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other Cinder 3D primitives](img/9564_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to draw something else instead of a sphere. How about a cylinder?
    Replace the `drawSphere()` function call with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will draw an open-ended cylinder on the screen. The first parameter defines
    the width of the cylinder base, the second parameter defines the width of the
    cylinder top. The third parameter defines the cylinder height.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we compile and run the application, you will notice that the cylinder
    is not rotating around it''s center like the cube or sphere we drew before. That
    is because of the way it is drawn – from the bottom up instead of both – up and
    down. To change that, we can draw another cylinder, with a negative height or
    change the `translate()` values. For the sake of simplicity, let''s draw another
    cylinder. Replace the cylinder drawing code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the same cylinder but now it rotates around its center. Another
    thing that we might want to add are the closed ends of the cylinder. We have to
    use 2D shapes again to accomplish this task. Add the following lines of code directly
    after the `drawCylinder()` function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'gl::drawSolidCircle(Vec2f(0,0), 50, 12);     Not too easy, right? There is no `drawSolidCircle()` function that would draw
    a circle based on 3D coordinates yet, but this is a kind of shorthand anyway so
    we don''t have to write pure OpenGL. What these lines of code do is that they
    move the scene or canvas in appropriate position and rotation relative to the
    already drawn cylinder to draw the top and the bottom of it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the code a bit, so we see another thing that is possible with
    the `drawCylinder()` function that is drawing a cone or even a pyramid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Delete or comment out the `drawSolidCircle()` part and change the top values
    of the `drawCylinder()` functions to `0` and add a fourth value (and set it to
    `4` or more if you want to draw a cone) that represents the slice count of the
    cylinder.
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling and running the application, a pyramid is not quite what we
    see. Let''s call it a diamond to describe the shape more correctly. In the following
    screenshot you can see an image strip with the `gl::drawCylinder()` adjustments
    we just did:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other Cinder 3D primitives](img/9564_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another basic shape worth introducing is the torus. Cinder has a built-in function
    for drawing this and this is how the function looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Add the preceding line of code after the cylinder drawing function calls. The
    first parameter defines the outer radius (the circle responsible for the base
    shape of the torus), the second defines the inner radius or the radius if the
    circle that is used for creating the volume of the torus.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things look even more straightedged, let''s add the third and fourth
    parameter that are responsible for the longitude and latitude segment count of
    the torus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run the application now, we should see an image similar to
    one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other Cinder 3D primitives](img/9564_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sum up, in this chapter we introduced ourselves with the very basic 3D stuff
    that can be done with Cinder. We understood a bit about the concept of 3D space
    as well as how to draw and animate objects in this space. We learned to switch
    on the lightning and construct more complex shapes out of primitives.
  prefs: []
  type: TYPE_NORMAL
- en: There is more, but to get the real graphics power out of Cinder, you have to
    learn some more of OpenGL and the **OpenGL Shading Language** (**GLSL**).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk less about graphics but more about what is
    possible with Cinder in terms of audio.
  prefs: []
  type: TYPE_NORMAL
