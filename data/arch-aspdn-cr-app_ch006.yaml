- en: 5 Minimal API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 最小化API
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的Discord书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“EARLY ACCESS SUBSCRIPTION”下找到“architecting-aspnet-core-apps-3e”频道）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file24.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file24.png)'
- en: 'This chapter covers Minimal APIs, a simplified way of setting up and running
    .NET applications. We explore what makes Minimal Hosting and Minimal APIs a pivotal
    update in ASP.NET Core as we unravel the simplicity of creating APIs with less
    ceremony. We cover many possibilities that ASP.NET Core Minimal API brings, like
    how to configure, customize, and organize those endpoints.We also explore using
    Minimal APIs with Data Transfer Objects (DTOs), combining simplicity with effective
    data management to structure API contracts effectively.Inspired by other technologies,
    these topics bring a fresh perspective to the .NET world, allowing us to build
    lean and performant APIs without compromising resiliency.In this chapter, we cover
    the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了最小化API，这是一种简化设置和运行.NET应用程序的方法。我们探讨了使最小化托管和最小化API成为ASP.NET Core关键更新的原因，我们揭示了创建API的简洁性。我们涵盖了ASP.NET
    Core最小化API带来的许多可能性，例如如何配置、自定义和组织这些端点。我们还探讨了使用数据传输对象（DTOs）与最小化API结合使用，将简洁性与有效的数据管理相结合，有效地构建API合同。受其他技术启发，这些主题为.NET世界带来了新的视角，使我们能够在不牺牲弹性的情况下构建精简且性能良好的API。在本章中，我们涵盖了以下主题：
- en: Top-level statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级语句
- en: Minimal Hosting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化托管
- en: Minimal APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化API
- en: Using Minimal APIs with Data Transfer Objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据传输对象（DTOs）与最小化API
- en: Let’s begin with Top-level statements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶级语句开始。
- en: Top-level statements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶级语句
- en: 'The .NET team introduced top-level statements to the language in .NET 5 and
    C# 9\. From that point, writing statements before declaring namespaces and other
    members is possible. Under the hood, the compiler emits those statements into
    a `Program.Main` method.With top-level statements, a minimal .NET “Hello World”
    console program looked like this (`Program.cs`):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET团队在.NET 5和C# 9中向语言引入了顶级语句。从那时起，在声明命名空间和其他成员之前编写语句成为可能。在底层，编译器将这些语句输出到`Program.Main`方法。使用顶级语句，一个最小的.NET“Hello
    World”控制台程序看起来像这样（`Program.cs`）：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unfortunately, we still need a project to run it, so we have to create a `.csproj`
    file with the following content:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们仍然需要一个项目来运行它，因此我们必须创建一个包含以下内容的`.csproj`文件：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From there, we can use the .NET CLI to `dotnet run` the application, and it
    will output the following in the console before the program terminates:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以使用.NET CLI来`dotnet run`应用程序，并在程序终止前在控制台输出以下内容：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On top of such statements, we can also declare other members, like classes,
    and use them in our application. However, we must declare classes at the end of
    the top-level code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的语句之上，我们还可以声明其他成员，如类，并在我们的应用程序中使用它们。然而，我们必须在顶级代码的末尾声明类。
- en: Be aware that the top-level statement code is not part of any namespace, and
    creating classes in a namespace is recommended, so you should limit the number
    of declarations done in the `Program.cs` file to what is internal to its inner
    workings, if anything.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，顶级语句代码不属于任何命名空间，建议在命名空间中创建类，因此您应该将`Program.cs`文件中进行的声明数量限制在其内部工作内部，如果有的话。
- en: Top-level statements are great for getting started with C#, writing code samples,
    and cutting out boilerplate code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级语句非常适合开始使用C#，编写代码示例，并删除样板代码。
- en: 'The highlighted line of the preceding C# code (`using System;`) is unnecessary
    when the *implicit usings* feature is enabled, which is the default in .NET 6+
    projects. The templates add the following line to the `.csproj` file:'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的C#代码中（`using System;`），当启用*隐式使用*功能时，该功能是.NET 6+项目的默认设置，高亮显示的行是不必要的。模板将以下行添加到`.csproj`文件中：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we explore the minimal hosting model built using top-level statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨使用顶级语句构建的最小化托管模型。
- en: Minimal Hosting
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化托管
- en: '.NET 6 introduced the minimal hosting model. It combines the `Startup` and
    `Program` classes into a single `Program.cs` file. It leverages top-level statements
    to minimize the boilerplate code necessary to bootstrap the application. It also
    uses *global using directives* and the *implicit usings* feature to reduce the
    amount of boilerplate code further. This model only requires one file with the
    following three lines of code to create a web application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 引入了最小化托管模型。它将 `Startup` 和 `Program` 类合并为一个 `Program.cs` 文件。它利用顶层语句来最小化启动应用程序所需的样板代码。它还使用
    *全局使用指令* 和 *隐式使用* 功能进一步减少样板代码。此模型只需要一个文件，包含以下三行代码即可创建 Web 应用程序：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s call that way leaner than before. Of course, the preceding code starts
    an app that does nothing, but doing the same before would have required tens of
    lines of code.The minimal hosting code is divided into two pieces:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这种方法比之前更精简。当然，前面的代码启动了一个什么也不做的应用程序，但要在之前做同样的事情，可能需要数十行代码。最小化托管代码分为两部分：
- en: The *web application builder* we use to configure the application, register
    services, settings, environment, logging, and more (the highlighted code).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的 *Web 应用程序构建器* 来配置应用程序、注册服务、设置、环境、日志等（高亮显示的代码）。
- en: The *web application* we use to configure the HTTP pipeline and routes (the
    non-highlighted lines).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的 *Web 应用程序* 来配置 HTTP 管道和路由（非高亮显示的行）。
- en: That simplified model led to minimal APIs that we explore next.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化的模型导致了我们接下来要探讨的最小化 API。
- en: Minimal APIs
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化 API
- en: ASP.NET Core’s Minimal APIs are built on the minimal hosting model and bring
    a lean approach to constructing web applications. Highly inspired by Node.js,
    they facilitate the development of APIs by reducing the boilerplate code. By emphasizing
    simplicity and performance, they enhance readability and maintainability. They
    are an excellent fit for microservices architecture and applications that aim
    to remain lean.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的最小化 API 建立在最小化托管模型之上，为构建 Web 应用程序提供了一种精简的方法。高度受 Node.js 启发，它们通过减少样板代码来简化
    API 的开发。通过强调简单性和性能，它们提高了可读性和可维护性。它们非常适合微服务架构和旨在保持精简的应用程序。
- en: You can also build large applications using Minimal APIs; the word minimal refers
    to their lean approach, not the type of application you can make with them.
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您也可以使用最小化 API 构建大型应用程序；这里的“最小化”指的是它们精简的方法，而不是您可以使用它们创建的应用程序类型。
- en: This minimalist approach does compromise a little on functionalities but improves
    flexibility and speed, ensuring you have complete control over your API’s behavior
    while keeping your project lean and efficient. Minimal APIs include the necessary
    features we need for most applications, like model binding, dependency injection,
    filters, and a route-to-delegate model. If you need all the features from MVC,
    you can still opt to use MVC. You can even use both; this is not one or the other.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最小化方法在功能上略有妥协，但提高了灵活性和速度，确保您对 API 的行为有完全的控制权，同时保持项目精简高效。最小化 API 包含大多数应用程序所需的必要功能，如模型绑定、依赖注入、过滤器以及路由到代理模型。如果您需要
    MVC 的所有功能，您仍然可以选择使用 MVC。您甚至可以使用两者；这并不是非此即彼。
- en: We explore the Model-View-Controller (MVC) pattern in *Chapter 6*, *MVC*.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在 *第 6 章* 中探讨了模型-视图-控制器 (MVC) 模式，*MVC*。
- en: Let’s have a look at how to map routes next.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何映射路由。
- en: Map route-to-delegate
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射路由到代理
- en: 'How does it work? Minimal APIs bring multiple extension methods to configure
    the HTTP pipeline and configure endpoints. We can use those methods to map a route
    (a URL pattern) to a `RequestDelegate` delegate.We can use the following methods
    to map different HTTP methods:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？最小化 API 带来了多个扩展方法来配置 HTTP 管道和配置端点。我们可以使用这些方法将路由（URL 模式）映射到 `RequestDelegate`
    代理。我们可以使用以下方法来映射不同的 HTTP 方法：
- en: '| **Method** | **Description** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `MapGet` | Maps a `GET` request to a `RequestDelegate` . |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `MapGet` | 将 `GET` 请求映射到 `RequestDelegate`。|'
- en: '| `MapPost` | Maps a `POST` request to a `RequestDelegate` . |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `MapPost` | 将 `POST` 请求映射到 `RequestDelegate`。|'
- en: '| `MapPut` | Maps a `PUT` request to a `RequestDelegate` . |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `MapPut` | 将 `PUT` 请求映射到 `RequestDelegate`。|'
- en: '| `MapDelete` | Maps a `DELETE` request to a `RequestDelegate` . |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `MapDelete` | 将 `DELETE` 请求映射到 `RequestDelegate`。|'
- en: '| `MapMethods` | Maps a route pattern and multiple HTTP methods to a `RequestDelegate`
    . |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `MapMethods` | 将路由模式和多个 HTTP 方法映射到 `RequestDelegate`。|'
- en: '| `Map` | Maps a route pattern to a `RequestDelegate` . |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | 将路由模式映射到 `RequestDelegate`。|'
- en: '| `MapFallback` | Maps a fallback `RequestDelegate` which runs when no other
    routes match. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `MapFallback` | 将回退 `RequestDelegate` 映射到没有其他路由匹配时运行的。|'
- en: '| `MapGroup` | Allows configuring a route pattern and properties that apply
    to all endpoints defined under that group. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `MapGroup` | 允许配置适用于该组下定义的所有端点的路由模式属性。|'
- en: 'Table 5.1: Map route-to-delegate extension methods.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：映射路由到委托的扩展方法。
- en: 'Here’s a minimal GET example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个最小 GET 示例：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When executing the program, navigating to the `/minimal-endpoint-inline` URI
    routes the request to the registered `RequestDelegate` (highlighted code), which
    outputs the following string:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行程序时，导航到 `/minimal-endpoint-inline` URI 将请求路由到已注册的 `RequestDelegate`（高亮代码），它输出以下字符串：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As simple as that, we can route requests to delegates and create endpoints.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，我们就可以将请求路由到委托并创建端点。
- en: On top of registering endpoints, we can also register middleware like any other
    ASP.NET Core application. Moreover, the built-in middlewares, like authentication
    and CORS, work the same with Minimal APIs.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在注册端点的基础上，我们还可以像任何其他 ASP.NET Core 应用程序一样注册中间件。此外，内置的中间件，如身份验证和 CORS，与最小 API
    的工作方式相同。
- en: Next, we explore ways to configure endpoints so we can create better APIs than
    an endpoint returning a literal string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索配置端点的方法，这样我们就可以创建比返回字面字符串的端点更好的 API。
- en: Configuring endpoints
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置端点
- en: 'Now that we know that with minimal APIs, we map routes to delegates and that
    we have learned of a few methods to do that, let’s explore how to register the
    delegates:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了，使用最小 API，我们将路由映射到委托，并且我们已经了解了一些实现此目的的方法，让我们探索如何注册委托：
- en: Inline, as with the preceding example.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联，就像前面的示例一样。
- en: Using a method.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法。
- en: 'To declare the delegate inline, we can do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要内联声明委托，我们可以这样做：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To use a method, we can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用方法，我们可以这样做：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When enabled, ASP.NET Core registers the class name that contains the method
    with the `ApiExplorer` as a tag. We dig deeper into metadata further in the chapter.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当启用时，ASP.NET Core 将包含方法的类名注册到 `ApiExplorer` 作为标签。我们将在本章的后面进一步探讨元数据。
- en: All the concepts we explore in this chapter apply to both ways of registering
    delegates. Let’s start by studying how to input data in our endpoints.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中探讨的所有概念都适用于两种注册委托的方式。让我们首先研究如何在端点中输入数据。
- en: Inputs
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'An endpoint rarely has no parameter (no input value). Minimal APIs, like MVC,
    support a wide variety of binding sources. A binding source represents the conversion
    from the HTTP request into a strongly typed C# object, inputted as a parameter.
    Most of the parameter binding happens implicitly, but in case you need to bind
    a parameter explicitly, here are the supported binding sources:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 端点很少没有参数（没有输入值）。类似于 MVC 的最小 API 支持广泛的绑定来源。绑定来源表示将 HTTP 请求转换为强类型 C# 对象的过程，该对象作为参数输入。大多数参数绑定都是隐式的，但如果你需要显式绑定参数，以下是一些支持的绑定来源：
- en: '| **Source** | **Attribute** | **Description** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **源** | **属性** | **描述** |'
- en: '| `Route` | `[FromRoute]` | Binds the route value that matches the name of
    the parameter. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Route` | `[FromRoute]` | 绑定与参数名称匹配的路由值。|'
- en: '| `Query` | `[FromQuery]` | Binds the query string value that matches the name
    of the parameter. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Query` | `[FromQuery]` | 绑定与参数名称匹配的查询字符串值。|'
- en: '| `Header` | `[FromHeader]` | Binds the HTTP header value that matches the
    name of the parameter. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Header` | `[FromHeader]` | 绑定与参数名称匹配的 HTTP 头部值。|'
- en: '| `Body` | `[FromBody]` | Binds the JSON body of the request to the parameter’s
    type. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `Body` | `[FromBody]` | 将请求的 JSON 主体绑定到参数的类型。|'
- en: '| `Form` | `[FromForm]` | Binds the form value that matches the name of the
    parameter. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `Form` | `[FromForm]` | 绑定与参数名称匹配的表单值。|'
- en: '| `Services` | `[FromServices]` | Inject the service from the ASP.NET Core
    dependency container. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `Services` | `[FromServices]` | 从 ASP.NET Core 依赖注入容器中注入服务。|'
- en: '| `Custom` | `[AsParameters]` | Binds the form values to a type. The matches
    happen between the form keys and the properties'' names. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `Custom` | `[AsParameters]` | 将表单值绑定到类型。匹配发生在表单键和属性名称之间。|'
- en: 'Table 5.2: supported binding sources'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2：支持的绑定来源
- en: 'Next is a demo where we implicitly bind the `id` parameter from the route (highlighted
    code) to a parameter in the delegate:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个演示，我们将路由中的 `id` 参数（高亮代码）隐式绑定到委托中的参数：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In most cases, the bindings work implicitly. However, you can explicitly bind
    the delegate’s parameters like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，绑定是隐式的。但是，你可以像这样显式绑定委托的参数：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also implicitly inject dependencies into our delegates and even mix
    that with a route parameter like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以隐式地将依赖项注入到我们的委托中，甚至可以与路由参数混合使用，如下所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Following this pattern opens endless possibilities to input data into our endpoints.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种模式，我们可以为我们的端点输入数据提供无限的可能性。
- en: If you are unfamiliar with Dependency Injection (DI), we explore DI more in-depth
    in *Chapter 8*, *Dependency Injection*. Meanwhile, remember that we can bind objects
    to parameters, whether they are a DTO or a service.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您不熟悉依赖注入（DI），我们将在第 8 章 *依赖注入* 中更深入地探讨 DI。同时，请记住，我们可以将对象绑定到参数，无论它们是 DTO 还是服务。
- en: On top of that, ASP.NET Core provides us with a few special types, which we
    explore next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ASP.NET Core 还为我们提供了一些特殊类型，我们将在下面进行探讨。
- en: Special types
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 特殊类型
- en: 'We can inject the following objects into our delegates as parameters, and ASP.NET
    Core manages them for us:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将以下对象作为参数注入到我们的委托中，ASP.NET Core 会为我们管理它们：
- en: '| **Class** | **Description** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **描述** |'
- en: '| `HttpContext` | The `HttpContext` encompasses all the current HTTP request
    and response details.The `HttpContext` exposes all the other special types we
    are exploring here, so if you need more than one, you can inject the `HttpContext`
    directly to reduce the number of parameters. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `HttpContext` | `HttpContext` 包含了所有当前的 HTTP 请求和响应细节。`HttpContext` 暴露了我们正在探讨的所有其他特殊类型，因此如果您需要多个类型，可以直接注入
    `HttpContext` 以减少参数数量。|'
- en: '| `HttpRequest` | We can use the `HttpRequest` to do basic HTTP operations
    on the current request, like query the parameters manually and bypass the ASP.NET
    Core data-binding mechanism. Same as the `HttpContext.Request` property. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `HttpRequest` | 我们可以使用 `HttpRequest` 在当前请求上执行基本的 HTTP 操作，例如手动查询参数并绕过 ASP.NET
    Core 数据绑定机制。与 `HttpContext.Request` 属性相同。|'
- en: '| `HttpResponse` | Like the `HttpRequest` , we can leverage the `HttpResponse`
    object to execute manual operations on the HTTP response, like writing directly
    to the response stream, managing HTTP headers manually, etc. Same as the `HttpContext.Response`
    property. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `HttpResponse` | 与 `HttpRequest` 类似，我们可以利用 `HttpResponse` 对象在 HTTP 响应上执行手动操作，例如直接写入响应流、手动管理
    HTTP 头等。与 `HttpContext.Response` 属性相同。|'
- en: '| `CancellationToken` | Passing a cancellation token to an asynchronous operation
    is a recommended practice. In this case, it allows canceling the operation when
    the request is canceled. Same as the `HttpContext.RequestAborted` property. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `CancellationToken` | 将取消标记传递给异步操作是一种推荐的做法。在这种情况下，它允许在请求被取消时取消操作。与 `HttpContext.RequestAborted`
    属性相同。|'
- en: '| `ClaimsPrincipal` | To access the current user, we can inject a `ClaimsPrincipal`
    instance. Same as the `HttpContext.User` property. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `ClaimsPrincipal` | 要访问当前用户，我们可以注入一个 `ClaimsPrincipal` 实例。与 `HttpContext.User`
    属性相同。|'
- en: 'Tabel 5.3: special HTTP types'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3：特殊 HTTP 类型
- en: 'Here’s an example where two endpoints write to the response stream, one using
    the `HttpContext` and the other the `HttpResponse` object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中两个端点写入响应流，一个使用 `HttpContext`，另一个使用 `HttpResponse` 对象：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can treat those special types like any other bindings and seamlessly integrate
    them with other types, such as route values and services.We cover one last piece
    of data-binding next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些特殊类型视为任何其他绑定，并与其他类型（如路由值和服务）无缝集成。我们将在下一节介绍数据绑定的最后一部分。
- en: Custom binding
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自定义绑定
- en: 'We can manually bind data from the request to an instance of a custom class.
    We can achieve this in the following ways:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动将请求数据绑定到自定义类的实例。我们可以通过以下方式实现：
- en: Create a static `TryParse` method that parses a string from a route, query,
    or header value.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个静态的 `TryParse` 方法，用于解析来自路由、查询或头值的字符串。
- en: Create a static `BindAsync` method that directly controls the binding process
    using the `HttpContext`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个静态的 `BindAsync` 方法，直接使用 `HttpContext` 控制绑定过程。
- en: We must write those static methods in the class we intend to create using the
    HTTP request’s data. We explore those two scenarios next.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在打算使用 HTTP 请求数据的类中编写这些静态方法。我们将在下面探讨这两种场景。
- en: Manual parsing
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 手动解析
- en: 'The `TryParse` method takes a string and an `out` parameter of the type itself.
    The framework uses that method to parse a value into the desired type.The parsing
    API supports the implementation of one of the following methods:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryParse` 方法接受一个字符串和一个自身类型的 `out` 参数。框架使用该方法将值解析为所需类型。解析 API 支持实现以下方法之一：'
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implementing the `IParsable<TSelf>` interface provides the appropriate `TryParse`
    method.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现 `IParsable<TSelf>` 接口提供了适当的 `TryParse` 方法。
- en: 'Here is an example that parses latitude and longitude coordinates:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，它解析了经纬度坐标：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the endpoint returns a JSON representation of the `Coordinate`
    class, while the `TryParse` method parses the input string into a `Coordinate`
    object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，端点返回了 `Coordinate` 类的 JSON 表示形式，而 `TryParse` 方法将输入字符串解析为 `Coordinate`
    对象。
- en: The `Parse` method of the `Coordinate` class comes from the `IParsable<TSelf>`
    interface and is not needed for model binding.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Coordinate` 类的 `Parse` 方法来自 `IParsable<TSelf>` 接口，对于模型绑定不是必需的。'
- en: 'For example, if we request the following URI:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们请求以下 URI：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The endpoint returns:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 端点返回：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Parsing a string into an object is a viable choice for simple scenarios. However,
    more complex scenarios require another technique that we explore next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串解析为对象是简单场景的一个可行选择。然而，更复杂的场景需要另一种技术，我们将在下一部分探讨。
- en: Manual binding
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 手动绑定
- en: 'The `BindAsync` method takes an `HttpContext` and a `ParameterInfo` parameter
    and returns a `ValueTask<TSelf>` where `TSelf` is the type we are writing data
    binding for. The `HttpContext` represents the source of the data (the HTTP request),
    and the `ParameterInfo` represents the delegate’s parameter, from which we could
    want to know something, like its name.The data-binding API supports the implementation
    of one of the following methods:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindAsync` 方法接受一个 `HttpContext` 和一个 `ParameterInfo` 参数，并返回一个 `ValueTask<TSelf>`，其中
    `TSelf` 是我们进行数据绑定的类型。`HttpContext` 表示数据源（HTTP 请求），而 `ParameterInfo` 表示代表参数的委托，我们可以从中获取一些信息，比如它的名称。数据绑定
    API 支持实现以下方法之一：'
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Implementing the `IBindableFromHttpContext<TSelf>` interface provides the appropriate
    `BindAsync` method.
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现 `IBindableFromHttpContext<TSelf>` 接口提供了适当的 `BindAsync` 方法。
- en: 'Here is an example that binds a `Person` from the HTTP request’s query parameters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，它将 `Person` 从 HTTP 请求的查询参数中绑定：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code returns a JSON representation of the person. For example,
    if we request the following URI:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码返回了人的 JSON 表示形式。例如，如果我们请求以下 URI：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The endpoint returns:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 端点返回：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see, the `BindAsync` method is way more powerful than the `TryParse`
    method because we can access a broader range of options using the `HttpContext`,
    allowing us to cover complex use cases.However, in this case, we could have leveraged
    the `[AsParameters]` attribute to achieve the same result and get the data from
    the query without needing to write the data-binding code manually. What a great
    opportunity to explore this attribute; here’s the updated version of the same
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`BindAsync` 方法比 `TryParse` 方法强大得多，因为我们可以使用 `HttpContext` 访问更广泛的选择，从而允许我们覆盖更复杂的使用场景。然而，在这种情况下，我们可以利用
    `[AsParameters]` 属性来实现相同的结果，并从查询中获取数据，而无需手动编写数据绑定代码。这是一个探索该属性的好机会；以下是相同代码的更新版本：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s it; the `AsParameters` attribute did the work for us!Now that we covered
    reading the input values from different places in the HTTP request, it is time
    to explore how to output results.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；`AsParameters` 属性为我们完成了工作！现在我们已经涵盖了从 HTTP 请求的不同位置读取输入值，是时候探索如何输出结果了。
- en: Outputs
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'There are several ways to output data from our delegates:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从我们的委托中输出数据：
- en: Return a serializable object.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个可序列化的对象。
- en: Return an `IResult` implementation.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个 `IResult` 实现的实例。
- en: Return a `Results<TResult1, TResult2, …, TResultN>` where the `TResult` generic
    parameters represent the different `IResult` implementation the endpoint can return.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个 `Results<TResult1, TResult2, …, TResultN>`，其中 `TResult` 泛型参数表示端点可以返回的不同
    `IResult` 实现。
- en: We explore those possibilities next.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分探讨那些可能性。
- en: Serializable object
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可序列化对象
- en: 'The first is to return a serializable object, as we did in the previous section
    about inputs. ASP.NET Core serializes the object into a JSON string and sets the
    `Content-Type` header to `application/json`. This is the easiest way to do it
    but also the less flexible.For example, the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是返回一个可序列化的对象，就像我们在关于输入的上一节中所做的那样。ASP.NET Core 将对象序列化为 JSON 字符串，并将 `Content-Type`
    标头设置为 `application/json`。这是最简单的方法，但也是灵活性最低的方法。例如，以下代码：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Outputs the following JSON string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以下 JSON 字符串：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The problem with this approach is that we don’t control the status code, nor
    can we return multiple different results from the endpoint. For example, if the
    endpoint returns `200 OK` in one case and `404 Not Found` in another. To help
    us with this, we explore the `IResult` abstraction next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们无法控制状态码，也无法从端点返回多个不同的结果。例如，如果端点在一个情况下返回 `200 OK`，在另一个情况下返回 `404 Not
    Found`。为了帮助我们，我们将探讨 `IResult` 抽象。
- en: IResult
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: IResult
- en: The next option is to return the `IResult` interface. We can leverage the `Results`
    or `TypedResults` classes from the `Microsoft.AspNetCore.Http` namespace to do
    that.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是返回 `IResult` 接口。我们可以利用来自 `Microsoft.AspNetCore.Http` 命名空间的 `Results` 或
    `TypedResults` 类来实现这一点。
- en: I recommend defaulting to using `TypedResults`, which .NET 7 introduced.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我建议默认使用 .NET 7 引入的 `TypedResults`。
- en: The main difference between the two is that the methods in the `Results` class
    return `IResult`, while those in `TypedResults` return a typed implementation
    of the `IResult` interface. This difference may sound insignificant, but it changes
    everything regarding discoverability by the API Explorer. The API Explorer can’t
    automatically discover the API contract of the former, while it can for the latter.
    This is possible because the compiler can infer the return type, but it creates
    challenges when returning more than one result type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个之间的主要区别在于 `Results` 类中的方法返回 `IResult`，而 `TypedResults` 类中的方法返回 `IResult`
    接口的类型化实现。这种区别可能听起来微不足道，但它改变了 API 探索器可发现性的方方面面。API 探索器无法自动发现前者的 API 合同，而可以自动发现后者。这是可能的，因为编译器可以推断返回类型，但在返回多个结果类型时会产生挑战。
- en: This choice impacts the amount of work you’ll have to put into getting well-crafted
    OpenAPI specifications automatically (or not so automatically).
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个选择会影响你需要投入多少工作量来获得精心制作的 OpenAPI 规范（自动或不那么自动）。
- en: 'The following two endpoints explicitly state the result is 200 OK, one with
    each class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个端点明确指出结果是 200 OK，每个端点使用一个类：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When looking at the generated OpenAPI specifications, the first endpoint has
    no return value, while the other has a `Coordinate` definition mimicking our C#
    class. Next, we dig deeper into the `TypedResults` class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看生成的 OpenAPI 规范时，第一个端点没有返回值，而其他端点有一个模仿我们 C# 类的 `Coordinate` 定义。接下来，我们更深入地探讨
    `TypedResults` 类。
- en: Typed results
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型化结果
- en: We can use the methods of the `TypedResults` class to generate strongly-typed
    outputs. They allow us to control the output while informing ASP.NET Core of the
    specifics, like the status code and return type.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `TypedResults` 类的方法生成强类型输出。它们允许我们控制输出，同时通知 ASP.NET Core 有关具体信息，如状态码和返回类型。
- en: Please note that for the sake of simplicity, I've omitted variants and overloads,
    focusing solely on the fundamental of each method in the tables.
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，为了简化，我已省略变体和重载，仅关注表中每个方法的本质。
- en: 'Let’s start with the successful status code, where the `200 OK` status code
    is most likely the most common:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从成功状态码开始，其中 `200 OK` 状态码可能是最常见的：
- en: '| **Method** | **Description** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Accepted` | Produces a `202 Accepted` response, indicating the beginning
    of an asynchronous process. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `Accepted` | 生成一个 `202 Accepted` 响应，表示异步过程的开始。|'
- en: '| `Created` | Produces a `201 Created` response, indicating the system created
    the entity, the location of the entity, and the entity itself. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `Created` | 生成一个 `201 Created` 响应，表示系统创建了实体，实体的位置以及实体本身。|'
- en: '| `Ok` | Produces a `200 OK` response, indicating the operation was successful.
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `Ok` | 生成一个 `200 OK` 响应，表示操作成功。|'
- en: 'Table 5.4: TypedResults successful status code methods.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.4：TypedResults 成功状态码方法。
- en: 'On top of the successes, we must know how to tell clients about the errors.
    For example, the `400 Bad Request` and `404 Not Found` are very common to point
    out the issues with the request. The following table contains methods to assist
    in indicating such issues to the clients:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的基础上，我们必须知道如何向客户端报告错误。例如，`400 Bad Request` 和 `404 Not Found` 非常常见，用于指出请求中的问题。以下表格包含帮助向客户端指示此类问题的方法：
- en: '| **Method** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `BadRequest` | Produces a `400 Bad Request` response, indicating an issue
    with the client request, often a validation error. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `BadRequest` | 生成一个 `400 Bad Request` 响应，表示客户端请求存在问题，通常是验证错误。|'
- en: '| `Conflict` | Produces a `409 Conflict` response, indicating a conflict occurred
    when processing the request, often a concurrency error. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `Conflict` | 生成 `409 Conflict` 响应，表示在处理请求时发生了冲突，通常是一个并发错误。|'
- en: '| `NotFound` | Produces a `404 Not Found` response, indicating the resource
    was not found. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `NotFound` | 生成 `404 Not Found` 响应，表示未找到资源。|'
- en: '| `Problem` | Produces a response adhering to the *Problem Details* structure
    defined by **RFC7807** , providing a standardized encapsulation of the error.
    We can modify the status code, which defaults to a `500 Internal Server Error`
    . |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Problem` | 生成遵循由 **RFC7807** 定义的 *问题详情* 结构的响应，提供错误的标准封装。我们可以修改默认为 `500 内部服务器错误`
    的状态码。|'
- en: '| `UnprocessableEntity` | Produces a `422 Unprocessable Content` response,
    indicating that while the server comprehends the request''s content type and the
    syntax is correct, it cannot process the instructions or the entity. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `UnprocessableEntity` | 生成 `422 Unprocessable Content` 响应，表示服务器理解请求的内容类型和语法是正确的，但不能处理指令或实体。|'
- en: '| `ValidationProblem` | Produces a `400 Bad Request` response adhering to the
    *Problem Details* structure defined by **RFC7807** . We can use this method to
    communicate input validation problems to the client. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `ValidationProblem` | 生成遵循由 **RFC7807** 定义的 *问题详情* 结构的 `400 Bad Request`
    响应。我们可以使用此方法向客户端传达输入验证问题。|'
- en: 'Table 5.5: TypedResults problematic status code.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.5：TypedResults 问题状态码。
- en: Leveraging the *Problem Details* structure improves the interoperability of
    our API by choosing a standard instead of crafting a custom way of returning our
    API errors.
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 利用 *问题详情* 结构通过选择标准而不是自定义返回API错误的方式，提高了我们API的互操作性。
- en: 'It is rarer in APIs than with conventional web applications to send redirections
    to clients, yet, we can redirect the clients to another URL with one of the following
    methods when needed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在API中，与常规Web应用相比，向客户端发送重定向较为罕见，然而，在需要时，我们可以使用以下方法之一将客户端重定向到另一个URL：
- en: '| **Method** | **Description** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `LocalRedirect` | Produces a `301 Moved Permanently`, `302 Found`, `307 Temporary
    Redirect`, or `308 Permanent Redirect` based on the specified arguments.This method
    throws an exception at runtime if the URL is not local, which is an excellent
    option to ensure dynamically generated URLs are not sending users away. For example,
    when the URL is composed using user inputs. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `LocalRedirect` | 根据指定的参数生成 `301 Moved Permanently`、`302 Found`、`307 Temporary
    Redirect` 或 `308 Permanent Redirect`。如果URL不是本地URL，此方法将在运行时抛出异常，这是一个确保动态生成的URL不会将用户带离的绝佳选项。例如，当URL使用用户输入组成时。|'
- en: '| `Redirect` | Produces a `301 Moved Permanently` , `302 Found` , `307 Temporary
    Redirect` , or `308 Permanent Redirect` based on the specified arguments. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `Redirect` | 根据指定的参数生成 `301 Moved Permanently`、`302 Found`、`307 Temporary
    Redirect` 或 `308 Permanent Redirect`。|'
- en: 'Table 5.6: TypedResults redirection status code.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.6：TypedResults 重定向状态码。
- en: 'Sending files to the client is another helpful feature; for example, the API
    could protect the files using authorization. The following table showcases a few
    helper methods to send files to the client:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 向客户端发送文件是另一个有用的功能；例如，API可以使用授权来保护文件。以下表格展示了几个发送文件到客户端的辅助方法：
- en: '| **Method** | **Description** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `File` | Writes the file content to the response stream.The `File` methods
    are aliases for the `Bytes` and `Stream` methods. We look at those soon. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `File` | 将文件内容写入响应流。`File` 方法是 `Bytes` 和 `Stream` 方法的别名。我们很快就会看到这些方法。|'
- en: '| `PhysicalFile` | Writes the content of a physical file to the response using
    an absolute or relative path.Caution: Do not expose this method to raw user inputs
    because it can read files outside the web content root. So a malicious actor could
    craft a request to access restricted files. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicalFile` | 将物理文件的内容写入响应，使用绝对或相对路径。注意：不要将此方法暴露给原始用户输入，因为它可以读取位于Web内容根目录之外的文件。因此，恶意行为者可以构建一个请求来访问受限制的文件。|'
- en: '| `VirtualFile` | Writes the content of a physical file to the response using
    an absolute or relative path.This method limits the file''s location to the web
    content root and is safer when dealing with user inputs. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `VirtualFile` | 使用绝对或相对路径将物理文件的内容写入响应。此方法将文件的位置限制在Web内容根目录，在处理用户输入时更安全。|'
- en: 'Table 5.7: TypedResults methods for downloading files.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.7：下载文件的 TypedResults 方法。
- en: 'On top of the methods we have explored so far, the following table lists ways
    to handle the content directly in its raw format. These content-handling methods
    can become handy when you need more control over what is happening:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经探讨的方法之上，以下表格列出了直接以原始格式处理内容的方法。当您需要更多控制内容时，这些内容处理方法会变得非常有用：
- en: '| **Method** | **Description** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Bytes` | Writes the byte-array or `ReadOnlyMemory<byte>` content directly
    to the response. It defaults to sending an `application/octet-stream` MIME Type
    to the client. This default behavior can be customized as needed. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `Bytes` | 将字节数组或 `ReadOnlyMemory<byte>` 内容直接写入响应。默认情况下，它向客户端发送 `application/octet-stream`
    MIME 类型，但这种默认行为可以根据需要自定义。|'
- en: '| `Content` | Writes the specified content `string` to the response stream.
    It defaults to sending a `text/plain` MIME Type to the client. This default behavior
    can be customized as needed. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `Content` | 将指定的内容 `string` 写入响应流。默认情况下，它向客户端发送 `text/plain` MIME 类型，但这种默认行为可以根据需要自定义。|'
- en: '| `Json` | Serializes the specified object to JSON. It defaults to sending
    an `application/json` MIME Type to the client with a `200 OK` status code. These
    default behaviors can be customized as needed.Compared to the other methods, like
    the `Ok` method, the primary advantage is that it allows us to use a non-default
    instance of the `JsonSerializerOptions` class to configure the serialization of
    the response. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `Json` | 将指定的对象序列化为 JSON。默认情况下，它向客户端发送带有 `200 OK` 状态码的 `application/json`
    MIME 类型，但这些默认行为可以根据需要自定义。与其他方法（如 `Ok` 方法）相比，主要优势是它允许我们使用非默认的 `JsonSerializerOptions`
    类实例来配置响应的序列化。|'
- en: '| `NoContent` | Produces an empty `204 No Content` response. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `NoContent` | 产生一个空的 `204 No Content` 响应。|'
- en: '| `StatusCode` | Produces an empty response with the specified status code.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `StatusCode` | 产生一个带有指定状态码的空响应。|'
- en: '| `Stream` | Allows writing directly to the response stream from another `Stream`.
    It defaults to sending an `application/octet-stream` MIME Type to the client.
    This default behavior can be customized as needed.This method is highly customizable,
    returns a `200 OK` status code by default, and supports range requests that produce
    a status code `206 Partial Content` or `416 Range Not Satisfiable`. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `Stream` | 允许从另一个 `Stream` 直接写入响应流。默认情况下，它向客户端发送 `application/octet-stream`
    MIME 类型，但这种默认行为可以根据需要自定义。此方法高度可定制，默认返回 `200 OK` 状态码，并支持产生状态码 `206 Partial Content`
    或 `416 Range Not Satisfiable` 的范围请求。|'
- en: '| `Text` | Writes the content string to the HTTP response. It defaults to sending
    a `text/plain` MIME Type to the client. This default behavior can be customized
    as needed, as well as the text encoding. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | 将内容字符串写入 HTTP 响应。默认情况下，它向客户端发送 `text/plain` MIME 类型，但这种默认行为可以根据需要自定义，以及文本编码。|'
- en: 'Table 5.8: TypedResults raw content handling methods.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.8：TypedResults 原始内容处理方法。
- en: The `application/octet-stream` MIME Type suggests that the response body is
    a file without specifying its type, which typically prompts the browser to download
    the file.
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`application/octet-stream` MIME 类型表明响应体是一个未指定类型的文件，这通常会导致浏览器下载文件。'
- en: 'Finally, we can leverage the following methods of the `TypedResults` class
    to create security flows. Most of these methods rely on the current implementation
    of the `IAuthenticationService` interface, which dictates their behavior:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以利用 `TypedResults` 类的以下方法来创建安全流程。这些方法中的大多数依赖于 `IAuthenticationService`
    接口的当前实现，这决定了它们的行为：
- en: '| **Method** | **Description** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Challenge` | Initiates a challenge for authentication when an unauthenticated
    user requests an endpoint that necessitates authentication. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `Challenge` | 当未经身份验证的用户请求需要身份验证的端点时，启动身份验证挑战。|'
- en: '| `Forbid` | Invoke when an authenticated user tries to access a resource for
    which they do not have the necessary permissions.By default, it produces a `403
    Forbidden` response, although the behavior may vary depending on the specific
    authentication scheme. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `Forbid` | 当经过身份验证的用户尝试访问他们没有必要权限的资源时调用。默认情况下，它会产生一个 `403 Forbidden` 响应，但具体行为可能因特定的身份验证方案而异。|'
- en: '| `SignIn` | Commences the sign-in process for a user, based on the specified
    authentication scheme. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `SignIn` | 根据指定的身份验证方案开始用户的登录过程。|'
- en: '| `SignOut` | Initiates the sign-out process for the given authentication scheme.
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `SignOut` | 为给定的身份验证方案启动注销过程。|'
- en: '| `Unauthorized` | Produces a `401 Unauthorized` response. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `Unauthorized` | 产生一个 `401 Unauthorized` 响应。|'
- en: 'Table 5.9: TypedResults security-related methods.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.9：TypedResults 安全相关方法。
- en: Now that we have covered the `TypedResults` possibilities, we explore how to
    return those typed results next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 `TypedResults` 的可能性，接下来我们将探讨如何返回这些类型化的结果。
- en: Returning multiple typed results
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回多个类型化结果
- en: 'While returning a single typed result is helpful, the capability to produce
    multiple results is better aligned with real-life scenarios. As we previously
    examined, it''s possible to return multiple `IResult` objects, but we''re restricted
    to a single typed result. This limitation arises from the compiler''s inability
    to identify a shared interface and deduce an `IResult` return type from the typed
    results. Even if the compiler could, that wouldn''t enhance discoverability.To
    overcome this limitation, .NET 7 introduced the `Results<T1, TN>` types, allowing
    us to return up to six different typed results.Here’s an example that returns
    `200 OK` when the random number is even and `209 Conflict` when it is odd:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然返回单个类型化的结果是有帮助的，但能够产生多个结果的能力与实际场景更加契合。正如我们之前所探讨的，我们可以返回多个 `IResult` 对象，但我们被限制在只能返回单个类型化的结果。这种限制源于编译器无法识别共享接口，并从类型化结果中推断出
    `IResult` 返回类型。即使编译器能够做到，这也不会提高可发现性。为了克服这一限制，.NET 7 引入了 `Results<T1, TN>` 类型，允许我们返回多达六个不同的类型化结果。以下是一个示例，当随机数是偶数时返回
    `200 OK`，当它是奇数时返回 `209 Conflict`：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This also works with methods like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于类似的方法：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adopting this approach enhances the API Explorer's comprehension of the API,
    thereby allowing libraries like Swagger and Swagger UI to automatically generate
    more accurate and detailed API documentation.Next, we explore adding more metadata
    to endpoints.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法可以增强 API 探索器对 API 的理解，从而允许像 Swagger 和 Swagger UI 这样的库自动生成更准确和详细的 API 文档。接下来，我们将探讨如何向端点添加更多元数据。
- en: Metadata
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元数据
- en: 'Sometimes, relying solely on automatic metadata is not enough. That’s why ASP.NET
    Core offers different helper methods to fine-tune the metadata of our endpoints.
    We can use most helper methods with groups and routes. In the case of a group,
    the metadata cascades to its children, whether it is another group or a route.
    However, a child can override the inherited values by changing the metadata.Here’s
    a partial list of helpers and their usage:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅仅依赖自动元数据是不够的。这就是为什么 ASP.NET Core 提供了不同的辅助方法来微调我们端点的元数据。我们可以使用大多数辅助方法与组和路由一起使用。在组的情况下，元数据会级联到其子项，无论它是另一个组还是路由。然而，子项可以通过更改元数据来覆盖继承的值。以下是一些辅助方法和它们的使用示例的部分列表：
- en: '| **Method** | **Description** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Accepts` | Specifies the supported request content types.*Only applicable
    to routes.* |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `Accepts` | 指定支持的请求内容类型。*仅适用于路由。* |'
- en: '| `AllowAnonymous` | Specifies that anonymous users can access the endpoint(s).
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `AllowAnonymous` | 允许匿名用户访问端点。 |'
- en: '| `CacheOutput` | Adds an output caching policy to the endpoint(s). |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `CacheOutput` | 为端点添加输出缓存策略。 |'
- en: '| `DisableRateLimiting` | Turns off the rate-limiting feature on the endpoint(s).
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `DisableRateLimiting` | 关闭端点上的速率限制功能。 |'
- en: '| `ExcludeFromDescription` | Excludes the item from the API Explorer data.
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `ExcludeFromDescription` | 将项目排除在 API 探索器数据之外。 |'
- en: '| `Produces``ProducesProblem``ProducesValidationProblem` | Describes a response,
    including its type, content type, and status code.*Only applicable to routes.*
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `Produces``ProducesProblem``ProducesValidationProblem` | 描述一个响应，包括其类型、内容类型和状态码。*仅适用于路由。*
    |'
- en: '| `RequireAuthorization` | Specifies that only authorized users can access
    the endpoint(s). We can be more granular by using one of the overloads. For example,
    we can specify a policy name or an `AuthorizationPolicy` instance.*You must configure
    authorization for this to work*. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `RequireAuthorization` | 指定只有授权用户可以访问端点。我们可以通过使用重载之一来更精细地指定。例如，我们可以指定策略名称或
    `AuthorizationPolicy` 实例。*您必须配置授权才能使其工作。* |'
- en: '| `RequireCors` | Specifies that the endpoint(s) must follow a CORS policy.*You
    must configure CORS for this to work*. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `RequireCors` | 指定端点必须遵循 CORS 策略。*您必须配置 CORS 才能使其工作。* |'
- en: '| `RequireRateLimiting` | Adds a rate-limiting policy to the endpoint(s).*You
    must configure rate-limiting for this to work*. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `RequireRateLimiting` | 为端点添加速率限制策略。*您必须配置速率限制才能使其工作。* |'
- en: '| `WithDescription` | Describes the route.When used on a group, the description
    cascades to all routes within that group. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `WithDescription` | 描述路由。当用于组时，描述会级联到该组中的所有路由。 |'
- en: '| `WithName` | Attributes a name to the route. We can use this name to identify
    the route, which must be unique.For example, we can use the route name with the
    `LinkGenerator` class to generate the URL of that endpoint. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `WithName` | 为路由分配一个名称。我们可以使用此名称来识别路由，该名称必须是唯一的。例如，我们可以使用路由名称与 `LinkGenerator`
    类一起生成该端点的 URL。 |'
- en: '| `WithOpenApi` | Ensure the builder adds the compatible metadata about the
    endpoint so tools like Swagger can generate the Open API specifications.We can
    also use this method to configure the operation and parameters instead of the
    other extension methods.*You must call this method for many others to work.* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `WithOpenApi` | 确保构建器添加与端点兼容的元数据，以便像 Swagger 这样的工具可以生成 Open API 规范。我们还可以使用此方法来配置操作和参数，而不是其他扩展方法。*您必须调用此方法才能使许多其他方法正常工作。*
    |'
- en: '| `WithSummary` | Add a summary to the route.When used on a group, the summary
    cascades to all routes within that group. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `WithSummary` | 为路由添加摘要。当在组中使用时，摘要会级联到该组内的所有路由。 |'
- en: '| `WithTags` | Add tags to the route.When used on a group, the tags cascade
    to all routes within that group. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `WithTags` | 为路由添加标签。当在组中使用时，标签会级联到该组内的所有路由。 |'
- en: 'Table 5.10: Metadata helper methods.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.10：元数据辅助方法。
- en: 'Let’s look at an example that creates a group, tags it, then ensures that all
    routes under that group have their metadata harvestable by SwaggerGen (the API
    Explorer):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个创建组、标记它，并确保该组下所有路由的元数据都能被 SwaggerGen（API 浏览器）收集的例子：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now define endpoints on that group using the `metadataGroup` as if it
    was the `app` variable. Next, we create an endpoint that we name `"Named Endpoint"`
    and describe it using the `WithOpenApi` method, including deprecating it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `metadataGroup` 定义该组上的端点，就像它是 `app` 变量一样。接下来，我们创建一个名为 `"Named Endpoint"`
    的端点，并使用 `WithOpenApi` 方法描述它，包括将其标记为已弃用：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we generate a URL based on the preceding named endpoint, we describe
    the endpoint using the `WithDescription` method and add metadata to the `endpointName`
    parameter, including an example. Once again we leverage the `WithOpenApi` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据前面的命名端点生成一个 URL，我们使用 `WithDescription` 方法描述端点，并将元数据添加到 `endpointName`
    参数中，包括一个示例。我们再次利用 `WithOpenApi` 方法：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When requesting the preceding endpoint, we get the URL of the specified route.
    By default, we get the URL of the `"Named Endpoint"` route—our only named route—in
    the following JSON format:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求前面的端点时，我们得到指定路由的 URL。默认情况下，我们得到 `"Named Endpoint"` 路由的 URL——我们唯一的命名路由——以下
    JSON 格式：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As a last example, we can exclude a route from the metadata with the `ExcludeFromDescription`
    method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，我们可以使用 `ExcludeFromDescription` 方法从元数据中排除一个路由：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When looking at the Swagger UI, we can see the following section representing
    the group we just defined:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看 Swagger UI 时，我们可以看到以下部分代表我们刚刚定义的组：
- en: '![Figure 5.1: a screenshot of the Swagger UI “Metadata Endpoints” route group.](img/file25.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：Swagger UI “元数据端点”路由组的截图](img/file25.png)'
- en: 'Figure 5.1: a screenshot of the Swagger UI “Metadata Endpoints” route group.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：Swagger UI “元数据端点”路由组的截图。
- en: We can see two endpoints in the preceding screenshot and, as expected, the third
    endpoint was excluded.The first route is marked as deprecated and shows a summary.
    When we open it, we see a warning, a description, no parameters, and one 200 OK
    response with a mime-type `text/plain`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到两个端点，并且正如预期的那样，第三个端点被排除了。第一个路由被标记为已弃用并显示摘要。当我们打开它时，我们看到一个警告、一个描述、没有参数，以及一个带有
    `text/plain` MIME 类型的 200 OK 响应。
- en: I omitted to add a screenshot of the Swagger UI for the first endpoint since
    it does not add much and would be hard to read. It is better to run the `Minimal.API`
    program and navigate to the `/swagger/index.html` URL instead.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我省略了第一个端点的 Swagger UI 截图，因为它没有添加太多内容，而且难以阅读。更好的做法是运行 `Minimal.API` 程序并导航到 `/swagger/index.html`
    URL。
- en: 'The second route does not have a summary, but when we open it, we have a description.
    The metadata we added for the `endpointName` parameter is there, and most interestingly,
    the example became the default value:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个路由没有摘要，但当我们打开它时，我们有一个描述。我们为 `endpointName` 参数添加的元数据就在那里，最有趣的是，示例变成了默认值：
- en: '![Figure 5.2: a screenshot of the Swagger UI showcasing the metadata of the
    endpointName parameter.](img/file26.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：Swagger UI 展示 `endpointName` 参数的元数据截图](img/file26.png)'
- en: 'Figure 5.2: a screenshot of the Swagger UI showcasing the metadata of the `endpointName`
    parameter.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：Swagger UI 的截图，展示了 `endpointName` 参数的元数据。
- en: Swagger UI can become very handy for manually calling our API during development
    or leveraging other Open API compatible tools. For example, we could generate
    code based on the Open API specs, like a TypeScript client.Next, we explore how
    to configure the Minimal API JSON serializer.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 在开发期间手动调用我们的 API 或利用其他兼容 Open API 的工具时非常有用。例如，我们可以根据 Open API 规范生成代码，如
    TypeScript 客户端。接下来，我们将探讨如何配置最小 API JSON 序列化器。
- en: Configuring JSON serialization
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置 JSON 序列化
- en: 'In ASP.NET Core, we can customize the JSON serializer globally or create a
    new one for a specific scenario.To change the default serializer behaviors, we
    can invoke the `ConfigureHttpJsonOptions` method, which configures the `JsonOptions`
    object. From there, we can change the options like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，我们可以全局自定义 JSON 序列化器或为特定场景创建一个新的序列化器。要更改默认序列化器的行为，我们可以调用 `ConfigureHttpJsonOptions`
    方法，该方法配置 `JsonOptions` 对象。从那里，我们可以更改选项如下：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the preceding code in the `Program.cs` file, we tell the serializer to
    serialize the property name following a `lower-case-kebab` naming convention.
    Here is an example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中的前面代码，我们告诉序列化器按照 `lower-case-kebab` 命名约定序列化属性名称。以下是一个示例：
- en: '| **Endpoint** | **Response** |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **响应** |'
- en: '| jsonGroup.MapGet("kebab-person/",() => new {FirstName = "John",LastName =
    "Doe"}); | {"first-name": "John","last-name": "Doe"} |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| jsonGroup.MapGet("kebab-person/",() => new {FirstName = "John",LastName =
    "Doe"}); | {"first-name": "John","last-name": "Doe"} |'
- en: 'Table 5.11: Showcasing the output of the JsonNamingPolicy.KebabCaseLower policy.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.11：展示 JsonNamingPolicy.KebabCaseLower 策略的输出。
- en: 'We can achieve the same for specific endpoints by using the `TypedResults.Json`
    method and specifying an instance of `JsonSerializerOptions`. The following code
    accomplishes the same outcome while preserving the default serialization options:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `TypedResults.Json` 方法并指定 `JsonSerializerOptions` 的一个实例来实现特定端点的相同效果，同时保留默认的序列化选项。以下代码实现了相同的结果：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I highlighted the changes between this code and the previous example. First,
    we create an instance of the `JsonSerializerOptions` class. To simplify the configuration,
    we start with the default web serialization values by passing the `JsonSerializerDefaults.Web`
    argument to the constructor. Then, in the object initializer, we set the value
    of the `PropertyNamingPolicy` property to `JsonNamingPolicy.KebabCaseLower`, which
    end up with the same result as before. Finally, to use our options, we pass the
    `kebabSerializer` variable as the second argument of the `TypedResults.Json` method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我突出了此代码与上一个示例之间的变化。首先，我们创建 `JsonSerializerOptions` 类的一个实例。为了简化配置，我们通过将 `JsonSerializerDefaults.Web`
    参数传递给构造函数来从默认的 Web 序列化值开始。然后，在对象初始化器中，我们将 `PropertyNamingPolicy` 属性的值设置为 `JsonNamingPolicy.KebabCaseLower`，这最终得到与之前相同的结果。最后，为了使用我们的选项，我们将
    `kebabSerializer` 变量作为 `TypedResults.Json` 方法的第二个参数传递。
- en: Serializing enums as string
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将枚举序列化为字符串
- en: 'I often find myself changing a configuration to output the string representation
    of an `enum` value. To do so, we must register an instance of the `JsonStringEnumConverter`
    class. Afterward, enums will be serialized as strings. Here is an example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常发现自己需要更改配置以输出 `enum` 值的字符串表示形式。为此，我们必须注册 `JsonStringEnumConverter` 类的一个实例。之后，枚举将被序列化为字符串。以下是一个示例：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When executing the preceding code, we obtain the following result:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，我们得到以下结果：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Using the default options yields the following instead:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认选项将产生以下结果：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I usually change this option globally since having a human-readable value instead
    of a number is more explicit, easier to understand for a human, and easier to
    leverage for a client (machine).
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我通常全局更改此选项，因为使用人类可读的值而不是数字更明确，更容易被人理解，也更容易被客户端（机器）利用。
- en: Many other options exist to tweak the serializer, but we can’t explore them
    all here. Next, we look at endpoint filters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他选项可用于调整序列化器，但我们不能在此处全部探索。接下来，我们将查看端点过滤器。
- en: Leveraging endpoint filters
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用端点过滤器
- en: ASP.NET Core 7.0 added the possibility to register endpoint filters. This way,
    we can encapsulate and reuse cross-cutting concerns and logic across endpoints.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 7.0 增加了注册端点过滤器的能力。这样，我们可以在端点之间封装和重用跨切面关注点和逻辑。
- en: 'An example of reusability is that I prefer FluentValidation to .NET attributes,
    so I created an open-source project implementing a filter that ties Minimal APIs
    with FluentValidation. I can then reuse that filter across projects by referencing
    a NuGet package. We explore FluentValidation in *Section 4: Application Patterns*,
    and I left a link to that project in the *Further Reading* section.'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重复使用的例子之一是我更喜欢FluentValidation而不是.NET属性，因此我创建了一个开源项目，实现了一个将Minimal APIs与FluentValidation关联的过滤器。然后，通过引用NuGet包，我可以跨项目重用该过滤器。我们在*第4节：应用模式*中探讨了FluentValidation，并在*进一步阅读*部分留下了该项目的链接。
- en: How does it work?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: We can register endpoint filters inline or by creating a class.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以内联注册端点过滤器或创建一个类。
- en: We can add filters to an endpoint or a group using the `AddEndpointFilter` method.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`AddEndpointFilter`方法将过滤器添加到端点或组。
- en: When adding a filter to a group, it applies to all its children.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向一个组添加过滤器时，它将应用于所有子元素。
- en: We can add multiple filters per endpoint or group.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为每个端点或组添加多个过滤器。
- en: ASP.NET Core executes the filters in the order they are registered.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core按照它们注册的顺序执行过滤器。
- en: 'Let’s look at a simple inline filter:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的内联过滤器：
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The highlighted code represents the filter in the form of a delegate. The filter
    does nothing but executes the next delegate in the chain, in this case, the endpoint
    delegate itself.In the following example, we use the `Rating` enum and only accept
    positive ratings in the endpoint. To achieve this, we add a filter that validates
    the input value before reaching the endpoint:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码表示了以委托形式存在的过滤器。过滤器什么也不做，只是执行链中的下一个委托，在这种情况下，就是端点委托本身。在下面的示例中，我们使用`Rating`枚举，并在端点中只接受正评分。为了实现这一点，我们添加了一个在到达端点之前验证输入值的过滤器：
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'From the filter, we leveraged the `EndpointFilterFactoryContext` to access
    the rating argument. The code then validates that the rating is not `Bad`. If
    the rating is `Bad`, the filter immediately returns a *problem details* with a
    `400 Bad Request` status code before reaching out to the endpoint delegate. Otherwise,
    the endpoint code is executed.You probably wonder how useful writing code like
    this can be; well, this case is purely educational and not that useful in a real-world
    scenario. We could have validated the parameter in the endpoint delegate directly
    and saved ourselves the trouble of accessing it through its index. Nonetheless,
    it shows how filters work so that you can build helpful real-life filters with
    this knowledge; remember that coding is like playing LEGO® blocks.To improve on
    this foundation and make the previous example reusable, we can extract the filter
    logic into a class and apply it to multiple endpoints. We could also move the
    inline implementation to a group so it affects all its children. Let’s have a
    look at making our inline filter a class.A filter class must implement the `IEndpointFilter`
    interface. Here’s the reimplementation of the previous logic in the `GoodRatingFilter`
    class, and two endpoints using it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从过滤器中，我们利用`EndpointFilterFactoryContext`访问评分参数。然后，代码验证评分不是`Bad`。如果评分是`Bad`，则过滤器立即返回一个带有`400
    Bad Request`状态码的*问题详情*，在调用端点委托之前返回。否则，执行端点代码。你可能想知道编写这种代码有多有用；好吧，这个案例纯粹是教育性的，在现实世界的场景中并不那么有用。我们可以在端点委托中直接验证参数，从而节省通过索引访问它的麻烦。尽管如此，它展示了过滤器是如何工作的，这样你就可以利用这些知识构建有用的现实生活过滤器；记住，编码就像玩LEGO®积木。为了在这个基础上进行改进并使前面的示例可重用，我们可以将过滤器逻辑提取到类中，并将其应用于多个端点。我们还可以将内联实现移动到组中，使其影响所有子元素。让我们看看如何将我们的内联过滤器变成一个类。过滤器类必须实现`IEndpointFilter`接口。以下是`GoodRatingFilter`类中前面逻辑的重新实现，以及使用它的两个端点：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `GoodRatingFilter` class `InvokeAsync` method code is the same as the inline
    version. However, we used it twice, keeping our code DRY.Encapsulating pieces
    of logic in filters can be very beneficial, whether it is input validation, logging,
    exception handling, or another scenario.And this is not it; there is one more
    thing about filters we must explore.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`GoodRatingFilter`类的`InvokeAsync`方法代码与内联版本相同。然而，我们使用了它两次，保持了我们的代码DRY（Don''t
    Repeat Yourself）。在过滤器中封装逻辑片段可以非常有用，无论是输入验证、日志记录、异常处理还是其他场景。而且这还不是全部；关于过滤器，我们还有另一件事要探索。'
- en: Leveraging the endpoint filter factory
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用端点过滤器工厂
- en: We can use an endpoint filter factory to run code when ASP.NET Core builds the
    endpoint (makes the `RequestDelegate`) before declaring the filter. Then, from
    the factory, we control the creation of the filter itself.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用端点过滤器工厂在 ASP.NET Core 构建端点（创建 `RequestDelegate`）之前运行代码。然后，从工厂中，我们可以控制过滤器的创建本身。
- en: We explore the factory pattern in *Chapter 7*.
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在 *第7章* 中探讨了工厂模式。
- en: 'The following code registers an endpoint filter factory:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码注册了一个端点过滤器工厂：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code adds an endpoint filter factory that logs some information
    to the console, which allows us to track what is happening. The highlighted code
    represents the filter itself. For example, we could write the same code as the
    `GoodRatingFilter` class there.Next, let’s look at what happens when we execute
    the program and load the endpoint five times:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码添加了一个端点过滤器工厂，该工厂将一些信息记录到控制台，这允许我们跟踪正在发生的事情。高亮代码代表过滤器本身。例如，我们可以在那里编写与 `GoodRatingFilter`
    类相同的代码。接下来，让我们看看当我们执行程序并加载端点五次时会发生什么：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here’s what happened from the preceding output:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面的输出中发生的事情：
- en: The API starts (the first ten lines).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 开始（前10行）。
- en: ASP.NET Core executes the factory code when building the `RequestDelegate` from
    the `EndpointRoutingMiddleware` (the next two lines).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 在从 `EndpointRoutingMiddleware`（下一行）构建 `RequestDelegate` 时执行工厂代码。
- en: '`SwaggerGen`, using the `ApiExplorer`, also does the same from the `SwaggerMiddleware`,
    hence the second factory call (the next two lines).'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SwaggerGen`，使用 `ApiExplorer`，也从 `SwaggerMiddleware` 中执行相同的操作，因此有第二次工厂调用（下一行）。'
- en: Afterward, ASP.NET Core only executes the filters during requests—in this case,
    five times (the last 10 lines).
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，ASP.NET Core 只在请求期间执行过滤器——在这种情况下，五次（最后10行）。
- en: Now that we’ve seen how it runs, it is time to learn how it works.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了它是如何运行的，现在是时候学习它是如何工作的了。
- en: Don’t worry if you don’t understand how the `GetRequiredService` method or the
    `ILoggerFactory` interface work; we explore those topics in *Chapter 8*, *Dependency
    Injection*, and *Chapter 10*, *Logging*.
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你不理解 `GetRequiredService` 方法或 `ILoggerFactory` 接口的工作原理，请不要担心；我们在 *第8章*、*依赖注入*
    和 *第10章*、*日志记录* 中探讨了这些主题。
- en: 'We start by registering the endpoint filter factory using the `AddEndpointFilterFactory`
    method, which applies to groups and individual routes (we dig deeper into groups
    next). The factory delegate is of type `Func<EndpointFilterFactoryContext, EndpointFilterDelegate,
    EndpointFilterDelegate>`.Inside the delegate, using the `EndpointFilterFactoryContext`
    parameter named `filterFactoryContext`, we have access to the following objects:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `AddEndpointFilterFactory` 方法注册端点过滤器工厂，这适用于组和单个路由（我们将在下一节深入探讨组）。工厂委托的类型为
    `Func<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate>`。在委托内部，使用名为
    `filterFactoryContext` 的 `EndpointFilterFactoryContext` 参数，我们可以访问以下对象：
- en: The `ApplicationServices` property provides access to an `IServiceProvider`
    interface, allowing us to extract services from the container, as demonstrated
    with the `ILoggerFactory` interface.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationServices` 属性提供了对 `IServiceProvider` 接口的访问，允许我们从容器中提取服务，如使用 `ILoggerFactory`
    接口所示。'
- en: The `MethodInfo` property offers a `MethodInfo` object granting access to the
    caller to which we add the endpoint filter factory. This object encapsulates the
    reflection data, including types, generic parameters, attributes, and more.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodInfo` 属性提供了一个 `MethodInfo` 对象，允许调用者访问我们添加的端点过滤器工厂。此对象封装了反射数据，包括类型、泛型参数、属性等。'
- en: 'Finally, the factory delegate returns the filter ASP.NET Core executes when
    a request hits the endpoint(s). In this case, the filter is the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，工厂委托返回 ASP.NET Core 在请求击中端点（s）时执行的过滤器。在这种情况下，过滤器如下：
- en: '[PRE42]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `next` parameter (highlighted code) represents the next filter in line or
    the endpoint itself—it works the same here as with any endpoint filter. Not calling
    the `next` parameter means ASP.NET Core will never execute the endpoint code,
    which is a way to control the flow of the application.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 参数（高亮代码）代表下一个过滤器或端点本身——在这里它与任何端点过滤器的工作方式相同。不调用 `next` 参数意味着 ASP.NET
    Core 将永远不会执行端点代码，这是一种控制应用程序流程的方式。'
- en: To make an endpoint filter factory more reusable, we could create a class, an
    extension method, or return an existing filter class. We can also combine those
    ways to craft a more testable and DRY implementation of an endpoint filter factory.
    While we won't delve into these specific approaches in this context, by the end
    of the book, you should have acquired enough knowledge to achieve these tasks
    by yourself.
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使端点过滤器工厂更具可重用性，我们可以创建一个类、一个扩展方法，或者返回一个现有的过滤器类。我们还可以结合这些方法来构建一个更易于测试和遵循DRY（不要重复自己）原则的端点过滤器工厂的实现。虽然我们不会在这个上下文中深入探讨这些具体方法，但到本书结束时，你应该已经获得了足够的知识，可以自己完成这些任务。
- en: Next, we look at organizing our endpoints.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看如何组织端点。
- en: Organizing endpoints
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组织端点
- en: Grouping endpoints using the `MapGroup` method is an effective organizational
    strategy. However, defining all routes directly within the `Program.cs` file can
    result in a long and challenging-to-navigate file. To mitigate this, we can arrange
    these groups of endpoints in separate classes and create an extension method to
    add these endpoints to the `IEndpointRouteBuilder`. We can also encapsulate the
    groups, or even multiple groups, within another assembly, which we can load from
    the API.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MapGroup`方法对端点进行分组是一种有效的组织策略。然而，直接在`Program.cs`文件中定义所有路由可能会导致文件很长，难以导航。为了减轻这种情况，我们可以将这些端点组安排在单独的类中，并创建一个扩展方法将这些端点添加到`IEndpointRouteBuilder`。我们还可以将这些组，甚至多个组，封装在另一个程序集中，然后从API中加载。
- en: 'We explore ways to design applications in *Section 4: Application Patterns*,
    including in *Chapter 18*, *Request-EndPoint-Response (REPR)*, and *Chapter 20*,
    *Modular Monolith*.'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在**第4节：应用模式**中探讨了设计应用程序的方法，包括在第18章的**请求-端点-响应（REPR**）和第20章的**模块化单体**。
- en: Let’s start with simple groups.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的组开始。
- en: MapGroup
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MapGroup
- en: 'Creating groups is the first tool to organize the routes of our APIs. It comes
    with the following advantages:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组是我们组织API路由的第一项工具。它具有以下优势：
- en: We can create a shared URL prefix for the group’s children.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为组的子项创建一个共享的URL前缀。
- en: We can add metadata that applies to the group’s children.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为组的子项添加适用的元数据。
- en: We can add endpoint filters that apply to the group’s children.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为组的子项添加端点过滤器。
- en: 'Here is an example of a group that configures those three items:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个配置这三个项目的示例组：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The highlighted code does the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码执行以下操作：
- en: Configures the `organizing-endpoints` URL prefix.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置`organizing-endpoints` URL前缀。
- en: Add the `Organizing Endpoints` tag (metadata).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`Organizing Endpoints`标签（元数据）。
- en: Add an inline filter that logs information about the requests.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个内联过滤器，记录关于请求的信息。
- en: 'We can reach the endpoints at the following URL:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下URL访问端点：
- en: '`/organizing-endpoints/demo`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/organizing-endpoints/demo`'
- en: '`/organizing-endpoints/demo/123`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/organizing-endpoints/demo/123`'
- en: 'As the following Swagger UI screenshot shows, the two endpoints are tagged
    correctly:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下Swagger UI截图所示，这两个端点被正确标记：
- en: '![Figure 5.3: The two endpoints under the Organizing Endpoints tag](img/file27.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：组织端点标签下的两个端点](img/file27.png)'
- en: 'Figure 5.3: The two endpoints under the Organizing Endpoints tag'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：组织端点标签下的两个端点
- en: 'Then, after requesting the two endpoints, we end up with the following logs
    excerpt:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在请求了这两个端点之后，我们得到了以下日志摘录：
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As demonstrated, leveraging groups for shared configuration streamlines the
    process of setting up aspects like authorization rules, caching, and more. By
    adopting this approach, we uphold the DRY (Don't Repeat Yourself) principle, improving
    the maintainability of our code.Next, we encapsulate mapping endpoints into classes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，利用组进行共享配置简化了设置诸如授权规则、缓存等方面的工作流程。通过采用这种方法，我们遵循了DRY（不要重复自己）原则，提高了代码的可维护性。接下来，我们将端点映射封装到类中。
- en: Create a custom Map extension method
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个自定义的Map扩展方法
- en: 'Now that we explored how to create groups, it is time to move the endpoints
    out of the `Program.cs` file. One way is to create an extension method that registers
    the route. To achieve this, we must extend the `IEndpointRouteBuilder` interface
    as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何创建组，是时候将端点从`Program.cs`文件中移除了。一种方法是通过创建一个扩展方法来注册路由。为了实现这一点，我们必须扩展`IEndpointRouteBuilder`接口，如下所示：
- en: '[PRE45]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then we must call our extension method in the `Program.cs` file, as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在`Program.cs`文件中调用我们的扩展方法，如下所示：
- en: '[PRE46]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And with that, we''ve seen how a simple technique allows us to group our routes
    together, offering an organized way to structure our APIs.We can improve on this
    technique by returning the `IEndpointRouteBuilder` instead of `void` in our extension
    method, which makes our extension “fluent”, as demonstrated below:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就看到了一个简单技术如何允许我们将路由分组在一起，为我们提供了组织API的有组织方式。我们可以在扩展方法中返回`IEndpointRouteBuilder`而不是`void`来改进这种技术，这使我们的扩展“流畅”，如下所示：
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then from the `Program.cs` file, we can call multiple maps in a “single line
    of code” like the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从`Program.cs`文件中，我们可以像以下这样在“单行代码”中调用多个映射：
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Creating fluent APIs is very convenient, especially in such cases.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 创建流畅的API非常方便，尤其是在这种情况下。
- en: This technique allows you to create fluent APIs for anything, not just registering
    routes.
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种技术允许你为任何东西创建流畅的API，而不仅仅是注册路由。
- en: 'Another variation of this pattern exists that''s worth noting. Rather than
    returning the `IEndpointRouteBuilder`, the extension method can return the `RouteGroupBuilder`
    instead, granting the caller access to the group itself. Here is an example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式还存在另一种值得注意的变体。而不是返回`IEndpointRouteBuilder`，扩展方法可以返回`RouteGroupBuilder`，从而授予调用者访问该组本身的权限。以下是一个示例：
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can use such methods to create a complex hierarchy of routes and groups by
    splitting the registration into multiple files. The second version is the most
    common way. It does not expose the group to the outside (encapsulation) and allows
    fluent chaining of other method calls.And voilà! We now know how basic extension
    methods can help us organize our endpoints. Next, we explore how to move those
    extension methods into class libraries.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种方法通过将注册拆分为多个文件来创建一个复杂的路由和组层次结构。第二个版本是最常见的方式。它不将组暴露给外部（封装），并允许流畅地链式调用其他方法。好了，现在我们知道了基本扩展方法如何帮助我们组织端点。接下来，我们将探讨如何将这些扩展方法移动到类库中。
- en: Class libraries
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类库
- en: 'This last technique allows us to create and register routes from class libraries
    using the previously explored techniques.First, we must create a class library
    project, which we can do using the `dotnet new classlib` CLI command.Unfortunately,
    a class library project cannot access everything we need, like the `IEndpointRouteBuilder`
    interface. The good news is that it is trivial to change this fact. All we have
    to do is add a `FrameworkReference` element in an `ItemGroup` element in the `csproj`
    file, as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最后的技术使我们能够使用之前探索的技术从类库中创建和注册路由。首先，我们必须创建一个类库项目，我们可以使用`dotnet new classlib`
    CLI命令来完成。不幸的是，类库项目无法访问我们需要的所有内容，例如`IEndpointRouteBuilder`接口。好消息是，改变这一事实非常简单。我们只需在`csproj`文件中的`ItemGroup`元素中添加一个`FrameworkReference`元素，如下所示：
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: That minor addition equips us with everything necessary to create an ASP.NET
    Core-enabled library, including mapping endpoints! Transferring the preceding
    C# code into this class library project should yield the same functional results
    as in a web application.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的添加使我们拥有了创建一个启用ASP.NET Core的库所需的一切，包括映射端点！将前面的C#代码转移到这个类库项目中应该会产生与在Web应用程序中相同的功能结果。
- en: I used this technique in the `Shared` project of the solution we explore in
    this chapter and the next. If you are curious, the complete source code is available
    on GitHub.
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在本章和下一章探讨的解决方案的`Shared`项目中使用了这种技术。如果你好奇，完整的源代码可在GitHub上找到。
- en: Next, we mix Minimal APIs and DTOs.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将Minimal APIs和DTOs结合起来。
- en: Using Minimal APIs with Data Transfer Objects
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Minimal APIs与数据传输对象
- en: This section explores leveraging the **Data Transfer Object** (**DTO**) pattern
    with minimal APIs.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了利用**数据传输对象**（**DTO**）模式与Minimal APIs。
- en: This section is the same as we explore in *Chapter 6*, *MVC*, but in the context
    of Minimal APIs. Moreover, the two code projects are part of the same Visual Studio
    solution for convenience, allowing you to compare the two implementations.
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本节与我们在第6章“MVC”中探讨的内容相同，但是在Minimal APIs的背景下。此外，这两个代码项目是同一个Visual Studio解决方案的一部分，以便于比较两种实现方式。
- en: Goal
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: As a reminder, DTOs aim to *control the inputs and outputs of an endpoint* by
    decoupling the API contract from the application’s inner workings. DTOs empower
    us to define our APIs without thinking about the underlying data structures, leaving
    us to craft our REST APIs how we want.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，DTOs（数据传输对象）旨在通过将API合约与应用程序的内部工作解耦来**控制端点的输入和输出**。DTOs使我们能够定义我们的API，而不必考虑底层的数据结构，从而让我们能够按照自己的意愿构建REST
    API。
- en: We discuss REST APIs and DTOs more in-depth in *Chapter 4*, *REST APIs*.
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在*第4章*，*REST API*中更深入地讨论了REST API和DTOs。
- en: Other possible objectives are to save bandwidth by limiting the amount of information
    the API transmits, flattening the data structure, or adding API features that
    cross multiple entities.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能的目的是通过限制API传输的信息量、简化数据结构或添加跨多个实体的API功能来节省带宽。
- en: Design
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'Let’s start by analyzing a diagram that shows how minimal APIs work with DTOs:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先分析一个图表，展示最小化API如何与DTOs协同工作：
- en: '![Figure 5.4: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO](img/file28.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：一个输入DTO触发了某些领域逻辑，然后端点返回一个输出DTO](img/file28.png)'
- en: 'Figure 5.4: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：一个输入DTO触发了某些领域逻辑，然后端点返回一个输出DTO
- en: 'DTOs allow the decoupling of the domain (3) from the request (1) and the response
    (5). This model empowers us to manage the inputs and outputs of our REST APIs
    independently from the domain. Here’s the flow:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs允许将领域（3）与请求（1）和响应（5）解耦。这种模型使我们能够独立于领域来管理REST API的输入和输出。以下是流程：
- en: The client sends a request to the server.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送请求。
- en: ASP.NET Core leverages its data binding and parsing mechanism to convert the
    information of the HTTP request to C# (input DTO).
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core利用其数据绑定和解析机制将HTTP请求的信息转换为C#（输入DTO）。
- en: The endpoint does what it is supposed to do.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点执行其应有的操作。
- en: ASP.NET Core serializes the output DTO to the HTTP response.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core将输出DTO序列化到HTTP响应中。
- en: The client receives and handles the response.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户接收并处理响应。
- en: Let’s explore some code to understand the concept better.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码来更好地理解这个概念。
- en: Project – Minimal API
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 最小化API
- en: '*This code sample is the same as the next chapter but uses Minimal APIs instead
    of the MVC framework*.**Context**: we must build an application to manage customers
    and contracts. We must track the state of each contract and have a primary contact
    in case the business needs to contact the customer. Finally, we must display the
    number of contracts and the number of opened contracts for each customer on a
    dashboard.The model is the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*此代码示例与下一章相同，但使用最小化API而不是MVC框架**上下文**：我们必须构建一个应用程序来管理客户和合同。我们必须跟踪每个合同的状态，并在业务需要联系客户时有一个主要联系人。最后，我们必须在仪表板上显示每个客户的合同数量和已打开合同数量。模型如下：'
- en: '[PRE51]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding code is straightforward. The only piece of logic is the `WorkStatus.State`
    property that returns `WorkState.New` when the work has not yet started on that
    contract, `WorkState.Completed` when all the work is completed, or `WorkState.InProgress`
    otherwise.The endpoints (`CustomersEndpoints.cs`) leverage the `ICustomerRepository`
    interface to simulate database operations. The implementation is unimportant.
    It uses a `List<Customer>` as the database. Here’s the interface that allows querying
    and updating the data:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码很简单。唯一的逻辑是`WorkStatus.State`属性，当该合同上的工作尚未开始时返回`WorkState.New`，当所有工作都已完成时返回`WorkState.Completed`，否则返回`WorkState.InProgress`。端点（`CustomersEndpoints.cs`）利用`ICustomerRepository`接口来模拟数据库操作。实现并不重要。它使用`List<Customer>`作为数据库。以下是允许查询和更新数据的接口：
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we know about the underlying foundation, we explore CRUD endpoints
    that do not leverage DTOs.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了底层基础，我们将探讨不利用DTOs的CRUD端点。
- en: Raw CRUD endpoints
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始CRUD端点
- en: 'Many issues can arise if we create CRUD endpoints to manage the customers directly
    (see `CustomersEndpoints.cs`). First, a little mistake from the client could erase
    several data points. For example, if the client forgets to send the contracts
    during a `PUT` operation, that would delete all the contracts associated with
    that customer. Here’s the controller code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建CRUD端点直接管理客户，可能会出现许多问题（参见`CustomersEndpoints.cs`）。首先，客户端的一个小错误可能会删除多个数据点。例如，如果客户端在`PUT`操作中忘记发送合同，那么将删除与该客户关联的所有合同。以下是控制器代码：
- en: '[PRE53]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The highlighted code represents the customer update. So to mistakenly remove
    all contracts, a client could send the following HTTP request (from the `Minimal.API.http`
    file):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码表示客户更新。因此，为了错误地删除所有合同，客户端可以发送以下HTTP请求（来自`Minimal.API.http`文件）：
- en: '[PRE54]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'That request would result in the following response entity:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 该请求将导致以下响应实体：
- en: '[PRE55]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Previously, however, that customer had contracts (seeded when we started the
    application). Here’s the original data:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，之前该客户已有合同（在我们启动应用程序时生成）。以下是原始数据：
- en: '[PRE56]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As we can see, by exposing our entities directly, we are giving a lot of power
    to the consumers of our API. Another issue with this design is the dashboard.
    The user interface would have to calculate the statistics about the contracts.
    Moreover, if we implement paging the contracts over time, the user interface could
    become increasingly complex and even overquery the database, hindering our performance.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过直接公开我们的实体，我们给了 API 的消费者很多权力。这个设计的问题之一是仪表板。用户界面将不得不计算关于合同的统计数据。此外，如果我们随着时间的推移实现分页显示合同，用户界面可能会变得越来越复杂，甚至可能过度查询数据库，从而阻碍我们的性能。
- en: I implemented the entire API, which is available on GitHub but without UI.
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我实现了整个 API，它可在 GitHub 上找到，但没有 UI。
- en: Next, we explore how we can fix those two use cases using DTOs.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用 DTO 修复这两个用例。
- en: DTO-enabled endpoints
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DTO 启用的端点
- en: 'To solve our problems, we reimplement the endpoints using DTOs. These endpoints
    use methods instead of inline delegates and returns `Results<T1, T2, …>` instead
    `IResult`. So, let’s start with the declaration of the endpoints:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的问题，我们使用 DTO 重新实现了端点。这些端点使用方法而不是内联委托，并返回 `Results<T1, T2, …>` 而不是 `IResult`。所以，让我们从端点的声明开始：
- en: '[PRE57]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, to make it easier to follow along, here are all the DTOs as a reference:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了更容易地跟踪，这里提供了所有 DTO 作为参考：
- en: '[PRE58]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'First, let’s fix our update problem, starting with the reimplementation of
    the update endpoint leveraging DTOs (see the `DTOEndpoints.cs` file):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修复我们的更新问题，从使用 DTO 重新实现更新端点开始（参见 `DTOEndpoints.cs` 文件）：
- en: '[PRE59]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding code, the main differences are (highlighted):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，主要的不同之处在于（突出显示）：
- en: The request body is now bound to the `UpdateCustomer` class instead of the `Customer`
    itself.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在请求体绑定到 `UpdateCustomer` 类而不是 `Customer` 本身。
- en: The action method returns an instance of the `CustomerDetails` class instead
    of the `Customer` itself when the operation succeeds.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作成功时，动作方法返回 `CustomerDetails` 类的实例而不是 `Customer` 本身。
- en: 'However, we can see more code in our endpoint than before. That’s because it
    now handles the changes instead of the clients. The action now does:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以看到端点中的代码比以前多了。这是因为现在它处理了变化，而不是客户端。动作现在执行：
- en: Load the data from the database.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库加载数据。
- en: Ensure the entity exists.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实体存在。
- en: Use the input DTO to update the data, limiting the clients to a subset of properties.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入 DTO 更新数据，限制客户端只能修改属性子集。
- en: Proceed with the update.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行更新。
- en: Ensure the entity still exists (handles conflicts).
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实体仍然存在（处理冲突）。
- en: Copy the Customer into the output DTO and return it.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户复制到输出 DTO 并返回它。
- en: 'By doing this, we now control what the clients can do when they send a `PUT`
    request through the input DTO (`UpdateCustomer`). Moreover, we encapsulated the
    logic to calculate the statistics on the server. We hid the computation behind
    the output DTO (`CustomerDetails`), which lowers the complexity of our user interface
    and allows us to improve the performance without impacting any of our clients
    (loose coupling).Furthermore, we now use the `customerId` parameter.If we send
    the same HTTP request as before, which sends more data than we accept, only the
    customer''s name will change. On top of that, we get all the data we need to display
    the customer’s statistics. Here’s a response example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们现在控制了客户端在通过输入 DTO (`UpdateCustomer`) 发送 `PUT` 请求时可以做什么。此外，我们将计算统计数据的逻辑封装在服务器上。我们通过输出
    DTO (`CustomerDetails`) 隐藏了计算过程，这降低了用户界面的复杂性，并允许我们在不影响任何客户端的情况下提高性能（松耦合）。此外，我们现在使用
    `customerId` 参数。如果我们发送与之前相同的 HTTP 请求，发送比我们接受更多的数据，只有客户的名字会改变。除此之外，我们还得到了显示客户统计数据所需的所有数据。以下是一个响应示例：
- en: '[PRE60]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we can see from the preceding response, only the customer’s name changed,
    but we now received the `statusWorkDone` and `statusTotalWork` fields. Lastly,
    we flattened the data structure.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的响应所示，只有客户的名字改变了，但我们现在收到了 `statusWorkDone` 和 `statusTotalWork` 字段。最后，我们简化了数据结构。
- en: DTOs are a great resource to flatten data structures, but you don’t have to.
    You must always design your systems, including DTOs and data contracts, for specific
    use cases.
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DTO 是简化数据结构的好资源，但你不必这样做。你必须始终为特定用例设计你的系统，包括 DTO 和数据合约。
- en: 'As for the dashboard, the “get all customers” endpoint achieves this by doing
    something similar. It outputs a collection of `CustomerSummary` objects instead
    of the customers themselves. In this case, the endpoint executes the calculations
    and copies the entity''s relevant properties to the DTO. Here’s the code:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仪表板而言，“获取所有客户”端点通过执行类似操作来实现这一点。它输出一个`CustomerSummary`对象集合，而不是客户本身。在这种情况下，端点执行计算并将实体的相关属性复制到DTO中。以下是代码：
- en: '[PRE61]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the preceding code, the action method:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，动作方法：
- en: Read the entities
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取实体
- en: Create the DTOs and calculate the number of open contracts.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建DTO并计算开放合同的数量。
- en: Return the DTOs.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回DTO。
- en: As simple as that, we now encapsulated the computation on the server.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，我们现在封装了服务器上的计算。
- en: You should optimize such code based on your real-life data source. In this case,
    a `static` `List<T>` is low latency. However, querying the whole database to get
    a count can become a bottleneck.
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您应该根据您的实际数据源优化此类代码。在这种情况下，一个`static` `List<T>`具有低延迟。然而，查询整个数据库以获取计数可能会成为瓶颈。
- en: 'Calling the endpoint results in the following:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 调用端点会产生以下结果：
- en: '[PRE62]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It is now super easy to build our dashboard. We can query that endpoint once
    and display the data in the UI. The UI offloaded the calculation to the backend.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建我们的仪表板变得非常简单。我们可以查询该端点一次，并在UI中显示数据。UI将计算卸载到了后端。
- en: User interfaces tend to be more complex than APIs because they are stateful.
    As such, offloading as much complexity to the backend helps. You can use a Backend-for-frontend
    (BFF) to help with this task. We explore ways to layer APIs, including the BFF
    pattern in *Chapter 19*, *Introduction to Microservices Architecture*.
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户界面通常比API更复杂，因为它们是状态化的。因此，将尽可能多的复杂性卸载到后端有助于。您可以使用后端-for-前端（BFF）来帮助完成这项任务。我们在*第19章*：*微服务架构简介*中探讨了分层API的方法，包括BFF模式。
- en: 'Lastly, you can play with the API using the HTTP requests in the `MVC.API.DTO.http`
    file. I implemented all the endpoints using a similar technique. If your endpoints
    become too complex, it is good practice to encapsulate them into other classes.
    We explore many techniques to organize application code in *Section 4*: *Applications
    patterns*.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`MVC.API.DTO.http`文件中的HTTP请求来玩转API。我使用类似的技术实现了所有端点。如果您的端点变得过于复杂，将它们封装到其他类中是一种良好的做法。我们在*第4节*：*应用程序模式*中探讨了多种组织应用程序代码的技术。
- en: Conclusion
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'A data transfer object allows us to design an API endpoint with a specific
    data contract (input and output) instead of exposing the domain or data model.
    This separation between the presentation and the domain is a crucial element that
    leads to having multiple independent components instead of a bigger, more fragile
    one.We use DTOs to control the endpoints'' inputs and outputs, giving us more
    control over what the clients can do or receive.Using the data transfer object
    pattern helps us follow the SOLID principles in the following ways:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输对象允许我们设计一个具有特定数据契约（输入和输出）的API端点，而不是暴露领域或数据模型。这种表示层与领域之间的分离是导致拥有多个独立组件而不是更大、更脆弱组件的关键元素。我们使用DTO来控制端点的输入和输出，从而让我们对客户端可以做什么或接收什么有更多的控制。使用数据传输对象模式有助于我们以下列方式遵循SOLID原则：
- en: '**S**: A DTO adds clear boundaries between the domain or data model and the
    API contract. Moreover, having an input and an output DTO help further separate
    the responsibilities.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：DTO在领域或数据模型与API契约之间添加了清晰的边界。此外，拥有输入和输出DTO有助于进一步分离责任。'
- en: '**O**: N/A'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：N/A'
- en: '**L**: N/A'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: A DTO is a small, specifically crafted data contract (abstraction) with
    a clear purpose in the API contract.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：DTO（数据传输对象）是一个小型、专门定制的数据契约（抽象），在API契约中有明确的目的。'
- en: '**D**: Due to those smaller interfaces (ISP), DTOs allow changing the implementation
    details of the endpoint without affecting the clients because they depend only
    on the API contract (the abstraction).'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：由于那些较小的接口（ISP），DTO允许在不影响客户端的情况下更改端点的实现细节，因为它们只依赖于API契约（抽象）。'
- en: You should now understand the added value of DTOs and what part in an API contract
    they play. Finally, you should have a strong base of Minimal APIs possibilities.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该理解DTO的附加价值以及它们在API契约中扮演的角色。最后，您应该有一个关于最小API可能性的坚实基础。
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout the chapter, we explored ASP.NET Core Minimal APIs and their integration
    with the DTO pattern. Minimal APIs simplify web application development by reducing
    boilerplate code. The DTO pattern helps us decouple the API contract from the
    application's inner workings, allowing flexibility in crafting REST APIs. DTOs
    can also save bandwidth and flatten or change data structures. Endpoints exposing
    their domain or data entities directly can lead to issues, while DTO-enabled endpoints
    offer better control over data exchanges. We also discussed numerous Minimal APIs
    aspects, including input binding, outputting data, metadata, JSON serialization,
    endpoint filters, and endpoint organization. With this foundational knowledge,
    we can begin to design ASP.NET Core minimal APIs.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了ASP.NET Core最小化API及其与DTO模式的集成。最小化API通过减少样板代码简化了Web应用程序的开发。DTO模式帮助我们解耦API合同与应用程序的内部工作，允许我们在构建REST
    API时具有灵活性。DTO还可以节省带宽并简化或更改数据结构。直接暴露其领域或数据实体的端点可能导致问题，而启用DTO的端点则提供了更好的数据交换控制。我们还讨论了多个最小化API方面，包括输入绑定、输出数据、元数据、JSON序列化、端点过滤器以及端点组织。有了这些基础知识，我们可以开始设计ASP.NET
    Core最小化API。
- en: 'For more information about Minimal APIs and what they have to offer, you can
    visit the *Minimal APIs quick reference* page of the official documentation: [https://adpg.link/S47i](https://adpg.link/S47i)'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于最小化API及其提供的功能，您可以访问官方文档中的*最小化API快速参考*页面：[https://adpg.link/S47i](https://adpg.link/S47i)
- en: In the next chapter, we revisit the same notions in an ASP.NET Core MVC context.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以ASP.NET Core MVC的上下文重新审视同样的概念。
- en: Questions
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s look at a few practice questions:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习问题：
- en: How to map different HTTP requests to delegates with Minimal APIs?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用最小化API将不同的HTTP请求映射到委托？
- en: Can we use middleware with Minimal APIs?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在最小化API中使用中间件？
- en: Can you name at least two binding sources that minimal APIs supports?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能列出至少两个最小化API支持的绑定源吗？
- en: What is the difference between using the `Results` and `TypedResults` classes?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Results`和`TypedResults`类有什么区别？
- en: What is the purpose of endpoint filters?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点过滤器的作用是什么？
- en: Further reading
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build on what we have learned in the chapter:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'Minimal APIs quick reference: [https://adpg.link/S47i](https://adpg.link/S47i)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化API快速参考：[https://adpg.link/S47i](https://adpg.link/S47i)
- en: 'Problem Details for HTTP APIs (RFC7807): [https://adpg.link/1hpM](https://adpg.link/1hpM)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HTTP API的问题详情（RFC7807）: [https://adpg.link/1hpM](https://adpg.link/1hpM)'
- en: 'FluentValidation.AspNetCore.Http: [https://adpg.link/sRtU](https://adpg.link/sRtU)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FluentValidation.AspNetCore.Http: [https://adpg.link/sRtU](https://adpg.link/sRtU)'
- en: Answers
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: Minimal APIs provide extension methods such as `MapGet`, `MapPost`, `MapPut`,
    and `MapDelete` to configure the HTTP pipeline and map specific HTTP requests
    to delegates.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小化API提供了如`MapGet`、`MapPost`、`MapPut`和`MapDelete`等扩展方法，用于配置HTTP管道并将特定的HTTP请求映射到委托。
- en: Yes, we can use middleware with Minimal APIs, just like any other ASP.NET Core
    application.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们可以在最小化API中使用中间件，就像任何其他ASP.NET Core应用程序一样。
- en: Minimal APIs support various binding sources, including `Route`, `Query`, `Header`,
    `Body`, `Form`, and `Services`.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小化API支持各种绑定源，包括`Route`、`Query`、`Header`、`Body`、`Form`和`Services`。
- en: The methods in the `Results` class return `IResult`, while those in `TypedResults`
    return a typed implementation of the `IResult` interface. This difference is significant
    because the API Explorer can automatically discover the API contract from the
    typed results (`TypedResults` methods) but not from the generic `IResult` interface
    (`Results` methods).
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Results`类中的方法返回`IResult`，而`TypedResults`类中的方法返回`IResult`接口的特定类型实现。这种差异很重要，因为API浏览器可以从类型化的结果（`TypedResults`方法）自动发现API合同，但不能从通用的`IResult`接口（`Results`方法）中自动发现。'
- en: Endpoint filters allow encapsulation and reuse of cross-cutting logic across
    endpoints. For example, they're helpful for input validation, logging, exception
    handling, and promoting code reusability.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点过滤器允许在端点之间封装和重用跨切面逻辑。例如，它们对于输入验证、日志记录、异常处理和促进代码重用非常有帮助。
