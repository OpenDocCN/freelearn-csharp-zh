- en: Setting Up a JavaScript Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置JavaScript环境
- en: In this chapter, we'll explore setting up your JavaScript development environment
    with examples in pure JavaScript and React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过纯JavaScript和React的示例来探索设置你的JavaScript开发环境。
- en: 'In this chapter, you will gain an understanding of:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解：
- en: Installing your IDE
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装你的IDE
- en: How to set up your testing framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置你的测试框架
- en: Writing your first tests in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中编写你的第一个测试
- en: Node.js
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: Node.js, commonly called Node, is practically a requirement for doing modern
    web application development. In this section, we will discuss what Node is exactly,
    provide reasons why you need Node, and, finally, talk about where you can get
    Node installation instructions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js，通常称为Node，实际上对于现代Web应用程序开发是必需的。在本节中，我们将讨论Node究竟是什么，提供你需要Node的原因，并最终讨论你可以在哪里找到Node安装说明。
- en: If you are already familiar with these subjects, then feel free to jump to the
    next section, where we discuss NPM in a similar fashion.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉这些主题，那么请随意跳转到下一节，在那里我们将以类似的方式讨论NPM。
- en: What is Node?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Node？
- en: Node was created in late 2009 by Ryan Dahl. Based on Chrome's V8 engine, Node
    provides a JavaScript runtime built for the purpose of providing evented, non-blocking
    I/O (input/output) for serving web applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node是在2009年底由Ryan Dahl创建的。基于Chrome的V8引擎，Node提供了一个为提供事件驱动的、非阻塞的I/O（输入/输出）而构建的JavaScript运行时，用于服务Web应用程序。
- en: At the time, Chrome had created the fastest JavaScript engine available. At
    the same time, they had decided to open-source the code for it. For these two
    extremely compelling reasons, Node decided to use the V8 engine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，Chrome已经创建了最快的JavaScript引擎。同时，他们决定开源其代码。出于这两个极其有说服力的原因，Node决定使用V8引擎。
- en: Ryan Dahl was unhappy with the performance, at the time, of the very popular
    Apache HTTP server. One of the problems with the way that Apache was handling
    concurrent connections was that it was creating a new thread for each connection.
    Task creation and task switching between these threads are both CPU-and memory-intensive.
    For these reasons, instead of using threads for concurrent connections, Dahl decided
    to write Node with the intent of using an event loop coupled with a callback paradigm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Dahl对当时非常流行的Apache HTTP服务器的性能感到不满。Apache处理并发连接的方式中存在的问题之一是它为每个连接创建了一个新线程。在这些线程之间创建任务和任务切换都是CPU和内存密集型的。出于这些原因，Dahl决定用事件循环和回调模式编写Node，而不是使用线程进行并发连接。
- en: Why do we need Node?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要Node？
- en: 'To perform TDD in JavaScript for a modern web application, we absolutely need
    Node. When writing a modern web application, you will very likely be using one
    of these popular frameworks: ReactJS, Angular, Ember.js, Vue.js, or Polymer. The
    majority of these applications require a compilation step in Node.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现代Web应用程序中进行TDD（测试驱动开发）JavaScript，我们绝对需要Node。在编写现代Web应用程序时，你很可能正在使用以下流行的框架之一：ReactJS、Angular、Ember.js、Vue.js或Polymer。这些应用程序中的大多数都需要在Node中进行编译步骤。
- en: Another reason for using Node is that we want to take advantage of new features
    in JavaScript. Node doesn’t support these features itself, but libraries have
    been written that will allow you to transpile the newer versions of JavaScript,
    ECMAScript 2015+, into a version of JavaScript that is supported by your target
    browsers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node的另一个原因是我们要利用JavaScript中的新特性。Node本身不支持这些特性，但已经编写了库，可以将JavaScript的新版本（ECMAScript
    2015+）转换为你的目标浏览器所支持的JavaScript版本。
- en: Lastly, for the purposes of this book, we need Node so that we can run our tests.
    Later, we will discuss how we can also run our tests continuously while we are
    writing our code. This is known as continuous testing and is a must-have for rapid
    development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了这本书的目的，我们需要Node来运行我们的测试。稍后，我们将讨论我们如何在编写代码的同时持续运行我们的测试。这被称为持续测试，对于快速开发是必不可少的。
- en: Installing Node
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node
- en: There are several options for installing Node on your machine. We will cover
    installing manually and installing from a package management repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的机器上安装Node有多种选择。我们将涵盖手动安装和从软件包管理仓库安装。
- en: The benefits of using a package management repository are many. The main reason
    that you would want to install this way would be the benefit of version management.
    Node updates versions frequently, and using a package manager can help to notify
    you of available updates. It can also help install those updates in a simple and
    efficient manner. We will start with a manual install, followed by installing
    using a Linux package manager, a Mac OSX package manager, and finally a Windows
    package manager.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用软件包管理仓库的好处有很多。你想要这样安装的主要原因可能是版本管理的便利。Node 经常更新版本，使用软件包管理器可以帮助你通知可用的更新。它还可以帮助以简单高效的方式安装这些更新。我们将从手动安装开始，然后是使用
    Linux 软件包管理器、Mac OSX 软件包管理器，最后是 Windows 软件包管理器安装。
- en: To install Node manually, open your favorite browser and go to [http://nodejs.org](http://nodejs.org).
    You should see something similar to the following screenshot. Regardless of your
    operating system, the Node website will have a download link for both current
    and **Long Term Support** (**LTS**) versions of Node installation files. For Windows
    and Mac, the Node website provides installers. For Linux, Node provides binaries
    and source code. Assuming you are familiar with your operating system, the installation
    process is fairly straightforward and shouldn't present any issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动安装 Node，打开你喜欢的浏览器并访问 [http://nodejs.org](http://nodejs.org)。你应该会看到以下截图类似的内容。无论你的操作系统是什么，Node
    网站都会有当前和**长期支持**（**LTS**）版本的 Node 安装文件的下载链接。对于 Windows 和 Mac，Node 网站提供安装程序。对于
    Linux，Node 提供二进制文件和源代码。假设你熟悉你的操作系统，安装过程相当直接，不应该有任何问题。
- en: '![](img/00014.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: Package managers greatly simplify the installation of many applications. If
    you are unfamiliar with package managers in general, they are based on the concept
    of having a repository of applications and tools that are available for installation
    on the system the package manager is for. Almost every system available has a
    package manager for it now. Linux has a different package manager for many distributions.
    Mac uses a system called *Homebrew, *and Windows has a package manager named *Chocolatey*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器极大地简化了许多应用程序的安装。如果你对软件包管理器不熟悉，它们基于有一个应用程序和工具仓库的概念，这些应用程序和工具可用于在软件包管理器针对的系统上安装。现在几乎每个可用的系统都有相应的软件包管理器。Linux
    有许多发行版的不同的软件包管理器。Mac 使用名为 *Homebrew* 的系统，而 Windows 有一个名为 *Chocolatey* 的软件包管理器。
- en: Linux
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'First, we will cover using the Ubuntu package manager, called `apt`, as Ubuntu
    is one of the most popular Linux systems. If you are using a different distribution,
    the process should be very similar. The only difference is the name of your package
    manager. Open a terminal window and enter the following commands to install Node
    for Ubuntu:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍如何使用 Ubuntu 软件包管理器 `apt`，因为 Ubuntu 是最受欢迎的 Linux 系统之一。如果你使用的是不同的发行版，过程应该非常相似。唯一的区别是软件包管理器的名称。打开终端窗口并输入以下命令来为
    Ubuntu 安装 Node：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's that simple; now the latest version of Node is installed and ready for
    you to begin using. These same commands will update Node when a new version is
    available.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；现在最新的 Node 版本已经安装好了，你可以开始使用了。这些相同的命令会在有新版本可用时更新 Node。
- en: Mac OSX
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac OSX
- en: 'Mac doesn''t come with a package manager preinstalled. To install Homebrew,
    you must open a Terminal and execute the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Mac 默认没有预装软件包管理器。要安装 Homebrew，你必须打开终端并执行以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that you have Homebrew installed, you also have one more requirement that
    you must fulfill. You must install Apple''s Xcode, which can be found by searching
    the App Store. Just like any other application on a Mac, once you have found it,
    just click the Install application button, and Xcode will download and install:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 Homebrew，你还需要满足另一个要求。你必须安装苹果的 Xcode，你可以在 App Store 中搜索到它。就像 Mac 上的任何其他应用程序一样，一旦找到它，只需点击安装应用程序按钮，Xcode
    就会下载并安装：
- en: '![](img/00015.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: 'Now that we have both prerequisites for Node installed on the system, installation
    is extremely simple. From a Terminal window, execute the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在系统上安装了 Node 的所有先决条件，安装过程非常简单。从终端窗口，执行以下命令：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Updating Node is also just as simple. Occasionally, when you want to update,
    execute the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Node 同样很简单。偶尔，当你想要更新时，执行以下命令：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You now have the latest version of Node installed on your Mac.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 Mac 上已经安装了最新版本的 Node。
- en: Windows
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: 'Windows also has a package manager. Just like Mac, the Windows package manager
    does not come preinstalled. The package manager for Windows is named Chocolatey
    and can be found at [https://chocolatey.org](https://chocolatey.org):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 也有包管理器。就像 Mac 一样，Windows 的包管理器不是预安装的。Windows 的包管理器名为 Chocolatey，可以在
    [https://chocolatey.org](https://chocolatey.org) 找到：
- en: '![](img/00016.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: 'To install Chocolatey, open a Command Prompt (`cmd.exe`) as administrator and
    execute the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Chocolatey，以管理员身份打开命令提示符 (`cmd.exe`) 并执行以下命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the Chocolatey installation has finished, you may need to restart the
    command window before you can use it. Restart the Command Prompt as an administrator,
    and then execute the following commands to install Node on windows using the Chocolatey
    package manager:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chocolatey 安装完成后，您可能需要在能够使用它之前重启命令窗口。以管理员身份重启命令提示符，然后执行以下命令，使用 Chocolatey
    包管理器在 Windows 上安装 Node：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you've executed the first command, you will be prompted to execute a script.
    You will need to agree to run the script to install Node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行第一个命令后，您将被提示执行一个脚本。您需要同意运行脚本以安装 Node。
- en: 'To upgrade Node using Chocolatey, execute the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Chocolatey 升级 Node，执行以下命令：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may need to agree to run the installation script. If prompted, simply hit
    the *Y* key and press *Enter*. You now have the latest version of Node.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要同意运行安装脚本。如果提示，只需按下 *Y* 键并按 *Enter*。现在您已经拥有了最新的 Node 版本。
- en: NPM
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM
- en: NPM is a critical piece of the Node environment and community. Without NPM,
    Node would not have taken off quite like it has. In this section, we will discuss
    what NPM is, what NPM isn't, why you need NPM for doing Node development, and
    finally, where you can get NPM and how to install it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 是 Node 环境和社区的一个关键部分。没有 NPM，Node 就不会像现在这样蓬勃发展。在本节中，我们将讨论 NPM 是什么，NPM 不是什么，为什么您需要
    NPM 来进行 Node 开发，以及最后，您可以从哪里获取 NPM 以及如何安装它。
- en: What is NPM?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 NPM？
- en: Initially released in early 2010, **NPM** (**Node Package Manager**). NPM was
    written by Isaac Z. Schlueter, and is now maintained by a team of developers.
    Although NPM has Node in the acronym, it can also be used to manage packages for
    the browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**NPM**（**Node Package Manager**）最初于 2010 年初发布。NPM 由 Isaac Z. Schlueter 编写，现在由一个开发团队维护。尽管
    NPM 的缩写中有 Node，但它也可以用来管理浏览器包。'
- en: In the past few years, many package managers were created specifically for browser
    packages. One of the most prominent is *Bower*. These secondary package managers
    were created because NPM was perceived as a package manager best suited for, or
    perhaps only suited for, managing Node packages. This belief has subsided; however,
    Bower’s own website now suggests that it not be used.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，许多包管理器是专门为浏览器包创建的。其中最突出的是 *Bower*。这些二级包管理器之所以被创建，是因为人们认为 NPM 是最适合，或者可能仅适合管理
    Node 包的包管理器。这种看法已经减弱；然而，Bower 的官方网站现在建议不要使用它。
- en: Why do we need NPM?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要 NPM？
- en: While you do need to install NPM, you don't necessarily have to use it. In late
    2016, Facebook released an alternative package manager named *Yarn*, which uses
    the NPM registry, so all of your favorite packages are available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您需要安装 NPM，但您不一定必须使用它。在 2016 年晚些时候，Facebook 发布了一个名为 *Yarn* 的替代包管理器，它使用 NPM
    注册表，因此您可以使用所有喜欢的包。
- en: There are likely other package management alternatives to NPM as well. These
    alternative package managers are important because they drive improvements in
    NPM, but ultimately, they will likely fade and NPM will continue to be the preferred
    package manager for Node, and for JavaScript in general. If you do decide to use
    an alternative package manager such as Yarn, you will need to install it using
    NPM.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能还有其他 NPM 的包管理替代方案。这些替代包管理器很重要，因为它们推动了 NPM 的改进，但最终，它们可能会逐渐消失，NPM 仍将是 Node
    以及 JavaScript 的一般首选包管理器。如果您决定使用 Yarn 等替代包管理器，您将需要使用 NPM 来安装它。
- en: Installing NPM?
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装 NPM？
- en: 'Good news; you already have NPM installed if you have gone through the process
    of installing Node. You may occasionally want to upgrade NPM outside Node''s release
    cycle. To attempt an upgrade, simply open your operating system''s preferred console
    or Terminal window and execute the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息；如果您已经完成了 Node 的安装过程，那么您已经安装了 NPM。您可能偶尔想要在 Node 的发布周期之外升级 NPM。要尝试升级，只需打开您操作系统首选的控制台或终端窗口，并执行以下命令：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: NPM is just another executable on your computer. It takes a list of arguments
    or parameters. In this case, we are asking NPM to install a package. The second
    argument, `-g`, tells NPM that we want to install the requested package globally.
    Lastly, the package we are asking NPM to install is NPM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: NPM只是你电脑上的另一个可执行文件。它接受一系列参数或参数。在这种情况下，我们要求NPM安装一个包。第二个参数`-g`告诉NPM我们想要全局安装请求的包。最后，我们要求NPM安装的包是NPM。
- en: A quick introduction to JavaScript IDEs
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对JavaScript IDE的简要介绍
- en: While you don't need an **IDE** (**Integrated Development Environment**) per
    se, you will need a text editor. Why not have a text editor that does a little
    bit of the heavy lifting for you? There are, essentially, two types of IDEs available
    for JavaScript development. The first kind is really more of a text editor than
    anything else, whereas the second kind is a full-blown editor with compiling and
    source control built in.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不需要一个真正的**IDE**（**集成开发环境**），但你将需要一个文本编辑器。为什么不选择一个能为你做些重活的文本编辑器呢？实际上，对于JavaScript开发，有两种类型的IDE可用。第一种实际上更像是一个文本编辑器，而第二种则是一个功能齐全的编辑器，内置编译和源代码控制。
- en: While you can work on JavaScript with only a simple text editor and a console/Terminal
    window, we recommend using something with at least a little more power.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以只用简单的文本编辑器和控制台/终端窗口来处理JavaScript，但我们建议使用功能更强大的工具。
- en: Visual Studio Code
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Visual Studio Code, as described in the C# section, is a lightweight editor
    based on the Electron framework and developed in TypeScript, a language designed
    by Microsoft to extend JavaScript with static types. TypeScript compiles to JavaScript,
    so ultimately Visual Studio Code is a JavaScript application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如C#部分所述，Visual Studio Code是一个基于Electron框架的轻量级编辑器，使用TypeScript开发，这是一种由微软设计来扩展JavaScript的静态类型语言。TypeScript编译成JavaScript，所以最终Visual
    Studio Code是一个JavaScript应用程序。
- en: Why Visual Studio Code?
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Visual Studio Code？
- en: For working with JavaScript, there are several reasons why you might choose
    Visual Studio Code or one of the other Electron-based editors. VSCode is lightweight,
    has an extensive plugin architecture, is integrated with source control, and is
    very easy to set up and use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用JavaScript，你可能选择Visual Studio Code或其他基于Electron的编辑器有几个原因。VSCode轻量级，拥有广泛的插件架构，与源代码控制集成，并且非常容易设置和使用。
- en: Installing Visual Studio Code
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio Code
- en: Installing VSCode is extremely simple. If you have already followed along in
    the *C#* section, then you likely have VSCode installed already. If not, here
    are some alternative ways to install it that were not discussed there.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安装VSCode极其简单。如果你已经跟随了*C#*部分，那么你很可能已经安装了VSCode。如果没有，这里有一些未讨论的替代安装方法。
- en: Linux
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'To install on Linux (again, this is an example for Ubuntu), simply execute
    the following commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux上安装（再次提醒，这是一个针对Ubuntu的示例），只需执行以下命令：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Mac
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac
- en: Unfortunately, I don't have a fancy command-line way to install  VSCode on a
    Mac. Instead, go to the Visual Studio Code homepage at [https://code.visualstudio.com](https://code.visualstudio.com) and
    follow the installation instructions there.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我没有一个花哨的命令行方法在Mac上安装VSCode。相反，请访问Visual Studio Code的主页[https://code.visualstudio.com](https://code.visualstudio.com)，并遵循那里的安装说明。
- en: Windows
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: 'For Windows, just like with Node, we can install VSCode using Chocolatey. To
    install using Chocolatey ([https://chocolatey.org/install](https://chocolatey.org/install)),
    execute the following command in a console window. Remember, you may want to run
    the console as an administrator:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows系统，就像Node一样，我们可以使用Chocolatey来安装VSCode。要使用Chocolatey（[https://chocolatey.org/install](https://chocolatey.org/install)）安装，请在控制台窗口中执行以下命令。记住，你可能需要以管理员身份运行控制台：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Installing the plugins you will need
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装所需的插件
- en: The two plugins that we would recommend getting are `npm` and `npm-intellisense`
    because they will aid in the flow and provide hints when you are not 100% sure
    that you are using the correct package name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐安装的两个插件是`npm`和`npm-intellisense`，因为它们将有助于流程并提供提示，当你不确定是否使用了正确的包名时。
- en: Configuring the testing environment
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试环境
- en: Visual Studio Code offers built-in test running capabilities. We are not going
    to choose those options for JavaScript development, however. For the purposes
    of test driving our application and demonstrating our approach to testing, we
    think using the available Terminal inside VSCode will be more appropriate and
    better suited to the flow that will be used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code提供了内置的测试运行功能。然而，我们不会选择这些选项进行JavaScript开发。为了测试驱动我们的应用程序并展示我们的测试方法，我们认为使用VSCode内可用的终端将更加合适，并且更适合将要使用的流程。
- en: WebStorm
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebStorm
- en: WebStorm is a full-blown IDE written by JetBrains in Java.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm是由JetBrains用Java编写的完整IDE。
- en: Why WebStorm?
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择WebStorm？
- en: WebStorm basically comes with everything you need to develop a JavaScript-based
    application. It also supports many of the JavaScript ecosystem alternatives to
    JavaScript, such as TypeScript, Flow, and React JSX. WebStorm also integrates
    seamlessly with many code-quality tools such as ESLine, TSLint, and JSHint.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm基本上包含了您开发基于JavaScript的应用程序所需的一切。它还支持许多JavaScript生态系统中的JavaScript替代品，如TypeScript、Flow和React
    JSX。WebStorm还与许多代码质量工具无缝集成，如ESLine、TSLint和JSHint。
- en: The only downside to WebStorm is that it does cost money. But, when you look
    at it, a paid product is actually a good thing. The company making the paid product
    has a good reason to continue maintaining it. JetBrains offers the purchase of
    WebStorm through a single purchase or through a subscription. We suggest the subscription,
    as the upfront cost to you is minimized and JetBrains has more motivation to keep
    you happy this way.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm的唯一缺点是它确实需要付费。但是，当你这么看的时候，付费产品实际上是一件好事。制作付费产品的公司有很好的理由继续维护它。JetBrains提供通过单次购买或订阅购买WebStorm。我们建议选择订阅，因为您的前期成本最小化，并且JetBrains有更多的动力让您保持满意。
- en: Installing WebStorm
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装WebStorm
- en: To install WebStorm, we are going to use a newer program created by JetBrains
    called *The JetBrains Toolbox App*. The Toolbox App is designed to track version
    updates and provide a common launching point for all JetBrains products. Once
    installed, it becomes very easy to install any of the JetBrains tools.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装WebStorm，我们将使用JetBrains创建的新程序，称为*The JetBrains Toolbox App*。Toolbox App旨在跟踪版本更新并为所有JetBrains产品提供一个共同的启动点。一旦安装，安装任何JetBrains工具都变得非常容易。
- en: Linux
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'There does not appear to be, at the time of writing, a way to install ToolBox
    or WebStorm from `apt-get`*.* So, we will have to do it the hard way. Go to the
    ToolBox download page at [https://www.jetbrains.com/toolbox/app/](https://www.jetbrains.com/toolbox/app/) and
    download the Linux tarball. Then, open a Terminal to your download directory.
    Once there, execute the following commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，似乎没有从`apt-get`安装ToolBox或WebStorm的方法。因此，我们只能采取困难的方式。请访问ToolBox下载页面[https://www.jetbrains.com/toolbox/app/](https://www.jetbrains.com/toolbox/app/)并下载Linux
    tarball。然后，打开一个终端到您的下载目录。一旦到达那里，执行以下命令：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Mac
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac
- en: 'On Mac, we can again use Homebrew for installation. Just execute the following
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，我们还可以再次使用Homebrew进行安装。只需执行以下命令：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Windows
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: 'On Windows, we are able to use Chocolatey to install Toolbox. Execute the following
    command and then launch the app:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们能够使用Chocolatey安装Toolbox。执行以下命令然后启动应用程序：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our ultimate goal when installing the Toolbox was to install WebStorm. So, with
    the Toolbox open, either sign in if you have purchased any JetBrains products
    or skip the sign in if you just want to try them out. Next, find WebStorm in the
    products list and click the button to install it. Once the install has finished,
    you will be able to click a Launch button that will replace the Install button.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装ToolBox的最终目标是安装WebStorm。因此，当ToolBox打开时，如果您购买了任何JetBrains产品，请登录；如果您只是想试用，请跳过登录。接下来，在产品列表中找到WebStorm并点击安装按钮。安装完成后，您将能够点击一个启动按钮，该按钮将替换安装按钮。
- en: Installing the plugins you will need
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装您需要的插件
- en: We've got good news for plugins with WebStorm. WebStorm offers a great plugin
    community, with every plugin you could possibly want accessible through a plugin
    management system built into the application. For the purposes of this book, however,
    you don't actually need any. So, we are done installing plugins! In fact, if anything,
    WebStorm has too much functionality built in, and we will be ignoring or even
    turning off some of it so that we can work the way we want to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为使用 WebStorm 的插件带来了好消息。WebStorm 提供了一个庞大的插件社区，你几乎可以找到你想要的任何插件，这些插件都可以通过应用程序内置的插件管理系统访问。然而，对于本书的目的而言，你实际上并不需要任何插件。因此，我们已经完成了插件的安装！实际上，WebStorm
    内置的功能太多了，我们将忽略或甚至关闭其中的一些功能，以便我们可以按照自己的方式工作。
- en: Configuring the testing environment
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试环境
- en: Just as in Visual Studio Code, for WebStorm we are not going to cover setting
    up any of the built-in test running capability. WebStorm offers a Terminal display
    that can be turned on and supports having multiple contexts open at the same time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Visual Studio Code中一样，对于WebStorm，我们不会介绍如何设置内置的测试运行能力。WebStorm提供了一个可以开启的终端显示，并支持同时打开多个上下文。
- en: Create React App
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Create React App
- en: Now that you have Node and NPM installed and up-to-date, turn your attention
    to the application you want to test drive. Due to its constantly increasing popularity,
    we are choosing to explain and demonstrate Test-Driven Development by testing
    a React application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了最新版本的Node和NPM，请将注意力转向你想要测试的应用程序。由于其不断增长的流行度，我们选择通过测试一个React应用程序来解释和演示测试驱动开发。
- en: According to the React website, React is *A JavaScript library for building
    user interfaces*. We are going to focus on using it for a front-end browser application,
    but it can be used to create mobile and desktop applications as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据React网站，React是*一个用于构建用户界面的JavaScript库*。我们将专注于使用它来构建前端浏览器应用程序，但它也可以用来创建移动和桌面应用程序。
- en: React was created and is maintained by Facebook. React was created to solve
    issues that Facebook had in its own user interface, and it is now taking the internet
    by storm. Facebook has also created a library called Create React App to quickly
    get a React application going.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: React是由Facebook创建和维护的。React是为了解决Facebook在其用户界面中遇到的问题而创建的，现在它正在互联网上掀起一场风暴。Facebook还创建了一个名为Create
    React App的库，以便快速启动React应用程序。
- en: What is Create React App?
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Create React App是什么？
- en: Create React App is an NPM package created by Facebook for the purpose of providing
    a zero-configuration way to create a react application. React requires quite a
    lot to get started, and it can take days to configure a React application manually.
    Create React App can reduce that time to under a minute.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App是由Facebook创建的一个NPM包，旨在提供一种零配置的方式来创建React应用程序。React需要相当多的设置才能开始，手动配置一个React应用程序可能需要几天时间。Create
    React App可以将这个时间缩短到一分钟以内。
- en: Installing the global module
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装全局模块
- en: 'Create React App has a global NPM package that must be installed before you
    can use the command-line utility to actually create a React application. To install
    the latest version of the Create React App global script, execute the following
    command in a console or Terminal window:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够使用命令行工具实际创建React应用程序之前，必须安装Create React App的全局NPM包。要在控制台或终端窗口中安装最新版本的Create
    React App全局脚本，请执行以下命令：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a React application
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建React应用程序
- en: 'Once the global module is installed, you will be ready to start using Create
    React App. Creating a React application is extremely streamlined and simple. On
    my system, I have a directory `\projects` that I use to house all my front-end
    application projects. Open a console/Terminal window to a similarly purposed directory
    on your machine and execute the following command to create a new React application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦全局模块安装完成，你就可以开始使用Create React App了。创建一个React应用程序的过程非常流畅和简单。在我的系统中，我有一个名为`\projects`的目录，用于存放所有我的前端应用程序项目。在你的机器上打开一个具有相同目的的目录的命令行/终端窗口，并执行以下命令来创建一个新的React应用程序：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our case, the name of our test case is Speaker Meet, so as an example, my
    command is displayed as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们的测试用例名称是Speaker Meet，所以作为一个例子，我的命令如下所示：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: SpeakerMeet, as mentioned in the C# section, has both a back-end (the RESTful
    Web API) and a front-end (a React-based **SPA** (**Single Page Application**)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在C#部分提到的，SpeakerMeet既有后端（RESTful Web API），也有前端（基于React的**SPA**（**单页应用程序**））。
- en: Running the Create React App script
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Create React App脚本
- en: 'When the `create-react-app` script finishes running, a list of available commands
    is displayed. You want to make sure that everything was successfully created.
    You can launch the application by executing the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `create-react-app` 脚本运行完成后，会显示一个可用命令列表。您需要确保一切创建成功。您可以通过执行以下命令来启动应用程序：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If everything installed correctly, your default browser will open and a new
    React application will be running.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切安装正确，您的默认浏览器将打开，并运行一个新的 React 应用程序。
- en: Mocha and Chai
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocha 和 Chai
- en: Create React App supports testing right out of the box. Initially, Create React
    App uses a testing library named Jest. We want to use Mocha and Chai due to their
    popularity in the JavaScript community.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App 支持开箱即用的测试。最初，Create React App 使用名为 Jest 的测试库。我们想使用 Mocha 和
    Chai，因为它们在 JavaScript 社区中非常受欢迎。
- en: Jest
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jest
- en: Jest is a testing framework written by Facebook. Just like Create React App,
    Jest is designed to be a zero-configuration tool. Jest also supports continuous
    testing and code coverage analysis.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是由 Facebook 编写的测试框架。就像 Create React App 一样，Jest 设计为无配置工具。Jest 还支持持续测试和代码覆盖率分析。
- en: Jest is designed to work within the common **BDD** (**behavior-driven development**)
    paradigms, as are many other JavaScript testing frameworks. As such, the testing
    functions `describe` and `it` can both be used to write your tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是设计在常见的 **BDD**（**行为驱动开发**）范式下工作的，许多其他 JavaScript 测试框架也是如此。因此，测试函数 `describe`
    和 `it` 都可以用来编写测试。
- en: Mocha
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocha
- en: Mocha is another JavaScript testing framework and is the one we would like to
    use. As for library interaction differences, there doesn't appear to be much different
    in terms of base interactions. The differences come down to the assertion library
    and the mocking library.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是另一个 JavaScript 测试框架，是我们想使用的框架。至于库交互差异，基础交互方面似乎没有太多不同。差异主要体现在断言库和模拟库上。
- en: Mocking, which will be covered in detail in [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195), *What
    to Know Before Getting Started*, is essentially a way to provide alternative implementations
    of objects, classes, and functions, specifically to aid the testing process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟，将在第 4 章[Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195)“开始之前需要了解的内容”中详细说明，本质上是一种提供对象、类和函数的替代实现的方法，特别是为了帮助测试过程。
- en: Mocha itself doesn't come with an assertion library, so one must be provided.
    The assertion library is what controls test results and how to verify that your
    code is executing correctly. Most developers who use Mocha rely on Chai for assertions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 本身不包含断言库，因此必须提供。断言库是控制测试结果以及如何验证代码是否正确执行的关键。大多数使用 Mocha 的开发者依赖于 Chai 进行断言。
- en: As mentioned previously, another consideration is what mocking library you want
    to use. For many Mocha users, that library is unquestionably *Sinon*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，另一个考虑因素是您想使用哪个模拟库。对于许多 Mocha 用户来说，这个库无疑是 **Sinon**。
- en: We will explain the purpose of any and all parts of Mocha that we use in this
    book. If you want to know more or want the documentation for quick reference while
    you are developing, you can go to the Mocha home page at [https://mochajs.org](https://mochajs.org).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释本书中使用的 Mocha 的任何和所有部分的目的。如果您想了解更多信息或想在开发时快速参考文档，您可以去 Mocha 主页[https://mochajs.org](https://mochajs.org)。
- en: 'Mocha can be installed into a JavaScript application using the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 可以使用以下命令安装到 JavaScript 应用程序中：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Chai
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chai
- en: Chai is a BDD assertion library. Chai uses a fluent API to allow for extremely
    flexible assertions. The two most popular ways that Chai is used are through the *should* and *expect* interfaces
    provided. The way that Chai works, and in fact, the way that every testing frameworks
    assertion works, is by throwing an exception when the check done by the assertion
    fails.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 是一个 BDD 断言库。Chai 使用流畅的 API 来允许极其灵活的断言。Chai 最受欢迎的两种使用方式是通过提供的 **should**
    和 **expect** 接口。Chai 的工作方式，以及实际上每个测试框架断言的工作方式，是在断言的检查失败时抛出异常。
- en: For instance, if you had a variable named `foo` with a value *3* and your assertion
    was `expect(foo).to.equal(5)` when the test ran, that assertion would throw an
    exception with a message that says `expected 3 to equal 5`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个名为 `foo` 的变量，其值为 **3**，并且当测试运行时您的断言是 `expect(foo).to.equal(5)`，那么这个断言将抛出一个包含消息“预期
    3 等于 5”的异常。
- en: 'To install Chai into your project, run the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Chai 安装到您的项目中，请运行以下命令：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have Chai installed, there is one more step that must be taken to
    be able to use it within your project. You must include the following import at
    the top of each test file in your application:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装 Chai 之后，还需要进行一个步骤才能在您的项目中使用它。您必须在应用程序中每个测试文件的顶部包含以下导入：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you wish to use should assertions, you can either replace `expect` with `should` or
    add `should` inside the curly braces, separating it from `expect` with a comma.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 should 断言，您可以将 `expect` 替换为 `should`，或者在大括号内添加 `should`，用逗号将其与 `expect`
    分隔。
- en: For more information or to refer to the documentation, the Chai home page is [https://chaijs.com](https://chaijs.com).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息或查阅文档，请访问 Chai 主页 [https://chaijs.com](https://chaijs.com)。
- en: Sinon
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sinon
- en: We won't be getting into mocking until [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195),
    *What to Know Before Getting Started*, but Sinon is the generally preferred mocking
    library among Mocha + Chai users. Some testing frameworks, such as Jest and Jasmine,
    come with their own mocking library features, but Mocha does not, and Sinon provides
    an excellent mocking experience.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在 [第 4 章](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195) “开始之前需要了解的内容”
    中介绍模拟，但 Sinon 是 Mocha + Chai 用户中普遍首选的模拟库。一些测试框架，如 Jest 和 Jasmine，自带模拟库功能，但 Mocha
    没有自带，而 Sinon 提供了出色的模拟体验。
- en: 'To install Sinon into your project, execute the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Sinon 安装到您的项目中，请执行以下命令：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once installed, you will need to import Sinon before you can use it. Use the
    following import statement to enable the use of Sinon:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您在使用 Sinon 之前需要导入它。使用以下导入语句来启用 Sinon 的使用：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enzyme
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Enzyme
- en: Enzyme is a library designed to aid in the testing of React components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme 是一个旨在帮助测试 React 组件的库。
- en: 'To install Enzyme into your project, execute the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Enzyme 安装到您的项目中，请执行以下命令：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The extra libraries listed, `react-test-renderer` and `react-dom`, are dependencies
    of Enzyme that it needs to function correctly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的额外库 `react-test-renderer` 和 `react-dom` 是 Enzyme 正确运行所需的依赖项。
- en: 'As with the other testing utilities mentioned in this section, we will get
    into usage as needed, while we discuss the topics covered in this book. But here
    is a quick example of a test using Enzyme from the Enzyme documentation at [https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与本节中提到的其他测试实用工具一样，我们将根据需要讨论使用方法，同时讨论本书涵盖的主题。但这里有一个使用 Enzyme 的快速示例，该示例来自 Enzyme
    文档 [https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme)：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ejecting the React app
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出 React 应用
- en: Unfortunately, this is where we part company with Create React App. In order
    to use Mocha, we will need to find an alternative way to work with the application.
    Because of the zero-configuration setup of Create React App, we cannot simply
    update the testing framework being used, and that is a problem for us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这就是我们与 Create React App 分道扬镳的地方。为了使用 Mocha，我们需要找到一种替代方法来与应用程序一起工作。由于 Create
    React App 的零配置设置，我们无法简单地更新正在使用的测试框架，这对我们来说是个问题。
- en: Thankfully, Create React App gives us an out in the form of ejecting the application.
    Ejecting the React application will install all the necessary configuration files
    and utilities into our project and remove Create React App.  Once the ejection
    process is finished, we will have access to all the configuration files and we
    will have the ability to switch to using Mocha.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Create React App 以退出应用的形式为我们提供了一个出路。退出 React 应用程序会将所有必要的配置文件和实用工具安装到我们的项目中，并移除
    Create React App。一旦退出过程完成，我们将能够访问所有配置文件，并将能够切换到使用 Mocha。
- en: 'To eject Create React App, execute the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 Create React App，请执行以下命令：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you take a look at the `package.json` in the root of the project, you will
    see that a lot of information and configuration have been added.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看项目根目录下的 `package.json`，您将看到添加了很多信息和配置。
- en: After any major modification to `package.json`, it is a good idea to delete
    `node_modules` and `package-lock.json` and then re-run `npm install`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `package.json` 进行任何重大修改后，删除 `node_modules` 和 `package-lock.json`，然后重新运行 `npm
    install` 是一个好主意。
- en: Configuring to use Mocha and Chai
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置以使用 Mocha 和 Chai
- en: 'After you have ejected the React app, before you make any further modifications,
    you should make sure everything still works. Execute the following command before
    making any further modifications:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在您退出 React 应用之后，在您进行任何进一步的修改之前，您应该确保一切仍然正常工作。在做出任何进一步的修改之前，请执行以下命令：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now check that a browser launched and that the application is running correctly.
    You will have to *Ctrl* + *C* to exit the running process:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查是否启动了浏览器，并且应用程序正在正确运行。你将需要按 *Ctrl* + *C* 退出运行进程：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After this command, check that a build folder was created at the root of your
    project and that there were no errors displayed in the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令之后，检查是否在项目根目录中创建了一个构建文件夹，并且控制台没有显示错误：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even though you are about to change the test configuration, you will be using
    some of the libraries that were provided by Create React App. You want to make
    sure that those prerequisites transitioned properly when you ejected. As with `npm
    start`, you will have to *Ctrl* + *C* to exit this process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你即将更改测试配置，但你将使用一些 Create React App 提供的库。你想要确保当你退出时，这些先决条件已经正确过渡。与 `npm start`
    一样，你将需要按 *Ctrl* + *C* 退出此进程。
- en: 'Assuming all of the commands executed without issues, you can now start the
    process of switching the test environment over to Mocha. Execute the following
    command to ensure the installation of the necessary dependencies:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有命令都无问题执行，你现在可以开始将测试环境切换到 Mocha 的过程。执行以下命令以确保安装必要的依赖项：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open `package.json` and update the following lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `package.json` 并更新以下行：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change the preceding code to:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码更改为：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will also need to install the BabelJS preset for ES2015:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装 BabelJS 预设 ES2015：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, find and delete the `jest` setting in `package.json`. You are now ready
    to change the `test` script to execute Mocha instead of Jest. Find NPM scripts
    and update the test script as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到并删除 `package.json` 中的 `jest` 设置。你现在可以更改 `test` 脚本来执行 Mocha 而不是 Jest。找到
    NPM 脚本并更新测试脚本如下：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Change the preceding code to:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码更改为：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The change you just made will cause Mocha to execute all of your tests. It will
    only execute them once, though. You want a way to have your tests running continuously
    while you work, so you need to add an additional script. Add a comma to the end
    of the line you just modified and then add the following script just beneath `test`*:*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才所做的更改将导致 Mocha 执行所有测试。不过，它只会执行一次。你想要一个在工作的同时持续运行测试的方法，所以你需要添加一个额外的脚本。在你修改的行末尾添加一个逗号，然后在其下方添加以下脚本：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, you need to update the `test.js` file provided when you ejected. Open `<project
    root>/scripts/test.js` and replace all the code inside with the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要更新当你退出时提供的 `test.js` 文件。打开 `<项目根目录>/scripts/test.js` 并将里面的所有代码替换为以下内容：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This file just sets up the base environment for your tests to execute inside.
    Make note of the `noop` function and usage. Currently, you are ignoring the `css`
    and `svg` extensions that are required by your production code when you are testing.
    In the course of testing, if you run into issues while requiring a different extension,
    you might have to come back to this file and add the troublesome extension to
    the list.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件只是为测试设置基础环境，以便测试在内部执行。注意 `noop` 函数及其用法。目前，当你进行测试时，你正在忽略生产代码所需的 `css` 和 `svg`
    扩展。在测试过程中，如果你在需要不同扩展时遇到问题，你可能需要回到此文件并将有问题的扩展添加到列表中。
- en: 'You are almost done; you only have one more modification to make before you
    are officially switched over to Mocha. Find the file `App.test.js` in your `src` directory,
    and change its name to `App.spec.js`, then update the contents to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎完成了；在你正式切换到 Mocha 之前，你只需要进行一个修改。在你的 `src` 目录中找到 `App.test.js` 文件，并将其重命名为
    `App.spec.js`，然后更新内容如下：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All you have really done here is import Chai and add a `describe` block. The
    rest of this test has remained unchanged and is the default test provided with
    Create React App.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里真正做的只是导入 Chai 并添加一个 `describe` 块。其余的测试代码保持不变，是 Create React App 提供的默认测试。
- en: A quick kata to check our test setup
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个快速 kata 来检查我们的测试设置
- en: For this setup test, you are going to do the Palindrome code kata. This code
    kata can get complex, but you are only going to concern yourself with the most
    basic form.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个设置测试，你需要执行回文代码 kata。这个 kata 可能会变得复杂，但你只需要关注最基本的形式。
- en: The requirements
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'The requirements for this kata are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 kata 的要求如下：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The execution
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行
- en: 'As you always should, you will begin with a templated test file designed to
    verify that the unit testing framework is configured correctly:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你一直应该做的，你将从一个模板化的测试文件开始，用于验证单元测试框架是否配置正确：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have shown a failing version of this template. Before you begin writing the
    tests that are actually for the kata, run the `test:watch` NPM script and verify
    that the test fails. Also, verify that it fails for the right reason. It should
    fail because *1* was expected but *0* was the actual result. After the test properly
    fails, change the zero to a one and verify that the test now passes. As long as
    these two validations work correctly, we will continue and begin working through
    the code kata.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了这个模板的失败版本。在你开始编写实际的kata测试之前，运行`test:watch` NPM脚本来验证测试失败。同时，验证它是否因为预期的*1*但实际结果是*0*而失败。在测试正确失败后，将零改为一，并验证测试现在是否通过。只要这两个验证都正确工作，我们就会继续，并开始处理代码kata。
- en: Starting the kata
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始kata
- en: The first thing you will do for the kata is write an `ItExists` test. Again,
    these types of test help to get the ball rolling and prevent writer's block. You
    will replace the code for checking the framework with the following.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个kata，你将要做的是编写一个`ItExists`测试。同样，这些类型的测试有助于推动工作并防止写作障碍。你将用以下代码替换检查框架的代码。
- en: '*Red phase*; write a failing test that expects an `isPalindrome` function to
    exist:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*红色阶段*；编写一个失败的测试，期望存在一个`isPalindrome`函数：'
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Verify that this test fails. It's important to see a failure before moving on
    to making the test pass. This will help confirm that your test setup is working
    properly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 验证这个测试是否失败。在继续使测试通过之前看到失败是很重要的。这将有助于确认你的测试设置是否正常工作。
- en: And now the *green phase*; make the test pass. Define an `isPalindrome` function
    and run the test once more to see it pass.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是*绿色阶段*；让测试通过。定义一个`isPalindrome`函数，并再次运行测试以查看它是否通过。
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the next test, we want to think of the simplest test case that would produce
    a result. Again, we are skipping bad data issues. The simplest test case we can
    think of that would product a result is a single letter. For the definition of
    palindrome that you will be using for these tests, a single letter is a palindrome.
    Add the following test under the previous one:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们想要考虑一个会产生结果的简单测试用例。同样，我们正在跳过不良数据问题。我们可以想到的最简单的会产生结果的测试用例是一个单个字母。对于你将在这些测试中使用的回文定义，单个字母是一个回文。在之前的测试下添加以下测试：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, to make it pass:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让它通过：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now you have a passing test, but you are always returning true. You want the
    next test to fail when you write it. So, you should write a test for when the
    value passed in is not a palindrome. The simplest non-palindrome would be two
    letters that are not the same:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个通过测试，但你总是返回true。当你编写下一个测试时，你希望它失败。所以，你应该编写一个测试，当传入的值不是回文时。最简单的非回文就是两个不相同的字母：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, make it pass:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让它通过：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Okay, so now you only return true single letters. This opens us up for our
    next test, flipping back to something that is a palindrome; write a test for two
    letters that are the same:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以现在你只返回单个字母的true。这为我们打开了下一个测试，回到一个回文；为相同的两个字母编写一个测试：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, to make it pass:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让它通过：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next test is to have a three-letter word that is a palindrome. Currently,
    this should fail:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是要有一个三个字母的回文单词。目前，这个应该失败：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make this test pass, think about what you have so far. One algorithm for
    checking a palindrome is to simply start on the outsides and check the two outermost
    letters. If those two letters are a match, then move in one letter on each side.
    Repeat this check until you get to the center of the word or phrase. If the center
    is one letter, then it''s a palindrome; otherwise, check if the two center-most
    characters are a match. Let''s try this concept out by using recursion to make
    the latest test pass:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个测试通过，想想你到目前为止学到的东西。检查回文的一个算法就是从两端开始，检查最外层的两个字母。如果这两个字母匹配，那么就分别在两边各移动一个字母。重复这个检查，直到你到达单词或短语的中心。如果中心是一个字母，那么它就是一个回文；否则，检查中间的两个字母是否匹配。让我们通过使用递归来尝试这个概念，以便让最新的测试通过：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We now need to check if a four-letter palindrome will pass:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要检查一个四字母回文是否通过：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It passes; excellent! We will end this code kata with two exercises for you.
    The first exercise is to add a test for "a man a plan a canal panama" and make
    it pass. The second exercise is to refactor the code for `isPalindrome`. While
    this is a small function, it could still do with some tidying up, and potentially
    some optimizations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过了；太棒了！我们将以两个练习结束这个代码kata。第一个练习是添加一个测试来检查“a man a plan a canal panama”，并让它通过。第二个练习是重构`isPalindrome`的代码。虽然这是一个小的函数，但它仍然可以进行一些整理，并且可能需要进行一些优化。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have Node installed and your JavaScript development environment
    configured. JavaScript examples throughout the rest of the book will assume your
    use of WebStorm.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该已经安装了Node，并且配置好了您的JavaScript开发环境。本书余下的JavaScript示例将假设您使用WebStorm。
- en: But, before diving right in, [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195), *What
    to Know Before Getting Started*, will focus on what more you need to know before
    getting started.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在深入之前，[第4章](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195)，*开始之前需要了解的内容*，将专注于在开始之前您还需要了解什么。
