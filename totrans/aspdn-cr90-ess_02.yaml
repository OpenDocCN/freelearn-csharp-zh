- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Building Dynamic UIs with Razor Pages, MVC, and Blazor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Razor Pages、MVC和Blazor构建动态UI
- en: ASP.NET Core 9 has a complete UI framework to suit different types of approaches
    and applications that allow the use of page rendering strategies on both the client
    side and server side. In this chapter, we will learn about the options available
    in the ASP.NET Core UI framework, in addition to understanding how to define the
    best option for each scenario.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9提供了一个完整的UI框架，适用于不同类型的方法和应用程序，允许在客户端和服务器端使用页面渲染策略。在本章中，我们将了解ASP.NET
    Core UI框架中可用的选项，以及了解如何为每个场景定义最佳选项。
- en: Initially, we will understand some important concepts and then continue with
    a practical approach so that we are able to exercise the concepts learned.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将了解一些重要概念，然后继续以实际的方法进行，以便我们能够练习所学的概念。
- en: In this approach, we will initially understand what the ASP.NET Core UI framework
    is, learning about the different approaches to rendering applications both on
    the server, using Razor Pages and ASP.NET MVC, and rendering on the client, using
    JavaScript frameworks. Finally, we will understand the power of merging different
    technologies into a hybrid solution that uses the best of both the client and
    the server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们最初将了解ASP.NET Core UI框架是什么，学习在服务器上使用Razor Pages和ASP.NET MVC以及客户端使用JavaScript框架渲染应用程序的不同方法。最后，我们将了解将不同技术合并到混合解决方案中的力量，该解决方案结合了客户端和服务器两方面的最佳之处。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Learning about the ASP.NET Core UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解ASP.NET Core UI
- en: Implementing a UI server render model with Razor Pages and ASP.NET MVC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Razor Pages和ASP.NET MVC实现UI服务器渲染模型
- en: Exploring UI client rendering with Blazor and JavaScript frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用Blazor和JavaScript框架进行UI客户端渲染
- en: Working with hybrid solutions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与混合解决方案一起工作
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all code examples and other materials used in this chapter in
    the following repository: [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下存储库中找到本章中使用的所有代码示例和其他材料：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials)
- en: Learning about the ASP.NET Core UI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解ASP.NET Core UI
- en: Dynamic web-based applications have a flow that basically involves two distinct
    “worlds” the frontend and the backend. In general, the frontend deals with the
    mechanisms that are visualized and allow interaction between users and the various
    functionalities proposed by the solution. Therefore, a frontend is made up of
    buttons, texts, lists, menus, images, and other aspects that together form the
    UI. The backend is the representation of the mechanisms used to allow dynamism
    to the frontend, according to user interaction. We will discuss more about backend-related
    aspects in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044) .
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 动态的基于网络的程序具有一种基本涉及两个不同“世界”的流程，即前端和后端。一般来说，前端处理的是可视化的机制，允许用户与解决方案提出的各种功能进行交互。因此，前端由按钮、文本、列表、菜单、图像和其他方面组成，共同构成了用户界面（UI）。后端是允许前端根据用户交互实现动态性的机制的表示。我们将在[*第3章*](B21788_03.xhtml#_idTextAnchor044)中进一步讨论与后端相关的方面。
- en: Each of the terms expressed in the previous paragraph works in different contexts.
    The *frontend* usually runs on the client, which translates into the user’s browser.
    *Client* is a generic term that can express other types of user interaction. But
    in this case, we will talk about the client as the browser of your choice. The
    *backend* runs on the server, whether in a data center or even a cloud provider
    such as Azure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段落中表达的所有术语在不同的上下文中都有不同的作用。*前端*通常在客户端运行，这转化为用户的浏览器。*客户端*是一个通用术语，可以表达其他类型的用户交互。但在这个情况下，我们将讨论客户端为您的选择浏览器。*后端*在服务器上运行，无论是在数据中心还是在像Azure这样的云服务提供商上。
- en: Through user interactions in the UI, the user must communicate with the backend
    and subsequently be able to adapt to the server’s responses to deliver some type
    of response and interaction, again , to the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过UI中的用户交互，用户必须与后端通信，随后能够适应服务器的响应，以提供某种类型的响应和交互，再次，与用户进行交互。
- en: 'The browser basically uses three technologies: HTML, CSS, and JavaScript. HTML
    is static; that is, it is interpreted by the browser and then rendered in the
    form of a UI. CSS is responsible for making visual elements more attractive, defining
    colors, shadows, and formatting, among other design aspects. JavaScript is used
    to make static elements dynamic, and this includes, for example, making a call
    to a server, and depending on the result, modifying the user’s UI to adapt to
    the response of the processing carried out. JavaScript is responsible for increasing
    the ability of web-based applications to become dynamic and interactive. However,
    it can be complex to create and manipulate elements through JavaScript code and,
    in addition, to manage calls on the server. There are several excellent JavaScript
    frameworks available, such as Angular or React that allow you to develop richly
    dynamic UI solutions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器基本上使用三种技术：HTML、CSS 和 JavaScript。HTML 是静态的；也就是说，它被浏览器解释，然后以 UI 的形式渲染。CSS 负责使视觉元素更具吸引力，定义颜色、阴影和格式等设计方面。JavaScript
    用于使静态元素动态化，这包括例如调用服务器，并根据结果修改用户的 UI 以适应处理结果的响应。JavaScript 负责提高基于 Web 的应用程序的动态性和交互性。然而，通过
    JavaScript 代码创建和操作元素可能很复杂，此外，还需要管理服务器上的调用。有几种优秀的 JavaScript 框架可用，例如 Angular 或
    React，这些框架允许您开发丰富的动态 UI 解决方案。
- en: It is essential to have knowledge of UI technologies; however, in addition,
    we can benefit from an integrated development model that allows us to work on
    both the UI and the backend in a rich way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握 UI 技术知识是至关重要的；然而，我们还可以从一种集成的开发模型中受益，它允许我们丰富地同时处理 UI 和后端。
- en: ASP.NET Core 9 has a complete UI framework to meet any UI requirement for web
    applications and is fully integrated with the .NET platform, using best practices
    for separation of responsibilities, management, and maintenance, among other important
    aspects. Despite this, ASP.NET Core is not restricted to the use of the UI renderers
    proposed by the platform; it also integrates well with JavaScript frameworks and
    even allows you to use the best of the available options by adopting a hybrid
    approach.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 拥有一个完整的 UI 框架，以满足 Web 应用程序对任何 UI 的需求，并且与 .NET 平台完全集成，使用最佳实践进行职责分离、管理和维护等重要方面。尽管如此，ASP.NET
    Core 并不局限于使用平台提出的 UI 渲染器；它还与 JavaScript 框架很好地集成，甚至允许您通过采用混合方法使用最佳选项。
- en: However, before we move on to a more specific understanding of the options available
    in ASP.NET Core 9, let’s learn about important aspects related to web systems
    architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们更深入地了解 ASP.NET Core 9 中可用的选项之前，让我们先了解与 Web 系统架构相关的重要方面。
- en: Rendering the UI
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染 UI
- en: There are different approaches to developing web-based solutions when it comes
    to the UI layer, even before talking about technologies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论技术之前，关于 UI 层开发基于 Web 的解决方案就有不同的方法。
- en: There are basically two models, client-side and server-side, with their respective
    pros and cons. There is also a third possibility, which would be to use a hybrid
    approach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种模型，客户端和服务器端，各有其优缺点。还有一种第三种可能性，即使用混合方法。
- en: In the client-side model, processing is done locally in the browser. In this
    way, all the HTML, CSS, JavaScript, and other assets are processed by the browser,
    responding to user stimuli. Interactions with users are handled locally through
    scripts containing UI-related logic without the need to request the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端模型中，处理在浏览器本地进行。这样，所有 HTML、CSS、JavaScript 和其他资产都由浏览器处理，响应用户的刺激。与用户的交互通过包含
    UI 相关逻辑的脚本在本地处理，无需请求服务器。
- en: However, this approach depends on server resources, such as access to data,
    among other things, and so it is necessary to make frequent calls to the server
    in order to obtain information based on the user’s needs, which is then processed
    and presented in the UI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法依赖于服务器资源，例如访问数据等，因此有必要频繁调用服务器以获取基于用户需求的信息，然后处理并在 UI 中呈现。
- en: In the server-side approach, all the processing is delegated to the server,
    which returns a customized HTML page ready to be rendered in the browser. The
    server processes all the necessary information, allows access to data, manages
    business logic, has the ability to abstract sensitive information using secrets,
    and delegates minimal processing to the client. However, if the server is not
    available, it will not be possible to use the system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端方法中，所有处理都委托给服务器，服务器返回一个定制的 HTML 页面，准备在浏览器中渲染。服务器处理所有必要的信息，允许访问数据，管理业务逻辑，能够使用密钥抽象敏感信息，并将最小处理委托给客户端。然而，如果服务器不可用，将无法使用该系统。
- en: In the hybrid approach, there is a combination of the best of “ both worlds.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '在混合方法中，结合了“两者之最”。 '
- en: There are many JavaScript frameworks prepared to make web-based systems dynamic,
    providing a great user experience by processing resources on the client and, likewise,
    having the ability to interact with the server, delegating the processing of only
    relevant information to the UI rather than the entire processing of a page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 JavaScript 框架准备用来使基于 Web 的系统动态化，通过在客户端处理资源提供优秀的用户体验，同样，它们也有与服务器交互的能力，将仅相关的信息处理委托给
    UI 而不是整个页面的处理。
- en: Fortunately, ASP.NET Core 9 is prepared for the development of web-based solutions
    in the different approaches mentioned. We’ll start to understand the first UI
    development model, using Razor Pages, in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ASP.NET Core 9 为使用不同方法开发基于 Web 的解决方案做好了准备。我们将在下一节开始了解第一个 UI 开发模型，即使用 Razor
    Pages。
- en: Implementing a UI server render model with Razor Pages and ASP.NET MVC
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Razor Pages 和 ASP.NET MVC 实现一个 UI 服务器端渲染模型
- en: 'ASP.NET Core 9 offers two powerful server-render models: Razor Pages and MVC.
    They are similar models, but MVC is more elaborate and implements the Model-View-Controller
    architectural design pattern—we’ll talk more about this in the *ASP.NET Core MVC*
    section. For now, let’s start learning about Razor Pages.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 提供了两种强大的服务器端渲染模型：Razor Pages 和 MVC。它们是类似模型，但 MVC 更为复杂，并实现了模型-视图-控制器（Model-View-Controller）架构设计模式——我们将在
    *ASP.NET Core MVC* 部分详细讨论这一点。现在，让我们开始学习 Razor Pages。
- en: ASP.NET Core Razor Pages
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core Razor Pages
- en: Razor Pages is a server-rendered framework that implements a page-based model.
    The page-based model basically contextualizes the implementation of a specific
    page, taking into account the UI and business logic, but correctly segregating
    responsibilities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 是一个基于页面的服务器端渲染框架，它实现了页面模型。基于页面的模型基本上将特定页面的实现上下文化，考虑到 UI 和业务逻辑，但正确地分离了责任。
- en: Razor is a markup language that acts similarly to a template engine and combines
    its use with HTML and C# code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 是一种标记语言，其作用类似于模板引擎，并将它的使用与 HTML 和 C# 代码相结合。
- en: Razor’s origins
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 的起源
- en: Razor’s development began in June 2010, but it was only released in January
    2011 with MVC 3, as part of Microsoft Visual Studio 2010. Razor is a simple-syntax
    visualization engine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 的发展始于 2010 年 6 月，但直到 2011 年 1 月才随着 MVC 3 一起发布，作为 Microsoft Visual Studio
    2010 的一部分。Razor 是一个简单的语法可视化引擎。
- en: This page-based development model brings great advantages, such as ease of creating
    and updating the UI; it’s testable, keeps UI and business logic separate, and
    although it has similarities to ASP.NET Core MVC, it’s simpler. Taking all these
    advantages into consideration, let’s create our first project using Razor Pages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于页面的开发模型带来了许多优势，例如创建和更新 UI 的简便性；它是可测试的，保持了 UI 和业务逻辑的分离，尽管它与 ASP.NET Core
    MVC 有相似之处，但它更简单。考虑到所有这些优势，让我们使用 Razor Pages 创建我们的第一个项目。
- en: Creating our first project with Razor Pages
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Razor Pages 创建我们的第一个项目
- en: To create a Razor Pages project, you can use Visual Studio or the **dotnet**
    CLI tool.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Razor Pages 项目，您可以使用 Visual Studio 或 **dotnet** CLI 工具。
- en: 'Creation using Visual Studio is very simple; just open the IDE, select **Create
    a new project** , and then select the **ASP.NET Core Web App** template, as shown
    in *Figure 2* *.1* :'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 创建非常简单；只需打开 IDE，选择 **创建一个新项目**，然后选择 **ASP.NET Core Web App**
    模板，如图 *图 2.1* 所示：
- en: '![Figure 2.1 – Selecting a project template](img/B21788_02_1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 选择项目模板](img/B21788_02_1.jpg)'
- en: Figure 2.1 – Selecting a project template
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 选择项目模板
- en: Both Visual Studio and the CLI tool work with the concept of templates. With
    the .NET platform, it is possible to develop different types of projects, whether
    for web, Windows, or mobile. Each template creates a basic project structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 和 CLI 工具都使用模板的概念。使用 .NET 平台，可以开发不同类型的项目，无论是网页、Windows 还是移动应用。每个模板都会创建一个基本的项目结构。
- en: Throughout the rest of the book, we will use the CLI tool to create projects,
    as well as other needs that we will discuss later. From now on, we will use the
    .NET CLI tool to create a Razor Pages project, as this tool offers us several
    benefits that we will discuss in the rest of the book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用 CLI 工具来创建项目，以及我们稍后将要讨论的其他需求。从现在起，我们将使用 .NET CLI 工具来创建 Razor Pages
    项目，因为这个工具为我们提供了本书其余部分将要讨论的几个好处。
- en: When you install the .NET 9 SDK, a number of tools are available. The main tool
    we will use in this book is **dotnet** .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装 .NET 9 SDK 时，将提供一系列工具。本书中我们将使用的主要工具是 **dotnet** 。
- en: 'The **dotnet** CLI tool also has a concept of templates. To test this functionality,
    open your operating system’s Command Prompt and run the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet** CLI 工具也有模板的概念。为了测试这个功能，打开您的操作系统命令提示符，并运行以下命令：'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After running the preceding command, the current version of the tool will be
    displayed. This time, still at the prompt, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，将显示当前工具的版本。这次，仍然在提示符下，运行以下命令：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After running the preceding command, you will see the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，您将看到以下内容：
- en: '![Figure 2.2 – dotnet CLI tool templates](img/B21788_02_2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – dotnet CLI 工具模板](img/B21788_02_2.jpg)'
- en: Figure 2.2 – dotnet CLI tool templates
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – dotnet CLI 工具模板
- en: 'As can be seen in *Figure 2* *.2* , some templates and examples of use were
    listed. Each model has a set of parameters that are used to customize project
    creation. If you want to know more about the parameters of each template, just
    type the following command; for example, for the **webapp** template, you’d type
    this command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 2.2* 所示，列出了一些模板和用法示例。每个模型都有一组参数，用于自定义项目创建。如果您想了解更多关于每个模板的参数，只需键入以下命令；例如，对于
    **webapp** 模板，您将键入此命令：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **-h** (help) parameter will provide a list of parameters and documentation
    for the desired template.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**-h**（帮助）参数将提供所需模板的参数列表和文档。'
- en: 'Depending on the installation on your machine, there may be other templates.
    Run the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的机器上的安装情况，可能会有其他模板。运行以下命令：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see a list containing many types of project templates; we will focus
    on the projects highlighted in *Figure 2* *.3* :'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个包含许多类型项目模板的列表；我们将关注 *图 2.3* 中突出显示的项目：
- en: '![Figure 2.3 – All available project templates](img/B21788_02_3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 所有可用的项目模板](img/B21788_02_3.jpg)'
- en: Figure 2.3 – All available project templates
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 所有可用的项目模板
- en: 'Now that we’ve understood templates, let’s finally create a new Razor Pages
    project via the command line. To do this, open Command Prompt, create a new folder
    called **NewRazorPages** , and run the following command on this folder:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模板，让我们最终通过命令行创建一个新的 Razor Pages 项目。为此，打开命令提示符，创建一个名为 **NewRazorPages**
    的新文件夹，并在该文件夹上运行以下命令：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous command is composed of the **new** command, to create a new project,
    then **razor** , representing the short name of the desired template, and finally
    the **-n** parameter, which defines the name of the project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令由 **new** 命令组成，用于创建新项目，然后是 **razor**，代表所需模板的简称，最后是 **-n** 参数，它定义了项目的名称。
- en: After executing the command, a new folder containing the project will be created.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，将创建一个包含项目的新的文件夹。
- en: Command details
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 命令详情
- en: Each of the commands available in the CLI tool can have a set of parameters.
    To find out more about these parameters, simply add the **-h** option after a
    command; for example, **dotnet** **new -h** .
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 工具中可用的每个命令都可以有一组参数。要了解更多关于这些参数的信息，只需在命令后添加 **-h** 选项；例如，**dotnet new -h**
    。
- en: 'You can also consult the tool’s documentation at the following link: [https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在以下链接中查阅工具的文档：[https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet)
- en: For the rest of the book, we will consider creating projects via the command
    line. Now, let’s go into more detail about the Razor Pages project we’ve created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的其余部分，我们将考虑通过命令行创建项目。现在，让我们更详细地了解我们创建的 Razor Pages 项目。
- en: Understanding the Razor Pages project
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Razor Pages 项目
- en: The Razor Pages project has a very simple directory structure and configurations
    compared to ASP.NET Core MVC. However, many of the concepts used in this project
    serve as a basis for the MVC project, so we’ll take advantage of all the content.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ASP.NET Core MVC 相比，Razor Pages 项目的目录结构和配置非常简单。然而，在此项目中使用的许多概念都是 MVC 项目的基石，因此我们将充分利用所有内容。
- en: '*Figure 2* *.4* shows the structure of the project created in the previous
    section and has been expanded to express each important item that we will discuss
    in more detail:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2* *.4* 展示了上一节创建的项目结构，并已扩展以表达我们将更详细讨论的每个重要项： '
- en: '![Figure 2.4 – Razor Pages project structure](img/B21788_02_4.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – Razor Pages 项目结构](img/B21788_02_4.jpg)'
- en: Figure 2.4 – Razor Pages project structure
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Razor Pages 项目结构
- en: 'Razor Pages has a simple structure that can basically be divided into four
    important items:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 具有简单的结构，基本上可以划分为四个重要项：
- en: '**wwwroot folder** : This folder contains the application’s static files, such
    as JavaScript, CSS, libraries, and images. By default, three subdirectories are
    configured, such as **css** , **js** , and **lib** , used to contain JavaScript
    files from external libraries, such as jQuery, among others. You can also create
    other directories to contain files such as images, fonts, and so on.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wwwroot 文件夹**：此文件夹包含应用程序的静态文件，例如 JavaScript、CSS、库和图像。默认情况下，配置了三个子目录，例如 **css**、**js**
    和 **lib**，用于包含来自外部库的 JavaScript 文件，例如 jQuery 等。您还可以创建其他目录以包含图像、字体等文件。'
- en: '**Pages folder** : This folder contains the application’s pages, subdivided
    into a pair of files with the **cshtml** extension that contain the HTML code
    and C# code using Razor syntax, and **cshtml.cs** , which contains the C# code
    responsible for handling page events.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pages 文件夹**：此文件夹包含应用程序的页面，细分为具有 **cshtml** 扩展名的成对文件，其中包含使用 Razor 语法编写的 HTML
    代码和 C# 代码，以及 **cshtml.cs**，其中包含负责处理页面事件的 C# 代码。'
- en: '**appsettings.json** : This is a file in **JSON** format that is used to maintain
    application settings centrally, as well as database connection strings, API keys,
    and other parameters. We’ll talk more about settings in [*Chapter 9*](B21788_09.xhtml#_idTextAnchor146)
    .'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**appsettings.json**：这是一个 JSON 格式的文件，用于集中维护应用程序设置，以及数据库连接字符串、API 密钥和其他参数。我们将在
    [*第 9 章*](B21788_09.xhtml#_idTextAnchor146) 中更多地讨论设置。'
- en: '**Program.cs** : This is the most important file in the Razor Pages project,
    written in C# and containing all the execution settings for the entire application
    flow.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Program.cs**：这是 Razor Pages 项目中最重要的文件，用 C# 编写，包含整个应用程序流程的所有执行设置。'
- en: Some other details and configurations related to the project will be seen in
    the other chapters of the book as we add more features and concepts to the learning
    process. For now, it’s very important to understand some of the project’s premises.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在学习过程中添加更多功能和概念，有关项目的其他一些细节和配置将在本书的其他章节中看到。目前，理解项目的一些前提条件非常重要。
- en: 'Let’s look at the **Program.cs** file to understand some details:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看 **Program.cs** 文件以了解一些细节：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following points explain the preceding code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点解释了前面的代码：
- en: The first line of the file creates an instance of an ASP.NET Core web application,
    using some standard configurations, such as adding middleware, between *lines
    9* and *13* , that acts on the application flow and convention configurations
    for generating routes, among other aspects provided by the framework itself.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的第一行创建了一个 ASP.NET Core Web 应用程序的实例，使用一些标准配置，例如在 *第 9* 行和 *第 13* 行之间添加中间件，这些中间件作用于应用程序流程和由框架本身提供的生成路由等约定配置。
- en: Next, we have the execution of the **builder.services.AddRazorPages** line,
    which is responsible for configuring the web application with the characteristics
    of the Razor Pages project. This project has dependencies on certain classes that
    are used by the platform when running the application.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有执行 **builder.services.AddRazorPages** 行，该行负责配置具有 Razor Pages 项目特性的 Web
    应用程序。此项目依赖于平台在运行应用程序时使用的某些类。
- en: Between *lines 4* and *8* , there is a check related to the environment in which
    the application is running. This block ensures that if there are any errors not
    dealt with by the application, the user will be redirected to a generic error
    page, preventing details of the application from being exposed. The **app.UseHsts()**
    code aims to force communication via the **HTTP Strict Transport Security** (
    **HSTS** ) protocol to add security and the use of HTTPS.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 4 行* 和 *第 8 行* 之间，有一个与应用程序运行环境相关的检查。此代码块确保如果应用程序未处理任何错误，用户将被重定向到通用错误页面，防止应用程序的详细信息被暴露。**app.UseHsts()**
    代码旨在强制通过 **HTTP Strict Transport Security** ( **HSTS** ) 协议进行通信，以增加安全性和 HTTPS
    的使用。
- en: On *line 9* , we guarantee the use of the HTTPS protocol.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 9 行* ，我们确保使用 HTTPS 协议。
- en: '*Line 10* is necessary for the Razor Pages application to take into account
    static files, localization, and the use of HTTPS.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 10 行* 对于 Razor Pages 应用程序考虑静态文件、本地化和 HTTPS 的使用是必要的。'
- en: It is important to consider, at this point, that the code described in the **Program.cs**
    file will affect how the application will behave at runtime. We must also consider
    the order of each of the methods located in the file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，考虑 **Program.cs** 文件中描述的代码将影响应用程序的运行行为是很重要的。我们还必须考虑文件中每个方法的顺序。
- en: Further details and configuration variations will be discussed later in the
    book. We are already familiar with the Razor Pages project structure, so let’s
    learn more about the syntax used in HTML pages and how to interact with C# code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的细节和配置变体将在本书的后面部分讨论。我们已经熟悉了 Razor Pages 项目结构，因此让我们更多地了解 HTML 页面中使用的语法以及如何与
    C# 代码交互。
- en: Working with pages
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与页面一起工作
- en: Razor acts as a powerful templating engine, allowing you to create pages using
    HTML, CSS, JavaScript, and C# code in the same file. This approach brings great
    flexibility in generating dynamic pages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 充当一个强大的模板引擎，允许你使用 HTML、CSS、JavaScript 和 C# 代码在同一文件中创建页面。这种方法在生成动态页面时提供了极大的灵活性。
- en: 'Let’s look at an example of the **Index.html** page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 **Index.html** 页面的一个示例：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first lines of code refer to page-related settings, and then we have the
    pure HTML code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行涉及页面相关设置，然后是纯 HTML 代码。
- en: 'Let’s understand the main components described in the file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解文件中描述的主要组件：
- en: The **@page** directive must be the first directive in a Razor page view. It
    indicates that the page will function as an action handler.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@page** 指令必须是 Razor 页面视图中的第一个指令。它表示该页面将作为动作处理程序。'
- en: The **@model** directive indicates which type of model will be passed to the
    page. Razor Pages has a set of two files that make up a page, **.cshtml** and
    **.cshtml.cs** .
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@model** 指令表示将传递给页面的模型类型。Razor Pages 由两个文件组成，**.cshtml** 和 **.cshtml.cs**
    。'
- en: The **ViewData["Title"]** code is a dictionary, which represents another way
    of passing data to pages. In general, **ViewData** is used to pass small amounts
    of data. In the case of the preceding code, **ViewData** is being used to pass
    information from the page title to the HTML template.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**ViewData["Title"]** 代码是一个字典，它代表将数据传递给页面的另一种方式。通常，**ViewData** 用于传递少量数据。在前面代码的情况下，**ViewData**
    正在被用来将页面标题的信息传递到 HTML 模板中。'
- en: The first concerns HTML; as with the previous example, **.cshtml.cs** refers
    to the C# code of the page handler, which contains the model or information that
    will be used on the page. Thus, the **Index.cshtml** file has an association with
    the **index.cshtml.cs** file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分涉及 HTML；与前面的示例一样，**.cshtml.cs** 指的是页面处理程序的 C# 代码，其中包含将在页面上使用的数据或信息。因此，**Index.cshtml**
    文件与 **index.cshtml.cs** 文件相关联。
- en: 'In the following code, we have the **IndexModel** class that represents the
    model that will be used on the page:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有 **IndexModel** 类，它表示将在页面上使用的模型：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we noted in the example, the **Index.cshtml** page does not have the entire
    structure of an HTML page. This is because Razor Pages allows the concept of Layout.
    That is, pages can often share a similar structure. This way, we can reuse the
    code to both generate common Layouts and create shared View blocks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中提到的，**Index.cshtml** 页面没有完整的 HTML 页面结构。这是因为 Razor Pages 允许布局的概念。也就是说，页面通常可以共享相似的结构。这样，我们可以重用代码来生成常见的布局和创建共享的视图块。
- en: 'In the project structure, Layouts are kept within the **Pages/Shared** folder.
    By convention, shared views start with an underscore. The **_Layout.cshtml** file
    has a common HTML structure and, in addition, a special directive, **@RenderBody()**
    :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目结构中，布局保存在**Pages/Shared**文件夹中。根据惯例，共享视图以下划线开头。**_Layout.cshtml**文件具有常见的HTML结构，并且还有一个特殊指令**@RenderBody()**：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The **RenderBody()** method specifies the location where views will be rendered
    after server processing. In the case of the **index.cshtml** page, all HTML will
    be rendered between the main tags, in the **_Layout.cshtml** file. Also, note
    the use of **ViewData["Title"]** , which will display the value set on a page,
    as done in the **index.cshtml** file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**RenderBody()**方法指定了在服务器处理之后视图将被渲染的位置。在**index.cshtml**页面的情况下，所有HTML都将渲染在主标签之间，在**_Layout.cshtml**文件中。此外，请注意**ViewData["Title"]**的使用，它将显示在页面上设置的值，如**index.cshtml**文件中所示。'
- en: 'There are two other special files that, by convention, should be located in
    the **Pages** folder:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个其他特殊文件，根据惯例，应位于**Pages**文件夹中：
- en: '**_ViewStart.cshtml** : This is a file that allows us to define code that must
    be executed before displaying each Views. In this case, this file has a code where
    it defines which Layout file will be used for Views.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**_ViewStart.cshtml**：这是一个允许我们在显示每个视图之前执行代码的文件。在这种情况下，此文件包含定义将用于视图的布局文件的代码。'
- en: '**_ViewImports.cshtml** : This file is used to define the namespace and import
    features into the page, in a common way. This way, there is no need to declare
    namespaces and other features on each page.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**_ViewImports.cshtml**：此文件用于定义命名空间并将功能导入页面，以通用方式。这样，就不需要在每个页面上声明命名空间和其他功能。'
- en: Now that we understand the entire project structure and how Razor pages are
    managed in the project, let’s add some customizations to the **Index** page and
    the **IndexModel** model and learn how to use Razor syntax and interact with C#
    code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了整个项目结构以及如何在项目中管理Razor页面，让我们对**Index**页面和**IndexModel**模型进行一些自定义设置，并学习如何使用Razor语法与C#代码交互。
- en: Interacting with the Razor syntax and C# model
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Razor语法和C#模型交互
- en: As explained previously, Razor pages have two files, one responsible for rendering
    the UI and the other responsible for containing the page’s business logic. Furthermore,
    there is the possibility of using C# code together with HTML, meaning that the
    page can be generated during processing time on the server, according to user
    interactions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Razor页面有两个文件，一个负责渲染UI，另一个负责包含页面的业务逻辑。此外，还有使用C#代码与HTML结合的可能性，这意味着页面可以在服务器处理时根据用户交互生成。
- en: 'We will make some changes to the **index.cshtml** file, adding some controls
    as shown in *Figure 2* *.5* :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对**index.cshtml**文件进行一些更改，添加一些如图*图2.5*所示的控件：
- en: '![Figure 2.5 – Customizing the index.cshtml file using Razor syntax](img/B21788_02_5.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 使用Razor语法自定义index.cshtml文件](img/B21788_02_5.jpg)'
- en: Figure 2.5 – Customizing the index.cshtml file using Razor syntax
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 使用Razor语法自定义index.cshtml文件
- en: 'Open the **index.cshtml** file in Visual Studio or Visual Studio Code to make
    the changes and follow these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio或Visual Studio Code中打开**index.cshtml**文件进行更改，并按照以下步骤操作：
- en: 'Between the **@{}** instance, add the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**@{}**实例之间添加以下代码：
- en: '[PRE9]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, change all the content between the **div** tags, which contain the page
    content, to the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将**div**标签之间的所有内容全部更改，这些标签包含页面内容，更改后的代码如下：
- en: '[PRE10]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code creates formatting for the **Price** property so that it
    is displayed in currency format. This formatting will take into account your browser’s
    regional settings. In the case of the example run in this book, the formatting
    will display the price in **en-US** culture format.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码为**Price**属性创建格式，以便以货币格式显示。此格式将考虑您的浏览器区域设置。在本书中运行的示例中，格式将显示**en-US**文化格式。
- en: 'To ensure that the property is displayed in a specific format, a new property
    can be created:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保属性以特定格式显示，可以创建一个新的属性：
- en: '[PRE11]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This way, we can update the existing code for price display to the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，我们可以更新现有代码以显示价格，如下所示：
- en: '[PRE12]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, we can define the application culture globally, avoiding the need
    to create a new property. To make this change, add the following code to the **Program.cs**
    file below the **var app =** **builder.Build()** line:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们可以全局定义应用程序文化，避免创建新属性的需求。为了进行此更改，请将以下代码添加到位于**var app = builder.Build()**行下面的**Program.cs**文件中：
- en: '[PRE13]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For more information about managing cultures in ASP.NET Core 9, see the following
    link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在 ASP.NET Core 9 中管理文化的更多信息，请参阅以下链接：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0)
- en: Some elements that use inline C# code have been added, in addition to some calls
    to the server code. At the moment, it is important to understand how Razor syntax
    can be used together with HTML. Let’s understand all the elements added to the
    UI and how they interact with C#.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对服务器代码的一些调用外，还添加了一些使用内联 C# 代码的元素。目前，理解如何将 Razor 语法与 HTML 一起使用非常重要。让我们了解添加到
    UI 中的所有元素以及它们如何与 C# 交互。
- en: The first snippet added on *line 5* , **string subtitle = "It's funny"** , is
    C# code, declaring a variable of type **string** .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 行添加的第一个片段是 C# 代码，声明了一个 **string** 类型的变量 **subtitle = "It's funny"**。
- en: Note that all the code is enclosed between **@{ and }** symbols, as per the
    example between *lines 3* and *6* of the **index.cshtml** file. This syntax allows
    the addition of a block of code capable of containing C# and HTML instructions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有代码都包含在 **@{** 和 **}** 符号之间，如 **index.cshtml** 文件中的第 3 行到第 6 行的示例所示。此语法允许添加一个能够包含
    C# 和 HTML 指令的代码块。
- en: Combining C# and HTML code and a block
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 C# 和 HTML 代码和代码块
- en: 'Within a C# code block, it is also possible to add HTML tags. Using this strategy
    brings great advantages, such as determining what type of HTML tag will be rendered,
    according to an **if** statement, as in the following example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 代码块中，也可以添加 HTML 标签。使用这种策略可以带来很大的优势，例如，根据 **if** 语句确定将渲染哪种类型的 HTML 标签，如下例所示：
- en: '**@{**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**@{**'
- en: '**if (total >** **0)**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**if (total > 0)**'
- en: '**{**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**<h1>The available amount** **is: @total</h1>**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**<h1>可用的数量是：@total</h1>**'
- en: '**}**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**else**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**else**'
- en: '**{**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**<h2>There is no** **amount available</h2>**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**<h2>没有可用的数量</h2>**'
- en: '**}**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**}**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: 'In addition to the code block, the use of the **@** symbol allows the addition
    of C# code in one line, as in the example of the preceding code, which will display
    the value of the **Message** property of the **Model** object and display the
    value of the **subtitle** variable, previously defined:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码块之外，使用 **@** 符号还可以在单行中添加 C# 代码，如前述代码示例所示，这将显示 **Model** 对象的 **Message**
    属性的值以及显示之前定义的 **subtitle** 变量的值：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Razor Pages provides directives, which are features added to HTML tags. The
    following code adds two anchors to the page:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 提供了指令，这些是添加到 HTML 标签中的功能。以下代码向页面添加了两个锚点：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that there are two attributes, **asp-page-handler** and **asp-route-id**
    . These are directive Razor pages, which determine, respectively, the name of
    the event handler when the link is clicked and the value that will be sent as
    a parameter to the handler.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两个属性，**asp-page-handler** 和 **asp-route-id**。这些是指令 Razor 页面，分别确定当点击链接时的事件处理器的名称以及将作为参数发送给处理器的值。
- en: Also, note that the **div** style has the **@Model.Color** code, inserted as
    the value of the **background-color** property. The color of the **div** tag will
    be set dynamically, according to the link.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，**div** 样式具有 **@Model.Color** 代码，作为 **background-color** 属性的值插入。**div**
    标签的颜色将根据链接动态设置。
- en: For the rest of the controls created on the page, we have a purely HTML form
    and a table that lists randomly generated products. The form does not have the
    **action** attribute, used to determine the page or script that will process the
    posting of data. This attribute was omitted because Razor Pages follows a convention,
    which in this case is to infer the action to the form page itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于页面上创建的其他控件，我们有一个纯 HTML 表单和一个列出随机生成产品的表格。该表单没有 **action** 属性，用于确定处理数据提交的页面或脚本。此属性被省略，因为
    Razor Pages 遵循一种约定，在这种情况下是推断表单页本身作为操作。
- en: 'The following code generates the rows and columns of the product table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成了乘法表的行和列：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is a mix of HTML and C# code. After executing the **foreach**
    statement, the columns and rows of the product table are defined. Products are
    generated in the **Products** property of the **Model** object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是 HTML 和 C# 代码的混合体。在执行 **foreach** 语句后，定义了乘法表的列和行。产品在 **Model** 对象的 **Products**
    属性中生成。
- en: Remember to separate responsibilities
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记得要分离职责
- en: As we can see, it is possible to add any C# code to an HTML page using Razor
    Pages. However, use this approach to manipulate UI elements, but it is important
    to separate responsibilities correctly, avoiding multiple implementations of business
    rules together with UI manipulation rules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 Razor Pages 可以在 HTML 页面中添加任何 C# 代码。然而，使用这种方法来操作 UI 元素，但正确地分离责任很重要，避免将业务规则和
    UI 操作规则的多重实现混在一起。
- en: All the elements we need at this point have been added, and we now know how
    to add C# code to manipulate our UI. Let’s finalize the **Index** page, adding
    the necessary code for its operation in the **index.cshtml.cs** file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要的所有元素都已添加，我们现在知道如何将 C# 代码添加到我们的 UI 中。让我们完成 **Index** 页面的设置，在 **index.cshtml.cs**
    文件中添加其操作所需的代码。
- en: Working with the page model
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与页面模型一起工作
- en: For the previously created UI to work correctly, we must add some properties
    and methods to the page model. Open the **index.cshtml.cs** file so that we can
    add the necessary functionality.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使之前创建的 UI 正确工作，我们必须向页面模型添加一些属性和方法。打开 **index.cshtml.cs** 文件，以便我们可以添加必要的功能。
- en: The **Index** page model is, in fact, a C# class that has an inheritance from
    the **PageModel** class, which is an abstraction of several properties and methods
    used by models in Razor Pages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**Index** 页面模型实际上是一个继承自 **PageModel** 类的 C# 类，它是 Razor Pages 中模型使用的多个属性和方法的抽象。'
- en: 'Let’s make changes to the **IndexModel** class and understand each piece of
    code added:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 **IndexModel** 类进行修改，并理解添加的每一行代码：
- en: 'Add a **Message** property to the **Index.cshtml.cs** file. It will be used
    to define a message that will be displayed in the UI:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Index.cshtml.cs** 文件中添加一个 **Message** 属性。它将用于定义将在 UI 中显示的消息：
- en: '[PRE17]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the project root, create a folder named **Models** and then add a class
    called **Product.cs** . This class must have the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下，创建一个名为 **Models** 的文件夹，然后添加一个名为 **Product.cs** 的类。这个类必须包含以下代码：
- en: '[PRE18]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Go back to the **Index.cshtml.cs** file and add a **Products** property that
    will contain a list of objects that will be listed in the table created in the
    UI previously:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **Index.cshtml.cs** 文件，并添加一个 **Products** 属性，该属性将包含一个列表，该列表将列在之前在 UI 中创建的表中：
- en: '[PRE19]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, add a **Color** property:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加一个 **Color** 属性：
- en: '[PRE20]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The basic properties have been created. Now, let’s create a method that randomly
    generates a list of products. Add the **GenerateProduct** method as per the following
    code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本属性已经创建。现在，让我们创建一个随机生成产品列表的方法。按照以下代码添加 **GenerateProduct** 方法：
- en: '[PRE21]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will change the class constructor and add default values for the **Products**
    and **Message** properties. This way, as soon as the page is displayed, we will
    have a randomly generated list of products and an **I’m using the Razor** **Syntax**
    message:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将更改类构造函数，并为 **Products** 和 **Message** 属性添加默认值。这样，一旦页面显示，我们就会有一个随机生成的产品列表和一个
    **我正在使用 Razor** **语法** 消息：
- en: '[PRE22]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The method that generates the products is being used in the constructor to
    generate an initial listing. However, we want to interact through the UI and generate
    a list based on a value that will be entered in the form. To do this, we will
    create an **OnPost** method. This method generates a new list, based on the quantity
    entered in the UI form:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成产品的那个方法在构造函数中被用来生成一个初始列表。然而，我们希望通过 UI 交互并基于在表单中输入的值生成一个列表。为此，我们将创建一个 **OnPost**
    方法。此方法基于在 UI 表单中输入的数量生成一个新的列表：
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, let’s define a last method that will be responsible for setting the
    value of the **Color** property:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们定义一个负责设置 **Color** 属性值的方法：
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our model is ready to interact with the UI. But before running the application,
    let’s understand a simple concept of Razor Pages convention.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式已经准备好与 UI 交互。但在运行应用程序之前，让我们了解 Razor Pages 规范的一个简单概念。
- en: The **OnPost** method has this name, following a convention, and is related
    to the **GET** , **POST** , **DELETE** , and **PUT** HTTP verbs. This way, by
    defining methods such as **OnGet** , **OnPost** , **OnDelete** , and **OnPut**
    , they will be able to handle page events, according to the HTTP verb. The **Index**
    page UI has a form with the **POST** method. Therefore, when clicking on the **Load
    Products** button, Razor Pages will automatically call the **OnPost** method on
    the **IndexModel** model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**OnPost**方法使用这个名字，遵循约定，并且与**GET**、**POST**、**DELETE**和**PUT** HTTP动词相关。这样，通过定义**OnGet**、**OnPost**、**OnDelete**和**OnPut**等方法，它们将能够根据HTTP动词处理页面事件。**Index**页面的UI有一个使用**POST**方法的表单。因此，当点击**加载产品**按钮时，Razor
    Pages将自动调用**IndexModel**模型上的**OnPost**方法。'
- en: 'The **OnGetDefineColor** method has this name to follow the convention, but
    there is no obligation to use the **OnGet** prefix in the method name. In HTML,
    we do not define the link handler as **OnGetDefineColor** ; this is because, by
    convention, Razor Pages will infer the prefix from the method name, and also because
    a **GET** request is performed. But if you wish to provide your full name, there
    will be no problem. The **OnGetDefineColor** method has another important characteristic:
    its **id** parameter. The **id** parameter receives the value defined in the directive
    added in the HTML link, as shown in the following code example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**OnGetDefineColor**方法使用这个名字是为了遵循约定，但方法名称中并不强制使用**OnGet**前缀。在HTML中，我们不会将链接处理程序定义为**OnGetDefineColor**；这是因为，按照约定，Razor
    Pages会从方法名称中推断前缀，也因为执行了一个**GET**请求。但如果你想提供完整的名称，则不会有问题。**OnGetDefineColor**方法还有一个重要的特性：它的**id**参数。**id**参数接收在HTML链接中添加的指令中定义的值，如下面的代码示例所示：'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This action is called binding, which means that when passing the **id** parameter,
    Razor Pages sets the values of the method arguments according to the name of each
    parameter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作被称为绑定，这意味着当传递**id**参数时，Razor Pages会根据每个参数的名称设置方法参数的值。
- en: Directive tip
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 指令提示
- en: Passing parameters in the previously defined HTML link is done using the **asp-route**
    directive together with the name of the parameter expected in the method—in this
    case, **id** . This way, the complete directive is defined by **asp-route-id**
    . If there were another argument called **name** , for example, the directive
    would be **asp-route-name** .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前定义的HTML链接中传递参数是通过**asp-route**指令与在方法中期望的参数名称一起完成的——在这种情况下，**id**。这样，完整的指令由**asp-route-id**定义。如果有另一个名为**name**的参数，例如，指令将是**asp-route-name**。
- en: Now that you know the entire implementation of the **Index** page, run the application
    and interact with the controls created previously.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了**Index**页面的整个实现，运行应用程序并交互之前创建的控件。
- en: So far, we have learned how to use Razor Pages to create dynamic pages using
    the server-side approach. With each interaction with the controls created on the
    **Index** page, a call will be made to the server, which will manipulate the information,
    interpret the Razor page code implemented in the UI, and later return an HTML
    output with the result.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用Razor Pages通过服务器端方法创建动态页面。与在**Index**页面上创建的控件每次交互时，都会调用服务器，服务器将操作信息，解释在UI中实现的Razor页面代码，然后返回带有结果的HTML输出。
- en: This approach is quite similar to ASP.NET Core MVC, which we will learn about
    in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们在下一节将要学习的ASP.NET Core MVC非常相似。
- en: ASP.NET Core MVC
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC
- en: ASP.NET Core MVC is also a very powerful server-side framework that implements
    the MVC design pattern. Let’s understand how the MVC design pattern works and
    then learn how to benefit from this approach by creating a new project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC也是一个非常强大的服务器端框架，它实现了MVC设计模式。让我们了解MVC设计模式是如何工作的，然后通过创建一个新项目来学习如何从这个方法中受益。
- en: MVC pattern
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MVC模式
- en: 'MVC is an architectural design pattern that works on the separation of responsibilities
    or context:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一种基于责任或上下文分离的架构设计模式：
- en: '![Figure 2.6 – MVC pattern](img/B21788_02_6.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – MVC模式](img/B21788_02_6.jpg)'
- en: Figure 2.6 – MVC pattern
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – MVC模式
- en: As you can see in *Figure 2* *.6* , the **Controller** acts as an orchestrator,
    responding to user interactions through the **View** , and delegating actions
    to the **Model** , which represents the application state and business rules.
    Subsequently, the Controller returns the result, defining which View will be responsible
    for displaying the UI to the end user.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图2.6*中看到的那样，**控制器**充当协调者，通过**视图**响应用户交互，并将动作委托给**模型**，该模型代表应用程序状态和业务规则。随后，控制器返回结果，定义哪个视图将负责向最终用户显示UI。
- en: The View and the Controller have a dependency on the Model, but the Model is
    agnostic, allowing the separation of responsibilities and the use of good code
    practices, such as the use of unit tests, as there is independence from the visual
    presentation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和控制器依赖于模型，但模型是中立的，允许分离责任并使用良好的代码实践，例如使用单元测试，因为与视觉表示独立。
- en: ASP.NET Core MVC is based on the MVC pattern, adapting the project model and
    conventions. Let’s understand how this pattern is implemented in this type of
    project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC基于MVC模式，适应项目模型和约定。让我们了解这种类型的项目中如何实现此模式。
- en: The ASP.NET Core MVC project structure
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC项目结构
- en: Creating the ASP.NET Core MVC project is very simple, and we use the CLI tool,
    in addition to Visual Studio Code as an editor.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ASP.NET Core MVC项目非常简单，我们除了使用CLI工具外，还使用Visual Studio Code作为编辑器。
- en: 'Follow the next instructions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明进行操作：
- en: Open your operating system’s Command Prompt and access a directory of your choice
    where the project will be created.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的操作系统命令提示符，访问您选择的目录，其中将创建项目。
- en: 'Enter the following command to create the project:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以创建项目：
- en: '[PRE26]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding command uses the **dotnet** CLI tool, where we specify the action
    of creating a new project through the **new** command. Then, we define which type
    of project will be created. In this case, we inform that the template will be
    **mvc** , and a **--name** parameter has been added, whereby we inform the name
    of the project.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令使用了**dotnet** CLI工具，其中我们通过**new**命令指定创建新项目的动作。然后，我们定义要创建的项目类型。在这种情况下，我们通知模板将是**mvc**，并且添加了一个**--name**参数，通过该参数我们通知项目的名称。
- en: 'A folder will be created with the name of the application. Access this folder
    and then open Visual Studio Code by running the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个与应用程序名称相同的文件夹。访问此文件夹，然后通过运行以下命令打开Visual Studio Code：
- en: '[PRE27]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding command will open up the following:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令将打开以下内容：
- en: '![Figure 2.7 – ASP.NET MVC project structure](img/B21788_02_7.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – ASP.NET MVC项目结构](img/B21788_02_7.jpg)'
- en: Figure 2.7 – ASP.NET MVC project structure
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – ASP.NET MVC项目结构
- en: When looking at the structure of the MVC project created, we will notice a similarity
    with Razor Pages.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看创建的MVC项目的结构时，我们会注意到它与Razor Pages的相似性。
- en: 'There are three main project folders:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要项目文件夹：
- en: '**Views** : It has the same characteristics as the **Pages** folder in Razor
    Pages; that is, it is the application’s UI. It has **.cshtml** files, and these
    are organized into subfolders that represent a page and contain all the UIs that
    can be used as responses to actions. However, there are no **.** **cshtml.cs**
    files.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：它具有与Razor Pages中的**页面**文件夹相同的特性；即它是应用程序的UI。它包含**.cshtml**文件，并且这些文件组织成子文件夹，代表一个页面，并包含所有可以作为对动作的响应使用的UI。然而，没有**.**
    **cshtml.cs**文件。'
- en: '**Controller** : The controller has a similar role to the class defined in
    the Razor Pages **.cshtml.cs** file. As mentioned, it is an orchestrator that
    has methods to manipulate events executed in Views. In MVC, each controller method
    is called **actions** and can return Views, redirections, or even data.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器在Razor Pages中定义的类中具有相似的角色。如前所述，它是一个协调者，具有用于操作在视图中执行的事件的方法。在MVC中，每个控制器方法被称为**动作**，可以返回视图、重定向，甚至数据。'
- en: '**Models** : This folder is used to manage the business classes and models
    that will be used to exchange information between Views and HTML.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：此文件夹用于管理将用于在视图和HTML之间交换信息的业务类和模型。'
- en: This structure follows a convention, which, in a way, facilitates development
    in this approach. However, the platform allows us to make customizations if necessary.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构遵循一种约定，这在某种程度上简化了这种方法的开发。然而，平台允许我们在必要时进行自定义。
- en: The MVC project also presents a small difference in the settings defined in
    the **program.cs** file in relation to Razor Pages. Before executing the **app.Run()**
    line, there is a call to the **app.MapControllerRoute** method. This method is
    responsible for configuring all of the application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 项目在 **program.cs** 文件中定义的设置与 Razor Pages 有一个小差异。在执行 **app.Run()** 行之前，有一个对
    **app.MapControllerRoute** 方法的调用。此方法负责配置整个应用程序。
- en: Routes define what will be accessed and how it should be accessed through application
    requests.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义了将通过应用程序请求访问的内容以及如何访问。
- en: 'As shown in the following code, a default route is configured, called **default**
    , which has the **controller** / **action** / **parameter** pattern. Furthermore,
    the controller and action have a default value, **Home** and **Index** , respectively,
    while the parameter is optional:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，配置了一个默认路由，称为 **default**，它具有 **controller** / **action** / **parameter**
    模式。此外，控制器和动作分别具有默认值 **Home** 和 **Index**，而参数是可选的：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a standard MVC convention and can be easily changed. In this model,
    if access to the application does not have a definition of the controller and
    which action should be executed, then the default controller, **Home** , and the
    **Index** action will be defined as the response to the request.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的 MVC 约定，可以很容易地更改。在这个模型中，如果应用程序的访问没有定义控制器和要执行的操作，则默认控制器 **Home** 和 **Index**
    动作将被定义为对请求的响应。
- en: It is interesting to note that we are referring to Controllers and not pages.
    This is because the MVC pattern allows the Controller to orchestrate the request,
    according to the desired action, and then return a result or a View.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们指的是控制器而不是页面。这是因为 MVC 模式允许控制器根据所需操作来协调请求，然后返回结果或视图。
- en: As we progress through the chapters of the book, we will have other examples
    of using routes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过本书的章节进展，我们将有其他使用路由的示例。
- en: Understanding patterns and conventions
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解模式和约定
- en: The MVC project follows a convention that benefits the file structure presented
    previously.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 项目遵循一个有利于之前提出的文件结构的约定。
- en: As we learned, the Controller acts as an orchestrator between the Model and
    the View. This way, instead of using a concept of pages, there is the idea of
    actions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所学，控制器在模型和视图之间充当协调者。这样，我们不是使用页面的概念，而是有动作的概念。
- en: 'Given the user’s intention or interaction, it triggers an action. This action
    is captured by a Controller, which then performs the processing and returns either
    a value or a View, as shown in *Figure 2* *.8* :'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 给定用户的意图或交互，它将触发一个动作。这个动作被控制器捕获，然后执行处理并返回一个值或视图，如图 *2.8* 所示：
- en: '![Figure 2.8 – MVC request flow](img/B21788_02_8.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – MVC 请求流程](img/B21788_02_8.jpg)'
- en: Figure 2.8 – MVC request flow
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – MVC 请求流程
- en: The **Controller** class is a C# class, which has attributes and methods. The
    **Controller** class’s public methods are called actions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**Controller** 类是一个 C# 类，它具有属性和方法。**Controller** 类的公共方法被称为动作。'
- en: 'Imagine a registry of people. We would then have the following class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个人物注册表。那么，我们就会有以下类：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The **PersonController** class follows the name convention, adopting the **Controller**
    suffix at the end of the class name. Furthermore, this class has an inheritance
    from the **Controller** class, which is a base class that already has some utility
    methods responsible for processing and returning data and information through
    the controller.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**PersonController** 类遵循命名约定，在类名末尾采用 **Controller** 后缀。此外，这个类从 **Controller**
    类继承，这是一个基类，它已经包含了一些负责通过控制器处理和返回数据和信息的方法。'
- en: Next, we have a method called **Index** , which just returns a View, executing
    the **return** **View()** command.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个名为 **Index** 的方法，它仅仅返回一个视图，执行 **return View()** 命令。
- en: Which View is returned?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 返回哪个视图？
- en: 'The **View()** method takes into account the Asp.NET Core MVC convention. So,
    when executed, the view that is instantiated considers the following path: **/Views/<ControllerName>/Action.cshtml**
    . This means that in the case of the **PersonController** class, calling the **Index**
    method will return a View: **Views/Person/Index.cshtml** .'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**View()** 方法考虑了 Asp.NET Core MVC 的约定。因此，当执行时，实例化的视图会考虑以下路径：**/Views/<ControllerName>/Action.cshtml**。这意味着在
    **PersonController** 类的情况下，调用 **Index** 方法将返回一个视图：**Views/Person/Index.cshtml**。'
- en: The **View()** method has other overloads, making it possible to pass an object
    that will be used as a Model into the View or even define a Controller View that
    should be displayed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**View()** 方法有其他重载，使得可以将一个对象传递给视图作为模型，甚至可以定义一个应显示的控制器视图。'
- en: 'The **GetPeople()** method just returns a list of people in JSON format, as
    shown in *Figure 2* *.9* :'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetPeople()** 方法仅返回一个人员列表的 JSON 格式，如图 *图 2.9* 所示：'
- en: '![Figure 2.9 – JSON with a list of people](img/B21788_02_9.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 包含人员列表的 JSON](img/B21788_02_9.jpg)'
- en: Figure 2.9 – JSON with a list of people
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 包含人员列表的 JSON
- en: 'The **Register()** method processes the form request and returns an object
    to the **Result** View. However, in this case, it is making the call to an action
    from the **PersonController** controller, executing the **RedirectToAction** method,
    called **Result** , which expects a string as a parameter. *Figure 2* *.10* demonstrates
    the display of the action result after registering a person:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**Register()** 方法处理表单请求，并将一个对象返回到 **Result** 视图。然而，在这种情况下，它正在调用 **PersonController**
    控制器中的动作，执行名为 **RedirectToAction** 的方法，该方法期望一个字符串作为参数。*图 2.10* 展示了注册人员后动作结果的显示：'
- en: '![Figure 2.10 – Register Person view](img/B21788_02_10.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 注册人员视图](img/B21788_02_10.jpg)'
- en: Figure 2.10 – Register Person view
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 注册人员视图
- en: Base Controller class
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 基础控制器类
- en: The abstract **Controller** class has some utility methods that allow you to
    work on the communication flow between the Controller and the View.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的 **Controller** 类包含一些实用方法，这些方法允许你在控制器和视图之间进行通信流程的工作。
- en: The **Json()** , **View()** , and **RedirectToAction()** methods are some of
    the resources that are commonly used in a controller class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**Json()**、**View()** 和 **RedirectToAction()** 方法是控制器类中常用的一些资源。'
- en: The MVC model and Razor Pages have similarities, but a big difference is the
    use of actions instead of pages. In this way, the controller has the ability to
    decide what type of View or information should be returned, in relation to some
    user interaction, orchestrating the processing flow.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模型和 Razor Pages 有相似之处，但一个很大的区别是使用动作而不是页面。这样，控制器就有能力根据某些用户交互决定应返回哪种类型的视图或信息，从而协调处理流程。
- en: The Controller responds to user events, and the View is an important aspect
    of this type of project. Based on the **PersonController** example, we will understand
    how the View was created and learn how the interaction with the Controller’s actions
    works in the next section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器响应用户事件，视图是这个类型项目的一个重要方面。基于 **PersonController** 示例，我们将了解视图是如何创建的，并学习在下一节中控制器动作的交互工作原理。
- en: Working with Views on ASP.NET MVC
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 ASP.NET MVC 中与视图一起工作
- en: 'The concept of Views in ASP.NET MVC is the same as that used in Razor Pages,
    using the Razor syntax. As we can see in the following code, there is a form tag,
    using Razor directives, defining which Controller and action will process the
    registration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET MVC 中的视图概念与 Razor Pages 中使用的概念相同，使用 Razor 语法。正如我们可以在以下代码中看到的那样，有一个表单标签，使用
    Razor 指令定义了哪个控制器和动作将处理注册：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding file was created in the **Views/Person/Index.cshtml** directory
    structure. Following the convention, for the **PersonController** controller,
    there must be a **Person** folder, a subfolder of Views, which will contain all
    the Views that will be displayed through the **PersonController** controller.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 之前创建的文件位于 **Views/Person/Index.cshtml** 目录结构中。按照惯例，对于 **PersonController** 控制器，必须有一个
    **Person** 文件夹，它是 Views 的一个子文件夹，将包含将通过 **PersonController** 控制器显示的所有视图。
- en: The view index is a good practice
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 视图索引是一个好的实践
- en: It is good practice to have an **Index.cshtml** file and an **Index()** action
    in each controller. Following the route pattern, defined in the **Program.cs**
    file, by default, when an action is not specified, an **Index()** action will
    be executed. In this case, having a View and Action Index will avoid usability
    problems in your application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个控制器中拥有一个 **Index.cshtml** 文件和一个 **Index()** 动作是一个好的实践。按照在 **Program.cs**
    文件中定义的路由模式，默认情况下，如果没有指定动作，将执行一个 **Index()** 动作。在这种情况下，拥有一个视图和动作索引可以避免你的应用程序中出现可用性问题。
- en: To create the labels and inputs used in the form, **tag helpers** were used.
    Tag helpers are Razor Pages methods that basically render HTML. The difference,
    in the preceding code presented, is that there is a connection with the Model.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建表单中使用的标签和输入，使用了 **标签助手**。标签助手是 Razor Pages 方法，基本上用于渲染 HTML。在前面展示的代码中，区别在于与模型存在连接。
- en: In the first line of the **Index.csthml** page, a Model was defined, using the
    **@model MyFirstMVCApp.Models.PersonModel** code. This makes the Model strongly
    typed. By using a tag helper, together with a Lambda expression, we are implementing
    good practice in relation to the MVC binding model.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Index.csthml**页面的第一行中，定义了一个Model，使用**@model MyFirstMVCApp.Models.PersonModel**代码。这使得Model具有强类型。通过使用标签助手和Lambda表达式，我们正在实施与MVC绑定模型相关的好做法。
- en: 'As a result, the HTML generated by tag helpers for the form will have the correct
    names in relation to the model properties, following the flow outlined next:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表单标签助手生成的HTML将具有与模型属性相关的正确名称，遵循以下概述的流程：
- en: The data is the name and date of birth informed in the inputs.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据是输入中提供的信息，包括姓名和出生日期。
- en: The user clicks the **Register** button.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击**注册**按钮。
- en: The ASP.NET framework makes a request to the **Result** action.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET框架向**Result**操作发送了一个请求。
- en: The ASP.NET framework identifies that the **Result** action has a **PersonModel**
    object as a parameter and then creates an instance.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET框架识别出**Result**操作有一个**PersonModel**对象作为参数，然后创建了一个实例。
- en: The ASP.NET framework binds the data posted by the form and sets the values
    in the corresponding properties of the instantiated object.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET框架将表单提交的数据绑定到实例化的对象的相应属性中。
- en: The ASP.NET framework executes the **Result** action.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET框架执行了**Result**操作。
- en: As the bind is done through property names, if any name is typed incorrectly,
    some properties will not have a value.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绑定是通过属性名完成的，如果任何名称输入错误，某些属性将没有值。
- en: The use of the tag helpers approach also helps in other aspects such as attributes
    added to the **Model** class that allow validations, among other aspects. We will
    discuss more about attributes and bind during *Chapters 3* and *5* .
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签助手方法还有助于其他方面，例如添加到**Model**类的属性，允许进行验证等。我们将在第3章和第5章中讨论更多关于属性和绑定。
- en: The MVC pattern provides us with several benefits, especially in more complex
    projects where there is a need to control different business flows and return
    dynamic Views according to the need.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式为我们提供了几个好处，特别是在需要控制不同的业务流程并根据需要返回动态视图的更复杂的项目中。
- en: There are other approaches to working with UIs in ASP.NET Core 9. Let’s learn
    a little more about other options, such as using Blazor and integrations with
    JavaScript frameworks, in the next section.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 9中，处理UI的方法还有其他几种。让我们在下一节中了解更多关于其他选项，例如使用Blazor和与JavaScript框架的集成。
- en: Exploring UI client rendering with Blazor and JavaScript frameworks
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索使用Blazor和JavaScript框架进行UI客户端渲染
- en: ASP.NET Core 9 has several frameworks that provide the creation of UIs with
    high quality and good user experience, using client-side and server-side approaches.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9有几个框架，它们通过客户端和服务器端方法提供高质量的UI创建和良好的用户体验。
- en: We will talk about the newest technology that uses the **WebAssembly** standard,
    called Blazor, which is a powerful and flexible UI framework. However, if you
    are used to JavaScript frameworks, you can also benefit from the . NET platform.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论使用**WebAssembly**标准的新技术，称为Blazor，它是一个强大且灵活的UI框架。然而，如果你习惯了JavaScript框架，你也可以从.NET平台中受益。
- en: Rich UIs with Blazor
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Blazor创建丰富的UI
- en: Just as with Razor Pages and MVC, Blazor offers a **single-page application**
    ( **SPA** ) framework on the .NET platform, running both client-side and server-side,
    using all the power of C#.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Razor Pages和MVC一样，Blazor在.NET平台上提供了一个**单页应用程序**（**SPA**）框架，它既可以在客户端运行，也可以在服务器端运行，利用了C#的所有功能。
- en: Blazor WebAssembly
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor WebAssembly
- en: The client-server version of Blazor runs on the WebAssembly platform, which
    is a compact bytecode with an optimized format, fast to download, and provides
    great performance when running on the client side, creating rich UI experiences.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor的客户端-服务器版本运行在WebAssembly平台上，这是一个紧凑的字节码，具有优化的格式，下载速度快，在客户端运行时提供出色的性能，创造了丰富的UI体验。
- en: As we can see in *Figure 2* *.11* , Blazor is an abstraction of ASP.NET Core
    for WebAssembly. This way, the Blazor code will generate application assemblies,
    which require the .NET runtime for execution, also allowing interaction between
    WebAssembly and the HTML document.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图2* *.11*中看到的那样，Blazor是ASP.NET Core为WebAssembly提供的抽象。这样，Blazor代码将生成应用程序程序集，这些程序集需要.NET运行时来执行，同时也允许WebAssembly与HTML文档之间的交互。
- en: WebAssembly
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly
- en: 'WebAssembly is a web standard, and you can learn more about it at the official
    website: [https://webassembly.org/](https://webassembly.org/)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是一个网络标准，你可以在官方网站上了解更多信息：[https://webassembly.org/](https://webassembly.org/)
- en: '![Figure 2.11 – WebAssembly and Blazor](img/B21788_02_11.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – WebAssembly和Blazor](img/B21788_02_11.jpg)'
- en: Figure 2.11 – WebAssembly and Blazor
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – WebAssembly和Blazor
- en: The WebAssembly platform uses an interoperability model, which allows it to
    interact with all browser APIs, running in a sandbox, providing security against
    malicious actions, and also allowing the execution of . NET code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly平台使用互操作性模型，这使得它可以与所有浏览器API交互，在沙盒中运行，提供对恶意行为的保护，并允许执行.NET代码。
- en: All page code developed is compiled into .NET assemblies. Thus, when accessing
    the page through the browser, both the assemblies and the .NET runtime are downloaded.
    Then, with the support of WebAssembly, the application runs and uses JavaScript
    interop to handle **DOM** ( **Document Object Model** ) manipulation and browser
    API calls.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的页面代码都编译成.NET程序集。因此，当通过浏览器访问页面时，会下载程序集和.NET运行时。然后，在WebAssembly的支持下，应用程序运行并使用JavaScript互操作来处理**DOM**（**文档对象模型**）操作和浏览器API调用。
- en: Blazor is a flexible framework that also allows you to create projects with
    the benefits of server-side processing, offering an excellent client-side experience.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor是一个灵活的框架，还允许你创建具有服务器端处理优势的项目，提供卓越的客户端体验。
- en: Blazor Server
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor服务器
- en: Blazor also allows for a server-side UI rendering approach. However, unlike
    what happens with Razor Pages and MVC, instead of rendering the entire HTML for
    each client request and returning a complete document as a response, Blazor creates
    a graph, which represents the page components, considering properties and state.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor还允许采用服务器端UI渲染方法。然而，与Razor Pages和MVC不同，Blazor不是为每个客户端请求渲染整个HTML并返回完整的文档作为响应，而是创建一个图，该图表示页面组件，考虑属性和状态。
- en: Then, with each interaction, Blazor performs an evaluation of the graph and
    produces a binary representation, which is sent back to the client.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每次交互中，Blazor对图进行评估，并生成二进制表示，将其发送回客户端。
- en: Blazor’s server-side approach uses **SignalR** technology, which allows you
    to update the UI through a direct connection to the server, bringing better usability
    and a rich user experience. We will cover SignalR in [*Chapter 4*](B21788_04.xhtml#_idTextAnchor061)
    .
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor的服务器端方法使用**SignalR**技术，这允许你通过直接连接到服务器来更新UI，带来更好的可用性和丰富的用户体验。我们将在[*第4章*](B21788_04.xhtml#_idTextAnchor061)中介绍SignalR。
- en: Blazor Server brings great benefits in the development of web-based solutions,
    with C# as a common language, bringing security, reliability, and performance.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor服务器在基于Web的解决方案的开发中带来了巨大的好处，以C#作为通用语言，带来了安全性、可靠性和性能。
- en: Let’s understand the development approach using Blazor.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解使用Blazor的开发方法。
- en: Blazor components and structure
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor组件和结构
- en: Just as with some JavaScript frameworks, such as Angular, Blazor works with
    a component structure.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一些JavaScript框架，例如Angular一样，Blazor使用组件结构。
- en: A component is one or more UI elements developed with a specific objective,
    according to the needs of the application. This component can be reused throughout
    the application, enabling separation of responsibilities, reusability, and flexibility.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是根据应用程序的需求，以特定目标开发的一个或多个UI元素。该组件可以在整个应用程序中重用，实现职责分离、可重用性和灵活性。
- en: All Blazor components have the **.razor** extension and use both the Razor syntax
    and all the benefits of C#.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Blazor组件都具有**.razor**扩展名，并使用Razor语法以及C#的所有优点。
- en: 'To create a Blazor project, simply use the **dotnet** CLI, with the following
    command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Blazor项目，只需使用**dotnet** CLI，以下命令：
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Interactivity Render Mode
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式渲染模式
- en: ASP.NET Core 9 introduces the render interactive mode on Blazor Apps. The interactive
    render mode feature enhances the way Blazor apps handle rendering, introducing
    a mode where the server-rendered static HTML is progressively enhanced into a
    fully interactive client-side application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9在Blazor应用程序中引入了渲染交互模式。交互式渲染模式功能增强了Blazor应用程序处理渲染的方式，引入了一种模式，其中服务器渲染的静态HTML逐渐增强为完全交互式的客户端应用程序。
- en: 'The goals of this feature are:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的目的是：
- en: 'Progressive Enhancement: When a Blazor app is initially loaded, the server
    pre-renders the HTML, providing a fully functional page for users to interact
    with immediately. This allows the app to seamlessly transition from this static
    HTML to a fully interactive Blazor app once the Blazor framework is loaded on
    the client side.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强：当Blazor应用最初加载时，服务器预先渲染HTML，为用户提供一个完全可交互的页面，用户可以立即与之交互。这允许应用在客户端加载Blazor框架后，无缝地从静态HTML过渡到完全交互式的Blazor应用。
- en: 'Seamless Transition: ensures the app appears interactive even while the client-side
    Blazor runtime is being initialized and users can start interacting with the app
    before the complete Blazor runtime is ready, making the user experience smoother.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 无缝过渡：确保即使在客户端Blazor运行时初始化期间，应用看起来也是交互式的，并且用户可以在完整的Blazor运行时准备好之前开始与应用交互，使用户体验更加流畅。
- en: 'Improved Performance: optimizes the time-to-interactivity by reducing the noticeable
    delay that users might experience in traditional Blazor Server or Blazor WebAssembly
    apps.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 提升性能：通过减少用户在传统的Blazor Server或Blazor WebAssembly应用中可能体验到的明显延迟，优化了交互时间。
- en: 'Enhanced User Experience: minimizes interruptions or loading indicators during
    transitions, giving users a better perception of speed.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 提升用户体验：在转换过程中最小化中断或加载指示器，使用户对速度有更好的感知。
- en: 'If you create a Blazor app using the command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用以下命令创建Blazor应用：
- en: '**dotnet new blazor --** **name MyFirstBlazorApp**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet new blazor --name MyFirstBlazorApp**'
- en: 'The default interactive mode is Server. In case you want to leverage the new
    feature, use the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的交互模式是服务器。如果你想利用这个新功能，请使用以下命令：
- en: '**dotnet new blazor --name MyFirstBlazorApp --** **interactivity Auto**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet new blazor --name MyFirstBlazorApp --interactivity Auto**'
- en: 'To learn more about this new feature, access the following URL: [https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这个新功能的信息，请访问以下网址：[https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0)
- en: 'After creating the project, just open the **Pages** folder, and you will then
    find some components as shown in *Figure 2* *.12* :'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，只需打开**Pages**文件夹，你将找到一些组件，如图*图2.12*所示：
- en: '![Figure 2.12 – The Blazor project structure](img/B21788_02_12.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – Blazor项目结构](img/B21788_02_12.jpg)'
- en: Figure 2.12 – The Blazor project structure
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – Blazor项目结构
- en: There are components that are defined as pages and therefore have the **@pages**
    directive, where a route to access the page is defined. There are also components
    that are added to pages.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些组件被定义为页面，因此具有**@pages**指令，其中定义了访问页面的路由。也有其他组件被添加到页面中。
- en: 'The **Counter.razor** file is a page component and has the following content:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**Counter.razor**文件是一个页面组件，包含以下内容：'
- en: '[PRE32]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that there is use of Razor and HTML syntax, as we learned in the Razor
    Pages and MVC approaches. There is also C# code between the **@code {}** tags.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里使用了Razor和HTML语法，正如我们在Razor Pages和MVC方法中学到的。在**@code {}**标签之间也有C#代码。
- en: The C# code defined in the preceding file has the functionality to increment
    a counter when the user clicks on the **Click** **me** button.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中定义的C#代码具有在用户点击**点击我**按钮时增加计数器的功能。
- en: The HTML button tag has the **@onclick** attribute, which is defined with the
    name defined in the C# code block.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: HTML按钮标签具有**@onclick**属性，该属性使用在C#代码块中定义的名称。
- en: For simple components, the approach of using HTML and C# code in the same file
    may be valid. However, it is good practice to separate business rules from the
    UI. Therefore, Blazor allows a file to be created containing the component’s C#
    code.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的组件，在同一个文件中使用HTML和C#代码的方法可能是有效的。然而，将业务规则与UI分离是良好的实践。因此，Blazor允许创建一个包含组件C#代码的文件。
- en: 'In the preceding code example, there would be two files: **Counter.razor**
    and **Counter.razor.cs** . All C# code could be moved to the new file generating
    the following class:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，将会有两个文件：**Counter.razor**和**Counter.razor.cs**。所有C#代码都可以移动到新文件中，生成以下类：
- en: '[PRE33]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Blazor is very flexible and offers a huge range of possibilities for developing
    rich web-based applications, integrated with HTML, CSS, and JavaScript and using
    the most modern technologies. It would take an exclusive book to talk about Blazor,
    however; this book will focus on approaches based on Razor Pages and MVC.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 非常灵活，为开发丰富的基于 Web 的应用程序提供了广泛的可能，这些应用程序与 HTML、CSS 和 JavaScript 集成，并使用最现代的技术。然而，关于
    Blazor 的讨论将需要一本专门的书籍；然而，本书将专注于基于 Razor Pages 和 MVC 的方法。
- en: ASP.NET Core 9 is very flexible when it comes to developing UIs, featuring different
    frameworks. But if you are familiar with Angular, React, or Vue.js, you can benefit
    from the power of the . NET platform.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 在开发 UI 方面非常灵活，提供了不同的框架。但如果你熟悉 Angular、React 或 Vue.js，你可以从 .NET
    平台的力量中受益。
- en: ASP.NET Core 9 and JavaScript frameworks
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 和 JavaScript 框架
- en: As we learned during the other topics in this chapter, ASP.NET Core 9 offers
    several approaches to building a UI, interacting with C# code. There are several
    related benefits, including the use of a common development model, using the Razor
    syntax, and all the benefits of the . NET platform.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章其他主题中学到的那样，ASP.NET Core 9 提供了多种构建 UI、与 C# 代码交互的方法。有几个相关的优点，包括使用通用开发模型、使用
    Razor 语法以及 .NET 平台的所有好处。
- en: 'However, if you are used to using a framework for building SPAs, such as Angular,
    Vue.js, and React, the .NET platform has some templates available for this purpose:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你习惯于使用 Angular、Vue.js 或 React 等框架来构建 SPAs，.NET 平台为此目的提供了一些模板：
- en: '![Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template](img/B21788_02_13.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – ASP.NET Core 9 JavaScript 框架模板](img/B21788_02_13.jpg)'
- en: Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – ASP.NET Core 9 JavaScript 框架模板
- en: The **React and ASP.NET Core** template creates two projects, one for the frontend
    and the other for the application’s backend.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**React 和 ASP.NET Core** 模板创建了两个项目，一个用于前端，另一个用于应用程序的后端。'
- en: SPAs use the approach where the UI is developed independently of the backend,
    which is generally an external service or application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPAs）采用一种将 UI 独立于后端开发的方法，后端通常是一个外部服务或应用程序。
- en: 'When using the model offered by ASP.NET Core, there is also a clear separation
    between the UI and the backend. The project is already configured for integration
    with the web API developed in .NET. One of the great benefits of this is the convenience
    of publishing the UI and backend project in a single simple unit, facilitating
    publication:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ASP.NET Core 提供的模型时，UI 和后端之间也有明显的分离。项目已经配置好了与在 .NET 中开发的 Web API 集成的功能。这种做法的一个巨大好处是，可以方便地将
    UI 和后端项目作为一个简单的单元发布，从而简化发布过程：
- en: '![Figure 2.14 – ASP.NET Core React standalone project structure](img/B21788_02_14.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – ASP.NET Core React 独立项目结构](img/B21788_02_14.jpg)'
- en: Figure 2.14 – ASP.NET Core React standalone project structure
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – ASP.NET Core React 独立项目结构
- en: Using project templates for frameworks such as Angular, Vue.js, or React is
    completely optional. Even if the UI project is created independently, we can benefit
    from ASP.NET Core by developing web APIs to serve the UI. We’ll talk about creating
    web APIs in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044) .
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular、Vue.js 或 React 等框架的项目模板完全是可选的。即使 UI 项目是独立创建的，我们也可以通过开发 Web API 来为
    UI 提供服务来受益。我们将在 [*第 3 章*](B21788_03.xhtml#_idTextAnchor044) 中讨论创建 Web API。
- en: As we can see, the platform offers several approaches for developing high-quality
    web-based systems. Each ASP.NET Core UI framework has several benefits that can
    be combined to generate even more powerful solutions, and we will look at these
    solutions in the next section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该平台提供了多种开发高质量基于 Web 系统的方法。每个 ASP.NET Core UI 框架都有一些可以组合起来生成更强大解决方案的好处，我们将在下一节中探讨这些解决方案。
- en: Working with hybrid solutions
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与混合解决方案一起工作
- en: One of the great benefits of working on a powerful platform such as ASP.NET
    Core is having the ability to integrate between technologies. Therefore, we can
    combine all the power of Razor Pages, MVC, and Blazor in the same project.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 ASP.NET Core 这样强大的平台上工作的一大好处是能够集成不同技术。因此，我们可以将 Razor Pages、MVC 和 Blazor 的所有功能结合到同一个项目中。
- en: In the case of integration with Blazor, there is the benefit of using **.razor**
    components, providing reusability.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 Blazor 集成的情况下，使用 **.razor** 组件的好处是可重用性。
- en: 'Blazor integration into Razor Pages or MVC projects must be configured according
    to the following steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Blazor 集成到 Razor Pages 或 MVC 项目中必须按照以下步骤进行配置：
- en: 'In the project root, add a file named **_Imports.razor** . This file will be
    responsible for importing the namespaces necessary for the project:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下，添加一个名为 **_Imports.razor** 的文件。此文件将负责导入项目所需的命名空间：
- en: '[PRE34]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that at the end of the file, there is a **{CHANGE_FOR_THE_NAMESPACE_OF_YOUR_PROJECT}**
    tag. Change this value to your project namespace.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在文件末尾有一个 **{CHANGE_FOR_THE_NAMESPACE_OF_YOUR_PROJECT}** 标签。将此值更改为您的项目命名空间。
- en: 'Now, it will be necessary to change the **_Layout.cshtml** file, located in
    **Pages/Shared** directory in the case of the Razor Pages project or in the **Views/Shared**
    directory for MVC projects. Add the following code in the head element:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，需要更改位于 **Pages/Shared** 目录中的 **_Layout.cshtml** 文件（如果是 Razor Pages 项目）或位于
    **Views/Shared** 目录中的 MVC 项目。在 head 元素中添加以下代码：
- en: '[PRE35]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The purpose of defining **<base href="~/"/>** is to define the base path of
    the application, while the **component** tag is used to render the contents of
    the Razor components in the HTML head element.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义 **<base href="~/"/>** 的目的是定义应用程序的基本路径，而 **component** 标签用于在 HTML 头元素中渲染 Razor
    组件的内容。
- en: 'Add the following script before the **@await RenderSection(...)** render section:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **@await RenderSection(...)** 渲染部分之前添加以下脚本：
- en: '[PRE36]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Don’t worry about the script path, much less creating it. This will be done
    automatically by the framework.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要担心脚本路径，更不用说创建它了。这将由框架自动完成。
- en: 'Now, open the **Program.cs** file to make some modifications. First, we must
    register the Blazor services so that they are available while the application
    is running. Add the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 **Program.cs** 文件进行一些修改。首先，我们必须注册 Blazor 服务，以便在应用程序运行时它们可用。添加以下代码：
- en: '[PRE37]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You also need to add the Blazor route mapping control. Add the following line
    below the **MapRazorPages** call (in the case of a Razor Pages project) or the
    **MapControllerRoute** call (in the case of an MVC project):'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要添加 Blazor 路由映射控制。在 **MapRazorPages** 调用（如果是 Razor Pages 项目）或 **MapControllerRoute**
    调用（如果是 MVC 项目）下方添加以下行：
- en: '[PRE38]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that the project is integrated with Blazor, let’s create a component with
    the following steps:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经与 Blazor 集成，让我们按照以下步骤创建一个组件：
- en: 'Create a file called **technology.razor** in the **Pages/Shared** (Razor Pages)
    or **Views/Shared** (MVC) folder and add the following code:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Pages/Shared**（Razor Pages）或 **Views/Shared**（MVC）文件夹中创建一个名为 **technology.razor**
    的文件，并添加以下代码：
- en: '[PRE39]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code creates a **Load** button with a click event that will load
    a list of technologies. This list of technologies was created in the **@code{}**
    session, using an array of strings. When running the application, the screen will
    be similar to *Figure 2* *.15* :'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码创建了一个具有点击事件的 **Load** 按钮，该事件将加载技术列表。此技术列表是在 **@code{}** 会话中创建的，使用字符串数组。当运行应用程序时，屏幕将类似于
    *图 2.15*：
- en: '![Figure 2.15 – Page/View using the Blazor component](img/B21788_02_15.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 使用 Blazor 组件的页面/视图](img/B21788_02_15.jpg)'
- en: Figure 2.15 – Page/View using the Blazor component
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 使用 Blazor 组件的页面/视图
- en: 'To use this component, add the following code to any MVC Razor page or View:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此组件，将以下代码添加到任何 MVC Razor 页面或视图中：
- en: '[PRE40]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When running the application, simply use the component to obtain the expected
    result, as shown in *Figure 2* *.16* . This component is reusable and can be added
    to any page or view, bringing greater flexibility and power to UI development:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序时，只需使用该组件即可获得预期的结果，如图 *图 2.16* 所示。此组件是可重用的，可以添加到任何页面或视图中，为 UI 开发带来更大的灵活性和功能：
- en: '![Figure 2.16 – Using a Blazor component with Razor Pages and MVC](img/B21788_02_16.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 使用 Blazor 组件与 Razor Pages 和 MVC](img/B21788_02_16.jpg)'
- en: Figure 2.16 – Using a Blazor component with Razor Pages and MVC
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 使用 Blazor 组件与 Razor Pages 和 MVC
- en: Combining ASP.NET Core UI frameworks can bring benefits during the web-based
    application development process, using the best of each approach.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 ASP.NET Core UI 框架可以在基于 Web 的应用程序开发过程中带来好处，利用每种方法的最佳之处。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve delved into the rich world of the ASP.NET Core UI, gaining
    valuable insights into the available tools for crafting dynamic and engaging UIs.
    You’ve not only understood the key concepts and tools required for implementing
    a server-side UI, but you’ve also discovered the remarkable benefits of WebAssembly
    through Blazor, enabling you to create powerful SPAs in conjunction with ASP.NET
    Core. As you wrap up this chapter, you’ve learned how to seamlessly combine ASP.NET
    Core UI solutions. Now, with a solid foundation in place, I invite you to embark
    on the next exciting journey in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044)
    , where we’ll explore the world of web APIs and their pivotal role in delivering
    outstanding services. Get ready to take your skills to the next level!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经深入探索了ASP.NET Core UI的丰富世界，获得了关于构建动态和吸引人的UI可用工具的宝贵见解。你不仅理解了实现服务器端UI所需的关键概念和工具，而且还发现了通过Blazor使用WebAssembly带来的显著好处，使你能够与ASP.NET
    Core结合创建强大的单页应用（SPAs）。随着本章的结束，你已经学会了如何无缝结合ASP.NET Core UI解决方案。现在，在打下坚实基础之后，我邀请你开始下一章的激动人心的旅程[*第3章*](B21788_03.xhtml#_idTextAnchor044)，我们将探讨Web
    API的世界及其在提供卓越服务中的关键作用。准备好将你的技能提升到下一个层次！
