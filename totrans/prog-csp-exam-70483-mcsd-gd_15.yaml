- en: Using LINQ Queries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LINQ 查询
- en: In .NET, we often need to query data from different sources, such as XML, SQL,
    and web services. In earlier versions of .NET, we performed these operations using
    simple strings. The main issue with this approach is that it lacks any IntelliSense
    and is quite cumbersome in implementation. These queries also differ from one
    another as to the source from which we are querying the data, thereby increasing
    the code complexity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，我们经常需要从不同的数据源查询数据，例如 XML、SQL 和 Web 服务。在 .NET 的早期版本中，我们使用简单的字符串执行这些操作。这种方法的主要问题是它缺乏任何智能感知，并且在实现上相当繁琐。这些查询也因查询数据的数据源不同而彼此不同，从而增加了代码的复杂性。
- en: To overcome these issues, LINQ was firstly introduced in .NET 3.5\. Compared
    to conventional data access methods, LINQ introduces an easy and consistent approach
    for the querying and modification of data across different types of data sources
    such as XML and even in-memory data structures such as arrays. In LINQ, we query
    data using a query expression. The query expression enables us to perform filtering,
    ordering, and grouping of operations on the data using minimal code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，LINQ 首次在 .NET 3.5 版本中引入。与传统的数据访问方法相比，LINQ 引入了一种简单且一致的方法，用于查询和修改不同类型的数据源中的数据，例如
    XML，甚至内存中的数据结构，如数组。在 LINQ 中，我们使用查询表达式来查询数据。查询表达式使我们能够使用最少的代码对数据进行过滤、排序和分组操作。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下主题：
- en: Introducing LINQ
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 LINQ
- en: Understanding the language features that make LINQ possible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使 LINQ 成为可能的语言特性
- en: Understanding LINQ query operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 LINQ 查询运算符
- en: Understanding LINQ behind the scenes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 LINQ 的幕后原理
- en: Using LINQ to XML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LINQ 查询 XML
- en: By the end of this chapter, we will have learned how we can use LINQ queries
    while performing operations on an XML file. We will look at how LINQ queries can
    help us write, query, and modify XML files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学习如何在操作 XML 文件时使用 LINQ 查询。我们将探讨 LINQ 查询如何帮助我们编写、查询和修改 XML 文件。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Like in the previous chapters covered in this book, the programs explained in
    this book will be developed in Visual Studio 2017.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中前面章节介绍的内容一样，本书中的程序将在 Visual Studio 2017 中开发。
- en: The sample code for this chapter can be found on GitHub in `Chapter 15` ([https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在 GitHub 的 `Chapter 15` 目录中找到（[https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples))。
- en: Introducing LINQ
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 LINQ
- en: In this section, we will learn the basics of LINQ. We can use LINQ queries against
    any collection of objects, with the only condition being that the object must
    support the `IEnumerable` or generic `IEnumerable<T>` interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 LINQ 的基础知识。我们可以使用 LINQ 查询针对任何对象集合，唯一条件是对象必须支持 `IEnumerable` 或泛型 `IEnumerable<T>`
    接口。
- en: Along with that, the target framework of the project in which we are planning
    to use LINQ must be version 3.5 or more recent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们计划在其中使用 LINQ 的项目的目标框架版本必须是 3.5 或更高版本。
- en: In the next section, we will look at queries, which form the basis of LINQ operations.
    We will be looking at the different components of a query and understand how they
    are constructed in .NET.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨查询，它是 LINQ 操作的基础。我们将研究查询的不同组成部分，并了解它们在 .NET 中的构建方式。
- en: Queries
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询
- en: 'A query is a string expression that retrieves data from a data source. The
    expression is usually related to a particular data source such as SQL or XML and
    will generally be expressed in that respective data source language. However,
    with LINQ, we can develop a reusable coding pattern that works on different data
    sources. The pattern is divided into three parts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是一个字符串表达式，用于从数据源检索数据。该表达式通常与特定的数据源相关，例如 SQL 或 XML，并且通常用该数据源的语言表达。然而，使用 LINQ，我们可以开发一个适用于不同数据源的通用编码模式。该模式分为三个部分：
- en: Obtaining the data source
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据源
- en: Creating the query
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建查询
- en: Executing the query
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行查询
- en: 'The following code that illustrates the three operations in their simplest
    forms:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了三种操作在最简单形式下的示例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code example, we created an array of integers whose size is
    `3`. As it implements the `IEnumerable<int>` interface, we will be able to implement
    LINQ on the array. In the next step, we created a query in which we are filtering
    even numbers present in the array. Finally, in the third step, we are looping
    through the results of the query execution and printing it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个大小为 `3` 的整数数组。由于它实现了 `IEnumerable<int>` 接口，我们将能够在数组上实现 LINQ。在下一步中，我们创建了一个查询，用于过滤数组中存在的偶数。最后，在第三步中，我们正在遍历查询执行的结果并打印它。
- en: 'In the preceding example, we used an array as the source of data. The array
    already supports the `IEnumerable` or `IEnumerable <T>` interface. However, in
    some cases, that may not always be the case. For example, when we read the data
    source from sources such as XML files, we need LINQ to load the data in memory
    as a queryable type. In this case, we can use the `XElement` type. The following
    is the syntax for this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用数组作为数据源。数组已经支持 `IEnumerable` 或 `IEnumerable <T>` 接口。然而，在某些情况下，情况可能并非总是如此。例如，当我们从
    XML 文件等源读取数据源时，我们需要使用 LINQ 将数据加载到内存中作为可查询的类型。在这种情况下，我们可以使用 `XElement` 类型。以下是这个语法的示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code example, we have loaded the data from the XML file in
    the `XElement` object, which implements an `IQuerable` interface. Now, on this,
    we can easily write LINQ queries to execute any operation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们已经将数据从 XML 文件加载到实现了 `IQuerable` 接口的 `XElement` 对象中。现在，基于此，我们可以轻松编写
    LINQ 查询以执行任何操作。
- en: Before we move ahead and understand more around LINQ, we must understand the
    built-in features of C# that help us implement LINQ queries. In the next section,
    we will discuss some of these features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进并了解更多关于 LINQ 的内容之前，我们必须了解 C# 的内置特性，这些特性有助于我们实现 LINQ 查询。在下一节中，我们将讨论这些特性之一。
- en: Understanding language features that make LINQ possible
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使 LINQ 成为可能的语言特性
- en: 'There are several features available in C# that are either necessary for the
    implementation of LINQ or that help us effectively use LINQ queries. These are
    some of the topics that we will be going through in this chapter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中有几个特性对于实现 LINQ 是必要的，或者有助于我们有效地使用 LINQ 查询。这些是我们将在本章中讨论的一些主题：
- en: Implicitly typed variables
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类型变量
- en: Object initialization syntax
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象初始化语法
- en: Lambda expressions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Extension methods
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法
- en: Anonymous types
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类型
- en: Implicitly typed variables
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式类型变量
- en: 'In C#, we generally use statically typed variables. This implies that the compiler
    knows the type of variable at compile time. Due to this, if it finds any operation
    that may result in an error, it will highlight it at compile time. For example,
    refer to the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，我们通常使用静态类型变量。这意味着编译器在编译时知道变量的类型。因此，如果它发现任何可能产生错误的操作，它将在编译时将其突出显示。例如，参考以下代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will observe that the compiler will give us a compile-time error. The following
    is the screenshot this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将观察到编译器会给我们一个编译时错误。以下是这个截图：
- en: '![](img/1375d3c9-6bee-4f03-b32a-5163d2fef34c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1375d3c9-6bee-4f03-b32a-5163d2fef34c.png)'
- en: As illustrated by the error description, the compiler identifies that the operation
    is not supported in terms of the type of the two variables, hence, it throws this
    error. This is referred to as explicit typing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如错误描述所示，编译器确定这两个变量的类型不支持该操作，因此抛出此错误。这被称为显式类型。
- en: Implicit typing was added to C# in version 3.0\. In implicit typing, the compiler
    automatically identifies the variable type at compile time. The compiler does
    this based on the value that is assigned to the variable during declaration. The
    compiler then strongly types the variable to that particular type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型在 C# 3.0 版本中添加。在隐式类型中，编译器在编译时自动识别变量的类型。编译器根据在声明时分配给变量的值来完成此操作。然后，编译器将变量严格类型化为该特定类型。
- en: 'In C#, we use implicit typing by using the `var` keyword. The following shows
    the same code written earlier, albeit with implicit typing:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，我们使用 `var` 关键字进行隐式类型。以下显示了之前编写的相同代码，但使用了隐式类型：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Please note that even though we have not implicitly specified the type of the
    variable as `int`, based upon the value `1` assigned to it, the compiler will
    infer that the type of the variable must be `int`. In this case, it will give
    us the same compile-time error. The following is the screenshot for this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们没有显式指定变量的类型为 `int`，但基于分配给它的值 `1`，编译器会推断出该变量的类型必须是 `int`。在这种情况下，它将给出相同的编译时错误。以下是该截图：
- en: '![](img/4d910edc-fc1f-465c-8703-3c10af12adde.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d910edc-fc1f-465c-8703-3c10af12adde.png)'
- en: Implicit `Type` helps in the LINQ query in circumstances when the return type
    is determined at compile time. In addition to being a mandatory declaration, implicit
    typing also improves code readability. To illustrate this example, refer to the
    following declaration in the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式 `Type` 在返回类型在编译时确定的 LINQ 查询情况下有所帮助。除了是强制声明之外，隐式类型还可以提高代码可读性。为了说明这个例子，请参考代码中的以下声明。
- en: 'Note that, instead of declaring the actual type, we have used the `Type` variable
    in the declaration, hence improving code readability:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在声明中，我们没有声明实际类型，而是使用了 `Type` 变量，从而提高了代码的可读性：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will look at initializers and how they can improve code
    readability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨初始化器以及它们如何提高代码可读性。
- en: Object initialization syntax
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象初始化语法
- en: 'Initializers in C# help us combine the creation of objects and set their properties.
    Let''s refer to the following code example. Let''s assume we have a `Student`
    class that has the following declaration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的初始化器帮助我们结合对象的创建和设置其属性。让我们参考以下代码示例。假设我们有一个 `Student` 类，其声明如下：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, suppose we need to declare an object for this class. In a conventional
    way, without the use of object initializers, we can do it in the following manner:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要为这个类声明一个对象。以传统方式，不使用对象初始化器，我们可以这样做：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that in the preceding code, we have to specify the creation of the `p`
    and `p2` objects and set up their respective properties separately.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们必须分别指定 `p` 和 `p2` 对象的创建和设置它们各自的属性。
- en: 'Using object initialization syntax, we will be able to combine the creation
    of the object and the setting up of its properties in one statement. As an example,
    if we use object initialization to execute the same functionality that we did
    earlier, we can use the following syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象初始化语法，我们可以在一个语句中结合对象的创建和属性的设置。例如，如果我们使用对象初始化来执行之前所做的相同功能，我们可以使用以下语法：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Please note that even though usage of object initialization is not necessary
    and doesn''t provide any additional capability or feature to us, it can improve
    the readability of our code. The code can also be enhanced if there is a requirement
    for creating a collection of the same objects. The following is the syntax for
    this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管对象初始化的使用不是必需的，并且不会为我们提供任何额外的功能或特性，但它可以提高我们代码的可读性。如果需要创建相同对象的集合，代码也可以得到增强。以下是该语法的示例：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that object initialization syntax makes the code much more readable and,
    in cases where we are working with anonymous types, it is actually required. In
    the next section, we will look at lambda expressions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对象初始化语法使代码的可读性大大提高，并且在处理匿名类型的情况下，实际上它是必需的。在下一节中，我们将探讨 lambda 表达式。
- en: Lambda expressions
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Lambda expressions were introduced to C# in 3.0 version. Lambda expressions
    are based upon anonymous functions and a lambda expression is a shorter way to
    represent an anonymous method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式是在 C# 3.0 版本中引入的。Lambda 表达式基于匿名函数，并且 lambda 表达式是表示匿名方法的更简短方式。
- en: In [Chapter 5](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml), *Creating and Implementing
    Events and Callbacks*, in the *Initiate delegate using anonymous functions* section,
    we looked at how we can create anonymous functions in C# using the `delegate`
    keyword. In a nutshell, just to recap, using anonymous methods, we can create
    an inline method in some code, assign it to a variable, and pass it around.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml)的“使用匿名函数初始化委托”部分，我们探讨了如何在
    C# 中使用 `delegate` 关键字创建匿名函数。简而言之，为了回顾，使用匿名方法，我们可以在某些代码中创建内联方法，将其分配给变量，并传递它。
- en: 'In [Chapter 5](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml), *Creating and Implementing
    Events and Callbacks*, in the *Lambda expressions* section, we looked at how we
    can convert an anonymous function into its equivalent lambda expression. However,
    just to recap, let''s go through the following code example, in which we will
    first create an anonymous function and then create a lambda expression for the
    same:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml) 的 *创建和实现事件和回调* 部分，在 *Lambda
    表达式* 节中，我们探讨了如何将匿名函数转换为等效的 lambda 表达式。但是，为了回顾，让我们看一下以下代码示例，其中我们将首先创建一个匿名函数，然后为相同的函数创建一个
    lambda 表达式：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we declared a delegate function of the `Func<T,T>` format.
    This implies that this function takes an input of `int` and returns an integer
    output. Hence, the output for the preceding operation would be *1 * 5*, that is,
    *5*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个 `Func<T,T>` 格式的委托函数。这意味着这个函数接受 `int` 类型的输入并返回一个整数输出。因此，前面操作的结果将是
    *1 * 5*，即 *5*。
- en: 'Now, if we need to write the same code using a lambda expression, we can use
    the following code syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要使用 lambda 表达式编写相同的代码，我们可以使用以下代码语法：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please also note the usage of the `=>` notation in a lambda expression. This
    notation translates into *becomes* or *for which*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在 lambda 表达式中 `=>` 符号的用法。这个符号翻译成“变为”或“对于”。
- en: If we execute the two code blocks, we will notice that the results of the operations
    are the same. However, with lambda expressions, we end up with much cleaner code
    and avoid a lot of code typing. In the next section, we will look at extension
    methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这两个代码块，我们会注意到操作的结果是相同的。然而，使用 lambda 表达式，我们最终得到更干净的代码，并避免了大量的代码输入。在下一节中，我们将探讨扩展方法。
- en: Extension methods
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展方法
- en: Extension methods in C# allow us to add methods to an existing type without
    altering them or using inheritance. The extension methods are defined in the `System.Linq.Enumerables`
    namespace.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的扩展方法允许我们在不修改它们或使用继承的情况下向现有类型添加方法。扩展方法定义在 `System.Linq.Enumerables` 命名空间中。
- en: 'An extension method is always defined in a static class and as a static method.
    Along with that, it also uses the `this` keyword to qualify itself as an extension
    method. The following is a code example in which we have declared an extension
    method multiple on the `int` type. To identify the calling object as the first
    parameter being passed to the function, we have used the `this` keyword:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法始终定义在静态类中，并且作为静态方法。除此之外，它还使用 `this` 关键字来表明它是一个扩展方法。以下是一个代码示例，其中我们在 `int`
    类型上声明了多个扩展方法。为了将调用对象识别为传递给函数的第一个参数，我们使用了 `this` 关键字：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the preceding code is executed, we get the output of `30`, which is the
    output when the calling object, `6`, is multiplied by `5`, which is declared in
    the extension method. In the next section, we will look at anonymous types.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行前面的代码，我们得到 `30` 的输出，这是当调用对象 `6` 乘以在扩展方法中声明的 `5` 时的输出。在下一节中，我们将探讨匿名类型。
- en: Anonymous types
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类型
- en: An anonymous type is a combination of both object initializers and implicit
    typing. An anonymous type is a type that doesn't have a name. Using anonymous
    types, using the `var` and `new` keyword, we create an object without defining
    its type or class. The type of anonymous type variable is inferred based on the
    value with which it's initialized. Along with that, the properties of an anonymous
    variable are read-only, which means we cannot change their values after the variable
    has been initialized.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型是对象初始化器和隐式类型化的组合。匿名类型是一种没有名称的类型。使用匿名类型，通过使用 `var` 和 `new` 关键字，我们可以创建一个对象，而不必定义其类型或类。匿名类型变量的类型是根据其初始化时的值推断出来的。此外，匿名变量的属性是只读的，这意味着在变量初始化后，我们无法更改它们的值。
- en: 'The following is some sample code syntax where we have declared an object of
    an anonymous type. In the object, we have specified three properties, `PropertyNum1`,
    `PropertyNum2`, and `PropertyNum3`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例代码语法，其中我们声明了一个匿名类型的对象。在这个对象中，我们指定了三个属性，`PropertyNum1`、`PropertyNum2`
    和 `PropertyNum3`：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the code is executed, we get the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码执行，我们得到以下输出：
- en: '![](img/189311df-d804-4691-a019-dd54358ba221.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/189311df-d804-4691-a019-dd54358ba221.png)'
- en: Note that, as we are displaying the type of the anonymous type, for each of
    its respective properties, the execution is displaying the type based upon the
    value that is assigned to the property. Hence, the output that we see is `String`,
    `Int32`, and `Boolean`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们正在显示匿名类型的数据类型，对于其各自的属性，执行将根据分配给属性的值显示类型。因此，我们看到的输出是`String`、`Int32`和`Boolean`。
- en: In the next section, we will look at some standard LINQ operators that we use
    often while writing LINQ queries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些我们在编写LINQ查询时经常使用的标准LINQ运算符。
- en: Understanding LINQ query operators
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解LINQ查询运算符
- en: As described in the *Queries* section, each LINQ operation is divided into three
    parts. In the first part, we obtain data from a data source. In the second part,
    we do operations on the data and finally, in the last part, we extract the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如*查询*部分所述，每个LINQ操作分为三个部分。在第一部分，我们从数据源获取数据。在第二部分，我们对数据进行操作，最后在最后一部分，我们提取数据。
- en: While doing the second part, that is, performing operations on the data, there
    are some standard operators that we can use. These operators help us to achieve
    a consistent experience and a code base that can be easily adapted to different
    data sources.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行第二部分，即对数据进行操作时，有一些标准运算符我们可以使用。这些运算符帮助我们实现一致的经验和易于适应不同数据源的代码库。
- en: Some of the standard query operators are `Select`, `SelectMany`, `Join`, `OrderBy`,
    `Average`, `GroupBy`, `Max`, `Min`, and `Where`. In the following sections, let's
    see some code and learn how some of these operators work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准查询运算符包括`Select`、`SelectMany`、`Join`、`OrderBy`、`Average`、`GroupBy`、`Max`、`Min`和`Where`。在以下章节中，我们将查看一些代码并学习这些运算符中的一些是如何工作的。
- en: Select and SelectMany
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和SelectMany
- en: 'We use `Select` in LINQ when we need to select some values from a collection.
    For example, in the following code syntax, we have declared an array of integers
    and are selecting all of the numbers present in the array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在LINQ中需要从集合中选择一些值时，我们使用`Select`。例如，在以下代码语法中，我们声明了一个整数数组，并选择了数组中所有的数字：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Therefore, if the preceding code is executed, it will print all of the numbers
    present in the array. The following is the output of the preceding code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果执行前面的代码，它将打印出数组中所有的数字。以下是在前面的代码片段中的输出：
- en: '![](img/33519f2d-91ab-4f1f-9976-f7b9ac49e50a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33519f2d-91ab-4f1f-9976-f7b9ac49e50a.png)'
- en: 'We use `Select` when we need to select a value from a collection. However,
    in scenarios where we need to select values from nested collections, that is,
    a collection of collections, we use the `SelectMany` operator. Refer to the following
    code example, in which we are using the `SelectMany` operator to retrieve individual
    characters from string objects present in a string array:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从一个集合中选择一个值时，我们使用`Select`。然而，在需要从嵌套集合中选择值的情况下，即集合的集合，我们使用`SelectMany`运算符。参考以下代码示例，其中我们使用`SelectMany`运算符从字符串数组中检索字符串对象中的单个字符：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following would be the output of the program:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/0b9ee7f5-aace-425b-a5af-f7fd8236a23f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b9ee7f5-aace-425b-a5af-f7fd8236a23f.png)'
- en: In the preceding program, the source of data is an array of strings. Now, strings
    are again an array of characters. Using `SelectMany`, we have directly looped
    through the characters present in the `Introduction`, `In`, and `C#` strings.
    Hence, using `SelectMany`, we can perform actions using fewer statements than
    it would take otherwise.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，数据源是一个字符串数组。现在，字符串又是一个字符数组。使用`SelectMany`，我们直接遍历了`Introduction`、`In`和`C#`字符串中的字符。因此，使用`SelectMany`，我们可以用比其他情况下更少的语句执行操作。
- en: In the next section, we will look at the `Join` operator, which helps us join
    two collections.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看`Join`运算符，它帮助我们连接两个集合。
- en: The join operator
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接运算符
- en: 'The `join` operators in LINQ help us join two collections that could be linked
    to each other by a common attribute. Refer to the following code example, which
    will provide a better explanation of this. Consider that we have two class objects,
    one representing `ClassDetail` and another representing `Students` that are studying
    in the class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ中的`join`运算符帮助我们连接两个可能通过一个共同属性相互关联的集合。参考以下代码示例，它将更好地解释这一点。假设我们有两个类对象，一个代表`ClassDetail`，另一个代表在班级中学习的`Students`：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Please note that in the `ClassDetail` class, we have details specific to the
    class in itself such as `ClassID` and `ClassName`. In the `Student` class, we
    have details specific to the student such as `rollNum`, `Name`, and `ClassID`.
    In the `Student` class, `ClassID` attribute refers to the class in which the student
    is currently studying. We will use this attribute to link the collections of `ClassDetail`
    and `Student`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`ClassDetail`类中，我们有关于班级本身的详细信息，例如`ClassID`和`ClassName`。在`Student`类中，我们有关于学生的详细信息，例如`rollNum`、`Name`和`ClassID`。在`Student`类中，`ClassID`属性指的是学生目前正在学习的班级。我们将使用这个属性来链接`ClassDetail`和`Student`的集合。
- en: 'The following code indicates how we make a join between the two collection
    items of `Student` and `Class`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表明我们如何将`Student`和`Class`的两个集合项进行连接：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we have created two collections lists, one each of `Student`
    and `ClassDetail`. Then, using a `join` operator, we are combining the two lists
    based on a common attribute, `ClassID`. In the resultant items, we are then saving
    the name of the student and the name of the class. If the code is executed, we
    will get the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了两个集合列表，一个是`Student`，另一个是`ClassDetail`。然后，使用`join`操作符，我们根据一个公共属性`ClassID`将两个列表结合起来。在结果项中，我们保存了学生的名字和班级的名字。如果执行此代码，我们将得到以下输出：
- en: '![](img/b3655d04-9042-4671-a052-d2831b55f665.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3655d04-9042-4671-a052-d2831b55f665.png)'
- en: In the next section, we will look at the `orderby` operator.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看`orderby`操作符。
- en: The orderby operator
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`orderby`操作符'
- en: 'The `orderby` operator is used to sort your data in ascending or descending
    order. The following code shows how to sort the data in descending order:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderby`操作符用于按升序或降序排序你的数据。以下代码展示了如何按降序排序数据：'
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we have declared an array of integers. Now, from this
    array, we select all numbers that are greater than `5`. After selecting them,
    we sort them in descending order using the `orderby` clause. Finally, we print
    them. The following is the output of the program when it''s executed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个整数数组。现在，从这个数组中，我们选择所有大于`5`的数字。选择后，我们使用`orderby`子句按降序排序它们。最后，我们打印它们。以下是在程序执行时的输出：
- en: '![](img/9c8af6ae-a551-4b7c-93f6-f33272e25912.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c8af6ae-a551-4b7c-93f6-f33272e25912.png)'
- en: Note that, in the preceding output, the numbers are in descending order and
    all are greater than `5`. In the next section, we will look at the `Average` operator
    in LINQ.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的输出中，数字是降序排列的，并且所有数字都大于`5`。在下一节中，我们将查看LINQ中的`Average`操作符。
- en: Average
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平均值
- en: 'In LINQ, we sometimes need to calculate the `Average` value of any numeric
    item present in the collection. To execute this operation, we can use the `Average`
    operator. Let''s go through the following code example to see how it works. Let''s
    assume we have the following class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在LINQ中，我们有时需要计算集合中任何数值项的`Average`值。为了执行此操作，我们可以使用`Average`操作符。让我们通过以下代码示例来了解它是如何工作的。假设我们有一个以下类：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we have created the following objects for the student class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为`student`类创建了以下对象：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To calculate the average age of the students, we can use the following code
    statement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算学生的平均年龄，我们可以使用以下代码语句：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we execute the code, we get the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，我们将得到以下输出：
- en: '![](img/e1a52ae2-a84b-44db-aefd-c08ebcb570fc.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1a52ae2-a84b-44db-aefd-c08ebcb570fc.png)'
- en: In the next section, we will look at the `GroupBy` operator.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看`GroupBy`操作符。
- en: GroupBy
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GroupBy
- en: We use the `GroupBy` clause in LINQ when we need to group elements based upon
    some key value. Each group is represented by a respective key and a collection
    of grouped elements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要根据某个键值对元素进行分组时，我们在LINQ中使用`GroupBy`子句。每个组由一个相应的键和一个分组元素的集合表示。
- en: To explain this operator, we will consider the same `Class` and `Student` example
    we have been discussing throughout this chapter. Let's consider a scenario wherein
    we need to group students based upon the classes they are currently enrolled in.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这个操作符，我们将考虑本章中一直在讨论的相同的`Class`和`Student`示例。让我们考虑一个场景，其中我们需要根据学生目前注册的班级对学生进行分组。
- en: 'To recap, the following is the structure of the `Student` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，以下是`Student`类的结构：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s assume that we have the following objects in the `Student` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`Student`类中有以下对象：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To group the students in terms of class ID, we use the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按班级ID对学生进行分组，我们使用以下代码：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we have created six objects of student class and are
    then trying to group them by `ClassID`. After the grouping is complete, we are
    looping through the groups that have been created. We are printing `Key`, which
    is, in this case, the class ID and the name of the student.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了六个学生类的对象，然后尝试按`ClassID`对他们进行分组。分组完成后，我们正在遍历创建的组。我们正在打印`Key`，在这种情况下，是班级ID和学生的名字。
- en: 'If we execute the code, we get the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行代码，我们会得到以下输出：
- en: '![](img/276152f8-54ae-4431-827e-238aa2542df6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/276152f8-54ae-4431-827e-238aa2542df6.png)'
- en: In the preceding code, the students are grouped with different classes. It shows
    the different students present in each class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，学生被按不同的班级分组。它显示了每个班级中存在的不同学生。
- en: With this, we have seen how operators work in LINQ. In the next section, we
    will look at the behind-the-scenes interfaces that make LINQ queries possible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经看到了LINQ中操作符的工作方式。在下一节中，我们将探讨使LINQ查询成为可能的幕后接口。
- en: Understanding LINQ behind the scenes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解LINQ背后的原理
- en: Now that we have a fair understanding of LINQ queries, let's consider a scenario
    in which we need to alter the way LINQ works. For the sake of explanation, let's
    consider a scenario in which we need to change the built-in implementation of
    the `Where` clause in the query.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对LINQ查询有了相当的了解，让我们考虑一个需要改变LINQ工作方式的场景。为了解释，让我们考虑一个需要更改查询中`Where`子句内置实现的场景。
- en: 'To do that, we first need to understand how the `Where` clause works in LINQ
    queries. We can do this by looking at the definition of the `Where` clause in
    Visual Studio. The following is how the definition of the `Where` clause would
    appear:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先需要了解`Where`子句在LINQ查询中是如何工作的。我们可以通过查看Visual Studio中`Where`子句的定义来实现这一点。以下是如何显示`Where`子句定义的示例：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, to create our own implementation of the `Where` clause, we will need to
    create an extension method with the same signature.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建我们自己的`Where`子句实现，我们需要创建一个具有相同签名的扩展方法。
- en: 'Once this is done, we can remove the `using` statement for `System.Linq` in
    the respective class and, instead, use our own method. The following is the complete
    code in which we have altered the built-in implementation of the `Where` clause
    without its own custom implementation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们就可以从相应的类中移除`using`语句`System.Linq`，而是使用我们自己的方法。以下是我们没有自己的自定义实现就改变了`Where`子句内置实现的完整代码：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Please note that in the preceding example, we have used the `Yield` keyword.
    The `Yield` keyword was introduced in C# in 2.0\. Using this keyword, the execution
    will basically remember the item that was returned from the previous execution
    of the `Where` function and will return the next item in the iteration.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在先前的示例中，我们使用了`Yield`关键字。`Yield`关键字是在C# 2.0中引入的。使用此关键字，执行将基本上记住从先前的`Where`函数返回的项目，并在迭代中返回下一个项目。
- en: This is particularly important when we working using LINQ queries on data providers
    such as SQL. Due to the usage of `Yield`, the query won't be sent to the database
    until the result is iterated over. However, this would also mean if we execute
    the query multiple times, each time it will hit the database and hence have a
    negative effect on the performance of the system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们使用LINQ查询数据提供程序，如SQL时尤为重要。由于使用了`Yield`，查询只有在结果被迭代时才会发送到数据库。然而，这也意味着如果我们多次执行查询，每次都会击中数据库，从而对系统的性能产生负面影响。
- en: In the next section, we will look at how LINQ queries are used on an XML data
    source.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在XML数据源上使用LINQ查询。
- en: Using LINQ to XML
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ to XML
- en: While working with XML files, we generally use the `XmlWriter`, `XmlReader`,
    and `XmlDocument` classes. Apart from these classes, we can also LINQ to execute
    operations on the XML file. One of the main advantages of using LINQ to execute
    XML operations is that we can use a consistent query experience that LINQ provides
    with other data providers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理XML文件时，我们通常使用`XmlWriter`、`XmlReader`和`XmlDocument`类。除了这些类之外，我们还可以使用LINQ来对XML文件执行操作。使用LINQ执行XML操作的主要优势之一是我们可以使用LINQ与其他数据提供程序提供的相同查询体验。
- en: Using LINQ, we can create, edit, and parse XML files. Apart from providing a
    consistent query experience, LINQ also helps us in writing much more powerful
    queries that are more compact than other XML classes. Let's look at the operations
    that we can perform on XML and understand how we can execute them via LINQ.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LINQ，我们可以创建、编辑和解析 XML 文件。除了提供一致的查询体验外，LINQ 还帮助我们编写更强大、更紧凑的查询，这些查询比其他 XML
    类更强大。让我们看看我们可以对 XML 执行的操作，并了解我们如何通过 LINQ 执行它们。
- en: Querying XML
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 XML
- en: While using LINQ on an XML file, we use the `XDocument` class to load the XML
    as a string in the memory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 LINQ 对 XML 文件进行操作时，我们使用 `XDocument` 类将 XML 作为字符串加载到内存中。
- en: 'Until LINQ was introduced in .NET, developers used to work with the `XmlDocument`
    helper class to do operations on the XML file. `XDocument` is a similar helper
    class that we use in LINQ for doing operations on the XML file. Using LINQ for
    such `xml` operations not only helps to provide a consistent query experience
    but also increases the overall performance of the application. The `XDocument`
    class contains the following elements:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LINQ 引入 .NET 之前，开发者通常使用 `XmlDocument` 辅助类来对 XML 文件进行操作。`XDocument` 是我们在 LINQ
    中用于对 XML 文件进行操作的类似辅助类。使用 LINQ 进行此类 `xml` 操作不仅有助于提供一致的查询体验，而且还能提高应用程序的整体性能。`XDocument`
    类包含以下元素：
- en: '`XDeclaration`: This component signifies information in regards to `XmlDeclaration`
    and contains information such as XML version and the encoding used.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XDeclaration`：此组件表示有关 `XmlDeclaration` 的信息，并包含有关 XML 版本和使用的编码等信息。'
- en: '`XElement`: This component signifies the root node or object present in the
    XML class.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XElement`：此组件表示 XML 类中的根节点或对象。'
- en: '`XProcessingInstruction`: This component contains relevant information for
    the application that will ultimately be consuming the XML file.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XProcessingInstruction`：此组件包含应用程序最终将消耗的 XML 文件的相关信息。'
- en: '`XComments`: This component contains any additional information apart from
    the `XElement` component that we want to add in the XML class.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XComments`：此组件包含除 `XElement` 组件外我们想要添加到 XML 类中的任何附加信息。'
- en: All of the preceding components derive from a common abstract class, `XNode`,
    and any operation executed using `XDocument` is based upon this `XNode` class.
    While working with `XDocument`, we can use `XNode` in several ways. For example,
    using the `XDocument.Nodes` syntax, we can loop through all of the nodes present
    in the XML file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述组件都源自一个共同的抽象类 `XNode`，并且使用 `XDocument` 执行的任何操作都基于此 `XNode` 类。在处理 `XDocument`
    时，我们可以以多种方式使用 `XNode`。例如，使用 `XDocument.Nodes` 语法，我们可以遍历 XML 文件中存在的所有节点。
- en: Similarly, if we have a scenario to search for a specific element or node, we
    can also use the `XDocument.Descendants` or `XDocument.Elements` syntax. Using
    `XNode`, we can also directly reach a particular element or a node that's present
    in the XML file. This can greatly enhance the performance of the application as
    we no longer need to loop through the entire XML file rather than just straightway
    jumping to the required node.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们有一个搜索特定元素或节点的场景，我们也可以使用 `XDocument.Descendants` 或 `XDocument.Elements`
    语法。使用 `XNode`，我们还可以直接访问 XML 文件中存在的特定元素或节点。这可以大大提高应用程序的性能，因为我们不再需要遍历整个 XML 文件，而是直接跳转到所需的节点。
- en: Please note that in an XML file, attributes are not considered nodes; instead,
    they are key-value pairs that belong to a node.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 XML 文件中，属性不被视为节点；相反，它们是属于节点的键值对。
- en: 'The following code sample shows a sample XML containing a set of students who
    all have the attributes of `Name`, `rollNum`, and contact information:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了一个包含一组具有 `Name`、`rollNum` 和联系信息的学生的示例 XML：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Suppose we need to loop through all of the student records that are present
    in this XML file. Using LINQ, we can execute queries that would load all of the
    names of the students present in the XML file as a string. To use LINQ on an XML
    file, we first need to add a reference to the `System.Xml.Linq` namespace. The
    following code syntax shows how we can use the `Descendants` method and the `Attribute`
    method to load this data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要遍历此 XML 文件中所有存在的学生记录。使用 LINQ，我们可以执行查询，将 XML 文件中所有学生的名字作为字符串加载。要在 XML 文件上使用
    LINQ，我们首先需要添加对 `System.Xml.Linq` 命名空间的引用。以下代码语法展示了我们如何使用 `Descendants` 方法和 `Attribute`
    方法来加载数据：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the output of the preceding code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为前述代码的输出：
- en: '![](img/5d00938a-7891-4bbd-a387-3d86b3bd4f86.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d00938a-7891-4bbd-a387-3d86b3bd4f86.png)'
- en: In the preceding program, using a LINQ query, we are retrieving all of the child
    nodes present in the `Student` descendant in the XML file. Once we have retrieved
    all of the nodes, we are selecting the values in the attribute nodes, `Name` and
    `rollNum`. To select the respective element present in the node, we are using
    the `.Attribute` syntax. The method returns an instance of an `XAttribute` object.
    Even though `XAttribute` has a `Value` property of the string type, we can always
    use explicit operators to cast the value to other data types in C#.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们使用LINQ查询检索XML文件中`Student`后代的全部子节点。一旦检索到所有节点，我们便选择属性节点中的`Name`和`rollNum`的值。为了选择节点中相应的元素，我们使用`.Attribute`语法。该方法返回一个`XAttribute`对象的实例。尽管`XAttribute`有一个字符串类型的`Value`属性，但我们始终可以使用显式运算符将值转换为C#中的其他数据类型。
- en: 'While using LINQ on XML files, we can also use operators such as `Where` and
    `OrderBy` in the queries. The following code syntax shows how we can filter all
    students to only those with a phone number:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用LINQ对XML文件进行操作时，我们还可以在查询中使用`Where`和`OrderBy`等运算符。以下代码语法显示了我们可以如何过滤所有有电话号码的学生：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we have added a `where` clause, in which we have added
    a condition on the phone number. Note that, in the XML string, only one child
    node has a phone number. When the preceding code is executed, we get the following
    output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个`where`子句，其中我们在电话号码上添加了一个条件。请注意，在XML字符串中，只有一个子节点有电话号码。当前面的代码执行时，我们得到以下输出：
- en: '![](img/d016f86a-f41b-43b5-915b-b0387515628e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d016f86a-f41b-43b5-915b-b0387515628e.png)'
- en: In the preceding XML file, only one student record has a phone number, hence
    it's filtering out that particular record. In the next section, we will look at
    how we can create an XML file using LINQ.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的XML文件中，只有一个学生记录有电话号码，因此它过滤出了那个特定的记录。在下一节中，我们将探讨如何使用LINQ创建XML文件。
- en: Creating XML
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建XML
- en: 'Apart from querying XML, we can also use LINQ to create XML files. To do this,
    we can use the `XElement` class. There is an `ADD` method available in the class
    that we can use to construct an XML file. The following code syntax shows how
    we can create some XML:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询XML之外，我们还可以使用LINQ创建XML文件。为此，我们可以使用`XElement`类。该类中有一个`ADD`方法，我们可以用它来构建XML文件。以下代码语法显示了我们可以如何创建一些XML：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we have defined an element by the name `Student`. In
    the root element, we have added a child node of `Marks` to represent the marks
    the student has earned. We have also added a child node of `Attendance` to represent
    the attendance of `Student`. Finally, we have added a `"Roll Number"` attribute
    to represent the unique identifier of `Student`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过名称`Student`定义了一个元素。在根元素中，我们添加了一个`Marks`子节点来表示学生获得的分数。我们还添加了一个`Attendance`子节点来表示学生的出勤情况。最后，我们添加了一个`"Roll
    Number"`属性来表示学生的唯一标识符。
- en: 'Once the code is executed, we will observe that it has created an XML file
    with the following structure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码执行完毕，我们将观察到它创建了一个具有以下结构的XML文件：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the next section, we will look at how we can use LINQ to update XML.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用LINQ更新XML。
- en: Updating XML
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新XML
- en: 'In this section, we will look at how we can modify an XML file using LINQ.
    With LINQ, we can modify the XML file by doing the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用LINQ修改XML文件。使用LINQ，我们可以通过以下方式修改XML文件：
- en: Removing existing nodes in the XML file
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XML文件中删除现有节点
- en: Inserting new nodes in the XML file
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XML文件中插入新节点
- en: Changing the content of existing nodes
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改现有节点的内容
- en: Saving the XML file back once the operation finishes
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作完成后保存XML文件
- en: 'For the sake of explanation, we will work on the same XML file that we created
    in the previous section. We will be writing a code that would add a mobile number
    element for all of the students. We will add this element in the node element
    of `ContactDetails`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释方便，我们将使用上一节中创建的相同XML文件。我们将编写一个代码，为所有学生添加一个手机号码元素。我们将在这个节点的`ContactDetails`元素中添加这个元素：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we are looping through all `Students` present in the
    XML and are then looping through the child element of `ChildDetails`. In that
    node, we are adding the element of `MobileNumber`. Once the code is executed,
    we will get the following output in the XML file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在遍历XML中所有的`Students`，然后遍历`ChildDetails`的子元素。在那个节点中，我们添加了`MobileNumber`元素。一旦代码执行完毕，我们将在XML文件中得到以下输出：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding XML, we have added a `MobileNumber` element in the `ContactDetails`
    node of `Student`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 XML 中，我们在 `Student` 的 `ContactDetails` 节点中添加了一个 `MobileNumber` 元素。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how we can use LINQ to write consistent queries
    against multiple data sources. We learned about the different components of a
    LINQ query and understood how we can construct them in a query. We then looked
    at the features in a C# language that allows us to work with LINQ such as implicit
    typing, object initialization syntax, lambda expressions, extension methods, and
    anonymous types.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 LINQ 对多个数据源编写一致的查询。我们了解了 LINQ 查询的不同组件，并理解了如何在查询中构建它们。然后，我们探讨了
    C# 语言中的功能，这些功能使我们能够使用 LINQ，例如隐式类型、对象初始化语法、lambda 表达式、扩展方法和匿名类型。
- en: We then looked at the different operators available in LINQ such as `Select`,
    `SelectMany`, `Where`, `join`, and `Average`. Using code scenarios, we looked
    at different situations in which we should use each of them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着探讨了 LINQ 中可用的不同操作符，例如 `Select`、`SelectMany`、`Where`、`join` 和 `Average`。通过代码场景，我们探讨了在不同情况下我们应该使用它们的各种情况。
- en: We then looked at the different interfaces that LINQ queries are based on. Finally,
    we looked at how we can use LINQ queries to perform an operation on XML files.
    Using code examples, we looked at how we perform, create, update, and query operations
    on LINQ.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着探讨了 LINQ 查询基于的不同接口。最后，我们探讨了如何使用 LINQ 查询对 XML 文件执行操作。通过代码示例，我们探讨了如何执行、创建、更新和查询
    LINQ 操作。
- en: In the next chapter, we will look at the serialization and deserialization of
    data. We will look at the different collection items, such as arrays, lists, and
    dictionaries, which are available in C#.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据的序列化和反序列化。我们将探讨 C# 中可用的不同集合项，例如数组、列表和字典。
- en: Questions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which LINQ code can be used to extract customers that have made sales of over
    5,000 dollars and whose name starts with A?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪段 LINQ 代码可以用来提取销售金额超过 5,000 美元且姓名以 A 开头的客户？
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) = 5000` `SELECT p`'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) = 5000` `SELECT p`'
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) > 5000` `SELECT p`'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) > 5000` `SELECT p`'
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.EndsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) < 1000` `SELECT p`'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.EndsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) < 1000` `SELECT p`'
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) >= 1000` `SELECT p`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) >= 1000` `SELECT p`'
- en: Which of the following statements in regards to LINQ is incorrect?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于 LINQ 的陈述中哪一项是不正确的？
- en: Compared to languages such as SQL, LINQ is more complex to code.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 SQL 等语言相比，LINQ 的编码更复杂。
- en: LINQ supports `Join`.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LINQ 支持 `Join`。
- en: LINQ can be used to do operations on XML files.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LINQ 可以用于对 XML 文件进行操作。
- en: All of the above.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述选项。
- en: Which of the following supports LINQ queries?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项支持 LINQ 查询？
- en: Object Collection
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象集合
- en: Entity Framework
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体框架
- en: XML Document
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: XML 文档
- en: All of the above
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述选项
- en: Answers
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**b**'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**b**'
- en: '**a**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**d**'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**d**'
