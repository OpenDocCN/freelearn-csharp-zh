- en: Concealing Complexity with a Facade Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外观模式隐藏复杂性
- en: The Facade pattern is an easy pattern to grasp because its name implies its
    purpose. The primary intent of the Facade pattern is to offer a simplified front-facing
    interface that abstracts the intricate inner workings of a complex system. This
    approach is beneficial for game development because games are composed of complex
    interactions between various systems. As a use case, we will write code that simulates
    the behavior and interactions of a vehicle's engine core components and then offers
    a simple interface to interact with the overall system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式是一个容易理解的模式，因为其名称暗示了其目的。外观模式的主要目的是提供一个简化的前端接口，抽象出复杂系统的复杂内部工作。这种方法对游戏开发有益，因为游戏由各种系统之间的复杂交互组成。作为一个用例，我们将编写代码来模拟车辆引擎核心组件的行为和交互，然后提供一个简单的接口来与整个系统交互。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Facade pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解外观模式
- en: Designing a bike engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计自行车引擎
- en: Implementing a bike engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自行车引擎
- en: A basic implementation of a vehicle's engine with the Facade pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外观模式的基本车辆引擎实现
- en: This section includes a simplified version of the implementation of an engine
    for simplicity and brevity reasons. A complete implementation of this code example
    can be found in the `/FPP` folder of the GitHub project—the link is available
    under the *Technical requirements* section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于简单和简洁的原因，本节包括了一个引擎实现的简化版本。此代码示例的完整实现可以在GitHub项目的`/FPP`文件夹中找到——链接可在*技术要求*部分找到。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This is a hands-on chapter, so you will need to have a basic understanding of
    Unity and C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实践性章节，因此你需要对Unity和C#有基本的了解。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，查看代码的实际效果：
- en: '[https://bit.ly/36wJdxe](https://bit.ly/36wJdxe)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/36wJdxe](https://bit.ly/36wJdxe)'
- en: Understanding the Facade pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解外观模式
- en: 'The Facade pattern''s name is analogous to the facade of a building—as the
    name implies, it''s an exterior face that hides a complex inner structure. Contrary
    to building architecture, in software development, the goal of a facade is not
    to beautify; instead, it is to simplify. As we are going to see in the following
    diagram, an implementation of the Facade pattern is usually limited to a single
    class that acts as a simplified interface to a collection of interacting subsystems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式的名称类似于建筑的立面——正如其名所示，它是一个外部面，隐藏着复杂的内部结构。与建筑结构相反，在软件开发中，外观模式的目标不是美化；相反，它是为了简化。正如我们将在以下图中看到的那样，外观模式的实现通常限于一个类，该类作为一组相互作用的子系统的简化接口：
- en: '![](img/7948ddd6-8d2d-4779-a345-a4a5cccf0d76.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7948ddd6-8d2d-4779-a345-a4a5cccf0d76.png)'
- en: Figure 15.1 – Unified Modeling Language (UML) diagram of the Facade pattern
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 外观模式的统一建模语言（UML）图
- en: As we can see in the preceding diagram, `EngineFacade` acts as an interface
    to the various components of the engine, thereupon the client is unaware of what
    is happening behind the scenes when calling `StartEngine()` on `EngineFacade`.
    It's unaware of the components that make up the engine and how to reach them;
    it only knows what it needs to know. This is similar to what happens when you
    turn the ignition key in your car—you don't see what's happening under the hood,
    and you don't need to; your only concern is that the engine starts. And so, the
    Facade pattern offers this same level of abstraction in your code, keeping the
    details of the system under the hood.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`EngineFacade`充当引擎各个组件的接口，因此当在`EngineFacade`上调用`StartEngine()`时，客户端对幕后发生的事情一无所知。它不知道构成引擎的组件以及如何访问它们；它只知道它需要知道的内容。这类似于当你转动汽车点火钥匙时发生的情况——你看不到引擎盖下发生了什么，你也不需要知道；你唯一关心的是引擎是否启动。因此，外观模式在代码中也提供了这种相同级别的抽象，保持系统引擎盖下的细节。
- en: The Facade pattern is part of the structural pattern category. Patterns in this
    classification are concerned with how classes and objects are composed to form
    larger structures.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式属于结构模式类别。这个分类中的模式关注于类和对象是如何组合成更大的结构的。
- en: Benefits and drawbacks
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'Here are some **benefits** of the Facade pattern:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是外观模式的一些**优点**：
- en: '**Simplified interface to a complex body of code**: A solid Facade class will
    conceal complexity from a client while providing a simplified interface to interact
    with an intricate system.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化对复杂代码体的接口**：一个坚实的外观类将隐藏复杂性，同时提供一个简化的接口与复杂的系统交互。'
- en: '**Easy refactoring**: It''s easier to refactor code that''s isolated behind
    a Facade because the system''s interface remains consistent to the client while
    its components are being modified behind the scenes.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于重构**：在背后修改组件的同时，由于系统的接口对客户端保持一致，因此隔离在外观背后的代码更容易重构。'
- en: 'The following are some **drawbacks** to watch out for:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些需要注意的**缺点**：
- en: '**It makes it easier to hide the mess**: Using the Facade pattern to hide messy
    code behind a clean front-facing interface will defeat the pattern''s core benefits
    in the long run, but this pattern does offer a way to mask some code smells until
    you have time to refactor them. However, expecting to have enough time later to
    fix stuff is a trap in itself because we rarely have enough time to refactor things
    correctly.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使其更容易隐藏混乱**：使用外观模式在干净的面向用户界面后面隐藏混乱的代码，从长远来看可能会损害模式的核心优势，但这个模式确实提供了一种方法来掩盖一些代码问题，直到你有时间重构它们。然而，期望以后有足够的时间来修复问题是自身的一个陷阱，因为我们很少有时间正确地重构事物。'
- en: '**Too many facades**: Globally accessible manager classes that act as facades
    to core systems are popular among Unity developers; they often implement them
    by combining the Singleton and Facade patterns. Unfortunately, it''s too easy
    to abuse this combination and end up with a code base comprising too many manager
    classes, each dependent on the other to function. As a consequence, debugging,
    refactoring, and unit testing components becomes very difficult.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过多的外观**：在Unity开发者中，全局可访问的管理器类作为核心系统的外观很受欢迎；他们通常通过结合单例和外观模式来实现它们。不幸的是，滥用这种组合很容易，最终导致代码库中包含过多的管理器类，每个类都依赖于其他类才能正常工作。因此，调试、重构和单元测试组件变得非常困难。'
- en: The Facade pattern establishes a new interface, whereas the Adapter pattern
    adapts an old interface. Therefore, when implementing patterns that might look
    and sound similar, it's essential to keep in mind that they're not necessarily
    identical in their purpose.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式建立了一个新的接口，而适配器模式则适配一个旧接口。因此，在实现看似和听起来相似的模式时，牢记它们在目的上不一定相同是至关重要的。
- en: Designing a bike engine
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计自行车发动机
- en: 'We are not aiming to implement a complete simulation of an actual gas engine
    for a bike; this will take too long and demands an in-depth understanding of the
    physics and mechanics of a real-world engine. But we will aim to simulate, to
    a minimal degree, some standard components of a high-speed vehicle''s motor. So
    first, let''s break down the expected behavior of each part of our engine, as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标不是为自行车实现一个实际的汽油发动机的完整模拟；这将花费太长时间，并且需要深入了解真实世界发动机的物理和机械原理。但我们将尝试以最小程度模拟高速车辆发动机的一些标准组件。因此，首先，让我们分解我们发动机每个部分的预期行为，如下所示：
- en: '**Cooling system**: The cooling system is responsible for making sure the engine
    is not overheating. When the turbocharger is activated, the cooling system shuts
    down during a turbocharge. This behavior means that if the player overuses the
    turbocharger, this can overheat the engine, and in consequence, the engine will
    stop or explode and the bike will stop moving.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷却系统**：冷却系统负责确保发动机不过热。当涡轮增压器被激活时，冷却系统在涡轮增压器工作期间关闭。这种行为意味着如果玩家过度使用涡轮增压器，这可能会导致发动机过热，进而导致发动机停止或爆炸，自行车将停止移动。'
- en: '**Fuel pump**: This component is responsible for managing the fuel consumption
    of the bike. It knows the amount of gas remaining and stops the engine if it runs
    out of it.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃油泵**：该组件负责管理自行车的燃油消耗。它知道剩余的汽油量，并在汽油耗尽时停止发动机。'
- en: '**Turbocharger**: If the turbocharger is activated, the vehicle''s top speed
    is increased, but the cooling system shuts down temporarily so that the engine''s
    circuitry can relay power to the charger.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**涡轮增压器**：如果涡轮增压器被激活，车辆的极速会增加，但冷却系统会暂时关闭，以便发动机的电路可以传递动力到充电器。'
- en: In the next section, we will implement a skeleton class for each of these components
    and establish an engine `Facade` class so that clients can start and stop the
    engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为这些组件中的每一个实现一个骨架类，并建立一个发动机`Facade`类，以便客户端可以启动和停止发动机。
- en: The design intention of having the cooling system shut down when the turbocharger
    is activated is to create a sense of risk versus reward. The player must balance
    the desire to go faster with the potential consequence of overheating the engine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当涡轮增压器被激活时关闭冷却系统的设计意图是为了创造一种风险与回报的感觉。玩家必须平衡想要更快行驶的愿望与发动机过热的潜在后果。
- en: Implementing a bike engine
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自行车发动机
- en: 'As we are going to see, the Facade pattern is straightforward, so we will keep
    the following code example simple and straight to the point. To start, we will
    write the classes for each of the core components that make up the bike''s engine,
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，Facade模式很简单，所以我们将保持以下代码示例简单直接。首先，我们将为组成自行车发动机的核心组件编写类，如下所示：
- en: 'We will start with the fuel pump; the purpose of this component is to simulate
    the consumption of fuel so that it knows the amount remaining and shuts down the
    engine when it runs out. Here''s the code you''ll need:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从燃油泵开始；这个组件的目的是模拟燃油消耗，以便它知道剩余的燃油量，并在燃油耗尽时关闭发动机。以下是所需的代码：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up is the cooling system, which is responsible for preventing the engine
    from overheating but gets deactivated if the turbocharger is activated. The code
    is illustrated in the following snippet:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是冷却系统，它负责防止发动机过热，但如果涡轮增压器被激活，则会关闭。代码如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And finally, the turbocharger, when activated, increases the bike''s top speed,
    but for it to function, it needs to deactivate the cooling system temporarily.
    Here''s the code to accomplish this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当涡轮增压器被激活时，它会增加自行车的极速，但为了使其工作，它需要暂时关闭冷却系统。以下是实现这一功能的代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have the core components of our engine ready, we need to implement
    a class that will permit a client to interact with them seamlessly. So, we will
    implement a Facade class called `BikeEngine` that will offer an interface for
    a client to start and stop the engine and toggle the turbocharger. But because
    the following code example is so long, we will review it in two parts. Here''s
    the first part:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了发动机的核心组件，我们需要实现一个类，允许客户端无缝地与之交互。因此，我们将实现一个名为`BikeEngine`的Facade类，它将为客户端提供一个接口来启动和停止发动机以及切换涡轮增压。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first part of this class is initialization code and is self-explanatory,
    but the following segment is the important part:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的第一部分是初始化代码，这部分是自解释的，但以下部分是重要的：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the `EngineFacade` class exposes the available functionality
    that the bike engine offers but, at the same time, conceals the interaction between
    its components. If we want to start the engine, we just need to call the `StartEngine()`
    method. If we didn't have a Facade pattern such as the one we just implemented,
    we would have to initialize each engine component individually and know each of
    their parameters to set and the methods to call. The Facade pattern permits us
    to tuck all the complexity away behind a clean interface.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`EngineFacade`类公开了自行车发动机提供的可用功能，同时，它也隐藏了其组件之间的交互。如果我们想启动发动机，我们只需要调用`StartEngine()`方法。如果我们没有像我们刚刚实现的那样有一个Facade模式，我们就必须单独初始化每个发动机组件，并知道每个组件的设置参数和要调用的方法。Facade模式允许我们将所有复杂性隐藏在干净的接口后面。
- en: But suppose we wished to add another engine component, such as a nitro injector;
    in that case, we would only need to modify the `BikeFacade` class and expose a
    new public method to allow us to trigger the injector.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们希望添加另一个发动机组件，例如一个硝基喷射器；在这种情况下，我们只需要修改`BikeFacade`类，并公开一个新的公共方法，以便我们可以触发喷射器。
- en: Testing the engine facade
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试发动机Facade
- en: 'We can quickly test the code we just implemented by adding the following client
    script to a GameObject in an empty Unity scene:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向一个空的Unity场景中的GameObject添加以下客户端脚本来快速测试我们刚刚实现的代码：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the client class, we see that it's not aware of the engine's inner workings,
    and this is the effect we want to achieve when using the Facade pattern. The only
    thing the client class knows is that it can start and stop the engine and toggle
    on a turbocharged feature by calling the public methods made available by the `BikeEngine` class.
    To put it another way, just as in real life, we don't need to open the hood to
    start the engine; we turn the ignition key, and the components start working together
    without us knowing how they are interacting with each other.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端类中，我们看到它并不了解引擎的内部工作原理，这就是我们使用外观模式时想要达到的效果。客户端类唯一知道的是，它可以调用由`BikeEngine`类提供的公共方法来启动和停止引擎，以及切换涡轮增压功能。换句话说，就像现实生活中一样，我们不需要打开引擎盖来启动引擎；我们转动点火钥匙，组件就会开始协同工作，而我们不需要知道它们是如何相互作用的。
- en: In the next section, we will review alternative solutions to consider before
    deciding on using the Facade pattern.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾在决定使用外观模式之前需要考虑的备选解决方案。
- en: In a potentially more advanced version of this code example, the engine would
    calculate the current **revolutions per minute** (**RPM**)—also known as the engine's
    speed—and we could connect it to a gear system regulated by a shifter input with
    which the player could control the bike's speed. Thus, we could easily enhance
    the level of realism at any time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例的更高级版本中，引擎将计算当前的每分钟转速（RPM）——也称为引擎速度——并且我们可以将其连接到一个由换挡输入调节的齿轮系统，玩家可以通过这个系统来控制自行车的速度。因此，我们可以在任何时候轻松地提高现实感水平。
- en: Reviewing alternative solutions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查备选解决方案
- en: 'There are several alternatives to keep in mind before considering the Facade
    pattern, depending on what you are actually trying to accomplish. These are listed
    here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑使用外观模式之前，有几个备选方案需要考虑，具体取决于你实际上想要实现什么。这些方案在此列出：
- en: '**Abstract Factory pattern:** If you only want to conceal how subsystem objects
    are initialized from the client code, you should consider using the Abstract Factory
    pattern instead of the Facade pattern.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂模式**：如果你只想从客户端代码中隐藏子系统对象的初始化方式，你应该考虑使用抽象工厂模式而不是外观模式。'
- en: '**Adapter**: If you are intending to write a "wrapper" over existing classes
    with the intent to bridge two incompatible interfaces, then you should consider
    using the Adapter pattern.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：如果你打算编写一个“包装器”来覆盖现有的类，目的是连接两个不兼容的接口，那么你应该考虑使用适配器模式。'
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Even though the Facade pattern is sometimes used to hide messy code, when you
    use it as intended, it can enhance your code base's readability and usability
    by masking underlying complex interactions of subsystems behind a singular front-facing
    interface. Thus, it's a pattern that can be very beneficial for game programming,
    but one to use wisely and with good intent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管外观模式有时被用来隐藏混乱的代码，但当你按照预期使用它时，它可以通过隐藏子系统背后的复杂交互，通过单一的前端界面来增强代码库的可读性和可用性。因此，它对于游戏编程来说是一个非常有益的模式，但需要谨慎且带有良好的意图来使用。
- en: In the upcoming chapter, we will explore a pattern named Service Locator, which
    we will use to manage global dependencies and expose core services.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，我们将探讨一个名为服务定位器（Service Locator）的模式，我们将使用它来管理全局依赖项并公开核心服务。
