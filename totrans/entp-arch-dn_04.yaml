- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with Time and Technical Debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An information system is like a living organism: it always moves and changes.
    Yet, most of them are designed “one shot,” without thinking of its adequation
    to the business in time, but only of its capacity to handle the business needs
    at the moment it is designed. Lots of IT problems can be related to time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we talked about business alignment and the importance
    of basing the structure on business concerns. This must also be applied to taking
    time as a parameter of the equation for a good information system: if the business
    feature is a one-shot/disposable one, its technical implementation will be no
    more complex than a prototype, quickly coded and soon discarded after use. On
    the other hand, for a feature that will be used for decades in production, you
    must carefully hone the design and polish the implementation, with as few moving
    parts as possible, since a good architect knows that maintaining such a module
    will eventually cost much more than its initial development (see, for example,
    [https://natemcmaster.com/blog/2023/06/18/less-code/](https://natemcmaster.com/blog/2023/06/18/less-code/)
    on this issue). The code’s quality and its ease of maintenance (hence the developer’s
    dreaded activity of documentation) will be much more important than the capacity
    to quickly deliver the feature for time-to-market reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will analyze this problem of time adequation in information systems
    since most of them are designed with a time-fixed goal and rarely with evolution
    in time. This is why the majority of them see their performance quickly degrade
    in time and also why when their construction is too long, the result is not even
    in conformity to the expressed needs, hence the emergence of Agile software. The
    concept of technical debt will be explained, as well as the notion of coupling.
    Hopefully, by the end of this chapter, you will have improved your critical thinking
    of what needs a **Proof of Concept** (**PoC**) approach and what needs strong,
    evolutive, design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The impact of time on systems due to functional change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Agile approach aims to solve the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of technical debt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An experience-proven blueprint method for information systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The impact of time on systems due to functional change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most difficult things to do when designing systems is to consider
    time. After all, it is already hard to picture how something complex should look
    at a given moment. Taking time into account requires an additional depth of thought,
    which can make this difficult. Moreover, time variations happen in every aspect
    as the system evolves, but it should also take into account time in its functioning,
    just like another variable.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of fun with ill-placed comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few sentences you may have heard in your everyday life concerning
    industries other than computers:'
  prefs: []
  type: TYPE_NORMAL
- en: The repairman changed my car engine this weekend; it is now ready for another
    10 years
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I took generic pills instead of the commercial brand: they are less expensive
    and I did not notice any difference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we started regularly maintaining the furnace, we haven’t had any failures
    during the winter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dimensions of the parts evolved a bit, but we just had to change the parameters
    on the CNC machine; there was no need for the machining expert for such a small
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s try and transpose this to the IT industry and see if we can hear
    the same expressions without at least a wry smile or a smirking face:'
  prefs: []
  type: TYPE_NORMAL
- en: We changed the ERP this weekend; everything seemed to work quite well on Monday
    morning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I used some free software as a replacement for my commercial suite: less expensive
    and since it was 100% compatible, everything works exactly as before'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we regularly maintain our information system, we never have any major
    failures or bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The business people need to adjust the system due to regulatory systems but,
    since it is just business rules, they do not need the IT team for such a small
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do any of these sentences sound realistic? If you happen to have the slightest
    experience in information systems, you will know that they aren’t, and even sound
    humorous. Nothing could be further from reality than these utopic sentences. The
    equivalent sentences should be more like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Management has decided to change the core ERP; we expect the information system
    to have a stabilization period of at least 6 months, and the initial project with
    analysis, deployment, and training will certainly take at least a year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I switched to open source to eliminate license costs, but since I had to adjust
    most of my processes, I lost a few functionalities and experts are hard to find
    on this technology, I am not sure the TCO will be lower in the end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to new cybersecurity compliance rules, we made the entire IT team push updates
    to software applications that are disseminated everywhere in the information system;
    we hope most of the servers are covered but know that we still have a high level
    of risk on the employees’ workstations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “This new GDPR will oblige us to release a brand-new version of the software
    and adjust most of the data streams in the information system; IT will certainly
    spend most of its non-maintenance time on this for the next 6 months.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These versions are way more realistic but sound like a desperate evaluation
    of the situation. Where does such a catastrophic capacity of the information systems
    come from? As explained in [*Chapter 1*](B21293_01.xhtml#_idTextAnchor014), information
    systems are not industrialized yet. But if you pay closer attention to these sentences,
    you will realize that they all bear the notion of evolution in time. And this
    is what makes them sound silly. If time was taken out of the equation, they may
    look fine:'
  prefs: []
  type: TYPE_NORMAL
- en: The ERP we currently use works correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am using free software and it works as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am using the latest version; everything seems to be fine (for now)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have set up the software with initial rules (and we hope we don’t have to
    change them in the future)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, IT can work and provide great services but most of the time, this
    is when time passes and IT has got to evolve when problems arise.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences in the software world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding comparisons may seem anecdotal, but they bear some reality as
    change is the only constant in life, and thus in information systems. A fun story
    I once heard stated that a perfectly stable information system is possible but
    needs three components: a human, a computer, and a dog. The computer does the
    work, the human feeds the dog, and the dog protects the computer from the human
    touching it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, despite the humorous approach, there is some truth in this joke: the
    fact that the perfect system can be considered so because it is stable (the dog
    preventing the human from causing change, and consequently chaos). The computer
    can do a perfect job because it does not need to change what it has been programmed
    to do. Humor put aside, the consequences of time and evolution on information
    systems can be described formally and various concepts are associated with their
    different categories, all of which we will describe here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first concept associated with time in IT – and this one is well-known by
    anyone using computers – is the notion of software upgrades. As time goes by,
    a piece of software, whatever quality efforts are put into its design and development,
    will have to undergo regular changes of versions and at least security patches
    to remain fully operational. A software application is a complex system in itself,
    with sometimes millions of lines of code. If we go on with comparisons with the
    mechanical industry (sorry about coming back on this one, which certainly comes
    from my academic background in mechanical systems), that means a standard industry-grade
    application is closer in complexity to a commercial airplane than a standard automobile.
    No wonder it has to be upgraded and adjusted during its lifetime, just like airliners
    necessitate heavy maintenance. The difficulty comes from the fact that most applications
    are designed in a way that is not as modular as we would expect, and unexpected
    dependencies happen very often, making the application work as a cohesive entity.
    If you take a Rafale war aircraft, the engines can be changed by two mechanics
    in a few hours because the whole plane has been designed with this constraint.
    How about your ERP software? Is there any way you could switch the authorization
    engine in a few hours? Most certainly not... This is why the majority of software
    applications have a limited life expectancy: after many version upgrades, the
    overall quality always degrades and, in time, the application becomes less adapted
    to the business. Sure, some applications stay in business for more than 10 years,
    sometimes 20 or even more. But ask the users if the reason is that the software
    is perfect and if they love it and you will always get the same answer: the piece
    of software is still here simply because it is way too dangerous to try and remove
    it!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second kind of impact of time on information systems is not on the software
    part but due to the business itself. As stated at the very beginning of this chapter,
    information systems are live entities, and they evolve continuously because business
    itself evolves. New strategies, regulation changes, large company reorganizations,
    fusion with an acquired company, selling of a business unit, and so on – there
    are so many factors that can move around the uses of the information systems that
    there is almost no way that they can remain stable for a long time, even in very
    stable business domains. In addition, on top of law-related regulations, many
    business rules are specific to companies and this makes it hard to produce applications
    that can truly pretend to reach the “one size fits all” state. Even with the best
    intention to keep things simple, companies often end up tweaking the software
    applications they bought, or integrating them with dedicated connectors or custom
    code, for them to comply with their way of doing business, simply because it costs
    less (at least at first) to do so, rather than reorganizing the corresponding
    function. But this is a trap and is where time comes into the game again: as time
    goes by, this specificity will cost more and more. First, every new major version
    of the application may make it fail, and money will be spent on keeping the specific
    code compatible with the new version. Most of the time, this was not fully budgeted,
    which means the overall cost grows and grows in time, sometimes ending up costing
    much more than initially adjusting the processes to the software. There is also
    a part of psychology in it: functional experts would feel bad adjusting their
    way of doing simply because some piece of code from an external editor thinks
    it is better to do it another way. What do they know about their job?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third link to time in information systems is neither on software nor on
    functions, but on how the software is adapted to the business functions. This
    can be done through integration, customization, adjustment of application parameters,
    adapting the way the application interoperates with other parts of the software,
    and more. The link to time is a bit more subtle here, but all these ways remain
    mostly specialists’ jobs. And since experts are rare, it is very common that this
    step in a software project takes more time than accounted for. Changing a parameter
    is quick but analyzing all possible impacts in a complex system needs a good understanding
    of it (we talked about the need for a map of the information system in [*Chapter
    3*](B21293_03.xhtml#_idTextAnchor069)) and can take a lot of time. This is one
    of the reasons why ERP projects – a well-known example – take so much time in
    a company (despite everything a commercial can tell you about it, there is no
    way in practice to reduce this time below 6 months at the very least). Another
    consequence of this is vendor lock-in: as more and more parameters get changed
    from their default values, as more and more connectors or integrations are added
    to the system, it becomes more and more difficult to change the software for other
    vendors. After a given amount of time, the application is so engrained in the
    system data streams that customizing a new application would take a huge effort
    (particularly since documentation is not the best asset of these projects), hence
    the stopped evolution of some IT capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these have the consequence that the company using the information system
    is, in a way, dispossessed from its business processes as there are so many ways
    IT stands in the way and can prevent rapid evolution. Sure, IT helps automate
    processes and, once set in place, can provide interesting gains. But the effort
    to make it work – and in particular to keep it working in time – might not make
    it very interesting (remember the Gartner statistics showing that 70% of the IT
    budget goes into maintenance alone!)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, **technical debt** is also a concept that is strongly associated with
    time passing by. As it turns out, it is very much like entropy and tends to always
    grow with time. But this one is so important that we will analyze it in its very
    own section later in this chapter. For now, we are going to look at how Agile
    practices can help us deal with time.
  prefs: []
  type: TYPE_NORMAL
- en: How the Agile approach aims at solving the time problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Agile has lots to do with time management, so it may help us deal with the time
    issues around information systems. To explain how, we will go back to what Agile
    is and then observe different ways it can solve the time-based complexity we need
    to tame.
  prefs: []
  type: TYPE_NORMAL
- en: A metaphor to explain Agile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Agile** is about taking the time factor into account. In a V-cycle development
    process, everything is planned and time passing by is only supposed to make things
    go forward in the process. The Agile approach recognizes that time is itself a
    factor in the project, and it appears everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: There is time negotiation because quality should not be compromised, and adding
    resources does not make a software project get quicker (“five cooks do not bake
    a cake in 10 minutes instead of 50”). So, the only way to adjust to hazards is
    to increase the time or reduce the functional scope (which comes back again to
    increasing time if the client still wants the complete initially-requested perimeter
    to be realized by the end of the project).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time is one of the major decisions in organizing an Agile project: how long
    should the sprints be if you work with Agile? What cadence should be used if you
    use a Kanban approach? At what frequency should we organize stabilization sprints?
    How quick should continuous integration be to be efficient? How sustainable in
    time is the rhythm used by the team?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling a sprint is a negotiation around time available, and how estimates of
    time to be taken by backlog tasks should be done and added up to fill the sprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the best metaphors I have found to explain Agile software development
    to my customers or students also talks very much about time. The idea is to compare
    two ways of shooting an arrow at a target: the usual way is to aim at the target,
    carefully accounting for the wind and the distance to the target and, when everything
    is fine, shooting the arrow and hoping there will not be a sudden gust of wind,
    that we have estimated correctly the angle, and more. Guess what? If the target
    is far enough, hitting the bull’s eye is pretty much a question of luck, in these
    conditions. This is what the V-cycle is about: carefully planning for the project
    development in time, considering as many initial conditions as possible, and eventually
    launching the project, hoping that nothing will get it out of target... Sadly,
    there will always be external changes in conditions, customers changing their
    minds, a team being sick, an important dependency not being released on time,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Meet the Agile way to hit the bull’s eye at every shot, or at least with a
    considerably higher probability: you must take the arrow in your hand, walk to
    the target against the changing winds, correct your path if the target moves,
    and eventually plant the arrow in the target when you’re close enough. Sure, walking
    to the target with an arrow in your hand takes way longer than the flight of the
    arrow once it’s been shot. But are you sure it is going to take longer than hitting
    many arrows in the wind to eventually have one reaching the target, not even in
    the middle? The difference lies in the conditions of the project. If everything
    is stable, no external dependencies are there, and you are in a fully controlled
    context, maybe planning everything in advance will be a bit quicker than adjusting
    step by step. However, the vast majority of software projects do not belong to
    this utopic situation. Most of them are developed in extremely changing contexts,
    with hazards everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Back to the concept of emerging architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069), emerging code architecture
    was quickly cited and I said we would come back to this. Now is the right moment
    to do so. Since we talked about Agile development and we are in the middle of
    a discussion about time, let’s look at two things that are closely related to
    emerging architecture. This concept is about achieving a good architecture **without
    aiming at it in advance, with schemas and plans**, by refining the architecture
    along the development of a software project and refactoring the code structure
    at every step of iterative development. Without aiming at it in advance... does
    this remind you of something? This is the metaphor we used previously to explain
    the Agile approach to hit the target of a software project. Again, time is the
    concept that allows us to reach an agreement between architecture (in its meaning
    of structuring in advance) and the impossibility of knowing a complex business
    domain before working with it (thus needing to advance with the arrow in your
    hand and readjusting the path). This opposition and its resolution are so important
    that they need a dedicated section.
  prefs: []
  type: TYPE_NORMAL
- en: Apparent opposition between architecture and Agile methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A decade ago, when I started understanding the principles of Agile software
    and applying them to the technical team I was leading, it was hard for me to understand
    why a typical Scrum team would be developers, testers, a product owner, and a
    Scrum master. How come there was no architect in there? As it was my business
    card title at this time, I took it personally. This was a bit disturbing since,
    at the same time, I was realizing the huge value Agile had compared to the old
    way we were using by then.
  prefs: []
  type: TYPE_NORMAL
- en: 'After discussing this with many Agile leaders who brought the concept to France,
    I eventually gave a conference in 2013 specifically on the subject of how to bring
    together architecture and Agile methods (French version: [https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/](https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/)).
    After exposing the many contradictions and how an “ivory tower” architect would
    have a hard time in short iterations, I ended up explaining a possible way to
    conciliate the utility of “seeing in advance” and “acting in short iterations
    and adjusting the vision”. Like most patterns, which are not invented but discovered
    independently by many people, this concept of emerging architecture is simply
    the result of any work trying to erase the contradiction stated previously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, time is the great equation solver here: **architecture and short iterations
    are not opposed if you set the time horizon of architecture to only a few iterations.**
    This way, the probability that the target moves a lot is strongly reduced, and
    the architecture remains useful because it helps structure the development of
    these few iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: This solves the difficulty for the architect as their job remains necessary,
    even if it changes quite a lot if you consider the job is to think long shots
    ahead. But then again, even before Agile, architects in ivory towers (imagining
    a long time ahead without a grasp of reality and giving plans to the teams...
    that will not follow them) were largely seen as pointless.
  prefs: []
  type: TYPE_NORMAL
- en: It also helps us understand the concept of emerging architecture, which states
    that, if refactoring is done correctly at the end of each sprint, the final structure
    of the code will be perfectly adequate for the functional needs... just like a
    perfect architectural vision (a long-shot of an arrow in the center of the target,
    in our metaphor) would have done in pure theory (but is practically impossible
    except for very small projects).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to time, semantics also helps remove the contradiction exposed
    previously. The word *architecture* is used in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture as *the emerging global shape of a project* is about the structure
    of the code produced by the team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture as *the act of envisioning a structure* in the application (or
    even higher, in the information system as a whole) is about trying to reach this
    structured state by initially thinking and acting on the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that this theoretical contradiction can be overcome. But that does
    not mean that there is no practical impact, and I will show you one because it
    will help us go back to the notion of aligning the technical aspects with the
    business ones. But before that, I will add an external analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The position of famous architects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like for any scientific discipline, we software architects save a lot of
    time “sitting on the shoulders of giants,” which in our case involves reflecting
    on the state of the art established by real experts of the subject. Martin Fowler
    is certainly one of the best references in software architecture. On this question
    of opposition between “hack, code, and fix” and “big upfront design”, I strongly
    recommend reading the excellent article at [https://www.martinfowler.com/articles/designDead.html](https://www.martinfowler.com/articles/designDead.html).
    The willingly-provocative title *Is Design Dead?* hides the real background subject,
    which is precisely what we’re talking about here.
  prefs: []
  type: TYPE_NORMAL
- en: Martin Fowler’s response to the opposition to architecture is simply to **only
    apply design to increase the capacity of the system to evolve**. As usual, there
    is no “true or false” answer between the two extremes, namely **eXtreme Programming**
    (which explicitly admits its extreme character) and **Big Up Front Design** (which
    often does not admit or even recognize its extreme character and quickly produces
    “ivory tower architects”).
  prefs: []
  type: TYPE_NORMAL
- en: This is where the job of the architect becomes an art as they need to proceed
    with good skills to obtain a subtle balance using some up front design without
    imposing unmovable limits, but still providing healthy guidelines that will truly
    help developers produce faster features *in the long term* (and not get blocked
    by software entropy, as described in Martin Fowler’s article).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since, in addition, change is the only constant in software development, there
    is no use in writing what will be out of target due to functional changes in advance,
    but that does not mean the architect’s job is removed: on the contrary, it is
    about **easing the evolutions in the future**. Architecture is not about UML or
    code frameworks but about guidelines on the way the system should be structured:
    what are its fixed points, what are the articulations around which it moves; where
    should we focus on quality, where can we afford disposable code since the business
    evolves so quickly that investing on solidity is pointless? Sometimes, heavy architecture
    efforts can be justified precisely to accommodate an important module to change
    very frequently. This is, for example, the case of using a **business rules management
    system** (we will come back to this in more detail in [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to coding patterns: the mere fact of working correctly, and
    refactorizing your code continuously, will naturally bring patterns in your code,
    even if you did not know them in advance (I told you that craftsmanship was not
    dead!). An excellent bit of evidence of this, if you have not experienced it already
    by yourself in a coding activity, is that, when you read a lot of code (which
    very few people like to do, even though most great writers have been hungry readers
    beforehand) or when you follow groups of students, you will realize that these
    patterns are often discovered anew. This is the very definition of patterns since
    they are universal and, however, they’re found, if you structure your code correctly,
    the context will make you end up using the right pattern for this precise problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Thinking ahead with function contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, I talked about a practical example to illustrate the opposition
    on long-term and emerging architecture that we talked about before letting the
    expert (Martin Fowler) speak. The example I am talking about comes from my own
    professional experience and is a diagram I have created for a complex scenario
    of interoperation between several applications to implement a functional process.
    When analyzing the business needs at the beginning of the project (or rather their
    initial expression, because they change alongside the project), I created the
    following stream diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Example of a data stream](img/B21293_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Example of a data stream
  prefs: []
  type: TYPE_NORMAL
- en: Following [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069), you should normally
    recognize the duality between the function and the software implementation, and
    in particular, the essential recommendations that dependencies should point to
    level 2 instead of directly to level 3, which would result in point-to-point interoperation,
    creating a “hard coupling” of software solutions (we will come back to this expression
    shortly if you do not know what it means).
  prefs: []
  type: TYPE_NORMAL
- en: Even if we use machine symbols, the bottom layer is really about software servers,
    hence layer 3\. The intermediate zone is also part of the software layer as it
    contains connectors destined to transform API calls into proprietary calls if
    needed. The orchestration layer at the top shows how functional tasks expressed
    by API contracts are put together to create fine-grained processes. It can mostly
    be considered as layer 2 in the CIGREF map, with some touches of layer 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason I’m showing this schema is twofold. First, it illustrates when architecture
    goes too far and how emerging architecture can help save time: I drew this when
    I was a young architect, not fully aware of the concept of emerging architecture
    and it went too far. Sure, it helped to have a project vision, but in the end,
    almost none of the connectors and data streams worked the way I envisioned they
    would and time was wasted there.'
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, this schema provides more detail on the interaction between layers
    2 and 3 of the CIGREF map, showing they are about API contracts (and we are not
    talking about API implementations with code, just contracts, which are lists of
    functional capabilities expressed in precise, technical terms). This is where
    it becomes particularly interesting because, despite the technical implementation
    not being (at all) the one envisioned and despite the orchestration of the streams
    having changed many times since the original blueprint, **it turned out the API
    contracts have remained unchanged for** **many years.**
  prefs: []
  type: TYPE_NORMAL
- en: I cannot tell you how much satisfaction it has brought me to realize this a
    few years after the project. When thinking about the code, my initial vision was
    a failure and a very small portion of it had been implemented. When thinking about
    orchestration, the way the APIs are glued together has changed due to modifications
    in the processes and the business rules. But the API contracts I designed with
    the business-knowledgeable people were still there years after, basically unchanged,
    and their extreme alignment with the business had allowed all these changes to
    happen with very limited impact in code or customization.
  prefs: []
  type: TYPE_NORMAL
- en: In short, code architecture should be limited to a few iterations. But business
    alignment architecture is an investment worth doing, even at the very beginning
    of the project, because its value will not decay.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why contract-first API design (again, I am not talking about API implementation,
    but solely the definition of the contract) is so important: the contracts can
    be established with pure functional knowledge, leaving every technical aspect
    outside, thus ensuring a very stable base for the definition of business modules
    and their dependencies that will serve as a strong foundation for the software
    implementations to come afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: We will come back to this notion of contract-first thinking in *Chapters 8*
    and *9* but for now, please just keep in mind that the time horizon has an impact
    on architecture in its two meanings. For technical architecture, the time horizon
    should be limited for “the arrow to reach the target.” But for the functional
    architecture, the time horizon does not stand any limit because in this case,
    what we are doing is getting to know where the target is. This is a prerequisite
    at even just thinking of hitting it!
  prefs: []
  type: TYPE_NORMAL
- en: The concept of technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technical debt may be one of the most discussed concepts related to IT management
    in the past decade. As the quality of software is a fundamental goal of this book,
    it is something we have to clearly describe.
  prefs: []
  type: TYPE_NORMAL
- en: The general definition of technical debt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are reading this book, you are certainly interested in software quality
    and how to architect things correctly, so you most certainly have a good grasp
    of the concept of technical debt, or at least have been exposed to it. Nonetheless,
    I will give a quick definition of it so that you can try and formalize it.
  prefs: []
  type: TYPE_NORMAL
- en: What is technical debt?
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt is the amount of accidental complexity you have allowed to enter
    your project, together with its increase in intrinsic complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s decompose this a little. When you develop a software project, it always
    aims at producing a function on a given business domain perimeter. There is an
    inner, definite, stable complexity that comes from the domain you are trying to
    address: it is much simpler to print an address on an envelope than to optimize
    the flights for an international airport.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Or is it? Just as a side note, take great care to always know exactly what
    we are talking about when business needs are expressed, and if you cannot, do
    not hesitate to formulate caveats about what can and will be done. Explaining
    the functional needs with a simple sentence does not necessarily mean that the
    objective is itself simple, and much can be hidden behind this. In this example,
    you should immediately have the reflex of asking how the addresses should be printed,
    if there are different envelope formats to support it, what the international
    address is, if there are some norms and standards to respect, how the data will
    be provided, and* *so on...*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This first type of complexity is often called **intrinsic complexity** because
    it comes with the functional business domain you want to address and there is
    no way to escape it. Short of doing less than your client expects, there is no
    way you can reduce this. This does not mean you should take all this complexity
    right away: remember the Agile approach to cutting projects into small, manageable
    chunks that will be dealt with one at a time (“How do you eat an elephant? One
    bite at a time”). And if your customer wants you to go all the way to treat the
    complete business domain function and complexity, you will simply add as many
    sprints as needed to reach the desired level of intrinsic complexity. It will
    only take longer and, thus, be more expensive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s cover the second type of complexity: the accidental one. For this,
    let’s take the first example of expressed functional need, namely printing addresses
    on envelopes. To keep this short, suppose we only have to print standard addresses
    with four lines on a standard A5 format envelope, that the data for the addresses
    is provided in any format we want, and that the hardware part (a special printer
    for envelopes) is taken care of. How could we, as developers, implement this requested
    function?'
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest ways that comes to mind is to use the fusion function of
    an Office Word application, consuming the XML data from the integrated assistant,
    and saving the file for future uses by the client.
  prefs: []
  type: TYPE_NORMAL
- en: But there is (way!) more than one way to implement a function with software
    and you may very well find yourself using a Java application that has been created
    from scratch to read addresses from any format, create a PDF document, and send
    it to the printer. It is not that complicated, but there are already more moving
    parts than in the first technical solution... and their maintenance is yours,
    instead of the Office editor’s! You will have to take care of the Java runtime
    with a version compatibility issue. The PDF generation can be a little tricky
    too. And maybe the developers will have left a few TODOs in the code, indicating
    that some corner cases need to be solved in the future. In the end, though not
    extremely complicated, this solution is more technically complex than the first
    one we proposed, though it reaches the same objectives in functional terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The delta is what we call accidental complexity in that this is the complexity
    that – contrary to the functional one – could have been avoided. It is sometimes
    confused with technical complexity, but this is not the right wording. There will
    always be some kind of technical complexity to implement a function: concrete
    execution cannot come from nowhere and there must be some kind of software to
    execute a function. Accidental complexity is, as its name suggests, the level
    of technical complexity that sits on top of the minimal necessary effort to implement
    the functional need. Therefore, it is considered an accident because things could
    have been done without it, and it is there because of external, unwanted reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: Causes of technical debt and its relation to time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What are these unwanted reasons? Well, there are so many of them that it would
    be difficult to list them all: laziness, lack of time to reach the appropriate
    quality, lack of training, the tendency that we all have to use a well-known technology
    rather than one that would be a better fit but would have to been learned first
    (“when all you have is a hammer, every problem looks like a nail”), lack of technical
    watch, with the result that we simply do not know about the mere existence of
    a better way to do things, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of these reasons, there is another one that has a deeper reach, namely
    that most technical experts, deep inside of them, actually *love* complexity.
    I often compare developers to gases (without malice: I am one myself, have been
    for decades, and still fall out in this trap): they will always occupy all the
    space you give them.'
  prefs: []
  type: TYPE_NORMAL
- en: '*This is another similarity with thermodynamics since I was talking about entropy
    as a metaphor for* *technical debt.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you a (not so unrealistic) example. Form a million-dollar team
    with software experts, asking them to create a function that calculates the sum
    of two integers, and you have a high probability that none of them proposes to
    simply use `Int32.Add`. They will work under the hypothesis that you know what
    you are doing: since you set up such a great team and budget, you must have elevated
    goals of creating a high-performance function to add integers with virtually no
    limits in size, working in all conditions with predictable outcomes.'
  prefs: []
  type: TYPE_NORMAL
- en: This is because developers are engineers and rarely business people. If they
    were, the first one you contacted in the team would tell you that you need no
    other hire and that they will take the whole job by themselves for only half the
    million dollars. Following this, they would put together a complex piece of machinery
    that simply calls `Int32.Add`, makes you wait for a few months to hide the extreme
    simplicity of it, and delivers the end product to you afterward.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key findings is to always give some boundary constraints to your
    developer teams; otherwise, they will add accidental complexity, sometimes even
    a large amount of it... and it is always a pain to know your best customer’s business
    process is blocked by a bug in a function that was added “in case we need it in
    the future” by an overzealous developer.
  prefs: []
  type: TYPE_NORMAL
- en: This first set of reasons for technical debt is quite critical of the developers
    but wait – there’s something to say about functional people too!
  prefs: []
  type: TYPE_NORMAL
- en: 'How about laziness in explaining the precise need? Lack of communication with
    the developers? Extreme reliance on them to figure out the technical complexity
    (previously, I talked about the danger of a one-sentence business needing expression:
    it often hides a lack of understanding by the requester itself)? Lack of availability
    to test the results and adjust the functional request? The list could go on, as
    well as picking on our beloved product owners. It is not because they are not
    technical themselves that functional actors cannot cause accidental complexity!'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these changes in the functional definition of what should be done have
    a huge toll on technical implementations: we do not change code like we change
    a wheel on a car! There are links between the functions, and the overall complexity
    of code escapes the human brain’s capacity after a few lines only. So, if indications
    change all the time, the result will undoubtedly be some low-quality code cutting
    corners on quality, full of “temporary” workarounds (who are we kidding? We all
    know they will stay there until the application end of life), `TODO` indications
    for a hypothetical colleague to magically appear later and refactor the dumb incomplete
    code into a marvelous elegant new version, and so on. I am not even talking about
    dead code that will bloat applications forever, simply because the complexity
    – and lack of documentation – just makes it so risky to remove it and create side
    effects...'
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt’s relation to time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Why, why, why is there so much junk code in today’s software industry? Well...
    time, again. Technical debt is another concept that’s strongly related to time.
    Try to operate a root cause analysis on the aforementioned symptoms and, after
    a few consecutive “whys,” you will almost always reach the same answer: “not enough
    time.” Lack of junior training? We do not have the time. Lack of product owner
    availability? They do not have the time. Absence of documentation? We do not have
    the time...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time also appears in another way in technical debt: as mentioned previously,
    technical debt, like entropy, always grows. And like entropy, there may be some
    special places where disorder is locally reducing, but this is always by consuming
    energy and growing disorder in other places, which makes entropy grow in the whole
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt is the reason why there is such a small portion of software applications
    that can still run fine after more than a decade. Casual observers may think this
    is because software is a world of fast changes, but when you think of it, change
    is not that quick. Java was the thing of the 90s, .NET came a decade later, the
    2010s saw the use of JavaScript rise to things it was not made for, and the 2020s
    marked a few attempts at new languages with none marking its time for now – not
    such a tremendous rate of change... So, why do we change software so quickly?
    Simply because they are so full of technical debt we cannot maintain them in a
    costly manner anymore!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is another link to time that technical debt exposes: as time goes by and
    technical debt grows, the time toll it takes on the project by slowing down development
    goes up. This is why technical debt is called this: just like financial debt,
    you must pay the interest, so long as you keep some borrowed capital. The higher
    the capital borrowed (the depth of your technical debt, which is related to the
    number of times you have been cutting corners in your development process), the
    higher the interest (the additional time it takes to add a feature to your application).'
  prefs: []
  type: TYPE_NORMAL
- en: And since we’re talking about a linear relationship between the level of debt
    and the time it eats away at software development, that means there is a rate,
    just like in financial loans. Now is a good time to analyze this rate in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Debt or usury?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of us make loans, at least once in our lives, to buy a house. And it makes
    sense to pay a few percent of the amount obtained compared to the advantages we
    can draw from them: owning the house at the end of the loan, not paying rent anymore,
    and more. Depending on the economic context (and individual preferences also take
    a great part in the choice), there may be some cases where it is better to rent
    and not buy but, in the longer term, building some capital always wins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this only holds true because the rate is small enough! How comfortable
    would you be if you had to borrow money at a rate of 10%, 20%, or even 50% interest
    per year? In this case, of course, nobody would ever borrow some money as, 2 years
    later only, the loan would have cost as much as the capital: in this case, you
    are way better off holding off your purchase for 2 years and buying cash.'
  prefs: []
  type: TYPE_NORMAL
- en: Except there are cases where you cannot do this. Sure, you can rent a place
    to live instead of buying it. But how about when you need money to eat or have
    a temporary shelter because of a hard incident in your life? Without regulation,
    the banks could increase their rates as much as they want, and, in some cases,
    you would be obliged to take the loan anyway because your life depends on it.
    In this situation, you would have to reimburse this when your situation improves,
    but the rate is so high that it would eat up everything you have saved and you
    would end up contracting another loan, in a never-ending poverty loop. This is
    to avoid the situation that, for centuries, banks and even individual actors performing
    financial operations have been limited by governments through what is called the
    **usury rate**.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not know this financial term, usury refers to lending money at such
    a high rate that it makes it practically impossible to reimburse the capital.
    Society improvement is why it is now illegal in most countries, where maximum
    rates are fixed. For example, in France, at the time of writing, the usury rate
    was 5.33%, which means that banks are not allowed to lend money at a rate higher
    than this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go back to technical debt and evaluate the rate at which we borrow.
    This isn’t very hard to find since the Gartner study on the cost of maintenance
    in information systems has already been cited twice previously: it is a flabbergasting
    70% of the IT budget! Okay, this does not account for a 70% interest rate in technical
    debt, because you should also count the benefits the IT systems offer the company
    and the cost of doing otherwise. I will let you do the calculation as this can
    vary depending on your organization’s context. But all in all, there’s a chance
    that you will reach a figure that you would, by no means, tolerate from your bank
    on a financial loan, and that will be *way* higher than the usury rate.'
  prefs: []
  type: TYPE_NORMAL
- en: So, why should we tolerate this? Reasons for the situation have already been
    cited previously; now is the time to lay a few solution paths to get rid of excessive
    technical debt. This is what we will do in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to balance technical debt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'People often talk about fighting technical debt or suppressing it. This is
    not the right wording as it bears the meaning that technical debt (and thus accidental
    complexity) should be downed to zero. This sounds like a hard thing to obtain
    as perfection costs a lot of money: in fact, your goal should not be removing
    all technical debt but rather keeping it in control, just like you should not
    try and find a 0% interest rate loan (you never will) but rather find the right
    rate that allows your project to be more cost-effective, balancing the interest
    rate, the amount and duration of the loan, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: So, a bit of technical debt is acceptable. If you have to roll out this feature
    in time for the yearly seminar with all the customers, who will care that you
    did not put logging in place for the occasion? The only really important part
    is that you have placed a ticket in the development tool and the product owners
    agreed that it will be done in a coming sprint, before putting the feature into
    production. If they come back on their promise and try to delay this “technical”
    ticket and make a fuss about it, remind them of the consequences, send an email
    explaining how this will impact the future, ask for their written agreement of
    responsibility, escalate it to the big boss... whatever it takes to get this feature
    back on track! Otherwise, it will be your responsibility that technical debt starts
    to grow.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the best way will always be simply to not let the technical debt
    slip away. Sure, it may sound easier to say than to do, but knowing how the problem
    can arise is already a great step forward. Remember that the mere concept of “technical
    debt” was not known or formalized in the 2000s; now, even non-technical managers
    working in IT or software development may have heard about it. This is already
    a big improvement and lets you make an educated point to them, explaining how
    reduced delays and lack of training or time for documentation and quality will
    end up in slow development in a few months. Again, if you are a technical lead
    or a CTO, controlling the technical debt is one of your first and most important
    duties.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you may be in a situation where the technical debt of a software application
    is already high – either because you have let it slip in the past (silly you)
    or because you are responsible for a piece of software that was already in a bad
    state. First of all, make it abundantly clear – if it is not perfectly known by
    stakeholders – that the situation is bad: you wouldn’t imagine how long bad software
    teams can invent pretexts for their inability to deliver, and you do need to have
    the capacity to improve the situation. If you accept the job but do not quickly
    issue warnings about the unstable situation, everyone will assume the software
    is fine. And you will not be able to alert about its state later, because, as
    you are a technical expert, everyone will logically consider that you should have
    seen it before, particularly if it is such a mess as you describe. You might even
    find some inconsiderate former owners ready to swear that the software was perfectly
    fine before they handed it over to your team!'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, establish a map of the technical debt in the application (using
    the CIGREF four-layer map, not forgetting that technical debt can even come from
    badly designed processes or ill-defined functions, with incorrect governance).
    There might be some places where a bit of technical debt is acceptable. There
    will be some others where it eats most of the maintenance time and budget and
    where it has to be urgently taken care of. When evaluating the risks of correcting
    this, lots of people who have participated in the initial mess will tell you that
    the impacts will be so high that trying to correct the software will not work,
    and maybe even that they already tried and it failed. In this case, make your
    best estimations and ask for managers to decide and take ownership. When announcing
    that rewriting the concerned feature will cost 100,000 dollars and will come with
    a 20% risk of impact worth 200,000 dollars more, everybody around the table will
    certainly frown... but if you also explain that this software has cost the company
    40,000 dollars every year for the last decade, thus already sending 400,000 dollars
    down the drain, the decision makers will be quick to perform the calculation and
    give you a go.
  prefs: []
  type: TYPE_NORMAL
- en: This means you may reimburse some of the capital (in the metaphor of financial
    loans) by removing technical debt, even if it is generally difficult to explain
    the benefits of this to the managers. After all, the business impact is not immediately
    perceivable and no customers are complaining that the software doesn’t work. So,
    again, you really must put a strong case together by evaluating how much time
    technical debt costs you, what features could have been done for your customers’
    delight at the same time, and how much time it will take to reimburse the debt
    and bring the application to a sound level of quality, without forgetting the
    impact analysis – there is always a risk in “changing the engine while the car
    is running.”
  prefs: []
  type: TYPE_NORMAL
- en: The Big Bang temptation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How about the Big Bang approach? You know – throwing it all away and restarting
    a new, fresh, clean product. The dream of all engineers... **If you think about
    it, this is not the right situation. If it happens without you being able to prevent
    it, then this is for the best.** Let me explain this: the Big Bang approach, however
    seductive it may be, is *never* the right one. If you have a technical debt problem
    in your software, this is because your development process is wrong. So, if you
    start another application hoping it will be better than the previous one without
    fixing the process, you will simply lose a few years and reach the same state.
    If you know what was wrong in the process and have corrected it, the application
    will improve, so there is no use in throwing it anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that the Big Bang never happens? No, of course. Even if it is
    not a good idea, people still try to do it... and fail. But a clean slate is such
    an appealing idea that application owners, even though poor in marketing in all
    other aspects, will go to great lengths to obtain an agreement and budget from
    the stakeholders. They will do so by promising increased performance, providing
    better time-to-market for future features and ease of improvement, and so many
    other qualities that participants will eventually wonder why this had not been
    proposed earlier. And again, they will fail. This is not me saying this, but a
    return on experience that you will find from about everyone with experience with
    these kinds of projects.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few exceptions, like in any rule, and some Big Bang projects have
    indeed succeeded. I have noticed this in projects where the Big Bang was not intended
    by the teams but experienced through the fact that the old project simply collapsed
    down on its weight. In France, where I live, we have had many cases of such huge
    government projects where the failure was so big that there was nothing to be
    saved from the project and new software companies had to restart from scratch.
    The “Louvois” project (managing soldiers’ salaries) comes to mind, with millions
    of euros being thrown away with the project. To come back to what I said before
    about shared responsibilities in these events, technical problems were abundant
    in this project, but there was also a huge lack of functional feature descriptions
    and almost no cutting down of the project, which led to this industrial catastrophe.
  prefs: []
  type: TYPE_NORMAL
- en: The different types of coupling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coupling between applications is the last concept we well talk about concerning
    time... Just like technical debt is a little too much of something that must exist
    (technical complexity, to implement functional complexity), coupling is the name
    given to a dependency that is a little stronger than what’s needed from a functional
    point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example: you want to send a contract with an electronic signature
    to one of your customers. Of course, the contract module will have a dependency
    on the electronic signing application, as well as on the module providing the
    information you need about this customer (namely, their financial or legal contact
    email address). But there are dependencies and dependencies...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that the first one has been very well designed, and you can simply
    send a contract for a signature by calling an API in your information system that
    will then take care of everything. You do not even need to know what company will
    do the actual work, nor how this will be legally binding: you simply call the
    API and if it returns an OK (`HTTP 200`, in technical terms), you are fine. This
    kind of dependency is a low-coupled one: things may change in the implementation,
    with your company preferring another electronic signature vendor, or routing the
    documents to sign in different ways, depending on who is calling the API: you
    do not care as you simply call something such as [https://mycompany.com/document-sign](https://mycompany.com/document-sign)
    with a `POST` command. This is all you know; whatever happens behind the scenes
    is not your concern. You still depend on the function’s completion to get your
    contract signed but this dependency is very flexible and you may never have to
    change anything in the way you call the function; the coupling you are subject
    to is low.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take the second dependency and imagine something at the other end
    of the spectrum: you need to get the email of the financial or legal contact for
    the customer, and to do this, you must know the customer ID. Sadly, this is not
    the same identification as the one you use internally in your service. So, first,
    you will have to call the service in charge of customer references to know the
    exact identification to use. When you have this information, you will have to
    dive deep into a folder shared through its IP number and go down the folder structure,
    starting with the year the consumer was recorded (it looks like it’s the first
    two numbers of the identifier you got, but you’re not sure), then a folder named
    `Contact`, and final a folder with the kind of contact, namely `FIN` for finance
    and `JUR` for legal. There, you will eventually find a Word document in which
    you will have to skip through some useless information before you finally get
    to page 2, where you find the email address you have been looking for all this
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: This sounds far-fetched but this is a real-world example I have seen during
    my consulting years (admittedly, though, it was one of the worst information systems
    I have ever seen in the 15 years I was working on customer systems). And we’re
    not even done yet! Some customers had multiple identifiers; and when they were
    deleted and re-entered in the database, their identifiers were recovered... but
    their data was in the folder corresponding to the renewal year instead of the
    initial creation year. At some point, the `Contact` folder was renamed `CONTACTS`,
    ruining the few attempts at automating information recovery, and the codes for
    the types of contacts were changed. Finally, the Word documents in the folders
    evolved in their format and the email address was not to be found at the same
    place, leaving people wondering if the new location contained the right data or
    if it was about new email information. All this useless complexity made this dependency
    on an email address one with a huge strong coupling (again, this is the worst
    example I have seen).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, low-coupling is generally better but, just like for technical debt,
    it is OK to have some coupling and the important thing is to control it. There
    might be some places where extremely strong coupling is not a concerning issue.
    For example, tight coupling to a budget structure is usually not a big deal because
    these structures are regulatory imposed and they change with a frequency calculated
    in decades. So, it’s no big deal if you have to radically review your processes
    and software applications in this case. On the other hand, you will want low coupling
    if you use a commercial dependency from a provider that tends to increase their
    license price when they realize you do a fair deal of business with their tools
    (you most certainly know of such editors). In this case, showing your CEO/CFO
    that you have made it possible to switch providers with a few changes of parameters
    and a small migration procedure will make you their beloved CTO partner as they
    will return to negotiations with the supplier having extremely strong arguments
    and an easy escape door if the latter will not change its pricing policy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, coupling is also related to time. There are lots of kinds of coupling,
    but there is a category of coupling that is chronologically measured. If, to proceed
    with a task in module A, you need a piece of information that comes from module
    B, the dependency is synchronous (and you will certainly find it is implemented
    through a synchronous call such as an HTTP `GET` call). If your process in module
    A can continue freely after it has called a function in module B, the dependency
    is asynchronous (and you will certainly see it as, for example, a `POST` API that
    returns a callback URL that you may call afterward to see if the job is done –
    or even better, you can register a webhook to get informed once the job is terminated;
    this will send you another URL you can contact to get the result of the external
    task). In [*Chapter 17*](B21293_17.xhtml#_idTextAnchor608), we will come back
    to this approach and, in particular, explain the difference between orchestration
    and choreography and when to use each of them – as always, there is no true or
    false here and the right technology depends on the exact functional need and its
    context. Ideally, both approaches are used in a good information system, each
    in the context where they are the preferred solution.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should now have a clear understanding of technical debt and
    how it affects the evolution of information systems. As time goes by and technical
    debt cumulates, IT assemblies slow down in their evolution and sometimes their
    sheer functioning because of technical debt. What can we do about this? Well,
    this is the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: An experience-proven blueprint method for information systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section, I would like to explain a method I have been using to
    create blueprints of information systems evolution that I have been perfecting
    in the past few years with several industrial customers. There’s nothing special
    in there, nor particularly innovative, as it is just applying common sense to
    reach function targets... but it is formalized enough so that I can imagine you
    finding value in the description of the steps used.
  prefs: []
  type: TYPE_NORMAL
- en: The full method is quite elaborate and would need a dedicated book, so I will
    concentrate on a case that is precisely the subject of the chapter, namely dealing
    with time and technical debt. The example I’ll use will involve extracting a monolith
    software application ridden with technical debt but sadly used as the core of
    the customer company’s business (yes, a worst-case scenario). A multi-year planned
    blueprint had to be created to extract this dependency while limiting the impacts
    on the daily business. The following sections explain how this has been done,
    concentrating on the method and not showing the exact actions, to maintain the
    confidentiality of the customer.
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with... mapping!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained in [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069), we have to
    start with a formalized mapping of the problem, and the CIGREF map was established
    around the perimeter to be studied. As the problem was on the functional and software
    layers, the processes were not represented at all and the fourth layer regarding
    hardware infrastructure just skirted over because all we needed there was the
    global cost of associated machines. The result was the following structure, where
    you can spot the top-left large white square in the software layer (this was the
    monolith subject we studied):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The evolution of the preciseness in maps](img/B21293_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The evolution of the preciseness in maps
  prefs: []
  type: TYPE_NORMAL
- en: 'This is something so important that I want to stress it again: **only the parts
    related to the study have been mapped**. Remember this graph from the previous
    chapter?'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Example of a real-world map with reduced content](img/B21293_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Example of a real-world map with reduced content
  prefs: []
  type: TYPE_NORMAL
- en: It was applied there because, with 20 software applications or so, it was only
    a small part of the whole information system of this company. As for the business
    capability map, it was more exhaustive, but this is only because we needed the
    whole perimeter for another project. As you can see, only a few of these functions
    were related to the software applications under study (following the lines between
    layer 2 and layer 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on the giants’ shoulders, I will simply recall that what Martin Fowler
    states about classes applies perfectly to functions and software applications
    mapping: Martin recommends not to draw all classes in UML diagrams, only important
    ones. He then goes on to explain that the main problem with diagrams is that people
    drawing them try to make them comprehensive. Diagrams should help us understand
    concise and clear information, while only the code should be the source of comprehensive
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the atomic actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since extracting the monolith at once and changing it for a new application
    was not possible (remember, “No Big Bang... ever”), we had to devise a way to
    progressively extract functions from the application and migrate them, step by
    step, and with limited impact on new, modern implementations. But in which order?
    This is where the map will help, showing the modules and their dependencies. From
    here on, I will use arbitrary schemas to better explain the approach, even if
    they deviate from what happened in this project. Let’s imagine that the three
    important features we need to “rescue” are based on five software modules with
    the following dependencies (beware, there are functional implementations – links
    between layer 2 and layer 3, and technical couplings – links inside layer 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Simple example of functions and their implementations](img/B21293_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Simple example of functions and their implementations
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve done this, we can use the information provided to draw two chronological
    approaches (this is where the time relationship is the most present in this section).
    This first one could be, for example, to try and get the first functions out as
    quickly as possible (time-to-market strategy):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Scenario with time-to-market priority](img/B21293_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Scenario with time-to-market priority
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the duty of rewriting the engine that features (or functions)
    1 and 2 eventually depends on is left for later, but at least function 3 is quickly
    available in its new implementation. The problem with this approach is that, since
    it leaves the technical debt for later, the development process will remain slow
    and features will be harder to release until the end of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This calls for another approach where technical debt will be addressed first.
    The advantage is that features will flow quickly in the future. However, the shortcoming
    of this alternative approach is that it will take some time before we see the
    result (and as explained previously, this is where you’d better have a strong
    business case to convince the stakeholders to finance this investment). This second
    approach can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Scenario with TCO priority](img/B21293_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Scenario with TCO priority
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up the advantages and drawbacks of each approach, it is better to superimpose
    the two diagrams, which puts forward the main differences, noted here by letters
    A and B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Graphical difference between the two scenarios](img/B21293_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Graphical difference between the two scenarios
  prefs: []
  type: TYPE_NORMAL
- en: The delta marked `A` shows the difference between **initial** time-to-market.
    This happens to be an important criterion in lots of businesses because customers
    need to be truly convinced that you are going forward. Whatever the trusty relationship
    you have with your customers – or internal users, by the way – it is hard to let
    them without any demonstration of what you have been doing for months, and business
    owners know it. In the first scenario, feature 3 arrives sooner on the market,
    and may then participate in the financial investment for the rest of the project.
    In the second one, the first feature to be released not only arrives later but
    is not the same, which can make a great difference depending on what is most important
    for the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The delta marked `B` shows the difference in total time spent on the project:
    while scenario number 2 shows the first results less quickly than scenario number
    1, it solves more technical debt at the beginning of the project, which will make
    for easier and quicker developments for the remaining time. This is something
    that should be taken into account because a development team costs a lot of money.
    Depending on the complexity of the project, this delta may become very important
    (note that in the preceding diagram, the scales are completely arbitrary and do
    not represent anything representative as it depends on your project).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established the two basic scenarios, we will dive into something
    a bit more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing the actions based on business criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a used trick, but presenting two extreme alternatives often helps in getting
    stakeholders to choose an intermediate approach. There are good chances that the
    decision will not be between the two extreme approaches that have been explained
    previously but for a compromise somewhere in the middle. But then again, how do
    you adjust the cursor? What criteria can you use for this?
  prefs: []
  type: TYPE_NORMAL
- en: Some criteria immediately come to mind for any business-savvy software architect,
    namely gross income/turnover and profitability rate. Often, I let the third criterion
    be something vague that stakeholders evaluate in terms of importance to the strategy
    of the company (they know more about this than any IT person). What is important
    at this point of the project is that these criteria should be evaluated fast,
    in a “planning poker” mode, and that they remain limited in number. I use levels
    of one to three stars for each of the criteria, and no more than three criteria
    as a whole. This is generally enough to find out what the best scenario is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To come back to something a bit more realistic, here is an example of such
    a decision table that I have created with another company I advised (some entries
    have been deleted or renamed as they would have revealed too much):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Prioritization of projects through the chosen criteria](img/B21293_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Prioritization of projects through the chosen criteria
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, in this case, you will note that the criteria were not the “standard”
    ones proposed previously. Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of processes improved (in layer 1 of the map)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The estimated impact on overall productivity (this was an industrial production
    company)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The estimated impact on growth (they were operated on a rapidly consolidating
    market, where small companies were bought by bigger ones, so quickly growing was
    of utmost importance to flourish)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, a column was added to the traditional estimated weight of the project
    and delay estimates, namely for the impact and risks associated with the project
    (which is a sound approach and should be done for any such projects). To stress
    the fact that ease of elaboration of such projects is much more important than
    completeness and exact respect of the methodology, here is what the table initially
    resembled, after the 2 hours of analysis directly on a whiteboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find this whiteboard image on GitHub: [https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg](https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg)'
  prefs: []
  type: TYPE_NORMAL
- en: A few last words on time, semantics, and alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why a complete chapter on the importance of time in software development? You
    might have wondered this and I hope that I have convinced you, not of the importance
    of time, which is a given in any project, but rather of the fact that lots of
    problems in software development and information systems design should be watched
    across the prism of time management.
  prefs: []
  type: TYPE_NORMAL
- en: 'It often happens that, taking it for granted as it passes by without anything
    we can do about it, we forget about time in our activities of design, not taking
    into account the perspective of the future. How many information systems were
    born ill because they were designed to solve today’s problems, without thinking
    of how business will evolve in the future? Technical evolution, sure, we can handle
    them, and we do more than we should sometimes by preparing the system for the
    next framework, the future technology, and so on. But this is not the issue! The
    important thing is the business domain functions: they are changing as well and
    the information system has got to remain aligned with the business, not to some
    technical evolution that may be a fad in a few years.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time is also often forgotten when we tend to analyze concepts as stable, simply
    because we do not use a broad enough time spectrum to explain them. Lots of concepts
    evolve while seemingly being extremely stable. In [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069),
    I explained how the concept of “customer” is a business rule and not a stable
    entity: a customer can be anyone who bought something in the past 12 months for
    commerce while being anyone who has done so in the past 24 months for marketing.
    And maybe maintenance will have a list of customers based on who has got a running
    guarantee. These rules, like any business rules, can change in time. At some point,
    maybe the big boss will get tired of commerce and marketing not communicating
    the same numbers and evolution rate of customers and will force them to adopt
    a common definition; maybe the guarantee duration will change, which will affect
    the maintenance list of customers. Who knows? One thing is sure: if you have not
    considered time, you will have trouble.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A small anecdote – that I hope you will find revealing of the importance of
    time – to conclude this chapter: I happened to advise an organization that, through
    fusion with another one, had to change their logo. Since these organizations were
    subject to political changes after elections, the people there wanted to make
    it easier to adjust their logo in the future because this operation was extremely
    long and boring: the logo had to be changed in every message template from every
    application of the information system that would produce documents, and we were
    talking about thousands of templates and months of work to adjust the logo everywhere.
    The initial approach was to propagate a server share path everywhere: this way,
    changing the logo would automatically happen everywhere when the files were modified.
    Luckily, we had time to think about it a bit more and it was decided to switch
    the approach to a URL exposing the logo resource in different formats through
    content negotiation, and using an additional URL query parameter to indicate the
    reference time for which the logo was to be sent. This way, most applications
    who simply created documents along the way did not have to care about passing
    this parameter and would get the latest logo bitmap resource; but for the few
    legally-constrained applications that had to be able to fusion a letter at a given
    time in the past with the exact pixel-perfect form, it remained possible to do
    so without the new logo appearing on a old letter, which would have cause trouble.
    Today, this organization has equipped itself with an archive-capable content management
    solution, which now solves the problem in a much better way. Technical evolution
    took care of the functional need in a new way. Again, it was only a question of
    time!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one last note about the importance of time and technical debt in information
    systems: there can be things even worse than technical debt, in what we could
    call “functional debt” or, more precisely, “semantics debt.” This will be the
    subject of [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318). But for now, we are
    going to end the theoretical part of this book with something that is extremely
    theoretical: a perfect information system!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have shown how time influences everything in the analysis
    of an information system since it is a living entity that evolves throughout its
    use. Time is so current in our daily lives that it is often forgotten when structuring
    an information system, but it is the key to designing it in such a way that it
    will stand the test of time and have a reduced TCO.
  prefs: []
  type: TYPE_NORMAL
- en: The Agile approach is one of the first methods that dealt with this time-related
    reality, and it has radically changed how software is created and handled. The
    same approach can be applied to systems as a whole set of applications working
    together, which means the technical debt can be handled globally and kept under
    control. This notion of technical debt is not well named and, as a future chapter
    will show, semantics is very important, so I would recommend keeping this in mind
    at all times and, if possible, adjusting the naming, as was proposed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book contains lots of recipes to help you reduce this technical
    debt or at least keep it to an acceptable level. But in the next chapter, we will
    try and imagine a perfect information system, with little or no debt or coupling.
  prefs: []
  type: TYPE_NORMAL
