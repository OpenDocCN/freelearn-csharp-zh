- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Data Binding Building Blocks in .NET MAUI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET MAUI中的数据绑定构建块
- en: In the previous chapters, we familiarized ourselves with the core concepts of
    the MVVM pattern and explored the fundamentals of .NET MAUI. With the knowledge
    of MVVM principles and .NET MAUI’s capabilities, we can now start looking at how
    to apply MVVM to .NET MAUI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们熟悉了MVVM模式的核心概念，并探讨了.NET MAUI的基础知识。在了解了MVVM原则和.NET MAUI的能力之后，我们现在可以开始探讨如何将MVVM应用于.NET
    MAUI。
- en: Data binding, a crucial component in .NET MAUI, is the key enabler of the MVVM
    pattern. In this chapter, we will focus on the fundamental concepts, components,
    and techniques that facilitate data binding in .NET MAUI. These critical elements
    link the View and ViewModel layers of your application, enabling efficient communication
    and ensuring a clean separation of concerns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是.NET MAUI中的关键组件，它是MVVM模式的关键推动者。在本章中，我们将重点关注促进.NET MAUI中数据绑定的基本概念、组件和技术。这些关键元素连接了应用程序的视图和ViewModel层，实现了高效的通信并确保了关注点的清晰分离。
- en: 'In the course of this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Key components for data binding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定的关键组件
- en: Binding modes and the **INotifyPropertyChanged** interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定模式和**INotifyPropertyChanged**接口
- en: Handling interactions with the **ICommand** interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理与**ICommand**接口的交互
- en: By the end of this chapter, you will have a solid understanding of the essential
    data-binding building blocks that come with .NET MAUI. This will help you understand
    the inner workings of data binding in .NET MAUI and what role each component plays.
    With this foundation in place, you will be well equipped to explore more advanced
    topics and techniques in the following chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入理解.NET MAUI附带的基本数据绑定构建块。这将帮助你理解.NET MAUI中数据绑定的内部工作原理以及每个组件的作用。有了这个基础，你将准备好探索下一章中更高级的主题和技术。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Throughout this chapter, we will add functionality to the **Recipes!** app.
    All required assets needed to follow along, including all the code used in this
    chapter, can be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向**Recipes!**应用添加功能。所有必要的资源，包括本章中使用的所有代码，都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03)。
- en: Key components for data binding
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定的关键组件
- en: 'Let’s first turn our attention to the core components that enable data binding
    in .NET MAUI: `BindableObject`, `BindableProperty`, and `BindingContext`. These
    components work in harmony to establish and manage the connections between your
    Views and ViewModels. Understanding the role and functionality of these elements
    is crucial, as they form the backbone of data binding in .NET MAUI.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注使.NET MAUI中的数据绑定成为可能的核心组件：`BindableObject`、`BindableProperty`和`BindingContext`。这些组件协同工作，建立并管理您的视图和ViewModel之间的连接。理解这些元素的作用和功能至关重要，因为它们构成了.NET
    MAUI中数据绑定的骨架。
- en: Let’s quickly discuss the elements that play a role in data binding.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速讨论在数据绑定中起作用的元素。
- en: Elements of data binding
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定元素
- en: 'Before we dive into the key components, let’s go through the elements that
    we need to understand to effectively work with data binding in .NET MAUI applications.
    These elements play a vital role in facilitating communication between the View
    and ViewModel layers, enabling seamless synchronization of data and user interactions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入关键组件之前，让我们回顾一下为了在.NET MAUI应用程序中有效地使用数据绑定，我们需要理解哪些元素。这些元素在促进视图和ViewModel层之间的通信中发挥着至关重要的作用，使得数据和使用者交互的无缝同步成为可能：
- en: '`INotifyPropertyChanged` interface. This interface ensures that the View is
    notified whenever the data in the ViewModel changes, allowing the UI to update
    accordingly. It’s essential to understand that implementing the `INotifyPropertyChanged`
    interface is not strictly required for a property to act as a binding source.
    In fact, any property, regardless of its enclosing class implementing `INotifyPropertyChanged`
    or not, can serve as a binding source.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged`接口。此接口确保每当ViewModel中的数据发生变化时，视图都会收到通知，从而允许UI相应地更新。重要的是要理解，实现`INotifyPropertyChanged`接口并非使属性作为绑定源所必需的。实际上，任何属性，无论其封装类是否实现了`INotifyPropertyChanged`，都可以作为绑定源。'
- en: '`BindableProperty` on a UI element – or another `BindableObject` – that you
    may want to connect to the binding source. In .NET MAUI, most UI elements, such
    as labels, text boxes, and buttons, derive from the `Microsoft.Maui.Controls.BindableObject`
    class, which enables them to serve as a binding target. As opposed to the binding
    source, not every property can be a binding target, only properties of type `BindableProperty`
    on a class that inherits from a `BindableObject`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想要连接到绑定源的UI元素（或另一个`BindableObject`）上的`BindableProperty`。在.NET MAUI中，大多数UI元素，如标签、文本框和按钮，都从`Microsoft.Maui.Controls.BindableObject`类派生，这使得它们能够作为绑定目标。与绑定源不同，并非每个属性都可以作为绑定目标，只有从`BindableObject`派生的类上的`BindableProperty`类型属性才能作为绑定目标。
- en: '**Binding context**: The binding context establishes the relationship between
    the ViewModel and the View. It serves as a reference point for the data binding
    engine, providing a connection to the ViewModel instance. The binding context
    is usually set at the page level or on individual UI elements. By default, child
    elements inherit the context from their parent.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定上下文**：绑定上下文建立了视图模型和视图之间的关系。它作为数据绑定引擎的参考点，提供对视图模型实例的连接。绑定上下文通常在页面级别或单个UI元素上设置。默认情况下，子元素从其父元素继承上下文。'
- en: '**Binding path**: The binding path is an expression that specifies the property
    of the binding source that need to be bound to the binding target. In the simplest
    case, the binding path refers to a single property name in the ViewModel, but
    it can also include more complex expressions, such as property chains or indexers.
    The combination of the binding path and the binding context form the binding source.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定路径**：绑定路径是一个表达式，指定了需要绑定到绑定目标的绑定源属性。在最简单的情况下，绑定路径指的是视图模型中的单个属性名，但它也可以包括更复杂的表达式，例如属性链或索引器。绑定路径和绑定上下文的组合构成了绑定源。'
- en: '**Binding mode**: The binding mode determines the direction of data flow between
    the binding source and target, as we saw earlier in [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015),
    *What Is the MVVM* *Design Pattern?*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定模式**：绑定模式决定了绑定源和目标之间数据流的方向，正如我们在[*第1章*](B20941_01.xhtml#_idTextAnchor015)“什么是MVVM设计模式？”中看到的，它决定了数据流的流向。'
- en: '**ValueConverter**: A value converter modifies the data between the ViewModel
    and the View and vice versa. It allows us to convert the data value that is being
    bound and is particularly useful when the ViewModel’s data type does not match
    the data type expected by the UI element in the View.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值转换器**：值转换器修改ViewModel和视图之间的数据，反之亦然。它允许我们转换正在绑定的数据值，当ViewModel的数据类型与视图中的UI元素期望的数据类型不匹配时，特别有用。'
- en: Throughout this and [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding
    in .NET MAUI*, all aspects of data binding will be thoroughly discussed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和[*第4章*](B20941_04.xhtml#_idTextAnchor069)“.NET MAUI中的数据绑定”中，将全面讨论数据绑定的各个方面。
- en: Let’s first take a look at the core component that makes data binding possible
    in .NET MAUI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看使.NET MAUI中的数据绑定成为可能的核心组件。
- en: BindableObject
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BindableObject
- en: In .NET MAUI, the `Microsoft.Maui.Controls.BindableObject` class is the base
    class for objects that leverage data binding. It provides the foundation to enable
    data binding with UI elements and other objects by implementing essential properties,
    methods, and events related to the binding process. It is, in fact, the cornerstone
    of data-binding functionality in .NET MAUI, which is a crucial component of applying
    the MVVM pattern. It allows us to connect the View and the ViewModel, allowing
    them to communicate and stay in sync with each other without direct coupling.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中，`Microsoft.Maui.Controls.BindableObject`类是利用数据绑定的对象的基类。它通过实现与绑定过程相关的必要属性、方法和事件，为通过UI元素和其他对象启用数据绑定提供了基础。实际上，它是.NET
    MAUI中数据绑定功能的核心，也是应用MVVM模式的关键组件。它使我们能够连接视图和视图模型，使它们能够相互通信并保持同步，而无需直接耦合。
- en: Most UI elements in .NET MAUI, such as labels, buttons, and text boxes, are
    derived from the `BindableObject` class. This inheritance enables these elements
    to participate in data binding.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI中的大多数UI元素，如标签、按钮和文本框，都从`BindableObject`类派生。这种继承使得这些元素能够参与数据绑定。
- en: In essence, the `BindableObject` stores instances of `Microsoft.Maui.Controls.BindableProperty`
    and manages the `BindingContext`. These are crucial aspects to enable effective
    data binding, which in turn fosters seamless communication between the View and
    ViewModel, facilitating MVVM.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`BindableObject`存储了`Microsoft.Maui.Controls.BindableProperty`的实例并管理`BindingContext`。这些是启用有效数据绑定的重要方面，从而促进了视图和视图模型之间的无缝通信，促进了MVVM。
- en: BindableProperty
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可绑定属性
- en: '`BindableProperty` is a special kind of property that can act as a binding
    target. It basically is an advanced CLR property, a property on steroids, if you
    will. Ultimately, a bindable property serves as a container for storing data related
    to the property, such as its default value and validation logic. It also provides
    a mechanism to enable data binding and property change notifications. It is associated
    with a public instance property, which serves as the interface for getting and
    setting the value of the bindable property. Many properties of UI elements in
    .NET MAUI are bindable properties, which allows us to set their values through
    data binding or using styles.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindableProperty`是一种特殊的属性，可以作为绑定目标。它基本上是一个高级CLR属性，如果你愿意的话，就是一个“强化”的属性。最终，可绑定属性充当存储与属性相关的数据的容器，例如其默认值和验证逻辑。它还提供了一个机制来启用数据绑定和属性更改通知。它与一个公共实例属性相关联，该属性作为获取和设置可绑定属性值的接口。在.NET
    MAUI中，许多UI元素的属性都是可绑定属性，这使得我们可以通过数据绑定或使用样式来设置它们的值。'
- en: 'As an example, let’s look at the `Text` property of `Label`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看`Label`的`Text`属性：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s start by looking at the `Text` property. This is just a CLR property,
    but instead of storing and retrieving the value from a backing field, it does
    the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看`Text`属性开始。这只是一个CLR属性，但它不是从后端字段存储和检索值，而是执行以下操作：
- en: The getter retrieves the value by calling the `GetValue` method, passing in
    `TextProperty`. This `GetValue` method is a method on the `BindableObject` base
    class that `Label` inherits from.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器通过调用`GetValue`方法并传入`TextProperty`来检索值。这个`GetValue`方法是在`Label`类继承的`BindableObject`基类上的一个方法。
- en: The setter calls the `SetValue` method of `BindableObject`, passing in `TextProperty`
    and the given value.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置器调用`BindableObject`的`SetValue`方法，传入`TextProperty`和给定的值。
- en: The `TextProperty` used in the `GetValue` and `SetValue` methods is a `BindableProperty`.
    It’s static and belongs to the `Label` class. As mentioned earlier, `BindableProperty`
    is a sort of “container” that holds various bits of information about the property,
    including its value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetValue`和`SetValue`方法中使用的`TextProperty`是一个`BindableProperty`。它是静态的，属于`Label`类。如前所述，`BindableProperty`是一种“容器”，它包含有关属性的各种信息，包括其值。
- en: 'Let’s break down this `TextProperty`. This property is defined as a public
    static field of type `BindableProperty`. It is instantiated by calling the `BindableProperty.Create`
    method, passing in the following values:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个`TextProperty`。这个属性被定义为`BindableProperty`类型的公共静态字段。它通过调用`BindableProperty.Create`方法并传入以下值来实例化：
- en: '`BindableProperty` field. In this particular case, `nameof(Text)` is used to
    refer to the `Text` property of the `Label` class.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BindableProperty`字段。在这个特定的案例中，`nameof(Text)`用于引用`Label`类的`Text`属性。'
- en: '`Type` and defines the data type of the property that the bindable property
    is referring to. As the `Text` property is of type `string`, `typeof(string)`
    is passed in as a value.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type`定义了可绑定属性所引用的属性的数据类型。由于`Text`属性是`string`类型，因此传递了`typeof(string)`作为值。'
- en: '`Type`. It refers to the owner type of the property, which is the class that
    the property belongs to. In this particular example, the `Text` property is defined
    in the `Label` class, so this type is passed as a value.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type`。它指的是属性的拥有者类型，即属性所属的类。在这个特定的例子中，`Text`属性是在`Label`类中定义的，因此这个类型作为值传递。'
- en: '`defaultValue` parameter, which is of type `object`. This parameter is optional
    and allows us to provide a default value to the bindable property. In this case,
    `default(string)` is passed, which means `NULL` will be the default value.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultValue`参数，其类型为`object`。这是一个可选参数，允许我们为可绑定属性提供一个默认值。在这种情况下，传递了`default(string)`，这意味着默认值将是`NULL`。'
- en: '**OnTextpropertyChanged**: Optionally, we can provide a delegate that needs
    to be called when the value of the property changes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnTextpropertyChanged**：可选地，我们可以提供一个在属性值更改时需要调用的委托。'
- en: The `BindableProperty.Create` method has a lot more optional parameters that
    you can provide if needed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindableProperty.Create`方法有很多可选参数，如果需要的话，你可以提供这些参数。'
- en: More about bindable properties
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于可绑定属性的信息
- en: In [*Chapter 11*](B20941_11.xhtml#_idTextAnchor182), *Creating MVVM-Friendly
    Controls*, we will look at building our own controls. Understanding the concept
    of a `BindableProperty` is essential when it comes to creating MVVM-friendly controls.
    So, you can expect to dive deeper into this in that chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 11 章*](B20941_11.xhtml#_idTextAnchor182)，*创建 MVVM 友好的控件*，我们将探讨如何构建我们自己的控件。理解
    `BindableProperty` 的概念对于创建 MVVM 友好的控件至关重要。因此，你可以期待在那个章节中更深入地了解这一点。
- en: The concept of a `BindableProperty` can be a little overwhelming or hard to
    understand to start with. For now, just remember that all of the UI elements inherit
    from `BindableObject` and that many of their properties are bindable properties,
    allowing us to use them as a binding target.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindableProperty` 的概念一开始可能会让人感到有些令人困惑或难以理解。目前，只需记住所有 UI 元素都继承自 `BindableObject`，并且它们中的许多属性都是可绑定属性，这使得我们可以将它们用作绑定目标。'
- en: BindingContext
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BindingContext
- en: A `BindableObject` has a `BindingContext` property of type `object`, which acts
    as the glue between the binding source and the binding target. It points the data
    binding engine to an instance of a class that serves as the binding source. When
    you set the `BindingContext` property on a `BindableObject`, such as a .NET MAUI
    page or a UI element, you are specifying the source object for data binding expressions
    within that object’s scope. Child elements within that scope will inherit the
    `BindingContext` by default unless a different `BindingContext` is explicitly
    set for them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindableObject` 有一个类型为 `object` 的 `BindingContext` 属性，它充当绑定源和绑定目标之间的粘合剂。它将数据绑定引擎指向一个充当绑定源的类的实例。当你在一个
    `BindableObject` 上设置 `BindingContext` 属性，例如一个 .NET MAUI 页面或 UI 元素时，你指定了该对象作用域内数据绑定表达式的源对象。该作用域内的子元素将默认继承
    `BindingContext`，除非为它们显式设置了不同的 `BindingContext`。'
- en: When the `BindingContext` is set on a `BindableObject`, the data-binding engine
    will resolve all bindings having their `Source` set to the `BindingContext`. Also,
    when the value of the `BindingContext` property changes, these bindings are reevaluated
    using the updated `BindingContext`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `BindableObject` 上设置 `BindingContext` 时，数据绑定引擎将解析所有将 `Source` 设置为 `BindingContext`
    的绑定。此外，当 `BindingContext` 属性的值发生变化时，这些绑定将使用更新的 `BindingContext` 重新评估。
- en: Now that we’ve discussed all the core components that allow us to do data binding
    in .NET MAUI, let’s see how to define and use them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了所有允许我们在 .NET MAUI 中进行数据绑定的核心组件，让我们看看如何定义和使用它们。
- en: Data binding in practice
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中的数据绑定
- en: 'Before we can start writing our data binding, we first need to add our ViewModels
    to our solution. In order to fully embrace the separation of concerns, let’s put
    them into a separate project:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写数据绑定之前，我们首先需要将我们的 ViewModels 添加到我们的解决方案中。为了完全接受关注点的分离，让我们将它们放入一个单独的项目中：
- en: In the **Solution Explorer**, right-click on your solution and select **Add**
    | **New Project…**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Solution Explorer** 中，右键单击你的解决方案，选择 **Add** | **New Project…**。
- en: Select **Class Library** from the list of project templates and click **Next**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目模板列表中选择 **Class Library** 并点击 **Next**。
- en: Enter `Recipes.Client.Core` under **Project name** and click **Next**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project name** 下输入 `Recipes.Client.Core` 并点击 **Next**。
- en: Select `.NET 8.0` as **Framework** and click **Create**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `.NET 8.0` 作为 **Framework** 并点击 **Create**。
- en: 'Once the project is created, let’s delete `Class1.cs`, which was created by
    default. Next, we want to add our ViewModels to this project. In order to keep
    everything nice and organized, let’s first create a `ViewModels` folder to put
    all of our ViewModels in:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了项目，让我们删除默认创建的 `Class1.cs`。接下来，我们想要将我们的 ViewModels 添加到这个项目中。为了保持一切井井有条，让我们首先创建一个
    `ViewModels` 文件夹来放置所有的 ViewModels：
- en: Right-click on the `Recipes.Client.Core` project in the `ViewModels`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 中右键单击 `Recipes.Client.Core` 项目。
- en: 'Right-click on the newly added folder and select `RecipeDetailViewModel`, and
    add the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新添加的文件夹，选择 `RecipeDetailViewModel`，并添加以下代码：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`RecipeDetailViewModel` represents the details of a recipe. For now, it only
    contains a `Title` property, which we now give a hardcoded value of `"Classic`
    `Caesar Salad"`.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RecipeDetailViewModel` 表示菜谱的详细信息。目前，它只包含一个 `Title` 属性，我们现在给它一个硬编码的值 `"Classic`
    `Caesar Salad"`。'
- en: Next, we need to add a reference to this `Recipes.Client.Core` project from
    the `Recipes.Mobile` project. To do this, simply right-click on the `Recipes.Mobile`
    project, select `Recipes.Client.Core` project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从 `Recipes.Mobile` 项目添加对 `Recipes.Client.Core` 项目的引用。为此，只需在 `Recipes.Mobile`
    项目上右键单击，选择 `Recipes.Client.Core` 项目。
- en: 'As a very last step, before we dive into data binding, we need to add a new
    page to our `Recipes.Mobile` project:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入数据绑定之前，作为最后一步，我们需要向我们的`Recipes.Mobile`项目添加一个新页面：
- en: Right-click the project name and select **Add** | **New Item…**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目名称，选择**添加** | **新建项…**。
- en: Select `RecipeDetailPage.xaml`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`RecipeDetailPage.xaml`。
- en: 'Open `App.xaml.cs` and, in the constructor, assign an instance of `RecipeDetailPage`
    to the `MainPage` property:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.xaml.cs`，并在构造函数中将`RecipeDetailPage`的一个实例分配给`MainPage`属性：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This ensures that on startup, the mobile app will show our newly created `RecipeDetailPage`.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了在启动时，移动应用将显示我们新创建的`RecipeDetailPage`。
- en: 'Finally, in the code-behind of `RecipeDetailPage`, we need to assign its `BindingContext`
    property to an instance of `RecipeDetailViewModel`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`RecipeDetailPage`的代码背后，我们需要将其`BindingContext`属性分配给`RecipeDetailViewModel`的一个实例：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can focus on `RecipeDetailPage` and start implementing some data bindings.
    Data bindings can be defined in code using C# and in XAML. Both have their cons
    and their pros, but essentially it comes down to preference. You can even mix
    and match both approaches if you want, although I wouldn’t recommend doing that.
    Most commonly, data bindings are defined in XAML, minimizing the amount of code
    in the code-behind. Nevertheless, let’s first see how we can define data bindings
    in C#.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于`RecipeDetailPage`并开始实现一些数据绑定。数据绑定可以使用C#和XAML在代码中定义。两者都有其优缺点，但本质上取决于个人喜好。如果你想的话，甚至可以混合使用这两种方法，尽管我不建议这么做。最常见的是在XAML中定义数据绑定，以最小化代码背后的代码量。不过，让我们首先看看如何使用C#定义数据绑定。
- en: Data binding in C#
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C#中的数据绑定
- en: 'Let’s go to our new `RecipeDetailPage.xaml` file and start updating some XAML:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到我们的新`RecipeDetailPage.xaml`文件，并开始更新一些XAML：
- en: Remove any default XAML elements inside the `ContentPage` tag.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ContentPage`标签内移除任何默认的XAML元素。
- en: 'Add the following elements inside `ContentPage`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContentPage`内添加以下元素：
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are keeping the UI very simple and straightforward for now. That’s why we
    are going to put everything in a `VerticalStackLayout`, which organizes child
    elements in a vertical stack. We’re surrounding the `VerticalStackLayout` with
    a `ScrollView` in order to make sure we get scrollbars when not everything fits
    on the screen.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前我们保持UI非常简单直接。这就是为什么我们将一切放入一个`VerticalStackLayout`中，它以垂直堆叠的方式组织子元素。我们用`ScrollView`包围`VerticalStackLayout`，以确保当屏幕上无法显示所有内容时，我们得到滚动条。
- en: 'Add a `Label` to the `VerticalStackLayout` with the name `lblTitle`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VerticalStackLayout`中添加一个名为`lblTitle`的`Label`：
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This label will be showing the recipe’s title.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个标签将显示菜谱的标题。
- en: 'In the code-behind, within the constructor of `RecipeDetailPage`, we can now
    add data-binding code so that the value of the `Title` property of the `RecipeDetailViewModel`
    is shown in the `lblTitle` label:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码背后，在`RecipeDetailPage`的构造函数中，我们现在可以添加数据绑定代码，以便在`lblTitle`标签中显示`RecipeDetailViewModel`的`Title`属性值：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because we have given the `Label` the name `lblTitle`, a field with this name
    is generated, which allows us to access this label from the code-behind. By calling
    the `SetBinding` method, we can define and apply a binding.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们已经给`Label`命名为`lblTitle`，所以会生成一个具有此名称的字段，这允许我们从代码背后访问这个标签。通过调用`SetBinding`方法，我们可以定义并应用一个绑定。
- en: Run the app and you should see the `Title` of `RecipeDetailViewModel`, which
    is currently hardcoded as `"Classic Caesar Salad"` on the screen.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用，你应该能在屏幕上看到`RecipeDetailViewModel`的`Title`，目前它是硬编码为`"Classic Caesar Salad"`。
- en: 'By looking at the first data binding we’ve just implemented, you should be
    able to identify most of the data binding elements we’ve discussed earlier:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们刚刚实现的第一条数据绑定，你应该能够识别出我们之前讨论的大多数数据绑定元素：
- en: '`SetBinding` method is a method on the `BindableObject` class. The first parameter
    the `SetBinding` method needs is a `BindableProperty`. In this case, we are passing
    in the static `Label.TextProperty`, which corresponds to the `Text` instance property
    of a `Label`. The instance of the `BindableObject` we are calling the `SetBinding`
    method on, together with the `BindableProperty` we’re specifying as the first
    parameter, form the binding target.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetBinding`方法是在`BindableObject`类上的一个方法。`SetBinding`方法需要的第一个参数是一个`BindableProperty`。在这种情况下，我们传递的是静态的`Label.TextProperty`，它对应于`Label`的`Text`实例属性。我们调用`SetBinding`方法的`BindableObject`实例，以及我们作为第一个参数指定的`BindableProperty`，共同构成了绑定目标。'
- en: '`SetBinding` method expects is the property path to bind to. This, together
    with the `BindingContext`, forms the binding source – but what is the `BindingContext`
    in this case? As we don’t explicitly specify the `BindingContext` on the `Label`,
    the `BindingContext` is inherited from `lblTitle`’s parent, which is `RecipeDetailPage`.
    Therefore, the `BindingContext` of the label is also the instance of `RecipeDetailViewModel`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetBinding`方法期望的是一个要绑定的属性路径。这，加上`BindingContext`，形成了绑定源——但在这个情况下，`BindingContext`是什么？由于我们没有在`Label`上显式指定`BindingContext`，`BindingContext`是从`lblTitle`的父元素继承的，即`RecipeDetailPage`。因此，标签的`BindingContext`也是`RecipeDetailViewModel`的实例。'
- en: '`BindingMode` is the third parameter in this example. This one, however, is
    optional. In this case, we are setting the `BindingMode` to `OneTime`. In [*Chapter
    1*](B20941_01.xhtml#_idTextAnchor015), *What Is the MVVM Design Pattern?*, we
    briefly discussed different binding modes, and we will discuss binding modes in
    a bit more depth later on in this chapter.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BindingMode`是本例中的第三个参数。然而，这个参数是可选的。在这种情况下，我们将`BindingMode`设置为`OneTime`。在[*第一章*](B20941_01.xhtml#_idTextAnchor015)，“什么是MVVM设计模式？”中，我们简要讨论了不同的绑定模式，我们将在本章稍后更深入地讨论绑定模式。'
- en: Defining data binding in code is quite easy and straightforward. However, most
    of the time, data bindings are defined in XAML. Personally, I think defining them
    in XAML feels more natural and requires less context switching when creating your
    UI with XAML. So, let’s have a look!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中定义数据绑定既简单又直接。然而，大多数情况下，数据绑定是在XAML中定义的。我个人认为在XAML中定义它们感觉更自然，并且在使用XAML创建UI时需要更少的上下文切换。那么，让我们看看吧！
- en: Data binding in XAML
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XAML中的数据绑定
- en: As we are going to write our data binding in XAML, we can delete or comment
    out the binding code that we added to the constructor of `RecipeDetailPage` in
    *step 4* of the previous section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要在XAML中编写数据绑定，我们可以删除或注释掉在上一节*步骤 4*中添加到`RecipeDetailPage`构造函数中的绑定代码。
- en: 'We can now switch to `RecipeDetailPage.xaml` and update the label by removing
    the `x:Name` property and adding the `Text` property, which contains a **Binding**
    **markup extension**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以切换到`RecipeDetailPage.xaml`并更新标签，通过删除`x:Name`属性并添加包含**绑定****标记扩展**的`Text`属性：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <Label
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <Label
- en: FontAttributes="Bold"
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: FontAttributes="Bold"
- en: FontSize="22"
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: FontSize="22"
- en: Mode=, we can indicate the binding mode, just like we did in the previous example;
    we’re setting it to OneTime in this example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Mode=, 我们可以指示绑定模式，就像我们在上一个示例中所做的那样；在这个示例中，我们将它设置为OneTime。
- en: Apart from `Path` and `Mode`, there are more properties to the binding markup
    extension, such as `Source`, which allows us to point to another binding source,
    `Converter`, `TargetNullValue`, and others. [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069),
    *Data Binding in .NET MAUI*, will cover all of this in much more detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Path`和`Mode`之外，绑定标记扩展还有更多属性，例如`Source`，它允许我们指向另一个绑定源，`Converter`，`TargetNullValue`等。[*第四章*](B20941_04.xhtml#_idTextAnchor069)，“.NET
    MAUI中的数据绑定”将更详细地介绍所有这些内容。
- en: Now, let’s take a look at the different binding modes in more detail and how
    to reflect changes from the binding source automatically in the binding target.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看不同的绑定模式以及如何自动在绑定目标中反映绑定源的变化。
- en: Binding modes and the INotifyPropertyChanged interface
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定模式和INotifyPropertyChanged接口
- en: 'In [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015), *What Is the MVVM Design
    Pattern*, we already discussed how data can flow:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B20941_01.xhtml#_idTextAnchor015)，“什么是MVVM设计模式”中，我们已经讨论了数据如何流动：
- en: '**One-way**: From ViewModel to View'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向**：从ViewModel到View'
- en: '**One-way-to-source**: From View to ViewModel'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向到源**：从View到ViewModel'
- en: '**One-time**: Only once from ViewModel to View'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性**：仅从ViewModel到View一次'
- en: '**Two-way**: From ViewModel to View and from View to ViewModel'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向**：从ViewModel到View和从View到ViewModel'
- en: Now, let’s take a look at how this is handled in .NET MAUI.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在.NET MAUI中是如何处理这个问题的。
- en: Binding modes in .NET MAUI
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI中的绑定模式
- en: '.NET MAUI supports all of these data flows, represented through the `Microsoft.Maui.Controls.BindingMode`
    enum: `OneWay`, `OneWayToSource`, `OneTime` and `TwoWay`. There is in fact a fifth
    value as well: `Default`. Remember when we talked about bindable properties earlier
    in this chapter? When creating a bindable property, there are some optional values
    we can set. One of those optional parameters is `defaultBindingMode`. This allows
    us to set a default binding mode on a bindable property. On `Entry`, for example,
    it makes sense to have the default binding mode on the `Text` property set to
    `TwoWay`, as it shows the value of the binding source, and the user is able to
    update the value as well. The `Text` property on a `Label`, on the other hand,
    is read-only, so the default binding mode there is `OneWay`. Now, going back to
    the `BindingMode` enum and more specifically, the `Default` value, when we don’t
    specify a binding mode or use `Default`, the data-binding engine will use the
    binding mode that is specified as the default one on the bindable property of
    the binding target.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 支持所有这些数据流，通过 `Microsoft.Maui.Controls.BindingMode` 枚举表示：`OneWay`、`OneWayToSource`、`OneTime`
    和 `TwoWay`。实际上还有一个第五个值：`Default`。记得我们在本章前面讨论可绑定属性时提到的吗？在创建可绑定属性时，我们可以设置一些可选值。其中之一是
    `defaultBindingMode`。这允许我们在可绑定属性上设置默认绑定模式。例如，在 `Entry` 上，将 `Text` 属性的默认绑定模式设置为
    `TwoWay` 是有意义的，因为它显示了绑定源的价值，并且用户能够更新该值。另一方面，`Label` 上的 `Text` 属性是只读的，因此那里的默认绑定模式是
    `OneWay`。现在，回到 `BindingMode` 枚举，特别是 `Default` 值，当我们没有指定绑定模式或使用 `Default` 时，数据绑定引擎将使用绑定目标的可绑定属性上指定的默认绑定模式。
- en: In the context of data binding and the various binding modes in .NET MAUI, it’s
    crucial to have an efficient way to inform the UI about changes to the ViewModel’s
    properties. The `INotifyPropertyChanged` interface addresses this need by providing
    a mechanism for your ViewModel to notify the UI when a property value has been
    updated.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据绑定和 .NET MAUI 中的各种绑定模式背景下，有一个高效的方法来通知 UI 关于 ViewModel 属性的更改至关重要。`INotifyPropertyChanged`
    接口通过提供一个机制来满足这一需求，允许 ViewModel 在属性值更新时通知 UI。
- en: INofityPropertyChanged
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: INofityPropertyChanged
- en: The `INotifyPropertyChanged` interface, part of the `System.ComponentModel`
    namespace, allows your binding source to communicate property changes to the binding
    target. This interface isn’t specific to .NET MAUI; it’s part of the .NET `PropertyChanged`
    event when the object that is being bound to implements the `INotifyPropertyChanged`
    interface. When the event is triggered, the engine will update the UI accordingly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged` 接口，作为 `System.ComponentModel` 命名空间的一部分，允许您的绑定源将属性更改通知给绑定目标。此接口并不仅限于
    .NET MAUI；当绑定到对象实现 `INotifyPropertyChanged` 接口时，它是 .NET `PropertyChanged` 事件的一部分。当事件被触发时，引擎将相应地更新
    UI。'
- en: 'To implement the `INotifyPropertyChanged` interface, your ViewModel must include
    a `PropertyChanged` event, which can be triggered whenever a property’s value
    changes. Furthermore, you typically create a method, usually called `OnPropertyChanged`,
    that triggers this event while providing the name of the altered property as a
    parameter. This method should be called within the property setter, immediately
    after the property value is updated:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `INotifyPropertyChanged` 接口，您的 ViewModel 必须包含一个 `PropertyChanged` 事件，该事件可以在属性值更改时触发。此外，通常创建一个方法，通常称为
    `OnPropertyChanged`，该方法触发此事件并提供更改属性的名称作为参数。此方法应在属性设置器中调用，在属性值更新后立即调用：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding sample, this `SampleViewModel` implements the
    `INotifyPropertyChanged` interface, which requires us to implement the `PropertyChanged`
    event of the `PropertyChangedEventHandler` type. The `PropertyChanged` event can
    easily be invoked by calling the `OnPropertyChanged` method and passing in the
    name of the property that has been changed. When looking at the code, in the setter
    of the `Title` property, the `OnPropertyChanged` method is called when a new value
    is assigned to the property’s backing field, passing in the name of the property.
    When calling the `PropertyChanged` event, the current instance of the `SampleViewModel`
    is passed-in as the sender through the `this` keyword, followed by an instance
    of `PropertyChangedEventArgs`, which requires the name of the updated property.
    Through this event, the data-binding engine gets notified about the updated property
    and can, depending on the data-binding mode, update the binding target automatically.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的示例所示，此 `SampleViewModel` 实现了 `INotifyPropertyChanged` 接口，这要求我们实现 `PropertyChanged`
    事件的 `PropertyChangedEventHandler` 类型。可以通过调用 `OnPropertyChanged` 方法并传递已更改属性的名称来轻松调用
    `PropertyChanged` 事件。在查看代码时，在 `Title` 属性的设置器中，当将新值分配给属性的备份字段时，会调用 `OnPropertyChanged`
    方法，并传递属性的名称。在调用 `PropertyChanged` 事件时，通过 `this` 关键字将 `SampleViewModel` 的当前实例作为发送者传递，后跟一个
    `PropertyChangedEventArgs` 实例，该实例需要更新的属性的名称。通过此事件，数据绑定引擎会收到已更新属性的通知，并且根据数据绑定模式，可以自动更新绑定目标。
- en: '`CallerMemberNameAttribute` is something that is very commonly used as an attribute
    on the `propertyName` parameter of the `OnPropertyChanged` method. This attribute
    automatically obtains the name of the method or property that calls the attributed
    method. This facilitates calling the `PropertyChanged` event from the property’s
    setter even more, as the name of the property doesn’t need to be explicitly passed
    as a parameter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallerMemberNameAttribute` 是在 `OnPropertyChanged` 方法的 `propertyName` 参数上非常常见的一种属性。此属性自动获取调用具有属性的方法或属性的名称。这使从属性的设置器调用
    `PropertyChanged` 事件变得更加容易，因为不需要显式地作为参数传递属性的名称：'
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the `Title` property calls the `OnPropertyChanged` method, without providing
    an explicit value as a parameter, the name of the caller  – `Title` in this case
    – will be passed in as a value. In [*Chapter 5*](B20941_05.xhtml#_idTextAnchor086),
    *Community Toolkits*, we’ll see how we can eliminate a lot of the ceremony here
    when triggering the `PropertyChanged` event.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Title` 属性调用了 `OnPropertyChanged` 方法，但没有提供作为参数的显式值，因此调用者的名称（在这种情况下为 `Title`）将被作为值传递。在
    [*第5章*](B20941_05.xhtml#_idTextAnchor086) 的 *社区工具包* 中，我们将看到如何在触发 `PropertyChanged`
    事件时消除这里的大部分仪式。
- en: Different binding modes in action
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的绑定模式在实际应用
- en: In the example earlier in this chapter, we bound the `Title` property of our
    `RecipeDetailViewModel` one time to the `Text` property of a `Label`. This means
    that the binding source is set only when the `BindingContext` of the binding target
    is set or when the `BindingContext` is assigned a new instance. In the context
    of our current setup, `BindingContext`, the initial value of the `Title` property
    is bound right away. However, any subsequent changes made to the `Title` property
    (such as updating it after the ViewModel loads data) won’t be reflected in the
    UI due to the nature of one-time data binding. This won’t be a problem for us
    right now since we’re working with static data for demonstration purposes, but
    it’s something to be aware of in a real-world application. As we progress through
    this book, we will revise this binding mode to handle such situations more effectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的示例中，我们将 `RecipeDetailViewModel` 的 `Title` 属性绑定了一次到 `Label` 的 `Text` 属性。这意味着仅在设置绑定目标的
    `BindingContext` 或将 `BindingContext` 分配为新实例时，才设置绑定源。在我们的当前设置中，`BindingContext`，`Title`
    属性的初始值立即绑定。然而，由于一次性数据绑定的性质，对 `Title` 属性的任何后续更改（例如在 ViewModel 加载数据后更新它）都不会反映在 UI
    中。由于我们目前使用的是静态数据来演示，所以这不会成为问题，但在实际应用中，这是一个需要注意的问题。随着我们继续阅读本书，我们将修订此绑定模式，以更有效地处理此类情况。
- en: 'Let’s add some more code and discuss the other binding modes. First, let’s
    add an additional `IngredientsListViewModel` and extend our `RecipeDetailViewModel`
    with a property of that type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加更多的代码并讨论其他绑定模式。首先，让我们添加一个额外的 `IngredientsListViewModel` 并将我们的 `RecipeDetailViewModel`
    扩展为具有该类型的属性：
- en: In the `ViewModels` folder in the `Recipes.Client.Core` project and select **Add**
    | **Class…**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes.Client.Core`项目的`ViewModels`文件夹中，选择**添加** | **类…**。
- en: Enter `IngredientsListViewModel.cs` as name and click **Add**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`IngredientsListViewModel.cs`作为名称并点击**添加**。
- en: 'Let the class implement the `INotifyPropertyChanged` interface and add the
    `OnPropertyChanged` method. Add the following code to the newly created class:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让类实现`INotifyPropertyChanged`接口并添加`OnPropertyChanged`方法。将以下代码添加到新创建的类中：
- en: '[PRE10]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a typical implementation of the `INotifyPropertyChanged` interface with
    the `PropertyChangedEvent` and an `OnPropertyChanged` method that triggers the
    implemented `PropertyChhanged` event.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是对`INotifyPropertyChanged`接口的典型实现，包括`PropertyChangedEvent`和一个触发已实现`PropertyChanged`事件的`OnPropertyChanged`方法。
- en: '4.  Next, we can add the `NumberOfServings` property, as shown in the following
    snippet. For brevity, the implementation of the `INotifyPropertyChanged` interface
    is left out:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  接下来，我们可以添加`NumberOfServings`属性，如下面的代码片段所示。为了简洁，省略了`INotifyPropertyChanged`接口的实现：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`IngredientsListViewModel` contains a list of all ingredients and the quantities
    of them that are needed for a particular recipe. It also contains a `NumberOfServings`
    property, which indicates the number of servings for which the listed ingredients
    and their quantities are intended. The user should be able to adjust the number
    of servings in the UI and see how the quantity of the ingredients is being updated
    according to the selected amount. We will add the list of ingredients later.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IngredientsListViewModel`包含所有食材及其所需数量的列表，以及一个`NumberOfServings`属性，该属性表示列表中食材及其数量所针对的份量数。用户应该能够在UI中调整份量数并看到根据所选数量更新食材数量的情况。我们将在稍后添加食材列表。'
- en: '5.  Move over to `RecipeDetailViewModel` and add an `IngredientsList` property
    of type `IngredientsListViewModel` and assign it a new instance by default:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5.  转到`RecipeDetailViewModel`并添加一个类型为`IngredientsListViewModel`的`IngredientsList`属性，并默认分配一个新实例：
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this updated code in place, we can now go to `RecipeDetailPage` and focus
    on the XAML again. We want to update the UI to allow users to choose the desired
    number of servings. For this use case, we will create a `OneWay` and a `TwoWay`
    data binding.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此更新后的代码到位后，我们现在可以转到`RecipeDetailPage`并再次关注XAML。我们希望更新UI以允许用户选择所需的份量数。对于此用例，我们将创建一个`OneWay`和一个`TwoWay`数据绑定。
- en: 'Go to `RecipeDetail` and add the following XAML below the `Label` that shows
    the recipe’s title:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往`RecipeDetail`并在显示食谱标题的`Label`下方添加以下XAML：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s have a look at the binding statements that we’ve added through this code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过这段代码添加的绑定语句：
- en: 'The `Text` property of the label is bound to the `NumberOfServings` property
    using the following binding statement: `{Binding IngredientsList.NumberOfServings,
    Mode=OneWay}`. The label displays the currently selected number of servings. The
    `NumberOfServings` property is part of the `IngredientsList` property on `RecipeDetailViewModel`,
    which is why the binding path is set to `IngredientsList.NumberOfServings`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签的`Text`属性使用以下绑定语句绑定到`NumberOfServings`属性：`{Binding IngredientsList.NumberOfServings,
    Mode=OneWay}`。标签显示当前选定的份量数。`NumberOfServings`属性是`RecipeDetailViewModel`上的`IngredientsList`属性的一部分，因此绑定路径设置为`IngredientsList.NumberOfServings`。
- en: Since the user can change the number of servings, we use the `OneWay` binding
    mode. This ensures that when the value of `NumberOfServings` is updated, the UI
    reflects the change accordingly.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于用户可以更改份量数，我们使用`OneWay`绑定模式。这确保了当`NumberOfServings`的值更新时，UI会相应地反映变化。
- en: 'The `Value` property of the `Stepper` control is bound to the `NumberOfServings`
    property using the following binding statement: `{Binding IngredientsList.NumberOfServings,
    Mode=TwoWay}`. `Stepper` allows the user to adjust the currently selected number
    of servings.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stepper`控件的`Value`属性使用以下绑定语句绑定到`NumberOfServings`属性：`{Binding IngredientsList.NumberOfServings,
    Mode=TwoWay}`。`Stepper`允许用户调整当前选定的份量数。'
- en: Since the user can change the number of servings and the ViewModel should update
    accordingly, we use the `TwoWay` binding mode. This ensures that not only the
    UI reflects the `NumberOfServings` property’s value but also that the ViewModel
    is updated when the user modifies the number of servings via the `Stepper` control.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于用户可以更改份量数，并且ViewModel应该相应更新，我们使用`TwoWay`绑定模式。这确保了不仅UI反映了`NumberOfServings`属性值，而且当用户通过`Stepper`控件修改份量数时，ViewModel也会更新。
- en: Increments or decrements to the `NumberOfServings` property made using `Stepper`
    will be reflected in the previously discussed label due to `OneWay` binding, and
    the property triggers the `PropertyChanged` event.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`Stepper`对`NumberOfServings`属性进行的增加或减少将由于`OneWay`绑定而在之前讨论的标签中反映出来，并且该属性会触发`PropertyChanged`事件。
- en: 'In the XAML code, both bindings target properties within the `IngredientsList`
    property. In this example, all child elements of `HorizontalStackLayout` are bound
    to properties of the `IngredientsList` property in `RecipeDetailViewModel`. Since
    child elements inherit the binding context from their parent, it’s possible to
    move the binding to the `IngredientsList` property one level up, if desired:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML代码中，这两个绑定都针对`IngredientsList`属性内的属性。在这个例子中，`HorizontalStackLayout`的所有子元素都绑定到`RecipeDetailViewModel`中`IngredientsList`属性的属性。由于子元素从其父元素继承绑定上下文，如果需要，可以将绑定移动到`IngredientsList`属性的一个级别以上：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we are binding the `BindingContext` of `HorizontalStackLayout`
    to the `IngredientsList` property of `RecipeDetailViewModel`. This allows us to
    simplify the binding statements on the child elements. Of course, you can only
    do this when all the child elements have the same binding source.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`HorizontalStackLayout`的`BindingContext`绑定到`RecipeDetailViewModel`的`IngredientsList`属性。这允许我们简化子元素上的绑定语句。当然，只有当所有子元素都具有相同的绑定源时，你才能这样做：
- en: 'As a final example, let’s implement a `OneWayToSource` data binding in our
    **Recipes!** app. Here our aim is to show the allergen information for each recipe.
    As not everyone is interested in viewing this information, we will not show it
    by default. However, we want to allow the user to tick a box to get this information:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，让我们在我们的**Recipes!**应用中实现一个`OneWayToSource`数据绑定。在这里，我们的目标是显示每个菜谱的过敏信息。由于并非每个人都对查看此信息感兴趣，我们不会默认显示它。然而，我们希望允许用户勾选复选框以获取此信息：
- en: 'Go to `RecipesDetailViewModel` and let it implement `INotifyPropertyChanged`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`RecipesDetailViewModel`并让它实现`INotifyPropertyChanged`：
- en: '[PRE15]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '2.  Create an `OnPropertyChanged` method that accepts `propertyName` as a parameter
    and calls the `PropertyChanged` event, just like we did in `IngredientsListViewModel`:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 创建一个接受`propertyName`参数并调用`PropertyChanged`事件的`OnPropertyChanged`方法，就像我们在`IngredientsListViewModel`中做的那样：
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '3.  Now, let’s add a `ShowAllergenInformation` property of type `bool`. This
    property will be responsible for the visibility of the allergen information on
    `RecipeDetailPage`:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 现在，让我们添加一个类型为`bool`的`ShowAllergenInformation`属性。这个属性将负责在`RecipeDetailPage`上显示过敏信息的可见性：
- en: '[PRE17]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 4.  This property triggers the `PropertyChanged` event when its value changes.
    This allows us to bind it to the `IsVisible` property of a `VisualElement` so
    that whenever the value on the ViewModel changes, the UI element’s visibility
    is updated automatically.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4. 当这个属性的值发生变化时，它会触发`PropertyChanged`事件。这允许我们将它绑定到`VisualElement`的`IsVisible`属性，这样每当ViewModel上的值发生变化时，UI元素的可见性就会自动更新。
- en: 'Finally, we can go to `RecipeDetailPage` and add the following XAML between
    the label that shows the recipe’s title and the `HorizontalStackLayout` that is
    bound to `IngredientsList`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以前往`RecipeDetailPage`并在显示菜谱标题的标签和绑定到`IngredientsList`的`HorizontalStackLayout`之间添加以下XAML：
- en: '[PRE18]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Additionally, we bind the same `ShowAllergenInformation` property using the
    `OneWay` mode to the `IsVisible` property of a label. This label will eventually
    display the allergen information. As a result, when the user toggles the checkbox,
    it updates the `ShowAllergenInformation` property in the ViewModel, which in turn
    triggers `PropertyChangedEvent`. This event will be picked up by the binding engine,
    which will update the `IsVisible` property of the label, allowing the allergen
    information to be displayed or hidden based on the user’s preference.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们使用`OneWay`模式将相同的`ShowAllergenInformation`属性绑定到标签的`IsVisible`属性。这个标签最终将显示过敏信息。因此，当用户切换复选框时，它会更新ViewModel中的`ShowAllergenInformation`属性，这反过来又触发了`PropertyChangedEvent`。这个事件将被绑定引擎捕获，它将更新标签的`IsVisible`属性，根据用户的偏好显示或隐藏过敏信息。
- en: INotifyPropertyChanged is not a requirement for the binding source
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged`不是绑定源的必要条件'
- en: It is important to note that a binding target should always be a `BindableProperty`
    on a class that inherits from the `BindableObject`. The binding source, on the
    other hand, can be any property of any class. Most of the time, the binding source’s
    class implements the `INotifyPropertyChanged` interface, but that’s not a requirement.
    Only when using `OneWay` and `TwoWay` binding modes in scenarios where the values
    on the binding source can update and need to be reflected in the UI does the `INotifyPropertyChanged`
    interface need to be implemented. Alternatively, setting the `BindingContext`
    again would also update all the values, but that means everything needs to be
    reevaluated, which might not be a good idea.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是要注意，绑定目标始终应该是继承自`BindableObject`的类的`BindableProperty`。另一方面，绑定源可以是任何类的任何属性。大多数情况下，绑定源类的实现`INotifyPropertyChanged`接口，但这不是必需的。只有在使用`OneWay`和`TwoWay`绑定模式，并且绑定源上的值可以更新并需要在UI中反映的情况下，才需要实现`INotifyPropertyChanged`接口。或者，重新设置`BindingContext`也会更新所有值，但这意味着需要重新评估一切，这可能不是一个好主意。
- en: Now that we’ve seen how .NET MAUI supports data binding and different binding
    modes, let’s see how we can handle user interactions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了.NET MAUI如何支持数据绑定和不同的绑定模式，让我们看看我们如何处理用户交互。
- en: Handling interactions with the ICommand interface
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ICommand接口处理交互
- en: In most applications, user interaction plays a vital role. Common interactions
    include clicking buttons, selecting items from a list, toggling switches, and
    more. To handle these interactions effectively while adhering to the MVVM pattern,
    it’s essential to utilize a robust mechanism that encapsulates the necessary logic
    within the ViewModel. The `ICommand` interface is designed specifically for this
    purpose, enabling you to manage user interactions in a clean and maintainable
    way while ensuring a clear separation of concerns between the View and the ViewModel.
    In this section, we’ll explore how to implement and use `ICommand` to handle user
    interactions in your .NET MAUI application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用中，用户交互起着至关重要的作用。常见的交互包括点击按钮、从列表中选择项目、切换开关等。为了在遵循MVVM模式的同时有效地处理这些交互，利用一个封装必要逻辑在ViewModel中的强大机制是至关重要的。`ICommand`接口正是为此目的而设计的，它允许您以干净和可维护的方式管理用户交互，同时确保视图和ViewModel之间有明确的关注点分离。在本节中，我们将探讨如何实现和使用`ICommand`来处理.NET
    MAUI应用程序中的用户交互。
- en: The ICommand interface
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ICommand接口
- en: The `ICommand` interface plays a crucial role in handling user interactions
    within the context of the MVVM pattern in .NET MAUI applications. `ICommand` is
    part of the `System.Windows.Input` namespace and allows you to encapsulate the
    logic for executing a specific action and determining whether that action can
    be executed in a ViewModel. Again, this interface isn’t specific to .NET MAUI;
    it’s an integral part of the .NET BCL.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI应用程序的MVVM模式上下文中，`ICommand`接口在处理用户交互方面发挥着关键作用。`ICommand`是`System.Windows.Input`命名空间的一部分，允许您在ViewModel中封装执行特定操作和确定该操作是否可以执行的逻辑。再次强调，此接口并不仅限于.NET
    MAUI；它是.NET BCL的一个组成部分。
- en: '`ICommand` has two main members: `Execute` and `CanExecute`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICommand`有两个主要成员：`Execute`和`CanExecute`：'
- en: '**Execute (object parameter)**: This method is what gets executed when the
    command is invoked. Through an optional parameter, additional data can be passed
    in if needed.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Execute (object参数)**：当命令被调用时，将执行此方法。如果需要，可以通过可选参数传递额外的数据。'
- en: '**CanExecute (object parameter)**: This method indicates whether the command
    can be executed in its current state or not. Optionally, a parameter can be passed
    in if needed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CanExecute (object参数)**：此方法指示命令在其当前状态下是否可以执行。如果需要，可以传递一个参数。'
- en: '`ICommand` also exposes an event called `CanExecute` method changes, signaling
    the UI to re-evaluate whether the command can be executed. This enables automatic
    enabling/disabling of UI elements (such as buttons) based on the current state
    of the application.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICommand`还公开了一个名为`CanExecute`方法更改的事件，该事件会通知UI重新评估命令是否可以执行。这使UI元素（如按钮）的自动启用/禁用成为可能，这些元素的状态基于应用程序的当前状态。'
- en: To use `ICommand` in your ViewModel, you can create a custom command class that
    implements the `ICommand` interface or use a built-in command class such as `Microsoft.Maui.Controls.Command`.
    There are also third-party implementations available such as `CommunityToolkit.Mvvm.Input.RelayCommand`
    from the MVVM Toolkit, which we will dive into in more detail in [*Chapter 5*](B20941_05.xhtml#_idTextAnchor086),
    *Community Toolkits*. Typically, these implementations contain a method called
    `ChangeCanExecute` or `NotifyCanExecuteChanged`, which is called the `CanExecuteChanged`
    event.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 ViewModel 中使用 `ICommand`，你可以创建一个实现 `ICommand` 接口的自定义命令类，或者使用内置的命令类，如 `Microsoft.Maui.Controls.Command`。还有来自
    MVVM Toolkit 的第三方实现，例如 `CommunityToolkit.Mvvm.Input.RelayCommand`，我们将在 [*第 5 章*](B20941_05.xhtml#_idTextAnchor086)，*社区工具包*
    中更详细地探讨。通常，这些实现包含一个名为 `ChangeCanExecute` 或 `NotifyCanExecuteChanged` 的方法，这被称为
    `CanExecuteChanged` 事件。
- en: Now that you’re familiar with the `ICommand` interface and its role in a ViewModel,
    it’s time to see it in action.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经熟悉了 `ICommand` 接口及其在 ViewModel 中的作用，是时候看看它在实际中的应用了。
- en: Putting it into action
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将其付诸实践
- en: 'As a simple demonstration, we want to allow users to add or remove a recipe
    as a favorite. For this, let’s add two buttons to `RecipeDetailPage`, right below
    the `VerticalStackLayout` that contains the `CheckBox` element to display the
    allergen information:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的演示，我们希望允许用户添加或删除菜谱作为收藏。为此，让我们向 `RecipeDetailPage` 添加两个按钮，位于包含显示过敏信息 `CheckBox`
    元素的 `VerticalStackLayout` 下方：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first button’s `Command` property binds to the `AddAsFavoriteCommand` property
    on our binding source, `RecipeDetailViewModel`. This button should allow a user
    to mark a recipe as a favorite when the recipe is not yet favorited. The second
    button does the exact opposite: it should allow a user to remove a recipe as a
    favorite. Let’s take a look at the implementation of both commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮的 `Command` 属性绑定到我们的绑定源 `RecipeDetailViewModel` 上的 `AddAsFavoriteCommand`
    属性。这个按钮应该允许用户在菜谱尚未收藏时将其标记为收藏。第二个按钮则正好相反：它应该允许用户取消收藏菜谱。让我们看看这两个命令的实现：
- en: 'In `RecipeDetailViewModel`, we can add an `IsFavorite` property:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecipeDetailViewModel` 中，我们可以添加一个 `IsFavorite` 属性：
- en: '[PRE20]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This property holds a `bool` value to indicate whether the user has marked this
    recipe as a favorite or not.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个属性包含一个 `bool` 值，用来指示用户是否已将此菜谱标记为收藏。
- en: '2.  Next, we need to add the two commands, `AddAsFavoriteCommand` and `RemoveAsFavoriteCommand`:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  接下来，我们需要添加两个命令，`AddAsFavoriteCommand` 和 `RemoveAsFavoriteCommand`：
- en: '[PRE21]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These are the two properties of type `ICommand` that the `Command` properties
    of the buttons bind to.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是按钮的 `Command` 属性绑定到的两个类型为 `ICommand` 的属性。
- en: 3.  Now, we need to instantiate both commands. Whilst .NET contains an `ICommand`
    interface, it doesn’t contain a concrete implementation. .NET MAUI, on the other
    hand, does have one! In order to access this implementation from the `Recipes.Client.Core`
    project, we need to configure the project to use the .NET MAUI framework.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，我们需要实例化这两个命令。虽然 .NET 包含一个 `ICommand` 接口，但它没有具体的实现。另一方面，.NET MAUI 确实有一个实现！为了从
    `Recipes.Client.Core` 项目访问这个实现，我们需要配置项目以使用 .NET MAUI 框架。
- en: 'In the `Recipes.Client.Core` project. This should open up the associated `csproj`
    file, wherein you need to add `<UseMaui>true</UseMaui>`:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Recipes.Client.Core` 项目中。这应该会打开相关的 `csproj` 文件，其中你需要添加 `<UseMaui>true</UseMaui>`：
- en: '[PRE22]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows us to access .NET MAUI-specific libraries from our `Core` project,
    such as `Microsoft.Maui.Controls.Command`, which implements `ICommand`.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使我们能够从我们的 `Core` 项目访问 .NET MAUI 特定的库，例如 `Microsoft.Maui.Controls.Command`，它实现了
    `ICommand` 接口。
- en: '4.  In the constructor of `RecipeDetailViewModel`, we can now instantiate `AddAsFavoriteCommand`
    and `RemoveAsFavoriteCommand`:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  在 `RecipeDetailViewModel` 构造函数中，我们现在可以实例化 `AddAsFavoriteCommand` 和 `RemoveAsFavoriteCommand`：
- en: '[PRE23]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we have two commands on the ViewModel: `AddAsFavoriteCommand`
    and `RemoveAsFavoriteCommand`. Each command is created with an associated `Action`
    and a `Func<bool>` to determine its executability.'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 ViewModel 中有两个命令：`AddAsFavoriteCommand` 和 `RemoveAsFavoriteCommand`。每个命令都使用一个相关的
    `Action` 和一个 `Func<bool>` 来确定其可执行性。
- en: '`AddAsFavoriteCommand` has an `AddAsFavorite` method as its action, which simply
    sets the `IsFavorite` property to `true`. Its `CanExecute` method is determined
    by the `CanAddAsFavorite` method, which returns `true` when the `IsFavorite` property
    has a value of `false`.'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AddAsFavoriteCommand` 有一个 `AddAsFavorite` 方法作为其操作，它只是将 `IsFavorite` 属性设置为
    `true`。它的 `CanExecute` 方法由 `CanAddAsFavorite` 方法确定，当 `IsFavorite` 属性的值为 `false`
    时返回 `true`。'
- en: On the other hand, `RemoveAsFavoriteCommand` has a `RemoveAsFavorite` method
    as its action, which sets the `IsFavorite` property to `false`. The `CanRemoveAsFavorite`
    method is provided as the `CanExecute` check for this command, and it returns
    `true` when the `IsFavorite` property has a value of `true`.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，`RemoveAsFavoriteCommand`有一个`RemoveAsFavorite`方法作为其操作，它将`IsFavorite`属性设置为`false`。`CanRemoveAsFavorite`方法提供为此命令的`CanExecute`检查，并且当`IsFavorite`属性值为`true`时返回`true`。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that it is up to the control to check and adhere to the
    `CanExecute` method. It should not be a thing to blindly rely on, as it might
    not be implemented or work the way you expect. Make sure to read the control’s
    documentation and test it thoroughly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，检查并遵守`CanExecute`方法的责任在于控件。它不应该是一个盲目依赖的东西，因为它可能没有实现或者没有按照你预期的样子工作。确保阅读控件的文档并彻底测试它。
- en: In summary, when the `IsFavorite` property is `true`, only `RemoveAsFavoriteCommand`
    can be executed, while  `AddAsFavoriteCommand` cannot be. Conversely, when the
    `IsFavorite` property is `false`, `AddAsFavoriteCommand` can be executed, and
    `RemoveAsFavoriteCommand` cannot be. This ensures that the appropriate command
    is available for execution based on the current state of the `IsFavorite` property.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当`IsFavorite`属性为`true`时，只有`RemoveAsFavoriteCommand`可以执行，而`AddAsFavoriteCommand`不能执行。相反，当`IsFavorite`属性为`false`时，`AddAsFavoriteCommand`可以执行，而`RemoveAsFavoriteCommand`不能执行。这确保了根据`IsFavorite`属性当前的状态，可以执行适当的命令。
- en: 'There is just one piece of the puzzle missing: whenever the `IsFavorite` property’s
    value changes, the `CanExecute` method of both commands needs to be re-evaluated.
    In order to do that, we need to update the setter of the `IsFavorite` property:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只缺少一个拼图碎片：每当`IsFavorite`属性的值发生变化时，两个命令的`CanExecute`方法都需要重新评估。为了做到这一点，我们需要更新`IsFavorite`属性的设置器：
- en: '[PRE24]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With all this code in place, we can run the app again. By default, only the
    first button (bound to `AddAsFavoriteCommand`) is enabled when the recipe is not
    a user favorite. Upon clicking this button, the `IsFavorite` property is updated,
    and the `ChangeCanExecute` method is called for both commands. As a result, the
    first button becomes disabled, while the second button (bound to `RemoveAsFavoriteCommand`)
    is automatically enabled. This ensures that the correct button is enabled or disabled
    based on the `IsFavorite` property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些代码就绪后，我们可以再次运行应用程序。默认情况下，当食谱不是用户喜欢的时，只有第一个按钮（绑定到`AddAsFavoriteCommand`）是启用的。点击此按钮后，`IsFavorite`属性被更新，并且两个命令的`ChangeCanExecute`方法被调用。结果，第一个按钮变为禁用，而第二个按钮（绑定到`RemoveAsFavoriteCommand`）自动启用。这确保了根据`IsFavorite`属性正确地启用或禁用按钮。
- en: 'Alternatively, we could also use a single command and use a `CommandParameter`
    to handle the toggling of the `IsFavorite` property:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用单个命令并使用`CommandParameter`来处理`IsFavorite`属性的切换：
- en: 'For that, let’s add a new `SetFavoriteCommand` property of type `ICommand`
    and initialize it in the constructor of `RecipeDetailViewModel`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们添加一个新的`SetFavoriteCommand`属性，其类型为`ICommand`，并在`RecipeDetailViewModel`的构造函数中初始化它：
- en: '[PRE25]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By assigning the command to an instance of `Command<bool>`, we are specifying
    that we expect a parameter of type bool in both the `Execute` and `CanExecute`
    methods.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将命令分配给`Command<bool>`的实例，我们指定在`Execute`和`CanExecute`方法中我们期望一个布尔类型的参数。
- en: 2.  In the setter of the `IsFavorite` property, we now need to call the `CanExecuteChanged`
    method of `SetFavoriteCommand`.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 在`IsFavorite`属性的设置器中，我们现在需要调用`SetFavoriteCommand`的`CanExecuteChanged`方法。
- en: 'Finally, we can update the binding statements on both buttons:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以更新两个按钮的绑定语句：
- en: '[PRE26]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both buttons call the same command, but they each pass in a different parameter,
    which gets passed to both the `Execute` and `CanExecute` methods.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个按钮调用相同的命令，但它们各自传递不同的参数，这些参数被传递到`Execute`和`CanExecute`方法中。
- en: UseMaui and MVVM best practices
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maui和MVVM最佳实践
- en: In this chapter, we introduced the `UseMaui` property in our `Core` project,
    which may seem to contradict our previous statements about ViewModels being framework-agnostic.
    While adhering to the MVVM pattern, it is recommended to keep the ViewModels free
    from any framework-specific dependencies. However, in this specific case, we have
    opted for a more practical approach to demonstrate an implementation of `ICommand`
    through the `Microsoft.Maui.Controls.Command` class. In a strictly MVVM-compliant
    scenario, you would want to avoid such dependencies in your ViewModels to ensure
    maximum flexibility and maintainability.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在`Core`项目中引入了`UseMaui`属性，这可能会与我们对ViewModels框架无关的先前声明相矛盾。虽然遵循MVVM模式，但建议保持ViewModels不受任何框架特定依赖的影响。然而，在这个特定的情况下，我们选择了更实用的方法来演示通过`Microsoft.Maui.Controls.Command`类实现`ICommand`的实例。在一个严格遵循MVVM的场景中，你希望在ViewModels中避免这样的依赖，以确保最大的灵活性和可维护性。
- en: In [*Chapter 5*](B20941_05.xhtml#_idTextAnchor086), *Community Toolkits*, we
    will take a look at the possibility of how to improve this code so that it follows
    these best practices more closely.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B20941_05.xhtml#_idTextAnchor086)，*社区工具包*中，我们将探讨如何改进这段代码，使其更接近这些最佳实践。
- en: 'As a little extra, we also might want to display an icon indicating whether
    a recipe is a favorite or not. The visibility of this icon can be bound to the
    `IsFavorite` property. When toggling this property through the buttons and commands
    we’ve just created, the icon’s visibility will be updated as well:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的功能，我们可能还想显示一个图标来指示一个菜谱是否是收藏的。这个图标的可见性可以绑定到`IsFavorite`属性。当我们通过我们刚刚创建的按钮和命令切换这个属性时，图标的可见性也会更新：
- en: First, let’s add the `Chapter 03``/Assets/favorite.png` file to the `Resources/Images`
    folder in the `favorite.png` file. You might need to adjust the file type filter
    in the file picker popup to include `.``png` file.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将`Chapter 03``/Assets/favorite.png`文件添加到`Resources/Images`文件夹中的`favorite.png`文件。你可能需要调整文件选择器弹出窗口中的文件类型过滤器，以包括`.png`文件。
- en: 'In `RecipeDetailPage.xaml`, add the following XAML directly below the `Label`
    displaying the recipe’s title:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RecipeDetailPage.xaml`中，在显示菜谱标题的`Label`下方直接添加以下XAML：
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now when we tap the **Add as favorite** or **Remove as favorite** button, you
    should see the favorite icon appearing or disappearing.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们点击**添加为收藏**或**从收藏中移除**按钮时，你应该看到收藏图标出现或消失。
- en: The `ICommand` interface plays a vital role in implementing the MVVM. By encapsulating
    user interactions within commands, it promotes a clean separation of concerns
    between the View and ViewModel. This allows for more maintainable, testable, and
    modular code. As demonstrated, `ICommand`, along with its `CanExecute` functionality,
    ensures that the appropriate actions are available to users based on the application’s
    state, further enhancing the user experience. By leveraging `ICommand`, developers
    can effectively implement the MVVM pattern.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICommand`接口在实现MVVM中扮演着至关重要的角色。通过在命令中封装用户交互，它促进了视图和ViewModel之间关注点的清晰分离。这允许代码更加可维护、可测试和模块化。正如所展示的，`ICommand`及其`CanExecute`功能确保了根据应用程序的状态，用户可以获得适当的操作，从而进一步增强用户体验。通过利用`ICommand`，开发者可以有效地实现MVVM模式。'
- en: As we’ve explored the `ICommand` interface, you may be interested to know that
    there are additional tools and resources available for implementing MVVM in .NET
    MAUI. Thanks to the fantastic .NET and .NET MAUI community, various Community
    Toolkits provide even more support for the MVVM pattern in your projects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索`ICommand`接口，你可能想知道，还有额外的工具和资源可用于在.NET MAUI中实现MVVM。多亏了出色的.NET和.NET MAUI社区，各种社区工具包为你的项目提供了更多对MVVM模式的支持。
- en: Summary
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the core components that enable the MVVM pattern
    in .NET MAUI. We discussed the essential building blocks, including `BindableObject`,
    `BindableProperty`, and `BindingContext`, and how they facilitate seamless communication
    between the View and ViewModel. Furthermore, we examined the importance of the
    `INotifyPropertyChanged` interface in notifying the UI of changes in ViewModel
    properties and demonstrated how the `ICommand` interface helps handle user interactions
    in a decoupled manner. By understanding these fundamental concepts, it becomes
    evident why .NET MAUI and the MVVM pattern are such a harmonious match.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了使 .NET MAUI 中的 MVVM 模式得以实现的核心理念。我们讨论了基本构建块，包括 `BindableObject`、`BindableProperty`
    和 `BindingContext`，以及它们如何促进视图和视图模型之间的无缝通信。此外，我们还考察了 `INotifyPropertyChanged` 接口在通知
    UI 视图模型属性变化中的重要性，并展示了 `ICommand` 接口如何以解耦的方式处理用户交互。通过理解这些基本概念，我们可以清楚地看到为什么 .NET
    MAUI 和 MVVM 模式如此和谐地匹配。
- en: As we move on to [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding
    in .NET MAUI*, we will take a closer look at data binding, diving deeper into
    topics such as value converters, fallback values, element and relative binding,
    multi-bindings, and compiled bindings. This will enable you to leverage the full
    power of data binding. Let’s continue our journey!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续进入第 *4 章* [数据绑定在 .NET MAUI 中](B20941_04.xhtml#_idTextAnchor069)，我们将更深入地研究数据绑定，包括值转换器、回退值、元素和相对绑定、多绑定以及编译绑定等主题。这将使你能够充分利用数据绑定的全部功能。让我们继续我们的旅程！
- en: Further reading
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Bindable properties: [https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties](https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可绑定属性：[https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties](https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties)
- en: 'The `BindableObject` class: [https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject](https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BindableObject` 类：[https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject](https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject)'
- en: 'The `INotifyPropertyChanged` interface: [https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged](https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged` 接口：[https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged](https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged)'
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
