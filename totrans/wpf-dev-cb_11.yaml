- en: Interoperability with Win32 and WinForm
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Hosting WinForm controls in WPF applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting WPF controls in WinForm applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Win32 APIs from WPF applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding ActiveX controls in WPF applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **interoperability** describes the capability of different applications
    to exchange data via a common set of exchangeable formats. It is a characteristic
    of the product or system, whose interfaces are completely understood, to work
    with other products or systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: WPF and Windows Forms present two different architectures for creating application
    interfaces. The `WindowsFormsHost` and `ElementHost` classes are used to implement
    the interoperation capabilities between these two.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, WPF provides interoperability with Win32 programs, which are written
    in unmanaged C++ code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a955b43-8436-49ad-a54f-f6832f9ef5d3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will start with interoperation between WPF and WinForm,
    demonstrating the way to host a WinForm control in a WPF application and a WPF
    control in a WinForm application. Then, we will move forward to learn interoperability
    between WPF and Win32, followed by embedding ActiveX controls inside WPF.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Hosting WinForm controls in WPF applications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though **Windows Platform Foundation** (**WPF**) provides a huge set of controls
    with a rich set of features, there can still be chances of various cases when
    you have some **Windows Form** (**WinForm**) controls that are not available in
    WPF. There could be some cases too, when you are porting your WinForm application
    to WPF, where you have no other choice than reusing existing controls and/or forms,
    as the reimplementation will burn huge efforts. So, what needs to be done in such
    cases?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: WPF provides a way to reuse existing controls from Windows Forms and host them
    inside it (whether in a control, a window, or a page). This is called interoperation
    between the two platforms as they present two different architectures for creating
    application interfaces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Windows.Forms.Integration` namespace provides you with the classes
    that enable the common interoperation scenarios, whereas the `WindowsFormsHost`
    class provides you with the capability to implement the interoperation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing interoperation between the two technologies to host a Windows
    Forms control inside WPF, the following scenarios may occur applicable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: One or more WinForm controls can be hosted in WPF
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more composite controls can be hosted in a WPF element
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more ActiveX controls can also be hosted in WPF
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WinForm container controls containing other WinForm controls can also be
    hosted
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also host a master/detail form with WPF as master, WinForm as details,
    and/or WinForm as master, and WPF as details
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A point to note is that multilevel hybrid controls are not supported. A **multilevel
    hybrid control** contains a control from one technology inside a control from
    another technology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take WinForm's `PropertyGrid` control as an example,
    which is not available in WPF, and will host it inside a WPF window using the
    `WindowsFormsHost` control.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating a new WPF application. Open your Visual Studio IDE,
    and create a new project named `CH11.WinFormInWpfXamlDemo`. Make sure to select
    WPF App as the project template.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to host a WinForm control inside a WPF application window
    and map its properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Begin with opening the WPF application window. From Solution Explorer, open
    the `MainWindow.xaml` file.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s split the default `Grid` panel to have two columns. The second column
    will have a width based on its child elements, and the first column will accommodate
    the rest of the space. Add the following XAML mark-up inside `Grid` to split it
    by the specific requirement:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Place a `TextBlock` control inside the first cell (0^(th) column) of `Grid`,
    name it as `txtBlock`, and set `Hello World!` as its `Text` property:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, after the `TextBlock` control, add a `<WindowsFormsHost> </WindowsFormsHost>`
    element. When added, this will throw the following design-time error message—WindowsFormsHost
    is not supported in a Windows Presentation Foundation (WPF) project. This is because
    the required assembly to resolve the `WindowsFormsHost` element is not referenced
    in this project:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad6839aa-df5f-4164-8fc9-085f7bb081cb.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: To add the dependent assembly references in the project, right-click on the
    project node and select Add | Reference... from the context menu entries.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Reference Manager dialog window, check the following two assembly
    references (System.Windows.Forms and WindowsFormsIntegration) and click OK, which
    will add the references in the project:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa791620-0266-4ab1-87b6-6ead98c6e89f.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Check the XAML file now. The preceding design-time error will now go away, as
    the required assembly reference has been established.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the `<WindowsFormsHost>` in the second column (`Grid.Column="1"`) and
    set its `Width` property to `300`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, inside the `WindowsFormsHost` element, place another element of type `PropertyGrid`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need to add the XMLNS namespace for the `PropertyGrid` to resolve from
    the `System.Windows.Forms` assembly. As shown in the following screenshot, click
    the lightbulb icon, or simply press *CTRL +* to add the required XMLNS entry to
    the `MainWindow.xaml` file:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c81326c-b495-4a67-a651-228715a18d0b.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can add the following XMLNS declaration to the `Window`
    tag:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add `x:Name="propertyGrid"` to the `PropertyGrid` element to define it with
    a name. This will be useful later when we want to access it from the code. Here''s
    the complete XAML markup of the `Grid` that we will be using here:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once done, let''s run the application. You will see the following output, having
    text and an empty property grid:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dedc978f-07d7-4a35-a9f9-121cd026d1b9.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Let's navigate to the code behind file (`MainWindow.xaml.cs`) of the application
    window.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导航到应用程序窗口背后的代码文件（`MainWindow.xaml.cs`）。
- en: 'Just after the `InitializeComponent()` call inside the constructor of `MainWindow`,
    add the following line, `propertyGrid.SelectedObject = txtBlock;`, to set the
    `SelectionObject` property of the property grid that we have already added in
    the UI. After this change, the code will look as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`构造函数中的`InitializeComponent()`调用之后，添加以下行，`propertyGrid.SelectedObject
    = txtBlock;`，以设置我们已在UI中添加的属性网格的`SelectionObject`属性。此更改后，代码将如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s run the application again. This time you will see that the property
    grid contains a set of properties, pointing to the `txtBlock` control placed in
    the window:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行应用程序。这次您将看到属性网格包含一组属性，指向窗口中放置的`txtBlock`控件：
- en: '![](img/40af7fae-9137-4880-8fd5-af19c60a5bfa.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40af7fae-9137-4880-8fd5-af19c60a5bfa.png)'
- en: 'Scroll up the property grid and change the FontSize property inside the grid
    to `40`. This will have immediate effect to the font-size of the text that we
    have added in the UI:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向上滚动属性网格，并将网格内的`FontSize`属性更改为`40`。这将立即影响我们已在UI中添加的文本的字体大小：
- en: '![](img/06b8a6e8-b9ae-4102-a59a-08fc1ce367be.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06b8a6e8-b9ae-4102-a59a-08fc1ce367be.png)'
- en: Similarly, change some other properties such as HorizontalAlignment, VerticalAlignment,
    FontStyle, FontWeight, Foreground, and so on, and see the effect on the screen:![](img/41f289b2-2629-4ce7-abfb-834d1d555a24.png)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，更改一些其他属性，如HorizontalAlignment、VerticalAlignment、FontStyle、FontWeight、Foreground等，并查看屏幕上的效果！[](img/41f289b2-2629-4ce7-abfb-834d1d555a24.png)
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `PropertyGrid` control, part of the .NET Framework, allows you to browse,
    view, and edit the properties of one or more objects. It uses reflection to retrieve
    and display properties of any object or type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyGrid`控件是.NET Framework的一部分，它允许您浏览、查看和编辑一个或多个对象的属性。它使用反射来检索和显示任何对象或类型的属性。'
- en: '**Reflection** is a technology that allows you to retrieve the type information
    at runtime.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射**是一种允许您在运行时检索类型信息的技术。'
- en: If you are using WinForm, you will be able to use the `PropertyGrid` control
    easily from the control toolbar. But, unfortunately, this control is not available
    in WPF. To use this inside a WPF application, you will need to use the interoperability
    of WPF and WinForm. For this to work, we need to use the `WindowsFormsHost` class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用WinForm，您将能够从控件工具栏轻松使用`PropertyGrid`控件。但是，不幸的是，此控件在WPF中不可用。要在WPF应用程序中使用此控件，您需要使用WPF和WinForm的互操作性。为此，我们需要使用`WindowsFormsHost`类。
- en: The `WindowsFormsHost` class allows you to host a Windows Forms control on a
    WPF page. It is part of the `System.Windows.Forms.Integration` namespace and it
    is available inside the `WindowsFormsIntegration.dll` assembly. That's the reason
    why we had to reference the `System.Windows.Forms` and `WindowsFormsIntegration`
    assemblies inside the project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowsFormsHost`类允许您在WPF页面上托管Windows Forms控件。它是`System.Windows.Forms.Integration`命名空间的一部分，并且可在`WindowsFormsIntegration.dll`程序集内部使用。这就是为什么我们必须在项目中引用`System.Windows.Forms`和`WindowsFormsIntegration`程序集。'
- en: The default location for the `WindowsFormsIntegration.dll` assembly is `%programfiles%Reference
    AssembliesMicrosoftFrameworkv3.0`, which comes with the other WPF assemblies.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowsFormsIntegration.dll`程序集的默认位置是`%programfiles%Reference AssembliesMicrosoftFrameworkv3.0`，它与其他WPF程序集一起提供。'
- en: Once the hosting of the WinForm control is successful inside a WPF window, you
    can then set/get its properties. In the preceding example, we assigned the `txtBlock`
    control (which is a WPF control) as the `SelectedObject` property of the `propertyGrid`
    control (which is a WinForm control). Thus, when you run the application, it uses
    reflection to retrieve all the properties exposed by the `TextBlock` control (`txtBlock`)
    and populates those inside the `PropertyGrid` with the default values set to each
    one of them. When you modify a property value at runtime, it changes the associated
    control based on the selection. Hence, you can see a change in the UI of `TextBlock`,
    when you change the `FontSize`, `Foreground`, and other properties.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在WPF窗口内成功托管WinForm控件，您就可以设置/获取其属性。在上面的示例中，我们将`txtBlock`控件（WPF控件）分配给`propertyGrid`控件的`SelectedObject`属性（WinForm控件）。因此，当您运行应用程序时，它使用反射来检索`TextBlock`控件（`txtBlock`）公开的所有属性，并将它们填充到`PropertyGrid`中，每个属性都设置为默认值。当您在运行时修改属性值时，它根据选择更改相关控件。因此，当您更改`FontSize`、`Foreground`和其他属性时，您可以在`TextBlock`的UI中看到变化。
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Though most of the properties work with `WindowsFormsHost`, there are some limitations
    with **z-order** and transformations when used in a hybrid application. By default,
    the `WindowsFormsHost` elements are drawn on top of other WPF elements, and thus
    there exists no-effect of the z-order property on that.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数属性与`WindowsFormsHost`一起工作，但在混合应用程序中使用时，**Z轴**和转换有一些限制。默认情况下，`WindowsFormsHost`元素绘制在其他WPF元素之上，因此Z轴属性对该元素没有影响。
- en: If you want to enable z-ordering, set the `IsRedirected` property of the `WindowsFormsHost`
    to `True`, and the `CompositionMode` property to either `CompositionMode.Full`
    or `CompositionMode.OutputOnly`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想启用Z轴排序，将`WindowsFormsHost`的`IsRedirected`属性设置为`True`，并将`CompositionMode`属性设置为`CompositionMode.Full`或`CompositionMode.OutputOnly`。
- en: As the WinForm controls do not support proper scaling and rotating features,
    the `WindowsFormsHost` element does not scale or rotate with other WPF elements.
    To enable these transforming features, such as z-ordering, set the `IsRedirected`
    property to `True` and the `CompositionMode` property to either `CompositionMode.Full`
    or `CompositionMode.OutputOnly`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WinForm控件不支持适当的缩放和旋转功能，`WindowsFormsHost`元素不会与其他WPF元素一起缩放或旋转。要启用这些转换功能，例如Z轴排序，将`IsRedirected`属性设置为`True`，并将`CompositionMode`属性设置为`CompositionMode.Full`或`CompositionMode.OutputOnly`。
- en: Hosting WPF controls in WinForm applications
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WinForm应用程序中托管WPF控件
- en: As WPF provides a rich user interface to applications, you may want to apply
    the same to your existing applications. But when you have a large Windows Form
    application project, where you already made a large investment, you won't like
    to reinvest on the same to scrap it and rewrite the entire project in WPF.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WPF为应用程序提供了丰富的用户界面，你可能希望将其应用到现有的应用程序中。但是，当你有一个大型的Windows Form应用程序项目，你已经投入了大量资金，你不会愿意再次投资来废弃它，并完全用WPF重写整个项目。
- en: In such cases, WPF interoperation with WinForms is ideal. Using this, you can
    embed a WPF control inside a form and leverage the additional features of WPF,
    wherever possible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，WPF与WinForms的交互是理想的。使用此方法，你可以在表单中嵌入WPF控件，并在可能的情况下利用WPF的额外功能。
- en: In the previous recipe, we learned how to host WinForm controls into a WPF application.
    But in this recipe, we will learn the reverse, that is, how to host a **WPF composite
    control** in a **Windows Forms** application. We will learn this by following
    some simple walkthrough steps. You can extend this procedure later to host more
    complex applications and controls.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们学习了如何在WPF应用程序中托管WinForm控件。但在这个配方中，我们将学习相反的过程，即如何在Windows Forms应用程序中托管**WPF复合控件**。我们将通过遵循一些简单的指南步骤来学习这一点。你可以稍后扩展此过程以托管更复杂的应用程序和控件。
- en: This walkthrough will basically be divided into two logical parts. In the first
    part, we will build a WPF UserControl, and in the second part, we will host it
    inside a form window.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将基本上分为两个逻辑部分。在第一部分，我们将构建一个WPF UserControl，在第二部分，我们将将其托管在一个表单窗口中。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start with this recipe to host a WPF control in a Windows Form, make
    sure that Visual Studio is up and running.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用此配方在Windows Form中托管WPF控件之前，请确保Visual Studio正在运行。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow these steps to create a WPF composite control and host it inside
    the Windows Form:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个WPF复合控件，并将其托管在Windows Form中：
- en: First, let's create a **WPF User Control Library** project. To do this, from
    Solution Explorer, right-click on the existing solution and select Add | New Project...
    from the context menu.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个**WPF用户控件库**项目。为此，从解决方案资源管理器中，右键单击现有解决方案，并在上下文菜单中选择添加 | 新项目...。
- en: 'Select WPF User Control Library (.NET Framework) as the project template, name
    it as `CH11.WpfUserControlLibrary`, and click the OK button, as shown in the following
    screenshot:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择WPF用户控件库(.NET Framework)作为项目模板，将其命名为`CH11.WpfUserControlLibrary`，然后单击OK按钮，如图所示：
- en: '![](img/d503d6b6-8e16-4829-9585-75f93348ee2a.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d503d6b6-8e16-4829-9585-75f93348ee2a.png)'
- en: Once the project gets created by Visual Studio, you will find a user control
    named `UserControl1.xaml`, inside the project folder. From Solution Explorer,
    double-click on it to open it.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Visual Studio创建了项目，你将在项目文件夹中找到一个名为`UserControl1.xaml`的用户控件。从解决方案资源管理器中双击它以打开它。
- en: 'Divide the default `Grid` of the `UserControl1` into two columns. Set the first
    column as stretchable to occupy maximum available space and set the second column
    as `Auto`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UserControl1`的默认`Grid`分为两列。将第一列设置为可伸缩的，以占用最大可用空间，并将第二列设置为`Auto`：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Place a `TextBox` control inside the first column and name it as `searchBox`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一列中放置一个名为`searchBox`的`TextBox`控件：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Place a `Button` control, named `searchButton`, and place it inside the second
    column of the `Grid`. Set its `Content` property to Search and register its `Click`
    event with `OnSearchButtonClicked`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置一个名为`searchButton`的`Button`控件，并将其放置在`Grid`的第二列中。将其`Content`属性设置为搜索，并将其`Click`事件注册为`OnSearchButtonClicked`：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the complete XAML of `Grid`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是`Grid`的完整XAML代码：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, press *F7* to navigate to the code behind the `UserControl1.xaml.cs` file.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按*F7*键导航到`UserControl1.xaml.cs`文件的代码后端。
- en: 'Insert the following event implementation inside the class:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中插入以下事件实现：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, it''s time to integrate the created user control inside a Windows Form.
    For this, we need a WinForm project. Let''s add the new project inside the solution.
    To do this, from Solution Explorer, right-click on the solution file and select
    Add | New Project... from the context menu. Use the following Windows Forms App
    (.NET Framework) template during project creation. Name it as `CH11.WpfInWinFormDemo`
    and click the OK button:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候将创建的用户控件集成到Windows表单中了。为此，我们需要一个WinForm项目。让我们在解决方案中添加新的项目。为此，从解决方案资源管理器中，右键单击解决方案文件，从上下文菜单中选择添加
    | 新项目...。在创建项目时使用以下Windows Forms App (.NET Framework)模板。将其命名为`CH11.WpfInWinFormDemo`并点击确定按钮：
- en: '![](img/93863ea5-9950-4f1a-a495-ca0c8b9bc5e4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93863ea5-9950-4f1a-a495-ca0c8b9bc5e4.png)'
- en: Once the project gets created, you need to add the reference of the UserControl
    Library into this project. To do so, right-click on the References node of the
    `CH11.WpfInWinFormDemo` project and then click Add Reference... from the context
    menu.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，您需要将UserControl库的引用添加到该项目中。为此，在`CH11.WpfInWinFormDemo`项目的引用节点上右键单击，然后从上下文菜单中点击添加引用...：
- en: 'From the Reference Manager dialog, as shown in the following screenshot, expand
    the Projects entry, select the desired library project (in our case, it is CH11.WpfUserControlLibrary),
    and click OK. This will add the reference of the library into the project:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从引用管理器对话框中，如图所示，展开项目条目，选择所需的库项目（在我们的例子中是CH11.WpfUserControlLibrary），然后点击确定。这将把库的引用添加到项目中：
- en: '![](img/3f3fab58-6c54-4f50-af77-3a04b9b3bfe7.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f3fab58-6c54-4f50-af77-3a04b9b3bfe7.png)'
- en: Also, add the following assembly references—`PresentationCore`, `PresentationFramework`,
    `System.Xaml`, `WindowsBase`, and `WindowsFormsIntegration` inside the project.
    These are required to use WPF controls and host them.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在项目中添加以下程序集引用—`PresentationCore`、`PresentationFramework`、`System.Xaml`、`WindowsBase`和`WindowsFormsIntegration`。这些是使用WPF控件并托管它们的必需项。
- en: Rebuild the solution and make sure that the solution is building without any
    errors. This step also ensures that the library project gets compiled and becomes
    discoverable in the main project.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建解决方案并确保解决方案构建时没有错误。这一步也确保了库项目被编译并可在主项目中被发现。
- en: From Solution Explorer, double-click on the `Form1.cs` file to open it.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中双击`Form1.cs`文件以打开它。
- en: 'Now, open the Toolbox, and as shown in the following screenshot, drag the ElementHost
    element to the form (`Form1.cs`), from the WPF Interoperability section:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开工具箱，如图所示，从WPF互操作性部分拖动ElementHost元素到表单（`Form1.cs`）中：
- en: '![](img/56707bef-7d48-49df-a0ed-6775ede02851.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56707bef-7d48-49df-a0ed-6775ede02851.png)'
- en: 'Expand the small arrow-head of the `ElementHost` element to select the hosted
    content. As shown in the following screenshot, click on the Select Hosted Content
    combo and select UserControl1 to host inside it:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开ElementHost元素的箭头，以选择托管内容。如图所示，点击选择托管内容组合框并选择UserControl1以在其中托管：
- en: '![](img/790bf580-b88a-4f97-a0f4-610b7444a53a.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/790bf580-b88a-4f97-a0f4-610b7444a53a.png)'
- en: 'Alternatively, you can also drag UserControl1 from the toolbox. In this case,
    Visual Studio will add the `ElementHost` and configure it to load the UserControl
    that you have dragged to the form. Once done, resize the control and position
    it inside the form:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您也可以从工具箱中拖动UserControl1。在这种情况下，Visual Studio将添加`ElementHost`并配置它以加载您拖到表单中的UserControl。完成后，调整控件大小并将其放置在表单中：
- en: '![](img/f7cb1f72-94f8-4bb4-8657-0a2f1cba0ac8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7cb1f72-94f8-4bb4-8657-0a2f1cba0ac8.png)'
- en: Now rebuild the solution again and run the form application (`CH11.WpfInWinFormDemo`).
    You will see a form window on the screen, containing the WPF UserControl that
    we have created. It basically consists of a `TextBox` and a `Button`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次重新构建解决方案并运行表单应用程序（`CH11.WpfInWinFormDemo`）。您将在屏幕上看到一个表单窗口，其中包含我们创建的WPF UserControl。它基本上由一个`TextBox`和一个`Button`组成。
- en: 'Enter some text in the search box and click the button. You will see the message
    box pop up on the screen, containing the text that you have entered:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a0e2448a-1224-40bb-86e5-fe80394dc819.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To host the **WPF composite control**, the `ElementHost` object is used inside
    the Windows Forms host application. The `ElementHost` class is part of the `System.Windows.Forms.Integration`
    namespace, and thus you will need to reference the `WindowsFormsIntegration.dll`
    in the project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: To host a WPF element in a Windows Form, you must assign it to the `Child` property
    of the `ElementHost` control. If it is required, use the `PropertyMap` property
    to assign the custom mappings between an `ElementHost` and its hosted WPF element.
    Optionally, you can use the boolean `BackColorTransparent` property to set a transparent
    background to the hosted element.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Calling Win32 APIs from WPF applications
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Presentation Foundation and Win32 interpolation can work as different
    approaches. You can either host a Win32 application in a WPF application, a WPF
    application in a Win32 application, or call a Win32 API from WPF by importing
    the specified system DLL. These are often useful when you have already invested
    a lot in Win32 applications and now you would like to build a rich WPF application
    by utilizing the existing code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to call a Win32 API from a WPF. We will use
    a simple example to launch a browser window and then activate/refresh the browser
    window from our WPF code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get started by creating a WPF application. Open your Visual Studio IDE, and
    create a new project named `CH11.Win32ApiCallDemo`. Make sure to select WPF App
    (.NET Framework) as the project template.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to give a call to Win32 APIs from WPF applications:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set up the project. Once the project gets created by Visual
    Studio, right-click on the References node of the project.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the context menu entry Add Reference... to add assembly references.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Reference Manager dialog, search for forms, and select System.Windows.Forms
    from the list. Click OK to add the reference:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/527e8f84-db19-4208-ada0-bf771ca78cdc.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Now, from Solution Explorer, navigate to the `MainWindow.xaml` file.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `Grid` panel with the following markup, which contains
    a `TextBox` (`address`) and three `Button` controls (`goButton`, `bringToFrontButton`,
    and `refreshButton`):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the UI is ready, it's time to create the button click event implementations.
    Press *F7* within the XAML page to navigate to its code behind. Alternatively,
    you can open the `MainWindow.xaml.cs` file from Solution Explorer.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the code behind the file, add the following namespaces:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, inside the `MainWindow` class, add the following declarations and make
    sure that the `DllImport` attribute and the `Process` class are discoverable:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s implement the `OnGoClicked` event handler. Copy the following code to
    launch Internet Explorer with the specified URL address, which is `http://www.kunal-chowdhury.com`
    in our case:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现 `OnGoClicked` 事件处理器。将以下代码复制以使用指定的 URL 地址启动 Internet Explorer，在我们的例子中是
    `http://www.kunal-chowdhury.com`：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s implement the `OnBringToFrontClicked` event handler to bring the launched
    Internet Explorer window to the front, if it lost its focus. Copy the following
    code to get the `MainWindowHandle` of the process instance and call the Win32
    API method, `SetForegroundWindow`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现 `OnBringToFrontClicked` 事件处理器，以将启动的 Internet Explorer 窗口带到前台，如果它失去了焦点。将以下代码复制以获取进程实例的
    `MainWindowHandle` 并调用 Win32 API 方法 `SetForegroundWindow`：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s add the event implementation of the Refresh button. Add the following
    `OnRefreshClicked` handler inside the class file to activate the Internet Explorer
    window and then call the *F5* key of the keyboard to refresh the said browser
    window:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加刷新按钮的事件实现。在类文件中添加以下 `OnRefreshClicked` 处理器以激活 Internet Explorer 窗口，然后调用键盘上的
    *F5* 键来刷新该浏览器窗口：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As the code implementation is done, let's run the application. You will see
    the following UI on the screen:![](img/6187bcb6-2f5c-4a23-bf9d-e1f2e6405b5c.png)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码实现完成后，让我们运行应用程序。你将在屏幕上看到以下 UI：![图片](img/6187bcb6-2f5c-4a23-bf9d-e1f2e6405b5c.png)
- en: 'As the address field of the application is already populated, click on the
    Go... button. This will launch Internet Explorer and will navigate to the address
    specified:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于应用程序的地址字段已经填充，点击“转到...”按钮。这将启动 Internet Explorer 并导航到指定的地址：
- en: '![](img/b8b57c2c-0eda-402e-9fdf-d3b434e03db9.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8b57c2c-0eda-402e-9fdf-d3b434e03db9.png)'
- en: Now, click on the application window. This will bring the application to the
    front.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击应用程序窗口。这将使应用程序带到前台。
- en: Now click the BringToFront button, which will activate Internet Explorer and
    bring it to the front.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击“带到前台”按钮，这将激活 Internet Explorer 并将其带到前台。
- en: 'Similarly, click on the application window, and then click on the Refresh button.
    This time, Internet Explorer will activate and refresh the content of the window:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，点击应用程序窗口，然后点击刷新按钮。这次，Internet Explorer 将激活并刷新窗口的内容：
- en: '![](img/f86b8888-e7a2-486c-9f13-70f57861c619.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f86b8888-e7a2-486c-9f13-70f57861c619.png)'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you click the Go... button of the application window, this creates the
    new process of the Internet Explorer (`iexplore.exe`) window and opens the URL
    specified to the process as its `Arguments`, once we call the `process.Start()`
    method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击应用程序窗口的“转到...”按钮时，这会创建一个新进程的 Internet Explorer (`iexplore.exe`) 窗口，并将指定的
    URL 作为其 `Arguments` 传递给进程，一旦我们调用 `process.Start()` 方法。
- en: When you click the BringToFront button, it retrieves the handle of the main
    window of the process and passes it as parameter to the `SetForegroundWindow`
    Win32 API method. The said API method brings the thread into the foreground and
    activates the window.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“带到前台”按钮时，它会检索进程的主窗口句柄，并将其作为参数传递给 `SetForegroundWindow` Win32 API 方法。该 API
    方法将线程带到前台并激活窗口。
- en: 'A process can set the foreground window only if one of the following conditions
    is satisfied:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 只有满足以下条件之一时，进程才能设置前台窗口：
- en: The process itself is a foreground process
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该进程本身是一个前台进程
- en: It was started by a foreground process
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是由前台进程启动的
- en: The process is being debugged
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程正在被调试
- en: The foreground process is not a Modern Application or the Start screen
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前台进程不是一个现代应用程序或启动屏幕
- en: No menus are active
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有菜单是激活的
- en: The `DllImport` attribute indicates that the attributed method is exposed by
    an unmanaged **dynamic-link library** (**DLL**) as a static entry point. In our
    case, it's the `User32.dll` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`DllImport` 属性表示具有该属性的函数是由一个未管理的 **动态链接库** (**DLL**) 作为静态入口点公开的。在我们的例子中，是 `User32.dll`
    文件。'
- en: When you click on the Refresh button, just like the BringToFront button, it
    first activates the Internet Explorer window by bringing it to the front. The
    keyboard input is then being directed to the window.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“刷新”按钮时，就像“带到前台”按钮一样，它首先通过将其带到前台来激活 Internet Explorer 窗口。然后键盘输入被导向该窗口。
- en: Note that an application can't force a window to the foreground if the user
    is working on another window. In this case, the window will flash in the task
    bar to notify the user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果用户正在另一个窗口上工作，应用程序不能强制将窗口带到前台。在这种情况下，窗口将在任务栏中闪烁以通知用户。
- en: The `SendKeys.SendWait("{F5}")` method call sends the given key (*F5*, in our
    case) to the active application, and then waits for the messages to be processed.
    As we have passed the *F5* key here, it will call the `refresh` method of the
    browser. Make sure that `System.Windows.Forms` is properly referenced in the project,
    for the `SendKeys.SendWait` method to work.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Embedding ActiveX controls in WPF applications
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WPF also supports **ActiveX**, which you can easily embed in a WPF application.
    This is not feature specific to WPF, but it works because of interoperability
    with Windows Forms. The WinForm acts as an intermediate layer between the two.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: There are several ActiveX controls present, which can be easily embedded in
    any WPF application. In this recipe, we will learn how to embed an ActiveX control
    by following some simple steps. We will demonstrate it using the **Microsoft Terminal
    Services Control** that ships with Windows.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure Visual Studio is up and running. Create a new WPF project and name
    it as `CH11.ActiveXDemo`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to generate the required libraries for the **Microsoft Terminal
    Services ActiveX** control and embed it inside our WPF application:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to generate the required libraries of our ActiveX control.
    This is required to get a managed and Windows Forms compatible definition of the
    relevant type. To do this, open **Visual Studio Developer Command Prompt** and
    navigate to an empty folder (let's say, `D:libs`).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the Command Prompt, enter the following command to generate the managed
    definitions of the Terminal Service DLL:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will generate two DLL files, named `MSTSCLib.dll` and `AxMSTSCLib.dll`,
    in the same folder (`D:libs`, in our case):![](img/7c71dc2d-ae3a-4cc3-a80b-9c3dee2c8e61.png)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's copy those DLLs in our project folder. Create a folder named `libs`, inside
    the root folder of our project, and copy both files there.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add the references of those binaries into our project. Navigate back to
    Visual Studio, and from Solution Explorer, right-click on the References node.
    Then, click Add Reference... from the context menu.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Reference Manager dialog window, click Browse... to add the references.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select both MSTSCLib.dll and AxMSTSCLib.dll, as shown in the following screenshot
    and click Add, which will add the selection to the Reference Manager:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f1cbf53-5796-4072-9867-92105f2914ea.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Search for `forms`, inside the Reference Manager dialog, and select System.Windows.Forms
    and WindowsFormsIntegration dlls.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to confirm adding the references of the four assembly files.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open the `MainWindow.xaml` file and add the following XMLNS attribute to
    it:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <Grid>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <WindowsFormsHost>
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <lib:AxMsTscAxNotSafeForScripting
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: x:Name="terminal"
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Height="500" Width="1000"/>
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </WindowsFormsHost>
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Grid>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: terminal.Server = "192.168.0.10";
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: terminal.Connect();
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
