["```cs\n    dotnet new sln\n    ```", "```cs\n    dotnet new classlib -o Uqs.Arithmetic -f net6.0 \n    ```", "```cs\n    dotnet sln add Uqs.Arithmetic \n    ```", "```cs\ndotnet new xunit -o Uqs.Arithmetic.Tests.Unit -f net6.0\n```", "```cs\ndotnet sln add Uqs.Arithmetic.Tests.Unit\n```", "```cs\ndotnet add Uqs.Arithmetic.Tests.Unit reference \n   Uqs.Arithmetic\n```", "```cs\nusing Xunit;\nnamespace Uqs.Arithmetic.Tests.Unit;\npublic class UnitTest1\n{\n    [Fact]\n    public void Test1()\n    {\n    }\n}\n```", "```cs\ndotnet test\n```", "```cs\npublic class ClassName\n{\n    public Type MethodName(…)\n    {\n        // Code that does something useful\n    }\n    // more code\n}\n```", "```cs\npublic class ClassNameTests\n{\n    [Fact]\n    public void MethodName_Condition1_Expectation1()\n    {\n        // Unit Testing Code that will call MethodName\n    }\n    // Other tests…\n    [Fact]\n    public void MethodName_ConditionN_ExpectationN()\n    {\n        // Unit Testing Code that will call MethodName\n    }\n    …\n}\n```", "```cs\n[Fact]\npublic void MethodName_Condition_Expectation()\n{\n…\n```", "```cs\n[Fact]\npublic void Divide_DivisibleIntegers_WholeNumber()\n{\n    int dividend = 10;\n    int divisor = 5;\n    decimal expectedQuotient = 2;\n    decimal actualQuotient = Division.Divide(dividend, \n        divisor);\n    Assert.Equal(expectedQuotient, actualQuotient);\n}\n```", "```cs\npublic static void Equal<T>(T expected, T actual) \n```", "```cs\nnamespace Uqs.Arithmetic;\npublic class Division\n{\n    public static decimal Divide(int dividend, int divisor)\n    {\n        decimal quotient = dividend / divisor;\n        return quotient;\n    }\n}\n```", "```cs\n[Fact]\npublic void Divide_DivisibleIntegers_WholeNumber()\n{\n    // Arrange\n    int dividend = 10;\n    int divisor = 5;\n    decimal expectedQuotient = 2;\n    // Act\n    decimal actualQuotient = Division.Divide(dividend,\n       divisor);\n    // Assert\n    Assert.Equal(expectedQuotient, actualQuotient);\n}\n```", "```cs\n[Fact]\npublic void Divide_IndivisibleIntegers_DecimalNumber()\n{\n    // Arrange\n    int dividend = 10;\n    int divisor = 4;\n    decimal expectedQuotient = 2.5m;\n    …\n}\n```", "```cs\ndecimal quotient = (decimal)dividend / divisor;\n```", "```cs\n[Fact]\npublic void Divide_ZeroDivisor_DivideByZeroException()\n{\n    // Arrange\n    int dividend = 10;\n    int divisor = 0;\n\n    // Act\n    Exception e = Record.Exception(() => \n        Division.Divide(dividend, divisor));\n    // Assert\n    Assert.IsType<DivideByZeroException>(e);\n}\n```", "```cs\npublic static Exception Exception(Func<object> testCode)\n```", "```cs\npublic static T IsType<T>(object @object)\n```", "```cs\n[Theory]\n[InlineData( int.MaxValue,  int.MinValue, -0.999999999534)]\n[InlineData(-int.MaxValue,  int.MinValue,  0.999999999534)]\n[InlineData( int.MinValue,  int.MaxValue, -1.000000000466)]\n[InlineData( int.MinValue, -int.MaxValue,  1.000000000466)]\npublic void Divide_ExtremeInput_CorrectCalculation(\n    int dividend, int divisor, decimal expectedQuotient)\n{\n    // Arrange\n    // Act\n    decimal actualQuotient = Division.Divide(dividend, \n        divisor);\n    // Assert\n    Assert.Equal(expectedQuotient, actualQuotient, 12);\n}\n```", "```cs\nstatic void Equal(decimal expected, decimal actual, \n    int precision)\n```"]