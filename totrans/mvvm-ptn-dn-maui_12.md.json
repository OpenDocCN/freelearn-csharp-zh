["```cs\nvar currentCulture = CultureInfo.CurrentCulture;\nvar currentUICulture = CultureInfo.CurrentUICulture;\n```", "```cs\nvar cultureInfo = new CultureInfo(\"fr-FR\");\nCultureInfo.CurrentCulture = cultureInfo;\nCultureInfo.CurrentUICulture = cultureInfo;\nCultureInfo.DefaultThreadCurrentCulture = cultureInfo;\nCultureInfo.DefaultThreadCurrentUICulture = cultureInfo;\n```", "```cs\nPreferences.Set(\"SelectedCulture\", \"fr-FR\");\n```", "```cs\nvar storedCulture = Preferences.Get(\"SelectedCulture\", \n\"en-US\");\n```", "```cs\nvar cultureInfo = new CultureInfo(storedCulture);\nCultureInfo.CurrentCulture = cultureInfo;\n```", "```cs\npublic DateTime LastUpdated { get; set; } = new\nDateTime(2020, 7, 3);\n```", "```cs\n<Label Text=\"{Binding LastUpdated}\" />\n```", "```cs\n<Label Text=\"{Binding LastUpdated, StringFormat='{0:MMMM d,\n  yyyy}'}\" />\n```", "```cs\nvar s1 = AppResources.\n    ResourceManager.GetString(\"AddAsFavorite\");\n```", "```cs\nvar s2 = AppResources.AddAsFavorite;\n```", "```cs\n    public static MauiApp CreateMauiApp()\n    {\n        var builder = MauiApp.CreateBuilder();\n        ...\n        var french = new CultureInfo(\"fr-FR\");\n        CultureInfo.CurrentCulture = french;\n        CultureInfo.CurrentUICulture = french;\n    ...\n    }\n    ```", "```cs\n    Title=\"{x:Static strings:AppResources.Tab1Title}\"\n    ```", "```cs\n    Title=\"{x:Static strings:AppResources.Tab2Title}\"\n    ```", "```cs\n    <MultiBinding StringFormat=\"{x:Static\n        strings:AppResources.ModifiedDateAuthorFormat}\">\n        <Binding Path=\"LastUpdated\" />\n        <Binding Path=\"Author\" />\n    </MultiBinding>\n    ```", "```cs\npublic interface ILocalizationManager\n{\n    void RestorePreviousCulture(\n        CultureInfo defaultCulture = null);\n    void UpdateUserCulture(CultureInfo cultureInfo);\n    CultureInfo GetUserCulture(\n        CultureInfo defaultCulture = null);\n}\n```", "```cs\npublic interface ILocalizedResourcesProvider\n{\n    string this[string key]\n    {\n        get;\n    }\n    void UpdateCulture(CultureInfo cultureInfo);\n}\n```", "```cs\nResourceManager resourceManager;\nCultureInfo currentCulture;\npublic static LocalizedResourcesProvider Instance\n{\n    get;\n    private set;\n}\npublic LocalizedResourcesProvider(\n    ResourceManager resourceManager)\n{\n    this.resourceManager = resourceManager;\n    currentCulture = CultureInfo.CurrentUICulture;\n    Instance = this;\n}\n```", "```cs\npublic string this[string key]\n    => resourceManager.GetString(key, currentCulture)\n    ?? key;\n```", "```cs\npublic void UpdateCulture(CultureInfo cultureInfo)\n{\n    currentCulture = cultureInfo;\n    OnPropertyChanged(\"Item\");\n}\n```", "```cs\nreadonly ILocalizedResourcesProvider _resourceProvider;\npublic LocalizationManager(\n    ILocalizedResourcesProvider resoureProvider)\n{\n    _resourceProvider = resoureProvider;\n}\n```", "```cs\npublic void UpdateUserCulture(CultureInfo cultureInfo)\n{\n    Preferences.Default.Set(\"UserCulture\",\n        cultureInfo.Name);\n    SetCulture(cultureInfo);\n}\nprivate void SetCulture(CultureInfo cultureInfo)\n{\n    currentCulture = cultureInfo;\n    Application.Current.Dispatcher.Dispatch(() =>\n    {\n        CultureInfo.CurrentCulture = cultureInfo;\n        CultureInfo.CurrentUICulture = cultureInfo;\n        CultureInfo.DefaultThreadCurrentCulture =\n            cultureInfo;\n        CultureInfo.DefaultThreadCurrentUICulture =\n            cultureInfo;\n    });\n    _resourceProvider.UpdateCulture(cultureInfo);\n}\n```", "```cs\npublic CultureInfo GetUserCulture(\n    CultureInfo defaultCulture = null)\n{\n    if (currentCulture is null)\n    {\n        var culture = Preferences.Default.Get(\n            \"UserCulture\", string.Empty);\n        if (string.IsNullOrEmpty(culture))\n        {\n            currentCulture = defaultCulture\n                ?? CultureInfo.CurrentCulture;\n        }\n        else\n        {\n            currentCulture = new CultureInfo(culture);\n        }\n    }\n    return currentCulture;\n}\n```", "```cs\npublic void RestorePreviousCulture(\n    CultureInfo defaultCulture = null)\n    => SetCulture(GetUserCulture(defaultCulture));\n```", "```cs\n    builder.Services.AddSingleton<ILocalizationManager,\n      LocalizationManager>();\n    ```", "```cs\n    var resources = new LocalizedResourcesProvider(\n        AppResources.ResourceManager);\n    ```", "```cs\n    builder.Services\n        .AddSingleton<ILocalizedResourcesProvider>(\n        resources);\n    ```", "```cs\n    readonly ILocalizedResourcesProvider _resources;\n    readonly ILocalizationManager _localizationManager;\n    readonly IDialogService _dialogService\n    ...\n    public PickLanguageViewModel(\n        INavigationService navigationService\n        IDialogService dialogService,\n        ILocalizedResourcesProvider resourcesProvider,\n        ILocalizationManager localizationManager)\n    {\n        _dialogService = dialogService;\n        _resources = resourcesProvider;\n        _localizationManager = localizationManager;\n        ...\n    }\n    ...\n    ```", "```cs\n    private Task<bool> ConfirmSwitchLanguage()\n        => _dialogService.AskYesNo(\n            _resources[\"SwitchLanguageDialogTitle\"],\n            _resources[\"SwitchLanguageDialogText\"],\n            _resources[\"YesDialogButton\"],\n            _resources[\"NoDialogButton\"]);\n    ```", "```cs\n    private Task NotifySwitch()\n        => _dialogService.Notify(\n            _resources[\"LanguageSwitchedTitle\"],\n            _resources[\"LanguageSwitchedText\"],\n            _resources[\"OKDialogButton\"]);\n    ```", "```cs\n    private void SwitchLanguage()\n    {\n        CurrentLanguage = newLanguage;\n        _localizationManager\n            .UpdateUserCulture(\n            new CultureInfo(SelectedLanguage));\n    }\n    ```", "```cs\n    xmlns:localization=\"clr-namespace:\n      Localization;assembly=Localization\"\n    ```", "```cs\n    Text=\"{Binding Path=[ChooseLanguage], Source={x:Static\n    localization:LocalizedResourcesProvider.Instance}}\"\n    LocalizedResourcesProvider.Instance[\"ChooseLanguage\"]\n    ```", "```cs\n    {Binding Path=[About], Source={x:Static\n    localization:LocalizedResourcesProvider.Instance}}\"\n    ```", "```cs\n    Title=\"{Binding Path=[SettingsTitle], Source={x:Static\n    localization:LocalizedResourcesProvider.Instance}}\"\n    ```", "```cs\n    Text=\"{Binding CurrentLanguage, StringFormat=\n      'Language: {0}'}\"\n    We’ve extracted the hardcoded `Language` part from the `StringFormat` property and defined two placeholders. By leveraging multi-binding, we can indicate the first placeholder should get the value associated with `Language` in the `AppResources`. The second placeholder is bound to the `CurrentLanguage` property on the ViewModel.Note that the `StringFormat` property starts with `{}`. Putting just `{0}: {1}` in there is not allowed, because the  `{` curly brace is a special character in XAML, often signaling the start of a markup extension. `{}` is an escape sequence to handle this.\n    ```", "```cs\npublic App(INavigationInterceptor navigationInterceptor,\n    ILocalizationManager manager)\n{\n    manager.RestorePreviousCulture();\n...\n}\n```", "```cs\nTitle=\"{mauiloc:Translate SettingsTitle}\"\n```", "```cs\nTitle=\"{Binding Path=[SettingsTitle], Source={x:Static\n  localization:LocalizedResourcesProvider.Instance},\n    Mode=OneWay}\"\n```", "```cs\nobject IMarkupExtension.ProvideValue(IServiceProvider\n  serviceProvider);\nT ProvideValue(IServiceProvider serviceProvider);\n```", "```cs\n[ContentProperty(nameof(Key))]\npublic class TranslateExtension :\n    IMarkupExtension<Binding>\n{\n    public string Key { get; set; }\n    object IMarkupExtension.ProvideValue(\n        IServiceProvider serviceProvider)\n        => ProvideValue(serviceProvider);\n    public Binding ProvideValue(\n        IServiceProvider serviceProvider)\n        => ...\n}\n```", "```cs\nTitle=\"{mauiloc:Translate ContentProperty attribute applied to this class, we can omit the Key= segment, simplifying our markup extension’s use even more. ContentProperty specifies the default property that is to be used when no identifier is specified in XAML. Remember how we don’t need to explicitly state Path= in a data-binding statement and can simply write the path? This ContentProperty attribute is exactly what drives that! Let’s finally see what the generic ProvideValue method returns:\n\n```", "```cs\n\n The `ProvideValue` method returns a `Binding` object. Its `Source` value is set to the static `Instance` property of `LocalizedResourcesProvider`, equivalent to this:\n\n```", "```cs\n\n For the `Path` property, when the `Key` value is `SettingsTitle`, it translates to `Path=[SettingsTitle]`. The `Binding`’s `Mode` is set to `OneWay` to ensure it listens for the `PropertyChanged` event and updates the bound value when needed.\nThe `Translate` markup extension provides a convenient way to define the exact same binding statements we had earlier. Let’s go ahead and update some of our Views so that they leverage this `Translate` markup extension:\n\n1.  Go to `SettingsPage` and add the following XML namespace, which points to the `Localization.Maui` namespace of the `Localization.Maui` project:\n\n    ```", "```cs\n\n     2.  Update the binding statements on the `SettingsPage`, as shown here:\n\n    ```", "```cs\n\n     3.  In `AppShell.xaml`, add the same XML namespace that we previously added to `SettingsPage` in *step 1*.\n4.  Now, update the binding statements on `AppShell.xaml`, as shown in the following snippet:\n\n    ```", "```cs\n\nThe `Translate` markup extension offers an elegant approach to what is typically considered a complex task. Everywhere hardcoded text is used, we can very simply replace it with this `TranslateExtension`. Note that the `TranslateExtension` can still be improved: all the typical data-binding properties such as `Converter`, `ConverterParameter`, and so on can be added to this class as well and be used in the `Binding` object that is being returned.\nNow that we know how to localize hardcoded `copy` labels, let’s have a look at how we can fetch localized data from APIs.\nFetching localized data from APIs\nBefore we wrap up this chapter, let’s have a quick look at how we could pass the user’s language to the API so that it can return localized data. One approach is to include a language parameter in every service and repository method, allowing the ViewModel to pass the user’s current language. However, I believe adding such parameters can clutter the code. A cleaner alternative is to handle this within the repositories. Let’s see how:\n\n1.  First, let’s update the `IRecipeAPI` interface by adding a `language` parameter of type `string` to the `GetRecipes` method. The following snippet shows how we can configure Refit to pass this additional parameter as an `Accept-Language` request header when executing the API call:\n\n    ```", "```cs\n\n     2.  It’s the `RecipeApiGateway` class that invokes the updated `GetRecipes` method. In order for it to access the current culture, let’s inject an instance of the `ILocalizationManager`, as shown here:\n\n    ```", "```cs\n\n     3.  The next code block shows how we can now use the `_localizationManager` field to access the current user culture and pass its `Name` property to the `GetRecipes` method:\n\n    ```", "```cs\n\n    While directly using `CultureInfo.CurrentCulture.Name` might seem straightforward, accessing the culture via our `ILocalizationManager` ensures greater consistency, as mentioned earlier.\n\n     4.  Accessing the `Accept-Language` that’s now being sent with this API call can be achieved by updating the `GetRecipes` endpoint in the `Program.cs` file inside the `Recipes.Web.Api` project. Here’s what the updated code looks like:\n\n    ```", "```cs\n\nIn contrast to the data-bound values on the screen, changing the app’s language won’t automatically fetch any localized data coming from the API anew. So, how can we tackle this? In [*Chapter 7*](B20941_07.xhtml#_idTextAnchor119), *Dependency Injection, Services, and Messaging*, we already discussed thoroughly how ViewModels can communicate with each other in a loosely coupled manner through `Messaging`. `Messaging` offers a solution to this challenge: `SettingsViewModel` can send a message notifying other ViewModels about the updated language. ViewModels can react to this and re-fetch their data. Let’s implement this:\n\n1.  Add a new class called `CultureChangedMessage` to the `Messages` folder of the `Recipes.Client.Core` project. Here’s what it looks like:\n\n    ```", "```cs\n\n     2.  Update the `SwitchLanguage` method on `SettingsViewModel`, as shown here:\n\n    ```", "```cs\n\n     3.  Finally, in the constructor of the `RecipesOverviewViewModel`, we can add the following code that listens for the `CultureChangedMessage` to arrive so that we can reload the list of recipes:\n\n    ```", "```cs\n\n    We don’t need to bother with passing the updated culture or language around. Once the message is received, the `LocalizationManager` is already updated to the selected culture and will return the newly selected culture. This ensures that any new recipe fetch will use the updated culture.\n\nWhen running the app and changing the language on the `SettingsPage`, the `RecipesOverviewViewModel` will reload its recipes. If you debug and set a breakpoint in the API, you’ll observe that the language parameter consistently matches the newly selected language.\nSummary\nWe kicked off this chapter with an introduction to localization, understanding its importance in ensuring our app resonates with users globally. Before diving deep, we explored the basics of how localizable values can be statically bound, offering a foundational approach.\nBuilding on this, we introduced a more dynamic localization framework. This allowed for more flexible updates and interactions. Following this, we delved into simplifying our XAML through the `Translate` markup extension. While it made our data-binding statements sleeker, the underlying mechanism remained unchanged.\nNext, we discussed getting localized data from our APIs. We found a neat way to tell the API about the user’s language choice without making our code messy. By using the `ILocalizationManager`, we kept our approach consistent. And, with `Messaging`, our app knows when to fetch new data if a user changes their language.\nThe big takeaway? All our steps respected the key MVVM idea of “separation of concerns.” Each part of our app has its job, making things organized and easier to manage.\nNote\nBe aware that what we’ve seen throughout this chapter doesn’t completely cover everything there is to localizing your apps, such as localizing the app’s name or localizing images. Take a look at [https://learn.microsoft.com/dotnet/maui/fundamentals/localization](https://learn.microsoft.com/dotnet/maui/fundamentals/localization) to find out more!\nAs we wrap up this chapter, we’ve truly come a long way in building the *Recipes!* app, while adhering to the MVVM principles. But, of course, no app development journey is complete without ensuring its robustness. And that’s where the next chapter comes in. We’ll dive into how MVVM isn’t just about structuring our app effectively, but also about setting the stage for thorough and effective unit testing.\nFurther reading\nTo learn more about the topics that were covered in this chapter, take a look at the following resources:\n\n*   The `ResourceManager` class: [https://learn.microsoft.com/dotnet/api/system.resources.resourcemanager?view=net-8.0](https://learn.microsoft.com/dotnet/api/system.resources.resourcemanager?view=net-8.0)\n*   *XAML markup* *extensions*: [https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions](https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions)\n*   *Create XAML markup* *extensions*: [https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create](https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create)\n\n```"]