- en: Chapter 2. Thread Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe some of the common techniques of working
    with shared resources from multiple threads. You will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic atomic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Mutex` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `SemaphoreSlim` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `AutoResetEvent` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ManualResetEventSlim` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `CountDownEvent` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Barrier` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ReaderWriterLockSlim` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `SpinWait` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading
    Basics*, it is problematic to use a shared object simultaneously from several
    threads. However, it is very important to synchronize those threads so that they
    perform operations on that shared object in a proper sequence. In the *Locking
    with a C# lock keyword* recipe, we faced a problem called the race condition.
    The problem occurred because the execution of those multiple threads was not synchronized
    properly. When one thread performs increment and decrement operations, the other
    threads must wait for their turn. Organizing threads in such a way is often referred
    to as **thread synchronization**.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to achieve thread synchronization. First, if there is
    no shared object, there is no need for synchronization at all. Surprisingly, it
    is very often the case that we can get rid of complex synchronization constructs
    by just redesigning our program and removing a shared state. If possible, just
    avoid using a single object from several threads.
  prefs: []
  type: TYPE_NORMAL
- en: If we must have a shared state, the second approach is to use only **atomic**
    operations. This means that an operation takes a single quantum of time and completes
    at once, so no other thread can perform another operation until the first operation
    is complete. Therefore, there is no need to make other threads wait for this operation
    to complete and there is no need to use locks; this in turn, excludes the deadlock
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: If this is not possible and the program's logic is more complicated, then we
    have to use different constructs to coordinate threads. One group of these constructs
    puts a waiting thread into a `blocked` state. In a `blocked` state, a thread uses
    as little CPU time as possible. However, this means that it will include at least
    one so-called **context switch**—the thread scheduler of an operating system will
    save the waiting thread's state and switch to another thread, restoring its state
    by turn. This takes a considerable amount of resources; however, if the thread
    is going to be suspended for a long time, it is good. These kind of constructs
    are also called **kernel-mode** constructs because only the kernel of an operating
    system is able to stop a thread from using CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: In case, we have to wait for a short period of time, it is better to simply
    wait than switch the thread to a `blocked` state. This will save us the context
    switch at the cost of some wasted CPU time while the thread is waiting. Such constructs
    are referred to as **user-mode** constructs. They are very lightweight and fast,
    but they waste a lot of CPU time in case a thread has to wait for long.
  prefs: []
  type: TYPE_NORMAL
- en: To use the best of both worlds, there are **hybrid** constructs; these try to
    use user-mode waiting first, and then, if a thread waits long enough, it switches
    to the `blocked` state, saving CPU resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look through the aspects of thread synchronization.
    We will cover how to perform atomic operations and how to use the existing synchronization
    constructs included in .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic atomic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to perform basic atomic operations on an object
    to prevent the race condition without blocking threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand basic atomic operations, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, it creates three threads that will execute a code in
    the `TestCounter` method. This method runs a sequence of increment/decrement operations
    on an object. Initially, the `Counter` object is not thread-safe and we get a
    race condition here. So, in the first case, a counter value is not deterministic.
    We could get a zero value; however, if you run the program several times, you
    will eventually get some incorrect nonzero result.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading Basics*,
    we resolved this problem by locking our object, causing other threads to be blocked
    while one thread gets the old counter value and then computes and assigns a new
    value to the counter. However, if we execute this operation in such a way, it
    cannot be stopped midway, we would achieve the proper result without any locking,
    and this is possible with the help of the `Interlocked` construct. It provides
    the `Increment`, `Decrement`, and `Add` atomic methods for basic math, and it
    helps us to write the `Counter` class without the use of locking.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Mutex construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to synchronize two separate programs using the
    `Mutex` construct. A `Mutex` construct is a synchronization primitive that grants
    exclusive access of the shared resource to only one thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the synchronization of two separate programs using the `Mutex`
    construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines a mutex with a specific name, providing
    the `initialOwner` flag as `false`. This allows the program to acquire a mutex
    if it is already created. Then, if no mutex is acquired, the program simply displays
    **Running** and waits for any key to be pressed in order to release the mutex
    and exit.
  prefs: []
  type: TYPE_NORMAL
- en: If we start a second copy of the program, it will wait for 5 seconds, trying
    to acquire the mutex. If we press any key in the first copy of a program, the
    second one will start the execution. However, if we keep waiting for 5 seconds,
    the second copy of the program will fail to acquire the mutex.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that a mutex is a global operating system object! Always close the mutex
    properly; the best choice is to wrap a mutex object into a `using` block.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it possible to synchronize threads in different programs, which could
    be useful in a large number of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SemaphoreSlim construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to limit multithreaded access to some resources
    with the help of the `SemaphoreSlim` construct. `SemaphoreSlim` is a lightweight
    version of `Semaphore`; it limits the number of threads that can access a resource
    concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to limit a multithreaded access to a resource with the help
    of the `SemaphoreSlim` construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it creates a `SemaphoreSlim` instance, specifying
    the number of concurrent threads allowed in its constructor. Then, it starts six
    threads with different names and start times to run.
  prefs: []
  type: TYPE_NORMAL
- en: Every thread tries to acquire access to a database, but we restrict the number
    of concurrent accesses to a database to four threads with the help of a semaphore.
    When four threads get access to a database, the other two threads wait until one
    of the previous threads finishes its work and signals to other threads by calling
    the `_semaphore.Release` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we use a hybrid construct, which allows us to save a context switch in
    cases where the wait time is very short. However, there is an older version of
    this construct called `Semaphore`. This version is a pure, kernel-time construct.
    There is no sense in using it, except in one very important scenario; we can create
    a named semaphore like a named mutex and use it to synchronize threads in different
    programs. `SemaphoreSlim` does not use Windows kernel semaphores and does not
    support interprocess synchronization, so use `Semaphore` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Using the AutoResetEvent construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, there is an example of how to send notifications from one thread
    to another with the help of an `AutoResetEvent` construct. `AutoResetEvent` notifies
    a waiting thread that an event has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to send notifications from one thread to another with the
    help of the `AutoResetEvent` construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two `AutoResetEvent` instances. One
    of them is for signaling from the second thread to the main thread, and the second
    one is for signaling from the main thread to the second thread. We provide `false`
    to the `AutoResetEvent` constructor, specifying the initial sate of both the instances
    as `unsignaled`. This means that any thread calling the `WaitOne` method of one
    of these objects will be blocked until we call the `Set` method. If we initialize
    the event state to `true`, it becomes `signaled` and the first thread calling
    `WaitOne` will proceed immediately. The event state then becomes `unsignaled`
    automatically, so we need to call the `Set` method once again to let the other
    threads calling the `WaitOne` method on this instance to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a second thread, which executes the first operation for 10 seconds
    and waits for the signal from the second thread. The signal notifies that the
    first operation is completed. Now, the second thread waits for a signal from the
    main thread. We do some additional work on the main thread and send a signal by
    calling the `_mainEvent.Set` method. Then, we wait for another signal from the
    second thread.
  prefs: []
  type: TYPE_NORMAL
- en: '`AutoResetEvent` is a kernel-time construct, so if the wait time is not significant,
    it is better to use the next recipe with `ManualResetEventslim`, which is a hybrid
    construct.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the ManualResetEventSlim construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to make signaling between threads more flexible
    with the `ManualResetEventSlim` construct.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `ManualResetEventSlim` construct, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it first creates an instance of the `ManualResetEventSlim`
    construct. Then, we start three threads that wait for this event to signal them
    to continue the execution.
  prefs: []
  type: TYPE_NORMAL
- en: The whole process of working with this construct is like letting people pass
    through a gate. The `AutoResetEvent` event that we looked at in the previous recipe
    works like a turnstile, allowing only one person to pass at a time. `ManualResetEventSlim`,
    which is a hybrid version of `ManualResetEvent`, stays open until we manually
    call the `Reset` method. Going back to the code, when we call `_mainEvent.Set`,
    we open it and allow the threads that are ready to accept this signal to continue
    working. However, thread number three is still sleeping and does not make it in
    time. We call `_mainEvent.Reset` and we thus close it. The last thread is now
    ready to go on, but it has to wait for the next signal, which will happen a few
    seconds later.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in one of the previous recipes, we use a hybrid construct that lacks the
    possibility to work at the operating system level. If we need to have a global
    event, we should use the `EventWaitHandle` construct, which is the base class
    for `AutoResetEvent` and `ManualResetEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CountDownEvent construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to use the `CountdownEvent` signaling construct
    to wait until a certain number of operations complete.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `CountDownEvent` construct, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, we create a new `CountdownEvent` instance, specifying
    that we want it to signal when two operations complete in its constructor. Then,
    we start two threads that signal to the event when they are complete. As soon
    as the second thread is complete, the main thread returns from waiting on `CountdownEvent`
    and proceeds further. Using this construct, it is very convenient to wait for
    multiple asynchronous operations to complete.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a significant disadvantage; `_countdown.Wait()` will wait
    forever if we fail to call `_countdown.Signal()` the required number of times.
    Make sure that all your threads complete with the `Signal` method call when using
    `CountdownEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Barrier construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe illustrates another interesting synchronization construct called
    `Barrier`. The `Barrier` construct helps to organize several threads so that they
    meet at some point in time, providing a callback that will be executed each time
    the threads call the `SignalAndWait` method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `Barrier` construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a `Barrier` construct, specifying that we want to synchronize two
    threads, and after each of those two threads call the `_barrier.SignalAndWait`
    method, we need to execute a callback that will print out the number of phases
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: Each thread will send a signal to `Barrier` twice, so we will have two phases.
    Every time both the threads call the `SignalAndWait` method, `Barrier` will execute
    the callback. It is useful for working with multithreaded iteration algorithms,
    to execute some calculations on each iteration end. The end of the iteration is
    reached when the last thread calls the `SignalAndWait` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ReaderWriterLockSlim construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to create a thread-safe mechanism to read and
    write to a collection from multiple threads using a `ReaderWriterLockSlim` construct.
    `ReaderWriterLockSlim` represents a lock that is used to manage access to a resource,
    allowing multiple threads for reading or exclusive access for writing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create a thread-safe mechanism to read and write to a
    collection from multiple threads using the `ReaderWriterLockSlim` construct, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it simultaneously runs three threads that read
    data from a dictionary and two threads that write some data into this dictionary.
    To achieve thread safety, we use the `ReaderWriterLockSlim` construct, which was
    designed especially for such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has two kinds of locks: a read lock that allows multiple threads to read
    and a write lock that blocks every operation from other threads until this write
    lock is released. There is also an interesting scenario when we obtain a read
    lock, read some data from the collection, and, depending on that data, decide
    to obtain a write lock and change the collection. If we get the write locks at
    once, too much time is spent, not allowing our readers to read the data because
    the collection is blocked when we get a write lock. To minimize this time, there
    are `EnterUpgradeableReadLock`/`ExitUpgradeableReadLock` methods. We get a read
    lock and read the data; if we find that we have to change the underlying collection,
    we just upgrade our lock using the `EnterWriteLock` method, then perform a write
    operation quickly and release a write lock using `ExitWriteLock`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we get a random number; we then get a read lock and check whether
    this number exists in the dictionary key collection. If not, we upgrade our lock
    to a write lock and then add this new key to a dictionary. It is a good practice
    to use `try`/`finally` blocks to make sure that we always release locks after
    acquiring them.
  prefs: []
  type: TYPE_NORMAL
- en: All our threads have been created as background threads, and after waiting for
    30 seconds, the main thread as well as all the background threads get completed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SpinWait construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to wait on a thread without involving kernel-mode
    constructs. In addition, we introduce `SpinWait`, a hybrid synchronization construct
    designed to wait in the user mode for some time, and then switch to the kernel
    mode to save CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe9`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to wait on a thread without involving kernel-mode constructs,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines a thread that will execute an endless
    loop for 20 milliseconds until the main thread sets the `_isCompleted` variable
    to `true`. We could experiment and run this cycle for 20-30 seconds instead, measuring
    the CPU load with the Windows task manager. It will show a significant amount
    of processor time, depending on how many cores the CPU has.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `volatile` keyword to declare the `_isCompleted` static field. The
    `volatile` keyword indicates that a field might be modified by multiple threads
    being executed at the same time. Fields that are declared `volatile` are not subject
    to compiler and processor optimizations that assume access by a single thread.
    This ensures that the most up-to-date value is present in the field at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use a `SpinWait` version, which on each iteration prints a special
    flag that shows us whether a thread is going to switch to a `blocked` state. We
    run this thread for 5 milliseconds to see that. In the beginning, `SpinWait` tries
    to stay in the user mode, and after about nine iterations, it begins to switch
    the thread to a blocked state. If we try to measure the CPU load with this version,
    we will not see any CPU usage in the Windows task manager.
  prefs: []
  type: TYPE_NORMAL
