<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>9. Functional Programming Techniques for Better State Management</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="8afe24fba552.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;9.&#160;Functional Programming Techniques for Better State Management">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09"></a>Chapter&#160;9.&#160;Functional Programming Techniques for Better State Management</h1>
            </div>
          </div>
        </div>
        <p>While writing concurrent/parallel code, handling state is difficult in an imperative program (something that you would have seen by now). Modern languages and platforms borrow idioms and practices that enable better state management and facilitate strong concurrency models from the functional programming community. In this chapter, we will see what those are and try to understand, through code samples, how to best leverage some of those features (striving for coverage would stretch this chapter to an entire book) to our advantage. We would also see how C# has evolved as a language to bring the best of both worlds (imperative and functional), and to help you apply functional thinking to model real-world scenarios. This chapter will also cover <span class="strong"><strong>Language Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>) as a mechanism for writing compositional code. Through this journey, we will uncover some good design practices, leveraging the functional constructs in the language (primarily C#). We hope this chapter serves as a starter kit by providing you with some of the techniques and tools to tackle programming tasks in a functional way. Some of the ideas covered include:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Being functional</li>
            <li class="listitem" style="list-style-type: disc">Referential transparency</li>
            <li class="listitem" style="list-style-type: disc">First class functions (also higher order functions)</li>
            <li class="listitem" style="list-style-type: disc">Lambda calculus and anonymous functions</li>
            <li class="listitem" style="list-style-type: disc">Currying and partial function application</li>
            <li class="listitem" style="list-style-type: disc">A brief overview of how LINQ works</li>
          </ul>
        </div>
        <div class="section" title="Being functional">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch09lvl1sec66"></a>Being functional</h1>
              </div>
            </div>
          </div>
          <p>Functional programming is a programming paradigm that involves algorithm composition, to be dealt on the same lines as mathematical function evaluations. This implies that the output of these functions would purely depend on the inputs provided. Moreover, any applicable data structures that the algorithm would need to create the output would be transient, having a lifetime within the function scope, and thus help in avoiding state mutation. It is also a powerful declarative programming paradigm, which involves leveraging expressions for readable code in place of procedural in-line statements.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Referential transparency">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec67"></a>Referential transparency</h1>
            </div>
          </div>
        </div>
        <p>Let's delve a bit deeper to understand the consequences of being functional, as illustrated by the definitions given in the preceding section. Now, when we try to relate functions from both these worlds (mathematical and imperative programming), we see a strong disparity, as the latter mutates state with commands in the source language, thereby bringing in side effects (though desirable from an imperative programming standpoint). This violates one of the fundamental pre-requisites of functional programming - that of referential transparency, that is, the same expressions (when run at different times) yield different values with respect to the executing program's state. This affects the predictability of the program, which is definitely not desirable. On the other hand, pure functions (say <span class="emphasis"><em>f</em></span>, one without such side effects) in the mathematical world would yield the same result <span class="emphasis"><em>f(x)</em></span> each time with the same value of <span class="emphasis"><em>x</em></span>, say <span class="emphasis"><em>sin(x)</em></span>. This characteristic is attributed to idempotency in software behavior (delivers consistency). Now you understand how this characteristic became so fundamental to functional programming.</p>
        <p>Let's understand the consequence of this by looking at two functions: one which is referentially opaque (with side effects), and the other which is referentially transparent:</p>
        <pre class="programlisting">    public class Counter  
    { 
      private int i = 0; 
      public int AddOneRO (int x) //Referentially Opaque 
      { 
        i += 1; 
        return x + i; 
      } 
      public int AddOneRT (int x) //Referentially Transparent 
      { 
        return x + 1; 
      } 
    } 
</pre>
        <p>The function <code class="literal">AddOneRT</code> is referentially transparent, which means that <code class="literal">AddOneRT (x) = AddOneRT (y)</code> if <code class="literal">x = y</code>. However, we can't say any such thing for <code class="literal">AddOneRO</code>, because it uses a global variable (<code class="literal">i</code>) that it modifies.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note41"></a>Note</h3>
            <p>Now since <code class="literal">AddOneRO (x) &lt;&gt; AddOneRO (y)</code> if <code class="literal">x = y</code>, this further implies <code class="literal">AddOneRO (x) - AddOneRO (x) &lt;&gt; 0</code>, thus invalidating the fundamental mathematical identity (<code class="literal">x - x = 0</code>)!</p>
          </div>
        </div>
        <p>This has major consequences in terms of code robustness and optimization by means of memorization (caching intermediate results), common subexpression elimination (where the result of a pure expression can be substituted in place of repeated evaluations without affecting the program behavior), lazy evaluation, or parallelization. So, in order to reap the benefits of these consequences from functional computation, one needs to strive to get the functions to be as referentially transparent (that is, free from the side effects of memory and I/O) as a mathematical function. With this, we come to the next important functional programming feature where functions become first-class citizens.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="First-class and higher-order functions">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec68"></a>First-class and higher-order functions</h1>
            </div>
          </div>
        </div>
        <p>Functions are the fundamental processing units in functional programming, and since they can be used like any other value, functions can be stored in variables, properties, objects, and collections. The term first-class function was created by Christopher Strachey.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note42"></a>Note</h3>
            <p>Higher-order functions are functions that can either take other functions as arguments or return them as results.</p>
          </div>
        </div>
        <p>C# supports higher-order functions (both named and anonymous), which are treated like ordinary variables with a function type.</p>
        <div class="section" title="Function type">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec36"></a>Function type</h2>
              </div>
            </div>
          </div>
          <p>C# provides the capability to define both generic functions and strongly typed delegates. The delegate type carries the method signature of a function prototype, and its instances become function pointers. Thus, you can manipulate a function variable whose function method signature matches with that of the function prototype.</p>
          <p>In addition to generic function types, C# 2.0 introduced anonymous methods/delegates and iterators (with the <code class="literal">yield return</code> statement which lets you create iterator/continuation methods that return sequences based on the caller's demand/pull. That is, you get the benefit of deferred execution without incurring storage allocation overheads for the input and output sequences), which provided more flexibility and compositional capability. We can also use the following three generic function types that C# provides:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">A function that takes multiple type arguments, and returns result of a particular type:</li>
            </ul>
          </div>
          <pre class="programlisting">        Func&lt;T1, T2, . . . , Tn, TReturn&gt;</pre>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">A procedure that takes multiple type arguments, and performs action/s without returning any result:</li>
            </ul>
          </div>
          <pre class="programlisting">        Action&lt;T1, T2, . . . , Tn&gt;</pre>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">A function that takes multiple type arguments, and returns a Boolean result:</li>
            </ul>
          </div>
          <pre class="programlisting">        Predicate&lt;T1, T2, . . . , Tn&gt;</pre>
          <p>You can see the preceding function types in action as follows:</p>
          <pre class="programlisting">    public static IEnumerable&lt;T&gt; GenerateSequences&lt;T&gt; ( 
    int noOfElements, Func&lt;T&gt; generator) 
    { 
      for ( int i = 0; i &lt; noOfElements; i++ ) 
      { 
        yield return generator(); 
      } 
    } 
 
    public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; ( 
    IEnumerable&lt;TSource&gt; source, Predicate&lt;TSource&gt; predicate) 
    { 
      foreach ( TSource element in source ) 
      { 
        if ( predicate(element) ) 
          yield return element; 
      } 
    } 
</pre>
          <p>A client using the anonymous delegate syntax would consume the preceding static methods as follows:</p>
          <pre class="programlisting">    int startEven = -2; 
    int startOdd = -1; 
    int increment = 2; 
 
    //To Generate first 1000 even numbers 
    IEnumerable&lt;int&gt; evenSequences = GenerateSequences&lt;int&gt; ( 
      1000, () =&gt; startEven += increment); 
 
    //To Generate first 1000 odd numbers 
    IEnumerable&lt;int&gt; oddSequences = GenerateSequences&lt;int&gt; ( 
      1000, () =&gt; startOdd += increment); 
</pre>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note43"></a>Note</h3>
              <p>As you can see, this deferred execution model makes your algorithms use less storage space and compose better than traditional imperative methods. More importantly, with functional purity you'll be able to leverage parallelism by assigning different operations to different CPU cores, thereby improving throughput.</p>
            </div>
          </div>
          <p>Now it's time to look at a core functional programming concept which was adopted in C# 3.0, that is, lambda expressions that facilitated wide adoption of functional programming practices (with little or no knowledge on it's consequences) in the imperative world.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Lambda (λ) calculus">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec69"></a>Lambda (λ) calculus</h1>
            </div>
          </div>
        </div>
        <p>λ-calculus is a mathematical formalism for denoting computation in an abstract form using functions. This brings forth a formal notation and transformation rules for representation (function abstraction) and manipulation (function application) of lambda terms. The key to this formalism is variable binding and substitution. <span class="strong"><strong>Alonzo Church</strong></span> created lambda calculus in an attempt to prove mathematical logic.</p>
        <p>The λ-calculus provides a simple semantics&#160;for computation using computable functions based on <span class="strong"><strong>Church-Turing</strong></span> thesis (readers are urged to take a look at the history of lambda calculus, its motivation, and mathematical implications at a little deeper level to better appreciate this formalism and its consequences, as opposed to just being sheer consumers) by incorporating the following simplifications and concepts:</p>
        <div class="section" title="Anonymous functions">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec37"></a>Anonymous functions</h2>
              </div>
            </div>
          </div>
          <p>This involves treating functions as anonymous, without giving them explicit names.
For example, take this simple <code class="literal">static</code> method:</p>
          <pre class="programlisting">    public static int AddOperation (int x, int y) 
    { 
      return x + y; 
    } 
</pre>
          <p>If you rewrite the preceding static method, the equivalent representation as an anonymous delegate would be what is highlighted in the following code:</p>
          <pre class="programlisting">    Func&lt;int, int, int&gt; AddOperation = delegate(int x, int y) 
    { 
      return x + y; 
    }; 
</pre>
          <p>Now, the corresponding lambda expression would be the one highlighted in this code:</p>
          <pre class="programlisting">    Func&lt;int, int, int&gt; AddOperation = (x, y) =&gt; x + y; 
</pre>
          <p>Another lambda expression that follows the same function signature, yet bringing in a polymorphic behavior, is as follows:</p>
          <pre class="programlisting">    Func&lt;string, string, string&gt; ConcatOperation = (x, y) =&gt; x + y; 
</pre>
          <p>Now you can see the formal syntax that lambda expressions obey, as stated in the definitions given earlier, which denotes that variables <code class="literal">x</code> and <code class="literal">y</code> are bound to the lambda term <code class="literal">x + y</code>. You just witnessed the lambda abstraction for the function <span class="emphasis"><em>f(x, y) = x + y</em></span>. The function definitions (<code class="literal">AddOperation</code> and <code class="literal">ConcatOperation</code>) with this lambda abstraction just sets up the function without invocation. An application in lambda calculus parlance, with respect to the preceding example, would signify applying inputs <code class="literal">x</code> and <code class="literal">y</code> to the function <span class="emphasis"><em>f</em></span>.</p>
          <p>Function application in lambda calculus is achieved through <span class="strong"><strong>beta reduction</strong></span> (a continuous reduction process involving substitution&#160;of bound variables to the lambda terms till no applications remain for reduction). A function application in lambda calculus is analogous to method invocation in the imperative world, except that the consequences are totally different, which you would have understood by now.</p>
        </div>
        <div class="section" title="Closures">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec38"></a>Closures</h2>
              </div>
            </div>
          </div>
          <p>As mentioned earlier, the key to formalism is variable binding and substitution. Bound variables are the ones that fall within the scope of an abstraction. The remaining variables are said to be free (from the context of that specific abstraction). A closed lambda expression is one with no free variables.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note44"></a>Note</h3>
              <p>Something to note here is that a variable is bound by its nearest abstraction, which means that a free variable, with respect to an abstraction, would eventually be bound to higher abstractions in the hierarchy. And this free or unbound variable (with its associated references and values), which gets captured in the context of an abstraction (that is, the lexical Scope), constitutes a closure (again pertaining to that abstraction).</p>
            </div>
          </div>
          <pre class="programlisting">    public static Func&lt;int, Func&lt;int, int&gt;&gt; sum =  
    x =&gt; y =&gt; x + y; 
</pre>
          <p>The preceding code clearly shows a closure in action. Here, the closure object (which constitutes of variable <code class="literal">x</code> and its target method) helps to share data between the functions. The use of this higher-order <code class="literal">sum</code> function (where new functions are composed and returned) is illustrated clearly in the following code snippet:</p>
          <pre class="programlisting">    var add10 = sum(10); //Returns closure with 10 
    var add50 = sum(50); //Returns closure with 50 
 
    Console.WriteLine(add10(90));  //Returns 100 
    Console.WriteLine(add10(190)); //Returns 200 
    Console.WriteLine(add50(70));  //Returns 120 
</pre>
        </div>
        <div class="section" title="Currying and partial application">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec39"></a>Currying and partial application</h2>
              </div>
            </div>
          </div>
          <p>Partial application and currying are two distinct techniques, yet loosely depicted. It is facilitated by the capability of higher-order functions, wherein their partial application (against one or multiple arguments) returns new functions (that accept the remaining arguments) with lesser arity (compared to the original function).</p>
          <p>Let's now understand the difference between currying and partial application.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note45"></a>Note</h3>
              <p>Currying is a natural consequence of lambda calculus, where functions employ only a single input. This technique primarily involves conversion of a function evaluation that accepts multiple arguments (as in any practical function) into a series of function evaluations that accept one argument at a time. Currying got its name from Haskell Curry, who developed it following the work of Gottlob Frege and Moses Schönfinkel.</p>
            </div>
          </div>
          <p>Without much ado, let's see these in action.</p>
          <div class="section" title="Currying">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch09lvl3sec9"></a>Currying</h3>
                </div>
              </div>
            </div>
            <p>Let's go back to our old example here:</p>
            <pre class="programlisting">    public static int AddOperation (int x, int y) 
    { 
      return x + y; 
    } 
</pre>
            <p>Now this is a simple and practical function we employ mostly. Let's see how this is deftly curried to generate functions that accept one argument at a time, and yet leverage the core function for function application:</p>
            <pre class="programlisting">    public static Func&lt;T1, Func&lt;T2, TReturn&gt;&gt; Curry&lt;T1, T2, TReturn&gt; 
    (Func&lt;T1, T2, TReturn&gt; f) 
    { 
      return a =&gt; b =&gt; f(a, b); 
    } 
</pre>
            <p>Any client would leverage the curried function this way:</p>
            <pre class="programlisting">    var curriedSum = Curry&lt;int, int, int&gt;(AddOperation); 
 
    Console.WriteLine( "Sum: {0}", curriedSum(10)(90));
    //Prints Sum: 100 
</pre>
            <p>There's another interesting way to curry functions; as a matter of fact, we can curry any arbitrary function using the function definition (delegate in our case). Here we leverage e<span class="strong"><strong>xtension methods</strong></span> (a language feature introduced in version 3.0) to provide innate currying capability to a generic function definition: <code class="literal">Func&lt;T1, T2, TReturn&gt;</code>. This means you can apply currying to any function that has this method signature. See the following code:</p>
            <pre class="programlisting">    public static Func&lt;T1, Func&lt;T2, TReturn&gt;&gt; Curry&lt;T1, T2, TReturn&gt; 
    (this Func&lt;T1, T2, TReturn&gt; f) 
    { 
      return a =&gt; b =&gt; f(a, b); 
    } 
</pre>
            <p>The keyword <code class="literal">this</code> in the highlighted code enables the extension method magic for you (which essentially decorates the generic delegate type <code class="literal">Func&lt;T1, T2, TReturn</code>) with the curry function. <span class="strong"><strong>Voila</strong></span>! We finally have imparted innate currying capability to any function that conforms to this definition. Take a look at the following code:</p>
            <pre class="programlisting">    Func&lt;int, int, int&gt; op = AddOperation; 
    var curriedSum = op.Curry&lt;int, int, int&gt;(); 
 
    Console.WriteLine( 
      "Sum: {0}",  
      curriedSum1(10)(90) 
    );                
    //Prints Sum: 100 
</pre>
            <p>Now to replicate the same thing in the polymorphic function below:</p>
            <pre class="programlisting">    public static string ConcatOperation (string x, string y) 
    { 
      return x + y; 
    } 
 
    Func&lt;string, string, string&gt; op2 = ConcatOperation; 
    var curriedConcat = op2.Curry&lt;string, string, string&gt;(); 
 
    Console.WriteLine( 
      "Concatenation: {0}",  
      curriedConcat("Currying ")("Rocks!!!") 
    );                  
    //Prints "Concatenation: Currying Rocks!!!" 
</pre>
            <p>You could continue (as shown in the next code) to create more curry function overloads to support additional function definitions (that has more than two input parameters):</p>
            <pre class="programlisting">    //Currying Extension Method that Supports 3 Input Parameters 
 
    public static Func&lt;T1, Func&lt;T2, Func&lt;T3, TReturn&gt;&gt;&gt;  
    Curry&lt;T1, T2, T3, TReturn&gt;  
    (this Func&lt;T1, T2, T3, TReturn&gt; f) 
    { 
      return a =&gt; b =&gt; c =&gt; f(a, b, c); 
    } 
    // Currying Extension Method that Supports 4 Input Parameters 
 
    public static Func&lt;T1, Func&lt;T2, Func&lt;T3, Func&lt;T4, TReturn&gt;&gt;&gt;&gt;  
      Curry&lt;T1, T2, T3, T4, TReturn&gt; 
      (this Func&lt;T1, T2, T3, T4, TReturn&gt; f) 
      { 
        return a =&gt; b =&gt; c =&gt; d =&gt; f(a, b, c, d); 
      } 
</pre>
          </div>
          <div class="section" title="Partial application">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch09lvl3sec10"></a>Partial application</h3>
                </div>
              </div>
            </div>
            <p>Now let's look at partial application which is distinctively different from currying, though highly confusing to many programmers.</p>
            <div class="note" title="Note" style="">
              <div class="inner">
                <h3 class="title"><a id="note46"></a>Note</h3>
                <p>Partial application (or partial function application) is yet another consequence of lambda calculus where functions employ a fixed set of inputs. This technique primarily involves conversion of a function evaluation that accepts multiple arguments (as in any practical function) into a function that accepts a fixed number of arguments, which in turn yields yet another function that accepts the remaining arguments.</p>
              </div>
            </div>
            <p>The following code says it all:</p>
            <pre class="programlisting">    public static string ConcatOperation(string a, string b, string c,  
    string d) 
    { 
      return a + b + c + d; 
    } 
 
    //Partial Application in functions that have 3 Input Parameters 
  
    public static Func&lt;T2, T3, TReturn&gt;  
    PartialApply&lt;T1, T2, T3, TReturn&gt; 
    (this Func&lt;T1, T2, T3, TReturn&gt; f, T1 arg1) 
    { 
      return (arg2, arg3) =&gt; f(arg1, arg2, arg3); 
    } 
 
    //Partial Application in functions that have 4 Input Parameters 
 
    public static Func&lt;T2, T3, T4, TReturn&gt;  
    PartialApply&lt;T1, T2, T3, T4, TReturn&gt; 
    (this Func&lt;T1, T2, T3, T4, TReturn&gt; f, T1 arg1) 
    { 
      return (arg2, arg3, arg4) =&gt; f(arg1, arg2, arg3, arg4); 
    } 
 
    //Sample code that illustrates usage 
 
    Func&lt;string, string, string, string, string&gt; op3 = ConcatOperation; 
 
    var partiallyAppliedConcat = op3. 
    PartialApply&lt;string, string, string, string, string&gt; 
    ("Partial "); 
             
    Console.WriteLine( 
      "Concatenation: {0}",  
      partiallyAppliedConcat( 
        "Function ",  
        "Application ",  
        "Rocks!!!") 
      ); 
    //Prints "Concatenation: Partial Function Application Rocks!!!" 
</pre>
          </div>
          <div class="section" title="Applying currying and partial application">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch09lvl3sec11"></a>Applying currying and partial application</h3>
                </div>
              </div>
            </div>
            <p>Let's see these two in action in a real programming scenario. The scenario we would look at is a classic mathematical conundrum - that of determining the Pythagorean Triples within a given range. As the name suggests, the Pythagorean triple constitutes the set of numbers that satisfy the Pythagorean theorem (<span class="emphasis"><em>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></em></span>). The conventional method to find the triples is shown in the following code:</p>
            <pre class="programlisting">    //The formula that confirms a Pythagorean Triplet 
 
    public static bool IsPythagoreanTriplet (int x, int y, int z) 
    { 
      return (x * x + y * y) == (z * z); 
    } 
 
    //Function that generates the triples within a given range based    
    //on the above formula. 
 
    public static IEnumerable&lt;IEnumerable&lt;int&gt;&gt;  
    PythagoreanTriples (int range) 
    { 
      Func&lt;int, int, int, bool&gt; formula = IsPythagoreanTriplet; 
      HashSet&lt;string&gt; capturedTriplets = new HashSet&lt;string&gt;(); 
 
      for (int a = 1; a &lt; range; a++) 
      { 
        for (int b = 1; b &lt; range; b++) 
        { 
          for (int c = 1; c &lt; range; c++) 
          { 
            if (formula(a, b, c))      //Direct Evaluation 
            { 
              string keyPart1 = a.ToString(); 
              string keyPart2 = b.ToString(); 
              //This check filters the duplicate triplets 
              if (!capturedTriplets 
              .Contains(keyPart1 + ":" + keyPart2) 
              &amp;&amp; 
              !capturedTriplets 
              .Contains(keyPart2 + ":" + keyPart1) 
              ) 
              { 
                capturedTriplets 
                .Add(keyPart1 + ":" + keyPart2); 
                yield return new List&lt;int&gt;() { a, b, c }; 
              } 
            } 
          } 
        } 
      } 
    } 
</pre>
            <p>This preceding code continuously yields the triplets as and when it is discovered. Another interesting thing about the brute force approach here is that it returns duplicates (for example-[3, 4, 5] and [4, 3, 5], [6, 8, 10] and [8, 6, 10], and so on. The filter (highlighted code), in conjunction with the <span class="strong"><strong>HashSet</strong></span>, helps eliminate these duplicates.</p>
            <p>Now let's see the same code leveraging curried functions:</p>
            <pre class="programlisting">    public static IEnumerable&lt;IEnumerable&lt;int&gt;&gt;  
    PythagoreanTriplesCurried (int range) 
   { 
     Func&lt;int, int, int, bool&gt; formula = IsPythagoreanTriplet; 
<span class="strong"><strong>     var cFormula = formula.Curry&lt;int, int, int, bool&gt;();        </strong></span> 
     HashSet&lt;string&gt; capturedTriplets = new HashSet&lt;string&gt;(); 
 
     for (int a = 1; a &lt; range; a++) 
     { 
       for (int b = 1; b &lt; range; b++) 
       { 
         for (int c = 1; c &lt; range; c++) 
         { 
           if (cFormula(a)(b)(c))    //Curried Evaluation 
           { 
             // Use same code from PythagoreanTriples function
           } 
         } 
       } 
     } 
   } 
</pre>
            <p>In this case the curried function is created, based on the formula that proves the Pythagorean theorem, which would accept a valid input for <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> consecutively, and final evaluation is done when the last argument is received.</p>
            <p>Now let's check out partial application usage in this same scenario:</p>
            <pre class="programlisting">    public static IEnumerable&lt;IEnumerable&lt;int&gt;&gt;  
    PythagoreanTriplesPartiallyApplied (int range) 
    { 
      Func&lt;int, int, int, bool&gt; formula = IsPythagoreanTriplet; 
      HashSet&lt;string&gt; capturedTriplets = new HashSet&lt;string&gt;(); 
 
      for (int a = 1; a &lt; range; a++) 
      { 
        var paFormula = formula 
        .PartialApply&lt;int, int, int, bool&gt;(a); 
        for (int b = 1; b &lt; range; b++) 
        { 
          for (int c = 1; c &lt; range; c++) 
          { 
            //Final Evaluation with remaining arguments 
            if (paFormula(b, c))     
            { 
              // Use same code from PythagoreanTriples function
            } 
          } 
        } 
      } 
    } 
</pre>
            <p>Now, you can clearly see the distinction between currying and partial application. The result yielded by partial application becomes a closure (gets captured) for reuse in place of function captures in the currying approach. This early evaluation (<span class="emphasis"><em>a<sup>2</sup></em></span> and <span class="emphasis"><em>b<sup>2</sup></em></span>) in the case of partial application would give an advantage for reuse in subsequent iterations in place of repeated deferred evaluations with respect to currying. The real use of currying and partial application is seen when inputs are generated asynchronously for consumption by a grand computation function. You could capture or partially compute as and when these inputs are generated, and trigger the final evaluation on obtaining the last input. Another thing to note is that partial application can accept more than one arguments (unlike the example shown here where it accepts one as in currying). A typical consumer client would be as follows:</p>
            <pre class="programlisting">    Console.WriteLine("PythagoreanTriples within 50...."); 
 
    foreach (var triplets in PythagoreanTriplesPartiallyApplied(50)) 
    { 
      Console.WriteLine(string.Join(",", triplets.ToArray())); 
    } 
    Console.ReadLine(); 
</pre>
            <p>So, we guess no more confusions on these two concepts from now on! Another adventure (if you're game; yes, we dare you) is to do the following:</p>
            <div class="itemizedlist">
              <ul class="itemizedlist">
                <li class="listitem" style="list-style-type: disc">Optimize this algorithm (now you know there are <span class="emphasis"><em>range3</em></span> iterations and the performance impact is huge when you go beyond the range of 1,000).</li>
                <li class="listitem" style="list-style-type: disc">Making the filter operation lazily evaluated as part of the LINQ consumer query which would yield duplicates (without the HashSet in the first place). And again, nothing actually stops you from figuring out a way to generate triplets without duplicates!</li>
                <li class="listitem" style="list-style-type: disc">Figure out a way to generate triples forever as they are detected (without the limitation of a range, loop, or any computation limits (such as reaching the max value for a 64-bit signed integer).</li>
              </ul>
            </div>
          </div>
        </div>
        <div class="section" title="Expression trees">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec40"></a>Expression trees</h2>
              </div>
            </div>
          </div>
          <p>By now you have seen how to create delegates from a lambda expression (anonymous function). You can also opt to create expression tree types. Expression trees are analogous to <span class="strong"><strong>Abstract Syntax Tree</strong></span> (<span class="strong"><strong>AST</strong></span>) in the compiler construction realm, and they embody code in a tree data structure, where each node is represented as an expression. Using expression trees, you can compile and run code, thereby gaining powerful ability to dynamically modify executable code.
</p>
          <div class="blockquote">
            <table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote">
              <tbody><tr>
                <td valign="top">&#160;</td>
                <td valign="top">
                  <p>
<span class="emphasis"><em>Expression trees are also used in the Dynamic Language Runtime (DLR) to provide interoperability between dynamic languages and the .NET Framework and to enable compiler writers to emit expression trees instead of Microsoft Intermediate language (MSIL).</em></span>
</p>
                </td>
                <td valign="top">&#160;</td>
              </tr>
              <tr>
                <td valign="top">&#160;</td>
                <td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>MSDN</em></span></span></td>
              </tr>
            </tbody>
</table>
          </div>
          <p>Expression trees are inherently immutable. All that we need to get the compiler emit the code for an expression tree is to assign the lambda expression&#160;to a variable of type <code class="literal">Expression&lt;TDelegate&gt;</code>. The .NET framework provides a rich API (expression class under <span class="strong"><strong>System.Linq.Expressions Namespace</strong></span>) for parsing, creation, and manipulation (of course recreating with appropriate tree visitors). The API supports most of the language grammar.</p>
          <p>Altogether, this becomes a very powerful construct that can be leveraged for code/dependency injection, <span class="strong"><strong>Domain-Specific Language</strong></span> (<span class="strong"><strong>DSL</strong></span>) creation, and associated language translations (all you would need to do in such a case is to let your dynamic language <span class="strong"><strong>lexer</strong></span> and <span class="strong"><strong>parser</strong></span> to generate the <span class="strong"><strong>Abstract Syntax Tree</strong></span> (<span class="strong"><strong>AST)</strong></span>, which in our case is the expression&#160;tree itself, and DLR would do the rest. Don't think twice before embarking on your next DSL adventure. There is inherent platform support!)You finally understand how a lambda expression (an anonymous function) can be used to create delegates or&#160;expression&#160;tree types. By using lambda expressions, you can write local functions that can be passed as arguments or returned as the value of function calls.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Recursion">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec70"></a>Recursion</h1>
            </div>
          </div>
        </div>
        <p>Recursions are no alien feature to any programmer worth his salt. Recursions are leveraged in functional programming to accomplish iteration/looping. Recursive functions invoke themselves, performing an operation repeatedly till the base case is reached. Tail call-based recursions are a common phenomenon. Recursion typically involves adding stack frames to the call stack, thus growing the stack. You can run out of stack space during deep recursions. The compiler does its own share of optimizations (predominantly tail call optimization/elimination) to conserve stack space and improve throughput. But the functional world (with its first-class and higher-order functions) gives us more flexibility to wire such optimizations in our recursive functions. Let's see how this is achieved with the following factorial example:</p>
        <pre class="programlisting">    //Regular Recursion 
 
    Func&lt;int, int&gt; factorial = (n) =&gt; 
    { 
      Func&lt;int, int&gt; fIterator = null; //Work-around for "use of 
        unassigned variable" error! 
      fIterator = (m) =&gt;  
        (m &lt; 2) ? 1 : m * fIterator(m - 1); 
      return fIterator(n); 
    };</pre>
        <p>Unlike the classical example, you see how recursion is put to work by lambda expressions as well, which makes you use these anonymous functions as higher order functions (where they are dynamically created or passed as arguments). You can also notice the use of a wrapper function (factorial in this case), which is directly called, but does not recurse itself, and instead, leverages an auxiliary function (<code class="literal">fIterator</code> in this case) to do the actual recursion.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note47"></a>Note</h3>
            <p>The wrapper function becomes handy for performing parameter validations, error handling, memorization, and so forth.</p>
          </div>
        </div>
        <p>In order to conserve stack space, we can opt for a tail call elimination technique known as tail recursion as follows:</p>
        <pre class="programlisting">    //Tail Call Elimination with Tail Recursion 
 
    Func&lt;int, int&gt; factorial = (n) =&gt; 
    { 
      Func&lt;int, int, int&gt; fIterator = null; 
      fIterator = (product, i) =&gt;  
        (i &lt; 2) ? product : fIterator(product * i, i - 1); 
      return fIterator(1, n); 
    };</pre>
        <p>In this case, no state, except for the calling function's address, needs to be saved either on the stack or on the heap, and the call stack frame for <code class="literal">fIterator</code> is reused for storage of the intermediate results. Another thing to note is the addition of an accumulator argument (product in this case).</p>
        <p>Tail recursion can be achieved by another technique called <span class="strong"><strong>trampolining</strong></span>, where functions are called by a <code class="literal">trampoline</code> function as opposed to functions calling each other directly. All the needed payload (function pointer and arguments) for the function call is provided to the <code class="literal">trampoline</code> function, which then places the call on the caller's behalf. This ensures that the stack does not grow and iteration can continue indefinitely:</p>
        <pre class="programlisting">    //Tail Recursion with Trampolining 
 
    Func&lt;int, int&gt; factorial = (n) =&gt; 
    { 
      Func&lt;int, int, int&gt; trampoline = null; 
      Func&lt;int, int, int&gt; fIterator = (product, i) =&gt;  
        (i &lt; 2) ? product : trampoline(product * i, i - 1); 
      trampoline = (product, i) =&gt;  
        fIterator(product * i, i - 1); 
      return trampoline(1, n); 
    }; 
</pre>
        <p>The following image depicts the supporting language constructs that have evolved to make these functional programming features available for consumption:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_09_01-1.jpg" alt="Recursion"/>
        </div>
        <p>
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Sample programs">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec71"></a>Sample programs</h1>
            </div>
          </div>
        </div>
        <p>Now that we have taken a detailed look at the core functional programming constructs, it's time to indulge in power play (with code of course). Let's learn to play the game with some hardcore sample programs.</p>
        <div class="section" title="Spell checker">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec41"></a>Spell checker</h2>
              </div>
            </div>
          </div>
          <p>This was inspired by Peter Norvig's (former Research Director at Google) technical blog on <span class="emphasis"><em>How to Write a Spelling Corrector</em></span>. What is interesting is the way the solution has been envisaged. The solution employs the probability theory at its core to find all possible corrections for a word of length <span class="emphasis"><em>n</em></span>, by accounting for user errors in the form of typos arising because of omissions (deletes), characters misplaced (replaces and transposes), and inserted (inserts).</p>
          <p>You can refer to this technical blog on&#160;<span class="emphasis"><em>How to Write a Spelling Corrector</em></span> &#160;by&#160;Peter Norvig for the following:</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note48"></a>Note</h3>
              <p>For a word of length <span class="emphasis"><em>n</em></span>, there will be <span class="emphasis"><em>n</em></span> deletions, <span class="emphasis"><em>n-1</em></span> transpositions, <span class="emphasis"><em>26n</em></span> replacements, and <span class="emphasis"><em>26(n+1)</em></span> insertions.</p>
            </div>
          </div>
          <p>To have fair shot at determining the corrections, we do find all possible corrections that are 1 (<code class="literal">edits1</code> function) and 2 (<code class="literal">edits2</code> function) distance away. You would be able to see the function compositions in the code given next using LINQ queries that yield these possible corrections in a breeze. This demonstrates the expressive and declarative power of lambda expressions.</p>
          <p>What is most important, and to ensure the right filtering of this huge set (for meaningful corrections), is to determine what are the known or meaningful words. For this a dictionary is either fed or created (in our case) from a corpus of free text from Project Gutenberg, and lists of the most frequent words from Wiktionary and the British National Corpus. The text is extracted, concatenated, and provided in the text file <code class="literal">NSC_Training_Model.txt</code> (you could also directly obtain this from <a class="ulink" href="http://norvig.com/big.txt">http://norvig.com/big.txt</a>). The <code class="literal">known</code> function does this filtering for you.</p>
          <p>Now, to determine the list of corrections in the order of recommendation, we employ the probability of occurrence of the known corrections in the dictionary created out of the corpus (as it becomes a good indication of common usage). Now you know how personalized spelling correctors work on your mobile device! (Yes, you guessed it right, it certainly is based on the probability of the list of possible corrections in the order of your usage of words).</p>
          <p>The authors encourage the readers to visit the site (<a class="ulink" href="http://norvig.com/spell-correct.html">http://norvig.com/spell-correct.html</a>), and take a look at the detailed explanation of the solution. One of the authors has his JavaScript implementation published on the site as well.</p>
          <p>The function <code class="literal">NorvigSpellChecker</code> shown below returns a list of potential corrections based on the word and count (maximum items in list) specified:</p>
          <pre class="programlisting">    public static IEnumerable&lt;string&gt; NorvigSpellChecker  
    (string word, int count) 
    { 
      var alphabets = @"abcdefghijklmnopqrstuvwxyz"; 
      var WORDS = new ConcurrentDictionary&lt;string, int&gt;(); 
      var trainingFile = @"D:\Packt\Code\NSC_Training_Model.txt"; 
     
      //Training Model Creation 
 
      var Train = Task.Factory.StartNew(() =&gt; 
      { 
        foreach (var line in File 
          .ReadLines(trainingFile) 
          .AsParallel())    //Parallel read 
        { 
          foreach (Match match in  
          Regex.Matches( 
            line,  
            @"([a-z]+)",     //Word detection 
            RegexOptions.IgnoreCase 
          ) 
          .AsParallel()) 
          { 
            WORDS.AddOrUpdate(    //Add detected word to dictionary
              match.Value,             
              0, 
              (k, v) =&gt; v + 1);   //Increment word count 
          } 
      } 
    }); 
 
    //All edits that are 1 edit away from word 
 
    Func&lt;string, Task&lt;IEnumerable&lt;string&gt;&gt;&gt; edits1 =  
    (tWord) =&gt; Task.Factory.StartNew(() =&gt; 
    { 
      return from i in Enumerable.Range(0, tWord.Length) 
      select new 
      { 
        part1 = tWord.Substring(0, i), 
        part2 = tWord.Substring(i) 
      }; //splits 
    }) 
    .ContinueWith(ant =&gt; 
    { 
      return (from splits in ant.Result 
      where splits.part2 != "" 
      select splits.part1 +  
      splits.part2 
      .Substring(1))                    //deletes 
      .Union(from splits in ant.Result 
      where splits.part2.Length &gt; 1 
      select splits.part1 +  
      splits.part2[1] +  
      splits.part2[0] +  
      splits.part2 
      .Substring(2))                    //transposes 
      .Union(from splits in ant.Result 
      from c in alphabets 
      where splits.part2 != "" 
      select splits.part1 + c + splits.part2.Substring(1)) //replaces 
      .Union(from splits in ant.Result 
      from c in alphabets 
      select splits.part1 + c + splits.part2);             //inserts 
    }); 
 
    //All edits that are 2 edits away from word 
 
    Func&lt;string, Task&lt;IEnumerable&lt;string&gt;&gt;&gt; edits2 =  
    (tWord) =&gt; Task.Factory.StartNew(() =&gt; 
    { 
      return (from e1 in edits1(tWord).Result 
      from e2 in edits1(e1).Result 
      where WORDS.ContainsKey(e2) 
      select e2); 
    }); 
 
    //Returns the subset of words that appear in the  
    //dictionary of WORDS 
 
    Func&lt;IEnumerable&lt;string&gt;, Task&lt;IEnumerable&lt;string&gt;&gt;&gt; known =  
    (tWords) =&gt; Task.Factory.StartNew(() =&gt; 
    { 
      return (from e1 in tWords 
      where WORDS.ContainsKey(e1) 
      select e1); 
    }); 
 
    //Generate all possible spelling corrections for word 
 
    Func&lt;string, Task&lt;IEnumerable&lt;string&gt;&gt;&gt; candidates =  
    (tWord) =&gt; Task.Factory.StartNew(() =&gt; 
    { 
      List&lt;string&gt; tWords = new List&lt;string&gt;(); 
      tWords.Add(word); 
      return ((from e1 in known(tWords).Result 
      select e1) 
      .Union(from e2  
      in known(edits1(tWord).Result).Result 
      select e2) 
      .Union(from e3  
      in known(edits2(tWord).Result).Result 
      select e3) 
      .Union(from e4  
      in tWords 
      select e4)) 
      .Distinct(); 
    }); 
 
    //Returns most probable spelling correction for word in the  
    //order of their probability of occurrence in the corpus 
 
    Func&lt;string, Task&lt;IEnumerable&lt;string&gt;&gt;&gt; corrections =  
    (tWord) =&gt; Task.Factory.StartNew(() =&gt; 
    { 
      var N = (from x in WORDS 
      select x.Value) 
      .Sum(); 
      List&lt;string&gt; tWords = new List&lt;string&gt;(); 
      return (from e1 in candidates(tWord).Result 
        .OrderByDescending( 
          e1 =&gt; WORDS.ContainsKey(e1) ?  
          (float) WORDS[e1] / (float) N : 0) 
          select e1) 
      .Take(count); 
    }); 
    Task.WaitAll(Train);            //Ensures Training Model is Created! 
    return corrections(word).Result; 
  } 
</pre>
          <p>A declarative style of coding with lambda expressions has been employed fluidly in realizing this spell checker. You could see how the algorithm is composed using LINQ expressions. Closures, concurrency, and parallelism (in the form of PLINQ) has been employed in realizing this function. A typical consumer of this spell checker would be the following:</p>
          <pre class="programlisting">    static void SpellCheckerClient () 
    { 
      var corrections = NorvigSpellChecker("somthing", 10); 
 
      foreach (var correction in corrections) 
      { 
        Console.WriteLine(correction); 
      } 
      Console.WriteLine("Training Model Creation Complete! {0}",  
      corrections.Count()); 
    } 
</pre>
          <p>We urge interested developers to explore options to further parallelize the algorithm/steps, and see the results (at least from a performance standpoint). It would be a worthwhile journey to understand that the parallelization constructs at your disposal (especially PLINQ and TPL) are not mere silver bullets!</p>
        </div>
        <div class="section" title="Subset generation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec42"></a>Subset generation</h2>
              </div>
            </div>
          </div>
          <p>This problem has a classical implication on a variety of NP-complete problems that we are exposed to in daily life. The procedural and generic serial implementation is shown as follows:</p>
          <pre class="programlisting">    public static IEnumerable&lt;IEnumerable&lt;T&gt;&gt;  
    Subsets&lt;T&gt; (IEnumerable&lt;T&gt; inputSet) 
    { 
      T[] _input = inputSet.ToArray&lt;T&gt;(); 
      int _bitcount = _input.Length; 
      int _mask = Convert.ToInt32(Math.Pow(2.0d, _bitcount)); 
      int i = 0; 
      while (i &lt; _mask) 
      { 
        List&lt;T&gt; _output = new List&lt;T&gt;(); 
        int j = 0; 
        while (j &lt; _bitcount) 
        { 
          if ((i &amp; (1 &lt;&lt; j)) &gt; 0) 
          { 
            _output.Add(_input[j]); 
          } 
          j++; 
        } 
        yield return _output.ToArray&lt;T&gt;(); 
        i++; 
      } 
    } 
</pre>
          <p>As you see, the preceding algorithm leverages Boolean logic to determine the unique sets. The possible <span class="emphasis"><em>ON (1)</em></span> states of the gates determine the sets, and we just need to determine the index of the element in the array (that has the complete list of elements whose sets need to be determined) that yields a state of 1.</p>
          <p>The declarative equivalent of the preceding implementation has been realized with PLINQ as follows:</p>
          <pre class="programlisting">    string[] names = { "a", "b", "c", "d", "e", "f" }; 
 
    var result = from i in Enumerable 
    .Range(0, Convert.ToInt32(Math.Pow(2.0d, names.Length))) 
    .AsParallel() 
    from j in Enumerable 
    .Range(0, names.Length) 
    .AsParallel() 
    let k = new 
    { 
      a = i, 
      b = names[j] 
    } 
    where ((i &amp; (1 &lt;&lt; j)) &gt; 0) 
    orderby k.a 
    group k.b by k.a; 
</pre>
          <p>Now, to take this to the next level, since this has a limit (9,223,372,036,854,775,807 - max value for a 64-bit signed integer) on the <code class="literal">_mask</code>, that is, computing the total possible combinations, we would have to trade this algorithm for another which can continuously generate subsets, that too, forever. This is the power of deferred execution and continuation methods (supported by the <code class="literal">yield return</code> keyword). Let's see this algorithm (again optimized for some amount of parallelism which becomes significant for large set generation). This also employs Boolean logic but in a different way. It computes 1- bit addition forever, in this case using the full adder logic (as the resulting bits directly represent the set):</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_09_02.jpg" alt="Subset generation"/>
          </div>
          <p>
</p>
          <p>The parallelization done here is to chunk the binary additions for each <code class="literal">overFlow</code> (as the code indicates). For example, say there are three elements namely, 10, 20, and 30. The process of determining the sets (including chunking) would happen as follows:</p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col/>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
<p>
<span class="strong"><strong>Bits</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Chunks</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Resulting set</strong></span>
</p>
</td>
                </tr>
                <tr>
                  <td>
<p>0 - 0 - 1</p>
</td>
                  <td>
<p>1</p>
</td>
                  <td>
<p>[30]</p>
</td>
                </tr>
                <tr>
                  <td>
<p>0 - 1 - 0</p>
</td>
                  <td>
<p>2</p>
</td>
                  <td>
<p>[20]</p>
</td>
                </tr>
                <tr>
                  <td>
<p>0 - 1 - 1</p>
</td>
                  <td>
<p>2</p>
</td>
                  <td>
<p>[20, 30]</p>
</td>
                </tr>
                <tr>
                  <td>
<p>1 - 0 - 0</p>
</td>
                  <td>
<p>3</p>
</td>
                  <td>
<p>[10]</p>
</td>
                </tr>
                <tr>
                  <td>
<p>1 - 0 - 1</p>
</td>
                  <td>
<p>3</p>
</td>
                  <td>
<p>[10, 30]</p>
</td>
                </tr>
                <tr>
                  <td>
<p>1 - 1 - 0</p>
</td>
                  <td>
<p>3</p>
</td>
                  <td>
<p>[10, 20]</p>
</td>
                </tr>
                <tr>
                  <td>
<p>1 - 1 - 1</p>
</td>
                  <td>
<p>3</p>
</td>
                  <td>
<p>[10, 20, 30]</p>
</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>The initial set of bit (<span class="emphasis"><em>0-0-0</em></span>) which yields an empty set is ignored here. The overflows are indicated by the high-lighted rows, and the bits that shift are represented as bold. The throughput was observed to be ~three times faster than the serial implementation on a quad-Core computer! In case you're wondering why parallelization has been restricted to one level, the authors urge you to find out the effect of parallelizing/optimizing further. This is a NP-complete problem that would demand <span class="emphasis"><em>2n</em></span> cores for the ultimate parallelization! It would be interesting to see how these sets could be applied for packing algorithms:</p>
          <pre class="programlisting">    public static IEnumerable&lt;IEnumerable&lt;T&gt;&gt;  
    BigSubsetsP&lt;T&gt; (IEnumerable&lt;T&gt; inputSet) 
    { 
      T[] _input = inputSet.ToArray&lt;T&gt;(); 
      BlockingCollection&lt;IEnumerable&lt;T&gt;&gt; output = new  
      BlockingCollection&lt;IEnumerable&lt;T&gt;&gt;(boundedCapacity: 20); 
      int _bitcount = _input.Length; 
      BitArray bits = new BitArray(_bitcount); 
      BitArray _bitsIncrement = new BitArray(_bitcount); 
      _bitsIncrement.Set(0, true); 
 
      //Stage#1 [GENERATE] 
 
      var generate = Task.Factory.StartNew(() =&gt; 
      { 
        try 
        { 
          Parallel.For(0, _bitcount, 
          (chunkIndex) =&gt; 
          { 
            BitArray _bits = new BitArray(_bitcount); 
            bool overFlow = false; 
            _bits.Set(chunkIndex, true); 
            output.Add(new[] { _input[chunkIndex] }); 
            while (!overFlow) 
            { 
              List&lt;T&gt; _output = new List&lt;T&gt;(); 
              int j = 0; 
              bool a; 
              bool b; 
              bool cIN = false; 
              bool cOUT = false; 
              bool bSUM = false; 
              while (j &lt;= chunkIndex) //Full-Adder Addition 
              { 
                a = _bits[j]; 
                b = _bitsIncrement[j]; 
                bSUM = a ^ b ^ cIN;   
                cOUT = (a &amp; b) | (cIN &amp; (a ^ b)); 
                _bits.Set(j, bSUM); 
                if (bSUM) 
                { 
                  _output.Add(_input[j]); 
                } 
                cIN = cOUT; 
                j++; 
              } 
              overFlow = cIN; 
              if (_output.Count &gt; 0) 
              { 
                output.Add(_output.ToArray&lt;T&gt;()); 
              } 
              _output.Clear(); 
              _output = null; 
            } 
            _bits = null; 
          }); 
        } 
        finally 
        { 
          output.CompleteAdding(); 
        } 
      }); 
 
      //Stage#2 [CONCURRENT READ] 
 
      foreach (var subset in 
      output.GetConsumingEnumerable().AsParallel()) 
      { 
        yield return subset; 
      } 
      generate.Wait(); 
    } 
</pre>
          <p>Just in case you are wondering how this could help in solving packing problems (of course with smaller sets), see this client given next, which generates the various ways in which the following packages (having weights 3, 1, 1, 2, 2, and 1 kg) could be packed in boxes that can accommodate 5 kg. We believe this opens up a window of possibilities for any interested developer:</p>
          <pre class="programlisting">    static void GenerateBoxingCombinations () 
    { 
      Console.WriteLine("All possible packages:"); 
      var watch = Stopwatch.StartNew(); 
      var resultSet = from subset in  
      Program4.BigSubsetsP&lt;int&gt;( 
        new List&lt;int&gt;() { 3, 1, 1, 2, 2, 1 }) 
      .AsParallel() 
      where subset.Sum() == 5 
      select subset; 
      foreach (var set in resultSet) 
      { 
        Console.WriteLine( 
          "SET &gt;&gt; {0} :: SUM &gt;&gt; {1}",  
          string.Join(",", set),  
          set.Sum()); 
      } 
      Console.WriteLine( 
        "Elapsed Time for Package set Generation : {0} seconds",    
        watch.ElapsedMilliseconds / 1000D); 
      } 
</pre>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="How does LINQ work?">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec72"></a>How does LINQ work?</h1>
            </div>
          </div>
        </div>
        <p>Before we conclude this chapter, we would like to give you a rough idea about how <span class="strong"><strong>Language Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>) works under the hood, in a schematic manner. As we know, LINQ is a declarative language embedded inside a multi-paradigm language. The primary advantage of LINQ is the alignment to the rich type system of C#. Syntactically, LINQ is very similar to SQL language and the evaluation model is very similar to an SQL engine. As an example, let us explore a LINQ query which retrieves information regarding a set of employees by querying <code class="literal">Employee</code> and <code class="literal">Department</code> table. The query returns an anonymous type consisting of employee name, department name and location of the employee. We are using the comprehension syntax in this particular example:</p>
        <pre class="programlisting">    var empInfo = from emp in db.Employee
    join dept in db.Department
    on emp.deptid equals dept.nid
    select new
    {
      emp.Name,
      dept.Name,
      emp.Location
    };</pre>
        <p>While evaluating this LINQ statement, even though documentation states about outer sequence and inner sequence, schematically speaking, a cartesian product (aka cross join in database parlance) will be performed between <code class="literal">Employee</code> and <code class="literal">Department</code> table. The resulting data set will be filtered based on the join clause (on <code class="literal">emp.deptid</code> equals <code class="literal">dept.nid</code>), resulting in yet another data set.</p>
        <p>Then, a project operation will be performed (<code class="literal">select new { &lt;data&gt; }</code>) to create an instance of new anonymous type, to add into a collection. The anonymous type will be synthesized by the C# compiler during the compile time. The above example uses comprehension style syntax and it will be transformed into a lambda expression syntax by the C# compiler, before generating the code. When we evaluate comprehension queries or mixed mode queries, the C# compiler transforms everything to lambda syntax before generating the code. The core algorithm for evaluation of LINQ queries are:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Cartesian product (of data sets involved)</li>
            <li class="listitem" style="list-style-type: disc">Restrict or filter (where predicate)</li>
            <li class="listitem" style="list-style-type: disc">Order by</li>
            <li class="listitem" style="list-style-type: disc">Group operations</li>
            <li class="listitem" style="list-style-type: disc">Projection (technical name for selecting subsets of fields, in a result)</li>
          </ul>
        </div>
        <p>To understand more about the query evaluation process, one can consult a book which deals with relational database theory, as this topics warrants another book! The LINQ was introduced with C# with version 3.0 of the language and the designers of language introduced the following features to the language to facilitate the implementation of LINQ. They are:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lambda expressions and functions</strong></span>: To facilitate the passing of predicates and transformations as parameters to LINQ operator functions</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Extension methods</strong></span>: To avoid the syntactic clutter while nesting LINQ operators (transformation of nested queries to fluent interface style)</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Anonymous types</strong></span>: To allow developers to project the contents of a data set to types which are not declared ahead of time by the developers</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Type inference</strong></span>: This feature was mandated because of the difficulty for programmers to identify the type of result from a LINQ operations</li>
          </ul>
        </div>
        <p>Try to understand in detail what has been covered in this section. If you are able to comprehend what has been dealt here tersely, it can help improve the competence as a developer.
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec73"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>Functional programming model and its idioms help a programmer to write better code in the many-core architecture of the modern CPUs. C# programming language and the .NET platform has incorporated FP constructs into the language to help write certain kind of code in a functional manner. The mastery of lambda expressions and functions, type inference, expression trees, LINQ, and so on helps structure our code better if used judiciously by mixing the OOP and FP codes. Mixing of OOP and FP to write code is termed as object/functional programming, and most modern day languages like C#, Scala, Java (after version 8), Ruby, and so on support this idiom. In the next chapter, we will implement some GoF design patterns using object/functional programming, and also pick up some OOP/FP programming idioms such as map/reduce.</p>
      </div>
    </div>
</body>
</html>