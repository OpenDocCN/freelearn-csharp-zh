- en: '*Chapter 9*: Working with Data in .NET 6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：在 .NET 6 中处理数据'
- en: One of the essential components for any application is the ability to persist
    data to a permanent data store; some forethought in picking the right persistent
    store can help a system scale better in the future.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的一个基本组件是将数据持久化到永久数据存储的能力；在选择合适的持久化存储时进行一些前瞻性思考可以帮助系统在未来更好地扩展。
- en: One of the common operations in any application is to log in to the system,
    perform some reads/updates, log off, and then come back later to see whether the
    changes were retained. Databases play a significant role in persisting these actions,
    which are typically called **user transactions**. Apart from transactional data,
    for monitoring and debugging purposes, an application may additionally need to
    store logging data and auditing data, such as who modified the date. An important
    step for designing any such application is to understand the requirements and
    design the database accordingly. It's also important to choose/design a database
    according to various data retention requirements and any data protection policies,
    such as the **General Data Protection Regulation** (**GDPR**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序中常见的操作之一是登录系统，执行一些读取/更新操作，注销，然后稍后再回来查看是否保留了更改。数据库在持久化这些通常称为 **用户事务** 的操作中发挥着重要作用。除了事务数据外，为了监控和调试目的，应用程序可能还需要存储日志数据和审计数据，例如谁修改了日期。设计任何此类应用程序的一个重要步骤是理解需求并相应地设计数据库。选择/设计数据库时，还必须考虑各种数据保留要求和任何数据保护政策，例如
    **通用数据保护条例**（**GDPR**）。
- en: 'There can be multiple data providers for an application, such as a **Structured
    Query Language** (**SQL**) data provider, NoSQL data provider, and file data provider.
    In this chapter, we will discuss various data providers that can be used for storage
    and data handling in .NET 6\. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以有多个数据提供者，例如结构化查询语言（**SQL**）数据提供者、NoSQL 数据提供者和文件数据提供者。在本章中，我们将讨论可用于 .NET
    6 中存储和数据处理的多种数据提供者。我们将涵盖以下主题：
- en: Introduction to data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据简介
- en: Disk, files, and directories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘、文件和目录
- en: SQL, Azure Cosmos DB, and Azure Storage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL、Azure Cosmos DB 和 Azure Storage
- en: Working with EF Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EF Core 进行操作
- en: Designing a Data Access service using Azure Cosmos DB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure Cosmos DB 设计数据访问服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A basic understanding of .NET Core, C#, Azure, and the .NET **command-line interface**
    (**CLI**) is required.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解 .NET Core、C#、Azure 和 .NET **命令行界面**（**CLI**）。
- en: 'The code files for this chapter can be found at the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下链接找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08).
- en: 'The instructions for the code can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的说明可以在这里找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).
- en: Introduction to data
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据简介
- en: Any web application, be it a content management system, social networking platform,
    or e-commerce application, needs to persist data to a permanent store so that
    users can retrieve, consume, and process data as needed. In [*Chapter 8*](B18507_08_Epub.xhtml#_idTextAnchor714),
    *All You Need to Know about Caching*, we discussed using cache stores; however,
    cache stores are temporary storage and data still needs to be persisted in permanent
    storage. So, we need a store that not only supports various **Create/Read/Update/Delete**
    (**CRUD**) operations on different entities but also supports high availability
    and recovers any data in case of an outage, that is, disaster recovery.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络应用程序，无论是内容管理系统、社交网络平台还是电子商务应用程序，都需要将数据持久化到永久存储中，以便用户可以按需检索、消费和处理数据。在[*第8章*](B18507_08_Epub.xhtml#_idTextAnchor714)，“所有你需要知道的缓存知识”中，我们讨论了使用缓存存储；然而，缓存存储是临时存储，数据仍然需要持久化在永久存储中。因此，我们需要一个不仅支持对各种实体进行**创建/读取/更新/删除**（**CRUD**）操作，而且支持高可用性并在出现故障时恢复任何数据的存储，即灾难恢复。
- en: One of the key criteria for better system design is to have a data model designed
    at an early stage of the system. The data model should try to define all the possible
    entities that are required for the system to function and interact between various
    entities. Having a data model defined early on in the system design helps in identifying
    the right strategies on how to manage data and what data store can be used, and
    in deciding various replication/partition strategies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀系统设计的关键标准之一是在系统设计的早期阶段就设计数据模型。数据模型应尝试定义系统运行和实体间交互所需的所有可能的实体。在系统设计早期定义数据模型有助于确定如何管理数据以及可以使用哪种数据存储，以及决定各种复制/分区策略。
- en: Two commonly classified data stores are explained in the following sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将解释两种常见的数据存储分类。
- en: Relational database management system (RDBMS)
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统（RDBMS）
- en: Relational databases store data in tables. Each entity is defined as one or
    more tables and a database is defined using multiple tables. The process of segregating
    tables into multiple tables is called **normalization**. The relations between
    various tables are defined by foreign key constraints. Properties of entities
    are defined as columns, and multiple entities of the same type are stored as rows.
    Some commonly used relational databases are Microsoft SQL Server, MySQL, PostgresSQL,
    and Oracle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库将数据存储在表中。每个实体被定义为一张或多张表，数据库通过多张表来定义。将表分割成多张表的过程称为**规范化**。各种表之间的关系通过外键约束来定义。实体的属性定义为列，相同类型的多个实体存储为行。一些常用的关系型数据库包括Microsoft
    SQL Server、MySQL、PostgreSQL和Oracle。
- en: 'A typical relational database to store employee information could possibly
    have an `employee` table defining various properties of employees, such as name,
    employee ID, and so on, and columns with employee ID as the primary key. Multiple
    employees are stored in separate rows in this table. Any properties of employees
    can further be normalized into a separate table; for example, an employee''s projects
    can be stored in a separate table (as there can be more than one project), say,
    `employeeproject`, and can be linked to the `employee` table using the employee
    ID, as shown in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的用于存储员工信息的关系型数据库可能有一个`employee`表，定义员工的各项属性，如姓名、员工ID等，以及以员工ID作为主键的列。多个员工以单独的行存储在这个表中。员工的任何属性都可以进一步规范化到单独的表中；例如，员工的工程项目可以存储在单独的表中（因为可能有多个项目），比如`employeeproject`，并且可以通过员工ID与`employee`表链接，如下面的图所示：
- en: '![Figure 9.1 – Employee ER diagram'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 员工实体关系图'
- en: '](img/Figure_9.1_18507.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_18507.jpg)'
- en: Figure 9.1 – Employee ER diagram
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 员工实体关系图
- en: 'The following are a few key characteristics of the relational database:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关系型数据库的关键特性：
- en: Relational databases are queried using SQL.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库使用SQL进行查询。
- en: Tables mostly have a well-defined schema and constraints and are less likely
    to change.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表通常具有明确的模式和约束，并且不太可能发生变化。
- en: All the transactions have **Atomicity/Consistency/Isolation/Durability** (**ACID**)
    properties, hence maintaining the data integrity and consistency.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有交易都具有**原子性/一致性/隔离性/持久性**（**ACID**）属性，因此维护数据完整性和一致性。
- en: As data is normalized, redundancy is minimized.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据已规范化，冗余最小化。
- en: Relational databases usually support vertical scaling, that is, scaling up (they
    do support replication, but it is an expensive operation compared to replication
    in NoSQL databases).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库通常支持垂直扩展，即向上扩展（它们确实支持复制，但与NoSQL数据库中的复制相比，这是一个昂贵的操作）。
- en: NoSQL
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL
- en: Another kind of data store is NoSQL databases, which store data in an unstructured
    format where the data doesn't need to have a predefined schema. Most commonly,
    data is either stored as a key-value pair (such as in Redis), stored as a document
    (such as in MongoDB and CouchDB), or stored as a graph using a graph structure
    (for example, in Neo4j).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的数据存储是NoSQL数据库，它们以非结构化格式存储数据，其中数据不需要有预定义的模式。最常见的是，数据以键值对的形式存储（例如在Redis中），以文档的形式存储（例如在MongoDB和CouchDB中），或使用图结构存储为图（例如在Neo4j中）。
- en: 'If we take the same employee example and persist it in a NoSQL database, such
    as MongoDB, we will end up storing it in something such as an `employee` collection,
    with each document storing all the properties of the employee, as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将相同的员工示例持久化到NoSQL数据库中，例如MongoDB，我们最终会在一个名为`employee`的集合中存储它，每个文档存储员工的全部属性，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following are a few key characteristics of NoSQL databases:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些NoSQL数据库的关键特性：
- en: Entities do not necessarily need to support a fixed schema and, at any point
    in time, additional properties can be added.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体不一定需要支持固定的模式，并且在任何时间点都可以添加额外的属性。
- en: They are a good fit for unstructured data, for example, storing the location
    in a ride-sharing app.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常适合非结构化数据，例如，在共享出行应用中存储位置。
- en: They can easily support horizontal scaling at a much lower cost compared to
    relational databases.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以以比关系型数据库低得多的成本轻松支持水平扩展。
- en: Data is highly redundant; however, that gives a significant performance boost,
    as data is readily available without performing joins across tables.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据高度冗余；然而，这提供了显著的性能提升，因为数据可以随时使用，而无需在表之间执行连接操作。
- en: Azure Cosmos DB is one such cloud-managed NoSQL database that we will use in
    our e-commerce application as a data store.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB是我们将在我们的电子商务应用程序中用作数据存储的一种云管理的NoSQL数据库。
- en: Let's look at the various storage options in detail in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中详细查看各种存储选项。
- en: SQL, Azure Cosmos DB, and Azure Storage
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL、Azure Cosmos DB和Azure Storage
- en: Earlier, we talked about the broader classification of data stores into RDBMSs
    and NoSQL. In this section, let's get into the details of some of the data providers
    available in the Microsoft ecosystem and their integration with .NET 6\. There
    is a wide variety of providers, including SQL, Azure Cosmos DB, and Azure Storage,
    and the selection of data providers is completely driven by the application needs.
    However, in real life, application requirements evolve quite a bit, so the key
    is to abstract your data framework implementation with the business layer and
    **user interface** (**UI**), which further helps in evolving the design as required.
    With that, let's look at our first data provider, SQL, in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了将数据存储更广泛地分类为RDBMS和NoSQL。在本节中，让我们深入了解Microsoft生态系统中的一些数据提供者及其与.NET 6的集成。提供者的种类繁多，包括SQL、Azure
    Cosmos DB和Azure Storage，数据提供者的选择完全由应用程序需求驱动。然而，在现实生活中，应用程序需求变化很大，因此关键是使用业务层和**用户界面**（**UI**）来抽象数据框架实现，这有助于根据需要演进设计。有了这个，让我们在下一节中看看我们的第一个数据提供者，SQL。
- en: SQL Server
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL Server
- en: One of the dominant databases in the RDBMS market is Microsoft SQL Server, popularly
    known as SQL Server, which uses SQL to interact with the database. SQL Server
    supports all the RDBMS-based entities, such as tables, views, stored procedures,
    and indexes, and primarily works on the Windows environment. However, from SQL
    Server 2017 onward, it supports both Windows and Linux environments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在RDBMS市场中占主导地位的一个数据库是微软的SQL Server，通常被称为SQL Server，它使用SQL与数据库交互。SQL Server支持所有基于RDBMS的实体，如表、视图、存储过程和索引，并且主要在Windows环境中运行。然而，从SQL
    Server 2017开始，它支持Windows和Linux环境。
- en: 'The primary component of SQL Server is its database engine, which takes care
    of processing queries and managing data in files. Apart from the database engine,
    SQL Server comes with various data management tools, such as the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server的主要组件是其数据库引擎，负责处理查询和管理文件中的数据。除了数据库引擎之外，SQL Server还附带各种数据管理工具，如下所示：
- en: '**SQL Server Management Studio** (**SSMS**): To connect to SQL Server and perform
    operations such as creating a database, monitoring a database, querying databases,
    and backing up databases'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Server管理工具**（**SSMS**）：用于连接到SQL Server并执行创建数据库、监控数据库、查询数据库和备份数据库等操作'
- en: '**SQL Server Integration Service** (**SSIS**): For data integration and transformation'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Server集成服务**（**SSIS**）：用于数据集成和转换'
- en: '**SQL Server Analysis Services** (**SSAS**): For data analysis'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Server分析服务**（**SSAS**）：用于数据分析'
- en: '**SQL Server Reporting Services** (**SSRS**): For reporting and visualization'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Server报表服务**（**SSRS**）：用于报表和可视化'
- en: To configure SQL Server on a local machine, we need to install one of the editions
    of SQL Server that installs the database engine and one or more preceding components.
    Installation typically involves downloading the installer and installing it either
    through the **graphical user interface** (**GUI**) or command line. For more details
    on installation, refer to [https://docs.microsoft.com/en-us/sql/database-engine/install-windows/install-sql-server?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/database-engine/install-windows/install-sql-server?view=sql-server-ver15).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地计算机上配置SQL Server，我们需要安装SQL Server的一个版本，该版本安装数据库引擎和一个或多个先前组件。安装通常涉及下载安装程序并通过**图形用户界面**（**GUI**）或命令行进行安装。有关安装的更多详细信息，请参阅[https://docs.microsoft.com/en-us/sql/database-engine/install-windows/install-sql-server?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/database-engine/install-windows/install-sql-server?view=sql-server-ver15)。
- en: Tip
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are also other editions of SQL Server such as the Developer edition and
    Express edition, which are lightweight and free and can be downloaded from [https://www.microsoft.com/en-in/sql-server/sql-server-downloads](https://www.microsoft.com/en-in/sql-server/sql-server-downloads).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server还有其他版本，如开发者版和Express版，这些版本轻量级且免费，可以从[https://www.microsoft.com/en-in/sql-server/sql-server-downloads](https://www.microsoft.com/en-in/sql-server/sql-server-downloads)下载。
- en: Although on-premises, SQL Server has been widely used; there is always overhead
    to managing databases, upgrades, and so on, and that's where Microsoft has come
    up with Azure SQL, which is a fully managed **Platform as a Service** (**PaaS**)
    component that runs on the same database engine as on-premises SQL Server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQL Server在本地环境中已被广泛使用，但管理数据库、升级等始终存在开销，这就是微软推出了Azure SQL的原因，它是一个完全托管的**平台即服务**（**PaaS**）组件，在相同的数据库引擎上运行，就像本地SQL
    Server一样。
- en: 'Azure SQL comes with the following variants:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Azure SQL提供了以下变体：
- en: '**Azure SQL Database (single database)**: This is a managed database server
    that allows you to create a fully isolated database with dedicated resources.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure SQL数据库（单数据库）**：这是一个托管数据库服务器，允许您创建一个完全隔离的数据库，并拥有专用资源。'
- en: '**Azure SQL Database (elastic pool)**: Elastic pool allows you to run multiple
    single databases in a predefined pool of resources (in terms of CPU, memory, and
    **input/output** (**I/O**)) on a single server. It is ideal for businesses that
    have multiple databases with a mix of low and high usage. The advantage of using
    an elastic pool in such situations is that a database that needs more CPU usage
    can utilize it during high demand and release it when demand is low. The ideal
    situation to use an elastic pool is when there is a set of databases and their
    consumption is unpredictable. Anytime you see a database consistently consuming
    the same set of resources, it can be moved out of the elastic pool into a single
    database and vice versa.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure SQL数据库（弹性池）**：弹性池允许您在单个服务器上运行多个单数据库，这些数据库位于预定义的资源池中（就CPU、内存和**输入/输出**（**I/O**）而言）。这对于拥有多个数据库且使用量高低不一的企业来说非常理想。在这种情况下使用弹性池的优势在于，需要更多CPU使用的数据库可以在需求高峰时使用它，在需求低时释放它。使用弹性池的理想情况是，有一组数据库，其消耗量不可预测。任何时候，如果您看到数据库持续消耗相同的一组资源，它可以从弹性池移动到一个单独的数据库，反之亦然。'
- en: '**Azure SQL Managed Instance**: This model provides a way for the seamless
    migration of on-premises SQL infrastructure to Azure SQL without re-architecting
    the on-premises applications and allows you to take advantage of PaaS. This is
    ideal for applications that have huge on-premises database infrastructure and
    need to migrate to the cloud without too much operational overhead.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure SQL托管实例**：此模型提供了一种无缝迁移本地SQL基础设施到Azure SQL的方法，无需重新架构本地应用程序，并允许您利用平台即服务（PaaS）。这对于拥有庞大的本地数据库基础设施并需要迁移到云而无需太多运营开销的应用程序来说非常理想。'
- en: '**SQL Server on VM (Windows/Linux)**: SQL VMs come under the **Infrastructure
    as a Service** (**IaaS**) category and are very similar to on-premises SQL Server,
    except that VMs are on Azure instead of your local network.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机上的 SQL Server (Windows/Linux)**：SQL 虚拟机属于 **基础设施即服务**（**IaaS**）类别，与本地
    SQL Server 非常相似，只是虚拟机位于 Azure 而不是您的本地网络中。'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's recommended to install SSMS for performing various operations on SQL Server
    (on-premises or the cloud), as it supports all the database operations. There
    is also Azure Data Studio, which is lightweight and can connect to on-premise
    or cloud SQL Server and can be downloaded from [https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15).
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议安装 SSMS 以执行 SQL Server（本地或云）的各种操作，因为它支持所有数据库操作。还有 Azure Data Studio，它轻量级，可以连接到本地或云
    SQL Server，并且可以从 [https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15)
    下载。
- en: From a .NET 6 application standpoint, connecting to Azure SQL is the same as
    connecting to on-premises SQL Server. You can use ADO.NET, which we import using
    `System.Data.SqlClient` and then use the `SqlConnection` object to connect to
    SQL; then, use the `SqlCommand` object to execute the SQL query and the `SQLReader`
    class to return the values. Apart from this, we can use an **object-relational
    mapping** (**ORM**) such as **Entity Framework Core** (**EF Core**) to work with
    Azure SQL, which is discussed in the *Working with EF Core* section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 6 应用程序的角度来看，连接到 Azure SQL 与连接到本地 SQL Server 相同。您可以使用 ADO.NET，我们通过 `System.Data.SqlClient`
    导入它，然后使用 `SqlConnection` 对象连接到 SQL；然后，使用 `SqlCommand` 对象执行 SQL 查询，并使用 `SQLReader`
    类返回值。除此之外，我们还可以使用 **对象关系映射**（**ORM**）例如 **Entity Framework Core**（**EF Core**）来与
    Azure SQL 一起工作，这在 *使用 EF Core* 部分中进行了讨论。
- en: 'So, in this section, we have briefly covered Azure SQL. However, I would recommend
    reviewing all the functionality of Azure SQL here: [https://docs.microsoft.com/en-us/azure/azure-sql/](https://docs.microsoft.com/en-us/azure/azure-sql/).
    For more samples please refer to [https://github.com/microsoft/sql-server-samples](https://github.com/microsoft/sql-server-samples).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们简要介绍了 Azure SQL。然而，我建议在这里查看 Azure SQL 的所有功能：[https://docs.microsoft.com/en-us/azure/azure-sql/](https://docs.microsoft.com/en-us/azure/azure-sql/)。更多示例请参阅
    [https://github.com/microsoft/sql-server-samples](https://github.com/microsoft/sql-server-samples)。
- en: With this, let's move on to Azure Cosmos DB, the database our e-commerce application
    will use as a persistent store.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续了解 Azure Cosmos DB，这是我们电子商务应用将用作持久存储的数据库。
- en: Azure Cosmos DB
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Cosmos DB
- en: Azure Cosmos DB is a fully managed (PaaS) NoSQL, globally distributed, and highly
    scalable database. One of the key things about Azure Cosmos DB is its multi-modeled
    nature, which helps in passing data in various formats, such as JSON and BSON,
    using different API models, such as SQL, MongoDB, and Gremlin. Developers have
    the flexibility to query the database using the API they are comfortable with.
    For example, SQL developers can continue to query the database using SQL query
    syntax, MongoDB developers can continue to query the database using MongoDB syntax,
    and so on. Under the hood, Azure Cosmos DB stores the database in a format known
    as **atom-record-sequence** (**ARS**) and exposes data as an API depending on
    the mode selected during the creation of the database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB 是一个完全托管的（PaaS）NoSQL、全球分布式的、高度可扩展的数据库。Azure Cosmos DB 的一个关键特性是其多模型特性，这有助于使用不同的
    API 模型，如 SQL、MongoDB 和 Gremlin，以不同的格式传递数据，例如 JSON 和 BSON。开发者可以根据自己的舒适度使用 API 来查询数据库。例如，SQL
    开发者可以继续使用 SQL 查询语法查询数据库，MongoDB 开发者可以继续使用 MongoDB 语法查询数据库，等等。在底层，Azure Cosmos
    DB 以称为 **原子记录序列**（**ARS**）的格式存储数据库，并根据在创建数据库时选择的模式暴露数据作为 API。
- en: Another important thing about Azure Cosmos DB is its capability to automatically
    index all the data, independent of the API model that is used. All this happens
    without developers additionally creating an index, so enabling the faster retrieval
    of data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB 的另一个重要特性是其能够自动索引所有数据，而不管使用的是哪种 API 模型。所有这些操作都无需开发者额外创建索引，从而实现数据的快速检索。
- en: 'Azure Cosmos DB supports the following APIs to perform operations on the database,
    which we choose while creating the database:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB 支持以下 API 来执行数据库操作，我们在创建数据库时选择这些 API：
- en: '`SELECT * FROM product WHERE product.Name = '' Mastering enterprise application
    development Book''`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT * FROM product WHERE product.Name = ''Mastering enterprise application
    development Book''`。'
- en: '`db.product.find({"Name": '' Mastering enterprise application development Book''})`.
    Just like MongoDB, data is represented in BSON.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.product.find({"Name": ''Mastering enterprise application development Book''})`。就像
    MongoDB 一样，数据以 BSON 表示。'
- en: '**Gremlin (graph) API**: This API supports using the Gremlin language to query
    and traverse data in graph format. This is ideal for situations where data can
    be represented in the form of a graph and can be queried through their relationships.
    A typical example can be a recommendation engine that can establish the relationship
    between two entities and come up with a recommendation.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gremlin（图）API**：此 API 支持使用 Gremlin 语言查询和遍历以图格式表示的数据。这在数据可以表示为图形式并通过其关系进行查询的情况下非常理想。一个典型的例子是一个推荐引擎，它可以建立两个实体之间的关系并提出推荐。'
- en: Apart from these, there is the Cassandra API, which uses the **Cassandra Query
    Language** (**CQL**) to operate on databases, and then the Table API, which can
    be used by applications built on top of Azure Table storage as their data store.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 Cassandra API，它使用**Cassandra 查询语言**（**CQL**）在数据库上操作，然后是 Table API，它可以用作构建在
    Azure 表存储之上的应用程序的数据存储。
- en: 'As you can see, there are quite a number of APIs and more are getting added.
    Choosing the right API depends purely on the application requirements; however,
    the following few points can be used to narrow down the choice:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有相当多的 API，并且还有更多正在添加。选择正确的 API 完全取决于应用程序需求；然而，以下几点可以用来缩小选择范围：
- en: If it's a new application, go with the Core (SQL) API.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是新的应用程序，请选择核心（SQL）API。
- en: If it's an existing application built on NoSQL, choose the relevant API based
    on the underlying data store. For example, if the existing database is MongoDB,
    choose the Mongo API, and so on.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个基于 NoSQL 的现有应用程序，请根据底层数据存储选择相关的 API。例如，如果现有数据库是 MongoDB，请选择 Mongo API
    等。
- en: For handling a specific scenario, such as establishing relationships between
    data, go with the Gremlin API.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于处理特定场景，例如建立数据之间的关系，请使用 Gremlin API。
- en: For our enterprise application, since we are building this application from
    scratch, we will go with the Core (SQL) API as our API to interact with Azure
    Cosmos DB.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的企业应用程序，由于我们是从头开始构建此应用程序的，因此我们将选择核心（SQL）API 作为与 Azure Cosmos DB 交互的 API。
- en: 'Let''s create a simple console application to start with and perform a few
    operations on Azure Cosmos DB, and we will later reuse these concepts in building
    our Data Access service:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的控制台应用程序开始，并在 Azure Cosmos DB 上执行一些操作，我们稍后将在构建我们的数据访问服务时重用这些概念：
- en: To start with, we need to have an Azure Cosmos DB account, so sign in to the
    Azure portal, click **Create resource**, and select **Databases** | **Azure Cosmos
    DB**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要有一个 Azure Cosmos DB 账户，因此登录到 Azure 门户，点击**创建资源**，然后选择**数据库** | **Azure
    Cosmos DB**。
- en: 'This will open the **Create Azure Cosmos DB Account** page. Fill in the details
    as shown in the following screenshot and click **Review + create**. This is the
    page where we select the API we want to choose, which is the Core (SQL) API in
    our case:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开**创建 Azure Cosmos DB 账户**页面。填写以下截图所示的详细信息，然后点击**审查 + 创建**。这是我们选择要选择的 API
    的页面，在我们的情况下是核心（SQL）API：
- en: '![Figure 9.2 – Create Azure Cosmos DB Account page'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 创建 Azure Cosmos DB 账户页面](img/Figure_9.2_18507.jpg)'
- en: '](img/Figure_9.2_18507.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.2_18507.jpg)'
- en: Figure 9.2 – Create Azure Cosmos DB Account page
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 创建 Azure Cosmos DB 账户页面
- en: Once the account is created, navigate to **Azure Cosmos DB Account** | **Keys**.
    Copy the **URI** and **PRIMARY KEY** values.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户创建完成后，导航到**Azure Cosmos DB 账户** | **密钥**。复制**URI**和**PRIMARY KEY**值。
- en: 'Open the command line and create a console application by using the following
    command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行，使用以下命令创建控制台应用程序：
- en: '[PRE19]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Navigate to the `EcommerceSample` folder and install the Azure Cosmos DB SDK
    using the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `EcommerceSample` 文件夹，并使用以下命令安装 Azure Cosmos DB SDK：
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this stage, we can open the folder in VS Code. Once we open the folder in
    VS Code, it will look as shown in the following screenshot:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，我们可以将文件夹在 VS Code 中打开。一旦我们在 VS Code 中打开文件夹，它将看起来如下所示：
- en: '![Figure 9.3 – EcommerceSample in VS Code'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – VS Code 中的 EcommerceSample](img/Figure_9.3_18507.jpg)'
- en: '](img/Figure_9.3_18507.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.3_18507.jpg)'
- en: Figure 9.3 – EcommerceSample in VS Code
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – VS Code 中的 EcommerceSample
- en: 'Open `Program.cs` and add the following static variables to the `Program` class
    that will hold the **URI** and **PRIMARY KEY** values that were copied in *Step
    3*:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 文件，并将以下静态变量添加到 `Program` 类中，这些变量将保存 *步骤 3* 中复制的 **URI** 和 **主键**
    值：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s add code to create an object of the `CosmosClient` class and use
    that to create an Azure Cosmos DB database. Subsequently, this object will be
    used to communicate with our Azure Cosmos DB database. As `CosmosClient` implements
    `IDisposable`, we will create it inside a `using` block so that the object can
    be disposed of automatically after the `using` block. Once you run this code and
    navigate to `Ecommerce` will be created. As we have created our Azure Cosmos DB
    account using the Core (SQL) API, this database will support querying in SQL syntax:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加代码来创建 `CosmosClient` 类的实例，并使用它来创建 Azure Cosmos DB 数据库。随后，此对象将被用于与我们的
    Azure Cosmos DB 数据库进行通信。由于 `CosmosClient` 实现了 `IDisposable` 接口，我们将在 `using` 块内创建它，以便对象可以在
    `using` 块之后自动释放。一旦运行此代码并导航到 `Ecommerce`，就会创建数据库。由于我们使用 Core (SQL) API 创建了 Azure
    Cosmos DB 账户，因此此数据库将支持使用 SQL 语法进行查询：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s create a container that is analogous to a table in SQL by adding
    the following code after `createDatabaseResponse`. As we are using `CreateDatabaseIfNotExistsAsync`
    to create the database, running the same code will not cause any exceptions:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `createDatabaseResponse` 之后添加代码来创建一个类似于 SQL 表的容器。由于我们正在使用 `CreateDatabaseIfNotExistsAsync`
    来创建数据库，运行相同的代码不会引发任何异常：
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we run this code, we can see in the Azure portal that a container with
    the name `Products` is created under the `Ecommerce` database:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行此代码，我们可以在 Azure 门户中看到在 `Ecommerce` 数据库下创建了一个名为 `Products` 的容器：
- en: '![Figure 9.4 – Products container'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 产品容器'
- en: '](img/Figure_9.4_18507.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_18507.jpg)'
- en: Figure 9.4 – Products container
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 产品容器
- en: A container is a unit in Azure Cosmos DB that is horizontally partitioned and
    replicated across multiple regions. In the preceding code, we have passed `ContainerProperties`
    while creating a container, and you can see that one of the values is `Name`,
    which is nothing but a partition key.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是 Azure Cosmos DB 中的一个单元，它在多个区域中进行水平分区和复制。在前面的代码中，我们在创建容器时传递了 `ContainerProperties`，你可以看到其中一个值是
    `Name`，这实际上就是一个分区键。
- en: Partitioning is one of the key features of Azure Cosmos DB that segregates data
    within a container into multiple logical partitions based on the partition key,
    that is, all the items with the same partition key are part of the same logical
    partition. Using a partition key, Azure Cosmos DB achieves horizontal scaling
    of the database, therefore, satisfying the scalability and performance needs of
    the application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是 Azure Cosmos DB 的一个关键特性，它根据分区键将容器内的数据分割成多个逻辑分区，即具有相同分区键的所有项都属于同一个逻辑分区。使用分区键，Azure
    Cosmos DB 实现了数据库的水平扩展，因此满足了应用程序的可扩展性和性能需求。
- en: 'Choosing a partition key is a key design decision, as it will significantly
    help the database to scale and better perform. Also, the partition key cannot
    be changed and has to be defined during the creation of the container. The following
    few points can be kept in mind when choosing the partition key:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 选择分区键是一个关键的设计决策，因为它将极大地帮助数据库进行扩展并提高性能。此外，分区键不能更改，必须在创建容器时定义。在选择分区键时，以下几点可以牢记在心：
- en: It should have a maximum number of unique values; the higher the number of unique
    values, the better the partitioning will be. For example, if we are creating a
    container for products, the product ID or name could be the partition key as these
    two attributes can uniquely identify most products. Under the hood, if a product
    name is chosen for the partition key and there are 100 products internally, it
    is represented by 100 logical containers in Azure Cosmos DB. Here, the product
    category can also be a partition key but, before choosing that as the partition
    key, we need to evaluate the sample data and decide based on the requirements.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该具有最大数量的唯一值；唯一值的数量越多，分区效果越好。例如，如果我们正在创建一个用于产品的容器，产品 ID 或名称可以作为分区键，因为这两个属性可以唯一标识大多数产品。在底层，如果选择产品名称作为分区键，并且内部有
    100 个产品，那么在 Azure Cosmos DB 中将表示为 100 个逻辑容器。在这里，产品类别也可以作为分区键，但在将其作为分区键选择之前，我们需要评估样本数据并根据需求做出决定。
- en: If there is no obvious unique choice, we can pick the most used field in the
    filtering query, so basically, a column that is very often used in the `where`
    clause.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有明显的唯一选择，我们可以选择在过滤查询中最常用的字段，所以基本上是一个在`where`子句中经常使用的列。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: In real-world applications, the creation of an Azure Cosmos DB account should
    be implemented using ARM templates or using Terraform so that templates can be
    easily integrated with **continuous deployment** (**CD**).
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际应用中，创建 Azure Cosmos DB 账户应使用 ARM 模板或使用 Terraform 实现，这样模板可以轻松地与**持续部署**（**CD**）集成。
- en: 'With this, let''s add some data to our product container and query it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，让我们向我们的产品容器添加一些数据并查询它：
- en: We will add this entity based on the following sample JSON. Based on the product
    category, there could be different attributes.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将根据以下示例 JSON 添加此实体。根据产品类别，可能会有不同的属性。
- en: 'For example, if the product category is `Books`, there would be values in fields
    such as `Authors` and `Format`; however, if the category is `Clothing`, there
    would be values for fields such as `Size` and `Color`. This schema could be reused
    in our e-commerce application:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果产品类别是`Books`，则`Authors`和`Format`等字段中会有值；然而，如果类别是`Clothing`，则`Size`和`Color`等字段会有值。这种模式可以在我们的电子商务应用程序中重用：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s create `Product`. One of the mandatory fields for any entity in
    Azure Cosmos DB with the Core (SQL) API is the `id` field, which is something
    like a primary key. So, it is necessary for our parent models to define the `id`
    field. These classes would look like the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Product`。在 Azure Cosmos DB 的 Core (SQL) API 中，任何实体的必填字段之一是`id`字段，它类似于主键。因此，对于我们的父模型来说，定义`id`字段是必要的。这些类看起来如下所示：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s create the following object of the `Product` class and insert it
    into the database:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建以下`Product`类的对象并将其插入到数据库中：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we will call the `CreateItemAsync` method using the `productContainer`
    object, as shown in the following code snippet. (There are other ways to retrieve
    records from the database, one of which is shown in the next point.) Also, we
    should ensure that an object with the same `ProductId` value isn''t already present:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`productContainer`对象调用`CreateItemAsync`方法，如下面的代码片段所示。（还有其他从数据库检索记录的方法，其中一种将在下一点中展示。）我们还应该确保没有已经存在具有相同`ProductId`值的对象：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once we run this code, data should be inserted into the `Ecommerce` database
    under the `Products` container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行此代码，数据应该会被插入到`Ecommerce`数据库下的`Products`容器中。
- en: 'If we want to query this record other than the way mentioned in the previous
    point, we can use the following code to query the database. As you can see, the
    syntax is very similar to querying data from a SQL database:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要以不同于前一点提到的方式查询此记录，我们可以使用以下代码来查询数据库。正如您所看到的，语法与从 SQL 数据库查询数据非常相似：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, `ContainerClass` provides all the relevant methods that can be used
    for various CRUD operations. All those APIs can be found here: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container?view=azure-dotnet](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container?view=azure-dotnet).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`ContainerClass`提供了可用于各种 CRUD 操作的所有相关方法。所有这些 API 都可以在以下位置找到：[https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container?view=azure-dotnet](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container?view=azure-dotnet)。
- en: With this foundation, we will design the data model required for our e-commerce
    application and the relevant data service layer to be consumed by various APIs.
    Up to now, we have seen SQL and NoSQL providers. Let's see what other options
    we have to persist data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，我们将设计电子商务应用程序所需的数据模型和相关数据服务层，以便由各种 API 使用。到目前为止，我们已经看到了 SQL 和 NoSQL 提供商。让我们看看我们还有哪些其他选项来持久化数据。
- en: Azure Storage
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 存储
- en: 'Azure Storage is a highly available and scalable data store that supports storing
    data in various formats, including files. Primarily, Azure Storage supports the
    following four types of data:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Storage 是一个高度可用和可扩展的数据存储，支持以各种格式存储数据，包括文件。主要来说，Azure Storage 支持以下四种类型的数据：
- en: '**Azure Table**: A NoSQL implementation that supports persisting schemaless
    data.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Table**：一种支持持久化无模式数据的 NoSQL 实现。'
- en: '**Azure Blob**: Blobs are unstructured data that are suitable for applications
    that have lots of files to upload, download, or stream.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Blob**：Blob 是适合于需要上传、下载或流式传输大量文件的未结构化数据。'
- en: '**Azure Queue**: This allows you to queue a message in any serializable format
    and can then be processed by a service. Queues are ideal for scenarios that have
    lots of service-to-service communication and act as a persistent layer for messages.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 队列**：这允许您以任何可序列化的格式排队消息，然后由服务进行处理。队列非常适合具有大量服务间通信的场景，并作为消息的持久层。'
- en: '**Azure Files/Azure Disk**: A data store for files and ideal for systems that
    are built on native file APIs.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 文件/Azure 磁盘**：一个文件数据存储，非常适合基于本地文件 API 构建的系统。'
- en: 'The following are a few points that make Azure Storage one of the important
    components of application development:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使 Azure 存储成为应用程序开发重要组件的几个要点：
- en: '**High availability**: Data stored in Azure Storage gives out-of-the-box support
    for replication across data centers/regions, which further ensures that hardware
    failure in one region doesn''t result in losing data.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：存储在 Azure 存储中的数据提供了数据中心/区域之间的复制支持，这进一步确保了某个区域的硬件故障不会导致数据丢失。'
- en: '**Performance**: Out-of-the-box support for CDN integration that helps to cache
    and load data (especially static files) from locations (edge servers) closer to
    the user and further improves the performance. In addition to this, the storage
    type can be upgraded to premium storage, which takes advantage of SSDs to further
    speed up disk I/O and improve performance.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：开箱即用的 CDN 集成支持，有助于从更靠近用户的位置（边缘服务器）缓存和加载数据（尤其是静态文件），从而进一步提高性能。此外，存储类型可以升级到高级存储，利用
    SSD 进一步加快磁盘 I/O 并提高性能。'
- en: '**Fully managed**: Hardware is fully managed by Azure for any updates/maintenance.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全托管**：硬件由 Azure 完全管理，包括任何更新/维护。'
- en: '**Security**: All the data stored on disks is encrypted and access to the data
    in Azure Storage further supports private, public, and anonymous modes.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：所有存储在磁盘上的数据都进行了加密，Azure 存储中对数据的访问进一步支持私有、公共和匿名模式。'
- en: '**Pay as you go**: Just like all other Azure services, Azure Storage also supports
    a pay-as-you-go model based on the size of the data/operations.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按量付费**：与所有其他 Azure 服务一样，Azure 存储也支持基于数据量/操作的按量付费模式。'
- en: Azure Storage accounts
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure 存储帐户
- en: 'Let''s create a simple console application that uploads a file to Blob and
    downloads the file from Blob. To communicate with Azure Storage services, the
    prerequisite is to create an Azure Storage account that provides access to all
    Azure Storage services and gives us access to the data stored in Azure Storage
    over HTTP/HTTPS by a unique namespace to Azure Storage. To create an Azure Storage
    account, take the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的控制台应用程序，将文件上传到 Blob 并从 Blob 下载文件。要与 Azure 存储服务通信，先决条件是创建一个 Azure 存储帐户，该帐户提供对所有
    Azure 存储服务的访问，并通过一个唯一的命名空间让我们能够通过 HTTP/HTTPS 访问 Azure 存储中存储的数据。要创建 Azure 存储帐户，请执行以下步骤：
- en: 'Sign in to the Azure portal, click **Create resource**, and select **Storage
    Account**. This will open the **Create storage account** page. Fill in the details
    as shown in the following screenshot and click **Review + create**:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 Azure 门户，点击**创建资源**，然后选择**存储帐户**。这将打开**创建存储帐户**页面。填写以下屏幕截图中显示的详细信息，然后点击**审查
    + 创建**：
- en: '![Figure 9.5 – Creating an Azure Storage account'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 创建 Azure 存储帐户'
- en: '](img/Figure_9.5_18507.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.5_18507.jpg)'
- en: Figure 9.5 – Creating an Azure Storage account
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 创建 Azure 存储帐户
- en: 'There are two important properties **Account Kind** and **Replication** for
    Standard tier. For **Account Kind****,** we have the following possible values:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准层，有两个重要属性**帐户类型**和**复制**。对于**帐户类型**，我们有以下可能的值：
- en: '**StorageV2 (general purpose v2)**: The latest version of the account type,
    which gives access to all storage types, such as files, blobs, and queues. This
    is preferable for newly created storage accounts.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StorageV2（通用 v2）**：帐户类型的最新版本，提供对所有存储类型的访问，例如文件、块和队列。这对于新创建的存储帐户来说更可取。'
- en: '**Storage (general purpose v1)**: An older version of the account type, which
    gives access to all storage types, such as files, blobs, and queues.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储（通用 v1）**：帐户类型的较旧版本，提供对所有存储类型的访问，例如文件、块和队列。'
- en: '**BlobStorage**: An account type that only supports blob storage.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BlobStorage**：仅支持 blob 存储的帐户类型。'
- en: 'The other is **Replication**, which supports replication of the storage data
    across data centers/regions. Possible values are shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是**复制**，它支持在数据中心/区域之间复制存储数据。可能的值在以下屏幕截图中显示：
- en: '![Figure 9.6 – Replication options in an Azure Storage account'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – Azure存储账户中的复制选项'
- en: '](img/Figure_9.6_18507.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.6_18507.jpg)'
- en: Figure 9.6 – Replication options in an Azure Storage account
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – Azure存储账户中的复制选项
- en: Once the account is created, navigate to **Storage Account** | **Keys**. Copy
    the **Connection String** value.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建账户，导航到**存储账户** | **密钥**。复制**连接字符串**值。
- en: Create a new .NET 6 console application and install the `Azure.Storage.Blobs`
    NuGet package.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的.NET 6控制台应用程序并安装`Azure.Storage.Blobs` NuGet包。
- en: 'To upload content to Azure Storage, we need to first create a container. We
    will make use of the `Azure.Storage.Blobs.BlobContainerClient` class and its `CreateIfNotExistsAsync`
    method to create the container if it doesn''t exist. With this, update the `Program`
    class, as shown in the following code snippet:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将内容上传到Azure存储，我们首先需要创建一个容器。我们将使用`Azure.Storage.Blobs.BlobContainerClient`类及其`CreateIfNotExistsAsync`方法来创建容器（如果不存在）。有了这个，更新`Program`类，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to upload the file to the container for which we will make use
    of `Azure.Storage.Blobs.BlobClient`, which takes the connection string, container
    name, and blob name as input parameters. For this sample, we are uploading a local
    `sample.png` file to the blob, which we will read using the `FileStream` class,
    and pass it to the `UploadAsync` method of the `Azure.Storage.Blobs.BlobClient`
    class. Add the following code snippet after container creation in the `Main` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将文件上传到容器，我们将使用`Azure.Storage.Blobs.BlobClient`，它接受连接字符串、容器名称和blob名称作为输入参数。对于此示例，我们将上传一个本地的`sample.png`文件到blob，我们将使用`FileStream`类读取它，并将其传递给`Azure.Storage.Blobs.BlobClient`类的`UploadAsync`方法。在`Main`方法中容器创建后添加以下代码片段：
- en: '[PRE30]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running the sample at this stage will upload the file to the blob and display
    the blob URL in the command line. However, if we try to access the URL, it won''t
    be accessible as the blob created is private. To access private blobs, we need
    to generate a `Main` method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段运行示例将文件上传到blob，并在命令行中显示blob URL。然而，如果我们尝试访问URL，由于创建的blob是私有的，它将无法访问。要访问私有blob，我们需要生成一个`Main`方法：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we are using the `Azure.Storage.Sas.BlobSasBuilder` class to configure
    various parameters, such as permissions and the expiry time, to generate a SAS
    URI for the uploaded file. Finally, the output of the preceding code is shown
    in the following figure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Azure.Storage.Sas.BlobSasBuilder`类来配置各种参数，例如权限和过期时间，以生成上传文件的SAS URI。最后，前面代码的输出如下所示：
- en: '![Figure 9.7 – Blob upload output and Storage Explorer'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – Blob上传输出和存储资源管理器'
- en: '](img/Figure_9.7_18507.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_18507.jpg)'
- en: Figure 9.7 – Blob upload output and Storage Explorer
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – Blob上传输出和存储资源管理器
- en: This is a small sample that makes use of Azure Storage for a file upload. This
    can be further enhanced as an API, which can eventually be used for file upload
    and download scenarios. For our e-commerce application, we will use Azure Blob
    to store the images of the products.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Azure Storage进行文件上传的小示例。这可以进一步扩展为一个API，最终可用于文件上传和下载场景。对于我们的电子商务应用程序，我们将使用Azure
    Blob来存储产品的图片。
- en: Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more advanced concepts on Azure Storage and samples, refer to the following
    links:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Azure存储的更高级概念和示例，请参考以下链接：
- en: '[https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview](https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview](https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview)'
- en: '[https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/storage/Azure.Storage.Blobs/samples](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/storage/Azure.Storage.Blobs/samples)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/storage/Azure.Storage.Blobs/samples](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/storage/Azure.Storage.Blobs/samples)'
- en: In this section, we have discussed various data providers available in .NET
    6\. However, one important library that simplifies persisting data is EF. Let's
    see how to integrate EF in .NET 6 applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了.NET 6中可用的各种数据提供者。然而，一个简化数据持久化的重要库是EF。让我们看看如何在.NET 6应用程序中集成EF。
- en: Working with EF Core
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EF Core
- en: EF Core is an ORM that is recommended for any ASP.NET Core 6 application that
    uses a relational database as the data store. Earlier, we saw how in ADO.NET,
    we must create `Connection`, `Command`, and `Reader` objects. EF simplifies this
    process by providing abstraction and allowing developers to write application
    code, and like any other ORM, EF helps in performing various operations on databases
    using the object model paradigm.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core是一个ORM，它被推荐用于任何使用关系数据库作为数据存储的ASP.NET Core 6应用程序。之前，我们看到了在ADO.NET中，我们必须创建`Connection`、`Command`和`Reader`对象。EF通过提供抽象并允许开发者编写应用程序代码来简化这个过程，并且像任何其他ORM一样，EF帮助开发者使用对象模型范式在数据库上执行各种操作。
- en: Configuring EF Core is as simple as installing the required NuGet packages,
    injecting the required services in the `Program` class, and then using them wherever
    required. As part of this process, one of the key classes that needs to be defined
    is the database context, and that needs to inherit the `Microsoft.EntityFrameworkCore.DbContext`
    class. Let's see how we do that along with the remaining EF Core configuration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 配置EF Core就像安装所需的NuGet包，在`Program`类中注入所需的服务，然后在需要的地方使用它们。在这个过程中，需要定义的一个关键类是数据库上下文，它需要继承`Microsoft.EntityFrameworkCore.DbContext`类。让我们看看我们如何做到这一点，以及剩余的EF
    Core配置。
- en: Configuration and querying
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和查询
- en: 'The `DbContext` class in EF Core holds all the required abstraction for our
    application to communicate with the database, so a key setup that needs to be
    part of integrating EF Core is to define our application-specific context class.
    This class will primarily hold all the SQL tables/views in the form of public
    property of the `DbSet` type, as shown in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core中的`DbContext`类包含我们应用程序与数据库通信所需的所有抽象，因此集成EF Core的关键设置之一是定义我们的应用程序特定上下文类。这个类将主要以`DbSet`类型的公共属性的形式持有所有SQL表/视图，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `Employee` is the POCO class representing tables in our database. The
    application context class should have the parameterized constructor that accepts
    `DbContextOptions` or `DbContextOptions<T>` and passes it to the base class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Employee`是代表我们数据库中表的POCO类。应用程序上下文类应该有一个参数化构造函数，它接受`DbContextOptions`或`DbContextOptions<T>`并将其传递给基类。
- en: 'Let''s create a simple web application based on Razor Pages and SQLite, and
    read data using EF Core. For this sample, we will take a simple employee database
    that holds employee details with the following data model using SQLite:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于Razor Pages和SQLite创建一个简单的Web应用程序，并使用EF Core读取数据。对于这个示例，我们将使用SQLite作为数据存储，选择一个简单的员工数据库，其中包含以下数据模型：
- en: '![Figure 9.8 – Employee database model'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – 员工数据库模型'
- en: '](img/Figure_9.8_18507.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.8_18507.jpg)'
- en: Figure 9.8 – Employee database model
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 员工数据库模型
- en: If you haven't worked in Razor Pages before, do not worry about that; it's a
    page-based framework that can be used to build data-driven applications in ASP.NET
    Core 6 and is covered in [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228),
    *Creating an ASP.NET Core 6 Web Application*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过Razor Pages，不要担心；它是一个基于页面的框架，可以用于在ASP.NET Core 6中构建数据驱动应用程序，并在[*第11章*](B18507_11_Epub.xhtml#_idTextAnchor1228)中介绍，即*创建ASP.NET
    Core 6 Web应用程序*。
- en: 'Now, let''s now create our application as mentioned in the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤创建我们的应用程序：
- en: 'Create a new Razor Pages application using the following command from the command
    line, which will create a new Razor Pages application inside the `EmployeeEF`
    folder:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从命令行创建一个新的Razor Pages应用程序，这将创建一个名为`EmployeeEF`的新Razor Pages应用程序：
- en: '[PRE33]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Navigate to the `EmployeeEF` folder and open it in Visual Studio Code, and
    then install the following NuGet packages:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`EmployeeEF`文件夹，并在Visual Studio Code中打开它，然后安装以下NuGet包：
- en: '`Microsoft.EntityFrameworkCore.Sqlite`'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.Sqlite`'
- en: '`Microsoft.EntityFrameworkCore.Design`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.Design`'
- en: The former package is the EF Core provider for SQLite and the latter one is
    to be used to create a database based on C# POCOs using EF Core migrations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个包是SQLite的EF Core提供程序，后一个包用于使用EF Core迁移创建基于C# POCOs的数据库。
- en: 'Now, add the `Models` folder and add the necessary POCO classes as follows.
    These classes represent the database schema from *Figure 9.8*:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`Models`文件夹，并按照以下方式添加必要的POCO类。这些类代表来自*图9.8*的数据库模式：
- en: '[PRE34]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, all the columns in the database table are represented as a property with
    relevant data types. For relationships such as a foreign key, a property of the
    child type is created (known as `ICollection`, while another property of the parent
    class type is created in the child class. For example, in the preceding code,
    this is represented in the `public Icollection<Address> Addresses` and `public
    Employee Employee` properties, which define the foreign key constraint between
    the `Employee` and `Address` tables. Any property named `ID` or `<class name>ID
    (EmployeeID)` is automatically considered a primary key. Constraints can be further
    defined using the Fluent API during `OnModelCreating` or using annotations in
    `System.ComponentModel.DataAnnotations`. For more examples and details on model
    creation, refer to [https://docs.microsoft.com/en-us/ef/core/modeling](https://docs.microsoft.com/en-us/ef/core/modeling).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，数据库表中的所有列都表示为具有相关数据类型的属性。对于如外键这样的关系，会在子类型中创建一个属性（称为 `ICollection`），同时在父类类型中创建另一个属性。例如，在前面的代码中，这通过
    `public Icollection<Address> Addresses` 和 `public Employee Employee` 属性表示，这些属性定义了
    `Employee` 和 `Address` 表之间的外键约束。任何名为 `ID` 或 `<class name>ID (EmployeeID)` 的属性都会自动被认为是主键。可以在
    `OnModelCreating` 期间使用 Fluent API 或在 `System.ComponentModel.DataAnnotations` 中使用注解进一步定义约束。有关模型创建的更多示例和详细信息，请参阅
    [https://docs.microsoft.com/en-us/ef/core/modeling](https://docs.microsoft.com/en-us/ef/core/modeling)。
- en: 'Add a class that inherits from `Microsoft.EntityFrameworkCore.DbContext` and
    name it `EmployeeContext`. Add the following code that defines our database context:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个继承自 `Microsoft.EntityFrameworkCore.DbContext` 的类，并将其命名为 `EmployeeContext`。添加以下代码以定义我们的数据库上下文：
- en: '[PRE35]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the connection string in `appsettings.json`. As we are using SQLite, specifying
    the filename in the data source should be good enough. However, this will change
    as per the provider:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `appsettings.json` 中添加连接字符串。由于我们使用 SQLite，指定数据源中的文件名应该足够。但是，这会根据提供程序而变化：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, inject the database context class in the `Program` class so that it is
    available across the application. Here, we additionally pass connection strings
    and configure any additional options such as a retry policy and query logging:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Program` 类中注入数据库上下文类，以便在整个应用程序中可用。在这里，我们还传递连接字符串并配置任何其他选项，例如重试策略和查询记录：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are almost done with the EF Core setup. So now, let's create some sample
    data that can be used to seed the database.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了 EF Core 的设置。因此，现在让我们创建一些可以用于填充数据库的示例数据。
- en: 'For that, we will create an extension method on our database context and call
    it during startup. Create a `DbContextExtension` static class and add the following
    code to it. This code does nothing but add a few records to the database:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将在我们的数据库上下文中创建一个扩展方法并在启动时调用它。创建一个名为 `DbContextExtension` 的静态类，并向其中添加以下代码。此代码只是向数据库中添加一些记录：
- en: '[PRE38]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Open the `Program` class and add the following code that seeds data during
    application startup. Since this is for a development environment, we can check
    whether the environment is a development one and add it. As we are checking what''s
    on the employee table before inserting, multiple runs of the application will
    not overwrite the data:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program` 类并添加以下代码，该代码在应用程序启动时填充数据。由于这是开发环境，我们可以检查环境是否为开发环境并添加它。由于我们在插入之前检查员工表中的内容，因此应用程序的多次运行不会覆盖数据：
- en: '[PRE39]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, run `dotnet build` in the VS Code terminal and fix any build errors. To
    generate a database from our models and populate the database, we need to install
    `dotnet-ef` either locally or globally and run the migration commands, as follows,
    in the VS Code terminal, which would generate the `Migrations` folder and then
    the `Employee.db` file, which is our SQLite database:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 VS Code 终端中运行 `dotnet build` 以修复任何构建错误。为了从我们的模型生成数据库并填充数据库，我们需要在本地或全局安装
    `dotnet-ef` 并在 VS Code 终端中运行迁移命令，如下所示，这将生成 `Migrations` 文件夹，然后是 `Employee.db`
    文件，这是我们的 SQLite 数据库：
- en: '[PRE40]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, to read the `Employee` table, navigate to `Index.cshtml.cs` and paste
    the following code. Here, we are injecting `EmployeeContext` and then reading
    data from the employee table:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要读取 `Employee` 表，导航到 `Index.cshtml.cs` 并粘贴以下代码。在这里，我们注入 `EmployeeContext`
    并从员工表中读取数据：
- en: '[PRE41]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Update `Index.cshtml` with the following code, which loops through the employee
    records populated in the `Employees` property of `IndexModel` and displays them:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `Index.cshtml`，该代码遍历 `IndexModel` 的 `Employees` 属性中填充的员工记录并显示它们：
- en: '[PRE42]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once we run this code, we can see the following output in the browser:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行此代码，我们可以在浏览器中看到以下输出：
- en: '![Figure 9.9 – Employee app output'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 员工应用输出'
- en: '](img/Figure_9.9_18507.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.9_18507.jpg)'
- en: Figure 9.9 – Employee app output
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 员工应用输出
- en: Similarly, there are additional methods available in the `DbContext` class,
    such as `Add()`, `Remove()`, and `Find()`, to perform various CRUD operations,
    and methods such as `FromSqlRaw()` to execute raw SQL queries or stored procedures.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`DbContext` 类中还有其他可用方法，例如 `Add()`、`Remove()` 和 `Find()`，用于执行各种 CRUD 操作，以及
    `FromSqlRaw()` 方法用于执行原始 SQL 查询或存储过程。
- en: This is a very simple example, and its main purpose is to show the capabilities
    of EF Core for real-world applications. We can use a repository pattern with a
    generic repository holding all the CRUD methods and specific repositories to perform
    specialized queries on a table. Additionally, a unit of work pattern can be used
    for transactions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，其主要目的是展示 EF Core 在实际应用中的能力。我们可以使用存储库模式，其中包含所有 CRUD 方法的通用存储库和特定存储库来执行表上的专用查询。此外，可以使用工作单元模式进行事务处理。
- en: Code first versus database first
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码优先与数据库优先
- en: In the previous sample, we have newly created POCOs and generated a database
    out of them; this style of generating a database from POCOs is known as a **code-first
    approach**. As the definition suggests, we have our POCOs defined first and then
    the database is generated.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了新的 POCOs 并从它们中生成了一个数据库；这种从 POCOs 生成数据库的风格被称为 **代码优先方法**。正如定义所暗示的，我们首先定义了
    POCOs，然后生成了数据库。
- en: However, many times, especially during a migration scenario or in cases where
    there is a dedicated database team, we would need to generate POCOs out of database
    tables. EF Core supports such scenarios through the **database-first approach**,
    where models and the application database context class are generated from an
    existing database.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很多时候，尤其是在迁移场景中或者有专门的数据库团队的情况下，我们需要从数据库表中生成 POCOs。EF Core 通过 **数据库优先方法** 支持这种场景，其中模型和应用程序数据库上下文类是从现有数据库生成的。
- en: This process of generating POCOs from database models is known as `Scaffold-DbContext`
    command, which accepts various parameters, such as a database connection string
    and the name of the application database context class, and then generates all
    the required classes needed for EF Core.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库模型生成 POCOs 的这个过程被称为 `Scaffold-DbContext` 命令，它接受各种参数，例如数据库连接字符串和应用程序数据库上下文类的名称，然后生成所有必需的类，用于
    EF Core。
- en: 'The rest of the configuration remains the same as in the code-first approach.
    A sample scaffolding command with various parameters will look like the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的配置与代码优先方法保持一致。一个带有各种参数的示例脚手架命令如下所示：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this command, we are reading a database, `Employee.DB`, generating all the
    models inside `Namespace Api.Data.Models`, generating context inside `Api.Data/Abstraction`,
    and naming the context `EmployeeContext`. In database-first, the relationship
    between classes is defined using the Fluent API as opposed to annotations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们正在读取一个数据库，`Employee.DB`，在 `Namespace Api.Data.Models` 内生成所有模型，在 `Api.Data/Abstraction`
    内生成上下文，并将上下文命名为 `EmployeeContext`。在数据库优先方法中，类之间的关系使用 Fluent API 定义，而不是使用注解。
- en: One thing here is every time we run this command, all the POCOs will be overwritten
    along with the application context class. Secondly, this command generates a context
    class with the `protected override void OnConfiguring(DbContextOptionsBuilder
    optionsBuilder)` method in it. This method is needed only if the context class
    needs to maintain the connection string and other EF Core options. However, in
    most real-world applications, the connection string is maintained in `appsettings.json`
    and EF Core is configured in the `Program` class, so this method can be deleted.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点需要注意，每次我们运行这个命令时，所有的 POCOs 都会被覆盖，包括应用程序上下文类。其次，这个命令生成一个包含 `protected override
    void OnConfiguring(DbContextOptionsBuilder optionsBuilder)` 方法的上下文类。只有当上下文类需要维护连接字符串和其他
    EF Core 选项时，这个方法才是必需的。然而，在大多数实际应用中，连接字符串保存在 `appsettings.json` 中，EF Core 在 `Program`
    类中配置，因此这个方法可以被删除。
- en: This means there is a cleanup involved after each time we scaffold, and a better
    way to avoid any customization is to create a partial class for our application
    database context and do all the customization there, such as adding specific models
    for stored procedures or defining any application-specific constraints. This way,
    any time we scaffold an application, customization won't be overwritten, which
    still allows us to auto-generate classes from a database.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次我们使用 Scaffold 时都涉及清理，为了避免任何自定义，更好的方法是创建一个用于我们的应用程序数据库上下文的局部类，并在那里进行所有自定义，例如添加特定的存储过程模型或定义任何应用程序特定的约束。这样，每次我们
    Scaffold 应用程序时，自定义都不会被覆盖，这仍然允许我们从数据库自动生成类。
- en: Choosing the database-first approach or code-first approach is completely up
    to the development team, as both approaches have pros and cons and there isn't
    any specific feature that is available in one but not in the other.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数据库优先方法或代码优先方法是完全由开发团队决定的，因为两种方法都有优点和缺点，并且没有一种方法具有另一种方法所不具备的特定功能。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Scaffold-DbContext` supports multiple parameters; for example, you can specify
    a schema for generating POCOs for a schema. For further reading, please refer
    to [https://docs.microsoft.com/en-us/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli](https://docs.microsoft.com/en-us/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scaffold-DbContext` 支持多个参数；例如，您可以为生成 POCOs 的架构指定一个模式。有关进一步阅读，请参阅 [https://docs.microsoft.com/en-us/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli](https://docs.microsoft.com/en-us/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli)。'
- en: With this understanding, let's create the Data Access service that we will use
    in our enterprise application in the next section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种理解，让我们创建将在下一节中用于我们企业应用程序的数据访问服务。
- en: Designing a Data Access service using Azure Cosmos DB
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure Cosmos DB 设计数据访问服务
- en: 'As NoSQL databases are all about fast access and high scalability, the schema
    for NoSQL is denormalized and so there is a high possibility of data redundancy.
    Let''s map our requirements from [*Chapter 1*](B18507_01_Epub.xhtml#_idTextAnchor020),
    *Designing and Architecting the Enterprise Application*, to various entities.
    A quick refresher of various services from the architecture is shown in the following
    figure:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 NoSQL 数据库都是关于快速访问和高可扩展性，因此 NoSQL 的架构是非规范化的，因此数据冗余的可能性很高。让我们将我们从 [*第 1 章*](B18507_01_Epub.xhtml#_idTextAnchor020)，*设计和架构企业应用程序*，的需求映射到各种实体。以下图显示了架构中各种服务的快速回顾：
- en: '![Figure 9.10 – Services in an e-commerce application'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 电子商务应用程序中的服务](img/Figure_9.10_18507.jpg)'
- en: '](img/Figure_9.10_18507.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_18507.jpg)'
- en: Figure 9.10 – Services in an e-commerce application
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 电子商务应用程序中的服务
- en: 'For easier understanding, we will represent entities in JSON before moving
    on to POCOs:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于理解，在转向 POCOs 之前，我们将以 JSON 格式表示实体：
- en: '`Email` field is used as a partition key:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Email` 字段用作分区键：'
- en: '[PRE44]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`Name` field is used as a partition key.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name` 字段用作分区键。'
- en: '`Id` field is used as a partition key:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id` 字段用作分区键：'
- en: '[PRE45]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Id` field is used as a partition key:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id` 字段用作分区键：'
- en: '[PRE46]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A combination of `Product` and `Order` is shown in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 `Product` 和 `Order` 的组合：
- en: '![Figure 9.11 – E-commerce database model''s Product and Order schema'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – 电子商务数据库模型的 Product 和 Order 架构'
- en: '](img/Figure_9.11_18507.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_18507.jpg)'
- en: Figure 9.11 – E-commerce database model's Product and Order schema
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 电子商务数据库模型的 Product 和 Order 架构
- en: 'As you can see, all *1:N* relationships are handled by embedding the child
    item as an array. Similarly, the `Invoice` and `User` entities schema is as shown
    in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有 *1:N* 关系都通过将子项作为数组嵌入来处理。同样，`Invoice` 和 `User` 实体架构如图下截图所示：
- en: '![Figure 9.12 – E-commerce database model''s Invoice and User schema'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 电子商务数据库模型的 Invoice 和 User 架构](img/Figure_9.12_18507.jpg)'
- en: '](img/Figure_9.12_18507.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_18507.jpg)'
- en: Figure 9.12 – E-commerce database model's Invoice and User schema
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 电子商务数据库模型的 Invoice 和 User 架构
- en: 'In our enterprise application, [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application),
    we will have one service interacting with the Azure Cosmos DB database. This service
    comprises the following three projects, which are explained next:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的企业应用程序中，[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application)，我们将有一个服务与Azure
    Cosmos DB数据库进行交互。此服务包含以下三个项目，接下来将进行解释：
- en: '`Packt.Ecommerce.Data.Models`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.Data.Models`'
- en: '`Packt.Ecommerce.DataStore`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.DataStore`'
- en: '`Packt.Ecommerce.DataAccess`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.DataAccess`'
- en: The first project is `Packt.Ecommerce.Data.Models`, which is a .NET Standard
    2.1 library and comprises all of our POCOs to communicate with the database. As
    discussed earlier, all the POCOs will have a common `id` property and the other
    properties described in the JSON schema in the previous section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目是`Packt.Ecommerce.Data.Models`，这是一个.NET Standard 2.1库，包含我们与数据库通信的所有POCOs。如前所述，所有POCOs都将有一个共同的`id`属性和前一小节中JSON模式中描述的其他属性。
- en: Tip
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If sample JSON is available, we can make use of JSON in C# class generation
    tools.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有示例JSON，我们可以在C#类生成工具中使用JSON。
- en: '`Packt.Ecommerce.DataStore` is a .NET Standard 2.1 library and is the repository
    layer that holds a generic repository and entity-specific repositories. An important
    class in this project is `BaseRepository`, which has the following methods, and
    each method calls the respective method of the `CosmosClient` class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.DataStore`是一个.NET Standard 2.1库，是存储库层，包含一个通用存储库和特定实体的存储库。此项目中的一个重要类是`BaseRepository`，它具有以下方法，并且每个方法都调用`CosmosClient`类的相应方法：'
- en: '`GetAsync(string filterCriteria)`: This method gets records from a container
    based on `filterCriteria`. If `filterCriteria` is empty, all the records from
    that container are retrieved.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAsync(string filterCriteria)`: 此方法根据`filterCriteria`从容器中获取记录。如果`filterCriteria`为空，则检索该容器中的所有记录。'
- en: '`GetByIdAsync(string id, string partitionKey)`: This method helps in retrieving
    any record from a container by its ID and partition key.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetByIdAsync(string id, string partitionKey)`: 此方法通过ID和分区键从容器中检索任何记录。'
- en: '`AddAsync(Tentity entity, string partitionKey)`: This method allows us to insert
    a record into a container.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddAsync(Tentity entity, string partitionKey)`: 此方法允许我们将一条记录插入到容器中。'
- en: '`ModifyAsync(Tentity entity, string partitionKey)`: This method allows us to
    `UPSERT` (modify if a record is present, otherwise, insert) a record in a container.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModifyAsync(Tentity entity, string partitionKey)`: 此方法允许我们在容器中`UPSERT`（如果记录存在则修改，否则插入）一条记录。'
- en: '`RemoveAsync(string id, string partitionKey)`: This method allows the deletion
    of a record from a container.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAsync(string id, string partitionKey)`: 此方法允许从容器中删除一条记录。'
- en: 'Since, in Azure Cosmos DB, each record is uniquely identified by a combination
    of ID and partition key, all these methods accept a partition key along with `id`.
    Since this is a generic repository, the signature of the class would be the following,
    which allows us to pass any POCO for our application and perform CRUD operations
    on the corresponding container:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Azure Cosmos DB中，每个记录都由ID和分区键的组合唯一标识，因此所有这些方法都接受一个分区键和`id`。由于这是一个通用存储库，类的签名如下，这允许我们传递任何应用程序的POCO并对其对应的容器执行CRUD操作：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'All these methods would require an object of `Microsoft.Azure.Cosmos.Continer`
    for which we create a `readonly` private member, which is initialized in the constructor
    of the class, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都需要一个`Microsoft.Azure.Cosmos.Continer`的对象，我们创建一个`readonly`私有成员，并在类的构造函数中初始化，如下所示：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, `CosmosClient` would be plumbed into the system through dependency injection
    and would be configured in the `static` class. As a best practice, it is recommended
    to have only one instance of `CosmosClient` in the lifetime of the application
    to better reuse connections, so we will be configuring it in our ASP.NET Core
    6 dependency injection container as a singleton. We will come to this in a bit.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`CosmosClient`将通过依赖注入集成到系统中，并在`static`类中进行配置。作为最佳实践，建议在整个应用程序的生命周期内只使用一个`CosmosClient`实例，以便更好地重用连接，因此我们将在我们的ASP.NET
    Core 6依赖注入容器中将它配置为单例。我们稍后会讨论这个问题。
- en: 'Coming back to the repository layer, `BaseRepository` is additionally inherited
    in the following concrete classes, with each repository representing a corresponding
    container:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 回到存储库层，`BaseRepository` 在以下具体类中额外继承，每个存储库代表一个相应的容器：
- en: '`ProductRepository`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductRepository`'
- en: '`UserRepository`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserRepository`'
- en: '`OrderRepository`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderRepository`'
- en: '`InvoiceRepository`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvoiceRepository`'
- en: 'Taking the example of `ProductRepository`, it will have the following implementation,
    where we pass the singleton instance of `CosmosClient` and additional properties
    using the `Ioptions` pattern:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `ProductRepository` 为例，它将具有以下实现，其中我们通过 `Ioptions` 模式传递 `CosmosClient` 的单例实例和额外的属性：
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: All the other repositories will follow a similar structure. Each repository
    will implement its own interface to support dependency injection.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他存储库都将遵循类似的架构。每个存储库都将实现自己的接口以支持依赖注入。
- en: Note
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These repositories will evolve as and when we progress with our application
    implementation.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些存储库将随着我们应用程序实现的进展而发展和演变。
- en: The next project is `Packt.Ecommerce.DataAccess`, which is a Web API project
    targeting .NET 6 and will primarily have all the controllers to expose our repositories.
    Each repository would be a *1:1* mapping with the corresponding controller. So,
    for example, there would be `ProductsController` exposing `ProductRepository`
    methods as a REST API. All the controllers will use constructor injection to instantiate
    their corresponding repositories. One important thing in `Packt.Ecommerce.DataAccess`
    is the configuration of the Azure Cosmos DB database. The design of various controllers
    would be very similar to the design of the `Packt.Ecommerce.Product` Web API,
    which is discussed in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目是 `Packt.Ecommerce.DataAccess`，这是一个针对 .NET 6 的 Web API 项目，它将主要包含所有控制器以公开我们的存储库。每个存储库将与相应的控制器进行*1:1*映射。例如，将会有
    `ProductsController` 以 REST API 的形式公开 `ProductRepository` 方法。所有控制器都将使用构造函数注入来实例化它们对应的存储库。在
    `Packt.Ecommerce.DataAccess` 中一个重要的事情是 Azure Cosmos DB 数据库的配置。各种控制器的设计将与 `Packt.Ecommerce.Product`
    Web API 的设计非常相似，这在[*第10章*](B18507_10_Epub.xhtml#_idTextAnchor1040)中讨论，*创建 ASP.NET
    Core 6 Web API*。
- en: 'To start with, we will have a corresponding section in `appsettings.json`,
    which is shown as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 `appsettings.json` 中有一个相应的部分，如下所示：
- en: '[PRE75]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the local development environment, we will use **Manage User Secrets**,
    as explained here: [https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0).
    We will set the following values:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发环境，我们将使用**管理用户密钥**，如这里所述：[https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0)。我们将设置以下值：
- en: '`{`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`  "CosmosDB:AccountEndPoint": "", //Cosmos DB End Point`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`  "CosmosDB:AccountEndPoint": "", //Cosmos DB End Point`'
- en: '`  "CosmosDB:AuthKey": "" //Cosmos DB Auth key`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`  "CosmosDB:AuthKey": "" //Cosmos DB Auth key`'
- en: '`}`'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: However, once the service is deployed, it should make use of Azure Key Vault,
    as explained in [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473), *Configuration
    in .NET 6*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦服务部署完成，它应该使用 Azure Key Vault，如[*第6章*](B18507_06_Epub.xhtml#_idTextAnchor473)中所述，*在
    .NET 6 中进行配置*。
- en: 'We will define an extension class that will hold the dependency injection mapping.
    A snippet of that is shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个扩展类来保存依赖注入映射。以下是其片段：
- en: '[PRE80]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Similarly, all the repositories would be mapped. Then, we will configure this
    in the `Program` class, along with Azure Cosmos DB configuration, by adding the
    following code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，所有存储库都将进行映射。然后，我们将在 `Program` 类中配置此设置，包括 Azure Cosmos DB 配置，通过添加以下代码：
- en: '[PRE90]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Once we are done with the configuration, this service is ready for consumption
    in other services, such as `Products`, `Orders`, and `Invoice`. This library will
    have all the necessary REST APIs to perform CRUD operations on various entities.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成配置，此服务就准备好在其他服务中使用，例如 `Products`、`Orders` 和 `Invoice`。此库将具有执行各种实体 CRUD 操作的所有必要的
    REST API。
- en: This concludes the creation of a Data Access service that performs CRUD operations
    on various entities, and all the operations are exposed as APIs. This service
    will be called from all the other services that we will develop in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着创建了一个执行各种实体 CRUD 操作的数据访问服务的完成，并且所有操作都作为 API 公开。这个服务将从我们将在[*第 10 章*](B18507_10_Epub.xhtml#_idTextAnchor1040)“创建
    ASP.NET Core 6 Web API”中开发的其它所有服务中调用。
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about various persistent options that are available
    in .NET 6, from APIs to work with files and directories to databases such as Microsoft
    SQL Server and Azure Cosmos DB.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 .NET 6 中可用的各种持久化选项，从与文件和目录一起工作的 API 到如 Microsoft SQL Server 和 Azure
    Cosmos DB 这样的数据库。
- en: We also learned about ORMs, their importance, and how EF Core can be used to
    build a persistence layer while working with Microsoft SQL Server. Along the way,
    we built a data access layer for our e-commerce application using the Azure Cosmos
    DB SDK. Some of the key takeaways are the design decisions we took between SQL
    versus NoSQL, and how we can abstract a data layer with application logic and
    a UI layer that will help you to build scalable enterprise applications.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了对象关系映射（ORM）及其重要性，以及在使用 Microsoft SQL Server 时如何使用 EF Core 来构建持久化层。在这个过程中，我们使用
    Azure Cosmos DB SDK 为我们的电子商务应用程序构建了一个数据访问层。一些关键收获是我们对 SQL 与 NoSQL 之间的设计决策，以及我们如何通过应用逻辑和
    UI 层来抽象数据层，这将帮助您构建可扩展的企业应用程序。
- en: In the next chapter, we will look at the foundation of RESTful APIs and the
    internals of the ASP.NET Core 6 Web API, and further build various RESTful services
    for e-commerce applications.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 RESTful API 的基础和 ASP.NET Core 6 Web API 的内部结构，并进一步为电子商务应用程序构建各种
    RESTful 服务。
- en: Questions
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Say you are migrating an existing web application to use EF Core; however, there
    isn't any change in the database schema and an existing one can be used as-is.
    What is the preferable mode to use EF Core?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你正在将现有的 Web 应用程序迁移到使用 EF Core，但是数据库模式没有变化，现有的数据库可以直接使用。使用 EF Core 的首选模式是什么？
- en: a. Database-first
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: a. Database-first
- en: b. Code-first
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: b. Code-first
- en: c. Both
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: c. Both
- en: '**Answer: a**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: If we are building a recommendation system for our e-commerce application and
    we are using Azure Cosmos DB, what API is best recommended in this scenario?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正在为我们的电子商务应用程序构建一个推荐系统，并且我们正在使用 Azure Cosmos DB，那么在这种情况下哪种 API 是最佳推荐？
- en: a. The Core (SQL) API
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: a. The Core (SQL) API
- en: b. The Mongo API
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: b. The Mongo API
- en: c. The Cassandra API
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: c. The Cassandra API
- en: d. The Gremlin (graph) API
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: d. The Gremlin (graph) API
- en: '**Answer: d**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：d**'
- en: I created a container in SQL API-based databases to store user profile information
    and defined `Email` as the partition key. My system has 100 unique emails. How
    many logical partitions will my container have?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我在基于 SQL API 的数据库中创建了一个容器来存储用户配置文件信息，并将 `Email` 定义为分区键。我的系统有 100 个唯一的电子邮件。我的容器将有多少个逻辑分区？
- en: a. 1.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: a. 1.
- en: b. 0.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: b. 0.
- en: c. 100.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: c. 100.
- en: d. Azure Cosmos DB does not support logical partitions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: d. Azure Cosmos DB 不支持逻辑分区。
- en: '**Answer: c**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: Further reading
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A few links to understand the topics of this chapter further are provided as
    follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些链接，可以帮助您进一步了解本章的主题：
- en: '[https://docs.microsoft.com/en-us/ef/core/saving/transactions](https://docs.microsoft.com/en-us/ef/core/saving/transactions)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/ef/core/saving/transactions](https://docs.microsoft.com/en-us/ef/core/saving/transactions)'
- en: '[https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics](https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics](https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-6.0)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-6.0)'
- en: '[https://aws.amazon.com/products/databases/](https://aws.amazon.com/products/databases/)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/products/databases/](https://aws.amazon.com/products/databases/)'
