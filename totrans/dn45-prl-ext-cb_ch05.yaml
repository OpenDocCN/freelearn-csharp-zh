- en: Chapter 5. Concurrent Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing items to `BlockingCollection`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating a `BlockingCollection` with `GetConsumingEnumerable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing LIFO operations with `ConcurrentStack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread safe data lookups with `ConcurrentDictionary`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling an operation in a concurrent collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple producers and consumers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating object pool with `ConcurrentStack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding blocking and bounding with `IProducerConsumerCollection`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple concurrent collections to create a pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although `System.Collections` namespace offers a wide range of collections;
    the only thing which limits our use of them in a multi-threaded or parallel environment
    is that they are not thread safe. A non thread safe collection could lead to race
    conditions, which is a condition that occurs when two or more threads can access
    shared data and try to change it at the same time, producing unexpected errors.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent collections in .NET Framework 4.5 allow the developers to create
    type safe as well as thread safe collections. These collection classes form an
    essential part of the parallel programming feature and are available under the
    namespace `System.Collections.Concurrent`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing items to BlockingCollection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` is a thread safe collection class that provides blocking
    and bounding functionality. Bounding means that you can set the maximum capacity
    of a collection, which enables you to control the maximum size of the collection
    in the memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple threads can add items to a collection concurrently, but if the collection
    reaches capacity, the producing threads will block until items are removed. Multiple
    consumers can remove items from the collection concurrently. If the collection
    becomes empty, consumption will block until more items are produced and added
    to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at the basics of adding items to, and removing
    items from `BlockingCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a `Console` application that initializes a range of integers
    and creates a parallel task to add the numbers to a blocking collection. Another
    parallel task will be created to remove items from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start Visual Studio and see how to add and remove items with `BlockingCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `BlockingCollection` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the `Main` method of the `Program` class, let's create our range of
    input data and our blocking collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create simple producer `Task` which will use a `for` loop to iterate
    through the numbers of our source data and add them to the blocking collection.
    After we are finished with the loop, use the `CompleteAdding` method of `BlockingCollection`
    to indicate we are done producing data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a simple consumer `Task` that uses a `while` loop to take
    items from `BlockingCollection` and write the output to `Console`. Finish up by
    waiting for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we see how to add items to and remove items from `BlockingCollection`.
    `BlockingCollection` is actually a wrapper for `IProducerConsumer<T>`, and provides
    the blocking and bounding capabilities for thread safe collections. `BlockingCollection`
    takes `IProducerConsumerCollection` in its constructor, or uses `ConcurrentQueue`
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the source data to the collection was easy enough. We just had to loop
    through the source data and call the `Add` method of `BlockingCollection` to add
    the item. When we are finished adding items to the collection, we call the `CompleteAdding`
    method. After a collection has been marked as complete for adding, no more adding
    will be permitted, and threads removing items from the collection will not wait
    when the collection is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Consumer `Task` uses the `IsCompleted` property of `BlockingCollection` to control
    a `while` loop. The `IsCompleted` property, as you would expect, indicates if
    `BlockingCollection` has been marked as complete for adding, and is empty. Inside
    the `while` loop, we just use the `Take` method to take an item from the collection
    and display it on the `Console` application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Iterating a BlockingCollection with GetConsumingEnumerable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BlockingCollection` provides us with an easier alternative for looping through
    a collection, and removing items without setting up a `while` loop, and checking
    the `IsCompleted` property. `BlockingCollection` gives us the ability to do a
    simple `foreach` loop with the `GetConsumingEnumerable` method.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a `Console` application that initializes
    a range of source data and spins up a producer task to add the data to the collection.
    The consumer of the collection data will use the `GetConsumingEnumerable` method
    to get `IEnumerable<T>` for items in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at how to iterate over a `BlockingCollection` with `GetConsumingEnumerable`.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Enumerate` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following `using` directives to the top of your `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the `Main` method of the `Program` class, let's create our range of
    input data and our blocking collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next let's create a simple producer `Task` which will use a `for` loop to iterate
    through the numbers of our source data and add them to the blocking collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create a consumer `Task` which will iterate through the collection
    with a `foreach` loop by calling the `GetConsumingEnumerable` method of blocking
    collection. Finish up by waiting for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Producer `Task` in this recipe is exactly the same as producer `Task` created
    in the first recipe. The only real change to take note of is that we no longer
    have to set up a `while` loop to take items from the collection, as we did in
    the first recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By calling the `GetConsumingEnumerable` method of `BlockingCollection`, we can
    now use much cleaner `foreach` loop syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `GetConsumingEnumerable` method takes a snapshot of the current state of
    the underlying collection and returns `IEnumerable<T>` for the collection items.
  prefs: []
  type: TYPE_NORMAL
- en: Performing LIFO operations with ConcurrentStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ConcurrentStack` is the thread safe counterpart of `Systems.Collections.Generic.Stack`,
    which is the standard **Last-In-First-Out** (**LIFO**) container in the .NET Framework.
    For algorithms that favor stack usage such as depth-first searches, a thread safe
    stack is a big benefit.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to take a look at the basic usage of `ConcurrentStack`.
    Our `Console` application for this recipe will initialize a range of data, which
    a simple producer `Task` will push onto the stack. Consumer `Task` will concurrently
    pop items from the stack and write them to `Console`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's take a look at performing LIFO operations with `ConcurrentStack`.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `ConcurrentStack` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the `Main` method of the `Program` class, let's create our range of
    input data and our blocking collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a simple producer task which will use a `for` loop to iterate
    through the numbers of our source data and pop them onto the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a consumer `Task` which will use a `while` loop to pop items
    off the stack while the `IsEmpty` property of the stack is false. Finish by waiting
    for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConcurrentStack` achieves thread safe access by using the `System.Threading.Interlocked`
    operations. Interlocked operations provide a simple mechanism for synchronizing
    access to variables shared by multiple threads. Interlocked operations are also
    very fast.'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, `ConcurrentStack` behaves like `System.Collections.Generic.Stack`.
    To push an item onto the stack, you just use the `Push` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, the `Pop` method was removed in favor of `TryPop`. `TryPop` returns
    `true` if an item existed and was popped, otherwise it returns `false`. The `out`
    parameter contains the object removed if the pop was successful, otherwise it
    is indeterminate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Thread safe data lookups with ConcurrentDictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary` is the thread safe counterpart to the generic `dictionary`
    collection. Both are designed for quick lookups of data based on a key. However,
    `ConcurrentDictionary` allows us to interleave both reads and updates. `ConcurrentDictionary`
    achieves its thread safety with no common lock to improve efficiency. It actually
    uses a series of locks to provide concurrent updates, and has lockless reads.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create `ConcurrentDictionary` and initialize it with
    a small set of key value pairs. Our `dictionary` will be concurrently updated
    by one task and read by another.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at how to use `ConcurrentDictionary` for data lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `ConcurrentDictionary` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's create our `ConcurrentDictionary` and initialize it with some data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create `Task` to update `dictionary` on a separate thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create another `Task` which will be concurrently reading from `dictionary`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary` behaves like `dictionary` counterpart with slight differences.
    We are updating `dictionary` using the `TryUpdate` method. This method was added
    to provide us with an atomic operation to check if the item exists, and if not,
    add it while still under an atomic lock.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are reading `dictionary` directly from the `Key` and `Value` properties of
    each `KeyValuePair` in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling an operation in a concurrent collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with `BlockingCollection`, most `Add` and `Take` operations are
    performed in a loop. The `TryAdd` and `TryTake` methods of `BlockingCollection`
    can accept a `CancellationToken` parameter so that we can respond to cancellation
    requests and break out of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a `Console` application that has producer
    `Task` and consumer `Task`. The producer will be adding items to `BlockingCollection`
    using `TryAdd`, and the consumer will be removing items using `Try`.
  prefs: []
  type: TYPE_NORMAL
- en: After the producer and consumer get started, we will call the `Cancel` method
    on a token source to see how we can use the `TryAdd` and `TryTake` overloads to
    handle cancellation of our operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime `Exception` is thrown, and
    intercepts the `Exception` before it gets to our handler.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how to cancel a concurrent collection operation.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `CancelOperation` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, let's create a source range of
    numbers, instantiate our `CancellationTokenSource` and obtain `CancellationToken`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, just below the previous lines, create a producer `Task` and pass in `CancellationToken`.
    The producer should add items to `BlockingCollection` by calling `TryAdd` inside
    a `try`/`catch` block. The `catch` block should handle `OperationCancelledException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a consumer `Task` and pass in `CancellationToken`. The consumer
    task should take items from `BlockingCollection` by calling `TryTake` inside a
    `try`/`catch` block. The `catch` block should handle `OperationCancelledException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's have the main thread wait for a bit, then call the `Cancel` method
    of `CancellationTokenSource`. Wait for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Responding to cancellations when working with `BlockingCollection` is pretty
    consistent with other classes in the Task Parallel Library.
  prefs: []
  type: TYPE_NORMAL
- en: In the producer task, we use the overload of `TryAdd` that accepts an out parameter,
    a timeout parameter and `CancellationToken`. We also call `TryAdd` in a `try`/`catch`
    block, so we can respond to `OperationCancelledException`. When the operation
    is cancelled, we call `CompleteAdding` to indicate we will be adding more items
    and execute a `break` statement to break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Things are very similar on the consumer side. We pass `CancellationToken` into
    `TryTake` and handle `OperationCancelledException` in our `catch` block. When
    the operation is cancelled, we issue a `break` statement to break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple producers and consumers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to use single `BlockingCollection` as a buffer between multiple
    producers and consumers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to build a `Console` application that will create
    multiple producer tasks which perform an expensive math operation on a small range
    of numbers. We will also have two consumer tasks that loop through the `BlockingCollection`
    buffer and display the results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's take a look at using a single `BlockingCollection` with multiple
    producers and consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `MultiptleProducerConsumer` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating a `static` method on the `Program` class which performs
    our expensive math operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create another `static` method on the `Program` class that the consumers
    will use to display the results to the `Console` application. This method will
    call `GetConsumingEnumerable` on `BlockingCollection` and loop through the collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, in the `Main` method of the `Program` class, let's define our `BlockingCollection`
    buffer and create `List<Task>`, so we can coordinate our multiple tasks, and create
    a couple of simple consumer `tasks` that will use the `DisplayResults` method
    to print out the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to create a `for` loop that loops from one to twenty-five, creating
    producer tasks that use the `CalcSumRoot` method to calculate the result, and
    then add the result to `BlockingCollection` by calling `TryAdd`. The loop must
    also add all of producer `tasks` to the `Task` list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create a continuation to run after all producer `tasks` that
    are complete. The continuation simply calls the `CompleteAdding` method of `BlockingCollection`
    to indicate that we are done adding items to the collection. Finish up by waiting
    for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Notice the ordered results
    in the following screenshot:![How to do it…](img/0225OT_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, `BlockingCollection` uses `ConcurrentQueue<T>` as the backing store.
    `ConcurrentQueue` takes care of thread synchronization and `BlockingCollection`
    does a non-busy wait while trying to take an item from the collection. That is,
    if the consumer calls `TryTake` when there are no items in the queue, it does
    a non-busy wait until any items are available.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are spinning up producer `tasks` in a `for` loop. Each producer
    `task` is calling the `CalcSumRoot` method which is a fairly expensive math operation.
    Our consumers are simply displaying the output to the screen. As a result, our
    two consumer `tasks` are probably spending most of their time in a non busy wait
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The producers and consumers are pretty simple, but we needed a way to call `CompleteAdding`
    after all producer `tasks` have finished. We handled this by adding all of our
    producer `Task` objects to `List<Task>`, and calling the `ContinueWhenAll` method
    of `Task.Factory`, so our continuation only runs when all of the producers complete.
    The only job of the continuation is to call the `CompleteAdding` method of `BlockingCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating object pool with ConcurrentStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object pool is a set of pre-initialized objects that your application can
    use, rather than creating and destroying all of the objects it needs. If the instantiation
    cost of an object type is high, your application might benefit from a pool of
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create an object pool based on `ConcurrentStack`.
    `ConcurrentStack` will handle concurrent access issues using fast interlocked
    operations, and will dispense our objects in a LIFO manner. We will also have
    an object pool client which creates three tasks. One creates objects and puts
    them in the pool, the other two tasks request objects from the pool on different
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how we can use `ConcurrentStack` to build a pool of pre-initialized
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `ObjectPool` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by creating our object pool class. Right-click on the `ObjectPool`
    project in the **Solution Explorer** and click on **Add**, then choose **New Item**.
    Select **Visual C# Items**, and **Class.** Enter `ConcurrentObjectPool` as the
    name of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `ConcurrentObjectPool`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want our object pool to work with any type, so add a generic type parameter
    after the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `ObjectPool` class is going to need a couple of private state fields. We
    need a `ConcurrentStack` field which will provide our backing store and a `Func<T>`
    field which will hold an object creation function the pool can use to generate
    objects when the pool is empty. Inside the class declaration, add the following
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need a constructor for the `ConcurrentObjectPool` class. The constructor
    should take a `Func<T>` argument for the object generator and should instantiate
    a new `ConcurrentStack` object as the backing store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need a `GetObject` method which will return a new object to the client.
    The `GetObject` method will try to pop an object off the stack. If it can't pop
    one off the stack, it will use `objectInitializer` to instantiate a new object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last step for our object pool is a `PutObject` method that takes a generic
    item parameter and pushes it on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create the `Console` application that will use the object pool.
    Go back to `Program.cs` and add the following `using` directives at the top of
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first step is to instantiate our object pool. In the `main` method of the
    program class, create a `ConcurrentObjectPool` object and pass in a function that
    creates a new `StringBuilder` object as the constructor parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a task that creates some objects and places them in `pool`
    using the `PutObject` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create two continuation tasks that run after the first task is
    completed. Both tasks just request objects from the object `pool` using the `GetObject`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other features we could have added to our object `pool`, such as controlling
    the concurrency level and/or using thread local segments to store our objects,
    but this simple implementation does the job for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of the object `pool` takes a function argument that it can
    use to generate an object if the pool is empty, and stores the function in a private
    `objectInitializer` field. We are just pooling `StringBuilder` objects in this
    sample, so we passed in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our `GetObject` method, which the client uses to get objects from `pool`, just
    uses the `TryPop` method of `ConcurrentStack` to return an object. If `TryPop`
    fails to return anything because the stack is empty, we just return the result
    of the `objectInitializer` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `PutObject` method probably doesn't require much explanation. It just uses
    the `Push` method of `ConcurrentStack` to push an object onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we chose to use `ConcurrentStack`, our object references are returned
    in a LIFO fashion. We could have chosen another type of backing store if this
    didn't work for us. For example, we could have chosen to use `ConcurrentQueue`
    as a backing store to have items returned in a **First-In-First-Out** (**FIFO**)
    fashion, or we could have used `ConcurrentBag` to provide unordered storage.
  prefs: []
  type: TYPE_NORMAL
- en: Adding blocking and bounding with IProducerConsumerCollection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, `BlockingCollection` uses `ConcurrentQueue` as its backing store.
    However, you can add blocking and bounding functionality to any custom or derived
    collection class by implementing the `IProducerConsumerCollection` interface in
    the class. You can then use an instance of the custom collection class as the
    backing store for `BlockingCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a custom priority queue and use the custom
    queue as the backing store for `BlockingCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's examine how we can use `IProducerConsumerColletion` to add blocking and
    bounding functionality to a custom collection.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign **CustomBlockingBounding** as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's add a `Class` file for our custom queue. Right-click on the **CustomBlockingBounding**
    project and click on **Add Item**, and then click on **Add New Item** and then
    click on **Class**. Name the new class `PriorityQueue.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `PriorityQueue` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Below the `PriorityQueue` class, let's create an enumeration for our queue priority
    levels. We just want to use low, medium, and high as the possible priority levels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our custom collection class will hold `KeyValuePairs` of the queue priority
    level and the data queued. Add priority level and queued data generic type parameters
    to `Class` and declare the `IProducerConsumerCollection` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need some private fields for the `PriorityQueue` class. We will need
    three `ConcurrentQueue<QueuePriorityLevel, TValue>` fields; one each for the low,
    medium, and high priority queues. We will need an array of `ConcurrentQueue` to
    hold all of the queues and an integer count variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's add a default constructor to the `PriorityQueue` class that initializes
    all of our fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to provide an implementation for several of the `IProducerConsumerCollection`
    interface members. Let's start with the `CopyTo` method. This method makes a copy
    of our collection array to a destination array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to provide an implementation for the `ToArray` method which returns
    an array of `KeyValuePairs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we are getting to the key `IProducerConsumerCollection` method implementations.
    We need to provide an implementation for the `TryAdd` method which is going to
    determine our private `ConcurrentQueue` collections to add the new item to, and
    then add the item, and use `Interlocked.Increment` to increment the count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TryTake` method implementation needs to loop through the backing `ConcurrentQueues`
    in priority order, and try to take the first available item from one of the queues,
    and decrement the count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next we need to implement the `GetEnumerator` methods required to implement
    `IEnumerable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We're almost done with the collection. The last thing we need to do is implement
    a simple getter for the `count` field. There is no need to provide an implementation
    for the other `IProducerConsumerCollection` members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ok, let''s move on to our `Console` application which will use the custom `queue`
    class. Open `Program.cs` and add the following `using` directives to the top of
    the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of your `Program` class, start with some local variable
    declarations for a `PriorityQueue` variable, a `BlockingCollection` variable that
    takes the `PriorityQueue` variable as a constructor argument, and a list of tasks
    which will hold references to our producer and consumer `tasks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `Console` application has a producer task which will add items to the priority
    queue with a random priority level. The consumer task will remove items from the
    queue in priority order and write the results to `Console`. Let's start with the
    `producer` task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right after the `producer` task, make a call to `Thread.SpinWait` to make the
    main thread wait for a bit before starting the `consumer` task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's add the `consumer` task which will pull items from the queue and display
    the results to the `Console` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up by adding the `producer` and `consumer` tasks to the list of `tasks`.
    Wait on both tasks to complete by calling `Task.WaitAll` inside a `try`/`catch`
    block. In the `catch` block, handle any `AggregateException` that may be thrown.
    Lastly, wait for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There were a lot of codes in this recipe, but the key points of the implementation
    can be distilled to just a few `IProducerConsumerCollection` interface method
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '`IProducerConsumerCollection<T>` defines a handful of methods for manipulating
    thread safe collections for producer/consumer usage.'
  prefs: []
  type: TYPE_NORMAL
- en: To create our custom collection class, we just implemented the `IProducerConsumerCollection`
    interface on our custom `PriorityQueue` class and used some `ConcurrentQueue`
    fields as our backing stores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation of the `IProducerConsumerCollection.TryAdd` method
    is pretty simple. We just determine the queue to place the item in by casting
    our `QueuePriorityLevel` enumeration to an integer, then enqueue the item. We
    then do `Interlocked.Increment` on our count field. `Interlocked.Increment` does
    a thread safe increment of the count field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`TryTake` isn''t much more complex. We just loop through our three private
    backing queues in order of priority and remove the first item we come to. `TryTake`
    returns a bool to indicate of it was successful in taking an item.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Using multiple concurrent collections to create a pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pipeline is like an assembly line in a factory. With the pipeline pattern,
    data is processed in a sequential order where the output from the first stage
    becomes the input for the second stage and so on. Pipelines use parallel tasks
    and concurrent queues to process a series of input values.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a simple pipeline that creates a range
    of numbers, doubles the numbers in the range, and then writes the results to `Console`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how to create a pipeline by using multiple concurrent collections.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Pipeline` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's add a `static` method to the `Program` class to create the range.
    This method needs a `BlockingCollection` parameter. It will simply add items to
    `BlockingCollection` in a loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a `static` method to square the range. This method will take
    two `BlockingCollection` parameters and will square each of the items in the source
    collection and place them in the result collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a `static` method to display the results. This method will
    take a `BlockingCollection` parameter and will loop through its items and write
    the values to the `Console` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, declare the two `BlockingCollection<int>`
    variables. These blocking collections will be the data buffers for the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create and start three tasks to call each of our three methods passing in the
    `BlockingCollection` buffers required for each method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, wait for all three tasks to complete by calling `Task.WaitAll`. Wait
    for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a simple pipeline composed of three stages. Each
    stage reads from and/or writes to a particular buffer. If your machine has more
    available processor cores than there are stages in the pipeline, the stages can
    run in parallel. The concurrent queues used by `BlockingCollection` will buffer
    all shared inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage in the pipeline can add items to its output buffer as long as there
    is room. If the buffer is full, the pipeline stage waits for space to become available
    before adding an item. The stages can also wait on inputs from the previous stage.
  prefs: []
  type: TYPE_NORMAL
- en: The stages that produce data use `BlockingCollection.CompleteAdding` to signal
    that they are finished adding data. This tells the consumer that it can end its
    processing loop after all previously added data has been removed or processed.
  prefs: []
  type: TYPE_NORMAL
