["```cs\n//Define possible states for enemy\npublic enum AI_ENEMY_STATE {IDLE = 2081823275,\n                            PATROL=207038023,\n                            CHASE= 1463555229,\n                            ATTACK=1080829965,\n                            SEEKHEALTH=-833380208};\n```", "```cs\n//Current state of enemy\npublic AI_ENEMY_STATE CurrentState = AI_ENEMY_STATE.IDLE;\n```", "```cs\n//Get Animator\nThisAnimator = GetComponent<Animator>();\n\n//Get Navigation Mesh Agent\nThisAgent = GetComponent<NavMeshAgent>();\n\n//Get Transform Component\nThisTransform = transform;\n\n//Get Player Transform\nPlayerTransform = GameObject.FindGameObjectWithTag(\"Player\").transform;\n\n//Get Collider\nThisCollider = GetComponent<BoxCollider>();\n```", "```cs\n01 //--------------------------------------------------\n02 //This coroutine runs when object is in idle state\n03 public IEnumerator State_Idle()\n04 {\n05       //Set current state\n06       CurrentState = AI_ENEMY_STATE.IDLE;\n07 \n08       //Activate idle state with Mecanim\n09       ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.IDLE);\n10 \n11       //Stop nav mesh agent movement \n12        ThisAgent.Stop();\n13  \n14       //Loop forever while in idle state\n15       while(CurrentState == AI_ENEMY_STATE.IDLE)\n16        {\n17              //Check if we can see player\n18              if(CanSeePlayer)\n19              {\n20                    // can see player?, chase to attack\n21                    StartCoroutine(State_Chase());\n22                    yield break;\n23               }\n24 \n25              //Wait for next frame\n26              yield return null;\n27        }\n28 }\n29 //--------------------------------------------------\n```", "```cs\n   //Event called when Idle animation is completed\n   public void OnIdleAnimCompleted()\n   {\n         //Stop active Idle state\n         StopAllCoroutines();\n StartCoroutine(State_Patrol());\n   }\n```", "```cs\n01 //Find all gameobjects with waypoint\n02 GameObject[] Waypoints = GameObject.FindGameObjectsWithTag(\"Waypoint\");\n03 \n04 //Select all transform components from waypoints using Linq\n05 WayPoints = (from GameObject GO in Waypoints\n06                   select GO.transform).ToArray();\n```", "```cs\n01 //--------------------------------------------------\n02 //This coroutine runs when object is in patrol state\n03 public IEnumerator State_Patrol()\n04 {\n05 //Set current state\n06 CurrentState = AI_ENEMY_STATE.PATROL;\n07 \n08 //Set Patrol State\n09 ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.PATROL);\n10 \n11 //Pick a random waypoint\n12 Transform RandomDest = WayPoints[Random.Range(0, WayPoints.Length)];\n13 \n14 //Go to destination\n15 ThisAgent.SetDestination(RandomDest.position);\n16 \n17 //Loop forever while in patrol state\n18 while(CurrentState == AI_ENEMY_STATE.PATROL)\n19 {\n20        //Check if we can see player\n21        if(CanSeePlayer)\n22        {\n23             //If we can see player, then chase to attack \n24             StartCoroutine(State_Chase());\n25             yield break;\n26        }\n27 \n28        //Check if we have reached destination\n29        if(Vector3.Distance(ThisTransform.position, RandomDest.position) <= DistEps)\n\n30        {\n31              //Reached destination. Changed state back to Idle\n32              StartCoroutine(State_Idle());\n33              yield break;\n34        }\n35 \n36        //Wait for next frame\n37        yield return null;\n38 }\n39 }\n40 //--------------------------------------------------\n```", "```cs\n01 void Update()\n02 {\n03 //Assume we cannot see player\n04 CanSeePlayer = false;\n05 \n06 //If player not inside bounds then exit\n07 if(!ThisCollider.bounds.Contains(PlayerTransform.position)) return;\n\n08 \n09 //Player is inside bounds, update line of sight\n10 CanSeePlayer = HaveLineSightToPlayer(PlayerTransform);\n11 }\n```", "```cs\n//Function to return whether player can be seen right now\nprivate bool HaveLineSightToPlayer(Transform Player)\n{\n//Get angle between enemy sight and player\nfloat Angle = Mathf.Abs(Vector3.Angle(ThisTransform.forward, (Player.position-ThisTransform.position).normalized));\n\n    //If angle is greater than field of view, we cannot see player\n    if(Angle > FieldOfView) return false;\n\n    //Check with raycast- make sure player is not on other side of wall\n    if(Physics.Linecast(ThisTransform.position, Player.position, SightMask)) return false;\n\n    //We can see player\n    return true;\n }\n```", "```cs\n01 //This coroutine runs when object is in chase state\n02 public IEnumerator State_Chase()\n03 {\n04 //Set current state\n05 CurrentState = AI_ENEMY_STATE.CHASE;\n06 \n07 //Set Chase State\n08 ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.CHASE);\n09 \n10 //Loop forever while in chase state\n11 while(CurrentState == AI_ENEMY_STATE.CHASE)\n12 {\n13        //Set destination to player\n14        ThisAgent.SetDestination(PlayerTransform.position);\n15 \n16       //If we lose sight of player, keep chasing \n17       if(!CanSeePlayer)\n18       {\n19              //Begin time out\n20              float ElapsedTime = 0f;\n21 \n22              //Continue to chase\n23              while(true)\n24              {\n25                    //Increment time\n26                    ElapsedTime += Time.deltaTime;\n27 \n28                    //Set destination to player\n29 ThisAgent.SetDestination( PlayerTransform.position);\n30 \n31                   //Wait for next frame\n32                   yield return null;\n33 \n34                   //Has timeout expired?\n35                   if(ElapsedTime >= ChaseTimeOut)\n36                   {\n37                          //If cannot see player, change to idle\n38                          if(!CanSeePlayer)\n39                          {\n40                                //Change to idle \n41                                StartCoroutine(State_Idle());\n42                                yield break;\n43                          }\n44                          else\n45                                break; //can see player again\n46                   }\n47              }\n48        }\n49 \n50        //If we have reached player then attack\n51 if(Vector3.Distance(ThisTransform.position, PlayerTransform.position) <= DistEps)\n\n52        {\n53              //We have reached distance, now attack\n54              StartCoroutine(State_Attack());\n55              yield break;\n56        }\n57 \n58        //Wait until next\n59        yield return null;\n60 }\n61 }\n```", "```cs\n//This coroutine runs when object is in attack state\n public IEnumerator State_Attack()\n {\n    //Set current state\n    CurrentState = AI_ENEMY_STATE.ATTACK;\n\n    //Set Chase State\n    ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.ATTACK);\n     //Stop nav mesh agent movement\n ThisAgent.Stop();\n\n    //Set up timer for attack interval\n    float ElapsedTime = 0f;\n\n    //Loop forever while in attack state\n    while(CurrentState == AI_ENEMY_STATE.ATTACK)\n    {\n         //Update timer\n         ElapsedTime += Time.deltaTime;\n\n        //Check if player has passed beyond the attack distance\nif(!CanSeePlayer || Vector3.Distance(ThisTransform.position, PlayerTransform.position) > DistEps)\n          {\n               //Change to chase\n               StartCoroutine(State_Chase());\n               yield break;\n          }\n\n          //Check attack delay\n          if(ElapsedTime >= AttackDelay)\n          {\n                //Reset counter\n                ElapsedTime = 0f;\n\n               //Launch attack\n               PlayerTransform.SendMessage(\"ChangeHealth\", -AttackDamage, SendMessageOptions.DontRequireReceiver);\n          }\n\n          //Wait until next frame\n          yield return null;\n    }\n }\n```", "```cs\n//Event called health changed\n public void ChangeHealth(float Amount)\n {\n    //Reduce health\n    Health += Amount;\n\n    //Should we die?\n    if(Health <= 0)\n    {\n          StopAllCoroutines();\n          Destroy(gameObject);\n          return;\n    }\n\n    //Check health danger level\n    if(Health > HealthDangerLevel) return;\n\n    //Health is less than or equal to danger level, now seek health restores, if available\n    StopAllCoroutines();\n StartCoroutine(State_SeekHealth());\n }\n```", "```cs\n01 //This coroutine runs when object is in seek health state\n02 public IEnumerator State_SeekHealth()\n03 {\n04 //Set current state\n05 CurrentState = AI_ENEMY_STATE.SEEKHEALTH;\n06 \n07 //Set Chase State\n08 ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.SEEKHEALTH);\n09 \n10 //This is the nearest health restore\n11 HealthRestore HR = null;\n12 \n13 //Loop forever while in seek health state\n14 while(CurrentState == AI_ENEMY_STATE.SEEKHEALTH)\n15 {\n16        //If health restore is not valid, then get nearest\n17        if(HR == null) HR = GetNearestHealthRestore(ThisTransform);\n18 \n19        //There is an active health restore, so move there\n20        ThisAgent.SetDestination(HR.transform.position);\n21 \n22        //If HR is null, then no more health restore, go to idle\n23        if(HR == null || Health > HealthDangerLevel)\n24        {\n25              //Change to idle\n26              StartCoroutine(State_Idle());\n27              yield break;\n28 \t      }\n29 \n30       //Wait until next frame\n31       yield return null;\n32 }\n33 }\n```", "```cs\n01 //Function to get nearest health restore to Target in scene\n02 private HealthRestore GetNearestHealthRestore(Transform Target)\n03 {\n04 //Get all health restores\n05 HealthRestore[] Restores = Object.FindObjectsOfType<HealthRestore>();\n\n06 \n07 //Nearest\n08 float DistanceToNearest = Mathf.Infinity;\n09 \n10 //Selected Health Restore\n11 HealthRestore Nearest = null;\n12 \n13 //Loop through all health restores\n14 foreach(HealthRestore HR in Restores)\n15 {\n16        //Get distance to this health restore\n17 float CurrentDistance = Vector3.Distance(Target.position, HR.transform.position);\n\n18 \n19        //Found nearer health restore, so update\n20        if(CurrentDistance <= DistanceToNearest)\n21        {\n22              Nearest = HR;\n23              DistanceToNearest = CurrentDistance;\n24        }\n25 }\n26 \n27 //Return nearest or null\n28 return Nearest;\n29 }\n```"]