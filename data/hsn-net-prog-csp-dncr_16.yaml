- en: The Internet Protocol
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议
- en: In the previous chapter, we got a comprehensive understanding of two of the
    most common and robust protocols in the transport layer of the **Open Systems
    Interconnection** (**OSI**) network stack, with the **Transmission Control Protocol**
    (**TCP**) and **User Datagram Protocol** (**UDP**). In this chapter, we'll look
    at the network layer protocol that enables each of those two transport layer services.
    In this chapter, we'll be learning about the **Internet Protocol** (**IP**). We'll
    look at how the IP standard has evolved to support a global network of billions
    of devices, allowing each of them to reliably communicate with one another. We'll
    consider the earlier, and more common IPv4, looking at what problems IPv4 was
    designed to solve, and discussing the limitations that it has reached. Next, we'll
    examine how IPv6 aims to solve those limitations. Finally, we'll take a closer
    look at the `IPAddress` class, and look closely at how the core libraries implement
    IPv4 and IPv6\. We'll take the opportunity to discuss and consider how IP addresses
    map to domain names and learn how **Domain Name System **(**DNS**) servers will
    map an address to a resource, and we'll look at some code samples that will allow
    us to implement those mappings on our own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们全面了解了**开放系统互联**（**OSI**）网络堆栈传输层中最常见且最健壮的两个协议：**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。在本章中，我们将探讨使这两个传输层服务得以实现的网络层协议。在本章中，我们将学习关于**互联网协议**（**IP**）的内容。我们将探讨IP标准是如何演变为支持数十亿设备的全球网络，并允许它们之间可靠地相互通信的。我们将考虑较早且更常见的IPv4，查看IPv4旨在解决的问题，并讨论其达到的限制。接下来，我们将检查IPv6旨在解决这些限制的方式。最后，我们将更详细地查看`IPAddress`类，并仔细研究核心库是如何实现IPv4和IPv6的。我们将借此机会讨论并考虑IP地址如何映射到域名，以及学习**域名系统**（**DNS**）服务器如何将地址映射到资源，并查看一些代码示例，这些示例将使我们能够自行实现这些映射。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What an IP address is composed of and how it is used, along with network masks,
    local addressing, and DNS servers, to identify physical devices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址的组成以及它是如何被使用的，包括网络掩码、本地寻址和DNS服务器，用于识别物理设备
- en: How IP addresses are assigned using the IPv4 standard, identifying the limitations
    of IPv4
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IPv4标准分配IP地址的方式，以及识别IPv4的限制
- en: The specifics of the IPv6 standard, enumerating the strengths of leveraging
    IPv6, and the costs of implementing it at the scale of the internet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6标准的详细信息，列举利用IPv6的优势以及在全球互联网规模上实施它的成本
- en: The hostname to IP address resolution at the DNS level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS级别的域名到IP地址解析
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we''ll be writing sample software to resolve IP addresses
    configured from our hosts file to simulate a DNS server. You''ll need your .NET
    Core **integrated development environment** (**IDE**) or a code editor. You can
    access the sample code at [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter
    12](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2012). Check
    out the following video to see the code in action: [http://bit.ly/2HYmyi9](http://bit.ly/2HYmyi9).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写示例软件来解析从我们的主机文件配置的IP地址，以模拟DNS服务器。您需要.NET Core **集成开发环境**（**IDE**）或代码编辑器。您可以在[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2012](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2012)访问示例代码。查看以下视频以查看代码的实际运行情况：[http://bit.ly/2HYmyi9](http://bit.ly/2HYmyi9)。
- en: The IP standard
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP标准
- en: Before we start looking at how the IP standard has evolved from its inception
    to the widely adopted IPv4, and now on to IPv6, we first have to understand what
    the standard is and how it's distinct from the transport layer protocols that
    we've looked at. This is critical to cementing our understanding of the OSI network
    stack, as IP is fundamental to the operation of transport layer protocols that
    operate over the internet. So, let's figure out just what IP is designed for,
    how it accomplishes its design goals, and what sort of features it enables for
    network software and hardware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看IP标准从其起源发展到广泛采用的IPv4，再到现在的IPv6之前，我们首先必须了解该标准是什么以及它与我们所查看的传输层协议有何不同。这对于巩固我们对OSI网络堆栈的理解至关重要，因为IP是互联网上运行的传输层协议的基础。因此，让我们弄清楚IP是为什么而设计的，它是如何实现其设计目标的，以及它为网络软件和硬件提供了哪些功能。
- en: The origins of IP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP的起源
- en: Originally implemented as a packet transmission mechanism in the earliest version
    of the TCP, IP was first formally described in 1974\. Still early in the history
    of modern computing, computational networks were very much in their infancy. Those
    networks grew in scope, however, and began to encapsulate multiple sub-networks
    with various interaction mechanisms. And as those networks grew, the need for
    a standard across network-connected devices quickly became apparent.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: IP最初作为TCP最早版本中的数据包传输机制实现。IP首次在1974年得到正式描述。在现代计算机历史的早期，计算网络还处于起步阶段。然而，这些网络在范围上不断增长，并开始使用各种交互机制封装多个子网络。随着网络的增长，对网络连接设备之间标准的需求迅速显现。
- en: To satisfy this need for a standard, the **Advanced Research Projects Agency**
    (**ARPA**) of the US government sponsored a series of experiments to define a
    protocol that could support a wide-scale interconnected network. With this sponsorship,
    the members of the **Institute of Electrical and Electronic Engineers** (**IEEE**)
    wrote a paper that described an inter-networking protocol that leveraged packet
    switching to share resources across and between hosts in a network. Beginning
    in 1977, the organization began experimenting with various drafts of the protocol
    described in this paper. Between 1977 and 1979, there were four experimental versions
    of IP described by **Internet Experiment Notes** (**IEN**), and labeled IPv0 through
    to IPv3\. Each of these versions tackled some major deficiency in the previous
    iteration of the protocol until the team was certain their protocol was sufficiently
    robust for use by the wider public.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这一对标准的需要，美国政府的高级研究计划署（**ARPA**）赞助了一系列实验，以定义一个能够支持大规模互联网络的协议。在这一赞助下，电气和电子工程师协会（**IEEE**）的成员撰写了一篇论文，描述了一种利用分组交换技术在网络中的主机之间共享资源的互联网络协议。从1977年开始，该组织开始尝试使用这篇论文中描述的协议的各种草案。在1977年至1979年之间，根据**互联网实验笔记**（**IEN**）的描述，有四个IP的实验版本，分别标记为IPv0至IPv3。这些版本中的每一个都解决了前一个协议版本中的某些主要缺陷，直到团队确信他们的协议足够健壮，可以供更广泛的公众使用。
- en: IPv0 – a network layer protocol for TCP
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv0 – TCP的网络层协议
- en: The first of these experiments, IEN 2, was written in August 1977\. It explicitly
    states that engineers had been screwing up in their design of IPs by violating
    the principle of layering. In its initial draft, TCP was responsible for the abstraction
    of both the host-to-host transmission of application layer packets, and for negotiating
    the hops between network devices along the route between the two connected hosts.
    By over-engineering TCP in this way, engineers created a single protocol that
    spanned both the transport and network layers of the OSI network stack. This violation
    of boundaries between OSI layers was almost immediately recognized as a bad design,
    and a bad practice. So, with IEN 2, the authors proposed a new and distinct internetwork
    protocol, and that TCP be used strictly as a host level end-to-end protocol. And
    with this experiment, IP was born.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实验中的第一个，IEN 2，是在1977年8月撰写的。它明确指出，工程师们在设计IP时违反了分层原则。在其初始草案中，TCP负责抽象应用层数据包的主机到主机的传输，以及协商两个连接主机之间路由上的网络设备之间的跳数。通过这种方式过度设计TCP，工程师创建了一个跨越OSI网络堆栈的传输和网络层的单一协议。这种违反OSI层之间边界的行为几乎立即被认识到是一个糟糕的设计和做法。因此，在IEN
    2中，作者提出了一个新的、独特的互联网协议，并建议TCP严格用作主机级别的端到端协议。通过这个实验，IP诞生了。
- en: The protocols and interfaces described in IEN 2 described two primary operations
    that had previously both been performed by TCP. First, there was the **Internet
    Host-Hop Protocol**, which would become TCP. This was meant to describe the interface
    for complete end-to-end interactions between hosts, with no concern for how to
    navigate between those two hosts. It described a rudimentary process for payload
    fragmentation and many of the headers that are still used in TCP today.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在IEN 2中描述的协议和接口描述了两个之前都由TCP执行的主要操作。首先，有**互联网主机-跳协议**，它将成为TCP。这是为了描述主机之间完整端到端交互的接口，而不关心如何在这两个主机之间导航。它描述了一个基本的负载分片过程和许多今天仍在TCP中使用的头部信息。
- en: The second protocol described was the **Internet Hop Interface**. It's this
    part of the IEN that described what would eventually become IP. The hops in this
    context are hops along a single edge in the network diagram between two nodes,
    or hosts. The goal of this section of the IEN was to define the minimum amount
    of information necessary to bundle with a packet to allow any step on the path
    to route it accordingly, without routing multiple instances of the same packet
    to the destination, and to allow fragmentation in such a way that the packet can
    be reassembled at the destination gateway.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的第二种协议是**互联网跳接口**。IEN的这一部分描述了最终成为IP的内容。在这个上下文中，“跳”是指网络图中两个节点或主机之间单条边上的跳。IEN的这一部分的目标是定义与数据包捆绑的最小必要信息，以便路径上的任何一步都能相应地路由它，避免将同一数据包的多个实例路由到目的地，并允许以这种方式进行分片，以便数据包可以在目的地网关重新组装。
- en: IPv1 to IPv3 – formalizing a header format
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv1到IPv3 – 正式化报头格式
- en: Over the course of the two years that followed, several more IENs were written
    to describe an evolving IP interface. Each of these, in their own way, formalized
    some detail of IP that would eventually become the broadly-released and universally
    supported IPv4\. Beginning with IPv1, as described by IEN 26, the first task engineers
    set to accomplish was defining the minimum necessary headers, along with their
    minimum necessary size specifications, to successfully route packets across an
    arbitrarily large and arbitrarily organized network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两年里，又编写了几个IEN来描述不断演变的IP接口。这些IEN各自以不同的方式，正式化了IP的一些细节，这些细节最终成为了广泛发布和普遍支持的IPv4。从IPv1开始，正如IEN
    26所描述的，工程师们设定的第一个任务是定义成功路由跨越任意大和任意组织的网络所需的最小必要报头，以及它们的最小必要大小规范。
- en: Without universal acceptance of some sort of header, there could ultimately
    be no internet as we know it today. However, until there was universal acceptance
    of some interface, members of the **Internet Engineering Task Force** (**IETF**)
    knew that their work would be subject to feedback and changes. As such, one of
    the primary tasks of the first IP header description was to allow for the support
    of multiple versions and multiple kinds of services exposed over those networks.
    Thus, the header described in IEN 26 introduced fields such as the IP version
    header, and the **type of service** (**TOS**) header.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 没有某种类型的报头的普遍接受，最终将无法出现我们今天所知道的互联网。然而，直到有某种接口的普遍接受，**互联网工程任务组**（**IETF**）的成员知道他们的工作将受到反馈和变化的制约。因此，第一份IP报头描述的主要任务之一是允许支持多个版本和多种在那些网络上暴露的服务。因此，IEN
    26中描述的报头引入了诸如IP版本报头和**服务类型**（**TOS**）报头等字段。
- en: Shortly after, in IEN 28, the team defined IPv2, which further crystallized
    the interface's header, as well as the process of fragmentation of packets over
    a network. This was also the first IEN to posit a mechanism for detecting packet
    corruption, though it provided no guidance on how that could be accomplished.
    Finally, it described a rudimentary addressing component of a packet, and the
    addressing mechanism for hosts on a network. However, it's worth noting that the
    mechanism described was not quite what was ultimately released to the broader
    public.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，在IEN 28中，团队定义了IPv2，这进一步明确了接口的报头以及网络上的数据包分片过程。这也是第一个提出检测数据包损坏机制的IEN，尽管它没有提供如何实现的指导。最后，它描述了数据包的基本寻址组件以及网络上的主机寻址机制。然而，值得注意的是，所描述的机制并非最终发布给更广泛公众的机制。
- en: IPv4 – establishing the IP
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv4 – 建立IP
- en: Over the course of several iterations on the protocol, the team worked through
    their design issues until, with IEN 54, they finalized the header definition that
    would be standardized by **Request for Comment** (**RFC**) 791, as IPv4\. With
    RFC 791, the IETF finally established the details of the operation and implementation
    of the IP standard. This version of the protocol has been in use across the globe
    since 1981, and even today, this interface specification is used on almost 80%
    of all datagrams sent between hosts on the internet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在对协议进行多次迭代的过程中，团队解决了他们的设计问题，直到IEN 54，他们最终确定了将被**请求评论**（**RFC**）791标准化的报头定义，即IPv4。随着RFC
    791的发布，IETF最终确立了IP标准的操作和实施细节。自1981年以来，该协议版本在全球范围内使用，即使今天，该接口规范也几乎用于互联网上主机之间发送的所有数据报的80%左右。
- en: The functions of IP
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP的功能
- en: As described in RCF 791, there are three primary functions that the IP is designed
    to provide for networks. In section 1.2 of that specification, the scope of the
    protocol is explicitly limited to just the functions necessary to deliver a package
    of bits (an internet datagram) from a source to a destination over an interconnected
    system of networks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如RFC 791所述，IP设计为网络提供三个主要功能。在该规范的1.2节中，协议的作用域被明确限制在仅提供将一个比特包（一个互联网数据报）从源传输到目的地的必要功能上，这些功能是在一个互联的网络系统中实现的。
- en: You'll note that nowhere in this definition do the authors mention reliability,
    ordered delivery, or connection negotiation. This is very much an intentional
    omission on their part. As they stated in IEN 2, attempting to account for those
    functions with a network layer protocol will be violating the boundaries of the
    OSI network stack. And that's not simply speculation on my part; in the definition
    of the scope of IP, the authors explicitly state that there are no mechanisms
    to augment end-to-end data reliability, flow control, sequencing, or other services
    found in host-to-host protocols. Here, by host-to-host protocols, the authors
    are referring to the responsibilities of transport layer protocols and interfaces.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在这个定义中，作者们没有提到可靠性、有序交付或连接协商。这完全是他们有意为之的省略。正如他们在IEN 2中所说的，试图用网络层协议来处理这些功能将违反OSI网络栈的边界。这不仅仅是我个人的推测；在IP作用域的定义中，作者们明确指出，没有机制来增强端到端数据可靠性、流量控制、排序或主机到主机协议中发现的其它服务。在这里，作者们指的是传输层协议和接口的职责。
- en: 'So, if reliable delivery, flow control, and sequencing are all outside the
    scope of IP, you may well be wondering what functions it is responsible for, and
    how it implements them. Well, according to the standard, IP is responsible for
    precisely two functions: addressing and fragmentation. The protocol provides these
    functions for the transport layer protocol above it, and it does so by leveraging
    the local network protocols of the data link layer below it.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果可靠的交付、流量控制和排序都不在IP的范围内，你可能很想知道它负责哪些功能，以及它是如何实现这些功能的。嗯，根据标准，IP精确负责两个功能：地址和分片。该协议为上层的传输层协议提供这些功能，它通过利用下层数据链路层的本地网络协议来实现这一点。
- en: Addressing for IP
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP地址
- en: Addressing is used to uniquely identify a host (or set of hosts) that can service
    requests over a network. Any device that must be located by other hosts on a network
    to which it's connected must have an address associated with it. This is the only
    mechanism by which the IP can request routing information from the data link layer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 地址用于唯一标识可以处理网络请求的主机（或一组主机）。任何必须被连接到其网络的其它主机定位的设备都必须有一个与其关联的地址。这是IP从数据链路层请求路由信息的唯一机制。
- en: Here, it's worth distinguishing between an address and a name, hostname, or
    domain name. Names, or hostnames, are the human-readable **Uniform Resource Identifier**
    (**URI**) structures, while an address is a unique, semantically structured key
    that indicates where the owner of a hostname resides. According to the IP standard,
    transport layer protocols are responsible for resolving a hostname to its specific
    address before passing the addressing information to the network layer to be transmitted
    to the next device in the route.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，区分地址和名称、主机名或域名是值得的。名称，或主机名，是供人类阅读的**统一资源标识符**（**URI**）结构，而地址是一个唯一、语义结构的键，指示主机名的所有者所在的位置。根据IP标准，传输层协议负责在将地址信息传递给网络层以传输到路由中的下一个设备之前，将主机名解析为其特定的地址。
- en: And here, a further distinction should be made between addressing, or identifying
    the sub-network and specific location of the target host, and routing, or finding
    the complete path from the source host to the destination host. Once a datagram
    is received by a host's IP interface, the destination address is validated, and
    the packet is fragmented, with all IP headers applied. Then, the datagram is passed
    along, and it is the responsibility of the data link layer to actually perform
    the task of routing along links and nodes in the network to find a connected path
    between the two hosts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应该进一步区分地址或识别目标主机的子网和特定位置，以及路由或找到源主机到目标主机之间的完整路径。一旦数据报被主机的IP接口接收，目标地址就会被验证，数据包会被分片，并应用所有IP头部。然后，数据报会被传递下去，而数据链路层负责在网络的链路和节点之间执行路由任务，以找到两个主机之间的连接路径。
- en: So, addressing functions of an IP implementation revolves around assigning addresses
    to new nodes on a network, and parsing and interpreting addresses attached to
    packets. When assigning new addresses, they are done with a fixed-length, semantically
    significant data key. A semantically significant data key is simply one in which
    meaning can be inferred from the structure of the key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，IP实现的地址功能围绕着在网络上为新节点分配地址，以及解析和解释附加到数据包上的地址。在分配新地址时，它们使用固定长度、语义上有意义的数值键。语义上有意义的数值键就是指可以从键的结构中推断出其含义的键。
- en: In the case of IP addresses, different segments of the address contain details
    about the specific location of the host that the IP address identifies. For example,
    in an early specification for address resolution, the first 8 bits of a 32-bit
    addressing scheme were used to locate the specific subnet in which the target
    host resided. The next 24 bits in the address serve as the address of the host
    within the local network's addressing scheme.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在IP地址的情况下，地址的不同部分包含有关IP地址标识的主机特定位置的信息。例如，在早期地址解析规范中，32位地址方案的前8位用于定位目标主机所在的具体子网。地址中的下一个24位在本地网络地址方案中作为主机的地址。
- en: The standards of the IP addressing scheme have grown and changed over the years
    to adapt to ever broadening networks and ever wider address spaces, but the principle
    of a well-formed, semantic key used as a host's address has remained unchanged
    since IPv4 was introduced in 1981.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络范围的不断扩展和地址空间的日益增大，IP地址方案的规范在多年中不断发展和变化，但自1981年IPv4引入以来，用作主机地址的良好格式化、语义键的原则保持不变。
- en: The fragmentation of packets
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据包分片
- en: The fact that IP is designed to facilitate hops between nodes in a network is
    why a specification for packet fragmentation (over the fragmentation that may
    already be performed at the transport layer) becomes necessary. Since each connected
    sub-network in the larger internet is free to specify its own constraints for
    packet size and delivery, there could be inconsistencies in the size and format
    requirements for a datagram as it moves across the network. It may well be the
    case that a datagram that is considered small enough by the sub-network of the
    originating host is actually too large for the sub-network of the target host.
    As such, it might be necessary for the IP implementation running on a router or
    bridge between two sub-networks to have to decompose or reassemble datagrams as
    they move between the two subnets.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP设计用于促进网络中节点之间的跳转，因此需要为数据包分片（在可能已在传输层执行的分片之上）制定规范。由于大型互联网中的每个连接子网都可以自由指定其自己的数据包大小和交付约束，因此在数据包穿越网络时，数据报的大小和格式要求可能会出现不一致。可能存在的情况是，由源主机子网认为足够小的数据报实际上对于目标主机子网来说太大。因此，运行在路由器或两个子网之间的桥上的IP实现可能需要在两个子网之间移动数据报时对其进行分解或重新组装。
- en: The specification does provide a mechanism for indicating that a datagram should
    not be fragmented under any circumstances. However, if the specifications of the
    data link layer prevent a datagram from being delivered without being fragmented,
    and the datagram is marked as do not fragment, then it is simply discarded instead.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 规范确实提供了一种机制，用于指示在任何情况下都不应将数据报分片。然而，如果数据链路层的规范阻止数据报在不分片的情况下交付，并且数据报被标记为不分片，那么它就会被简单地丢弃。
- en: 'The actual process of fragmenting is defined by the standard as a general system
    for decomposing a longer datagram into some number, *n*, of smaller datagrams.
    The datagrams are broken up into smaller frames of binary data, with additional
    headers added incorporated to allow for the reconstruction of the smaller datagrams
    into an appropriate recreation of the original, larger datagram. Those additional
    fields added to the smaller datagrams are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 标准定义了分片过程的实际步骤，作为一个将较长的数据报分解成若干个较小数据报的通用系统。数据报被分解成更小的二进制数据帧，并添加额外的头部信息，以便将这些较小的数据报重新组合成适当大小的原始数据报。添加到较小数据报中的额外字段如下：
- en: '**Offset**: The position in the datagram that the new fragment came from. This
    allows for the proper reordering of datagram fragments that may have been delivered
    out of order.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏移量**：新分片在数据报中的位置。这允许正确地重新排序可能已经乱序交付的数据报片段。'
- en: '**Length**: This specifies the length of the content that was pulled out of
    the original datagram and stored in the payload of the current fragment.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**：这指定了从原始数据报中提取并存储在当前分片有效载荷中的内容的长度。'
- en: '**Identification field**: The new, smaller fragments also use an identification
    number to specify which larger datagram they belong to. This helps ensure that
    smaller fragments from different parent datagrams are not mixed up during recomposition.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符字段**：新的、较小的分片也使用一个标识符来指定它们属于哪个较大的数据报。这有助于确保在重组过程中，来自不同父数据报的较小片段不会混淆。'
- en: '**More-fragments flag**: Finally, there is a more-fragments flag field used
    to indicate whether or not there are additional smaller fragments that need to
    be added to the reconstructed parent datagram.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更多分片标志**：最后，有一个更多分片标志字段，用于指示是否需要将额外的较小分片添加到重建的父数据报中。'
- en: These fields taken together – offset, length, identification, and more-fragments
    – are sufficient to reconstruct a datagram from an arbitrary number of fragments
    on the destination host. The generalized nature of the description in the RFC
    that we've seen here allows for reliable fragmentation and recomposition in almost
    any use case across any network gateway, router, or subnet interface. Now that
    we understand what the protocol was designed to accomplish, let's look at how
    it has been implemented and deployed since its inception.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段（偏移量、长度、标识符和更多分片）结合起来，足以从任意数量的片段在目标主机上重建一个数据报。我们在RFC中看到的描述的通用性质允许在几乎任何网络网关、路由器或子网接口的任何用例中进行可靠的分片和重组。现在我们了解了该协议旨在实现的目标，让我们看看自其诞生以来是如何实施和部署的。
- en: IPv4 and its limits
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv4及其限制
- en: First defined in 1981, and widely deployed in 1983, IPv4 has been the standard
    for network layer interactions across the whole of the internet, and almost every
    local area network, for over three decades now. As I mentioned before, nearly
    80% of all internet traffic is done using the IPv4 specification of the IP interface.
    Its stability, scalability, and reliability have been well-proven at this point.
    So, what is it about IPv4 that made its implementation of network layer responsibilities
    so successful? And what was it about the IPv4 specification that precipitated
    the need, after such a long and successful lifespan, to define and deploy a new
    protocol with IPv6?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 1981年首次定义，并于1983年广泛部署，IPv4已经成为整个互联网以及几乎所有局域网网络层交互的标准，至今已有三十多年的历史。正如我之前提到的，几乎所有互联网流量都是使用IP接口的IPv4规范完成的。它的稳定性、可扩展性和可靠性已经得到了充分证明。那么，IPv4的哪些特性使其在网络层责任实施上如此成功？IPv4规范中的哪些特性在如此漫长且成功的历史之后，促使定义和部署新的IPv6协议？
- en: The addressing standard of IPv4
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv4的寻址标准
- en: As I mentioned in the previous section on the addressing functions of IP, the
    address of IPv4 is designed with a semantic structure, as opposed to simply having
    an arbitrary key allocated for each new device on a network. So, provided you
    understand how to parse the semantic meaning of an address, determining the specific
    location of a host can be done through a hierarchical analysis of each segment
    of an address.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在关于IP寻址功能的上一节中提到的，IPv4的地址设计具有语义结构，而不是简单地为网络上的每个新设备分配一个任意的键。因此，只要你理解如何解析地址的语义意义，就可以通过分析地址的每个段来进行分层分析，从而确定主机的具体位置。
- en: The IPv4 address syntax
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv4地址语法
- en: Addresses in IPv4 are 32-bits long, and are typically divided into four octets
    (bytes), separated by a decimal, with each byte expressed in its base-10 notation.
    However, the underlying structure of the address is flexible enough to be expressed
    as anything from the dot-decimal notation, to a raw base-10 integer representation
    of the 32-bit value, to hexadecimal, to a dotted hexadecimal format. Each of these
    representations is merely a different way of expressing the same binary value.
    In this way, the syntactical representation of a given IP address is unimportant,
    since the semantic meaning is preserved by the underlying 32-bit representation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址是32位的，通常分为四个八位字节（字节），由十进制分隔，每个字节以十进制表示。然而，地址的底层结构足够灵活，可以表示为从点十进制表示法，到32位值的原始十进制整数表示，到十六进制，到点十六进制格式。这些表示法中的每一种都只是表达相同二进制值的不同方式。因此，给定IP地址的语法表示法并不重要，因为底层32位表示法保留了语义意义。
- en: 'So, let''s consider the following IPv4 address:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们考虑以下IPv4地址：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This probably doesn''t seem familiar to you as an IP address,  at least, not
    in that representation. So, let''s look at how we can express this in a way we''d
    more easily recognize as an IP address. We''ll start by separating the binary
    representation into four octets:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对你来说并不熟悉，作为一个IP地址，至少不是以那种形式。那么，让我们看看我们如何以我们更容易识别为IP地址的方式表达它。我们将首先将二进制表示分为四个八位字节：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we''ll convert each of the dot-delimited bytes and convert their values
    to the corresponding base-10 representation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将每个以点分隔的字节转换为它们的十进制表示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And, just like that, we have an IP address format that we''re more familiar
    with. However, we could have just as easily converted the string to its hexadecimal-dot
    notation, and gotten the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们得到了一个我们更熟悉的IP地址格式。然而，我们同样可以将字符串转换为它的十六进制点表示法，并得到以下结果：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As long as we preserve the ordering of the octets, the meaning remains true,
    and can provide us with useful information for routing requests to the given address.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们保持八位字节的顺序，意义就保持不变，并且可以为我们提供有关将路由请求发送到给定地址的有用信息。
- en: Classful IP addressing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别IP寻址
- en: With IPv4, the value of each octet in an address can carry with it hierarchical
    routing information about the host at that address. When the protocol version
    was first defined, there was a specification that the first octet of an address
    value would designate the subnet to which the host belonged. This was dubbed the
    network field. The remaining three octets were then left to designate the address
    within that subnet at which the host could be found. These octets, together, were
    commonly called the **rest field**, short for the **rest of the address**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，地址中每个八位字节的值可以携带关于该地址主机分层路由信息。当协议版本最初定义时，有一个规定，即地址值的第一个八位字节将指定主机所属的子网。这被称为网络字段。剩下的三个八位字节被用来指定主机在该子网中的地址。这些八位字节共同被称为**剩余字段**，简称**地址的其余部分**。
- en: Now, if you're on top of your binary math, you will have already recognized
    the issue with the structure that I just described. With only a single octet to
    designate a subnet, there could only be, at most, `255` subnets on the whole of
    the internet. Such a limitation was almost immediately recognized as infeasible,
    and so the standards document included a provision for different classes of addressing
    schemes. Described in RFC 791, there were three specific classes of IP addresses,
    each of which used a different number of bits to specify the subnet of a host,
    and with each having their own unique limits on the maximum number of hosts on
    a given subnet.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你对二进制数学很熟悉，你可能会已经意识到了我刚才描述的结构问题。由于只有一个八位字节来指定子网，整个互联网上最多只能有`255`个子网。这种限制几乎立即被认定为不可行，因此标准文档中包含了针对不同类别的寻址方案的规定。在RFC
    791中描述了三种特定的IP地址类别，每个类别使用不同数量的位来指定主机的子网，并且每个类别都有其自己独特的最大主机数限制。
- en: 'At the time that the RFC was drafted, there were only about `64` subnets in
    existence, meaning at most, that only the six least significant bits of the network
    field had been used to designate a known subnet, up to that point. Not wanting
    to reassign widely used subnet addresses, the most significant bits of the network
    field were set for use as the class flags for a given IP address. In the original
    RFC, there were three well-defined classes of IP structure, with a fourth left
    open for future specification as need demanded. These original three classes were
    defined as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC被起草的时候，只有大约`64`个子网存在，这意味着最多只有网络字段的六个最低有效位被用来指定已知的子网，直到那时。为了避免重新分配广泛使用的子网地址，网络字段的最高有效位被设置为用于指定给定IP地址的类标志。在原始RFC中，有三个定义良好的IP结构类，第四个留作未来根据需要指定的开放类。这三个原始类被定义为如下：
- en: '**Class A**: In a **Class A** address, the most significant bit is zero, and
    the next seven bits are to be used for subnet identification. This leaves the
    remaining three octets as the rest field, allowing for up to `16,777,215` possible
    unique host addresses within a subnet identified by a **Class A** address.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A类**：在一个**A类**地址中，最高有效位为零，接下来的七个位用于子网标识。这留下剩余的三个八位作为其余字段，允许在一个由**A类**地址标识的子网中有多达`16,777,215`个可能的唯一宿地址。'
- en: '**Class B**: In a **Class B** address, the most significant bit of the address
    has a value of `1`, and the second most significant bit has a value of `0`. The
    next 14 bits of the address are used for subnet identification, leaving the two
    least significant octets available for unique host addresses within the subnet.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B类**：在一个**B类**地址中，地址的最高有效位值为`1`，次高有效位值为`0`。地址的接下来的14位用于子网标识，留下两个最低有效八位用于子网内唯一的宿地址。'
- en: '**Class C**: Finally, in a **Class C** address, the first two most significant
    bits of the address have a value of `1`, while the third most significant bit
    has a value of `0`. With these values in the three most significant bits, the
    next 21 bits are to be used for subnet identification, allowing for `2,097,151`
    unique possible subnets. This leaves only the final octet for host addressing,
    leaving at most `255` host addresses available in a **Class C** IP address.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C类**：最后，在一个**C类**地址中，地址的前两个最高有效位值为`1`，而第三个最高有效位值为`0`。在这三个最高有效位中的这些值，接下来的21位用于子网标识，允许有`2,097,151`个可能的唯一子网。这仅留下最后一个八位用于宿地址标识，在一个**C类**IP地址中最多只有`255`个宿地址可用。'
- en: 'To further illustrate how these classes are semantically parsed, consider the
    following three IP addresses:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这些类在语义上的解析方式，考虑以下三个IP地址：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, by converting each address to their dot-binary representation, we can
    examine the most significant digits to determine the class of IP address under
    which each of them falls:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过将每个地址转换为它们的点二进制表示，我们可以检查最高有效位来确定每个地址属于哪个IP地址类。
- en: '![](img/f7dc5ef3-ae5c-4849-a973-ad47c7d670ef.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7dc5ef3-ae5c-4849-a973-ad47c7d670ef.png)'
- en: However, restricting use of the three most significant bits to indicate the
    class of a network was an untenable long-term solution. Soon enough, the IETF
    devised a new mechanism for determining the network field of an IP address.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将三个最高有效位限制用于指示网络类是一个不可持续的长期解决方案。不久之后，IETF设计了一种新的机制来确定IP地址的网络字段。
- en: Subnet masking
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子网掩码
- en: By 1993, the available pool of IP addresses under the classful address architecture
    was depleting at an untenable rate (a problem that we'll discuss more later).
    To mitigate this challenge, the IETF did away with the classful architecture described
    by RFC 791, and introduced the **Classless Inter-Domain Routing (CIDR)** address
    syntax. The CIDR syntax applies an additional, optional suffix to an IP address
    that is used to indicate precisely how many bits of the address are dedicated
    to the network field. The suffix is delimited with a leading `/` character, and
    then an integer that denotes how many leading 1s are in the subnet mask.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到1993年，在类地址架构下的可用IP地址池以不可持续的速度耗尽（我们将在稍后讨论这个问题）。为了减轻这一挑战，IETF废除了由RFC 791描述的类地址架构，并引入了**无类域间路由（CIDR）**地址语法。CIDR语法在IP地址上应用了一个额外的、可选的后缀，用于精确指示地址中有多少位是用于网络字段。后缀由一个开头的`/`字符分隔，然后是一个整数，表示子网掩码中有多少个前导`1`。
- en: 'If the term **subnet mask** sounds familiar, you''ve likely seen it in the
    diagnostic output when you''ve run the `ipconfig` command in your terminal. The
    term **mask** in this context specifically refers to a bitwise mask. Basically,
    when you apply a mask to another binary number, the result is a `1` value in any
    position in which at least one of the two numbers has a `1` value. Consider the
    following IP address:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果术语**子网掩码**听起来很熟悉，你可能在你终端中运行`ipconfig`命令时的诊断输出中见过它。在这个上下文中，术语**掩码**特指位掩码。基本上，当你将掩码应用于另一个二进制数时，结果是在两个数中至少有一个为`1`的任何位置上都有一个`1`值。考虑以下IP地址：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And then the following subnet mask:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是以下子网掩码：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result of applying the mask to the IP address will be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将掩码应用于IP地址的结果如下：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, in this example, if we convert our binary to its dot-decimal notation,
    we''ve got an IP address as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，如果我们将我们的二进制数转换为点十进制表示法，我们得到的IP地址如下：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And we also have the following subnet mask:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下子网掩码：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What this subnet mask does is indicate to a routing device what bits of the
    IP address are to be used for network identification. So, since the subnet mask
    we just looked at had all `1` values for the first 24 most significant bits, this
    means those first 24 bits should be used as the network identifier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子网掩码的作用是指示路由设备哪些IP地址的位应该用于网络识别。因此，因为我们刚才查看的子网掩码的前24位都是`1`，这意味着这前24位应该用作网络标识符。
- en: This specific subnet mask will likely look pretty familiar to you since it's
    the default local subnet and subnet mask for most modern routers. The sub-network
    identified by this IP address is the one created by your home router, which serves
    as a gateway between the wider internet and your home network. What this means,
    though, is that for any given household with a single router, there is a maximum
    number of devices that can be connected to the network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的子网掩码可能对你来说很熟悉，因为它是最现代路由器的默认本地子网和子网掩码。这个IP地址所标识的子网是由你的家用路由器创建的，它作为更广泛互联网和你的家庭网络之间的网关。但是，这意味着对于任何只有一个路由器的家庭，可以连接到网络的最大设备数量是有限的。
- en: 'Using the notation of CIDR, that same IP address and subnet mask combination
    is expressed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CIDR的表示法，相同的IP地址和子网掩码组合如下表示：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This gives us what's called **variable-length subnet masking** (**VLSM**). It
    allows us to use any arbitrary number of bits for network identification without
    having to reserve the most significant bits as flag values. This means that IP
    addresses could be used to identify a much larger set of unique sub-networks,
    and those networks could have a wider variety of maximum sizes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就产生了所谓的**可变长度子网掩码**（**VLSM**）。它允许我们使用任意数量的位进行网络识别，而无需保留最高位作为标志值。这意味着IP地址可以用来识别更大的一组唯一子网，而这些网络可以有更广泛的最大尺寸范围。
- en: Address space exhaustion
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址空间耗尽
- en: All of this work of adapting the standard to allow for a broader flexibility
    in the address syntax was done primarily to mitigate perhaps the greatest limitation
    of IPv4\. I've alluded to it before, but the address specification for IPv4 allows
    for a maximum of 32 bits for an address. This means that the maximum number of
    unique IP addresses, no matter how you structure your network field and rest field,
    will always be at most `4,294,967,296` unique addresses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些将标准适应以允许地址语法的更大灵活性的工作主要是为了减轻IPv4可能的最大限制。我之前已经提到过，IPv4的地址规范允许地址最多有32位。这意味着无论你如何结构化你的网络字段和其余字段，最大唯一IP地址的数量始终是`4,294,967,296`个。
- en: In 1983, when IPv4 was standardized, the internet remained nothing more than
    an experiment. Certainly, the engineers working on the IETF had the foresight
    to expect their network experiment would eventually grow to the span the world.
    But the development of IPv4 was done on the assumption that their specific networking
    experiment wouldn't extend beyond the computer networks of ARPA. However, even
    as they saw the widespread adoption of their standard on hosts across the nascent
    internet, there was still an assumption that 4.3 billion unique addresses would
    provide ample time to devise a workable alternative before the address space was
    exhausted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在1983年，当IPv4被标准化时，互联网还只是一个实验。当然，在IETF工作的工程师们有远见，预计他们的网络实验最终会扩展到覆盖整个世界。然而，IPv4的发展是基于他们的特定网络实验不会超出ARPA的计算机网络。然而，即使他们看到他们的标准在新兴互联网上的广泛应用，仍然有一个假设，即430亿个唯一地址将提供足够的时间在地址空间耗尽之前设计出一个可行的替代方案。
- en: What they didn't predict though, was the rate at which computers would increase
    in power, and decrease in cost. This combination resulted in an explosion in the
    consumer computer market, and with it, an explosion in networked hosts in need
    of addresses. As the new millennium approached, so too did the assignment of the
    last available IPv4 address. And so, in 1998, a draft standard for the next IP
    version was released.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 他们没有预料到的是，计算机的功率会增加，成本会降低的速度。这种组合导致了消费计算机市场的爆炸性增长，随之而来的是需要地址的网络主机数量的爆炸性增长。随着新世纪的临近，最后可用的IPv4地址的分配也随之而来。因此，在1998年，发布了下一个IP版本的草案标准。
- en: IPv6 – the future of the protocol
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 – 协议的未来
- en: Designed to overcome an insufficient number of valid addresses for network hosts,
    IPv6 was first introduced in 1998, though it was only accepted as a formal standard
    in 2017 (which goes to show how diligent engineers can be about defining standards).
    The new specification was written to deal with a small number of issues presented
    by IPv4, including the limited address space. The standard also has native support
    for multicast transmission, as well as **IP security** (**IPSec**) security features.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 设计用来克服网络主机有效地址数量不足的问题，IPv6首次在1998年被引入，尽管它直到2017年才被正式接受为标准（这也说明了工程师在定义标准方面的勤奋）。新的规范是为了处理IPv4提出的一些问题而编写的，包括有限的地址空间。该标准还支持多播传输，以及**IP安全**（**IPSec**）安全特性。
- en: The IPv6 addressing scheme
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6地址方案
- en: Where IPv4 had a 32-bit addressing mechanism, allowing for a maximum of about
    4.3 billion unique addresses, the IPv6 standard provides a 128-bit addressing
    scheme, allowing for 3.4 x 10^(38) unique addresses. That's 340 billion addresses!
    For a bit of context, the scheme allows for more addresses than there are meters
    from the surface of the earth to the edge of the observable universe. With such
    a large addressing space, the IPv6 scheme allows for simpler address allocation,
    route aggregation, and unique addressing features that we'll look at later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与IPv4有32位地址机制，允许最多有约430亿个唯一地址相比，IPv6标准提供了一个128位的地址方案，允许有3.4 x 10^(38)个唯一地址。那就是3400亿个地址！为了有一点背景，该方案允许的地址数量比从地球表面到可观测宇宙边缘的米数还要多。有了如此大的地址空间，IPv6方案允许更简单的地址分配、路由聚合和我们将要探讨的唯一地址特性。
- en: 'These 128 bits are organized into eight groups of 16 bits each. These groups
    are typically written as four hexadecimal digits (as opposed to the integral representation
    typical in IPv4), with each grouping separated by a colon. However, for the sake
    of minimizing the size of a packet header, there is a standard for abbreviating
    IPv6 addresses without the loss of meaningful information. The two steps to follow
    for address abbreviation are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这128位被组织成每组16位的八个组。这些组通常以四个十六进制数字的形式书写（与IPv4中典型的整数表示形式不同），每个分组之间用冒号分隔。然而，为了最小化数据包头的大小，有一个标准可以缩写IPv6地址，而不会丢失有意义的信息。地址缩写的两个步骤如下：
- en: Remove any leading zeros in any 16-bit (or four hexadecimal) segment of the
    route
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除路由中任何16位（或四个十六进制）段的前导零
- en: Eliminate exactly one consecutive string of remaining zeros, and replace the
    removed segments with `**:**`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除一个连续的零字符串，并用`**:**`替换被删除的部分
- en: 'To see this in action, let''s start with the following address:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这一过程在实际中的应用，让我们从以下地址开始：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, after applying step 1, we have the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在应用步骤1之后，我们有以下内容：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, removing the longest string of consecutive zeros, we have the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，移除最长的连续零字符串，我们得到以下内容：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While this representation is substantially smaller, it's only really used as
    a convenience. The packet header for an IPv6 packet is configured to use the full
    128-bit address for the source and destination of the packet, so, prior to transmission,
    the full address is applied to the packet regardless of how short it can be abbreviated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种表示方式在实质上更小，但它实际上只用作便利。IPv6数据包的报头被配置为使用完整的128位地址作为数据包的源地址和目的地址，因此，在传输之前，无论缩写得多短，完整的地址都会应用到数据包上。
- en: Network fields and routing efficiency
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络字段和路由效率
- en: With IPv4, a considerable amount of work was put into allocating sufficient
    space for a subnet identifier within the limited 32-bit addresses. However, since
    IPv6 is designed with such a vast address space, network identification is greatly
    simplified. All IPv6 addresses allocate the most significant 64 bits to subnet
    addressing, and the remaining 64 bits to host, or interface identification.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，人们投入了大量工作来在有限的32位地址内分配足够的空间用于子网标识符。然而，由于IPv6设计时考虑到了如此庞大的地址空间，网络标识大大简化。所有IPv6地址都将最重要的64位分配给子网寻址，而将剩余的64位分配给主机或接口标识。
- en: One of the simplest things this enables is more efficient processing by routers
    and network switches. Because the network identifier and host addresses are always
    of a fixed length, and those lengths are well-aligned with word length in 32-
    and 64-bit hardware, routers can parse the structure of the address with much
    greater efficiency.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得路由器和网络交换机能够更有效地处理数据。因为网络标识符和主机地址总是固定长度的，并且这些长度与32位和64位硬件的字长很好地对齐，因此路由器可以更高效地解析地址结构。
- en: Fragmentation in IPv6
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6中的分片
- en: Another major change between IPv4 and IPv6 comes in the delegation of responsibility
    to fragment packets appropriately for their route. With IPv4, this was explicitly
    a concern for the network layer, and one that IPv6 sought to solve. The guidance
    provided for the fragmentation of a data packet was a major part of the RFC that
    defined IPv4\. Meanwhile, with IPv6, packet fragmentation is considered the joint
    responsibility of the transport layer and the data link layer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4和IPv6之间，另一个主要的变化在于对数据包进行适当分片以适应其路由的责任分配。在IPv4中，这明确是网络层的关注点，IPv6试图解决这个问题。关于数据包分片提供的指导是定义IPv4的RFC中的一个重要部分。与此同时，在IPv6中，数据包分片被认为是传输层和数据链路层的共同责任。
- en: The idea behind this change in responsibilities is the assertion that there
    should be a step in the end-to-end protocols of the transport layer. That step
    is nothing but determining the maximum packet size allowable along a route between
    two hosts. Meanwhile, the **Maximum Transmission Unit** (**MTU**) of every edge
    along a route between two hosts should be discoverable from the data link layer
    when the transmission is initiated. In cases of failure to discover the MTU of
    the specific route between two hosts, the transport layer should fall back to
    the default MTU of the internet, which is 1280 bytes of data. Thus, in an ideal
    case, the data link layer can provide the specific route MTU and the transport
    layer can fragment its packets accordingly. If the data link layer fails to provide
    the route's MTU, the transport layer uses a worst-case fragment size of the default
    MTU, that is, 1,280 bytes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种责任变化背后的理念是断言，在传输层的端到端协议中应该有一个步骤。这个步骤就是确定两个主机之间路由上允许的最大数据包大小。同时，两个主机之间路由的每个边缘的**最大传输单元**（**MTU**）应在传输开始时从数据链路层可发现。在无法发现两个主机之间特定路由的MTU的情况下，传输层应回退到互联网的默认MTU，即1280字节的数据。因此，在理想情况下，数据链路层可以提供特定路由的MTU，而传输层可以相应地分片其数据包。如果数据链路层未能提供路由的MTU，传输层将使用默认MTU的最坏情况分片大小，即1280字节。
- en: IPv6 to IPv4 interfaces
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6到IPv4接口
- en: Because IPv6 so fundamentally alters the structure of the IPv4 packet header,
    the two versions are entirely incompatible. This obviously poses a problem when
    network engineers need to support the widely deployed IPv4 over the whole lifetime
    of the transition to IPv6\. To facilitate that transition, a number of intermediary
    solutions have been devised to allow IPv6 traffic to function over IPv4 networks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IPv6从根本上改变了IPv4数据包头部的结构，这两个版本完全不兼容。当网络工程师需要在整个IPv4向IPv6过渡的整个生命周期内支持广泛部署的IPv4时，这显然是一个问题。为了促进这一过渡，已经设计出一些中间解决方案，以允许IPv6流量在IPv4网络上运行。
- en: Side-by-side IP deployment
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行IP部署
- en: The simplest way to get IPv4 and IPv6 to coexist on a single network is to have
    each host on that network deploy a full protocol implementation of each version.
    This is commonly done at the operating system (OS) level and allows traffic travelling
    to and from a single hardware interface to interact with both IP versions once
    the physical data transmission is delivered to the OS. Devices that use this side-by-side
    deployment will acquire an address for IPv4 and IPv6 simultaneously, and if the
    host has a registered domain name, that domain name will be resolved for both
    address schemes by a DNS server. Of course, the obvious downside here is that
    a side-by-side deployment is only as good as the subnet to which it is deployed.
    If a host supports both protocols, but exists on a network that only supports
    IPv4, then there's no benefit to be gained. In a strictly controlled sub-network,
    however, side-by-side deployment is a viable and often simple option.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个网络上使IPv4和IPv6共存的最简单方法是在该网络上的每个主机部署每个版本的完整协议实现。这通常在操作系统（OS）级别完成，并允许流量在到达和离开单个硬件接口时与两个IP版本交互，一旦物理数据传输被交付给操作系统。使用这种并行部署的设备将同时获得IPv4和IPv6的地址，如果主机有一个注册的域名，该域名将由DNS服务器解析为这两种地址方案。当然，这里的明显缺点是并行部署的效果仅与部署的子网一样好。如果一个主机支持两种协议，但存在于仅支持IPv4的网络中，那么就没有任何好处。然而，在一个严格控制的子网中，并行部署是一个可行且通常简单的选项。
- en: Tunneling interfaces
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隧道接口
- en: The other alternative for the cross-version support of IP traffic is known as
    **tunneling**. This is a mechanism by which IPv6 traffic is tunneled over an IPv4
    network by wrapping the IPv6 packet in an IPv4 packet. This process is described
    in RFC 4213, and is widely used by servers leveraging strictly IPv6 packet schemes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: IP流量跨版本支持的另一种替代方案被称为**隧道**。这是一种通过将IPv6数据包封装在IPv4数据包中来在IPv4网络上隧道传输IPv6流量的机制。这一过程在RFC
    4213中有描述，并被严格使用IPv6数据包方案的服务器广泛采用。
- en: One of the most popular tunneling schemes, **Teredo**, is consistently used
    for integrating an IPv6 sub-network onto the wider IPv4 internet. The mechanism
    by which Teredo accomplishes this is by leveraging our old friend, UDP. The IPv6
    packets are wrapped in a UDP packet header, which is itself wrapped in an IPv4
    packet. The IPv4 packets are routed normally, until received by a Teredo client
    or server, which is configured specifically to decompose the IPv4 packets into
    their original IPv6 structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的隧道方案之一，**Teredo**，一直被用来将IPv6子网集成到更广泛的IPv4互联网中。Teredo实现这一目标的方式是通过利用我们的老朋友，UDP。IPv6数据包被封装在一个UDP数据包头部中，而这个UDP头部本身又被封装在一个IPv4数据包中。IPv4数据包按正常路由，直到被配置为专门分解IPv4数据包为原始IPv6结构的Teredo客户端或服务器接收。
- en: While this is useful information for any network engineer, though, as C# developers,
    we are lucky enough to not need to concern ourselves with the details of these
    interfaces. While we have access to the specific IP information from any network
    traffic in our software, the translation and parsing of IP packets is mostly abstracted
    away from us. So, let's look now at how we can investigate and understand the
    nature of IP traffic within our software.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对任何网络工程师来说都是有用的信息，但作为C#开发者，我们很幸运，不需要关心这些接口的细节。虽然我们可以从软件中的任何网络流量中获取特定的IP信息，但IP数据包的翻译和解析主要被抽象化，不为我们所知。因此，现在让我们看看我们如何调查和理解软件中IP流量的本质。
- en: Leveraging IP in C#
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中利用IP
- en: Since C# and the .NET Core runtime will abstract away most of the details of
    IP interactions from our application software, this demonstration will be relatively
    simple. What we're going to write is a simple web API that simulates a DNS name
    resolution. We'll use a simple JSON file to store domain names and their associated
    addresses and provide an instance of the `IPAddress` class (or a list of instances
    of it) as our response. This will demonstrate how the language provides a lot
    of parsing and negotiation behind the scenes for you, and how that can streamline
    your development process considerably. And since we've been working with IP addresses
    and ports throughout this book, much of this should seem familiar to you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C# 和 .NET Core 运行时会从我们的应用程序软件中抽象出大多数 IP 交互的细节，所以这个演示将相对简单。我们将编写一个简单的 Web
    API 来模拟 DNS 名称解析。我们将使用一个简单的 JSON 文件来存储域名及其相关地址，并提供 `IPAddress` 类（或其实例列表）的一个实例作为我们的响应。这将展示语言在幕后为您提供了大量的解析和协商，以及这如何显著简化您的开发过程。而且，因为我们一直在本书中处理
    IP 地址和端口，所以其中很多内容应该对您来说都很熟悉。
- en: Setting up our server
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的服务器
- en: 'We''ll be using a simple web API project for this, so we''ll create it with
    the **command-line** **interface** (**CLI**):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的 Web API 项目来完成这个任务，因此我们将使用 **命令行界面**（**CLI**）来创建它：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once that''s up, we''ll go ahead and remove all of the scaffolded endpoints
    in our controller except for our POST endpoint. This will be the route by which
    users will look up hostnames from our DNS server. We''ll also modify our route
    to more accurately express what our API provides. So, before we start coding,
    our controller should appear as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，我们将从我们的控制器中移除所有除 POST 端点之外的所有脚手架端点。这将是通过用户从我们的 DNS 服务器查找主机名的路由。我们还将修改我们的路由，以更准确地表达我们的
    API 提供的内容。因此，在我们开始编码之前，我们的控制器应该如下所示：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we''ll need to add a simple host registry for our application to perform
    lookups on. So, create a JSON file that represents a list of key-value pairs.
    The keys will be the hostnames we''re performing lookups on, and the values will
    be an array of string representations of arbitrary IP addresses. And for demo
    purposes, be sure to use both IPv4 and IPv6 addresses in our file. Mine looks
    like this, but yours can have whatever hostnames and addresses you feel like using:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的应用程序添加一个简单的主机注册表，以便执行查找。因此，创建一个表示键值对的 JSON 文件。键将是我们在执行查找的主机名，值将是任意
    IP 地址的字符串表示的数组。并且为了演示目的，确保在我们的文件中使用 IPv4 和 IPv6 地址。我的文件看起来像这样，但您的可以使用您喜欢的任何主机名和地址：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As a final setup step, we''ll just add a simple static class to make our `hosts.json`
    file easier to work with from within our controller. To do that, we''ll create
    a `Hosts` static class, give it a single public property called `Map`, and then
    use the static constructor feature of C# to initialize the `Map` property with
    the contents of our JSON file. Then, whenever we need to access our hosts file,
    we do so with a static reference to our `Hosts.Map` method and `query` its dictionary
    accordingly. This pattern is incredibly simple, and incredibly useful for providing
    straightforward and easily understandable access to static content files in your
    application code. Our example appears as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的设置步骤，我们将添加一个简单的静态类，以便从我们的控制器中更容易地处理 `hosts.json` 文件。为此，我们将创建一个 `Hosts`
    静态类，给它一个名为 `Map` 的单个公共属性，然后使用 C# 的静态构造函数特性来初始化 `Map` 属性，使其包含我们的 JSON 文件的内容。然后，每次我们需要访问我们的主机文件时，我们都会通过到
    `Hosts.Map` 方法的静态引用来这样做，并相应地查询其字典。这种模式非常简单，也非常有用，可以为您的应用程序代码提供直接且易于理解的静态内容文件访问。我们的示例如下所示：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And with that, we're ready to implement our IP lookup.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经准备好实现我们的 IP 查找。
- en: IP parsing in C#
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 中的 IP 解析
- en: Now that we're ready to read from our hosts file, we can start parsing incoming
    requests and returning IP information for our consumers as a JSON string. As with
    all of our demo code, we'll assume we're getting well-formed inputs and ignore
    error handling for the time being.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好从主机文件中读取，我们可以开始解析传入的请求，并以 JSON 字符串的形式返回给我们的消费者 IP 信息。就像我们所有的演示代码一样，我们将假设我们得到的是格式良好的输入，并且暂时忽略错误处理。
- en: 'Our inputs will be a fully-qualified URI, and so we''ll initialize a temporary
    URI variable to allow easier domain name acquisition:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入将是一个完全限定的 URI，因此我们将初始化一个临时的 URI 变量，以便更容易地获取域名：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we''ll try to access the IP addresses for the hostname in our `Hosts.Map`
    method. If it fails, we''ll defer to the outer DNS server, and return whatever
    addresses it can provide for our hostname. We''ll do this using a utility method
    written to serialize `IPAddress` arrays into a string, called `GetSerializedIpAddresses()`,
    which we''ll look at later. For now, though, the important thing to understand
    is that our fallback when we can''t find the hostname in our own server registry
    is to look to an outer DNS server for our name resolution:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试访问`Hosts.Map`方法中的主机名对应的IP地址。如果失败，我们将回退到外部的DNS服务器，并返回它为我们的主机名提供的任何地址。我们将使用一个名为`GetSerializedIpAddresses()`的实用方法来完成这项工作，该方法将`IPAddress`数组序列化为字符串，我们稍后会讨论它。现在，重要的是要理解，当我们无法在我们的服务器注册表中找到主机名时，我们的回退是查找外部的DNS服务器以进行名称解析：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once we''ve made it past this point, we know that we hold the `IPAddress` entries
    for the requested host, and we can use C#''s `IPAddress` class to parse them accordingly.
    So, first, we''ll create a container for our `IPAddress` instances. Then, we''ll
    attempt to initialize each instance using the `IPAddress.TryParse()` method. Assuming
    that succeeds (which it does in my example, and provided you have well-formed
    IP addresses in your own file, it will with yours too), we add the new `IPAddress`
    instances to our list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过了这一点，我们就知道我们拥有了请求主机的`IPAddress`条目，我们可以使用C#的`IPAddress`类来相应地解析它们。所以，首先，我们将为我们的`IPAddress`实例创建一个容器。然后，我们将尝试使用`IPAddress.TryParse()`方法初始化每个实例。假设这成功了（在我的例子中是这样，并且假设你自己的文件中有良好格式的IP地址，它也会在你的文件中成功），我们将新的`IPAddress`实例添加到我们的列表中：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you've followed my example up to this point, you'll find that the `TryParse()`
    method of the `IPAddress` class will automatically detect and account for each
    of the addressing schemes that I've discussed so far. We could add everything
    from a human readable dot-decimal-formatted IPv4 address, to an abbreviated IPv6
    address, to a raw 32-bit binary string, and the `TryParse()` method will build
    the address accordingly. This kind of utility is why the software demo for this
    chapter can be so light. Almost all the heavy lifting is done for you by the .NET
    Core runtime.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直按照我的例子做，你会发现`IPAddress`类的`TryParse()`方法会自动检测并处理我之前讨论的所有寻址方案。我们可以添加从人类可读的点分十进制格式的IPv4地址，到简化的IPv6地址，再到原始的32位二进制字符串，`TryParse()`方法会相应地构建地址。这种实用工具是为什么本章的软件演示可以如此轻量。几乎所有繁重的工作都是由.NET
    Core运行时为您完成的。
- en: Using the IPAddress class in C#
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中使用`IPAddress`类
- en: Our last task for this service will be converting our list of `IPAddress` instances
    to their corresponding JSON. This is where you will likely hit a pretty substantial
    snag in your code. Unfortunately, the `IPAddress` class doesn't play very well
    with `JsonConvert.SerializeObject()`. In fact, if you tried to execute that method
    on an instance of `IPAddress`, you'll get an exception almost every time. That's
    because the `IPAddress.Address` property is actually deprecated. It's defined
    as a long type, which, in C#, is a 64-bit integer. However, as you now know, an
    IPv6 address is a 128-bit value. Unfortunately, though, the `JsonConverter` class
    isn't intelligent enough to determine at runtime which public properties are deprecated.
    That means it will attempt to access the `Address` property of your `IPAddress`
    instance for serialization, and that access will throw an error for any `IPAddress`
    instances containing an IPv6 address.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个服务的最后一个任务是将我们的`IPAddress`实例列表转换为相应的JSON。这可能是你代码中遇到的一个相当大的障碍。不幸的是，`IPAddress`类与`JsonConvert.SerializeObject()`配合得不是很好。事实上，如果你尝试在一个`IPAddress`实例上执行该方法，你几乎每次都会得到一个异常。这是因为`IPAddress.Address`属性实际上是已弃用的。它被定义为长类型，在C#中是64位整数。然而，正如你所知，IPv6地址是一个128位值。不幸的是，`JsonConverter`类并不足够智能，无法在运行时确定哪些公共属性已弃用。这意味着它将尝试访问你的`IPAddress`实例的`Address`属性进行序列化，并且对于包含IPv6地址的任何`IPAddress`实例，这种访问将引发错误。
- en: 'Now, if you''re familiar with writing your own `JsonConverter` extension class,
    you can overwrite the `JsonConverter` class for `IPAddress` and use that to serialize
    your return object. However, as that''s quite outside the scope of this book,
    instead, we''ll take the less ideal shortcut of writing our own serialization
    with a `GetSerializedIPAddresses()` method. Since we know better than to use the
    `IPAddress.Address` property, we''ll just use the `ToString()` method to get the
    value of our `IPAddress` instance. That method will simply build out the string
    representation of each of our `IPAddress` instances as JSON, using each public
    property that we know is not deprecated and safe to access. That method will read
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你熟悉编写自己的 `JsonConverter` 扩展类，你可以覆盖 `IPAddress` 的 `JsonConverter` 类，并使用它来序列化你的返回对象。然而，由于这超出了本书的范围，因此，我们将采取不太理想的捷径，通过编写自己的
    `GetSerializedIPAddresses()` 方法来实现序列化。既然我们知道最好不要使用 `IPAddress.Address` 属性，我们只需使用
    `ToString()` 方法来获取我们的 `IPAddress` 实例的值。该方法将简单地构建出每个 `IPAddress` 实例的字符串表示形式，作为
    JSON，使用我们知道的每个不是已弃用且可以安全访问的公共属性。该方法如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And with that method, we see exactly what information the `IPAddress` class
    can provide for us regarding the nature of the IP version and its implementation
    just through its public properties. We can learn about the mappings or interfaces
    used to leverage IPv6 over IPv4, or simply learn about the feature support of
    an IPv6 host.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过该方法，我们可以确切地看到 `IPAddress` 类可以通过其公共属性为我们提供有关 IP 版本性质及其实现的哪些信息。我们可以了解用于利用 IPv6
    覆盖 IPv4 的映射或接口，或者简单地了解 IPv6 主机的功能支持。
- en: 'And with that last piece of the puzzle in place, our final controller method
    should read as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最后一块拼图的到位，我们的最终控制器方法应该如下所示：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And if you run the application and `POST` hostnames to your endpoint, you'll
    notice that the IP addresses returned are always well-formed, and even the fully-qualified
    IPv6 addresses have been abbreviated. With this simple functionality, you can
    abstract away all of the mess of parsing and manipulating IP addresses within
    your application code. You can trust that the work is being properly handled for
    you by a robust implementation of both IPv4 and IPv6 under the hood.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序并将 `POST` 主机名发送到你的端点，你会注意到返回的 IP 地址总是格式良好的，甚至完全限定的 IPv6 地址也被缩写了。通过这种简单的功能，你可以抽象出在应用程序代码中解析和操作
    IP 地址的所有混乱。你可以信任，这项工作正在由底层的 IPv4 和 IPv6 的强大实现为你正确处理。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took an extremely close look at IP, first discerning precisely
    why IP, as a network layer protocol, was unique from the transport layer protocols
    that we've examined before it and then learning about the functions and use of
    IP through its origin. We looked at when the split was made between the transport
    layer responsibilities of TCP and the network layer responsibilities of what eventually
    became IP. In doing so, we established clear boundaries on the scope of IP and
    what functions it is meant to provide, and what functions fall outside its scope.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们极其仔细地研究了 IP，首先精确地辨别了为什么 IP 作为一种网络层协议，与之前我们考察过的传输层协议不同，然后通过其起源了解了 IP 的功能和用途。我们考察了
    TCP 的传输层责任与 IP 的网络层责任（最终成为 IP）之间的分界点。通过这样做，我们明确了 IP 的范围以及它旨在提供的功能，以及哪些功能超出了其范围。
- en: Once we established the scope and intent of IP, we looked closely at how it
    has evolved over the years. Starting with IPv4, we learned about the addressing
    scheme, how it came to be, and how it is used by network software to uniquely
    identify hosts on a network. We learned about the common mechanisms for distinguishing
    between a network address and a host address within the IPv4 addressing architecture.
    We also looked at how subnet masking can help with the distinction between those
    two fields in a single address. Once we covered the addressing architecture of
    IPv4, we looked at its limitations with regard to the total number of addressable
    hosts that IPv4 supports.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了 IP 的范围和意图，我们就仔细研究了它多年来是如何演变的。从 IPv4 开始，我们学习了寻址方案、它是如何产生的以及网络软件如何使用它来唯一标识网络上的主机。我们了解了在
    IPv4 寻址架构中区分网络地址和主机地址的常见机制。我们还考察了子网掩码如何帮助区分单个地址中的这两个字段。一旦我们涵盖了 IPv4 的寻址架构，我们就考察了它在支持可寻址主机总数方面的局限性。
- en: After exploring the full scope of IPv4, we looked at its current proposed replacement
    in IPv6, and saw how the updated addressing structure in the new standard can
    support an immense number of hosts in a single universal network. Then, briefly,
    we examined some of the interfaces that allow for IPv4 and IPv6 to coexist. Finally,
    we looked at the classes that C# provides for parsing and constructing IPv4 and
    IPv6 addresses in our software for the reliable routing of our network packets.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了IPv4的全貌之后，我们看到了其当前提议的替代品IPv6，并看到了新标准中更新的地址结构如何支持单个通用网络中的大量主机。然后，简要地，我们检查了一些允许IPv4和IPv6共存的接口。最后，我们探讨了C#为我们软件中解析和构建IPv4和IPv6地址提供的类，以确保我们的网络数据包可靠路由。
- en: Now that we've seen how information is routed and delivered at the lowest level,
    it's time to consider perhaps the most important aspect of network interactions.
    So, in the next chapter, we'll be looking at how security is provided across networks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了信息在最低级别是如何路由和交付的，是时候考虑网络交互的最重要方面了。因此，在下一章中，我们将探讨如何在网络中提供安全性。
- en: Questions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the two primary functions of IP?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IP的两个主要功能是什么？
- en: What is classful addressing? What are the classes of IPv4 addresses?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类地址？IPv4地址有哪些类别？
- en: What is variable length subnet masking?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是可变长度子网掩码？
- en: What is address exhaustion?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是地址耗尽？
- en: What is the upper limit of the IPv4 address space?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPv4地址空间的上限是多少？
- en: What is the structure of an IPv4 address? What about an IPv6 address?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPv4地址的结构是什么？IPv6地址的结构又是什么？
- en: What is Teredo tunneling?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Teredo隧道？
- en: What features does IPv6 enable?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPv6启用了哪些功能？
- en: Further reading
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For your own reference, I strongly recommend reading the original RFC for IPv4\.
    You'd be surprised how readable it is and how much information you can glean from
    just the underlying spec. It's also available for free, online, here: [https://tools.ietf.org/html/rfc791](https://tools.ietf.org/html/rfc791).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您自己的参考，我强烈建议您阅读IPv4的原始RFC。您会惊讶地发现它有多容易阅读，以及您可以从底层规范中获取多少信息。它也可以免费在线阅读，这里： [https://tools.ietf.org/html/rfc791](https://tools.ietf.org/html/rfc791)。
- en: I'd also recommend, simply for its brevity, that you read the original IEN 2
    to understand exactly what motivated the development of IP in the first place.
    It's also free to read online, and surprisingly engaging: [https://www.rfc-editor.org/ien/ien2.txt](https://www.rfc-editor.org/ien/ien2.txt).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议，仅仅为了其简洁性，您阅读原始IEN 2，以了解IP最初发展的确切动机。它也可以免费在线阅读，并且出人意料地引人入胜：[https://www.rfc-editor.org/ien/ien2.txt](https://www.rfc-editor.org/ien/ien2.txt)。
- en: Additionally, if you'd like to understand other ways to program for IP, I once
    again recommend *Understanding TCP/IP,* by *Alena Kabelová* and *Libor Dostálek*,
    available from Packt Publishing here: [https://www.packtpub.com/networking-and-servers/understanding-tcpip](https://www.packtpub.com/networking-and-servers/understanding-tcpip).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想了解其他编程IP的方法，我再次推荐由*Alena Kabelová*和*Libor Dostálek*撰写的*Understanding
    TCP/IP*，由Packt Publishing提供，这里：[https://www.packtpub.com/networking-and-servers/understanding-tcpip](https://www.packtpub.com/networking-and-servers/understanding-tcpip)。
