<html><head></head><body>
  <div id="_idContainer068">
   <h1 class="chapter-number" id="_idParaDest-124">
    <a id="_idTextAnchor154">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     10
    </span>
   </h1>
   <h1 id="_idParaDest-125">
    <a id="_idTextAnchor155">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Profiling and Identifying Bottlenecks
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     As your minimal API project evolves, the potential for performance bottlenecks increases.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Working with data, making connections over networks, and running business logic and calculations – all these activities have a performance cost.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     If configured the wrong way, these activities could incur a higher than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      necessary cost.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In this chapter, we are going to explore strategies for analyzing resource utilization, identifying common bottlenecks, and implementing them.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We will cover
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.7.1">
      An introduction to profiling and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.8.1">
       performance monitoring
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Profiling tools
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       and techniques
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Common
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       performance bottlenecks
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-126">
    <a id="_idTextAnchor156">
    </a>
    <span class="koboSpan" id="kobo.13.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.14.1">
     You will need Visual Studio 2022 or Visual Studio code running, at minimum, a new ASP.NET core minimal API project.
    </span>
    <span class="koboSpan" id="kobo.14.2">
     It is recommended to use the code from the previous chapter, as we will be working with performance examples within the context of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.15.1">
      MyCompany
     </span>
    </strong>
    <span class="koboSpan" id="kobo.16.1">
     API project.
    </span>
    <span class="koboSpan" id="kobo.16.2">
     Because the examples in this chapter are run against the code examples in
    </span>
    <a href="B20968_10.xhtml#_idTextAnchor154">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.17.1">
        Chapter 10
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.18.1">
     , you will need to have Entity Framework installed as per the instructions in the previous chapter.
    </span>
    <span class="koboSpan" id="kobo.18.2">
     (See the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.19.1">
      Configuring Entity Framework in minimal API projects
     </span>
    </em>
    <span class="koboSpan" id="kobo.20.1">
     section in
    </span>
    <a href="B20968_09.xhtml#_idTextAnchor143">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.21.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.22.1">
      .)
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-127">
    <a id="_idTextAnchor157">
    </a>
    <span class="koboSpan" id="kobo.23.1">
     An introduction to profiling and performance monitoring
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.24.1">
     At the beginning of
    </span>
    <a id="_idIndexMarker398">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     this chapter, we established that the code we run in a minimal API
    </span>
    <a id="_idIndexMarker399">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     application will incur performance costs, some of which could be presented as bottlenecks, hampering the efficiency of the overall system.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     To remedy this, we can leverage a profiling tool, also known as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      a profiler.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-128">
    <a id="_idTextAnchor158">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     Introducing the profiler
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.30.1">
      profiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.31.1">
     is
    </span>
    <a id="_idIndexMarker400">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     a piece of software that measures the cost of running code.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     While your API application runs, the profiler will provide telemetry that outlines how expensive certain areas of the code base are in terms of resource usage.
    </span>
    <span class="koboSpan" id="kobo.32.3">
     This allows us to identify areas of inefficiency, which is critical to optimizing the performance of your minimal API applications.
    </span>
    <span class="koboSpan" id="kobo.32.4">
     This is an important practice for many reasons, not limited to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.34.1">
       Scalability
      </span>
     </strong>
     <span class="koboSpan" id="kobo.35.1">
      : The ability to ensure that your code will be able to perform at an increasing rate
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.36.1">
       of demand.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.37.1">
       Availability
      </span>
     </strong>
     <span class="koboSpan" id="kobo.38.1">
      : Access to the API to outside clients is paramount.
     </span>
     <span class="koboSpan" id="kobo.38.2">
      If clients cannot access the API because of a lack of available hardware resources, the application has
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.39.1">
       lost availability.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.40.1">
       Security
      </span>
     </strong>
     <span class="koboSpan" id="kobo.41.1">
      : The connection between the client and API should not be open for any longer than necessary.
     </span>
     <span class="koboSpan" id="kobo.41.2">
      If your API takes a long time to complete a request, the connection is open for longer, leaving more opportunities for malicious activity
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.42.1">
       to occur.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.43.1">
       Cost
      </span>
     </strong>
     <span class="koboSpan" id="kobo.44.1">
      : The financial cost of not optimizing a system can be severe.
     </span>
     <span class="koboSpan" id="kobo.44.2">
      If production servers frequently require upgrades because of software bottlenecks, each scale-up of the hardware incurs
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.45.1">
       financial costs.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.46.1">
       User experience
      </span>
     </strong>
     <span class="koboSpan" id="kobo.47.1">
      : Ensuring that your API runs as quickly as possible ensures that people will have a positive experience, securing repeat usage of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.48.1">
       the application.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.49.1">
       Error detection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.50.1">
      : While profiling allows for the detection of bottlenecks, it can also indirectly reveal other bugs in the code base that may not have been detected by unit or
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.51.1">
       integration testing.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     Along the same vein, the
    </span>
    <a id="_idIndexMarker401">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     advantages of profiling minimal APIs
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      are considerable:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.55.1">
       Latency reduction
      </span>
     </strong>
     <span class="koboSpan" id="kobo.56.1">
      : With profiling, response times can be increased, resulting in a much more
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.57.1">
       responsive API.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.58.1">
       Optimal hardware usage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.59.1">
      : Profiling can help you see where you are overconsuming resources such as CPU, memory,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.60.1">
       and I/O.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.61.1">
       Preventative measures
      </span>
     </strong>
     <span class="koboSpan" id="kobo.62.1">
      : Running a profiler to identify potential optimizations allows developers to get ahead of potential future issues, letting them make planned changes rather than
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.63.1">
       reactionary ones.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.64.1">
       Maintenance
      </span>
     </strong>
     <span class="koboSpan" id="kobo.65.1">
      : Overall, a
     </span>
     <a id="_idIndexMarker402">
     </a>
     <span class="koboSpan" id="kobo.66.1">
      more performant code base is usually easier to maintain.
     </span>
     <span class="koboSpan" id="kobo.66.2">
      If the minimal API application is easy to maintain, it will likely see a more frequent
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.67.1">
       release cadence.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     Next, let’s look at some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      performance metrics.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-129">
    <a id="_idTextAnchor159">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     Performance metrics
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.71.1">
     Before
    </span>
    <a id="_idIndexMarker403">
    </a>
    <span class="koboSpan" id="kobo.72.1">
     releasing
    </span>
    <a id="_idIndexMarker404">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     an application for general use, it is difficult to predict how an API will cope under heavy load in an accurate way without performing stress testing and gathering the resulting data.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.74.1">
      Performance monitoring
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     can help by providing insights into how your code is performing in specific scenarios.
    </span>
    <span class="koboSpan" id="kobo.75.2">
     This data in the form of metrics can inform how you optimize your code as you approach release.
    </span>
    <span class="koboSpan" id="kobo.75.3">
     One of the key things you need to understand from performance metrics is how the resources on the machine hosting the API handle a high volume
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      of requests.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     Profiling can monitor various resources within a minimal API and its dependencies, including
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.79.1">
       Response times
      </span>
     </strong>
     <span class="koboSpan" id="kobo.80.1">
      : The
     </span>
     <a id="_idIndexMarker405">
     </a>
     <span class="koboSpan" id="kobo.81.1">
      amount of time it takes for a request to be handled by the API, with a response being returning
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.82.1">
       the client.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.83.1">
       Throughput
      </span>
     </strong>
     <span class="koboSpan" id="kobo.84.1">
      : The
     </span>
     <a id="_idIndexMarker406">
     </a>
     <span class="koboSpan" id="kobo.85.1">
      volume of data flowing through a connection at any
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.86.1">
       given time.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.87.1">
       CPU processing
      </span>
     </strong>
     <span class="koboSpan" id="kobo.88.1">
      : The
     </span>
     <a id="_idIndexMarker407">
     </a>
     <span class="koboSpan" id="kobo.89.1">
      amount of processing being completed by the API host’s CPU during requests, or even on other background tasks not related to a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.90.1">
       client request.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.91.1">
       Memory
      </span>
     </strong>
     <span class="koboSpan" id="kobo.92.1">
      : The
     </span>
     <a id="_idIndexMarker408">
     </a>
     <span class="koboSpan" id="kobo.93.1">
      amount of RAM being consumed by the application at any
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.94.1">
       given time.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.95.1">
     Having access to metrics allows us to start identifying potential bottlenecks so that we can then take steps to address them in the minimal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.96.1">
      API code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.97.1">
     For example, the profiler might show a sudden increase in CPU usage during a particular operation.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     This may indicate that the operation is written in a sub-optimal way (e.g., an unnecessary loop or iteration over
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      a collection).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     With some understanding of profiling and performance monitoring, let’s take a look at some tools and techniques for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      the former.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-130">
    <a id="_idTextAnchor160">
    </a>
    <span class="koboSpan" id="kobo.101.1">
     Profiling tools and techniques
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.102.1">
     There are many different profiling tools available, but for the purposes of developing minimal APIs in ASP.NET, we will be looking at two examples: the Visual Studio profiler and BenchmarkDotNet.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     The former is a GUI-based tool, whereas the latter is a library that we can add as a dependency to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      our project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.104.1">
     Each of these tools has its strengths in particular use cases, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.105.1">
      shown here:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.106.1">
       The Visual Studio profiler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.107.1">
      : It is
     </span>
     <a id="_idIndexMarker409">
     </a>
     <span class="koboSpan" id="kobo.108.1">
      integrated into the IDE and provides live performance
     </span>
     <a id="_idIndexMarker410">
     </a>
     <span class="koboSpan" id="kobo.109.1">
      data and CPU and memory metrics.
     </span>
     <span class="koboSpan" id="kobo.109.2">
      It is ideal for capturing a quick profile, performing basic performance analysis, and identifying areas of high CPU and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.110.1">
       memory usage.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.111.1">
       BenchmarkDotNet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.112.1">
      : It can
     </span>
     <a id="_idIndexMarker411">
     </a>
     <span class="koboSpan" id="kobo.113.1">
      be installed as
     </span>
     <a id="_idIndexMarker412">
     </a>
     <span class="koboSpan" id="kobo.114.1">
      a package within a .NET project and is adept at micro-benchmarking.
     </span>
     <span class="koboSpan" id="kobo.114.2">
      It is used for establishing baseline performance and the fine-tuning
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.115.1">
       of code.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.116.1">
     There are several other potential choices that are not free, such as dotTrace by JetBrains, which is a very competent profiler that can provide the usual resource consumption metrics along with some very in-depth views of the call tree and events over a timeline.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     I can certainly recommend dotTrace, but as it is not free, we will keep things simple by exploring profiling examples in the Visual Studio profiler
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      and BenchmarkDotNet.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor161">
    </a>
    <span class="koboSpan" id="kobo.118.1">
     Profiling in Visual Studio
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.119.1">
     Let
    </span>
    <a id="_idIndexMarker413">
    </a>
    <span class="koboSpan" id="kobo.120.1">
     us start
    </span>
    <a id="_idIndexMarker414">
    </a>
    <span class="koboSpan" id="kobo.121.1">
     by setting up profiling in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      Visual Studio:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.123.1">
      Open the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.124.1">
       MyCompany
      </span>
     </strong>
     <span class="koboSpan" id="kobo.125.1">
      API example in Visual Studio.
     </span>
     <span class="koboSpan" id="kobo.125.2">
      Then, click
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.126.1">
       Debug
      </span>
     </strong>
     <span class="koboSpan" id="kobo.127.1">
      , and select
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.128.1">
       Performance Profiler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.129.1">
      .
     </span>
     <span class="koboSpan" id="kobo.129.2">
      You will see several different options on the screen for various kinds of profiling.
     </span>
     <span class="koboSpan" id="kobo.129.3">
      For this example, we are going to profile CPU usage to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.130.1">
       demonstrate profiling.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.131.1">
      Tick
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.132.1">
       CPU Usage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.133.1">
      and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.134.1">
       click
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.135.1">
        Start
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.136.1">
       .
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer063">
     <span class="koboSpan" id="kobo.137.1">
      <img alt="Figure 10.1: The profiling configuration screen" src="image/B20968_10_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.138.1">
     Figure 10.1: The profiling configuration screen
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.139.1">
     The aim will be to start profiling so that it is capturing CPU usage data in the background while we are interacting with the API.
    </span>
    <span class="koboSpan" id="kobo.139.2">
     Once the application stops, a report will be generated that will give us a breakdown of CPU usage over time, which we can then track back to specific lines
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.140.1">
      of code.
     </span>
    </span>
   </p>
   <ol>
    <li value="3">
     <span class="koboSpan" id="kobo.141.1">
      After starting the profiler (ensure that it is recording) your API project will also start running.
     </span>
     <span class="koboSpan" id="kobo.141.2">
      Interact with the API by calling the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.142.1">
       GetEmployeeById
      </span>
     </strong>
     <span class="koboSpan" id="kobo.143.1">
      endpoint, passing an ID value for an existing employee record.
     </span>
     <span class="koboSpan" id="kobo.143.2">
      You will notice when you make the request that the profiler updates in real time.
     </span>
     <span class="koboSpan" id="kobo.143.3">
      You should see an increase in CPU usage as soon as the request starts, which settles down again once the request
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.144.1">
       has completed.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.145.1">
      Once
     </span>
     <a id="_idIndexMarker415">
     </a>
     <span class="koboSpan" id="kobo.146.1">
      you have made some requests to the API, click the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.147.1">
       Stop Collection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.148.1">
      button in the top-left corner of the screen, and then click
     </span>
     <a id="_idIndexMarker416">
     </a>
     <span class="koboSpan" id="kobo.149.1">
      the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.150.1">
       CPU Usage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.151.1">
      tab (around a quarter of the way down the screen toward the left).
     </span>
     <span class="koboSpan" id="kobo.151.2">
      The result should be a diagnostic report showing the peaks and dips in CPU usage across the time
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.152.1">
       being profiled.
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer064">
     <span class="koboSpan" id="kobo.153.1">
      <img alt="Figure 10.2: The profiler report for CPU usage" src="image/B20968_10_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.154.1">
     Figure 10.2: The profiler report for CPU usage
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.155.1">
     As you can see in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.156.1">
       Figure 10
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.157.1">
      .2
     </span>
    </em>
    <span class="koboSpan" id="kobo.158.1">
     , there was a spike in CPU usage at the beginning of the profiling session.
    </span>
    <span class="koboSpan" id="kobo.158.2">
     This was at the point that a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.159.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.160.1">
     request was made to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.161.1">
      employees
     </span>
    </strong>
    <span class="koboSpan" id="kobo.162.1">
     endpoint, with the API handling the request by returning an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     object with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.165.1">
      given ID.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.166.1">
     There is a wealth of information that can be filtered in this view.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     Suffice it to say, a whole book could be written on profiling in .NET alone.
    </span>
    <span class="koboSpan" id="kobo.166.3">
     However, by way of example, click the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.167.1">
      Open Details
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     button toward the top-right corner of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.169.1">
      CPU
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.170.1">
       Usage
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      pane.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.172.1">
     The details shown on the screen following this will provide more detailed information about the code that consumes various percentage levels of CPU for the given time.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     There are several key views, such as the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.173.1">
      Call Tree
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     view, which shows the nested relationships
    </span>
    <a id="_idIndexMarker417">
    </a>
    <span class="koboSpan" id="kobo.175.1">
     between function and method calls (i.e.,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.176.1">
      what
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.177.1">
       called what
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      ).
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer065">
     <span class="koboSpan" id="kobo.179.1">
      <img alt="Figure 10.3: The Call Tree view, showing the CPU consumed by functions at each level of the tree" src="image/B20968_10_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.180.1">
     Figure 10.3: The Call Tree view, showing the CPU consumed by functions at each level of the tree
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.181.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.182.1">
      Functions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     view
    </span>
    <a id="_idIndexMarker418">
    </a>
    <span class="koboSpan" id="kobo.184.1">
     is quite useful in the sense that it can be used to identify which specific lines of code are consuming higher amounts of CPU.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     By sorting this view by
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.185.1">
      Total CPU% descending
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     , you can quickly identify the top consumer of CPU.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     This can be beneficial when performing optimization on a minimal API, as you can gain insights into the underlying functions’ impact on an endpoint’s response time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      for example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     What is more, any of the entries in this view can be double-clicked to reveal the original source code, with the CPU usage annotated next to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      function signature.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.190.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.191.1">
      Caller/Callee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     view, which demonstrated what functions are called by and what they themselves call, is particularly insightful in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.193.1">
      this request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.194.1">
     Take the example in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.195.1">
       Figure 10
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.196.1">
      .4
     </span>
    </em>
    <span class="koboSpan" id="kobo.197.1">
     .
    </span>
    <span class="koboSpan" id="kobo.197.2">
     We can see that for the current function in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      EmployeeService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      GetEmployeeById()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     , the CPU resource was consumed at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      51.42%
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     .
    </span>
    <span class="koboSpan" id="kobo.203.2">
     Going deeper, we can see that the function is called into a method within Entity Framework Core.
    </span>
    <span class="koboSpan" id="kobo.203.3">
     In this case, the function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      was
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.205.1">
       FirstOrDefault()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.206.1">
      .
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.207.1">
      FirstOrDefault()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     is a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.209.1">
      Language Integrated Query
     </span>
    </strong>
    <span class="koboSpan" id="kobo.210.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.211.1">
      LINQ
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     ) feature that will get the first item in a
    </span>
    <a id="_idIndexMarker419">
    </a>
    <span class="koboSpan" id="kobo.213.1">
     collection that meets the given condition, or it will return a default value, in this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      case,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.215.1">
       null
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.216.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.217.1">
     What we can see in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.218.1">
       Figure 10
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.219.1">
      .4
     </span>
    </em>
    <span class="koboSpan" id="kobo.220.1">
     is that of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.221.1">
      51.42%
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     of CPU usage consumed by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      GetEmployeeById()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      50.34%
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     of that usage was taken up by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      FirstOrDefault()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     ; don’t be surprised
    </span>
    <a id="_idIndexMarker420">
    </a>
    <span class="koboSpan" id="kobo.229.1">
     if the value you get for the same profiling differs.
    </span>
    <span class="koboSpan" id="kobo.229.2">
     This
    </span>
    <a id="_idIndexMarker421">
    </a>
    <span class="koboSpan" id="kobo.230.1">
     value should and would vary between machines.
    </span>
    <span class="koboSpan" id="kobo.230.2">
     The important thing is that you are able to see a spike
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.231.1">
      in usage.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer066">
     <span class="koboSpan" id="kobo.232.1">
      <img alt="Figure 10.4: The Caller/Callee view, demonstrating the breakdown of CPU usage for the GetEmployeeById() function" src="image/B20968_10_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.233.1">
     Figure 10.4: The Caller/Callee view, demonstrating the breakdown of CPU usage for the GetEmployeeById() function
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     This result demonstrates the percentage of CPU usage spread across each function.
    </span>
    <span class="koboSpan" id="kobo.234.2">
     On its own, this does not necessarily indicate a bottleneck, but it is useful information when troubleshooting performance or for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.235.1">
      general optimization.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     We could dig into this further by replacing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.237.1">
      FirstOrDefault()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.238.1">
     with our own custom implementation of a loop for finding the first employee with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      matching ID.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.240.1">
     The loop would look like the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.241.1">
      example here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.242.1">
foreach(var employee in _companyContext.Employees)
{
    if (employee.Id == id)
    {
        return employee;
    }
}
throw new EmployeeNotFoundException(id);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.243.1">
     If we run this loop in place of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      FirstOrDefault()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     , we can check the same profiling capture and compare the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.246.1">
      CPU usage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.247.1">
     In this case, when running the updated code using a loop, we saw a minor increase in CPU usage compared to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      FirstOrDefault()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     .
    </span>
    <span class="koboSpan" id="kobo.249.2">
     So, while
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      FirstOrDefault()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     is not confirmed to be the most performant method of retrieving
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.252.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     for the calling API endpoint, it is
    </span>
    <a id="_idIndexMarker422">
    </a>
    <span class="koboSpan" id="kobo.254.1">
     confirmed that our alternative is not
    </span>
    <a id="_idIndexMarker423">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     as performant.
    </span>
    <span class="koboSpan" id="kobo.255.2">
     This is a process of elimination technique, which is an exercise worth practicing across your whole
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.256.1">
      code base.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer067">
     <span class="koboSpan" id="kobo.257.1">
      <img alt="Figure 10.5: CPU usage for GetEmployeeById() using a foreach loop instead of FirstOrDefault()" src="image/B20968_10_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.258.1">
     Figure 10.5: CPU usage for GetEmployeeById() using a foreach loop instead of FirstOrDefault()
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     As mentioned previously, we could go much further into the Visual Studio profiler, but that is beyond the scope of this book.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     With this foundation, you should now have at least one item in your toolset for optimizing minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.259.3">
     Let us look at another useful tool for analyzing API performance –
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      BenchmarkDotNet.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor162">
    </a>
    <span class="koboSpan" id="kobo.261.1">
     Benchmarking with BenchmarkDotNet
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.262.1">
      BenchmarkDotNet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     is an
    </span>
    <a id="_idIndexMarker424">
    </a>
    <span class="koboSpan" id="kobo.264.1">
     open source .NET library designed to facilitate micro-benchmarking in .NET applications.
    </span>
    <span class="koboSpan" id="kobo.264.2">
     It was created by software engineer, Andrey Akinshin, a prominent member of the .NET community specializing in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.265.1">
      software performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.266.1">
     The project
    </span>
    <a id="_idIndexMarker425">
    </a>
    <span class="koboSpan" id="kobo.267.1">
     started around 2014 to provide developers with an easy-to-use tool for measuring and comparing the performance of different pieces
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      of code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     The library is available as a NuGet package and will need to be installed in order for us to run performance benchmarking against the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      MyCompany
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      API project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.272.1">
     To keep things clean, we will perform the benchmarking in another project.
    </span>
    <span class="koboSpan" id="kobo.272.2">
     However, we can stay within the current Visual Studio setup by adding the new benchmarking project to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      current solution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     In Visual Studio’s Solution Explorer, right-click the current solution and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.275.1">
      Add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     |
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.277.1">
       New Project
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.278.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.279.1">
     In the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.280.1">
      New Project
     </span>
    </strong>
    <span class="koboSpan" id="kobo.281.1">
     screen
    </span>
    <a id="_idIndexMarker426">
    </a>
    <span class="koboSpan" id="kobo.282.1">
     there is a search box at the top of the window that allows you to search for a project template.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     Use this to search for
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.283.1">
      "C# Console App"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     .
    </span>
    <span class="koboSpan" id="kobo.284.2">
     Once you see it, select it and click
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.285.1">
      "Next"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     .
    </span>
    <span class="koboSpan" id="kobo.286.2">
     You will be asked to choose a .NET version.
    </span>
    <span class="koboSpan" id="kobo.286.3">
     We are using version 9, so leave this selected and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      click
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.288.1">
       "Create"
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.289.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.290.1">
     Next, we will need to add the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.291.1">
      BenchmarkDotNet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     library package to the new project via the Package
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.293.1">
      Manager Console:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.294.1">
dotnet add package BenchmarkDotNet</span></pre>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     The new project is in our solution and has the required libraries installed, but how is it supposed to be able to reference the dependencies from the minimal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      API project?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     The way to address this is to create a project reference.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     This allows us to reference object types across multiple .NET projects.
    </span>
    <span class="koboSpan" id="kobo.297.3">
     This is especially easy when the projects are in the same solution as they are in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      this example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.299.1">
     To add the project reference, right-click your new benchmarking project and click
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.300.1">
      Add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     |
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.302.1">
       Project Reference
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     You will be presented with a dialog box in which you can browse to the project location.
    </span>
    <span class="koboSpan" id="kobo.304.2">
     Your ASP.NET project should have been compiled
    </span>
    <a id="_idIndexMarker427">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     as a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.306.1">
      Dynamic Link Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.308.1">
      DLL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     ) so you should be able to select that from the bin folder within your ASP.NET
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.310.1">
      project directory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.311.1">
     Now that you have a project reference, you can add using statements to reference types in that project as if they had been created within the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      benchmarking project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.313.1">
     We can now move on to setting up our benchmarks and utilizing the dependencies that we would have normally injected, but first, the benchmarks need their own class; so, create one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.314.1">
      called
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.315.1">
       EmployeeBenchmarks
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     In this new class, create a private field to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      hold
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.319.1">
       EmployeeService
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.320.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.321.1">
public class EmployeeBenchmarks
{
    private EmployeeService _employeeService;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     Next, we
    </span>
    <a id="_idIndexMarker428">
    </a>
    <span class="koboSpan" id="kobo.323.1">
     can create a method that accesses the required dependencies.
    </span>
    <span class="koboSpan" id="kobo.323.2">
     We will call this method
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.324.1">
      Setup()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     .
    </span>
    <span class="koboSpan" id="kobo.325.2">
     We need to annotate this method with an attribute –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.326.1">
      [
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.327.1">
       GlobalSetup]
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.328.1">
     Having this attribute means that BenchmarkDotNet will run the logic inside
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.329.1">
      Setup()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.330.1">
     before
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.331.1">
      benchmarks run:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.332.1">
[GlobalSetup]
    public void Setup()
    {
        var services = new ServiceCollection();
        services.AddScoped&lt;MyCompanyContext&gt;();
        services.AddScoped&lt;EmployeeService&gt;();
        var serviceProvider =
            services.BuildServiceProvider();
        _employeeService =
            serviceProvider
                .GetRequiredService&lt;EmployeeService&gt;();
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     This code uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      ServiceCollection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     , which will require the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      Microsoft.Extensions.DependencyInjection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     package to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      be installed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     Inside
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      Setup()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     , we have created the required dependencies and added them to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.342.1">
      ServiceContainer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.343.1">
     so that they are ready to be used
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.344.1">
      at runtime.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     We have also retrieved
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.346.1">
      EmployeeService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.347.1">
     and stored it in the private field so that our benchmark can call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.348.1">
      GetEmployeeId()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.349.1">
     function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.350.1">
      within it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     Finally, for
    </span>
    <a id="_idIndexMarker429">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     this class, we add the benchmark itself, which is the important part.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     We want to create a benchmark for the activity running in Entity Framework so we will call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.353.1">
      GetEmployeeId()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.354.1">
     function so that it interacts with the database via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.355.1">
      MyCompanyContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.356.1">
     , and this activity will be recorded by BenchmarkDotNet.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     We are passing a hardcoded ID to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.357.1">
      GetEmployeeById()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     , because we know that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.359.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     record with ID
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.361.1">
      6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     exists and that this is not going to change (obviously, you must ensure a record with this ID exists, or change the value from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.363.1">
      6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.364.1">
     to one you know to exist in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      the database):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.366.1">
  [Benchmark]
  public void GetEmployeeByIdBenchmark()
  {
      var result = _employeeService
          .GetEmployeeById(6)
          .GetAwaiter()
          .GetResult();
  }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     Notice the presence of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      [Benchmark]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     attribute decorating the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.370.1">
      GetEmployeeByIdBenchmark()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.371.2">
     This labels the method as being a relevant benchmark that should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      be run.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.373.1">
     Now, this is where having a separate console application really helps.
    </span>
    <span class="koboSpan" id="kobo.373.2">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.374.1">
      Main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.375.1">
     method of the benchmark console application’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.376.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     class, we can simply call the static
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      BenchmarkRunner
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     and tell it to run any of the benchmarks in the benchmark class, which it will detect based on the presence of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      [
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.381.1">
       Benchmark]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.382.1">
      attribute:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.383.1">
static void Main(string[] args)
{
    var result = BenchmarkRunner.Run&lt;EmployeeBenchmarks&gt;();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.384.1">
     The benchmarking console application can now be run to provide results for any methods or functions in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.385.1">
      EmployeeBenchmarks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     that are annotated with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.387.1">
      [
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.388.1">
       Benchmark]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.389.1">
      attribute.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.390.1">
     Before running
    </span>
    <a id="_idIndexMarker430">
    </a>
    <span class="koboSpan" id="kobo.391.1">
     the console application, right-click the console application project in Solution Explorer and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.392.1">
      Set as
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.393.1">
       Startup Project
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     Once the console app has finished running, you will see the benchmark output in the console window, as well as a series of files published to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.396.1">
      bin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.397.1">
     directory of the application in a folder called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.398.1">
      BenchmarkDotNet.Artifacts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     .
    </span>
    <span class="koboSpan" id="kobo.399.2">
     Here, you will find the output to the console, as well as the results organized in HTML, Markdown, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      Excel formats.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     Let’s look at the most important section of the output.
    </span>
    <span class="koboSpan" id="kobo.401.2">
     In the result shown in the console, you’ll notice a table.
    </span>
    <span class="koboSpan" id="kobo.401.3">
     This table contains the benchmarking information
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      for
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.403.1">
       GetEmployeeById()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.404.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.405.1">
| Method                   | Mean     | Error   | StdDev  |
|------------------------- |---------:|--------:|--------:|
| GetEmployeeByIdBenchmark | 171.1 μs | 3.37 μs | 5.63 μs |</span></pre>
   <p>
    <span class="koboSpan" id="kobo.406.1">
     This table shows the average time in microseconds that it took to run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.407.1">
      GetEmployeeById()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.408.1">
     out of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      several iterations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.410.1">
     The average time taken is displayed as a mean value, giving us a measurement we can use as a basis for performance analysis.
    </span>
    <span class="koboSpan" id="kobo.410.2">
     It would be advisable to note this mean average, and then run benchmarking several more times with different inputs, to provide further re-enforcement of this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.411.1">
      average value.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.412.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.413.1">
      Error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.414.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.415.1">
      StdDev
     </span>
    </strong>
    <span class="koboSpan" id="kobo.416.1">
     columns provide some further supporting information.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.417.1">
      StdDev
     </span>
    </strong>
    <span class="koboSpan" id="kobo.418.1">
     represents the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.419.1">
      standard deviation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.420.1">
     , which
    </span>
    <a id="_idIndexMarker431">
    </a>
    <span class="koboSpan" id="kobo.421.1">
     is the amount of variation from the average.
    </span>
    <span class="koboSpan" id="kobo.421.2">
     A smaller standard deviation means that benchmark times were consistent.
    </span>
    <span class="koboSpan" id="kobo.421.3">
     If you see a higher standard deviation, it implies more variability in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.422.1">
      average results.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      Error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     column represents the estimated standard deviation of the mean average result, which is an indication of how reliable the result is.
    </span>
    <span class="koboSpan" id="kobo.425.2">
     The smaller the number, the more reliable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.426.1">
      the result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.427.1">
     Again, it makes sense to run several benchmarks with varying inputs.
    </span>
    <span class="koboSpan" id="kobo.427.2">
     If you are seeing similar standard deviations and errors, you can be confident in the accuracy of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      the results.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.429.1">
     Release mode
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.430.1">
     Your project will need to be built in Release mode for the preceding profiling to work.
    </span>
    <span class="koboSpan" id="kobo.430.2">
     If you see the word
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.431.1">
      Debug
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     in a dropdown in the top ribbon of Visual Studio, change it to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.433.1">
      Release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.434.1">
     and then rebuild
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.435.1">
      your project.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-133">
    <a id="_idTextAnchor163">
    </a>
    <span class="koboSpan" id="kobo.436.1">
     Common performance bottlenecks
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     Let’s look at some common
    </span>
    <a id="_idIndexMarker432">
    </a>
    <span class="koboSpan" id="kobo.438.1">
     reasons that performance could be degraded and how you might address them.
    </span>
    <span class="koboSpan" id="kobo.438.2">
     These are by no means applicable to every situation, but they are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.439.1">
      well-known bottlenecks:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.440.1">
       Database access
      </span>
     </strong>
     <span class="koboSpan" id="kobo.441.1">
      : The
     </span>
     <a id="_idIndexMarker433">
     </a>
     <span class="koboSpan" id="kobo.442.1">
      bottleneck is caused by slow database queries or inefficient use of database connections.
     </span>
     <span class="koboSpan" id="kobo.442.2">
      To mitigate this, do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.443.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.444.1">
        Use asynchronous database
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.445.1">
         operations (
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.446.1">
          async/await
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.447.1">
         ).
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.448.1">
        Optimize SQL queries and use proper indexing.
       </span>
       <span class="koboSpan" id="kobo.448.2">
        Look at any
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.449.1">
         WHERE
        </span>
       </strong>
       <span class="koboSpan" id="kobo.450.1">
        clauses or
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.451.1">
         JOIN
        </span>
       </strong>
       <span class="koboSpan" id="kobo.452.1">
        operations that might be taxing
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.453.1">
         the system.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.454.1">
        Implement connection pooling to reduce the number of times new connections need to
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.455.1">
         be opened.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.456.1">
        Use a caching system such as ASP.NET’s
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.457.1">
         IMemoryCache
        </span>
       </strong>
       <span class="koboSpan" id="kobo.458.1">
        for frequently
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.459.1">
         accessed data.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.460.1">
       I/O operations
      </span>
     </strong>
     <span class="koboSpan" id="kobo.461.1">
      : The
     </span>
     <a id="_idIndexMarker434">
     </a>
     <span class="koboSpan" id="kobo.462.1">
      bottleneck is due to blocking I/O operations, such as file or network access.
     </span>
     <span class="koboSpan" id="kobo.462.2">
      To mitigate this, do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.463.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.464.1">
        Use asynchronous
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.465.1">
         I/O operations.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.466.1">
        Minimize disk and network I/O.
       </span>
       <span class="koboSpan" id="kobo.466.2">
        Where possible, retrieve commonly required data from memory rather than from persistent storage or over
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.467.1">
         a network.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.468.1">
        Use efficient data formats (e.g., JSON instead
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.469.1">
         of XML).
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.470.1">
       Serialization/deserialization
      </span>
     </strong>
     <span class="koboSpan" id="kobo.471.1">
      : The
     </span>
     <a id="_idIndexMarker435">
     </a>
     <span class="koboSpan" id="kobo.472.1">
      bottleneck arises from slow or inefficient serialization and deserialization of data.
     </span>
     <span class="koboSpan" id="kobo.472.2">
      To mitigate this, do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.473.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.474.1">
        Use optimized serializers such as
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.475.1">
         System.Text.Json
        </span>
       </strong>
       <span class="koboSpan" id="kobo.476.1">
        instead
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.477.1">
         of
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.478.1">
          Newtonsoft.Json.
         </span>
        </strong>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.479.1">
        Minimize the size of the data
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.480.1">
         being serialized.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.481.1">
       Middleware pipeline
      </span>
     </strong>
     <span class="koboSpan" id="kobo.482.1">
      :The bottleneck is caused by excessive or inefficient middleware in
     </span>
     <a id="_idIndexMarker436">
     </a>
     <span class="koboSpan" id="kobo.483.1">
      the request pipeline.
     </span>
     <span class="koboSpan" id="kobo.483.2">
      To mitigate this, do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.484.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.485.1">
        Review and optimize
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.486.1">
         middleware components.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.487.1">
        Remove
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.488.1">
         unnecessary middleware.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.489.1">
        Use
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.490.1">
         lightweight middleware.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.491.1">
       Logging
      </span>
     </strong>
     <span class="koboSpan" id="kobo.492.1">
      : The
     </span>
     <a id="_idIndexMarker437">
     </a>
     <span class="koboSpan" id="kobo.493.1">
      bottleneck results from extensive or synchronous logging.
     </span>
     <span class="koboSpan" id="kobo.493.2">
      To mitigate this, do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.494.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.495.1">
        Use
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.496.1">
         asynchronous logging.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.497.1">
        Reduce the log verbosity level
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.498.1">
         in production.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.499.1">
        Use efficient logging frameworks such
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.500.1">
         as Serilog.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.501.1">
       Dependency injection (DI)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.502.1">
      :The bottleneck is due to the inefficient use of dependency
     </span>
     <a id="_idIndexMarker438">
     </a>
     <span class="koboSpan" id="kobo.503.1">
      injection.
     </span>
     <span class="koboSpan" id="kobo.503.2">
      To mitigate this, do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.504.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.505.1">
        Use scoped or singleton lifetimes
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.506.1">
         where appropriate.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.507.1">
        Avoid unnecessary injections of services.
       </span>
       <span class="koboSpan" id="kobo.507.2">
        If there is a simpler alternative that avoids dependency injection,
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.508.1">
         use it.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.509.1">
       Garbage collection (GC) pressure
      </span>
     </strong>
     <span class="koboSpan" id="kobo.510.1">
      : The bottleneck results from excessive memory
     </span>
     <a id="_idIndexMarker439">
     </a>
     <span class="koboSpan" id="kobo.511.1">
      allocation, leading to frequent garbage collection.
     </span>
     <span class="koboSpan" id="kobo.511.2">
      To mitigate this, do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.512.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.513.1">
        Reduce allocations by
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.514.1">
         reusing objects.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.515.1">
        Use value types instead of reference types
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.516.1">
         where possible.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.517.1">
        Optimize data structures and avoid large allocations of objects onto the heap (relates back to using value types over reference types
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.518.1">
         where possible).
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.519.1">
       Network latency
      </span>
     </strong>
     <span class="koboSpan" id="kobo.520.1">
      : The bottleneck is caused by high latency in network calls.
     </span>
     <span class="koboSpan" id="kobo.520.2">
      To mitigate this, do
     </span>
     <a id="_idIndexMarker440">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.521.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.522.1">
        Minimize the number of
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.523.1">
         network calls.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.524.1">
        Implement retry policies with
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.525.1">
         exponential backoff.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.526.1">
        Investigate alternative network protocols, using benchmarking to see whether they are
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.527.1">
         less resource-intensive.
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.528.1">
     By having a general understanding of the most common bottlenecks and how they can be mitigated, you will become more vigilant when debugging and reviewing code in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.529.1">
      minimal APIs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.530.1">
     We will now recap the various topics we have covered in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.531.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor164">
    </a>
    <span class="koboSpan" id="kobo.532.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.533.1">
     In this chapter, we explored at a high level the various pitfalls and mitigation options for performance issues in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.534.1">
      minimal APIs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.535.1">
     We started by outlining the basics of performance analysis and why it is important within not just minimal APIs, but in general
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.536.1">
      software engineering.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.537.1">
     We then reviewed some of the different tools on offer, before narrowing the scope of the tools we would use to the Visual Studio profiler
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.538.1">
      and BenchmarkDotNet.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.539.1">
     Then, we started profiling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      MyCompany
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     API using the Visual Studio profiler, with a breakdown of the various metrics that are outputted into the diagnostic report produced by the profiler.
    </span>
    <span class="koboSpan" id="kobo.541.2">
     This allowed us to find the overall CPU usage of a section of a code, but then also to break that down further by its called functions lower down in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.542.1">
      call tree.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.543.1">
     Moving on to BenchMarkDotNet, we implemented the same analysis example undertaken by the Visual Studio profiler, this time running a performance benchmark against the target method.
    </span>
    <span class="koboSpan" id="kobo.543.2">
     We then reviewed the output to understand how best to secure an accurate benchmark based on the consistency of the error rate and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.544.1">
      standard deviation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.545.1">
     Like many topics in this book, this is just a scratch of the surface, but it will provide a solid foundation for further optimization of minimal APIs and give you a good grounding in analyzing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.546.1">
      their efficiency.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.547.1">
     Let’s move on to the next chapter, in which we will be exploring ways to use asynchronous programming to scale
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.548.1">
      minimal APIs.
     </span>
    </span>
   </p>
  </div>
 </body></html>