<html><head></head><body>
		<div><h1 id="_idParaDest-293"><em class="italic"><a id="_idTextAnchor1932"/>Chapter 16</em>: Deploying the Application in Azure</h1>
			<p>Deployment is a set of activities we perform to make software applications available for use. The general approach is to take the code, and then build, test, and deploy it to the target systems. Depending on the type of application and the business requirements, the approach that you take to deploy your code might vary. It could be as simple as taking the target system down, replacing existing code with a new version, and then bringing the system up; or, it may involve other sophisticated approaches such as blue-green deployment, where you deploy code to a staging environment that is identical to production, run your tests, and then redirect the traffic to staging to make it to production.</p>
			<p>Modern software development adopts Agile and DevOps to shorten the development cycle and deliver new features, updates, and bugs frequently and reliably to provide more value to customers. To enable this, you will need a set of tools to plan, collaborate, develop, test, deploy, and monitor.</p>
			<p>In this chapter, we will learn what Azure DevOps is and the tools it offers for rapid and reliable delivery.</p>
			<p>The following topics are covered in this chapter:</p>
			<ul>
				<li>Introducing Azure DevOps</li>
				<li>Understanding the CI pipeline</li>
				<li>Understanding the CD pipeline</li>
				<li>Deploying an ASP.NET 6 application</li>
			</ul>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor1933"/><a id="_idTextAnchor1934"/>Technical requirements</h1>
			<p>For this chapter, you need basic knowledge of Azure, Visual Studio 2022, Git, and an active Azure subscription with a contributor role. If you don't have one, you can sign up for a free account at <a href="https://azure.microsoft.com/en-in/free">https://azure.microsoft.com/en-in/free</a>.</p>
			<p>The code for the chapter can be found here: https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter16.</p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor1935"/><a id="_idTextAnchor1936"/>Introducing Azure DevOps</h1>
			<p>To bring a<a id="_idIndexMarker1407"/> product<a id="_idTextAnchor1937"/> idea to life, irrespective of your team size, you will need an efficient way to plan your work, collaborate within your team, and build, test, and deploy. Azure DevOps helps you to address these challenges and offers various services and tools for your success. Azure DevOps services can be accessed via the web or from popular development IDEs such as Visual Studio, Visual Studio Code, and Eclipse. Azure DevOps services are available in the cloud as well as on-premises using Azure DevOps Server.</p>
			<p>Azure DevOps offers the<a id="_idTextAnchor1938"/> following services:</p>
			<ul>
				<li><strong class="bold">Boards</strong>: Offers a set of tools to plan and track your work, defects, and issues using Scrum and Kanban methodologies</li>
				<li><strong class="bold">Repos</strong>: Offers<a id="_idIndexMarker1408"/> source control to manage your cod<a id="_idTextAnchor1939"/>e using Git or <strong class="bold">Team Foundation Version Control</strong> (<strong class="bold">TFVC</strong>)</li>
				<li><strong class="bold">Pipelines</strong>: Offers<a id="_idIndexMarker1409"/><a id="_idTextAnchor1940"/> a set <a id="_idIndexMarker1410"/>of servi<a id="_idTextAnchor1941"/>ces to support <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>)</li>
				<li><strong class="bold">Test Plans</strong>: Offers a set of test management tools to drive the quality of your application with end-to-end traceability</li>
				<li><strong class="bold">Artifacts</strong>: Allows you to share packages from public and private sources, as well as integrating with CI and CD pipelines</li>
			</ul>
			<p>In addition to these services, Azure DevOps also helps you to manage wikis for your team, manage dashboards, use widgets to share progress and trends, and configure notifications. It also allows you to add or develop custom extensions and integrate with popular third-party services such as Campfire, Slack, and Trello.</p>
			<p>Azure DevOps services offer free and paid subscriptions. To sign up for a free account, follow the steps outlined at <a href="https://docs.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates?view=azure-devops</a>.</p>
			<p>The following is a screenshot of the home screen from a sample projec<a id="_idTextAnchor1942"/>t:</p>
			<div><div><img src="img/Figure_16.1_B18507.jpg" alt="Figure 16.1 – Azure DevOps home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – Azure DevOps home page</p>
			<p>Let's understand<a id="_idIndexMarker1411"/> Azure DevOps and each of these services in deta<a id="_idTextAnchor1943"/><a id="_idTextAnchor1944"/>il.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor1945"/>Boards</h2>
			<p><strong class="bold">Boards</strong> helps you<a id="_idIndexMarker1412"/> to defi<a id="_idTextAnchor1946"/>ne<a id="_idIndexMarker1413"/> a process for your project and track your work. When you create a new project in Azure DevOps, you have the option to choose a process template as Agile, Basic, Scrum, or a <strong class="bold">Capability Maturity Model Integration</strong> (<strong class="bold">CMMI</strong>) process. The process template determines the work item <a id="_idIndexMarker1414"/>types and workflows that you can use in your project. Work items help you to track your work, and workflows help you track the progress of your work items. The following figure shows the hierarchy of work items and the workflow of the Scrum process temp<a id="_idTextAnchor1947"/>late:</p>
			<div><div><img src="img/Figure_16.2_B18507.jpg" alt="Figure 16.2 – Hierarchy of work items and the workflow in a Scrum process&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.2 – Hierarchy of work items and the workflow in a Scrum process</p>
			<p>To further customize or define your workflows and work item types, you can choose to create your <a id="_idIndexMarker1415"/>own p<a id="_idTextAnchor1948"/>rocess template based on the previously mentioned process templates.</p>
			<p>Let's understand more about work items and workflows.</p>
			<h3>Work items</h3>
			<p>Work items <a id="_idIndexMarker1416"/>help<a id="_idTextAnchor1949"/> you to track features, requirements, and bugs in your project. You can group requirements in a hierarchy. Usually, we start with a hig<a id="_idTextAnchor1950"/>h-level requirement<a id="_idIndexMarker1417"/> called an <strong class="bold">epic</strong>, which can be further broken down <a id="_idIndexMarker1418"/>into <strong class="bold">features</strong> and <strong class="bold">product backlog items</strong>. Product back<a id="_idTextAnchor1951"/>log items are deliverables that are prioritized, assigned to a team member, and delivered in <a id="_idIndexMarker1419"/>a sprint. <strong class="bold">Tasks</strong> are created for backlog items and bugs to track defects against product backlog items.</p>
			<p>The collaboration featu<a id="_idTextAnchor1952"/>re enables communication within your team through discussion or questions on a work item. You can mention a team member or link another work item and view the history of all actions or discussions at any time. You can also choose to follow a work item to get alerts when it is updated.</p>
			<h3>Workflows</h3>
			<p>Workflows h<a id="_idTextAnchor1953"/>elp you<a id="_idIndexMarker1420"/> to review the progress and health of your project. For instance, a product backlog item is created with the <strong class="bold">New</strong> state. Once it is reviewed and approved by a product owner, it is moved to <strong class="bold">Approved</strong>, then it is prioritized and assigned to a team member in a sprint and moved to <strong class="bold">Committed</strong>, and when it is complete, it is moved to <strong class="bold">Done</strong>. Workflows help you to track the health of your project.</p>
			<p>You can use a Kanban board to view the state of all work items and easily move work items to different states using the drag-and-drop feature. The following screenshot illustrates a Kanban board<a id="_idTextAnchor1954"/> consisting of work items in differe<a id="_idTextAnchor1955"/>nt states:</p>
			<div><div><img src="img/Figure_16.3_B18507.jpg" alt="Figure 16.3 – Kanban dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.3 – Kanban dashboard</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you create your own process template, you can customize work items or create new work items and customize or define your workflows to suit your business needs.</p>
			<p>To learn more abo<a id="_idTextAnchor1956"/>ut process templates and how they differ, you can refer to <a href="https://docs.microsoft.com/en-us/azure/devops/boards/get-started/what-is-azure-boards?view=azure-devops&amp;tabs=scrum-process#work-item-types">https://docs.microsoft.com/en-us/azure/devops/boards/get-started/what-is-azure-boards?view=azure-devops&amp;tabs=scrum-process#work-item-types</a>.</p>
			<p>Next, let's understand more about Repos.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor1957"/>Repos</h2>
			<p><strong class="bold">Repos</strong> offers<a id="_idIndexMarker1421"/> vers<a id="_idTextAnchor1958"/>ion<a id="_idIndexMarker1422"/> control tools with which you can manage your code. A version control system allows you to track the changes made by your team to code. It creates a snapshot of each change, which you can review at any time and revert to it if required. Azure DevOps offers <strong class="bold">Git</strong> and <strong class="bold">TFVC</strong> as your version control systems.</p>
			<p>Git is curren<a id="_idTextAnchor1959"/>tly the most widely used version control system and is increasingly becoming the standard for version control systems. Git is a distributed version control system with a local copy of the version control system in which you can view the history or commit chan<a id="_idTextAnchor1960"/>ges locally, even if you are offline, and it will sync to the server once connected to a network. TFVC, however, is a<a id="_idTextAnchor1961"/> centralized version control system with only one version of each file on the dev machine, and the history is maintained on the server. For more<a id="_idIndexMarker1423"/> information on Git, you can refer to <a href="https://docs.microsoft.com/en-in/azure/devops/repos/git/?view=azure-devops">https://docs.microsoft.com/en-in/azure/devops/repos/git/?view=azure-devops</a>, and for TFVC, you can refer to <a href="https://docs.microsoft.com/en-in/azure/devops/repos/tfvc/?view=azure-devops">https://docs.microsoft.com/en-in/azure/devops/repos/tfvc/?view=azure-devops</a>.</p>
			<p>The following are the key services of <strong class="bold">Repos</strong>:</p>
			<ul>
				<li><code>main</code> or <code>master</code>, and you can create another branch from it. This way, you can isolate your changes for feature development or a bug fix. You can create any number of branches, share them among your team members, commit your changes, and safely merge them back to <code>master</code>.</li>
				<li><strong class="bold">Branch policies</strong> help you to protect your branches during development. When you enable a bran<a id="_idTextAnchor1963"/>ch policy on a branch, any change must be made via pull requests only, so that you can review, give feedback, and approve changes. As a branch policy, you can configure a minimum number of required approvers, check for linked work items and comment resolution, and enforce the build to be successful to complete pull requests.</li>
			</ul>
			<p>The following screenshot illustrates policies defined<a id="_idTextAnchor1964"/> on a branch:</p>
			<div><div><img src="img/Image87446.jpg" alt="Figure 16.4 – Branch policies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.4 – Branch policies</p>
			<p>Here, a policy is created <a id="_idIndexMarker1425"/>to validate the<a id="_idIndexMarker1426"/> build before the code is merged to the branch.</p>
			<ul>
				<li><strong class="bold">Pull requests</strong> allow you to review code, add comments, and ensure they are resolved before the code is<a id="_idTextAnchor1965"/> merged to your branch. Based on the configured branch policy, you can add mandatory reviewers to review and approve changes. You can associate work items to pull requests to enable traceability of changes. The following screenshot illustrates a sample<a id="_idTextAnchor1966"/> pull request:</li>
			</ul>
			<div><div><img src="img/Figure_16.5_B18507.jpg" alt="Figure 16.5 – Pull request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.5 – Pull request</p>
			<p>The pull request has a title and <a id="_idIndexMarker1427"/>description, and<a id="_idIndexMarker1428"/> users can review files and compare them with the previous versions, check the status of builds and linked work items, and approve.</p>
			<p>Next, let's under<a id="_idTextAnchor1967"/><a id="_idTextAnchor1968"/>stand Pipelines.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor1969"/>Pipelines</h2>
			<p><strong class="bold">Pipeli<a id="_idTextAnchor1970"/>nes</strong> allows <a id="_idIndexMarker1429"/>you to <a id="_idIndexMarker1430"/>configure, build, test, and deploy your code to any target system. Using Pipelines, you can enable CI and CD for consistent and quality delivery of your code. You can use pipelines targeting many application types built using popular languages such as .NET, Java, JavaScript, Node.js, PHP, and C++, and target them to deploy to either cloud or on-premises servers. You can define pipelines using YAML files or a UI-based classic editor.</p>
			<p>CI automates builds and tests for your project to ensure quality and consistency. CI can be configured to run on schedule or when new code is merged into your branch or both. CI generates artifacts that are used by CD pipelines to deploy to target systems.</p>
			<p>CD enables you to automatically deploy code to the target system and run tests. CD can be<a id="_idIndexMarker1431"/> configured <a id="_idIndexMarker1432"/>to run on a schedule.</p>
			<p>Next, let's understand mo<a id="_idTextAnchor1971"/><a id="_idTextAnchor1972"/>re about Test Plans.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor1973"/>Test Plans</h2>
			<p>Azu<a id="_idTextAnchor1974"/>re DevOps <a id="_idIndexMarker1433"/>provides<a id="_idIndexMarker1434"/> a set of tools to drive quality in your projects. It provides browser-based test management solutions with all the capabilities required for manual and exploratory testing. It provides the capability to organize <strong class="bold">test cases</strong> under <strong class="bold">test suites</strong> or <strong class="bold">test plans</strong> with which you can track the quality of a feature or a release. These are explained as follows:</p>
			<ul>
				<li><strong class="bold"><a id="_idTextAnchor1975"/>Test cases</strong> are used to <a id="_idIndexMarker1435"/>validate individual parts of your application. They contain test steps, which you can use to assert a requirement. You can reuse a test case by importing it into test suites or test plans.</li>
				<li><strong class="bold">Tes<a id="_idTextAnchor1976"/>t suites</strong> are a group <a id="_idIndexMarker1436"/>of test cases executed to validate a feature or a component. You can create static test suites, requirement-based suites, and query-based suites.</li>
				<li><strong class="bold">Test p<a id="_idTextAnchor1977"/>lans</strong> are a group of<a id="_idIndexMarker1437"/> test suites or test cases used to track the quality of each iteration of a release.</li>
			</ul>
			<p>Next, let's underst<a id="_idTextAnchor1978"/><a id="_idTextAnchor1979"/>and more about Artifacts.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor1980"/>Artifacts</h2>
			<p><strong class="bold">Artifacts</strong> makes it <a id="_idIndexMarker1438"/>easy <a id="_idIndexMarker1439"/>to share code among teams. You can easily create and<a id="_idTextAnchor1981"/> share Maven, npm, or NuGet package feeds from public and private sources, and they are easy to use in CI and CD pipelines. Artifacts are based on standard packaging formats and can be easily integrated with development IDEs, such as Visual Studio, as a package source.</p>
			<p>Azure DevOps enables coordination and collaboration within teams and helps you to deliver projects consistently with high quality. With CI and CD, you can automate the build<a id="_idIndexMarker1440"/> and <a id="_idIndexMarker1441"/>deployment of your code.</p>
			<p>In the next section, let'<a id="_idTextAnchor1982"/><a id="_idTextAnchor1983"/>s understand the CI pipeline.</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor1984"/>Understanding the CI pipeline</h1>
			<p>CI is a practice in <a id="_idIndexMarker1442"/>which you automate the building and testing of your code. I<a id="_idTextAnchor1985"/>n Azure DevOps, you can create pipelines and configure them to trigger automatically when code is merged to your target (master/main) branch, run on a schedule, or both. You may choose to create a pipeline using YAML files or a UI-based classic editor.</p>
			<p>The following figure illustrates the typical flow of code from a deve<a id="_idTextAnchor1986"/>loper's machine to the cloud:</p>
			<div><div><img src="img/Figure_16.6_B18507.jpg" alt="Figure 16.6 – Typical flow of code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.6 – <a id="_idTextAnchor1987"/>Typical flow of code</p>
			<p>From the preceding screenshot, we see the following:</p>
			<ol>
				<li>The developer uses development tools such as Visual Studio, Visual Studio Code, or Visual Studio for Mac to develop code.</li>
				<li>Code changes are moved to the repository.</li>
				<li>The CI pipeline is triggered, validates the build, runs tests, and publishes artifacts. The CD pipeline is triggered, and it deploys code to target systems.</li>
				<li>The developer uses Application Insights t<a id="_idTextAnchor1988"/>o continuously monitor and improve the application.<p class="callout-heading">Note</p><p class="callout"><strong class="bold">YAML</strong> (short for <strong class="bold">YAML <a id="_idTextAnchor1989"/>Ain't Markup Language</strong>) is the<a id="_idIndexMarker1443"/> preferred way to define your pipelines. It offers the same capabilities as a classic editor. You can check these files to repositories and<a id="_idIndexMarker1444"/> manage them <a id="_idTextAnchor1990"/>like any other source file. For more details, you can refer to <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema%2Cparameter-schema">https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema%2Cparameter-schema</a>.</p></li>
			</ol>
			<p>Let's understa<a id="_idTextAnchor1991"/>nd the core com<a id="_idTextAnchor1992"/><a id="_idTextAnchor1993"/>ponents and flow of a pipeline.</p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor1994"/>Understanding the flow and components of a pipeline</h2>
			<p><a id="_idTextAnchor1995"/>A <strong class="bold">pipeline</strong> is a <a id="_idIndexMarker1445"/>definition of a set of actions to be performed to build and test your code. A pipeline definition contains a <strong class="bold">trigger</strong>, <strong class="bold">variables</strong>, <strong class="bold">stages</strong>, <strong class="bold">jobs</strong>, <strong class="bold">steps</strong>, and <strong class="bold">tasks</strong>. When we run a pipeline, it executes <strong class="bold">tasks</strong> defined in the pipeline definition. Let's understand each of these components in the following sections.</p>
			<h3>Trig<a id="_idTextAnchor1996"/>ger</h3>
			<p>A <code>trigger</code> section of a pipeline.</p>
			<p>In the following code snippet, the pipeline is configured to trigger when code is pushed to the <code>master</code> branch or any branch under the <code>releases</code> folder. Optionally, we can also specify path filters in the pipeline so that it is triggered only when code is changed that satisfies path conditions:</p>
			<pre class="source-code">trigger:</pre>
			<pre class="source-code">  branches:</pre>
			<pre class="source-code">    include:</pre>
			<pre class="source-code"><strong class="bold">    - master</strong></pre>
			<pre class="source-code"><strong class="bold">    - releases/*</strong></pre>
			<pre class="source-code">  paths:</pre>
			<pre class="source-code">    include:</pre>
			<pre class="source-code">    - web</pre>
			<pre class="source-code">    exclude:</pre>
			<pre class="source-code">    - docs/README.md</pre>
			<p>You can also <a id="_idIndexMarker1448"/>configure <a id="_idIndexMarker1449"/>a pipeline to run automatically based on a schedule. In the following code snippet, a pipeline is configured to run<a id="_idTextAnchor1997"/> every day at 9:30 A.M. Schedules are specified using a <code>cron</code> expression and you can specify multiple schedules. If you set <code>always</code> to <code>true</code>, the build is triggered even if there is no change in the code:</p>
			<pre class="source-code">schedules:</pre>
			<pre class="source-code"><strong class="bold">- cron: "30 9 * * *"</strong></pre>
			<pre class="source-code">  displayName: Daily build</pre>
			<pre class="source-code">  branches:</pre>
			<pre class="source-code">    include:</pre>
			<pre class="source-code">    - master</pre>
			<pre class="source-code">  always: false</pre>
			<h3>Variables</h3>
			<p><strong class="bold">Variables</strong> can be <a id="_idIndexMarker1450"/>defined <a id="_idIndexMarker1451"/>with a value and reused at multiple p<a id="_idTextAnchor1998"/>laces in your pipeline. You can define variables at root, a stage, or in a job. There are three different types of variables that can be used in pipelines – user-defined, system variables, and environmental variables:</p>
			<pre class="source-code">variables:</pre>
			<pre class="source-code"><strong class="bold"> buildConfiguration: 'Release'</strong></pre>
			<pre class="source-code">. . . .</pre>
			<pre class="source-code">. . . .</pre>
			<pre class="source-code">- task: DotNetCoreCLI@2</pre>
			<pre class="source-code">  displayName: Publish</pre>
			<pre class="source-code">  inputs:</pre>
			<pre class="source-code">   command: 'publish'</pre>
			<pre class="source-code">   publishWebProjects: false</pre>
			<pre class="source-code">   projects: '**/*HelloWorld.csproj'</pre>
			<pre class="source-code"><strong class="bold">   arguments: '--configuration $(BuildConfiguration) --output $(build<a id="_idTextAnchor1999"/>.artifactstagingdirectory)/web'</strong></pre>
			<p>In the preceding code snippet, the <code>buildConfiguration</code> variable is defined with the <code>Release</code> value and is used in the <code>arguments</code> section of the task. The <code>build.artifactstagingdirectory</code> system variable contains the location of the artifacts direct<a id="_idTextAnchor2000"/>ory.</p>
			<h3>Stages</h3>
			<p><strong class="bold">Stages</strong> are a<a id="_idIndexMarker1452"/> collection <a id="_idIndexMarker1453"/>of jobs run sequentially by default. You can also specify conditions on the preceding stage execution state or add approval checks to control when a stage should run.</p>
			<p>The following is a sample pipeline definition with multiple stages:</p>
			<pre class="source-code">stages:</pre>
			<pre class="source-code">- stage: Build</pre>
			<pre class="source-code">  jobs:</pre>
			<pre class="source-code">  - job: build</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">    - script: echo building code</pre>
			<pre class="source-code">- stage: Test</pre>
			<pre class="source-code">  jobs:</pre>
			<pre class="source-code">  - job: windows</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">    - script: echo running tests on windows</pre>
			<pre class="source-code">  - job: linux</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">    - script: echo running tests on Linux</pre>
			<pre class="source-code">- stage: Deploy</pre>
			<pre class="source-code">  dependsOn: Test</pre>
			<pre class="source-code">  jobs:</pre>
			<pre class="source-code">  - job: deploy</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">    - script: echo deploying code</pre>
			<p>In the preceding<a id="_idIndexMarker1454"/> sample, three stages are configured, each runn<a id="_idTextAnchor2001"/>ing sequentially. The <code>Test</code> stage contains two jobs that can run in parallel, and the <code>Deploy</code> stage has a dependency on the <code>Test</code> stage.</p>
			<p>The following is a screenshot of the pipeline execution summary of the preceding sample, and you c<a id="_idTextAnchor2002"/>an click on each stage to view the logs:</p>
			<div><div><img src="img/Figure_16.7_B18507.jpg" alt="Figure 16.7 – Summary of a pipeline run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.7 – Summary of a pi<a id="_idTextAnchor2003"/>peline run</p>
			<h3>Jobs</h3>
			<p><code>testNull</code> variable:</p>
			<pre class="source-code">variables:</pre>
			<pre class="source-code">- name: testNull</pre>
			<pre class="source-code">  value: ''</pre>
			<pre class="source-code">jobs:</pre>
			<pre class="source-code">  - job: BuildJob</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">    - script: echo Building!</pre>
			<pre class="source-code"><strong class="bold">    condition: eq('${{ variables.testNull }}', '')</strong></pre>
			<p>In the preceding code, the job is configured with a condition to run only when <code>testNull</code> is <a id="_idTextAnchor2004"/>empty.</p>
			<h4>Steps and tasks</h4>
			<p><strong class="bold">Steps</strong> are groups<a id="_idIndexMarker1457"/> of tasks in your pipeline. These could be to build your code, run tests, or publish artifacts. Each step is executed on the agent and has access to the pipeli<a id="_idTextAnchor2005"/>ne workspace.</p>
			<p><code>DotNetCoreCLI@2</code> task to build <code>csproj</code>:</p>
			<pre class="source-code">- task: DotNetCoreCLI@2</pre>
			<pre class="source-code">  displayName: build</pre>
			<pre class="source-code">  inputs:</pre>
			<pre class="source-code">   command: 'build'</pre>
			<pre class="source-code">   projects: '**/*.csproj'</pre>
			<pre class="source-code">   arguments: '--configuration $(BuildConfiguration)'</pre>
			<p>To learn more about pipelines, you can refer to <a href="https://docs.microsoft.com/en-in/azure/devops/pipelines/create-first-pipeline?view=azure-devops&amp;tabs=java%2Ctfs-2018-2%2Cbrowser">https://docs.microsoft.com/en-in/azure/devops/pipelines/create-first-pipeline?view=azure-devops&amp;tabs=java%2Ctfs-2018-2%2Cbrowser</a>.</p>
			<p>In the next sect<a id="_idTextAnchor2006"/><a id="_idTextAnchor2007"/>ion, let's learn more about the CD pipeline.</p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor2008"/>Understanding the CD pipeline</h1>
			<p>CD is a process<a id="_idIndexMarker1459"/> by which you automate the deployment of code to ta<a id="_idTextAnchor2009"/>rget environments. CD pipelines use artifacts produced by CI pipelines and deploy to one or more environments. Like the CI pipeline, we can use YAML files or a classic editor to define a CD pipeline. You can specify conditions on the preceding stage execution state or add approval checks to deploy, which is a very common scenario for production deployments.</p>
			<p>You can also configure to run automated UI tests to perform a sanity check post-deployment. Based on the sanity check results, you can configure it to automatically promote code to a higher environment.</p>
			<p>At any point in time, if the deployment to a stage fails, we can re-deploy code from previous releases. Depending on the configured retention policy under the project settings, Azure DevOps retains build artifacts so that it is easy to deploy code of any version at any time. If you find any issues with the application post-deployment, you can easily find the last<a id="_idIndexMarker1460"/> known good release and deploy code to minimize the business impact.</p>
			<p>Let's unders<a id="_idTextAnchor2010"/><a id="_idTextAnchor2011"/>tand more about this in the following secti<a id="_idTextAnchor2012"/>on.</p>
			<h2 id="_idParaDest-304">Continuous deploymen<a id="_idTextAnchor2013"/>t versus CD</h2>
			<p>Continuous <a id="_idIndexMarker1461"/>deployment <a id="_idIndexMarker1462"/>is automated deployment to the target system whenever new code is merged to your repository, whereas CD makes the application available to deploy at any time to the target system. Azure DevOps offers multi-staged pipelines; you can configure pipelines with stages to achieve this.</p>
			<p>Continuous deployment is usually configured on lower environments, such as dev or test, whereas for higher environments such as staging or production, you should consider CD so that you can validate changes on lower environments and approve to deploy code to higher environments.</p>
			<p>The following screenshot illustrates a multi-stage pi<a id="_idTextAnchor2014"/>peline, with automated build and release to dev<a id="_idTextAnchor2015"/>, and waiting for approval in the test stage. In this cas<a id="_idTextAnchor2016"/>e, releasing code to testing requires approval:</p>
			<div><div><img src="img/Figure_16.8_B18507.jpg" alt="Figure 16.8 – Multi-stage pipeline pending approval&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.8 – Multi-stage pipeline pending approval</p>
			<p>To learn more about how to configure approvals and check on Azure pipelines, you can refer to <a href="https://docs.microsoft.com/en-in/azure/devops/pipelines/process/approvals?view=azure-devops&amp;tabs=check-pass">https://docs.microsoft.com/en-in/azure/devops/pipelines/process/approvals?view=azure-devops&amp;tabs=check-pass</a>.</p>
			<p>To view the details of a pipeline run, you can click on any stage to view the logs of that run. Logs help us to troubleshoot deployment failures. The following scre<a id="_idTextAnchor2017"/>enshot illustrates the<a id="_idIndexMarker1463"/> logs <a id="_idIndexMarker1464"/>of a pipeline run:</p>
			<div><div><img src="img/Figure_16.9_B18507.jpg" alt="Figure 16.9 – Pipeline execution details&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16<a id="_idTextAnchor2018"/>.9 – Pipeline executi<a id="_idTextAnchor2019"/>on details</p>
			<p>In the preceding screenshot, you will notice that you can view stages, jobs, and tasks configured in<a id="_idIndexMarker1465"/> the <a id="_idIndexMarker1466"/>pipeline, and you can click on tasks to view logs.</p>
			<p>In the next section, we will learn how to cre<a id="_idTextAnchor2020"/><a id="_idTextAnchor2021"/>ate a pipeline to build and deploy an application.</p>
			<h1 id="_idParaDest-305">Deploying an ASP<a id="_idTextAnchor2022"/>.NET 6 application</h1>
			<p>So far in this chapter, we <a id="_idIndexMarker1467"/>have explored Azure DevOps, understood the tools and services it offers, and then learned about CI and CD pipelines. In this section, we shall learn how to create an Azure DevOps project, clone the repository, push code to the repository, and create a CI and CD pipeline to deploy code to Azure App Service.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Do check the <em class="italic">Technical requirements</em> section to ensure you have everything set up before you deploy the sample application.</p>
			<p>You can follow along with these steps to deploy an ASP.NET 6 application to Azure:</p>
			<ol>
				<li value="1">Log in to your Azure DevOps account. Create an Azure DevOps account if you don't have one; you can follow the steps given at <a href="https://docs.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates?view=azure-devops</a>.</li>
				<li>On the home <a id="_idIndexMarker1468"/>page of Azure DevOps, provide a name for your project, say, <code>HelloWorld</code>, then for <strong class="bold">Version con<a id="_idTextAnchor2023"/>trol</strong>, choose <strong class="bold">Git</strong>, and for <strong class="bold">Work item process</strong>, you can choose <strong class="bold">Agile</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_16.10_B18507.jpg" alt="Figure 16.10 – New Azure DevOps project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.10 – New Azure DevOps project</p>
			<ol>
				<li value="3">Now, let's<a id="_idIndexMarker1469"/> create a service connection, which we will use in the pipeline to connect and deploy code to Azure App Service.</li>
			</ol>
			<p>From the left menu, navigate to <strong class="bold">Project settings</strong> | <strong class="bold">Service connections</strong> | <strong class="bold">Create service connection</strong> | <strong class="bold">Azur<a id="_idTextAnchor2024"/>e Resource Manager</strong> | <strong class="bold">Service Principal (automatic)</strong>:</p>
			<div><div><img src="img/Figure_16.11_B18507.jpg" alt="Figure 16.11 – New service principal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure <a id="_idTextAnchor2025"/>16.11 – New service principal</p>
			<p>The service<a id="_idIndexMarker1470"/> principal enables pipelines to connect to your Azure subscription to manage resources or deploy your code to Azure services.</p>
			<ol>
				<li value="4">Select a subscription and provide a name for the connection to create a service connection. Azure DevOps uses this service con<a id="_idTextAnchor2026"/>nection to connect Azure resources and deploy co<a id="_idTextAnchor2027"/>de:</li>
			</ol>
			<div><div><img src="img/Figure_16.12_B18507.jpg" alt="Figure 16.12 – New service principal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.12 – New service principal</p>
			<ol>
				<li value="5">Once the <a id="_idIndexMarker1471"/>project is created, you should see a page similar to the following<a id="_idTextAnchor2028"/>. From the left menu, under <strong class="bold">Repos</strong>, select <strong class="bold">Branches</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_16.13_B18507.jpg" alt="Figure 16.13 – Azure DevOps Home | Repos screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.13 – Azure DevOps Home | Repos screen</p>
			<ol>
				<li value="6">Copy the <a id="_idIndexMarker1472"/>link, which we wil<a id="_idTextAnchor2029"/>l use to clone the repository to our local machine:</li>
			</ol>
			<div><div><img src="img/Figure_16.14_B18507.jpg" alt="Figure 16.14 – Clone repository&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.14 – Clone repository</p>
			<ol>
				<li value="7">To clone the repository to your system, open Command Prompt and navigate to a folder to which you want to clone the code, t<a id="_idTextAnchor2030"/>hen run the following command.</li>
			</ol>
			<p>Replace <code>&lt;organization&gt;</code> with your Azure DevOps organization:</p>
			<pre>git clone https://&lt;organization&gt;@dev.azure.com/&lt;organization&gt;<a id="_idTextAnchor2031"/>/HelloWorld/_git/HelloWorld</pre>
			<ol>
				<li value="8">Since our repository is new and empty, we need to add code to it. The following <code>dotnet</code> CLI commands would help us to create an ASP.NET 6 application and an xUnit project, create a solu<a id="_idTextAnchor2032"/>tion file, and add a web and tests project to it. Run each command in sequence to continue:<pre><strong class="bold">dotnet new mvc --auth Individual -o HelloWorld</strong>
<strong class="bold">dotnet new xunit -o HelloWorld.Tests</strong>
<strong class="bold">dotnet new sln</strong>
<strong class="bold">dotnet sln add HelloWorld/HelloWorld.csproj</strong>
<strong class="bold">dotnet sln add HelloWorld.Tests/HelloWorld.Tests.csproj</strong></pre></li>
				<li>Run the following commands to build code and run tests to verify whether it is all good:<pre><strong class="bold">dotnet build</strong>
<strong class="bold">dotnet test</strong></pre></li>
			</ol>
			<p>Now that we<a id="_idIndexMarker1473"/> have tested the code, next let's see how the p<a id="_idTextAnchor2033"/><a id="_idTextAnchor2034"/>ipeline is created for CI and CD for using the code.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor2035"/>Creating a pipeline for CI and CD</h2>
			<p>After running <a id="_idIndexMarker1474"/>the tests, we<a id="_idIndexMarker1475"/> need to see how the CI and CD pipeline is created. Perform the following steps:</p>
			<ol>
				<li value="1">Next, we need to create a pipeline for CI and CD. You can use the code available at <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/master/Chapter16/Pipelines/HelloWorld/azure-ci-pipeline.yml">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/master/Chapter16/Pipelines/HelloWorld/azure-ci-pipeline.yml</a> and save it in the root directory of the repository. Let's name it <code>azure-ci-pipeline.yml</code>.</li>
			</ol>
			<p>This pipeline is configured to trigger when new code is merged to the <code>main</code> branch.</p>
			<ol>
				<li value="2">It is configured to have three stages – build, <a id="_idTextAnchor2036"/>dev, and test – where the build stage is configured to build code, run unit tests, and publish artifacts. The dev and test stages are configured to deploy code to Azure App Service.</li>
				<li>Dependencies are configured at the dev and test stages, where the dev stage depends on build, and the test depends on the dev stage.</li>
			</ol>
			<p>Let's examine a few important sections of this YAML file.</p>
			<p>The<a id="_idIndexMarker1476"/> following <a id="_idIndexMarker1477"/>snippet contains a section to define variables:</p>
			<pre>trigger:
- main
variables:
  BuildConfiguration: 'Release'
  buildPlatform: 'Any CPU'
  solution: '**/*.sln'
  <strong class="bold">azureSubscription</strong>: 'HelloWorld-Con' # replace this
<strong class="bold">  #</strong> with your service connection name to connect Azure 
<strong class="bold">  #</strong>subscription
  <strong class="bold">devAppServiceName</strong>: 'webSitejtrb7psidvozs' # replace 
<strong class="bold">  #</strong>this with your app service name
  <strong class="bold">testAppServiceName</strong>: 'webSitejtrb8psidvozs' # replace 
<strong class="bold">  #</strong>this with your app service name</pre>
			<p>You will notice three variables are declared in the YAML file. Provide the appropriate values before you save the file:</p>
			<ul>
				<li><code>azureSubscription</code>: Provide the name of your service connection.</li>
				<li><code>devAppServiceName</code>: Provide the name of the app service for<a id="_idTextAnchor2037"/> dev deployment.</li>
				<li><code>testAppServiceName</code>: Provide the name of the app service for test deployment.</li>
			</ul>
			<p>To build code, we use the <code>DotNetCoreCLI@2</code> task and configure <code>command</code>, <code>projects</code>, and, optionally, <code>arguments</code>:</p>
			<pre>- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    command: 'build'
    projects: '**/*.csproj'</pre>
			<p><code>command</code> is <a id="_idIndexMarker1478"/>configured <a id="_idIndexMarker1479"/>as <code>build</code> and the path is set to <code>csproj</code> for <code>projects</code> to build the code. This task runs .NET CLI commands, so we can also configure this task with other .NET CLI commands, such as <code>run</code>, <code>test</code>, <code>publish</code>, <code>restore</code>, and so on.</p>
			<ol>
				<li value="4">To publish the code, the <code>PublishBuildArtifacts@1</code> task is used. It is configured with <code>PathtoPublish</code>, <code>ArtifactName</code>, and <code>publishLocation</code>:<pre>- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: 
      '$(Build.ArtifactStagingDirectory)/web'
    ArtifactName: 'drop'
    publishLocation: 'Container'</pre></li>
			</ol>
			<p><code>PathtoPublish</code> is configured with the location of the artifact directory where build artifacts are available, <code>ArtifactName</code> as <code>drop</code>, and <code>publishLocation</code> as <code>Container</code> to publish artifacts to Azure Pipelines. Alternatively, we can also <a id="_idTextAnchor2038"/>configure <code>publishLocation</code> as <code>FileShare</code>.</p>
			<p>The following code snippet does the required actions to deploy code:</p>
			<pre>- download: current
  artifact: drop
- task: AzureWebApp@1
  displayName: 'Azure App Service Deploy: website'
  inputs:
    azureSubscription: '$(azureSubscription)'
    appType: 'webApp'
    appName: '$(devAppServiceName)'
    package: '$(Pipeline.Workspace)/drop/*.zip'
    deploymentMethod: 'auto'</pre>
			<p>In the<a id="_idIndexMarker1480"/> deployment<a id="_idIndexMarker1481"/> job, the first step is to download the artifact, and the artifact's name should be the same as the one that is configured in the <code>PublishBuildArtifacts@1</code> task, in this case, <code>drop</code>.</p>
			<p>The <code>AzureWebApp@1</code> task is used to deploy artifacts to Azure App Service. The required parameters are <code>azureSubscription</code>, <code>appType</code>, <code>appName</code>, <code>package</code>, and <code>deploymentMethod</code> (as <code>auto</code>).</p>
			<p>Now that the artifact is ready, we see how the code is committed and code changes are pushed.</p>
			<h3>Pushing the code</h3>
			<p>Now that<a id="_idIndexMarker1482"/> the code <a id="_idIndexMarker1483"/>and pipeline are ready, the next step is to commit and push these changes to the Azure DevOps repository:</p>
			<ol>
				<li value="1">In Command Prompt, run the following commands to commit changes locally and push them to Azure DevO<a id="_idTextAnchor2039"/>ps:<pre><strong class="bold">git add .</strong>
<strong class="bold">git commit -m "Initial Commit"</strong>
<strong class="bold">git push</strong></pre></li>
				<li>In Azure DevOps, navigate to <a id="_idTextAnchor2040"/><strong class="bold">Pipelines</strong> and click <strong class="bold">Create Pipeline</strong> to create a new pipeline:</li>
			</ol>
			<div><div><img src="img/Figure_16.15_B18507.jpg" alt="Figure 16.15 – New pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.15 – New pipeline</p>
			<ol>
				<li value="3">To configure the pipeline, we need to perform four steps. Select the service in which your repository resides, select the repository, configure the pipeline, and save. For this implementation, select <strong class="bold">A<a id="_idTextAnchor2041"/>zure Repos Git</strong> to continue, and then select y<a id="_idTextAnchor2042"/>our repository:</li>
			</ol>
			<div><div><img src="img/Figure_16.16_B18507.jpg" alt="Figure 16.16 – Source control selection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.16 – Source control selection</p>
			<ol>
				<li value="4">In<a id="_idIndexMarker1484"/> the <strong class="bold">Configure<a id="_idTextAnchor2043"/></strong> tab, choose <strong class="bold">Existing Azure Pipelines YAML file</strong> to <a id="_idIndexMarker1485"/>continue:</li>
			</ol>
			<div><div><img src="img/Figure_16.17_B18507.jpg" alt="Figure 16.17 – Configuration pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">F<a id="_idTextAnchor2044"/>igure 16.17 – Configuration pipeline</p>
			<ol>
				<li value="5">Select<a id="_idIndexMarker1486"/> the<a id="_idIndexMarker1487"/> pipeline file we saved earlier in the repository a<a id="_idTextAnchor2045"/>nd click <strong class="bold">Continue</strong>, and then click <strong class="bold">Run</strong> to trigger the pipeline:</li>
			</ol>
			<div><div><img src="img/Figure_16.18_B18507.jpg" alt="Figure 16.18 – YAML file selection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.18 – YAML file selection</p>
			<ol>
				<li value="6">This will open a page in which we <a id="_idTextAnchor2046"/>can see the state of the pipeline. The following screenshot is taken from the <a id="_idTextAnchor2047"/>pipeline run. You will notice three stages have been created:</li>
			</ol>
			<div><div><img src="img/Figure_16.19_B18507.jpg" alt="Figure 16.19 – Summary of the pipeline run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.19 – Summary of the pipeline run</p>
			<p>In the<a id="_idIndexMarker1488"/> build <a id="_idIndexMarker1489"/>stage, you will notice two jobs in progress.</p>
			<p>The dev stage and test stage are waiting for the build to complete.</p>
			<p>Optionally, you can enable deployment slots on Azure App Service and configure the pipeline to deploy code to a non-production deployment slot, say, <em class="italic">pre-prod</em>. Once you check the sanity of the deployed code, you can swap the <em class="italic">production</em> slot with <em class="italic">pre-prod</em>. The swap is instantaneous and, without any downtime, you can make the latest changes available to users. If you notice any issues, you can swap back to t<a id="_idTextAnchor2048"/>he previous slot to go back to the last known good version. For more information, you can refer to <a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots">https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots</a>.</p>
			<ol>
				<li value="7">After the pipeline execution is c<a id="_idTextAnchor2049"/>omplete, navigate to <strong class="bold">Environments</strong> under <strong class="bold">Pipelines</strong> from the left me<a id="_idTextAnchor2050"/>nu. You will notice the dev and test environments are created:</li>
			</ol>
			<div><div><img src="img/Figure_16.20_B18507.jpg" alt="Figure 16.20 – Environments&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.20 – Environments</p>
			<ol>
				<li value="8">Click on<a id="_idIndexMarker1490"/> the <strong class="bold">test</strong> stage<a id="_idIndexMarker1491"/> and in the m<a id="_idTextAnchor2051"/>ore actions selection, select <strong class="bold">Approvals and checks</strong> t<a id="_idTextAnchor2052"/>o continue:</li>
			</ol>
			<div><div><img src="img/Figure_16.21_B18507.jpg" alt="Figure 16.21 – Approvals and checks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.21 – Approvals and checks</p>
			<ol>
				<li value="9">You will find many options <a id="_idIndexMarker1492"/>to <a id="_idIndexMarker1493"/>choose fro<a id="_idTextAnchor2053"/>m, such as <strong class="bold">Approvals</strong>, <strong class="bold">Branch control</strong>, <strong class="bold">Business Hours</strong>, and<a id="_idTextAnchor2054"/> so on:</li>
			</ol>
			<div><div><img src="img/Figure_16.22_B18507.jpg" alt="Figure 16.22 – Add checks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.22 – Add checks</p>
			<ol>
				<li value="10">Select <strong class="bold">Approvals</strong> to <a id="_idIndexMarker1494"/>continue and it will open a dialog where<a id="_idIndexMarker1495"/> we can select users/gro<a id="_idTextAnchor2055"/>ups as approvers. Provide the necessary details and click <strong class="bold">Create</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_16.23_B18507.jpg" alt="Figure 16.23 – Add approvals&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.23 – Add approvals</p>
			<ol>
				<li value="11">Re-run the pipeline to test the c<a id="_idTextAnchor2056"/>hanges. You w<a id="_idTextAnchor2057"/>ill notice the pipeline is waiting to execute at the test stage:</li>
			</ol>
			<div><div><img src="img/Figure_16.24_B18507.jpg" alt="Figure 16.24 – Multi-stage pipeline with pending approvals&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.24 – Multi-stage pipeline with pending approvals</p>
			<ol>
				<li value="12">Click on <strong class="bold">Review</strong>, which <a id="_idIndexMarker1496"/>will<a id="_idIndexMarker1497"/> open a dia<a id="_idTextAnchor2058"/>log to approve or reject. Click <strong class="bold">Approve</strong> to finish the deployment:</li>
			</ol>
			<div><div><img src="img/Figure_16.25_B18507.jpg" alt="Figure 16.25 – Approve or reject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.25 – Approve or reject</p>
			<p>To summarize, in this section, we started with the creation <a id="_idTextAnchor2059"/>of a new project in Azure DevOps, then cloned the repository to a local system, created a simple ASP.NET Core application using the .NET CLI, created a pipeline in YAML to build, test, and publish artifacts and deploy them to Azure App Service, and committed and pushed code back to the repository. Next, we <a id="_idIndexMarker1498"/>created a new CI/CD pipeline by selecting a <a id="_idIndexMarker1499"/>YAML file in our repository and triggered the pipeline. In <strong class="bold">Environments</strong>, we configu<a id="_idTextAnchor2060"/><a id="_idTextAnchor2061"/>red approval checks and triggered the pipeline to see how it works.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor2062"/>Summary</h1>
			<p>In this chapter, we understood what Azure DevOps is, as well as the tools and services it offers. We understood how services such as Boards, Repos, Pipelines, Test Plans, and Artifacts help us to efficiently execute a project.</p>
			<p>Next, we looked at CI and CD pipelines and their core components. We also learned how they help us to automate the building and deployment of code. We concluded this chapter by learning how to create an ASP.NET 6 application, and a pipeline to build and deploy to Azure App Service using CI and CD pipelines.</p>
			<p>I hope this book has helped you to enhance your .NET skills and motivated you to try out and build more of its applications. There are further topics that you can explore by referring to the notes and the <em class="italic">Further reading</em> sections of the chapters.</p>
			<p>For enterprise applications, we have also covered the happy path scenarios for a typical e-commerce application, and it can be further extended based on the requirements defined in <a href="B18507_01_Epub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing and Architecting the Enterprise Application</em>. There are examples to extend the authentication/authorization for an end-to-end flow, using an API gateway for service-to-service communication and authentication, and implementing the notification service, for you to learn more.<a id="_idTextAnchor2063"/><a id="_idTextAnchor2064"/></p>
			<p>We wish you the best in your C# and .NET projects. Happy learning!</p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor2065"/>Questions</h1>
			<ol>
				<li value="1">How does continuous deployment differ from CD?</li>
			</ol>
			<p>a. CD works with databases and continuous deployment supports web applications.</p>
			<p>b. Continuous deployment is released to an environment <em class="italic">every</em> time, whereas CD is released to an environment at <em class="italic">any</em> one time.</p>
			<p>c. Continuous deployment requires the cloud, while CD works with on-premises servers.</p>
			<p>d. Continuous deployment is released to an environment at <em class="italic">any</em> one time, whereas CD is released to an environment <em class="italic">every</em> time.</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="2">What are the characteristics of the CD approach? (Choose two)</li>
			</ol>
			<p>a. A focus on cycle time reduction</p>
			<p>b. A small amount of complex releases</p>
			<p>c. Resource-based management of the process</p>
			<p>d. Self-managed and responsive teams</p>
			<p><strong class="bold">Answers : a and d</strong></p>
			<ol>
				<li value="3">Which component provides the first feedback on the quality of committed application code changes?</li>
			</ol>
			<p>a. Automated deployment</p>
			<p>b. Aut<a id="_idTextAnchor2066"/><a id="_idTextAnchor2067"/>omated provisioning</p>
			<p>c. Automated build</p>
			<p>d. Automated test</p>
			<p><strong class="bold">Answer: c</strong></p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor2068"/>Further reading</h1>
			<p>To learn more about Azure DevOps, you can refer to <a href="https://docs.microsoft.com/en-in/azure/devops/user-guide/services?view=azure-devops">https://docs.microsoft.com/en-in/azure/devops/user-guide/services?view=azure-devops</a>, and for pipelines, you can refer to <a href="https://docs.microsoft.com/en-in/azure/devops/pipelines/get-started/pipelines-get-started?view=azure-devops">https://docs.microsoft.com/en-in/azure/devops/pipelines/get-started/pipelines-get-started?view=azure-devops</a>.</p>
		</div>
	</body></html>