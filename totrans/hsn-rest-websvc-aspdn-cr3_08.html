<html><head></head><body>
        

                            
                    <h1 class="header-title">Routing System</h1>
                
            
            
                
<p class="mce-root">This chapter describes the routing functionalities of ASP.NET Core. The routing part of the framework is designed to provide a dynamic routing system that's fully customizable and overridable to cover most of the use cases of a web service. Here, we will discover how to use <em>conventional</em> and <em>attribute routing</em> approaches, and then we will dig into the use of routing constraints in order to match complex rules and provide higher customization.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>A brief overview of the routing system</li>
<li>Conventional routing versus attribute routing</li>
<li>Binding routing parameters</li>
<li>Routing constraints</li>
<li>Custom attribute routing and custom routing constraints</li>
</ul>
<p>The topics covered in this chapter provide some basic knowledge around the routing system of ASP.NET Core and how to use the routing engine of ASP.NET Core to cover all the use cases that are needed by our web service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of the routing system</h1>
                
            
            
                
<p>The routing system of ASP.NET Core maps an incoming request to a <em>route handler</em>. In ASP.NET Core, the <kbd>Startup</kbd> class is responsible for configuring the routes that are needed by the application. Furthermore, the routing functionalities of ASP.NET Core are implemented using a middleware approach. Let's take a closer look at the <kbd>Startup</kbd> class and how it initializes the routing system:</p>
<pre>public class Startup<br/>{<br/>    ...<br/>    <br/>    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>    {<br/>      <strong>  app.UseRouting();</strong><br/>        ...<br/>       <strong> app.UseEndpoints(endpoints =&gt;</strong><br/><strong>        {</strong><br/><strong>            endpoints.MapControllers();</strong><br/><strong>        });</strong><br/>    }<br/>}</pre>
<p>The preceding code uses two extension methods: <kbd>UseRouting</kbd> and <kbd>UseEndpoints</kbd>. These methods were introduced in the latest release of ASP.NET Core. In the previous version of the framework, the routing system was initialized with the <kbd>UseMvc</kbd> extension method, which is now deprecated. The <kbd>UseRouting</kbd> extension method is used to define where, in the middleware pipeline, the routing decisions are made. On the other side, the <kbd>UseEndpoints</kbd> extension method declares the mapping of effective routes. For example, in the preceding code snippet, the <kbd>Startup</kbd> class uses the <kbd>MapControllers()</kbd> extension method to map the controller routes and declares the default routing convention that's implemented by ASP.NET Core. </p>
<p>To summarize, when the <kbd>Startup</kbd> class executes the <kbd>UseRouting</kbd> and <kbd>UseEndpoints</kbd> extension methods, ASP.NET Core adds a new <kbd>EndpointRoutingMiddleware</kbd> class to mark the routing point and <kbd>EndpointMiddleware</kbd> in the pipeline, which describes our routes. The preceding calls can be summarized as follows:</p>
<div><img src="img/cf3f48b4-907b-4e22-a636-b9c151f486d6.png" style=""/></div>
<p>Furthermore, it is possible to define new <em>route templates</em> inside our <kbd>Startup</kbd> class using the following syntax:</p>
<pre>...<br/>public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>{<br/>    ...<br/>    <br/>    app.UseEndpoints(endpoints =&gt;<br/>    {<br/>       <strong> endpoints.MapControllerRoute("default", "{controller}/{action}/{id?}");</strong><br/>    });<br/>}<br/>...<br/></pre>
<p>This implementation creates a new <em>route template</em> that maps a generic route such as <kbd>https://myhostname/mycontroller/myaction</kbd><em> </em>with a controller named <kbd>MyController</kbd> and an action named <kbd>MyAction</kbd>. This way of defining routing is called <strong>conventional routing</strong>, in the sense that it establishes a convention between our handlers (the controllers) and the URI system. We will discuss conventional routing in more detail in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conventional routing</h1>
                
            
            
                
<p>The <em>conventional</em><em> routing </em>is the default routing approach in ASP.NET Core<em>.</em> As we have already seen, this approach uses the <kbd>app.UseEndpoints</kbd> extension method in the <kbd>Startup</kbd> class to declare routing templates:</p>
<pre>    app.UseEndpoints(endpoints =&gt;<br/>    {<br/>       <strong> endpoints.MapControllerRoute("default", "{controller}/{action}/{id?}");</strong><br/>    });<strong> </strong></pre>
<p>By default, ASP.NET Core applies the <kbd>default</kbd> <em>route template</em> to the routing engine, which maps each segment of our URL with the <kbd>controller</kbd> name, the <kbd>action</kbd> name, and the <kbd>id</kbd> name<em>,</em> respectively<em>.</em> Furthermore, it is possible to define multiple routes in our application by adding them to the routing builder in the <kbd>Startup</kbd> class:</p>
<pre>app.UseEndpoints(endpoints =&gt;<br/>{<br/>    endpoints.MapControllerRoute("default", "{controller}/{action}/{id?}");<br/><br/>    <strong>endpoints.MapControllerRoute("order", "order/givemeorders", </strong><strong>new { controller = "Order", action = "Get" });</strong><br/>});</pre>
<p>In this case, the <kbd>https://myhostname/order/givemeorders</kbd> route will be mapped to the <kbd>Get</kbd> action of <kbd>OrderController</kbd>. We should notice that the<em> </em>routing template example we defined in the preceding code is not compliant with the REST architectural style. Accordingly, it doesn't respect the 2<sup>nd</sup> level of the Richardson Maturity Model, as mentioned in <a href="b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml">Chapter 1</a>, <em>REST 101 and Getting Started with ASP.NET Core</em>. Furthermore, if we apply the <kbd>default</kbd> routing template to <kbd>OrderController</kbd> we discussed in previous chapters, the <kbd>Get</kbd> action method will respond to the following URI: <kbd>https://localhost/order/get</kbd>.</p>
<p>To make our routing template compliant with the Richardson Maturity Model, let's introduce the <kbd>Map</kbd> method that's provided by ASP.NET Core. It is possible to map different HTTP verbs using <em>routing templates</em>, as follows:</p>
<pre>app.UseEndpoints(endpoints =&gt;<br/>{<br/><strong>    endpoints.MapGet("order", context =&gt; context.Response.WriteAsync("Hi, from GET verb!"));</strong><br/><strong>    endpoints.MapPost("order", context =&gt; context.Response.WriteAsync("Hi, from POST verb!"));</strong><br/>});</pre>
<p>The <kbd>MapGet</kbd>, <kbd>MapPost</kbd>, <kbd>MapPut</kbd>, and <kbd>MapDelete</kbd> methods accept the <em>route template</em> as the first parameter and a <kbd>RequestDelegate</kbd> method, which provides a way to handle <kbd>HttpContext</kbd> of the current request. However, it is not possible to call the <kbd>OrderController</kbd> logic in <kbd>RequestDelegate</kbd> because there isn't an effortless way to access the controllers' instances from the context. Therefore, there isn't an easy way to implement a REST-compliant routing system using <em>conventional routing.</em> In general, conventional routing is mainly designed for web applications that serve views and HTML. An alternative solution is to use the <em>attribute routing</em> technique, which is the most solid way to implement controllers' routing in a web services context.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attribute routing</h1>
                
            
            
                
<p>The <em>attribute routing</em> technique is a different way to implement routing in ASP.NET Core. It moves the declaration of routing within the controllers' implementation using attributes to describe the routes in a metaprogramming way:</p>
<pre><strong>     [Route("api/order")]</strong><br/>     [ApiController]<br/>     public class OrderController : ControllerBase<br/>     {<br/>         private readonly IOrderRepository _orderRepository;<br/> <br/>         public OrderController(IOrderRepository orderRepository)<br/>         {<br/>             _orderRepository = orderRepository;<br/>             <br/>         } <br/>     ...</pre>
<p>The <kbd>Route</kbd> attribute declares the routing template within the controller or the action. The routing attribute is the default approach of the web API template in ASP.NET Core. Another critical thing to notice is that this practice doesn't need any route definition in the <kbd>Startup</kbd> class; therefore, <kbd>app.MapControllers()</kbd> is invoked without route parameters.</p>
<p>Furthermore, this kind of approach also provides more flexibility when it comes to binding each action method with a specific route:</p>
<pre>    [Route("api/order")]<br/>    [ApiController]<br/>    public class OrderController : ControllerBase<br/>    {<br/>        <strong>[HttpGet]</strong><br/>        public IActionResult Get() {<br/>            ...<br/>        }<br/><br/>        <strong>[HttpGet("{id:guid}")]</strong><br/>        public IActionResult GetById(Guid id) {<br/>            ...<br/>        }<br/><br/>        <strong>[HttpPost]</strong><br/>        public IActionResult Post(OrderRequest request) {<br/>            ...<br/>        }<br/><br/>        <strong>[HttpPut("{id:guid}")]</strong><br/>        public IActionResult Put(Guid id, OrderRequest request) {<br/>            ...<br/>        }<br/><br/>        <strong>[HttpPatch("{id:guid}")]</strong><br/>        public IActionResult Patch(Guid id, JsonPatchDocument&lt;Order&gt; <br/>        requestOp) {<br/>            ...<br/>        }<br/><br/>      <strong>  [HttpDelete("{id:guid}")]</strong><br/>        public IActionResult Delete(Guid id) {<br/>            ...<br/>        }<br/>    }</pre>
<p>The preceding controller uses <kbd>HttpVerb</kbd> to map each action method to one particular HTTP verb. Furthermore, it also uses the <kbd>HttpVerb</kbd> attribute to define the last segment of the URI, which usually contains the parameters of our target resource.</p>
<p>The <kbd>Route("api/order")</kbd> attribute defines a static route segment. ASP.NET Core provides some reserved placeholders, that is, <kbd>[controller]</kbd>, <kbd>[action]</kbd>, and <kbd>[area]</kbd><em>,</em> which<em> </em>are replaced at runtime with the corresponding <kbd>controller</kbd>, <kbd>action</kbd>, or <kbd>area</kbd>. For example, we can achieve the same result by using <kbd>Route("api/[controller]")</kbd> because the  <kbd>OrderController</kbd> name will replace the <kbd>[controller]</kbd> placeholder. As I mentioned in the previous chapter, I strongly suggest that you avoid this kind of approach because, in a real-world application, you may accidentally change the route of your API by merely refactoring a controller's name.</p>
<p>Moving forward, let's have a look at custom attribute routing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom attribute routing</h1>
                
            
            
                
<p>The routing engine of ASP.NET Core also provides a way for us to create our routing attributes. This technique is useful in complex routing systems where it is essential to keep a conceptual order between different routes. An example of a custom routing definition is as follows:</p>
<pre>using System;<br/>using Microsoft.AspNetCore.Mvc.Routing;<br/><br/>namespace SampleAPI.CustomRouting<br/>{<br/>    public class CustomOrdersRoute : Attribute, IRouteTemplateProvider<br/>    {<br/>        public string Template =&gt; "api/orders";<br/><br/>        public int? Order { get; set; }<br/><br/>        public string Name =&gt; "Orders_route";<br/>    }<br/>}</pre>
<p>The class extends the <kbd>Attribute</kbd> abstract class, which is to be applied as an attribute. It implements <kbd>IRouteTemplateProvider</kbd> to get the attributes of the r<em>outing template workflow. </em>As a result, the application of the attribute looks as follows:</p>
<pre><strong>[CustomOrdersRoute]</strong><br/>[ApiController]<br/>public class OrderController : ControllerBase<br/>{<br/>    ...</pre>
<p class="p1">This approach is really useful when we want to implement a more complex routing system. Therefore, it is possible to apply concepts such as inheritance to improve the reusability of the implemented routing rules.</p>
<p>This section provided an understanding of different routing approaches of ASP.NET Core: <em>conventional routing</em> and <em>attribute routing</em>. In the next section, we will discover how to use the <em>routing constraints</em> rules provided by the framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Routing constraints</h1>
                
            
            
                
<p><em>Routing constraints</em> are part of the templating routing system of ASP.NET Core. They provide a way for us to match a route with a parameter type or a set of values, like so:</p>
<pre>app.UseEndpoints(endpoints =&gt;<br/>{<br/>    endpoints.MapControllerRoute("default", "{controller}/{action}/<strong>{id:guid?}</strong>");<br/>});</pre>
<p>In this case, our route template will match all the <kbd>https://myhostname/mycontroller/myaction</kbd> calls and all the calls that present a valid <kbd>Guid</kbd> as an <kbd>id</kbd> parameter, for example, <kbd>https://myhostname/mycontroller/myaction/4e10de48-9590-4531-9805-799167d58a44</kbd>. The <kbd>{id:guid?}</kbd> expression gives us two pieces of information about constraints: first, the parameter must have the <kbd>guid</kbd> type, and secondly, it is specified as optional using the <kbd>?</kbd> character. ASP.NET Core provides a rich set of built-in <em>routing constraints </em>such as <em>min</em> and <em>max</em> <em>values</em>, <em>regular expressions,</em> and <em>range</em>. It is also possible to combine them using the colon operator (<kbd>:</kbd>), like so:</p>
<pre>app.UseEndpoints(endpoints =&gt;<br/>{<br/>    endpoints.MapControllerRoute("default", "{controller}/{action}/<strong>{id:int:min(1)}</strong>");<br/>});</pre>
<p>In this case, we are combining the <kbd>int</kbd> constraint with the <kbd>min(1)</kbd> constraint. Therefore, we can cover a large number of use cases and business rules. In addition, we can improve our routing matching logic by providing different action methods for the same URI that is receiving a different type of data. It is also important to note that the same <em>routing constraints</em> can also be applied to the attribute routing part:</p>
<pre>    [Route("api/mycontroller")]<br/>    [ApiController]<br/>    public class MyControllerController : ControllerBase<br/>    {<br/>       <strong> [HttpGet({id:int:min(1)})]</strong><br/>        public IActionResult Get() {<br/>            ...<br/>    }</pre>
<p>ASP.NET Core provides a rich set of default routing constraints that can be used out of the box. The following link lists all the additional default routing constraints of ASP.NET Core: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference</a>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom constraints</h1>
                
            
            
                
<p>If default constraints don't cover all the business rules of your application, ASP.NET Core exposes all the necessary components to extend the behavior of route constraints so that you can define your own rules. It is possible to extend routing constraints by implementing the <kbd>IRouteConstraint</kbd> interface provided by <kbd>Microsoft.AspNetCore.Routing</kbd>, like so:</p>
<pre>using System.Collections.Generic;<br/>using Microsoft.AspNetCore.Http;<br/>using Microsoft.AspNetCore.Routing;<br/><br/>namespace SampleAPI.CustomRouting<br/>{<br/>    public class CurrencyConstraint : IRouteConstraint<br/>    {<br/>        private static readonly IList&lt;string&gt; _currencies =  <br/>            new List&lt;string&gt; { "EUR", "USD", "GBP" };<br/>        <br/>        public bool Match(HttpContext httpContext, IRouter route,<br/>            string routeKey, RouteValueDictionary values,<br/>            RouteDirection routeDirection)<br/>        {<br/>            return  _currencies.Contains(values[routeKey]?.ToString().ToLowerInvariant());<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code shows an example of the implementation of <kbd>IRouteConstraint</kbd>. The interface exposes the <kbd>Match</kbd> method, which allows us to match the incoming route values with a custom set of values. In this case, the constraint matches a set of currencies. In order to use <kbd>CurrencyConstraint</kbd>, it is necessary to configure it in the <kbd>ConfigureServices</kbd> method:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>   ...<br/>  <strong>  services.Configure&lt;RouteOptions&gt;(options =&gt; {</strong><br/><strong>        options.ConstraintMap.Add("currency", typeof(CurrencyConstraint));</strong><br/><strong>    });</strong><br/>    ...<br/>}</pre>
<p>It is possible to use the custom <kbd>CurrencyConstraint</kbd> routing constraint using the regular syntax: </p>
<pre>endpoints.MapControllerRoute("default", "{controller}/{action}/{currency}");</pre>
<p>In this case, the <kbd>default</kbd> route will match only the parameter that's using the logic that's implemented in the <kbd>CurrencyConstraint</kbd> class. Therefore, it will match the <kbd>https://localhost/controller/action/eur</kbd>, <kbd>https://localhost/controller/action/usd</kbd>, and <kbd>https://localhost/controller/action/gbp</kbd> URIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The ASP.NET Core routing system can be extended and used to cover a lot of use cases. In general, it provides all the necessary functionalities out of the box. It is essential to understand that <em>conventional routing</em> is generally used by web applications, while web services routing is usually achieved by applying the <em>attribute routing</em>. This chapter described how to deal with these two approaches,  how to use the out-of-box constraints provided by ASP.NET Core and how to implement our custom routing constraints.  In the next chapter, we will look at how to deal with the filter pipeline of ASP.NET Core and in which way they differ from the implementation of the middleware classes.</p>


            

            
        
    </body></html>