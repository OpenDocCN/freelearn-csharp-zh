<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Advanced Topics" id="aid-2C9D01"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Advanced Topics</h1></div></div></div><p>In <a class="link" title="Chapter 12. Performance" href="part0078.xhtml#aid-2ACBS2">Chapter 12</a>, <span class="emphasis"><em>Performance</em></span>, we studied application's performance under several points of view and analyzed some of the most meaningful tools at our disposal in order to improve our software's response time.</p><p>This chapter covers advanced concepts, mainly related to three areas. So, you can consider it a miscellaneous chapter, addressing several topics that either do not fit directly within the context of any of the preceding chapters or are too new, such as what happens with .NET Core.</p><p>Specifically, I will cover how an application can receive system's calls in its own functions and also explain how our code can integrate and communicate with the OS using its APIs. </p><p>Another topic we will cover is <span class="strong"><strong>Windows Management Instrumentation</strong></span> (<span class="strong"><strong>WMI</strong></span>) and how it allows the developer to<a id="id1143" class="indexterm"/> access and modify critical aspects of the system, which are sometimes difficult to reach in other approaches.</p><p>We'll also cover parallelism, analyzing some myths and misunderstandings of these topics and testing these approaches so that we can really evaluate the advantages of this type of programming.</p><p>The chapter ends with an introduction to .NET Core 1.0 and its derivative work, ASP.NET Core 1.0, and its implications and meaning in the open source programming world, along with some examples of how to use it. The availability of this technology was made public by the end of June, 2016, and some minor additions were included in version 1.1, mainly bug fixes and coverage for more operating systems.</p><p>So, we're going to start with the mechanisms that allow communication between the OS and .NET in both directions. But first, it would be interesting to remember the basics of how the operating system works internally and, specifically, how it manages messages between windows if we really want to understand and take advantage of this feature in the .NET code.</p><p>To summarize, we will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Sub-classing and platform/invoke</li><li class="listitem">Windows Management Instrumentation</li><li class="listitem">Extended techniques in parallel programming</li><li class="listitem">An introduction to .NET Core 1.0 and ASP.NET Core 1.0</li></ul></div><div class="section" title="The Windows messaging subsystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec74"/>The Windows messaging subsystem</h1></div></div></div><p>All Windows-based applications are event-driven. This means that they don't make explicit calls to functions in the OS APIs. Instead, they wait for the system to pass any input to them. So it's the <a id="id1144" class="indexterm"/>system that's the one in charge of providing that input.</p><p>The system's kernel is in charge of converting hardware events (users' clicks, keyboard entries, touch screen gestures, the arrival of bytes in a communication's port, and so on) into software events, which take the form of messages addressed to a software target: a button in a window, a textbox in a form, and so on. After all, this is the soul of the Event-driven Programming paradigm.</p><p>I'll start with a section that deals with how .NET can use low-level resources of the operating system, in other words, how our applications can communicate and use the core functionality of our operating system, despite being coded using distinct models, with distinct data types and calling conventions. This technique permits .NET applications to use resources in Windows that are not mapped directly to CLR classes and integrate that functionality into our applications.</p><div class="section" title="The MSG structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec132"/>The MSG structure</h2></div></div></div><p>A message is nothing but<a id="id1145" class="indexterm"/> a numeric code that uniquely identifies a particular event. For example, for the previous case when the user presses the left mouse button, the window receives a message with this message code: <code class="literal">0x0201</code>. This number is previously defined in code in the following way:</p><div class="informalexample"><pre class="programlisting">#define WM_LBUTTONDOWN    0x0201</pre></div><p>Some messages have data associated with them. For example, in this case, the <code class="literal">WM_LBUTTONDOWN</code> message has to indicate the <code class="literal">x</code> coordinate and <code class="literal">y</code> coordinate of the mouse cursor to the programmer.</p><p>Whenever a message is passed to a window, the operating system calls a special function of that window, called the window procedure, which is registered for that window at creation time.</p><p>This is because in Windows, everything is a window (well, almost), and every window procedure (called <code class="literal">WndProc</code>) takes care of the messages it receives as soon as the system sends some input for that window. Actually, the messages are queued, and the system has the ability to promote some messages in the queue thanks to a priority policy.</p><p>All aspects of a window's appearance (and behavior) depend on the window procedure's response to these messages.</p><div class="note" title="Note"><h3 class="title"><a id="tip21"/>Tip</h3><p>Remember, a window is anything that the system distinguishes with a handler: a unique number that makes that component different from the rest. That is, buttons, icons, among others, are just windows embedded in other windows, each one with its own handler.</p><p>So, every time you click on a button, pass the cursor over an icon or use <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> to copy the content, and system sends a message to the target window (the button, the icon, the clipboard, and so on).</p></div><p>A message is received<a id="id1146" class="indexterm"/> by the <code class="literal">wndproc</code> function associated with that target, which processes that message and returns control to the system.</p><p>The following figure shows this structure in more detail:</p><div class="mediaobject"><img src="../Images/image00673.jpeg" alt="The MSG structure"/></div><p style="clear:both; height: 1em;"> </p><p>Note that according to the MSDN:</p><div class="blockquote"><blockquote class="blockquote"><p>"If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding. In this case, the system hides the window and replaces it with a ghost window that has the same Z order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window."</p></blockquote></div><p>As mentioned earlier, either system messages or user messages are queued and the <code class="literal">wndproc</code> function processes them in a first-in-first-out fashion (with some exceptions).</p><p>Actually, you can <a id="id1147" class="indexterm"/>distinguish between two kinds of messages: those sent by user applications, which generally go to the FIFO queue, and others, sent by the OS which can have a distinct priority and, therefore, can be located before the rest in the queue (for example, error messages).</p><p>These messages can be sent via Post Message or Send Message APIs depending on the expected behavior, and although we're not going to cover these aspects in depth (since they go far beyond the scope of this chapter), we'll look at how we can send messages using these APIs and what we can obtain through this technique.</p><p>The next figure shows how all this happens from different threads in the system:</p><div class="mediaobject"><img src="../Images/image00674.jpeg" alt="The MSG structure"/></div><p style="clear:both; height: 1em;"> </p><p>Our applications, though<a id="id1148" class="indexterm"/> managed, behave the same way, and the fact that we can access handles from our code makes it possible to capture events from the system and change behaviors at will.</p><p>Among these techniques, the one that allows us to capture system or application events is called sub-classing. Let's explain how it works and how we can use it.</p></div></div></div>
<div class="section" title="Sub-classing techniques" id="aid-2D7TI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec75"/>Sub-classing techniques</h1></div></div></div><p>Once we understand the previous<a id="id1149" class="indexterm"/> architecture, it makes sense to use it in a variety of ways: avoiding predefined behaviors for controls or windows, adding specific elements to existing windows components, and many others.</p><p>Let's try a basic example. Suppose that we want to change the way a window responds to the left button. Only that. So, we have a simple Windows Forms application, and we need to think of the elements we need in order to code that behavior.</p><p>First, we need to <a id="id1150" class="indexterm"/>capture the specific messages addressed to the left button. Then, we have the override to <code class="literal">WndProc</code> associated with our window, determine what to do if the message is the one required, and finally, <span class="emphasis"><em>always</em></span> return the control to the operating system correctly.</p><p>This figure shows the process:</p><div class="mediaobject"><img src="../Images/image00675.jpeg" alt="Sub-classing techniques"/></div><p style="clear:both; height: 1em;"> </p><p>Fortunately, in C#, that's something pretty simple. Just look at this code, which we add to the <code class="literal">main</code>, default window code created by the IDE:</p><div class="informalexample"><pre class="programlisting">protected override void WndProc(ref Message m)
{
    // Captures messages relative to left mouse button
    if (m.Msg &gt;= 513 &amp;&amp; m.Msg &lt;= 515)
    {
        MessageBox.Show("Processing message: " + m.Msg);
    }
    base.WndProc(ref m);
}</pre></div><p>A few things should be noted in this fragment: first and foremost, we're overriding a method that is not defined in our code. Actually, <code class="literal">WndProc</code> is defined in the <code class="literal">Form</code> class, as you can see by selecting the <span class="strong"><strong>Go to Definition</strong></span> option in the class declaration (over <code class="literal">Form</code>):</p><div class="mediaobject"><img src="../Images/image00676.jpeg" alt="Sub-classing techniques"/></div><p style="clear:both; height: 1em;"> </p><p>If you launch the <a id="id1151" class="indexterm"/>application, it should run just fine, but any left click on it will respond with a message box, indicating the processed message number. There's no way to left-click on it; only right-click will work properly! (You might find difficult to even close the window, although you can always close the application from Visual Studio or right-click on the title's area).</p><p>The output will be something like what is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00677.jpeg" alt="Sub-classing techniques"/></div><p style="clear:both; height: 1em;"> </p><p>However, you might be wondering how in the world is the number 513 defined and where can we find information about it.</p><p>This might be the proper time to talk a bit about some tools (local or online) that you can use to find not only<a id="id1152" class="indexterm"/> that information, but also any other system-related data you can use in these kind of .NET/OS interactions.</p></div>
<div class="section" title="Some useful tools" id="aid-2E6E41"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec76"/>Some useful tools</h1></div></div></div><p>If we deal with definitions and also with the distinct ways in which a system's API should be called from .NET, there's a<a id="id1153" class="indexterm"/> reference website: <a class="ulink" href="http://PInvoke.net">PInvoke.net</a> (available at <a class="ulink" href="http://www.pinvoke.net/">http://www.pinvoke.net/</a>).</p><p>You'll find the vast<a id="id1154" class="indexterm"/> majority of the system's APIs clearly detailed, explaining the way they work, how they should be defined in our code (either from C# or VB.NET), and all other related information.</p><p>For example, knowing that all window messages<a id="id1155" class="indexterm"/> are defined with the <code class="literal">WM_</code> prefix, we can expand it under the <span class="strong"><strong>Constants</strong></span> topic to locate the one I used earlier.</p><p>Furthermore, we are shown a definition of the message and its purpose, along with the hexadecimal number associated with it, and at the end of that list, you'll find the C# definitions, where it's easy to locate those linked to the left button, as shown in the next screenshots:</p><div class="mediaobject"><img src="../Images/image00678.jpeg" alt="Some useful tools"/></div><p style="clear:both; height: 1em;"> </p><p>Following, you can see the definitions in C# code, ready to use in a program:</p><div class="mediaobject"><img src="../Images/image00679.jpeg" alt="Some useful tools"/></div><p style="clear:both; height: 1em;"> </p><p>In the code, as you already know, we can use the decimal equivalent (as I did) or the hexadecimal definition, with the same results. Actually, it's preferable to use these definitions to produce clearer and readable code instead of what I did in the first demo.</p><p>If, instead, you look for a function or scroll over some well-known system DLLs such as <code class="literal">user32.dll</code>, you will see that it contains lots of functions related to Windows, such as <code class="literal">FindWindowEx</code>. If you expand this function, you'll see the definition that we should use in our code in order to call that function, as we will do in the next section, <span class="emphasis"><em>Platform/Invoke</em></span>.</p><p>A bit further down, we can <a id="id1156" class="indexterm"/>even find a sample of how to use the function in practice (in this case, this is done in order to get a reference to the horizontal scroll bar of a window).</p><p>There's also another interesting tool, created<a id="id1157" class="indexterm"/> by Justin Van Patten, at <span class="strong"><strong>Microsoft: P/Invoke Interop Assistant</strong></span>, which we can download and install from Codeplex, at <a class="ulink" href="http://clrinterop.codeplex.com/releases/view/14120">http://clrinterop.codeplex.com/releases/view/14120</a>.</p><p>Once downloaded and installed, you'll find several tools in the <code class="literal">Program Files (X86)/InteropSignatureToolkit</code> directory. Two of them are command-line tools to help you define the function's signatures from other libraries or DLLs (they might be TLBs as well).</p><p>The last one is a Windows app that lets you do the work we previously did in the PInvoke.net site, only from a Windows application. It's called Windows Signature Generator (<code class="literal">winsiggen.exe</code>).</p><p>Within these tools, you can import DLLs from anywhere in the system, or you can even consult the previous definition without requiring any more work: by selecting the <span class="strong"><strong>SigImp Search</strong></span> tag, you filter what you're looking for and see the definitions in a list. Furthermore, by selecting the definitions you want to work with, you'll have the choice to generate the C# or VB.NET code necessary, as the following screenshot shows, in which I searched for the definitions used in the previous demo:</p><div class="mediaobject"><img src="../Images/image00680.jpeg" alt="Some useful tools"/></div><p style="clear:both; height: 1em;"> </p><p>Besides this solution, there is another choice, which is pretty interesting for the developer in Visual Studio: under the <span class="strong"><strong>Extensions and Updates</strong></span> menu; if you select <span class="strong"><strong>on-line</strong></span> and filter <span class="strong"><strong>pinvoke</strong></span> or similar, there's a version of this tool called <span class="strong"><strong>PInvoke.net for Visual Studio Extension</strong></span>, lately<a id="id1158" class="indexterm"/> managed by Red Gate. You should find an entry like the one shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00681.jpeg" alt="Some useful tools"/></div><p style="clear:both; height: 1em;"> </p><p>Once installed (it takes a moment), it will create a new menu in the IDE after a restart of Visual Studio.</p><p>What you will see is a window similar to the one in the previous tool, but highly simplified and with the option to search for any function or module or visit the <a class="ulink" href="http://PInvoke.net">PInvoke.net</a> site if you need to look for a definition.</p></div>
<div class="section" title="Platform/Invoke: calling the OS from .NET"><div class="titlepage" id="aid-2F4UM2"><div><div><h1 class="title"><a id="ch13lvl1sec77"/>Platform/Invoke: calling the OS from .NET</h1></div></div></div><p>Platform/Invoke allows the coder to use standard (unmanaged) C/C++ DLLs. If you need to have access to any <a id="id1159" class="indexterm"/>function inside the extensive Windows APIs (which hold basically everything the operating system can perform) and there's no available wrapper to call the same functionality from the CLR, then this is the choice.</p><p>From the developer's perspective, by Platform/Invoke, we understand a feature of the CLR that allows a program to interact with the functionality that is unique to the system in which the application runs, thus allowing managed code to call native code and vice versa.</p><p>The assembly responsible for calling the APIs will define how the native code is called and accessed, via metadata embedded inside, which usually requires attribute decorations. These attributes are defined inside the class containing the caller methods in order to indicate the compiler the correct way to do the marshaling between the two worlds (managed and unmanaged).</p><p>The idea is that if I need to call an unmanaged function from the managed code, I should indicate the destination context how big the things that I'm passing are and what direction they are going. That is if I'm asking for data or if I'm passing data (or both).</p><p>The caveat is that there are many exceptions, and often, there's always a better way to do it, even if coded correctly. This is where the tools we just reviewed help the programmer to deal with these situations.</p><p>But let's first review the foundations of the platform invocation and how to use it from C# with a simple example.</p><div class="section" title="The process of platform invocation"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec133"/>The process of platform invocation</h2></div></div></div><p>To achieve <a id="id1160" class="indexterm"/>platform invocation, the CLR has to do several things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Locate the DLL containing the function and load it in memory</li><li class="listitem">Locate the function's memory address and push its arguments onto the stack, marshaling data as required</li></ul></div><p>Note, however, that <a id="id1161" class="indexterm"/>operating in this way also has some pitfalls. For example, you no longer have the benefits of type safety or garbage collection, and you have to be careful when using them. The great advantage, on the other hand, is that the enormous amount of functionality provided by the system is available for us, and we're talking about functionality that has been fully tested and optimized.</p><p>It's easy to insert external APIs' definitions into our code. Let's look at this in an example. Imagine that our application uses the system's calculator (or any other system's tool) and we want to make sure that in certain circumstances, the calculator is located in a given position (such as the screen's origin) and also that we want to have the ability to close the calculator from our program.</p><p>We need three APIs here—<code class="literal">SetWindowPos</code> (to change the calculator's position), <code class="literal">SendMessage</code> (to close the calculator), and <code class="literal">FindWindow</code>—in order to get the calculator's handle that we need to use with other two.</p><p>So, we search for these<a id="id1162" class="indexterm"/> functions in the Platform/Invoke Assistant to find their definitions, and we use the Insert button to have the translated definition inserted in our code. For every function search, we should see a window like this:</p><div class="mediaobject"><img src="../Images/image00682.jpeg" alt="The process of platform invocation"/></div><p style="clear:both; height: 1em;"> </p><p>After finding the three functions, we should have the following code available:</p><div class="informalexample"><pre class="programlisting">[DllImport("user32.dll", EntryPoint = "FindWindow", SetLastError = true)]
static extern IntPtr FindWindowByCaption(IntPtr ZeroOnly, string lpWindowName);
[DllImport("user32.dll", EntryPoint = "SetWindowPos")]
public static extern IntPtr SetWindowPos(IntPtr hWnd, int hWndInsertAfter, 
    int x, int Y, int cx, int cy, int wFlags);
[DllImport("user32.dll", CharSet = CharSet.Auto)]
static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, 
    IntPtr wParam, IntPtr lParam);
IntPtr calcHandler;
private const UInt32 WM_CLOSE = 0x0010;</pre></div><p>This is our bridge to the operating system's functionality, and we can call these functions from any accessible place just like if they were .NET functions.</p><p>For this demo, I'll create a<a id="id1163" class="indexterm"/> basic Windows Forms app with a couple of buttons in order to implement the required functionality. The first button finds the calculator's handler and locates the <code class="literal">Calculator</code> in the top-left position:</p><div class="informalexample"><pre class="programlisting">private void btnPosition_Click(object sender, EventArgs e)
{
  calcHandler =  FindWindowByCaption(IntPtr.Zero, "Calculator");
  SetWindowPos(calcHandler, 0, 0, 0, 0, 0, 0x0001 | 0x0040);
}</pre></div><p>Now, in another button, we have to send a message to the <code class="literal">Calculator</code> to close it. Again, we can check with the assistant, knowing that the message identifier is called <code class="literal">WM_CLOSE</code> and that we will find it searching for constants and going down to those starting with <code class="literal">WM_</code>. So we insert this definition and are ready to call the second button, which closes the calculator:</p><div class="informalexample"><pre class="programlisting">private const UInt32 WM_CLOSE = 0x0010;
private void btnClose_Click(object sender, EventArgs e)
{
  SendMessage(calcHandler, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
}</pre></div><p>Remember that when <a id="id1164" class="indexterm"/>we are using the system APIs, some parameters have to be specifically <span class="strong"><strong>marshaled</strong></span> (converted) into the destination types. This is why the last two parameters are expressed as <code class="literal">IntPrt.Zero</code>, which is the correct definition for this type in .NET.</p><p>Naturally, we can use this technique to close any window, including managed ones, although in this case, we have other (simpler) options, including the possibilities that we saw in relation to Reflection, if the holding assembly is external.</p><p>Also, note that some solutions called <span class="emphasis"><em>multiplatform</em></span> are based on calls to native code from managed code: in Silverlight; the runtime is based on <span class="strong"><strong>Platform Adaptation Layer</strong></span> (<span class="strong"><strong>PAL</strong></span>) based on these <a id="id1165" class="indexterm"/>principles. This allows you to call native<a id="id1166" class="indexterm"/> functions in different OSes.</p><p>This can also be said for<a id="id1167" class="indexterm"/> Platform/Invoke in Linux and MacOS, the most successful manifestation of this being the Xamarin initiative (more information about Platform/Invoke on these platforms is available at <a class="ulink" href="http://www.mono-project.com/docs/advanced/pinvoke/">http://www.mono-project.com/docs/advanced/pinvoke/</a>).</p><p>However, as we'll see at the end, the new .NET Core is a great promise in this respect since it is thought of to work on any platform and any operating system.</p><p>Nevertheless, if we're <a id="id1168" class="indexterm"/>programming for Windows, there are situations where we need to know specific data about the configuration of our platform. That's where <span class="strong"><strong>Windows Management Instrumentation</strong></span> (<span class="strong"><strong>WMI</strong></span>), or its recent alternative Windows Management Infrastructure, can be very useful, not just for programmers, but for IT people as well.</p><div class="section" title="Windows Management Instrumentation"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec81"/>Windows Management Instrumentation</h3></div></div></div><p>The official <a id="id1169" class="indexterm"/>documentation defines <a id="id1170" class="indexterm"/>WMI technology in this manner:</p><div class="blockquote"><blockquote class="blockquote"><p>"Windows Management Instrumentation (WMI) is the infrastructure for management data and operations on Windows-based operating systems. You can write WMI scripts or <a id="id1171" class="indexterm"/>applications to automate administrative tasks on remote computers but WMI also supplies management data to other parts of the operating system and products, for example, System Center Operations Manager, formerly Microsoft Operations Manager (<span class="strong"><strong>MOM</strong></span>), or <span class="strong"><strong>Windows Remote Management</strong></span> (<span class="strong"><strong>WinRM</strong></span>)."</p></blockquote></div><p>However, the same documentation adds:</p><div class="blockquote"><blockquote class="blockquote"><p>"WMI is fully supported by Microsoft; however, the latest version of administrative scripting and control is<a id="id1172" class="indexterm"/> available through the Windows <span class="strong"><strong>Management Infrastructure</strong></span> (<span class="strong"><strong>MI</strong></span>). MI is fully compatible with previous versions of WMI and provides a host of features and benefits that make designing and developing providers and clients easier than ever. For more information, see Windows Management Infrastructure (MI)."</p></blockquote></div><p>You can find more information<a id="id1173" class="indexterm"/> on configuring MI at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn313131(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/dn313131(v=vs.85).aspx</a> if you want to dig into these features in depth.</p><p>So, with WMI, we query the system to get details on its implementation and the software and hardware installed. The<a id="id1174" class="indexterm"/> reason for the query is that WMI stores the system's information in <span class="strong"><strong>Common Information Model</strong></span> (<span class="strong"><strong>CIM</strong></span>) databases, stored and updated by the system continuously.</p><p>And by the way, the CIM is <a id="id1175" class="indexterm"/>not something exclusive to Windows operating systems. As Wikipedia states:</p><div class="blockquote"><blockquote class="blockquote"><p>"The <span class="strong"><strong>Common Information Model</strong></span> (<span class="strong"><strong>CIM</strong></span>) is an open standard that defines how managed elements in an IT environment are represented as a common set of objects and relationships between them.</p><p>The Distributed Management Task Force maintains the CIM to allow consistent management of these managed elements, independent of their manufacturer or provider."</p></blockquote></div><p>The DMTF updates these documents frequently (sometimes, twice a year).</p><div class="section" title="CIM searchable tables"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec19"/>CIM searchable tables</h4></div></div></div><p>There are many tables <a id="id1176" class="indexterm"/>permanently<a id="id1177" class="indexterm"/> updated by the system, which we can search. The complete list is published on MSDN, and you can<a id="id1178" class="indexterm"/> find this information in the <span class="emphasis"><em>Computer System Hardware Classes</em></span> section, available at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/aa389273(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/aa389273(v=vs.85).aspx</a>.</p><p>I'll resume some of the most useful terms to search for programmers here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Input device classes</li><li class="listitem">Mass storage classes</li><li class="listitem">Motherboard, controller, and port classes</li><li class="listitem">Networking device classes</li><li class="listitem">Power classes</li><li class="listitem">Printing classes</li><li class="listitem">Telephony classes</li><li class="listitem">Video and monitor classes</li></ul></div><p>Each one contains a set of distinct classes, holding a variety of information about the hardware and the software.</p><p>For this brief review, we're just going to use the classical WMI and look at the type of data that can be revealed to us in a demo and how to query for it.</p><p>Although there are several ways to access this information for the .NET programmer, .NET provides part of the WMI functionality through the <code class="literal">System.Management</code> namespace, which is filled with classes to search for system-related information, such as <code class="literal">ManagementObjectSearcher</code>, <code class="literal">SelectQuery</code>, <code class="literal">ManagementObject</code>, and so on.</p><p>For a simple query about the system information, we first create a <code class="literal">ManagementObjectSearcher</code> object that defines the focus of our search (an information provider). This object should receive a SQL string, indicating the table we want to search for.</p><p>So, in our demo, we're <a id="id1179" class="indexterm"/>going to start by creating a Windows Forms app, including a few buttons and a couple of Listbox controls to present the results.</p><p>We'll start by coding a general query to obtain the list of tables available. The code for the button in charge of that is as follows:</p><div class="informalexample"><pre class="programlisting">ManagementObjectSearchermos = newManagementObjectSearcher
("SELECT * FROM meta_class WHERE __CLASS LIKE 'Win32_%'");
foreach (ManagementObject obj in mos.Get())
listBox1.Items.Add(obj["__CLASS"]);</pre></div><p>As you can see, <code class="literal">meta_class</code> is a CIM object containing the complete list of classes available for searching. Note that the query might take a while since <code class="literal">ManagementObjectSearcher</code> has to go through all the information available in the system and registered in the CIM tables.</p><p>You should see output similar to the what is shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00683.jpeg" alt="CIM searchable tables"/></div><p style="clear:both; height: 1em;"> </p><p>Later on, we can query these tables to retrieve the required data. In this demo, we'll use several tables—<span class="strong"><strong>Win32_OperatingSystem</strong></span>, <span class="strong"><strong>Win32_processor</strong></span>, <span class="strong"><strong>Win32_bios</strong></span>, <span class="strong"><strong>Win32_Environment</strong></span>, and <span class="strong"><strong>Win32_Share</strong></span>—to find some information about the running machine and related <a id="id1180" class="indexterm"/>characteristics.</p><p>The way it works is always the same: you create <code class="literal">ManagementObjectSearcher</code> and iterate over it, invoking the <code class="literal">Get()</code>method on every instance of the collection returned by the searcher. So, we have the following code:</p><div class="informalexample"><pre class="programlisting">private void btnQueryOS_Click(object sender, EventArgs e)
{
    listBox1.Items.Clear();
    listBox2.Items.Clear();

    // First, we get some information about the Operating System:
    // Name, Version, Manufacturer, Computer Name, and Windows Directory
    // We call Get() to retrieve the collection of objects and loop through it
    var osSearch = new ManagementObjectSearcher("SELECT * FROM Win32_OperatingSystem");
    listBox1.Items.Add("Operating System Info");
    listBox1.Items.Add("-----------------------------");
    foreach (ManagementObject osInfo in osSearch.Get())
    {
        listBox1.Items.Add("Name: " + osInfo["name"].ToString());
        listBox1.Items.Add("Version: " + osInfo["version"].ToString());
        listBox1.Items.Add("Manufacturer: " + osInfo["manufacturer"].ToString());
        listBox1.Items.Add("Computer name: " + osInfo["csname"].ToString());
        listBox1.Items.Add("Windows Directory: " + osInfo["windowsdirectory"].ToString());
    }

    // Now, some data about the processor and BIOS
    listBox2.Items.Add("Processor Info");
    listBox2.Items.Add("------------------");
    var ProcQuery = new SelectQuery("Win32_processor");
    ManagementObjectSearcher ProcSearch = new ManagementObjectSearcher(ProcQuery);
    foreach (ManagementObject ProcInfo in ProcSearch.Get())
    {
        listBox2.Items.Add("Processor: " + ProcInfo["caption"].ToString());
    }

    listBox2.Items.Add("BIOS Info");
    listBox2.Items.Add("-------------");
    var BiosQuery = new SelectQuery("Win32_bios");
    ManagementObjectSearcher BiosSearch = new ManagementObjectSearcher(BiosQuery);
    foreach (ManagementObject BiosInfo in BiosSearch.Get())
    {
        listBox2.Items.Add("Bios: " + BiosInfo["version"].ToString());
    }

    // An enumeration of Win32_Environment instances
    listBox2.Items.Add("Environment Instances");
    listBox2.Items.Add("-----------------------------");
    var envQuery = new SelectQuery("Win32_Environment");
    ManagementObjectSearcher envInstances = new ManagementObjectSearcher(envQuery);
    foreach (ManagementBaseObject envVar in envInstances.Get())
        listBox2.Items.Add(envVar["Name"] + " -- " + envVar["VariableValue"]);

    // Finally, a list of shared units
    listBox2.Items.Add("Shared Units");
    listBox2.Items.Add("------------------");
    var sharedQuery = new ManagementObjectSearcher("select * from win32_share");
    foreach (ManagementObject share in sharedQuery.Get())
    {
        listBox2.Items.Add("Share = " + share["Name"]);
    }
}</pre></div><p>If you run the demo, depending<a id="id1181" class="indexterm"/> on your machine, you'll get some distinct values, but the structure of the information should be similar to what is shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00684.jpeg" alt="CIM searchable tables"/></div><p style="clear:both; height: 1em;"> </p><p>To summarize, WMI offers a simple, managed way to access practically any relevant data related to the hardware and software on our machine and also in the network to which we are connected (as far as the query has the required permissions).</p><p>As for the security concerns, Microsoft has published an exhaustive article on the subject on MSDN: <span class="emphasis"><em>Maintaining WMI Security</em></span> (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/aa392291(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/aa392291(v=vs.85).aspx</a>), with all the critical information and guidelines about maintaining security while allowing access to these resources.</p><p>There is much more functionality related to the <code class="literal">ManagementObject</code> class. For instance, you can get information<a id="id1182" class="indexterm"/> related to processes or services by creating a new instance of the desired element and use the methods the object inherits.</p><p>For example, if you want to know which services are dependent on other services programmatically, you can use the <code class="literal">GetRelated </code>method of the object's instance. Let's imagine we want to know <a id="id1183" class="indexterm"/>which services are related to the <span class="strong"><strong>LSM</strong></span> (<span class="strong"><strong>Local Session Manager</strong></span>) service. We could code the following:</p><div class="informalexample"><pre class="programlisting">var mo = newManagementObject(@"Win32_service='LSM'");
foreach (var o in mo.GetRelated("Win32_Service", "Win32_DependentService",
null,null,"Antecedent","Dependent", false, null))
{
  listBox1.Items.Add(o["__PATH"]);
}</pre></div><p>In this way, we can get this (hard-to-find) information in a totally programmatic manner. This will help us configure some scenarios in which one of our application's procedures require the active presence of a certain service (remember that we can launch a service from code as well).</p><p>Besides this, other actions are available, such as stopping, pausing, or resuming a given service. In the case of the LSM service, we should see information similar to what is shown in this screenshot:</p><div class="mediaobject"><img src="../Images/image00685.jpeg" alt="CIM searchable tables"/></div><p style="clear:both; height: 1em;"> </p><p>And there is much more information that you will discover going through the class hierarchy related to <code class="literal">System.Management</code>. Practically every byte of system-related data that we should<a id="id1184" class="indexterm"/> otherwise read via Registry or Windows APIs is available here in a totally programmatic fashion with no need for complex approaches.</p><p>The only caveat is that the documentation is very long. Consequently, Microsoft created a tool called WMI Code Creator, which analyzes the information available and generates code for all possible scenarios (often, this code is expressed in Windows Scripting Host), but a big part is perfectly translatable to C#.</p><p>Besides, we have the advantage of a tool that joins much of the functionality available in a single user interface.</p><p>You can download it from <a class="ulink" href="https://www.microsoft.com/en-gb/download/details.aspx%3Fid%3D8572">https://www.microsoft.com/en-gb/download/details.aspx%3Fid%3D8572</a>, getting a ZIP file that contains the executable and the<a id="id1185" class="indexterm"/> source code, which is a valuable tip for coding in WMI.</p><p>The tool includes several options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Query data from a WMI class</li><li class="listitem">Executing a method</li><li class="listitem">Receiving an event</li><li class="listitem">Browsing the namespaces on this computer</li></ul></div><p>As you can see in the next screenshot, this tool is quite complete in possibilities and in the information it provides:</p><div class="mediaobject"><img src="../Images/image00686.jpeg" alt="CIM searchable tables"/></div><p style="clear:both; height: 1em;"> </p><p>Another typical usage of WMI is to check the state of a piece of hardware before performing an action that could provoke a system's failure, such as testing a hard drive before copying big<a id="id1186" class="indexterm"/> chunks of data that could exceed the disk quota.</p><p>The code, in this case, is simple, and it gives us an idea about how to code other system-related queries. All we need is something like this:</p><div class="informalexample"><pre class="programlisting">ManagementObject disk = new
ManagementObject("win32_logicaldisk.deviceid='c:'");
disk.Get();
var totalMb = long.Parse(disk["Size"].ToString()) / (1024 * 1024);
var freeMb = long.Parse(disk["FreeSpace"].ToString()) / (1024 * 1024);
listBox1.Items.Add("Logical Disk Size = " + totalMb + " Mb.");
listBox1.Items.Add("Logical Disk FreeSpace = " + freeMb + " Mb.");</pre></div><p>Thus, after adding a new button and including the previous code to check the state of the <code class="literal">C:</code> drive, we should see output similar to this:</p><div class="mediaobject"><img src="../Images/image00687.jpeg" alt="CIM searchable tables"/></div><p style="clear:both; height: 1em;"> </p><p>To summarize, we've seen several ways of interacting with the operating system. We can analyze which messages are linked to a certain functionality and capture the related events to either <a id="id1187" class="indexterm"/>change, cancel, or modify the default behaviors. In this case, the communication is in both directions.</p><p>This also happens (bi-directional communications) when we use the system APIs to call functionalities through Platform/Invoke, which offers unlimited possibilities.</p><div class="note" title="Note"><h3 class="title"><a id="note31"/>Note</h3><p>However, the official Microsoft recommendation is that if they're available for the .NET programmer, it's always preferable to use the resources linked to .NET classes.</p></div><p>Finally, Windows Management Instrumentation and its variant MI provide access to otherwise difficult-to-reach information, allowing our applications to configure and behave more suitably depending on the operating system's state.</p></div></div></div></div>
<div class="section" title="Parallel programming" id="aid-2G3F81"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec78"/>Parallel programming</h1></div></div></div><p>As you may<a id="id1188" class="indexterm"/> remember, we've already talked about asynchronous programming, when we were dealing with the <code class="literal">async/await</code> keywords that appeared in .NET Framework 4.5 as a solution to avoid performance bottlenecks and improve the overall responsiveness of our applications.</p><p>Parallelism was present earlier, in version 4.0 of the framework, and it was programmatically related to<a id="id1189" class="indexterm"/> the <span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>). But first, let's define the concept of parallelism (at least according to Wikipedia):</p><div class="blockquote"><blockquote class="blockquote"><p>"Parallelism is a form of computation in which several operations can execute simultaneously. It's based on the 'Divide and Conquer' principle, fragmenting a task in smaller tasks, which are later solved in parallel."</p></blockquote></div><p>This is, obviously related to hardware, and we should be aware of the difference between multiple processors and <a id="id1190" class="indexterm"/>multiple cores. As Rodney Ringler says in his excellent book <span class="emphasis"><em>C# Multithreading and Parallel Programming</em></span> by <span class="emphasis"><em>Packt Publishing</em></span>:</p><div class="blockquote"><blockquote class="blockquote"><p>"A multiple core CPU has more than one physical processing unit. In essence, it acts like more than one CPU. The only difference is that all cores of a single CPU share the same memory cache instead of having their own memory cache. From the multithreaded parallel developer standpoint, there is very little difference between multiple CPUs and multiple cores in a CPU. The total number of cores across all of the CPUs of a system is the number of physical processing units that can be scheduled and run in parallel, that is, the number of different software threads that can truly execute in parallel."</p></blockquote></div><p>Several types of parallelism can be distinguished: at bit level, at instruction level, data parallelism, and task parallelism. And this is at the software level.</p><p>There's another type of parallelism, at the hardware level, in which distinct architectures can be implied, offering distinct solutions depending on the problem to be solved (there's a particularly exhaustive<a id="id1191" class="indexterm"/> explanation published by Lawrence Livermore National Laboratory if you're interested in this topic, <span class="emphasis"><em>Introduction to Parallel Computing</em></span> at <a class="ulink" href="https://computing.llnl.gov/tutorials/parallel_comp/">https://computing.llnl.gov/tutorials/parallel_comp/</a>. We'll stick to the software level, of course.</p><p>Parallelism can be applied in many different areas of computing, such as the Monte-Carlo Algorithm, Combinational Logic, Graph Traversal and Modeling, Dynamic Programming, Branch and Bound methods, Finite-state Machines, and so on.</p><p>From a more practical perspective, this translates into solving problems related to a wide variety of areas in science and engineering: astronomy, weather, rush hour traffic, plate tectonics, civil engineering, finance, geophysics, information services, electronics, biology, consulting, and, in a more everyday approach, any process that takes certain time and that can be improved thanks to these techniques (downloading data, I/O operations, expensive queries, and so on).</p><p>The process followed in computing in parallel is explained in the previously mentioned source in four steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A problem is broken into discrete parts that can be solved concurrently.</li><li class="listitem">Each part is further broken down into a series of instructions.</li><li class="listitem">Instructions from each part execute on different processors simultaneously.</li><li class="listitem">An overall control/coordination mechanism is employed.</li></ol><div style="height:10px; width: 1px"/></div><p>Note that the<a id="id1192" class="indexterm"/> computational problem has to be of a nature such that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It can be broken into discrete fragments of work that can later be solved simultaneously</li><li class="listitem">It has to be possible to execute several instructions at any moment in time</li><li class="listitem">It should be solved in less time using multiple resources or the computer than would be with a single resource</li></ul></div><p>The resulting architecture can be explained in a graphic schema, as follows:</p><div class="mediaobject"><img src="../Images/image00688.jpeg" alt="Parallel programming"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Difference between multithreading and parallel programming"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec134"/>Difference between multithreading and parallel programming</h2></div></div></div><p>It's also important to<a id="id1193" class="indexterm"/> remember the difference between multithreading and parallel programming. When we create a new thread in a given process (review the discussion about this in the first chapter if you need more references), that thread is scheduled by the operating system, which associates it with some CPU time. The thread executes the code in an asynchronous manner: that is, it goes its way until it finishes, a moment in which it should be synchronized with the main thread in order to obtain the results (we've also talked about updating main threads earlier).</p><p>However, at the same time, there are other applications in execution in our computer (think of services, among other things). And these applications are also given their corresponding CPU time; so, if our application uses more than one thread, it's also given more CPU time, and the results are obtained more rapidly without blocking the UI thread.</p><p>Moreover, if all this is executed in one core, we're not talking about parallel programming. We can't talk about parallel programming if we don't have more than one core.</p><div class="note" title="Note"><h3 class="title"><a id="tip22"/>Tip</h3><p>A typical mistake that we see is when a program executes in a virtual machine, and the code uses parallel approaches because in a virtual machine we only use one core by default. You have to configure the VM to work with more than one core in order to take advantage of parallelism.</p></div><p>Also, from the everyday programmer point of view, you can mainly divide the types of tasks subject to parallel programming into two principal areas: those that are CPU-bound and those that are I/O bound (we can also add another two, Memory Bound, the amount of memory available is limited with respect to a process, and Cache Bound, which happens when the process is limited by the amount and the speed of the available cache. Think of a task that processes more data than the cache space it has available).</p><p>In the first case, we're dealing with code that would run faster if the CPU were faster, which is the case where the CPU spends the majority of time using the CPU cores (complex calculations being a typical example).</p><p>The second scenario, (I/O-bound) happens when something would run faster if the I/O subsystem could also run faster. This case might happen in different scenarios: downloading something, accessing disk drives or network resources, and so on.</p><p>The first two cases are the most common, and this is where TPL comes into play. Task Parallel Library appeared as a solution to implement parallel coding in our applications linked to the first two scenarios: CPU-bound and I/O-bound.</p><p>Programmatically, we can find it in three flavors: Parallel LINQ, the Parallel class, and the Task class. The first two are mainly used for CPU-bound processes, while the Task class is more suitable (always generally speaking) for I/O-bound scenarios.</p><p>We already saw the basics of working with the Task class, which also allows you to execute code <a id="id1194" class="indexterm"/>asynchronously, and here, we'll see how it can also perform cancelations (with tokens), continuations, synchronization of contexts, and so on.</p><p>So, let's review these three flavors to look at some typical solutions to coding problems in which these libraries have noticeable improvements.</p></div></div>
<div class="section" title="Parallel LINQ"><div class="titlepage" id="aid-2H1VQ2"><div><div><h1 class="title"><a id="ch13lvl1sec79"/>Parallel LINQ</h1></div></div></div><p>As the name suggests, parallel<a id="id1195" class="indexterm"/> LINQ is an extension of the previous LINQ <a id="id1196" class="indexterm"/>capabilities provided in previous versions of .NET.</p><p>In the first solution (Parallel LINQ), Microsoft expert Stephen Toub explains the reasons for this approach in <span class="emphasis"><em>Patterns Of Parallel Programming</em></span> (available at <a class="ulink" href="https://www.microsoft.com/en-us/download/details.aspx?id=19222">https://www.microsoft.com/en-us/download/details.aspx?id=19222</a>):</p><div class="blockquote"><blockquote class="blockquote"><p>"A significant majority of the work in many applications and algorithms is done through loop control constructs. Loops, after all, often enable the application to execute a set of instructions over and over, applying logic to discrete entities, whether those entities are integral values, such as in the case of a for loop, or sets of data, such as in the case of a for each loop.</p><p>Many languages have built-in control constructs for these kinds of loops, Microsoft Visual C#® and Microsoft Visual Basic® being among them, the former with for and foreach keywords, and the latter with For and For Each keywords. For problems that may be considered delightfully parallel, the entities to be processed by individual iterations of the loops may execute concurrently: thus, we need a mechanism to enable such parallel processing."</p></blockquote></div><p>One of these mechanisms is the <code class="literal">AsParallel()</code> method, applicable to expressions that imply the resources we've seen in relation to LINQ and Generic collections. Let's explore this in detail in an example (in this case, the sample will be linked to CPU-bound code).</p><p>Our demo will have a simple UI, and we're going to calculate prime numbers between 1 and 3,000,000.</p><p>I'll start by creating the prime calculation algorithm as an extension method of the <code class="literal">int</code> type, with the following code:</p><div class="informalexample"><pre class="programlisting">public static class BaseTypeExtensions
{
  public static bool IsPrime(this int n)
  {
    if (n &lt;= 1) return false;
    if ((n &amp; 1) == 0)
    {
      if (n == 2) return true;
      else return false;
    }
    for (int i = 3; (i * i) &lt;= n; i += 2)
    {
      if ((n % i) == 0) return false;
    }
    return n != 1;
  }
}</pre></div><p>Now, we'll use three buttons to compare different behaviors: without parallelism, with parallelism, and with parallelism using ordered results.</p><p>Previously, we defined some basic values:</p><div class="informalexample"><pre class="programlisting">Stopwatch watch = new Stopwatch();
IEnumerable &lt;int&gt; numbers = Enumerable.Range(1, 3000000);
string strLabel = "Time Elapsed: ";</pre></div><p>The two important <a id="id1197" class="indexterm"/>elements here are <code class="literal">Stopwatch</code>, to measure the time elapsed, and the initial collection of numbers, which we are going to generate using the static <code class="literal">Range</code> method of the <code class="literal">Enumerable</code> class, from 1 to 3,000,000.</p><p>The code in the first button is pretty straightforward:</p><div class="informalexample"><pre class="programlisting">private void btnGeneratePrimes_Click(object sender, EventArgs e)
{
  watch.Restart();
  var query = numbers.Where(n =&gt; n.IsPrime());
  var primes = query.ToList();
  watch.Stop();
  label1.Text = strLabel + watch.ElapsedMilliseconds.ToString("0,000")+ " ms.";
  listBox1.DataSource = primes.ToList();
}</pre></div><p>But, in the second button, we're including the <code class="literal">AsParallel</code> construct we mentioned earlier. It's quite similar to the previous one, but we indicate that before getting any results, we want the <code class="literal">numbers</code> collection to be treated in parallel.</p><p>When you execute the sample (the elapsed time values will vary slightly depending on the machine you're using), this second method is considerably faster than the previous one.</p><p>This means that the code has used all cores available in the machine to perform the task (the <code class="literal">where</code> method next to <code class="literal">AsParallel</code>).</p><p>You have a way to prove this immediately: just open the Task Manager and select the <span class="strong"><strong>Performance</strong></span> tab. In there (if you're using Windows 10 like me), you have to open <span class="strong"><strong>Resource Monitor</strong></span> to view the activities of all the CPUs present in your machine.</p><div class="note" title="Note"><h3 class="title"><a id="tip23"/>Tip</h3><p>Just to make sure you only watch the activity related to this demo, observe that you can select the output process to view the list of processes (in this case, it will be <span class="strong"><strong>DEMOLINQ1.vshost.exe</strong></span>).</p></div><p>At runtime, the<a id="id1198" class="indexterm"/> difference becomes evident: in the first event handler, only one CPU appears to be working. If you do this with the parallel method, you'll see that there is an activity (probably in all CPUs if it's not configured in some other way).</p><p>This happens with the third option as well, (more about it soon), which uses the <code class="literal">AsOrdered()</code> clause. In my box (with eight cores), the resulting window shows the following output:</p><div class="mediaobject"><img src="../Images/image00689.jpeg" alt="Parallel LINQ"/></div><p style="clear:both; height: 1em;"> </p><p>So, we're really using parallelism, with a very simple addition to our code! The difference in the results becomes evident (as an average, it's about one-third of the time with respect to the synchronous option).</p><p>But we still have a <a id="id1199" class="indexterm"/>problem. If you take a look at the output of the second Listbox control, at some point, you'll see that the list is not ordered, as it happened in the first case. This is normal, since we're using several cores to run the results and the code adds these results in the order in which they are received from the eight cores (in my case).</p><p>This order will vary depending on the number of cores, the speed, and other factors difficult to foresee. So, if we really need the results ordered, just as in the first case, we can use the <code class="literal">AsOrdered()</code> method, applied right next to the <code class="literal">AsParallel()</code> indication.</p><p>In this way, the resulting code is fairly the same as in the second method, but the results are ordered now, just with a (usually negligible) delay.</p><p>In the next screenshot, I'm moving to prime number <span class="strong"><strong>18973</strong></span> just to show the different way in which Listboxes were filled:</p><div class="mediaobject"><img src="../Images/image00690.jpeg" alt="Parallel LINQ"/></div><p style="clear:both; height: 1em;"> </p><p>If there are no other processes consuming CPU, successive executions of these methods will offer slightly different results, but the variations will be minimal (actually, sometimes, you'll see <a id="id1200" class="indexterm"/>that the <code class="literal">AsOrdered()</code> method appears to run faster than the non ordered one, but that's only because of the CPU activity).</p><p>In general, if you need to really evaluate the execution time, you should perform the benchmarks several times and vary some of the initial conditions.</p><div class="section" title="Dealing with other issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec135"/>Dealing with other issues</h2></div></div></div><p>Dealing with other<a id="id1201" class="indexterm"/> issues appears to be an excellent way to use all the resources available in our machine, but other considerations may lead us to modify this code. For example, if our application should behave correctly under stress conditions, or we should respect the possible execution of other applications and the process to parallelize is much heavier than this one, it could be wise to use a feature called Parallelization Degree.</p><p>With this feature, we can establish the number of cores to use in our application by code, leaving the rest for other machines' applications and services.</p><p>We can use this code to include this feature in another button, which will use only a limited number of cores this time. But how do we determine the number of cores? A reasonable solution would be to use only half of the cores available in the system, leaving the other half free.</p><p>Fortunately, there's an easy way to find out this number (no need to use Platform/Invoke, Registry values, or WMI): the <code class="literal">Environment</code> class has static properties that allow simple access to certain useful values directly: in this case, the <code class="literal">ProcessorCount</code> property returns the number of cores. So we can write the following (I'm showing only the modified line):</p><div class="informalexample"><pre class="programlisting">var query = numbers.AsParallel().AsOrdered()
.WithDegreeOfParallelism(Environment.ProcessorCount/2)
.Where(n =&gt; n.IsPrime());</pre></div><p>In this case, in my <a id="id1202" class="indexterm"/> machine, I'll be using only four cores, which should show a gain in the performance although not as much as when using all cores (I've changed the numbers collection to 5,000.000 in order to better appreciate these values. Refer to the screenshot):</p><div class="mediaobject"><img src="../Images/image00691.jpeg" alt="Dealing with other issues"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Canceling execution"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec136"/>Canceling execution</h2></div></div></div><p>Another case that we should consider in our code in when the user, for whatever reason, wants to have the ability to cancel the process at a given moment.</p><p>The solution for this, as<a id="id1203" class="indexterm"/> mentioned earlier in this section, is the cancellation feature. It is performed using <code class="literal">token</code>, which you pass to the process in its definition, and can be later used to force the cancelation (and the subsequent detention of the process).</p><p>For code brevity, we'll use a trick: extend again the <code class="literal">int</code> type so that it admits this token feature. We can write simple extension code, as follows:</p><div class="informalexample"><pre class="programlisting">public static bool IsPrime(this int n, Cancellation TokenSource cs)
{
  if (n == 1000) cs.Cancel();
  return IsPrime(n);
}</pre></div><p>As you can see, we now have an overload of <code class="literal">IsPrime</code>, which calls the basic implementation only while <code class="literal">n</code> is distinct to <code class="literal">1000</code>. As we reach the thousandth integer, the Cancel method of the <code class="literal">CancellationTokenSource</code> instance is called.</p><p>The behavior of this depends on the possible previous configuration values of this class. As shown in the next screenshot, several values allow us to manipulate and find out related information, such as whether it can be really canceled, whether the cancelation has been requested, and<a id="id1204" class="indexterm"/>  even a low-level value <code class="literal">WaitHandle</code>, which is signaled when the token is canceled.</p><p>This <code class="literal">WaitHandle</code> property is another object that provides access to the native operating system handle for this thread and has properties and methods to release all resources held by the current <code class="literal">WaitHandle</code> property (the <code class="literal">Close</code> method) or to block the current thread until <code class="literal">WaitHandle</code> receives a signal:</p><div class="mediaobject"><img src="../Images/image00692.jpeg" alt="Canceling execution"/></div><p style="clear:both; height: 1em;"> </p><p>Obviously, in this case, the process is a bit more complex, since we need to catch the exception launched <a id="id1205" class="indexterm"/>by the token and act accordingly:</p><div class="informalexample"><pre class="programlisting">private void btnPrimesWithCancel_Click(object sender, EventArgs e)
{
  List&lt;int&gt; primes;
  using (var cs = newCancellationTokenSource())
  {
    watch.Restart();
    var query = numbers.AsParallel().AsOrdered()
    .WithCancellation(cs.Token)
    .WithDegreeOfParallelism(Environment.ProcessorCount / 2)
    .Where(n =&gt; n.IsPrime(cs));
    try
    {
      primes = query.ToList();
    }
    catch (OperationCanceledException oc)
    {
      string msg1 = "Query cancelled.";
      string msg2 = "Cancel Requested: " +
      oc.CancellationToken.IsCancellationRequested.ToString();
      listBox5.Items.Add(msg1);
      listBox5.Items.Add(msg2);
    }
  }
  watch.Stop();
  lblCancel.Text = strLabel + watch.ElapsedMilliseconds.ToString("0,000") + " ms.";
}</pre></div><p>Note the use of <code class="literal">WithCancellation(cs.Token)</code> inside the query and also that the entire process in embedded in a <code class="literal">using</code> structure in order to guarantee the release of resources after the process ends.</p><p>Besides, instead <a id="id1206" class="indexterm"/>of using another mechanism, we add a cancelation message to the corresponding Listbox control, indicating whether the token was really canceled. You can see this in the next screenshot (also, note that the time elapsed is considerably less than the rest of cases):</p><div class="mediaobject"><img src="../Images/image00693.jpeg" alt="Canceling execution"/></div><p style="clear:both; height: 1em;"> </p><p>Nevertheless, there are some occasions in which the use of parallelism in this form might not be recommendable or is limited, such as when using operators, such as <code class="literal">Take</code> or <code class="literal">SkipWhile</code>, and also for the indexed versions of <code class="literal">Select</code> or <code class="literal">ElementAt</code>. In other circumstances, the overhead generated might be big, such as when using <code class="literal">Join</code>, <code class="literal">Union</code>, or <code class="literal">GroupBy</code>.</p></div></div>
<div class="section" title="The Parallel class" id="aid-2I0GC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec80"/>The Parallel class</h1></div></div></div><p>The Parallel class is <a id="id1207" class="indexterm"/>optimized for iterations and its behavior is even better—in loops—than PLINQ, although the difference is not meaningful. However, there are situations in which a fine-tuning of loops can noticeably increase the user experience.</p><p>The class has variants of the <code class="literal">for</code> and <code class="literal">foreach</code> methods (also <code class="literal">invoke</code>, but it is rare to see this in practice), which can be used in loops when we think the performance can be clearly slowed down using the nonparallel versions.</p><p>If we take a look at the definition of the <code class="literal">Parallel.For</code> version, we'll see that it receives a couple of numbers (<code class="literal">int</code> or <code class="literal">long</code>) to define the scope of the loop and an <code class="literal">Action</code>, which relates to the functionality to be executed.</p><p>Let's test this with a example that is similar, but not exact, to the previous one. We'll use the same <code class="literal">IsPrime</code> algorithm, but this time, we'll write the results checking one by one inside a <code class="literal">for</code> loop. So, we start with a simple loop that checks the first 1000 numbers and loads the result in RichTextbox.</p><p>Our initial code for the nonparallel version will be as follows:</p><div class="informalexample"><pre class="programlisting">private void btnStandardFor_Click(object sender, EventArgs e)
{
  rtbOutput.ResetText();
  watch.Start();
  for (int i = 1; i &lt; 1000; i++)
  {
    if (i.IsPrime())
      rtbOutput.Text += string.Format("{0} is prime", i) + cr;
    else
      rtbOutput.Text += string.Format("{0} is NOT prime", i) + cr;
  }
  watch.Stop();
  label1.Text = "Elapsed Time: " + watch.ElapsedMilliseconds.ToString("0,000") + " ms."; ;
}</pre></div><p>The problem here is knowing how to transform the previous code into a <code class="literal">Parallel.For</code>. Now, the action to perform by the loop is indicated by a lambda expression that is in charge of checking each value.</p><p>However, we find an extra problem. Since this is parallel and new threads will be created, we can't update the user interface directly, or we will get <code class="literal">InvalidOperationException</code>.</p><p>There are several solutions for this, but one of most used solutions is in the <code class="literal">SynchronizationContext</code> object. As Joydip Kanjilal states in <span class="emphasis"><em>Learning Synchronization Context, async, and await</em></span> (refer to <a class="ulink" href="http://www.infoworld.com/article/2960463/application-development/my-two-cents-on-synchronizationcontext-async-and-await.html">http://www.infoworld.com/article/2960463/application-development/my-two-cents-on-synchronizationcontext-async-and-await.html</a>), The <code class="literal">SynchronizationContext</code> object represents an <a id="id1208" class="indexterm"/>abstraction it denotes the location where your application's code is executed and enables you to queue a task onto another context (every thread <a id="id1209" class="indexterm"/>can have its own <code class="literal">SynchronizatonContext</code> object). The <code class="literal">SynchronizationContext</code> object was added to the <code class="literal">System.Threading</code> namespace to facilitate communication between threads.</p><p>The resulting code for our Parallel. For that will look like this:</p><div class="informalexample"><pre class="programlisting">// Previously, at class definition:
Stopwatch watch = newStopwatch();
string cr = Environment.NewLine;
SynchronizationContext context;

public Form1()
{
  InitializeComponent();
  //context = new SynchronizationContext();
  context = SynchronizationContext.Current;
}

private void btnParallelFor_Click(object sender, EventArgs e)
{
  rtbOutput.ResetText();
  watch.Restart();
  Parallel.For(1, 1000, (i) =&gt;
  {
    if (i.IsPrime())
      context.Post(newSendOrPostCallback((x) =&gt;
    {
      UpdateUI(string.Format("{0} is prime", i));
    }), null);
    else
      context.Post(newSendOrPostCallback((x) =&gt;
    {
      UpdateUI(string.Format("{0} is NOT prime", i));
    }), null);
  });
  watch.Stop();
  label2.Text = "Elapsed Time: " + watch.ElapsedMilliseconds.ToString("0,000") + " ms.";
}
private void UpdateUI(string data)
{
  this.Invoke(newAction(() =&gt;
  {
    rtbOutput.Text += data + cr;
  }));
}</pre></div><p>With this approach, we<a id="id1210" class="indexterm"/> send a synchronization order from the thread in execution (whichever it is) to the main thread (the UI Thread). To do this, we first cache the <code class="literal">SynchronizationContext</code> object of the current thread at definition time, and later, we use it to call the <code class="literal">Post</code> method on the context which will invoke a new action to update the user interface.</p><p>Note that this solution is coded in this way to show that <code class="literal">Parallel.For</code> can also be used in processes that (one at a time) manipulate the user interface.</p><p>We can appreciate the difference between both approaches calculating the same primes, as shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00694.jpeg" alt="The Parallel class"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="The Parallel.ForEach version"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec137"/>The Parallel.ForEach version</h2></div></div></div><p>Another variant of the same idea is <code class="literal">Parallel.ForEach</code>. It's practically the same except that we don't have a <a id="id1211" class="indexterm"/>starting or ending number in the definition. It's better to use a sequence of information and a unique variable that we'll use to iterate over each element of the sequence.</p><p>However, I'm going to change the type of process for this demo so that you can compare and get your own conclusions. I will go through a list of small <code class="literal">.png</code> files (icons128 x 128), and I'll create a new version of these icons (transparent), saving the new modified icon in another directory.</p><p>We're using an IO-bound process in this case. The slow method will be linked to the disk drive, not to the CPU. Other possible IO-bound processes you could try include downloading files or images from a website or blog posts from any social network.</p><p>Since the most important thing here is time gain, we'll process the files one after the other and compare the resulting elapsed times, showing the output in a window. I'll use a button to launch the process with the following code (please, note that <code class="literal">Directory.GetFiles</code> should point to a directory of your own where some <code class="literal">.png</code> files are present):</p><div class="informalexample"><pre class="programlisting">Stopwatch watch = new Stopwatch();
string[] files = Directory.GetFiles(@"&lt;Your Images Directory Goes Here&gt;", "*.png");
string modDir = @"&lt;Images Directory&gt;/Modified";

public void ProcessImages()
{
  Directory.CreateDirectory(modDir);
  watch.Start();

  foreach (var file in files)
  {
    string filename = Path.GetFileName(file);
    var bitmap = ne0wBitmap(file);
    bitmap.MakeTransparent(Color.White);
    bitmap.Save(Path.Combine(modDir, filename));
  }
  watch.Stop();

  lblForEachStandard.Text += watch.ElapsedMilliseconds.ToString() + " ms.";
  watch.Restart();

Parallel.ForEach(files, (file) =&gt;
  {
    string filename = Path.GetFileName(file);
    var bitmap = newBitmap(file);
    bitmap.MakeTransparent(Color.White);
    bitmap.Save(Path.Combine(modDir, "T_" + filename));
  });
  watch.Stop();
  lblParallel.Text += watch.ElapsedMilliseconds.ToString() + " ms.";
  MessageBox.Show("Finished");
}</pre></div><p>As you can see, there are two loops. The second one also uses a <code class="literal">file</code> variable to iterate over the collection of files retrieved by the <code class="literal">Directory.GetFiles()</code> call, but the second argument of the <code class="literal">Parallel.ForEach</code> loop is a lambda expression, containing exactly the same code as the first <code class="literal">foreach</code> method (well, with the slight difference that I'm appending a <code class="literal">T_</code> prefix to<a id="id1212" class="indexterm"/> the name before saving it).</p><p>However, the difference in the processing time is meaningful, even in this case where just a handful of files were available (around a hundred).</p><p>You can see the difference in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00695.jpeg" alt="The Parallel.ForEach version"/></div><p style="clear:both; height: 1em;"> </p><p>So, in both samples, either CPU- or IO-bound, the gain is important, and other considerations apart (there's always some), we have a nice solution here, with these two options for parallelism (Remember that you should change the program's entry point, depending on the demo to execute, in the <code class="literal">Program.cs</code> file).</p></div></div>
<div class="section" title="Task Parallel"><div class="titlepage" id="aid-2IV0U2"><div><div><h1 class="title"><a id="ch13lvl1sec81"/>Task Parallel</h1></div></div></div><p>While all this is important, there are cases where this solution lacks enough flexibility, and that's why we include <span class="strong"><strong>Task Parallel Library</strong></span> in the set of the software tools available.</p><p>We've seen the basics <a id="id1213" class="indexterm"/>of the <code class="literal">Task</code> object in <a class="link" title="Chapter 3. Advanced Concepts of C# and .NET" href="part0023.xhtml#aid-LTSU2">Chapter 3</a>, <span class="emphasis"><em>Advanced Concepts of C# and .NET</em></span>, and <a class="link" title="Chapter 12. Performance" href="part0078.xhtml#aid-2ACBS2">Chapter 12</a>, <span class="emphasis"><em>Performance</em></span>, but now it's time to look at some more advanced aspects that make this object one of the most interesting in .NET Framework regarding parallel programming.</p><div class="section" title="Communication between threads"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec138"/>Communication between threads</h2></div></div></div><p>As you know, the<a id="id1214" class="indexterm"/> results obtained after task completions can be of any type (Generics included).</p><p>When you create a new <code class="literal">Task&lt;T&gt;</code> object, you inherit several methods and properties to facilitate data manipulation and retrieval. For example, you have properties such as <code class="literal">Id</code>, <code class="literal">IsCancelled</code>, <code class="literal">IsCompleted</code>, <code class="literal">IsFaulted</code>, and <code class="literal">Status</code> to determine the state of the task and a <code class="literal">Result</code> property, which contains the returning value of the task.</p><p>As for the methods available, you have a <code class="literal">Wait</code> method to force the <code class="literal">Task</code> object to wait until completion, and another very useful method called <code class="literal">ContinueWith</code>. With this method, you can code what to do when the task is finished, knowing that the results are obtainable from the <code class="literal">Result</code> property.</p><p>So, let's imagine a situation like we did in the earlier demo about reading and manipulating files in a directory – only this time, we're just reading the names and using a <code class="literal">Task</code> object.</p><p>With all this functionality, we might think that the following code should work correctly:</p><div class="informalexample"><pre class="programlisting">private void btnRead_Click(object sender, EventArgs e)
{
var getFiles = newTask&lt;List&lt;string&gt;&gt;(() =&gt;  getListOfIconsAsync());
  getFiles.Start();
  getFiles.ContinueWith((f) =&gt; UpdateUI(getFiles.Result));
}
private List&lt;string&gt; getListOfIconsAsync()
{
  string[] files = Directory.GetFiles(filesPath, "*.png");
  return files.ToList();
}
private void UpdateUI(List&lt;string&gt; filenames)
{
  listBox1.Items.Clear();
  listBox1.DataSource = filenames;
}</pre></div><p>As you can see, we create a new <code class="literal">Task&lt;List&lt;string&gt;&gt;</code> object instance; so, we can take advantage of its functionality and invoke <code class="literal">ContinueWith</code> to update the user interface with the results.</p><p>However, we get <code class="literal">InvalidOperationException</code> in the <code class="literal">UpdateUI</code> method because it's still the Task (another thread) that is trying to access a different thread. And it does not matter that the results have been obtained correctly, as you can see in this screenshot, showing the value of <code class="literal">Result</code>:</p><div class="mediaobject"><img src="../Images/image00696.jpeg" alt="Communication between threads"/></div><p style="clear:both; height: 1em;"> </p><p>Fortunately, we have<a id="id1215" class="indexterm"/> a solution linked to the <code class="literal">TaskScheduler</code> object, which is part of this set of tools. We just have to pass another argument to the <code class="literal">ContinueWith</code> method, indicating the <code class="literal">FromCurrentSynchronizationContext</code> property.</p><p>So, we'll modify the previous call as follows:</p><div class="informalexample"><pre class="programlisting">getFiles.ContinueWith((f) =&gt; UpdateUI(getFiles.Result),
TaskScheduler.FromCurrentSynchronizationContext());</pre></div><p>Now everything works perfectly, as you can see in the final screenshot of the execution:</p><div class="mediaobject"><img src="../Images/image00697.jpeg" alt="Communication between threads"/></div><p style="clear:both; height: 1em;"> </p><p>And there it is! A very simple form of updating the user interface from a task without needing complex constructions or other specific objects.</p><p>Also, note that this method has up to 40 overloads in order to allow us the behavior configuration in many different ways:</p><div class="mediaobject"><img src="../Images/image00698.jpeg" alt="Communication between threads"/></div><p style="clear:both; height: 1em;"> </p><p>Other interesting <a id="id1216" class="indexterm"/>possibilities linked to the <code class="literal">Task</code> object are related to some of its static methods, especially <code class="literal">WaitAll</code>, <code class="literal">WaitAny</code>, <code class="literal">WhenAll</code>, and <code class="literal">WhenAny</code>. Let's look at what they do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">WaitAll</code>: Waits for all the <a id="id1217" class="indexterm"/>provided <code class="literal">Task</code> objects to complete the execution (it receives a collection of the <code class="literal">Task</code> objects)</li><li class="listitem"><code class="literal">WaitAny</code>: It has the <a id="id1218" class="indexterm"/>same structure as <code class="literal">WaitAll</code>, but it waits for the first task to finish</li><li class="listitem"><code class="literal">WhenAll</code>: Creates a new<a id="id1219" class="indexterm"/> task that executes only when all the provided tasks are completed</li><li class="listitem"><code class="literal">WhenAny</code>: The same <a id="id1220" class="indexterm"/>structure as the earlier one, but it waits for the first task to finish</li></ul></div><p>And there's still another interesting feature: <code class="literal">ContinueWhenAll</code>, which guarantees that something is done only when all tasks passed as arguments are finished.</p><p>Let's take an example to see how this works. We have three algorithms for image manipulation: the three receive a <code class="literal">Bitmap</code> object and return another bitmap, transformed. You can read the algorithms in the demo code (they are named <code class="literal">BitmapInvertColors</code>, <code class="literal">MakeGrayscale</code>, and <code class="literal">CorrectGamma</code>).</p><p>When the button is clicked on, four tasks are created: each one calling to a method in charge of transforming a bitmap and presenting the result in a different <code class="literal">pictureBox</code> control. And we use the previous <code class="literal">ContinueWith</code> method to update a label's text in the user interface so that we know the order in which they execute.</p><p>The code is as follows:</p><div class="informalexample"><pre class="programlisting">private void btnProcessImages_Click(object sender, EventArgs e)
{
  lblMessage.Text = "Tasks finished:";
  var t1 = Task.Factory.StartNew(() =&gt; pictureBox1.Image =
    Properties.Resources.Hockney_2FIGURES);
  t1.ContinueWith((t) =&gt; lblMessage.Text += " t1-",
    TaskScheduler.FromCurrentSynchronizationContext());
  var t2 = Task.Factory.StartNew(() =&gt; pictureBox2.Image =
    BitmapInvertColors(Properties.Resources.Hockney_2FIGURES));
  t2.ContinueWith((t) =&gt; lblMessage.Text += " t2-",
    TaskScheduler.FromCurrentSynchronizationContext());
  var t3 = Task.Factory.StartNew(() =&gt; pictureBox3.Image =
    MakeGrayscale(Properties.Resources.Hockney_2FIGURES));
  t3.ContinueWith((t) =&gt; lblMessage.Text += " t3-",
    TaskScheduler.FromCurrentSynchronizationContext());
  var t4 = Task.Factory.StartNew(() =&gt; pictureBox4.Image =
    CorrectGamma(Properties.Resources.Hockney_2FIGURES, 2.5m));
  //var t6 = Task.Factory.StartNew(() =&gt; Loop());
  t4.ContinueWith((t) =&gt; lblMessage.Text += " t4-",
    TaskScheduler.FromCurrentSynchronizationContext());
  var t5 = Task.Factory.ContinueWhenAll(new[] { t1, t2, t3, t4 }, (t) =&gt;
  {
    Thread.Sleep(50);
  });
  t5.ContinueWith((t) =&gt; lblMessage.Text += " –All finished",
    TaskScheduler.FromCurrentSynchronizationContext());
}</pre></div><p>If we want the <code class="literal">All finished</code> label to update the last one, we need a way to make sure that the fifth Task is <a id="id1221" class="indexterm"/>executed as the latest in the sequence (of course, if we don't use a Task, it would be updated as the first).</p><p>As you can see in the next screenshot, the order of the second, third, and fourth tasks will be random, but the first one (because it doesn't do any heavy work; it only loads the original image) will always appear heading the sequence and the fifth one will appear the latest:</p><div class="mediaobject"><img src="../Images/image00699.jpeg" alt="Communication between threads"/></div><p style="clear:both; height: 1em;"> </p><p>There are other<a id="id1222" class="indexterm"/> interesting features still, similar to the ones we saw earlier in the parallel demos in relation to cancellation.</p><p>To cancel a task, we will use a similar procedure—only in this case, it is simpler. I'll use a Console application to show it in a couple of simple methods:</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  Console.BackgroundColor = ConsoleColor.Gray;
  Console.WindowWidth = 39;
  Console.WriteLine("Operation started...");
  var cs = newCancellationTokenSource();
  var t = Task.Factory.StartNew(
    () =&gt; DoALongWork(cs)
  );
  Thread.Sleep(500);
  cs.Cancel();
  Console.Read();
}
private static void DoALongWork(CancellationTokenSource cs)
{
  try
  {
    for (int i = 0; i &lt; 100; i++)
    {
      Thread.Sleep(10);
      cs.Token.ThrowIfCancellationRequested();
    }
  }
  catch (OperationCanceledException ex)
  {
    Console.WriteLine("Operation Cancelled. \n Cancellation requested: " + ex.CancellationToken.IsCancellationRequested);
  }
}</pre></div><p>As you can see, we <a id="id1223" class="indexterm"/>generate a Task over a <code class="literal">DoALongWork</code> method, which includes a delay of a tenth of a second in a 100-iteration loop. However, in every iteration, we check the value of the <code class="literal">ThrowIfCancellationRequested</code> method, which belongs to the <code class="literal">CancellationTokenSource</code> method previously generated at task creation, and passes it to the slow method.</p><p>After 500 milliseconds, <code class="literal">cs.Cancel()</code> is called in the main thread, thread execution stops, and <code class="literal">Exception</code> is launched and recovered on the <code class="literal">catch</code> side in order to present the output in the Console as a message, showing whether the cancellation was really requested.</p><p>The next screenshot shows what you should see when executing this code:</p><div class="mediaobject"><img src="../Images/image00700.jpeg" alt="Communication between threads"/></div><p style="clear:both; height: 1em;"> </p><p>Up until here, this was a review of Task Parallel Library and some of its most interesting possibilities.</p><p>We'll move toward<a id="id1224" class="indexterm"/> the end of this book by talking about the latest innovations in .NET now: the so-called NET Core 1.0, which is intended to execute on all platforms, including Linux and MacOS.</p></div></div>
<div class="section" title=".NET Core 1.0"><div class="titlepage" id="aid-2JTHG2"><div><div><h1 class="title"><a id="ch13lvl1sec82"/>.NET Core 1.0</h1></div></div></div><p>.NET Core is a version of .NET Framework (first versions were released in the summer of 2016) that denotes <a id="id1225" class="indexterm"/>a major breakthrough in the Microsoft Development Technologies ecosystem, the greatest promise being its ability to execute cross-platform: Windows, MacOS, and Linux.</p><p>Besides, .NET Core is modular, open source, and cloud-ready. It can be deployed along with the application itself, minimizing installation issues.</p><p>Although the number was consecutive to previous versions initially, Microsoft decided to restart the numbering, reinforcing the idea that this is a totally new concept with respect to classical versions, as a better way to avoid ambiguities. For those who were already aware of the initial versions, let's remember that the equivalence is as follows (refer to the screenshot):</p><div class="mediaobject"><img src="../Images/image00701.jpeg" alt=".NET Core 1.0"/></div><p style="clear:both; height: 1em;"> </p><p>The screenshot shows the equivalence between the new names and how some technologies go beyond platforms and (as it happens in ASP.NET Core or MVC Core) can even execute over the classic platform (.NET Framework 4.6).</p><p>.NET Core is based on CoreCLR, which is a lightweight runtime, providing the basic services. This includes automatic memory management, garbage collection, and the basic type libraries.</p><p>.NET Core, as with <a id="id1226" class="indexterm"/>many other projects now, is part of the .NET foundation.</p><p>It also includes CoreFx, which is a set of modular assemblies. These assemblies can be added to your project as per your demand (remember that in .NET 4.x, we always had to make the entire BCL available). Now, you select only the assemblies that you need.</p><div class="section" title="The list of supported environments"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec139"/>The list of supported environments</h2></div></div></div><p>According <a id="id1227" class="indexterm"/>to C# Corner's <span class="emphasis"><em>.NET Core - Fork In The Road</em></span> (<a class="ulink" href="http://www.c-sharpcorner.com/article/net-core-fork-in-the-road/">http://www.c-sharpcorner.com/article/net-core-fork-in-the-road/</a>), the following<a id="id1228" class="indexterm"/> table explains<a id="id1229" class="indexterm"/> availability for distinct platforms, although the list is continuously growing:</p><div class="mediaobject"><img src="../Images/image00702.jpeg" alt="The list of supported environments"/></div><p style="clear:both; height: 1em;"> </p><p>Another target of .NET <a id="id1230" class="indexterm"/>Core is to achieve project unification by means of a unique <code class="literal">project.json</code> file, in which all configuration<a id="id1231" class="indexterm"/> features will appear independently of the type of project being built (no more <code class="literal">app.config</code>, <code class="literal">web.config</code>, and so on). However, in Visual Studio 2017, the dependencies declared in the <code class="literal">project.json</code> file have been moved to the <code class="literal">.sln</code> file for unification.</p><p>.NET Core is supposed to be built on four parts, including Core FX, Core CLR, Core RT, and Core CLI. Let's take a quick look these parts, one by one.</p><div class="section" title="Core FX"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec82"/>Core FX</h3></div></div></div><p>Core FX contains<a id="id1232" class="indexterm"/> the implementation of the foundational libraries, including the classic namespaces: <code class="literal">System.Collections</code>, <code class="literal">System.IO</code>, <code class="literal">System.Xml</code>, and so on. However, it doesn't include the base types, which <a id="id1233" class="indexterm"/>are part of <code class="literal">mscorlib</code>, in a different repo, <code class="literal">CoreCLR</code>.</p><p>You can access these repos in GitHub at <a class="ulink" href="https://github.com/dotnet/corefx">https://github.com/dotnet/corefx</a>.</p></div><div class="section" title="Core CLR"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec83"/>Core CLR</h3></div></div></div><p>Core CLR is actually<a id="id1234" class="indexterm"/> the .NET virtual machine (the runtime). It includes RyuJIT (or CLR JIT), which is a new<a id="id1235" class="indexterm"/> generation 64-bit compiler, the .NET Garbage Collector, the <code class="literal">mscorlib.dll</code> previously mentioned, and a bunch of libraries.</p><p>The repo is available at <a class="ulink" href="https://github.com/dotnet/coreclr">https://github.com/dotnet/coreclr</a>, and you'll also find all the related documentation there.</p><p>It is deployed along with your application (so no more <code class="literal">.NET Framework x.x version required</code> messages) and allows side-by-side execution; therefore, it guarantees the integrity of other existing applications.</p></div><div class="section" title="Core RT"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec84"/>Core RT</h3></div></div></div><p>Core RT is an<a id="id1236" class="indexterm"/> alternative to Core CLR, optimized<a id="id1237" class="indexterm"/> for <span class="strong"><strong>AoT</strong></span> (<span class="strong"><strong>Ahead of Time</strong></span>) scenarios. It's available at the repo at <a class="ulink" href="https://github.com/dotnet/corert">https://github.com/dotnet/corert</a>.</p><p>Obviously, you might be<a id="id1238" class="indexterm"/> wondering about this term (AoT) and the difference with respect to the JIT compilation that we've been using.</p><p>Let's remember that a JIT compiler is responsible for converting MSIL code into native code. And this is done at runtime; so, every time a method is called for the first time, it is compiled and executed.</p><p>In this manner, the application can be executed in distinct CPUs and OSes with the runtime installed, but the caveat is that it's a process that takes time and has an impact on the application's performance.</p><p>On the other hand, AoT compilers also compile MSIL to native code, but Wikipedia says that they do it, reducing the runtime overhead, into a native (system-dependent) machine code with the intention of executing the resulting binary file natively.</p><p>Wikipedia also adds this:</p><div class="blockquote"><blockquote class="blockquote"><p>"In most situations with fully AOT compiled programs and libraries it is possible to drop a considerable fraction of theruntime environment, thus saving disk space, memory, battery and startup times (no JIT warmup phase), etc. Because of this, it can be useful in embedded or mobile devices."</p></blockquote></div><p>As RobJb points <a id="id1239" class="indexterm"/>out in StackOverflow:</p><div class="blockquote"><blockquote class="blockquote"><p>"AOT compilers can also spend as much time optimizing as they like, whereas JIT compilation is bound by time requirements (to maintain responsiveness) and the resources of the client machine. For this reason, AOT compilers can perform a complex optimization that would be too costly during JIT."</p></blockquote></div><p>To summarize, the emphasis of CoreRT is on code optimization and conversion into a specific native platform. The generated executable will greater in size, but it contains the application, all its dependencies, plus the CoreRT.</p><p>Applications that use CoreRT execute faster and can use the proper optimizations of a native compiler, favoring better performance and code quality improvement.</p></div><div class="section" title="Core CLI"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec85"/>Core CLI</h3></div></div></div><p>Core CLI is a command line<a id="id1240" class="indexterm"/> interface, independent from other libraries, providing an easy way to install a basic framework where we can test .NET Core code on any platform in only a few steps.</p><p>The installation is simple: files of types MSI in Windows, PKG in MacOS, or and <code class="literal">apt-get</code> in Linux; or they may even use a <code class="literal">curl</code> script.</p><p>Besides, a re-platform <a id="id1241" class="indexterm"/>of ASP.NET over .NET Core 1.0 has been created, as we'll see later. The project file will be a <code class="literal">.xproj</code> file, with no differences between flavors or languages.</p><p>Once installed, you can emit commands such as <code class="literal">dotnetbuild</code>, for example, and generate the results and see the execution. One point to note is that the Core CLI itself is made using Core RT; so it uses optimized native technology as well.</p></div></div><div class="section" title="Installation of .NET Core"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec140"/>Installation of .NET Core</h2></div></div></div><p>The .NET Core<a id="id1242" class="indexterm"/> installation has changed since the first release candidates, and now the previous location at GitHub will lead us to the <a class="ulink" href="https://www.microsoft.com/net/core">https://www.microsoft.com/net/core</a> site, where we'll find instructions to download .NET Core in four different contexts: Windows, Linux, MacOS, and Docker.</p><div class="note" title="Note"><h3 class="title"><a id="note32"/>Note</h3><p>Also, note that in order to work with .NET Core from Visual Studio 2015, you need to have Upgrade 3 installed. It will appear as an option under the <span class="strong"><strong>Extensions and Updates</strong></span> in the <span class="strong"><strong>Updates</strong></span> section.</p></div><p>Besides this installation, you can use .NET Core inside Visual Studio 2015 and higher versions if you additionally install NET Core 1.0.0 – VS 2015 Tooling, available at the same page. It takes a few minutes and asks for a confirmation (refer to the screenshot):</p><div class="mediaobject"><img src="../Images/image00703.jpeg" alt="Installation of .NET Core"/></div><p style="clear:both; height: 1em;"> </p><p>Note that, at the<a id="id1243" class="indexterm"/> time of writing this, the VS 2015 Tooling is available as a preview version and will probably be in its final version by the time you read this. Additionally, you <a id="id1244" class="indexterm"/>can install the Core CLI from the same page mentioned earlier or go directly to the <a class="ulink" href="https://github.com/dotnet/cli">https://github.com/dotnet/cli</a> page.</p><p>Once the installation is complete, if we go to Visual Studio and select <span class="strong"><strong>New Project</strong></span>, we'll see a new section called <span class="strong"><strong>NET Core</strong></span>, offering three types of applications: Class Library, Console Application, and ASP.NET Core Web Application:</p><div class="mediaobject"><img src="../Images/image00704.jpeg" alt="Installation of .NET Core"/></div><p style="clear:both; height: 1em;"> </p><p>As you can imagine, in the fist case, we can create a DLL to be used by other projects, and the two latest options are the ones that make sense (for the moment) with this initial version of .NET Core.</p><p>If we take a look at the files created with the <span class="strong"><strong>Console Application</strong></span> option, the Solution Explorer will show<a id="id1245" class="indexterm"/> us a familiar structure with some differences, though.</p><p>To start with, we see the presence of two main directories: one for the solution (which includes a <code class="literal">global.json</code> file) and another called <code class="literal">src</code>, where we find the rest of the assets of our application.</p><p>The <code class="literal">global.json</code> file contains the folders that should be searched at compile-time when resolving dependencies for projects. The build system will only search top-level child folders.</p><p>By default, the following content is included:</p><div class="informalexample"><pre class="programlisting">{
  "projects": [ "src", "test" ],
  "sdk": {
    "version": "1.0.0-preview2-003121"
  }
}</pre></div><p>This defines two projects in our solution: the standard one and another for testing. Besides this, the <code class="literal">sdk</code> key indicates the version to be used (<code class="literal">1.0.0-preview-003121</code>), and we can add or change that at will.</p><div class="note" title="Note"><h3 class="title"><a id="note33"/>Note</h3><p>A very interesting aspect of the tooling in Visual Studio 2015, when dealing with <code class="literal">.json</code> files for configuration is that if we change any value, the corresponding reference will be searched online automatically and downloaded to our project.</p></div><p>There are other<a id="id1246" class="indexterm"/> options available, such as the architecture to be used (x64 / x86) or the target runtime, as shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00705.jpeg" alt="Installation of .NET Core"/></div><p style="clear:both; height: 1em;"> </p><p>Within the <code class="literal">src</code> directory, the typical console structure can be found, only that all references included in the <span class="strong"><strong>References</strong></span> section point to <span class="strong"><strong>Microsoft.NETCore.App (1.0.0)</strong></span> and include a long list of components available, all of them in a hierarchical structure of dependencies.</p><p>The aspect of the main <code class="literal">Program.cs</code> file is just the usual in these projects (no changes), and this is true for <code class="literal">AssemblyInfo.cs</code> (although some values would be ignored on other platforms).</p><p>However, there's no <code class="literal">app.config</code> file. This file has been replaced with another <code class="literal">.json</code> file, <code class="literal">project.json</code>, which will be in charge of the definitions of the application's configuration from now on (remember that this has changed in Visual Studio 2017, where the <code class="literal">.sln</code> file is used to declare dependencies).</p><p>And, as it happens with the <code class="literal">global.json</code> file, the editor recognizes the values assigned to the keys and provides Intellisense here as well, with interesting hints about the possible values to configure (the next screenshot includes the initial list of references and Intellisense in<a id="id1247" class="indexterm"/> action within the <code class="literal">project.json</code> file):</p><div class="mediaobject"><img src="../Images/image00706.jpeg" alt="Installation of .NET Core"/></div><p style="clear:both; height: 1em;"> </p><p>Now, I'm going to use a simple code snippet to explore how some of the common namespaces are implemented in .NET Core. In this case, we have three text files located in the same directory as the application (could be any directory, of course), and we're going to search for them, read their content, and present it in the console.</p><p>So we have some very simple code in the <code class="literal">program.cs</code> file, which serves as the entry point of the application:</p><div class="informalexample"><pre class="programlisting">staticstring pathImages = @"&lt;Your Path to files&gt;;
staticvoid Main(string[] args)
{
  Console.WriteLine(" Largest number of Rows: " + Console.LargestWindowHeight);
  Console.WriteLine(" Largest number of Columns: " + Console.LargestWindowWidth);
  Console.WriteLine(" ------------------------------\n");
  ReadFiles(pathImages);
  Console.ReadLine();
}

privatestaticvoid ReadFiles(string path)
{
  DirectoryInfo di = newDirectoryInfo(path);
  var files = di.EnumerateFiles("*.txt",
  SearchOption.TopDirectoryOnly).ToArray();
  foreach (var item in files)
  {
    Console.WriteLine(" "+ File.ReadAllText(item.FullName));
  }
}</pre></div><p>We can compile the <a id="id1248" class="indexterm"/>program as always, and at runtime, we should see the output, only working on the .NET Core infrastructure (refer to the next screenshot):</p><div class="mediaobject"><img src="../Images/image00707.jpeg" alt="Installation of .NET Core"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the functionalities, code, libraries, and namespaces used are just the same as the ones we would use in a standard Console application—only now, we're using the .NET Core 1.0 libraries and architecture.</p><p>However, a look at the code (and the output) will probably call your attention, since the name of the executable that we see in the output window is <code class="literal">dotnet.exe</code> and not <code class="literal">NETCoreConsoleApp1</code> (the name we gave to our solution).</p><p>The reason for this has to do with the complexity linked to this model. The application is thought to be executable on distinct platforms. The default option allows the deployment architecture to determine the best way to configure the JIT compilers depending on the target. This is why the execution is undertaken by the dotnet runtime (named <code class="literal">dotnet.exe</code>).</p><p>In NET Core, two types<a id="id1249" class="indexterm"/> of applications are defined: portable and self-contained. As the official documentation states:</p><div class="blockquote"><blockquote class="blockquote"><p>"Portable applications are the default type in .NET Core. They require .NET Core to be installed on the targeted machine in order for them to run. To you as a developer, this means that your application is portable between installations of .NET Core.</p><p>A self-contained application does not rely on any shared component to be present on the machine where you want to deploy the application. As its name implies, it means that the entire dependency closure, including the runtime, is packaged with the application. This makes it larger, but also makes it capable of running on any .NET Core supported platforms with the correct native dependencies, whether it has .NET Core installed or not. This makes it that much easier to deploy to the target machine since you only deploy your application."</p></blockquote></div><p>The default configuration we're using is the portable one. Where is this configuration established? In the <code class="literal">project.json</code> dependencies section, you'll see that there is a <code class="literal">"type":"Platform"</code> entry. That's what indicates this execution model.</p><p>Actually, the resulting assembly is a DLL, as you can see by watching the <code class="literal">bin/debug</code> directory after compilation. In our case, this DLL is only 6 Kb long.</p><p>What about the other choice? Well, if you know that you're going to target a certain platform, you can eliminate the previously mentioned entry in the <code class="literal">project.json</code> file (that's first). Second, you should leave the <code class="literal">Microsoft.NET Core.App</code> dependency, since it will retrieve all of the rest of the required components. Finally, it will be necessary to indicate (in the runtimes node) those that you want to use.</p><p>So, I changed the <code class="literal">project.json</code> file to appear with this configuration:</p><div class="informalexample"><pre class="programlisting">{
  "version": "1.0.0-*",
  "buildOptions": {
    "emitEntryPoint": true
  },

  "dependencies": {
    "Microsoft.NETCore.App": {
      "version": "1.0.0"
    }
  },
  "runtimes": {
    "win10-x64": {}
  },
  "frameworks": {
    "netcoreapp1.0": {
      "imports": "dnxcore50"
    }
  }
}</pre></div><p>Now the compiler behaves differently: it generates a new folder (dependent on the debug folder), containing a real native executable, which contains all the required elements to run in any platform <a id="id1250" class="indexterm"/>of that type (<code class="literal">win10-x64</code>, in our demo).</p><p>After compilation, you'll see new files appearing, and one of them will be an executable file now. If you move to that folder in the Explorer, you'll see that there's a new file named <code class="literal">NETCoreConsoleApp1.exe</code>, which is the standalone executable. Also, this new file is larger than the DLL since it contains all the requirements (refer to the screenshot):</p><div class="mediaobject"><img src="../Images/image00708.jpeg" alt="Installation of .NET Core"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note34"/>Note</h3><p>There is an exhaustive<a id="id1251" class="indexterm"/> explanation of all possible configuration options at <a class="ulink" href="https://docs.microsoft.com/es-es/dotnet/articles/core/tools/project-json">https://docs.microsoft.com/es-es/dotnet/articles/core/tools/project-json</a>.</p></div></div><div class="section" title="The CLI interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec141"/>The CLI interface</h2></div></div></div><p>As we mentioned earlier, another choice available to develop these type of applications is now a command-line interface offered by the standalone installation of Core CLI or by the previous installation I made (the <code class="literal">DotNetCore.1.0.0 - VS2015Tools.Preview2.0.1</code> file).</p><p>Several preconfigured command-line windows are made available depending on the platform to target under<a id="id1252" class="indexterm"/> the generic name of Cross Tools Command Prompt. Just open the one that corresponds to your target platform and proceed as follows.</p><p>You can use the initial, basic demo mode that Microsoft has prepared as a start up with this tool. After opening Command Prompt, create a new directory that will serve as the root for a new project. In my case, I do it in a new <code class="literal">C:\dev\hello_world</code> directory (among other things, to avoid some security issues that might arise when using the <code class="literal">C:\</code> root directory).</p><p>At this point, you can ask for help by just typing <code class="literal">dotnet –help</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00709.jpeg" alt="The CLI interface"/></div><p style="clear:both; height: 1em;"> </p><p>To create a new project over this location, type <code class="literal">dotnet</code> new. Core CLI will download all the required components to your directories, including a basic application template, which holds a <code class="literal">program.cs</code> file with the classic <code class="literal">Hello World</code> console application, along with the default <code class="literal">project.json</code> file.</p><p>From this point, you can also open the project with Visual Studio Code (any platform, remember) and make the desired changes. The dot (<code class="literal">.</code>) indicates the IDE to use the current directory as the solution's directory.</p><p>The next step is to call <code class="literal">dotnet</code> restore. The result is that NuGet gets called in order to restore the tree<a id="id1253" class="indexterm"/> dependencies defined in <code class="literal">project.json</code> and creates a variant of this file called <code class="literal">project.lock.json</code>, which is required if you want to be able to compile and run (if you open this file, you'll see that it is pretty large).</p><p>The official documentation defines this file as:</p><div class="blockquote"><blockquote class="blockquote"><p>"A persisted and complete set of the graph of NuGet dependencies and other information describing an app. This file is read by other tools, such as dotnet build and dotnet run, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions."</p></blockquote></div><p>From here, several options are available. You can launch a <code class="literal">dotnet build</code> command, which will build the application and generate a directory structure similar to the one we saw in Visual Studio. It will not run; it will only generate the resulting files.</p><p>The alternative option is to call <code class="literal">dotnet run</code>. With this command, the <code class="literal">build</code> option is called, and next, it launches execution; so, you should see something like this:</p><div class="mediaobject"><img src="../Images/image00710.jpeg" alt="The CLI interface"/></div><p style="clear:both; height: 1em;"> </p><p>And, of course, it's a good practice to take a look at the resulting files, which will be located in a subdirectory of the debug file, just like in our Visual Studio app:</p><div class="mediaobject"><img src="../Images/image00711.jpeg" alt="The CLI interface"/></div><p style="clear:both; height: 1em;"> </p><p>If you're curious, you can change the <code class="literal">project.json</code> file to generate the standalone executable, just like we did earlier, and the results should be equivalent.</p><p>Well, up until<a id="id1254" class="indexterm"/> this point, we've seen an introduction to the .NET Core 1.0, but that's not the only development model .NET Core supports. Let's take a look at the—very interesting—ASP.NET Core 1.0.</p></div></div>
<div class="section" title="ASP.NET Core 1.0"><div class="titlepage" id="aid-2KS222"><div><div><h1 class="title"><a id="ch13lvl1sec83"/>ASP.NET Core 1.0</h1></div></div></div><p>The model adopted for ASP.NET applications that use .NET Core is totally based on the previous MVC model. But it's built from scratch, with the target on cross-platform execution, the elimination of some features (no longer necessary), and the unification of the previous MVC with the web API variant; so, they work with the same controller type.</p><p>Besides this, the code<a id="id1255" class="indexterm"/> doesn't need to be compiled prior to execution while you're developing. You change the code on the fly and Roselyn services take care of updating; so, you just have to refresh your page to see the changes.</p><p>If we take a look at the new list of templates, after installing .NET Core in the "Web" development section, we're offered a classic version of ASP.NET, where we have the typical templates you already know (including Web Forms applications) and two new options: ASP.Core Web Application (.NET Core) and ASP.NET Core Web Application (.NET Framework) (Review the first image at the beginning of the <span class="emphasis"><em>.NET Core 1.0</em></span> section to remember the architecture).</p><div class="section" title="What's new"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec142"/>What's new</h2></div></div></div><p>Many new things show <a id="id1256" class="indexterm"/>up in this version of ASP.NET Core. First, there's a new hosting model because ASP.NET is completely decoupled from the web server environment that hosts the application. It supports IIS versions and also self-hosting contexts via Kestrel (cross-platform, extremely optimized, built on top of LibUv, the same component that Node.js uses) and WebListener HTTP (Windows-only) servers.</p><p>We also count on a new generation of middleware that are asynchronous, very modular, lightweight, and totally configurable, where we define things such as routing, authentication, static files, diagnostics, error handling, session, CORS, localization, and even you can write and include your own middleware.</p><div class="note" title="Note"><h3 class="title"><a id="note35"/>Note</h3><p>For those who don't know, middleware is a pipeline element that is run before and after the user code. The components of a pipeline are executed in a sequence and they call the next one in the pipeline. In this way, we can execute pre/post code. When a piece of middleware generates a <code class="literal">Response</code> object, the pipeline returns.</p></div><p>Refer to the<a id="id1257" class="indexterm"/> following schema:</p><div class="mediaobject"><img src="../Images/image00712.jpeg" alt="What's new"/></div><p style="clear:both; height: 1em;"> </p><p>In addition, a new built-in IoC container for dependency injection is responsible for bootstrapping the system, and we also find a new configuration system, which we'll discuss in more detail a bit later.</p><p>ASP.NET Core joins many things that were separate earlier. No more distinctions between MVC and Web API, and a complete set of new Tag Helpers is available. And if you target .NET Core, or if you prefer to target any of the other versions of .NET, the architectural model is going to be MVC with this rebuilt architecture.</p></div><div class="section" title="A first approach"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec143"/>A first approach</h2></div></div></div><p>Let's look at the structure <a id="id1258" class="indexterm"/>of a project made up of the default templates available in Visual Studio 2015. You just have to select <span class="strong"><strong>New Project</strong></span> | <span class="strong"><strong>Web</strong></span> in Visual Studio to see these alternatives in action:</p><div class="mediaobject"><img src="../Images/image00713.jpeg" alt="A first approach"/></div><p style="clear:both; height: 1em;"> </p><p>I think it's a good idea to start with the simplest possible template and start digging into the programming architecture that lies behind this new proposal. So, I'll start with one of these new projects and select the <span class="strong"><strong>Empty</strong></span> option. I'm offered the three initial choices: <span class="strong"><strong>Empty</strong></span>, <span class="strong"><strong>Web API</strong></span>, and <span class="strong"><strong>Web Application</strong></span>.</p><p>A basic directory structure will be created for us, where we'll easily find some of the elements we previously saw in the introduction to .NET Core (including the separated <code class="literal">global.json</code> file used to define directories, projects, and packages). I named this demo <code class="literal">ASPNETCoreEmpty</code> (refer to the next screenshot for the solution structure).</p><p>You might be surprised to notice the absence (and also the presence) of certain files at first.</p><p>For instance, there's a new folder named <code class="literal">wwwroot</code>, which you surely know from other applications hosted in IIS. In this case, that hasn't to do with IIS: it only means that it is the root directory of our site. Actually, you'll also see a <code class="literal">web.config</code> file, but that's only to be used if you want the website to be hosted in IIS precisely.</p><p>You will also see the presence of a <code class="literal">project.json</code> file, but be careful with this. As the official documentation states:</p><div class="blockquote"><blockquote class="blockquote"><p>"ASP.NET Core's configuration system has been re-architected from previous versions of ASP.NET, which relied on System.Configuration and XML configuration files like web.config. The new configuration model provides streamlined access to key/value based settings that can be retrieved from a variety of sources. Applications and frameworks can then access configured settings in a strongly typed fashion using the new Options pattern."</p></blockquote></div><p>The next<a id="id1259" class="indexterm"/> capture remarks the two main <code class="literal">.cs</code> files created by the project:</p><div class="mediaobject"><img src="../Images/image00714.jpeg" alt="A first approach"/></div><p style="clear:both; height: 1em;"> </p><p>Furthermore, the official recommendation is that you use a configuration written in C#, which is linked to the <code class="literal">Startup.cs</code> file that you see in the file structure. Once there, you should use Options pattern to access any individual setting.</p><p>So we now have two initial points: one related to the host and another that configures our application.</p></div><div class="section" title="Configuration and Startup settings"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec144"/>Configuration and Startup settings</h2></div></div></div><p>Let's briefly<a id="id1260" class="indexterm"/> analyze the<a id="id1261" class="indexterm"/> file's contents:</p><div class="informalexample"><pre class="programlisting">// This method gets called by the runtime. Use this method to add 
// services to the container.
public void ConfigureServices(IServiceCollection services)
{
}
// This method gets called by the runtime. Use this method to configure
// the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironmentenv,
ILoggerFactory loggerFactory)
{
  loggerFactory.AddConsole();

  if (env.IsDevelopment())
  {
    app.UseDeveloperExceptionPage();
  }

  app.Run(async (context) =&gt;
  {
    await context.Response.WriteAsync("Hello World!");
  });
}</pre></div><p>You can see, there are only two methods: <code class="literal">ConfigureServices</code> and <code class="literal">Configure</code>. The former permits (you guessed it) to configure services. The <code class="literal">IServiceCollection</code> element it receives allows you to configure logins, options, and two flavors of services: <code class="literal">scoped</code> and <code class="literal">transient</code>.</p><p>The latter is the initial entry point of our application, and it receives three arguments that permit the developer all types of configuration and initial settings. The first one, <code class="literal">loggerFactory</code>, lets you add <a id="id1262" class="indexterm"/>
<code class="literal">ILoggerProvider</code> to the login system (refer to <a class="ulink" href="https://docs.asp.net/en/latest/fundamentals/logging.html">https://docs.asp.net/en/latest/fundamentals/logging.html</a> for more details), and in this case, it adds the <code class="literal">Console</code> provider.</p><div class="note" title="Note"><h3 class="title"><a id="note36"/>Note</h3><p>Observe that these two method's arguments are received automatically. Behind the scenes,the Dependency Injection engine provides these and other instances' elements.</p></div><p>We can add as many logging providers as we want: each time we write a log entry, that entry will be forwarded to each logging provider. The default provider writes to the Console window (if available).</p><p>The following lines also <a id="id1263" class="indexterm"/>explain some important things about the way this pipeline works. The second argument (of type <code class="literal">IHosting Environment</code>) lets you configure two different working environments: development and production, so we can, like in this case, activate error pages proper for development, or we can <a id="id1264" class="indexterm"/>configure these errors in a customized manner. This argument also contains some utility properties for developers.</p><p>The third argument (of type <code class="literal">IApplication Builder</code>) is the one that really launches the application. As you can see, it calls the <code class="literal">Run</code> method of another object received by injection: the <code class="literal">context</code> variable (of type <code class="literal">HttpContext</code>), which holds all the required information and methods to manipulate the dialog process.</p><p>If you take a look, you'll see that it has properties such as <code class="literal">Connection</code>, <code class="literal">Request</code>, <code class="literal">Response</code>, <code class="literal">Session</code>, <code class="literal">User</code>, among others and an <code class="literal">Abort</code> method to cancel the connection at any time.</p><p>Actually, the code calls the <code class="literal">Run</code> method asynchronously (with <code class="literal">async/await</code>), and it writes content that is addressed to the clients. Note that no HTML is implied here yet. If you run the project, you will see the <code class="literal">Hello World</code> text as expected every time a request to a port is made over localhost. (The IDE randomly assigns a different port for each application and you can change that, of course).</p><p>So, you can change the <code class="literal">Response</code> object, adding some more information to the initial response. A look at the <code class="literal">context</code> object shows several properties related to the process, such as the <code class="literal">Connection</code> object, which has a <code class="literal">Local Port</code> property whose value we can add to <code class="literal">Response</code> by just modifying the code in this way:</p><div class="informalexample"><pre class="programlisting">app.Run(async (context) =&gt;
{
  string localPort = context.Connection.LocalPort.ToString();
  await context.Response.WriteAsync("Hello World! - Local Port: " + localPort);
});</pre></div><p>However, we said we can change the hosting context. If we select the running host to be the name of our application instead of IIS Express, then we're opting for the self-hosting option, and two windows will open at runtime: a Console window (corresponding to the host) and the browser we select, sending a request over the application.</p><p>So, we should see one console with the data related to the hosting, as shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00715.jpeg" alt="Configuration and Startup settings"/></div><p style="clear:both; height: 1em;"> </p><p>Simultaneously, the <a id="id1265" class="indexterm"/>selected browser will open, showing the initial <a id="id1266" class="indexterm"/>message plus the modified information, including the port number:</p><div class="mediaobject"><img src="../Images/image00716.jpeg" alt="Configuration and Startup settings"/></div><p style="clear:both; height: 1em;"> </p><p>Note that although a look at the code seems to have some markup, this is included in the browsers because when they receive plain text, they wrap it around some basic markup instead of just presenting the text without any HTML. But we still didn't activate the option to serve static files.</p><p>Also, observe that there's no checking of resources; so, no matter what you put next to the <code class="literal">localhost:5000</code> address, you'll get the same result.</p><p>On the other hand, the host construction is made in the <code class="literal">Program.cs</code> file, where we find the entry point, which only creates a new host that calls the constructor of <code class="literal">WebHost Builder</code> and configures some default behavior:</p><div class="informalexample"><pre class="programlisting">public static void Main(string[] args)
{
  var host = new WebHostBuilder()
  .Use Kestrel()
  .Use ContentRoot(Directory.GetCurrentDirectory())
  .Use IIS Integration()
  .Use Startup&lt;Startup&gt;()
  .Build();
  host.Run();
}</pre></div><p>If you take a look at the <code class="literal">WebHost Builder</code> class (which follows the builder pattern), you'll see that it is<a id="id1267" class="indexterm"/> full of <code class="literal">Use*</code> like methods, which allow the programmer to configure this behavior:</p><div class="mediaobject"><img src="../Images/image00717.jpeg" alt="Configuration and Startup settings"/></div><p style="clear:both; height: 1em;"> </p><p>In the preceding example, the<a id="id1268" class="indexterm"/> Kestrel web server is used, but other web servers can be specified. The code also indicates that you use the current directory as the content root to integrate with IIS (that's why this is optional) and to use the <code class="literal">Startup</code> instance available in order to finish its configuration before actually building the server.</p><p>Once built, the server is launched, and that's the reason for the information we see in the console if we select self-hosting instead of IIS.</p></div><div class="section" title="Self-hosted applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec145"/>Self-hosted applications</h2></div></div></div><p>Self-hosted applications have a number of benefits, as we said: the application carries out anything it needs<a id="id1269" class="indexterm"/> to run. That is, there's no need to have .NET Core preinstalled, which makes this option pretty useful for constrained environments.</p><p>Operationally, it works like a normal native executable, and we can build it for any of the supported platforms. Future plans are to convert this executable into pure native executables depending on the platform to be used.</p><p>Before digging into MVC, if you want to serve a static file, you'll have to ensure that the <code class="literal">UseContentRoot</code> method has <a id="id1270" class="indexterm"/>been configured, and you have to add another piece of middleware indicating that. Just add the following to your <code class="literal">Configure</code> method and add some static content that you can invoke:</p><div class="informalexample"><pre class="programlisting">app.UseStaticFiles();</pre></div><p>In my case, I've created a very simple <code class="literal">index.html</code> file with a couple of HTML text tags and an <code class="literal">img</code> tag to make a dynamic call to the <code class="literal">http://lorempixel.com</code> site in order to serve an image file of size 200 x 100:</p><div class="informalexample"><pre class="programlisting">&lt;h2&gt;ASP.NET Core 1.0 Demo&lt;/h2&gt;
&lt;h4&gt;This content is static&lt;/h4&gt;
&lt;imgsrc="http://lorempixel.com/200/100"alt="Random Image"/&gt;</pre></div><p>If you leave this file in the <code class="literal">wwwroot</code> directory, you can now invoke the <code class="literal">http://localhost:&lt;port&gt;/index.html</code> address, and you should see the page just as well:</p><div class="mediaobject"><img src="../Images/image00718.jpeg" alt="Self-hosted applications"/></div><p style="clear:both; height: 1em;"> </p><p>Consequently, nothing prevents you from using ASP.NET Core technologies to build and deploy static sites or even sites that perform a functionality depending on the input without the need to use MVC, Web Pages, Web Forms, or other classic ASP.NET elements.</p><p>Once we understand the<a id="id1271" class="indexterm"/> basic structure of ASP.NET Core, it's time to look at a more complex project, (MVC type), similar to the typical initial solution that Microsoft used to include in previous templates, including controllers, views, use of Razor, and third-party resources, such as BootStrap and jQuery, among others.</p><p>But before we get into that, let me just indicate some surprising results obtained recently in benchmarks published by the ASP.NET Core development team: the performance gains using ASP.NET Core are meaningful.</p><p>The benchmark was made to compare classic ASP.NET 4.6, Node.js, ASP.NET Core (Weblist), ASP.NET Core on Mono, ASP.NET Core (CLR), ASP.NET Core (on Linux), and ASP.NET Core (Windows), resulting in the last case 1,150,000 requests per second in fine-grained requests (highly superior to Node.js). Refer to the following figure:</p><div class="mediaobject"><img src="../Images/image00719.jpeg" alt="Self-hosted applications"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="ASP.NET Core 1.0 MVC"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec146"/>ASP.NET Core 1.0 MVC</h2></div></div></div><p>If we opt for a complete<a id="id1272" class="indexterm"/> template when creating a new ASP.NET Core application, we'll find some meaningful changes and extended functionality.</p><p>I think it's interesting to compare both approaches in order to see exactly which elements are added or modified to permit these type of applications. First, pay attention to the new file structure.</p><p>Now, we recognize the typical elements that we already know from ASP.NET MVC applications: Controllers, Views, (no <code class="literal">Model</code> folder in this case because there's no need for it in the basic template), and another four folders with static resources pending from <code class="literal">wwwroot</code>.</p><p>They contain the recommended location folders for the CSS used in the application, static images, JavaScript <a id="id1273" class="indexterm"/>files (for instance, to access the new ECMA Script2015 APIs), plus versions 3.3.6 of Bootstrap, version 2.2 of jQuery, and version 1.14 of the jQuery Validation plugin (of course, the version number will vary with time).</p><p>These files are loaded into the project via <code class="literal">Bower</code>. Under the dependencies section, you'll find a <code class="literal">Bower</code> folder that you can use—even dynamically—to change versions, update to higher ones, and so on.</p><div class="note" title="Note"><h3 class="title"><a id="tip24"/>Tip</h3><p>If you right-click on any of the <code class="literal">Bower</code> entries, a contextual menu will offer to update the package, uninstall it, or manage other packages so that you can add new missing packages.</p></div><p>All this is under the <span class="strong"><strong>wwwroot</strong></span> section. But taking a look at the <span class="strong"><strong>Controllers</strong></span> and <span class="strong"><strong>Views</strong></span> folders, you'll discover a—somehow—familiar structure and content:</p><div class="mediaobject"><img src="../Images/image00720.jpeg" alt="ASP.NET Core 1.0 MVC"/></div><p style="clear:both; height: 1em;"> </p><p>Of course, if you execute the application, the main page launches, similar to the previous versions of ASP.NET MVC—only, the structure has changed. Let's see how, starting with a review of the <code class="literal">Startup.cs</code> and <code class="literal">Program.cs</code> files.</p><p>The first thing to <a id="id1274" class="indexterm"/>notice in the <code class="literal">Startup</code> content is that now, the class has a constructor. This constructor uses an object of type <code class="literal">IConfigurationRoot</code>, named <code class="literal">Configuration</code>, defined as public; so, whatever it contains is accessible all over the application.</p><p>As the documentation states:</p><div class="blockquote"><blockquote class="blockquote"><p>"Configuration is just a collection of sources, which provide the ability to read and write name/value pairs. If a name/value pair is written to Configuration, it is not persisted. This means that the written value will be lost when the sources are read again."</p></blockquote></div><p>For the project to work properly, you must configure at least one source. Actually, the current implementation does something else:</p><div class="informalexample"><pre class="programlisting">public Startup(IHostingEnvironmentenv)
{
  var builder = newConfigurationBuilder()
  .SetBasePath(env.ContentRootPath)
  .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
  .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true)
  .AddEnvironmentVariables();
  Configuration = builder.Build();
}</pre></div><p>The process goes in two phases. First, a <code class="literal">Configuration Builder</code> object is created and configured to read from distinct sources (JSON files). In this manner, when the runtime creates the <code class="literal">Startup</code> instance, all the required values are already read, as shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00721.jpeg" alt="ASP.NET Core 1.0 MVC"/></div><p style="clear:both; height: 1em;"> </p><p>The next<a id="id1275" class="indexterm"/> important change from the original demo is that MVC is an optional service that requires to be explicitly registered. This is done in the <code class="literal">ConfigureServices</code> method.</p><p>Finally, the runtime calls <code class="literal">Configure</code> in the <code class="literal">Startup</code> object. This time, we see that <code class="literal">Add Debug()</code>is called, and depending on the application's environment (development or production), distinct error pages are configured. (By the way, also note the call to <code class="literal">Add StaticFiles()</code>, which we added in the previous demo.)</p><p>The last step in this middleware configuration process is to configure routes. Those of you who are experienced and who already know ASP.NET MVC will easily recognize the similar code structure that we used in the classic version, although here, the default configuration has been simplified.</p><p>This also explains why <code class="literal">Configure Services</code> should be called prior to <code class="literal">Configure</code> because it's using the MVC service this latter call adds.</p><p>With all this, the application is ready to start; so, the runtime goes to the entry point (the <code class="literal">Main</code> method in <code class="literal">Program.cs</code>).</p><p>Another interesting behavior is shown here: the web host is built. And <code class="literal">WebHost Builder</code> is in <a id="id1276" class="indexterm"/>charge of it. Only when this builder is instantiated and configured does the process end, calling the <code class="literal">Build()</code>method. This method generates a working and tuned server, which is finally launched. A look at the code also tells us more about the structure:</p><div class="informalexample"><pre class="programlisting">public static void Main(string[] args)
{
  var host = new WebHostBuilder()
  .Use Kestrel()
  .Use ContentRoot(Directory.GetCurrentDirectory())
  .Use IISIntegration()
  .Use Startup&lt;Startup&gt;()
  .Build();

  host.Run();
}</pre></div><p>Note how the <code class="literal">UseStartup</code> method connects the main program with the previously defined <code class="literal">Startup</code> object.</p><p>Naturally, if you want to check the properties of the final, running server, a breakpoint in the <code class="literal">host.Run()</code>call will inform you about that in the <code class="literal">Services</code> and <code class="literal">Server Features </code>properties.</p><p>Of course, there is much more about the runtime and the classes it uses to configure and execute the server, which you'll find in the documentation, and that goes far beyond the scope of this introduction.</p><p>As for the rest of the code (the business logic), it's pretty similar to what we had in classic MVC, but we'll find many additions and modifications in order to make the architecture cross-platform, besides certain native support for common developer tools, such as Bower, NPM, Gulp, Grunt, and so on.</p><p>A look at the <code class="literal">HomeController</code> class shows basically the same structure, with the exception that now the action methods are defined as being of type <code class="literal">IActionResult</code> instead of <code class="literal">ActionResult</code>:</p><div class="informalexample"><pre class="programlisting">public IActionResult About()
{
  ViewData["Message"] = "Your application description page.";

  return View();
}</pre></div><p>So, we can add another action method by following exactly the same pattern. This happens to the <span class="strong"><strong>Models</strong></span> section (not present here). A model should be defined as a <span class="strong"><strong>POCO</strong></span> (<span class="strong"><strong>Plain Old CLR Object</strong></span>) class, with little<a id="id1277" class="indexterm"/> or no behavior. In this way, business logic is encapsulated and can be accessed wherever it's needed in the app.</p><p>Let's create a <code class="literal">Model</code> and an <code class="literal">Action</code> method and its corresponding view so that we can see how similar it is with respect to the previous version.</p><p>We'll create a<a id="id1278" class="indexterm"/> new <code class="literal">Model</code> folder, and inside it, we'll add a class named <code class="literal">PACKTAddress</code>, where we'll define a few properties:</p><div class="informalexample"><pre class="programlisting">public classPACKTAddress
{
  public string Company { get; set; }
  public string Street { get; set; }
  public string City { get; set; }
  public string Country { get; set; }
}</pre></div><p>Once compiled, we can create a new action method inside <code class="literal">HomeController</code>. We need to create an instance of the <code class="literal">PACKTAddress</code> class, fill its properties with the required information, and pass it to the corresponding view, which will receive and present the data:</p><div class="informalexample"><pre class="programlisting">public IActionResult PACKTContact()
{
  ViewData["Message"] = "PACKT Company Data";

  var viewModel = new Models.PACKTAddress()
  {
    Company = "Packt Publishing Limited",
    Street = "2nd Floor, Livery Place, 35 Livery Street",
    City = "Birmingham",
    Country = "UK"
  };
  return View(viewModel);
}</pre></div><p>With this, the business logic for our new view is almost ready. The next step is to add a new view file of the same name as the action method, that will sit next to its siblings in the <code class="literal">Views/Home</code> folder.</p><p>In the view, we need to add a reference to the model we just passed and later use Tag Helpers in order to recover the data, presenting its results in the page.</p><p>This is quite easy and straightforward:</p><div class="informalexample"><pre class="programlisting">@model WebApplication1.Models.PACKTAddress
&lt;h2&gt;PACKT Publishing office information&lt;/h2&gt;
&lt;address&gt;
  @Model.Company&lt;br/&gt;
  @Model.Street&lt;br/&gt;
  @Model.City, @Model.Country &lt;br/&gt;
  &lt;abbrtitle="Phone"&gt;P:&lt;/abbr&gt;
  0121 265 6484
&lt;/address&gt;</pre></div><p>A few things should be noticed when building this view. First, we have plain Intellisense in the view's editor, just like we did with the classic MVC. This is important so that we can always make sure that the context recognizes value models appropriately.</p><p>Thus, if we have <a id="id1279" class="indexterm"/>compiled the code and everything is correct, we should see these helping features as we proceed with the creation of the view:</p><div class="mediaobject"><img src="../Images/image00722.jpeg" alt="ASP.NET Core 1.0 MVC"/></div><p style="clear:both; height: 1em;"> </p><p>Finally, we have to integrate our new view with the main page (<code class="literal">_Layout.cshtml</code>) by including a new menu entry to point to the view in the same way as the previous entries. So, the modified menu will be as follows:</p><div class="informalexample"><pre class="programlisting">&lt;ulclass="nav navbar-nav"&gt;
  &lt;li&gt;&lt;aasp-controller="Home"asp-action="Index"&gt;Home&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;aasp-controller="Home"asp-action="About"&gt;About&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;aasp-controller="Home"asp-action="Contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;aasp-controller="Home"asp-action="PACKTContact"&gt;PACKT Information&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>Here, you'll notice the presence of new customized attributes related to ASP.NET: <code class="literal">asp-controller</code>, <code class="literal">asp-action</code>, and so on. This is similar to the way we work with controllers when building AngularJS applications.</p><p>Also, note that we pass some extra information using the <code class="literal">ViewData</code> object, which has been recovered for preferable use instead of the previous <code class="literal">ViewBag</code> object.</p><p>Finally, I've added <a id="id1280" class="indexterm"/>a link to this book's cover in a standard image (no problems or configuration features for that). When we launch the application, a new menu element will appear, and if we go to that link, we should see the new page inside the main application page, just like we expected:</p><div class="mediaobject"><img src="../Images/image00723.jpeg" alt="ASP.NET Core 1.0 MVC"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Managing scripts"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec147"/>Managing scripts</h2></div></div></div><p>As you've probably seen after a review of the folder's contents, there are more <code class="literal">.json</code> files related to configuration options. Actually, in this project, we see several files, each one in charge of <a id="id1281" class="indexterm"/>some part of the configuration. Their purpose is the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">launch Settings.json</code>: It is located under <code class="literal">Properties</code>. It configures ports, browsers, basic URLs, and <a id="id1282" class="indexterm"/>environment variables.</li><li class="listitem"><code class="literal">app Settings.json</code>: It is located at<a id="id1283" class="indexterm"/> root level, and not wwwroot. It defines logging values and is also the place to locate other application-related data, such as connection strings.</li><li class="listitem"><code class="literal">bower.json</code>: It is located at<a id="id1284" class="indexterm"/> root level, and not wwwroot). It defines which external components have to be updated in the application, utilizing Bower services: Bootstrap, jQuery, and so on.</li><li class="listitem"><code class="literal">bundle Config.json</code>: It is located<a id="id1285" class="indexterm"/> at root level, and not wwwroot. This is where you define which files are to be bundled and minified, indicating the original and final filenames in each case.</li></ul></div><p>So, we've seen how the programming model has been improved, and there's much more to deal with in relation to the new Tag Helpers, other improvements in the modeling, data access, and so many other features that we cannot cover here, but I hope this has served as an introduction to the new architecture.</p></div></div>
<div class="section" title="NET Core 1.1" id="aid-2LQIK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec84"/>NET Core 1.1</h1></div></div></div><p>A few days before closing this book's editing process, Microsoft announced in the Connect() event the <a id="id1286" class="indexterm"/>availability of this new version of .NET Core. This update also<a id="id1287" class="indexterm"/> affects the related versions of the "Core" family: ASP.NET Core 1.1 and EF Core 1.1.</p><p>Obviously, it's not a version with many foundational changes, nor breaking changes, either. The focus of the development team was to broaden the OS targets, improve performance, and fix bugs, fundamentally.</p><p>Thus, and according to the official page in Github (<a class="ulink" href="https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.md">https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.md</a>) and the team's blog, the changes are mainly located around four different areas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Support for the following distributions:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Red Hat Enterprise Linux 7.2</li><li class="listitem">CentOS 7.1+</li><li class="listitem">Debian 8.2+</li><li class="listitem">Fedora 23, 24*</li><li class="listitem"> Linux Mint 17.1, 18*</li><li class="listitem">Oracle Linux 7.1</li><li class="listitem">Ubuntu 14.04 &amp; 16.04</li><li class="listitem">Mac OS X 10.11, and 10.12</li><li class="listitem">Windows 7+ / Server 2012 R2+</li><li class="listitem">Windows Nano Server TP5 Linux Mint 18</li><li class="listitem">OpenSUSE 42.1</li><li class="listitem">MacOS 10.12 (also added to .NET Core 1.0)</li><li class="listitem">Windows Server 2016 (also added to .NET Core 1.0)</li></ul></div></li><li class="listitem">Performance<a id="id1288" class="indexterm"/> improvements, which had led to surpass the benchmarks obtained by Node and Nginx (reaching in ASP.NET Core 1,15 million requests/second)</li><li class="listitem">Several new features added to the API's and hundreds of bug fixes</li><li class="listitem">A serious update to the documentation, now, more accessible and comprehensive</li></ul></div><p>As for ASP.NET Core 1.1, the documentation states that this release was designed around the following feature themes in order to help developers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Improved and <a id="id1289" class="indexterm"/>cross-platform compatible site hosting capabilities when using a host other than Windows Internet Information Server (IIS)</li><li class="listitem">Support for developing with native Windows capabilities</li><li class="listitem">Compatibility, portability and performance of middleware and other MVC features throughout the UI framework</li><li class="listitem">Improved deployment and management experience of ASP.NET Core applications on Microsoft Azure</li></ul></div><p>For additional details on<a id="id1290" class="indexterm"/> the news offered by this version, you can read the article <span class="emphasis"><em>Announcing the Fastest ASP.NET Yet, ASP.NET Core 1.1 RTM</em></span>, at <a class="ulink" href="https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/">https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/</a>.</p></div>
<div class="section" title="Summary" id="aid-2MP361"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec85"/>Summary</h1></div></div></div><p>In this final chapter, we saw three not-well-known aspects for distinct reasons, and that included a brief introduction to the new .NET Core and ASP.NET Core proposals that Microsoft presented officially this year.</p><p>This is the last chapter of this book in which I've reviewed the state of .NET Programming using (mainly, but not exclusively), the C# language.</p><p>We made a historic tour of the language in its different versions, including the latest stable, C# 7, and we've seen with a bunch of examples the way it behaves and how we can use it in distinct contexts and application scenarios.</p><p>We've also compared languages taking a sneak peek at other proposals, like the functional language F# and the popular TypeScript.</p><p>Data management has been another important topic, covering the two most popular models today (SQL and NoSQL), sampling how to use both, their advantages and caveats.</p><p>Finally, we've dedicated several chapters to traversal techniques which imply the whole application, like architecture, good practices, security and performance, to end with this miscellaneous chapter.</p><p>I, sincerely, expect this text serves you as a reference on the many possibilities that a .NET programmer has today, and, possibly opens new paths and channels of development for your needs.</p></div></body></html>