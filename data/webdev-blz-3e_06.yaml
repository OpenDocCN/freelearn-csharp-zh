- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building Forms with Validation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验证构建表单
- en: In this chapter, we will learn about creating forms and validating them, which
    is an excellent opportunity to build our admin interface, where we can manage
    our blog posts and also take a look at the new enhanced form navigation. We will
    also build multiple reusable components and learn about some of the new functionalities
    in Blazor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习创建和验证表单，这是一个构建我们的管理界面的绝佳机会，我们可以管理我们的博客文章，并查看新的增强表单导航。我们还将构建多个可重用组件，并了解
    Blazor 中的一些新功能。
- en: This chapter will be super fun, and we will use a lot of the things we have
    learned up until now.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将非常有趣，我们将使用到目前为止所学的许多东西。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring form elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索表单元素
- en: Adding validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加验证
- en: Custom validation class attributes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义验证类属性
- en: Looking at bindings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看绑定
- en: Building an admin interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建管理界面
- en: Adding an abstraction layer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加抽象层
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have followed the previous chapters or use the `Chapter05` folder
    as a starting point.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经遵循了前面的章节，或者以 `Chapter05` 文件夹作为起点。
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06)找到本章结果的源代码。
- en: Exploring form elements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索表单元素
- en: There are many form elements in HTML, and we can use them all in Blazor. In
    the end, what Blazor outputs is HTML.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 中有许多表单元素，我们可以在 Blazor 中使用它们。最终，Blazor 输出的是 HTML。
- en: Blazor does have components that will add to the functionality, so we can and
    should try to use those components instead of HTML elements. The built-in components
    give us great functionality for free.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 确实有一些组件可以增加功能，因此我们可以也应该尝试使用这些组件而不是 HTML 元素。内置组件为我们提供了免费的功能。
- en: 'Blazor offers the following components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 提供以下组件：
- en: '`EditForm`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditForm`'
- en: '`InputBase<>`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputBase<>`'
- en: '`InputCheckbox`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputCheckbox`'
- en: '`InputDate<TValue>`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputDate<TValue>`'
- en: '`InputNumber<TValue>`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputNumber<TValue>`'
- en: '`InputSelect<TValue>`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputSelect<TValue>`'
- en: '`InputText`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputText`'
- en: '`InputTextArea`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputTextArea`'
- en: '`InputRadio`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputRadio`'
- en: '`InputRadioGroup`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputRadioGroup`'
- en: '`ValidationMessage`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidationMessage`'
- en: '`ValidationSummary`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidationSummary`'
- en: Let’s go through them all in the next sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中逐一介绍它们。
- en: EditForm
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditForm
- en: '`EditForm` renders as a `form` tag, but it has a lot more functionalities.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm` 以 `form` 标签的形式渲染，但它具有更多功能。'
- en: First, we will not create an action or method like traditional `form` tags;
    Blazor will handle all of that.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不会像传统的 `form` 标签那样创建操作或方法；Blazor 将处理所有这些。
- en: '`EditForm` will create an `EditContext` instance as a cascading value so that
    all the components you put inside of `EditForm` will access the same `EditContext`.
    `EditContext` tracks the metadata regarding the editing process, such as what
    fields have been edited, and keeps track of any validation messages.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm` 将创建一个 `EditContext` 实例作为级联值，以便所有放入 `EditForm` 中的组件都可以访问相同的 `EditContext`。`EditContext`
    跟踪有关编辑过程的相关元数据，例如哪些字段已被编辑，并跟踪任何验证消息。'
- en: You need to assign either a model (a class you wish to edit) or an `EditContext`
    instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要分配一个模型（您希望编辑的类）或一个 `EditContext` 实例。
- en: For most use cases, assigning a model is the way to go, but for more advanced
    scenarios, you might want to be able to trigger `EditContext.Validate()`, for
    example, to validate all the controls connected to `EditContext`. This is very
    rarely done, but it might be good to know it is possible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用例，分配模型是最佳选择，但对于更高级的场景，您可能希望能够触发 `EditContext.Validate()`，例如，验证与 `EditContext`
    连接的所有控件。这种情况很少发生，但了解它是可能的可能是个好主意。
- en: '`EditForm` has the following events that you can use to handle form submissions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm` 具有以下事件，您可以使用它们来处理表单提交：'
- en: '`OnValidSubmit` gets triggered when the data in the form validates correctly
    (we will come back to validation in just a bit).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnValidSubmit` 在表单中的数据验证正确时被触发（我们将在稍后回到验证）。'
- en: '`OnInvalidSubmit` gets triggered if the form does not validate correctly.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInvalidSubmit` 如果表单没有正确验证，则被触发。'
- en: '`OnSubmit` gets triggered when the form is submitted, regardless of whether
    the form validates correctly or not. Use `OnSubmit` if you want to control the
    validation yourself.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnSubmit`在表单提交时被触发，无论表单是否正确验证。如果你想要自己控制验证，请使用`OnSubmit`。'
- en: Let’s take a look at an example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。
- en: 'Consider a class that holds a person; the class has a name and an age for that
    person and looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含一个人的类的例子；这个类有一个人的名字和年龄，看起来像这样：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`EditForm` for this class would look like this (without any other elements
    for now):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的`EditForm`看起来像这样（目前没有其他元素）：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`EditForm` specifies a model (in this case, `personmodel`), and we are listening
    to the `OnValidSubmit` event.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm`指定了一个模型（在这种情况下，`personmodel`），我们正在监听`OnValidSubmit`事件。'
- en: The `Submit` button is a regular HTML button that is not a specific Blazor component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Submit`按钮是一个普通的HTML按钮，不是一个特定的Blazor组件。'
- en: InputBase<>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputBase<>`'
- en: All the Blazor input classes derive from the `InputBase` class. It has a bunch
    of things we can use for all of the `input` components; we will go through the
    most important ones.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Blazor输入类都从`InputBase`类派生。它有一系列我们可以用于所有`input`组件的东西；我们将介绍其中最重要的。
- en: '`InputBase` handles `AdditionalAttributes`, which means that if we add any
    other attributes to the tag, they will automatically get transferred to the output.
    This means that the components derived from this class can leverage any HTML attributes
    since they will be part of the output.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputBase`处理`AdditionalAttributes`，这意味着如果我们向标签添加任何其他属性，它们将自动转移到输出中。这意味着从该类派生的组件可以利用任何HTML属性，因为它们将是输出的一部分。'
- en: '`InputBase` has properties for `Value`, which we can bind to, and an event
    callback for when the value changes called `ValueChanged`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputBase`有`Value`属性，我们可以将其绑定，还有一个当值改变时被调用为`ValueChanged`的事件回调。'
- en: We can also change `DisplayName` so that the automated validation messages will
    reflect the correct name and not the property’s name, which is the default behavior.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更改`DisplayName`，以便自动验证消息将反映正确的名称，而不是属性的名称，这是默认行为。
- en: Not all controls support the `DisplayName` property. Some properties are only
    used inside the component, and we will return to those in a bit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有控件都支持`DisplayName`属性。一些属性仅用于组件内部，我们将在稍后回到这些属性。
- en: InputCheckbox
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputCheckbox`'
- en: The `InputCheckbox` component will render as `<input type="checkbox">`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputCheckbox`组件将渲染为`<input type="checkbox">`。'
- en: InputDate<TValue>
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputDate<TValue>`'
- en: The `InputDate` component will render as `<input type="date">`. We can use `DateTime,
    DateOnly, TimeOnly,` and `DateTimeOffset` as values for the `InputDate` component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputDate`组件将渲染为`<input type="date">`。我们可以使用`DateTime`、`DateOnly`、`TimeOnly`和`DateTimeOffset`作为`InputDate`组件的值。'
- en: There is no way to format the date; it will use the web browser’s current setting.
    This behavior is by design and is part of the HTML5 spec.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 没有方法可以格式化日期；它将使用网络浏览器的当前设置。这种行为是按设计进行的，也是HTML5规范的一部分。
- en: InputNumber<TValue>
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputNumber<TValue>`'
- en: The `InputNumber` component will render as `<input type="number">`. We can use
    `Int32`, `Int64`, `Single`, `Double`, and `Decimal` as values for the `InputNumber`
    component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputNumber`组件将渲染为`<input type="number">`。我们可以使用`Int32`、`Int64`、`Single`、`Double`和`Decimal`作为`InputNumber`组件的值。'
- en: InputSelect<TValue>
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputSelect<TValue>`'
- en: The `InputSelect` component will render as `<select>`. We will create `InputSelect`
    later in this chapter, so I won’t go into further detail here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputSelect`组件将渲染为`<select>`。我们将在本章的后面创建`InputSelect`，所以在这里我不会进一步详细介绍。'
- en: InputText
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputText`'
- en: The `InputText` component will render as `<input type="text">`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputText`组件将渲染为`<input type="text">`。'
- en: InputTextArea
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputTextArea`'
- en: The `InputSelect` component will render as `<textarea>`. In this chapter, we
    will build our own version of this control.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputSelect`组件将渲染为`<textarea>`。在本章中，我们将构建这个控件的自定义版本。'
- en: InputRadio
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputRadio`'
- en: The `InputRadio` component will render as `<input type="radio">`. Use this for
    individual options.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputRadio`组件将渲染为`<input type="radio">`。用于单个选项。'
- en: InputRadioGroup
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputRadioGroup`'
- en: The `InputRadioGroup` component is not an element itself but rather groups other
    `InputRadioInputs`. Use this to group options. We can add multiple `InputRadio`
    components inside of the `InputRadioGroup`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputRadioGroup`组件本身不是一个元素，而是将其他`InputRadioInputs`分组。用于分组选项。我们可以在`InputRadioGroup`内部添加多个`InputRadio`组件。'
- en: InputFile
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputFile`'
- en: The `InputFile` component will render as `<Input type="file">`. This component
    will make it easier to get the file data. It will supply us with a stream for
    each file’s content.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputFile`组件将渲染为`<Input type="file">`。此组件将使获取文件数据变得更容易。它将为每个文件的内容提供一个流。'
- en: 'We can dive into `InputFile` further by checking out the documentation here:
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看以下文档进一步了解`InputFile`：[https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0)。
- en: As we can see, there is a Blazor component for almost all the HTML form controls,
    with some added functionality such as validation, which we will see in the next
    section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，几乎所有HTML表单控件都有一个Blazor组件，其中包含一些附加功能，例如验证，我们将在下一节中看到。
- en: Adding validation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加验证
- en: We have already touched on validation; there are some built-in functionalities
    in the `input` components and `EditForm` to handle validation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及了验证；`input`组件和`EditForm`中有些内置的功能可以处理验证。
- en: One way to add validation to our form is to use `DataAnnotations`. Using DataAnnotations,
    we don’t have to write any custom logic to ensure the data in the form is correct;
    instead, we can add attributes to the data model and let `DataAnnotationsValidator`
    take care of the rest.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的表单添加验证的一种方法是通过使用`DataAnnotations`。使用DataAnnotations，我们不需要编写任何自定义逻辑来确保表单中的数据正确；相反，我们可以在数据模型中添加属性，并让`DataAnnotationsValidator`处理其余部分。
- en: There are a bunch of `DataAnnotations` instances in .NET already that we can
    use; we can also build our own annotations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中已经存在许多我们可以使用的`DataAnnotations`实例；我们也可以构建自己的注释。
- en: 'Some of the built-in data annotations are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置的数据注释如下：
- en: '`Required`: This makes the field required.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Required`：这使得字段成为必填项。'
- en: '`Email`: This will check that the entered value is an email address.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Email`：这将检查输入的值是否为电子邮件地址。'
- en: '`MinLength`: This will check that the number of characters is not fewer than
    the value specified.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinLength`：这将检查字符数是否不少于指定值。'
- en: '`MaxLength`: This will check that the number of characters is not exceeded.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxLength`：这将检查字符数是否不超过指定值。'
- en: '`Range`: This will check that the value is within a specific range.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range`：这将检查值是否在特定范围内。'
- en: 'There are many more annotations that can help us validate our data. To test
    this out, let’s add data annotations to our data classes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他注释可以帮助我们验证数据。为了测试这一点，让我们在我们的数据类中添加数据注释：
- en: In the `Data.Models` project, open `Models/BlogPost.cs`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Data.Models`项目中，打开`Models/BlogPost.cs`文件。
- en: 'At the top of the file, add a `using` statement for System.ComponentModel.DataAnnotations:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加一个`using`语句用于`System.ComponentModel.DataAnnotations`：
- en: '[PRE2]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `Required` and `MinLength` attributes to the `Title` property:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Required`和`MinLength`属性添加到`Title`属性：
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Required` attribute will ensure we can’t leave the title empty, and `MinLength`
    will make sure it has at least `5` characters.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Required`属性将确保标题不能为空，而`MinLength`将确保它至少有`5`个字符。'
- en: 'Add the `Required` attribute to the `Text` property:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Required`属性添加到`Text`属性：
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Required` attribute will ensure the `Text` property cannot be empty, which
    makes sense – why would we create an empty blog post?
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Required`属性将确保`Text`属性不能为空，这是有意义的——我们为什么要创建一个空的博客文章？'
- en: Open `Models/Category.cs`, and at the top of the file, add a `using` statement
    for `System.ComponentModel.DataAnnotations`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Models/Category.cs`文件，并在文件顶部添加一个`using`语句用于`System.ComponentModel.DataAnnotations`。
- en: 'Add the `Required` attribute to the `Name` property:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Required`属性添加到`Name`属性：
- en: '[PRE5]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Required` attribute will make sure we can’t leave the name empty.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Required`属性将确保我们无法留空名称。'
- en: Open `Models/Tag.cs`, and at the top of the file, add a `using` statement for
    `System.ComponentModel.DataAnnotations`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Models/Tag.cs`文件，并在文件顶部添加一个`using`语句用于`System.ComponentModel.DataAnnotations`。
- en: 'Add the `Required` attribute to the `Name` property:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Required`属性添加到`Name`属性：
- en: '[PRE6]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Required` attribute will make sure we can’t leave the name empty.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Required`属性将确保我们无法留空名称。'
- en: Open `Models/Comment.cs`, and at the top of the file, add a `using` statement
    for `System.ComponentModel.DataAnnotations`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Models/Comment.cs`文件，并在文件顶部添加一个`using`语句用于`System.ComponentModel.DataAnnotations`。
- en: 'Add the `Required` attribute to the `Name` and `Text` properties:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Required`属性添加到`Name`和`Text`属性：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Great, now our data models have validation built into them. We need to give
    our users feedback on what went wrong with the validation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们的数据模型已经内置了验证。我们需要向我们的用户提供有关验证错误的反馈。
- en: We can do that by using the `ValidationMessage` or `ValidationSummary` components.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`ValidationMessage`或`ValidationSummary`组件来实现这一点。
- en: ValidationMessage
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ValidationMessage`'
- en: The `ValidationMessage` component can show us individual error messages for
    a specific property. We want to use this component to show validation errors under
    a form element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationMessage`组件可以显示特定属性的个别错误消息。我们希望使用此组件在表单元素下显示验证错误。'
- en: 'To add a `ValidationMessage` component, we have to specify the `For` property
    with the name of the property we want to show the validation errors for:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加`ValidationMessage`组件，我们必须指定`For`属性，并给出我们想要显示验证错误的属性的名称：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ValidationSummary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ValidationSummary
- en: 'The `ValidationSummary` component will show all the validation errors as a
    list for the entire `EditContext`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationSummary`组件将显示整个`EditContext`的所有验证错误列表：'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We don’t need to supply any model or property to the `ValidationSummary` component
    since it gets access to the `EditContext` using the cascading value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ValidationSummary`组件通过级联值访问`EditContext`，我们不需要向其提供任何模型或属性。
- en: I prefer to show the error close to the problem so the user can see where the
    issue is. However, we also have the option to show the validation errors as a
    list using `ValidationSummary`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢将错误显示在问题附近，这样用户就可以看到问题所在。然而，我们也有选项使用`ValidationSummary`将验证错误显示为列表。
- en: To ensure our input controls match the Bootstrap theme (or whatever theme we
    might use), we can create our **custom validation class**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的输入控件与Bootstrap主题（或我们可能使用的任何主题）相匹配，我们可以创建我们的**自定义验证类**。
- en: Custom validation class attributes
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证类属性
- en: By simply using the edit form, input components, and `DataAnnotationValidator`,
    the framework will automatically add classes to the components when it is and
    isn’t valid.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地使用编辑表单、输入组件和`DataAnnotationValidator`，框架将在组件有效或无效时自动向其添加类。
- en: By default, these classes are `.valid` and `.invalid`. In .NET 5, we were given
    a way to customize these class names ourselves.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些类是`.valid`和`.invalid`。在.NET 5中，我们被赋予了自定义这些类名的途径。
- en: When using Bootstrap, the default class names are `.is-valid` and `.is-invalid`
    , and the list of class names must also include `.form-control` to get the proper
    styles.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Bootstrap时，默认的类名是`.is-valid`和`.is-invalid`，类名列表还必须包括`.form-control`以获取适当的样式。
- en: The next component we build will help us get the proper Bootstrap styling on
    all our form components.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来构建的下一个组件将帮助我们为所有表单组件获取适当的Bootstrap样式。
- en: 'We will create our own `FieldCssClassProvider` to customize what classes Blazor
    will use:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的`FieldCssClassProvider`来自定义Blazor将使用的类。
- en: In the `SharedComponents` project, inside the `ResuableComponents` folder, add
    a new class called `BootstrapFieldCssClassProvider.cs`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，在`ResuableComponents`文件夹中，添加一个名为`BootstrapFieldCssClassProvider.cs`的新类。
- en: 'Open the new class and add the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新类并添加以下代码：
- en: '[PRE10]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`BootstrapFieldCssClassProvider` needs an `EditContext` instance to work.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BootstrapFieldCssClassProvider`需要一个`EditContext`实例来工作。'
- en: The code will check whether the form (or `EditContext` to be specific) is valid
    and whether or not it has been modified. Based on that, it returns the correct
    CSS classes.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码将检查表单（或具体为`EditContext`）是否有效以及是否已被修改。基于此，它将返回正确的CSS类。
- en: It returns the form control for all elements; that way, we don’t have to add
    it to every element in the form. We could validate an untouched form as valid
    or invalid, but we don’t want it to show that the form is OK just because it hasn’t
    been changed yet.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它为所有元素返回表单控件；这样，我们就不必在表单中的每个元素上添加它。我们可以验证未修改的表单为有效或无效，但我们不希望它仅仅因为尚未更改就显示表单是好的。
- en: 'Without the code we are about to build, we need to get the `EditContext` instance
    from our `EditForm` and then set `FieldCssClassProvider` on `EditContext` as follows:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们即将构建的代码之外，我们需要从我们的`EditForm`中获取`EditContext`实例，然后在`EditContext`上设置`FieldCssClassProvider`，如下所示：
- en: '`CurrentEditContext.SetFieldCssClassProvider(provider);`'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CurrentEditContext.SetFieldCssClassProvider(provider);`'
- en: Next, we will do that more elegantly (in my humble opinion) with the `CustomCssClassProvider`
    we will create next.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们即将创建的`CustomCssClassProvider`以更优雅的方式（以我谦卑的观点）来完成这项工作。
- en: Earlier in this chapter, I mentioned that `EditForm` exposes its `EditContext`
    as `CascadingValue`.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我提到`EditForm`将其`EditContext`作为`CascadingValue`公开。
- en: That means we will build a component that we can just put inside of our `EditForm`
    and access `EditContext` that way.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们将构建一个可以放入我们的`EditForm`中并以此方式访问`EditContext`的组件。
- en: In the `SharedComponents` project, in the root of the project, add a new class
    and name it `CustomCssClassProvider.cs`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，在项目根目录下，添加一个新类，并将其命名为`CustomCssClassProvider.cs`。
- en: 'Open the new file and replace the content with the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新文件，并用以下代码替换内容：
- en: '[PRE11]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This generic component takes a `type` value, in this case, the type of `Provider`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个泛型组件接受一个`type`值，在这种情况下，是`Provider`的类型。
- en: We specified that `type` must inherit from `FieldCssClassProvider` and must
    have a constructor without parameters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`type`必须继承自`FieldCssClassProvider`并且必须有一个无参数的构造函数。
- en: The component inherits from `ComponentBase`, which makes it possible to place
    the component inside a Blazor component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件继承自`ComponentBase`，这使得我们可以在Blazor组件内部放置该组件。
- en: In this case, we are writing our component with C# only, but it is not rendering
    anything.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只用C#编写我们的组件，但它并没有渲染任何内容。
- en: We have a `Cascading` parameter that will be populated from `EditForm`. We throw
    an exception if `EditContext` is missing for some reason (for example, if we place
    the component outside of `EditForm`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Cascading`参数，它将从`EditForm`中填充。如果由于某种原因（例如，如果我们将组件放置在`EditForm`之外）缺少`EditContext`，我们将抛出一个异常。
- en: Finally, we set `FieldCssClassProvider` on `EditContext`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`EditContext`上设置`FieldCssClassProvider`。
- en: 'To use the component, we have to add the following code inside of `EditForm`
    (don’t worry, we will create an `EditForm` soon):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该组件，我们必须在`EditForm`内部添加以下代码（别担心，我们很快就会创建一个`EditForm`）：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We provide our `CustomCssClassProvider` component with the right `ProviderType`:
    `BootstrapFieldCssClassProvider`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的`CustomCssClassProvider`组件提供正确的`ProviderType`：`BootstrapFieldCssClassProvider`。
- en: 'This is one way of implementing components to help us encapsulate functionality.
    We could have written the code this way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种实现组件以帮助我们封装功能的方法。我们也可以这样编写代码：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But with the new `CustomCssClassProvider` component, we can write the same
    thing like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但有了新的`CustomCssClassProvider`组件，我们可以这样编写相同的内容：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we are doing something with `EditContext`, we can always create a component
    like this since it is a `cascading` parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在做与`EditContext`相关的事情，我们可以始终创建一个像这样的组件，因为它是一个`cascading`参数。
- en: Now, we have a component that will make our form controls look like Bootstrap
    controls and instead of adding specific code to every component, we can now add
    the `CustomCssClassProvider` component. Next, it’s time to put that into practice
    and create a couple of forms by building our admin interface.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个组件，可以使我们的表单控件看起来像Bootstrap控件，而且我们不再需要为每个组件添加特定的代码，现在我们可以添加`CustomCssClassProvider`组件。接下来，是时候将其付诸实践，通过构建我们的管理界面来创建几个表单。
- en: Looking at bindings
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看绑定
- en: In this chapter, we are using bindings to bind data to our form controls. We
    briefly discussed bindings in *Chapter 5*, *Creating Advanced Blazor Components*,
    but it’s time to dig deeper into bindings.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用绑定将数据绑定到我们的表单控件上。我们在*第5章*，*创建高级Blazor组件*中简要讨论了绑定，但现在是我们深入探讨绑定的时候了。
- en: Binding to HTML elements
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定到HTML元素
- en: With HTML elements, we can use `@bind` to bind variables to the element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTML元素，我们可以使用`@bind`将变量绑定到元素上。
- en: 'So, if we are binding to a textbox, we would do it like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们正在绑定到一个文本框，我们会这样做：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`@bind` and `@bind-value` both work and do the same thing. Note the lower `v`
    in value. The input element is an HTML element that will render as a normal HTML
    element with no extra features (except binding). Compare this to `InputText`,
    which will work in a similar way but also give you additional features like validation
    and styles.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`@bind`和`@bind-value`都起作用，并且做同样的事情。注意`value`中的小写`v`。输入元素是一个HTML元素，它将以一个普通的HTML元素渲染，没有额外的功能（除了绑定）。将其与`InputText`进行比较，它将以类似的方式工作，但也会提供额外的功能，如验证和样式。'
- en: 'By default, the value in the variable will change when we leave the textbox.
    But we can change that behavior by adding a `@bind:event` attribute like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当离开文本框时，变量中的值会发生变化。但我们可以通过添加一个`@bind:event`属性来改变这种行为，如下所示：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can even take full control over what is happening by using the `@bind:get`
    and `@bind:set` attributes like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用像`@bind:get`和`@bind:set`这样的属性来完全控制正在发生的事情：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These are doing the same thing as `@bind`, so we can’t use them together with
    `@bind`. The `@bind:set` attribute has another nice feature. We can run asynchronous
    methods when we set a value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作与 `@bind` 做的是同一件事情，所以我们不能与 `@bind` 同时使用。`@bind:set` 属性还有一个很好的特性。当我们设置一个值时，我们可以运行异步方法。
- en: 'There is also a way for us to run a method after the value is set by using
    `@bind:after` like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置值之后，我们可以使用 `@bind:after` 来运行一个方法，如下所示：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This gives us great flexibility when it comes to binding to HTML elements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这在绑定到 HTML 元素时提供了很大的灵活性。
- en: 'On top of that, we can also set the culture using `@bind:culture`. Both date
    and number fields use invariant culture and will use the appropriate browser formatting,
    but if we use a text field, we can change the behavior like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用 `@bind:culture` 来设置文化。日期和数字字段使用不变的文化，并将使用适当的浏览器格式化，但如果使用文本字段，我们可以像这样更改行为：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Where `GBCulture`, in this case, is a `CultureInfo` object. Lastly, we can
    set the format using `@bind:format`. This is only implemented for `DateTime` at
    this point:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `GBCulture` 在这个例子中是一个 `CultureInfo` 对象。最后，我们可以使用 `@bind:format` 来设置格式。目前这仅适用于
    `DateTime`：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now know how we can bind to HTML elements. Next, we will take a look at binding
    to components.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经知道如何绑定到 HTML 元素。接下来，我们将看看如何绑定到组件。
- en: Binding to components
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定到组件
- en: When binding to components, `Get`, `Set`, and `After` will also work. `Culture`,
    `Event`, and `Format` will work on some components.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到组件时，`Get`、`Set` 和 `After` 也会起作用。`Culture`、`Event` 和 `Format` 在某些组件上也会起作用。
- en: 'When binding to a component, we use `@bind-{ParameterName}`, so for the parameter
    `Value`, it would look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到组件时，我们使用 `@bind-{ParameterName}`，所以对于 `Value` 参数，它看起来是这样的：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the background, `@bind-Value` will affect two other parameters, `ValueExpression`
    and `ValueChanged`. This means you will not be able to set them manually if you
    use `@bind-Value`. When we change the value, `ValueChanged` will get triggered,
    and we can listen to the event and make things happen when it changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，`@bind-Value` 将影响另外两个参数，`ValueExpression` 和 `ValueChanged`。这意味着如果你使用 `@bind-Value`，将无法手动设置它们。当我们更改值时，`ValueChanged`
    将被触发，我们可以监听这个事件，并在它改变时执行某些操作。
- en: 'We can also use `Get` and `Set` like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像这样使用 `Get` 和 `Set`：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We must always supply both `Get` and `Set` and they cannot be combined with
    `@bind-Value`. These samples use `InputText`, a built-in Blazor component, but
    this concept works with any parameter on any component. The same thing goes for
    `After`. It can be used with any component, like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终提供 `Get` 和 `Set`，并且它们不能与 `@bind-Value` 结合使用。这些示例使用 `InputText`，这是一个内置的
    Blazor 组件，但这个概念适用于任何组件上的任何参数。对于 `After` 也是如此。它可以与任何组件一起使用，如下所示：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have access to some nice binding features, and they work when binding to
    components as well as HTML elements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问一些很好的绑定功能，并且它们在绑定到组件以及 HTML 元素时都有效。
- en: Next, we will build an admin interface using bindings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用绑定来构建一个管理界面。
- en: Building an admin interface
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建管理界面
- en: Now, it’s time to build a simple admin interface for our blog.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为我们的博客构建一个简单的管理界面了。
- en: 'We need to be able to do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够做到以下几点：
- en: List categories
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出分类
- en: Edit categories
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑分类
- en: List tags
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出标签
- en: Edit tags
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑标签
- en: List blog posts
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出博客文章
- en: Edit blog posts
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑博客文章
- en: If we look at the preceding list, we might notice that some of the things seem
    similar – perhaps we can build shared components for those. Categories and tags
    are very similar; they have names, and the name is the only thing we should be
    able to edit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前面的列表，我们可能会注意到一些事情看起来很相似——也许我们可以为这些事情构建共享组件。分类和标签非常相似；它们有名称，而且我们唯一能编辑的就是名称。
- en: Let’s make a component for that. The component is going to be responsible for
    listing, adding, deleting, and updating the object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个目的创建一个组件。该组件将负责列出、添加、删除和更新对象。
- en: 'Since the object we are working with is either `Category` or `Tag`, we need
    to be able to call different APIs depending on the object, so our component needs
    to be generic:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理的对象要么是 `Category` 要么是 `Tag`，我们需要能够根据对象调用不同的 API，因此我们的组件需要是通用的：
- en: In the `SharedComponents` project, in the root of the project, add a new Razor
    component and call it `ItemList.razor`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，在项目根目录下添加一个新的 Razor 组件，并命名为 `ItemList.razor`。
- en: 'Open the newly created file and at the top of the file, add:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的文件，并在文件顶部添加：
- en: '[PRE24]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`@typeparam` is to make the component generic, and the variable holding the
    generic type is called `ItemType`.'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@typeparam`是为了使组件泛型，持有泛型类型的变量被称为`ItemType`。'
- en: 'Add a `code` section (if you don’t have one already), and add the following
    lines of code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`code`部分（如果您还没有的话），并添加以下代码行：
- en: '[PRE25]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need two parameters: a list where we can add all the items and an `ItemTemplate`
    instance that we can use to change how we want the items to be shown. The `EditorRequired`
    attribute makes sure that we need to set this value when using the component.
    Otherwise, Visual Studio will show hostile error messages until we fix it.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个参数：一个列表，我们可以添加所有项目，以及一个`ItemTemplate`实例，我们可以用它来改变我们希望显示项目的方式。`EditorRequired`属性确保我们在使用组件时需要设置此值。否则，Visual
    Studio将显示敌对错误消息，直到我们修复它。
- en: In this case, we are using `RenderFragment<T>`, which will give us access to
    the item inside the template (things will become clearer as soon as we implement
    it).
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`RenderFragment<T>`，这将使我们能够访问模板内部的项目（一旦我们实现它，一切就会变得清晰起来）。
- en: 'We also need a couple of events; add the following code to the `code` section:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要几个事件；在`code`部分添加以下代码：
- en: '[PRE26]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We added two events; the first is when we delete a tag or a category. We will
    send an event to the parent component where we can add the code needed to delete
    the item.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了两个事件；第一个是在我们删除一个标签或一个类别时。我们将向父组件发送一个事件，在那里我们可以添加删除项目的所需代码。
- en: The second one is when we select an item so that we can edit the item.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个是在我们选择一个项目以便我们可以编辑项目时。
- en: 'Now, it’s time to add the UI; replace the top of the file below the `@typeparam`
    to the code tag with:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加UI了；将文件中`@typeparam`下面的顶部替换为以下代码：
- en: '[PRE27]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we look back to *Step 3*, we’ll notice that we used the variable for the
    lists and `RenderFragment`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾到*步骤3*，我们会注意到我们使用了列表的变量和`RenderFragment`。
- en: Then, we use the new `Virtualize` component to list our items; to be fair, we
    might not have that many categories or tags, but why not use it when we can? We
    set the `Items` property to `"Items"` (which is the name of our list) and the
    `Context` parameter to `"item"`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用新的`Virtualize`组件来列出我们的项目；公平地说，我们可能没有那么多类别或标签，但为什么不用呢？我们将`Items`属性设置为`"Items"`（这是我们列表的名称）并将`Context`参数设置为`"item"`。
- en: We can give it whatever name we want; we’re only going to use it inside of the
    `Virtualize` render template.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给它任何我们想要的名称；我们只会在`Virtualize`渲染模板内部使用它。
- en: We added two buttons that simply invoke the `EventCallback` instance we added
    in *Step 4*. Between those buttons, we added `@ItemTemplate(item)`; we want Blazor
    to render the template, but we also send the current item in the loop.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个按钮，这两个按钮简单地调用了我们在*步骤4*中添加的`EventCallback`实例。在这两个按钮之间，我们添加了`@ItemTemplate(item)`；我们希望Blazor渲染模板，同时也发送循环中的当前项目。
- en: That means we have access to the item’s value inside our template.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在模板内部访问项目的值。
- en: Listing and editing categories
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和编辑类别
- en: 'With our new component, it’s now time to create a component for listing and
    editing our categories:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的新组件，现在是时候创建一个用于列出和编辑我们类别的组件了：
- en: 'In the `SharedComponents` project, open `_Imports.razor`. Make sure the following
    namespaces are included: `@using SharedComponents` and `@using Microsoft.AspNetCore.Components.Forms`.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，打开`_Imports.razor`。确保包含以下命名空间：`@using SharedComponents`和`@using
    Microsoft.AspNetCore.Components.Forms`。
- en: Right-click on the `Pages` folder, select **Add** | **New folder**, and name
    the folder `Admin`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Pages`文件夹，选择**添加** | **新建文件夹**，并将文件夹命名为`Admin`。
- en: In the `Pages/Admin` folder, add a new Razor component and name it `CategoryList.razor`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pages/Admin`文件夹中，添加一个新的Razor组件，并将其命名为`CategoryList.razor`。
- en: 'At the top of the component, replace `<h3>CategoryList</h3>` with the following
    code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件顶部，将`<h3>CategoryList</h3>`替换为以下代码：
- en: '[PRE28]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We started with the `@page` directive, telling Blazor that if we navigate to
    the `"``admin/categories"` URL, we will get to the `CategoryList.Razor` component.
    This component has some interactivity, so we need to set what interactivity mode
    we wish to use. In this case, we are using `InteractiveServer`. If we want to
    use `InteractiveAuto` or `InteractiveWebAssembly`, we need to put the component
    in the `BlazorWebApp.Client` project. We will add a `using` statement and then
    inject our API.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从`@page`指令开始，告诉Blazor，如果我们导航到`"``admin/categories"` URL，我们将到达`CategoryList.Razor`组件。这个组件有一些交互性，因此我们需要设置我们希望使用的交互模式。在这种情况下，我们使用`InteractiveServer`。如果我们想使用`InteractiveAuto`或`InteractiveWebAssembly`，我们需要将组件放在`BlazorWebApp.Client`项目中。我们将添加一个`using`语句并注入我们的API。
- en: 'The next step is to add a form to edit the categories. Add the following code
    under the code from the previous step:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加一个用于编辑类别的表单。在上一步骤的代码下方添加以下代码：
- en: '[PRE29]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We added `EditForm`, which will execute the `Save` method if the form validates
    OK. For validation, we added `DataAnnotationsValidator`, which will validate the
    supplied data against the annotations we added to the `Tag` and `Category` classes.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了 `EditForm`，如果表单验证通过，它将执行 `Save` 方法。对于验证，我们添加了 `DataAnnotationsValidator`，它将验证提供的数据与我们添加到
    `Tag` 和 `Category` 类的注解。
- en: Since we are using Bootstrap, we want our form controls to look the same, so
    we added `CustomCssClassProvider`, which we created earlier in this chapter.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在使用 Bootstrap，我们希望我们的表单控件看起来相同，因此我们添加了之前在本章中创建的 `CustomCssClassProvider`。
- en: We added `InputText` and connected it to a `Category` object called `Item` (which
    we will add in just a second).
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了 `InputText` 并将其连接到一个名为 `Item` 的 `Category` 对象（我们将在下一秒添加它）。
- en: Below that, we added `ValidationMessage`, which will show any errors for the
    `name` property, and then a **Submit** button.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面，我们添加了 `ValidationMessage`，它将显示 `name` 属性的任何错误，然后是一个 **提交** 按钮。
- en: 'Now, it’s time to add our `ItemList` component; under the code we added in
    the previous step, add this code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加我们的 `ItemList` 组件了；在上一步骤添加的代码下方添加以下代码：
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add our component and we bind the `Items` property to a list of items (we
    will create that list in the next step).
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加我们的组件并将 `Items` 属性绑定到一个项目列表（我们将在下一步创建该列表）。
- en: We bind the `Select` and `Delete` events to methods and we specify the type
    of the list in the `ItemType` property. Then, we have `ItemTemplate`. Since we
    are using `RenderFragment<T>`, we now have access to a variable called `context`.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将 `Select` 和 `Delete` 事件绑定到方法，并在 `ItemType` 属性中指定列表的类型。然后，我们有 `ItemTemplate`。由于我们正在使用
    `RenderFragment<T>`，我们现在可以访问一个名为 `context` 的变量。
- en: We convert that variable to a category and print out the name of the category.
    This is the template for each item that will be shown on the list.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将那个变量转换为类别并打印出类别的名称。这是将在列表上显示的每个项目的模板。
- en: 'Finally, we add the following code to replace the `code` section:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将以下代码添加到替换 `code` 部分的代码中：
- en: '[PRE31]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We added a list to hold all our categories and a variable that holds one item
    (the item currently being edited). We use `OnInitializedAsync` to load all the
    categories from the API.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了一个用于存储所有类别的列表和一个用于存储一个项目（当前正在编辑的项目）的变量。我们使用 `OnInitializedAsync` 从 API
    加载所有类别。
- en: The `Delete` and `Save` methods call the API’s corresponding method, and the
    `Select` method takes the provided item and puts it into the item variable (ready
    to be edited).
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Delete` 和 `Save` 方法调用 API 的相应方法，而 `Select` 方法将提供的项目放入 `item` 变量中（准备进行编辑）。'
- en: We check whether we already have the item in the list before we add it to the
    list. Run the project and navigate to `/admin/categories`.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在将项目添加到列表之前，我们检查列表中是否已经存在该项目。运行项目并导航到 `/admin/categories`。
- en: 'Try to add, edit, or delete a category, as shown in *Figure 6.1*:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试添加、编辑或删除一个类别，如图 *6.1* 所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_01.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21849_06_01.png)'
- en: 'Figure 6.1: The Edit category view'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：编辑类别视图
- en: Now, we need a component for listing and editing tags as well – it is pretty
    much the same thing, but we need to use `Tag` instead of `Category`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个用于列出和编辑标签的组件，这几乎与之前相同，但我们需要使用 `Tag` 而不是 `Category`。
- en: Listing and editing tags
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和编辑标签
- en: 'We just created a component for listing and editing categories; now, we need
    to create a component to list and edit tags:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个用于列出和编辑类别的组件；现在，我们需要创建一个用于列出和编辑标签的组件：
- en: In the `BlazorWebApp.Client` project, in the `Pages`folder, add a new folder
    called`Admin`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp.Client` 项目中，在 `Pages` 文件夹下，添加一个名为 `Admin` 的新文件夹。
- en: Add a new Razor component called `TagList.razor`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `TagList.razor` 的新 Razor 组件。
- en: 'At the top of the component, replace `<h3>TagList</h3>` with the following
    code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件顶部，将 `<h3>TagList</h3>` 替换为以下代码：
- en: '[PRE32]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We started with the `@page` directive telling Blazor that if we navigate to
    the `"admin/tags"` URL, we will get to the `TagList.Razor` component. We also
    specify the render mode as `InteractiveServer`. We add a `using` statement and
    then inject our API.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从 `@page` 指令开始，告诉 Blazor 如果我们导航到 `"admin/tags"` URL，我们将到达 `TagList.Razor`
    组件。我们还指定了渲染模式为 `InteractiveServer`。我们添加了一个 `using` 语句，然后注入我们的 API。
- en: 'The next step is to add a form to edit the tags. Add the following code under
    the code from the previous step:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加一个用于编辑标签的表单。在上一步骤的代码下方添加以下代码：
- en: '[PRE33]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We added `EditForm`, which will execute the `Save` method if the form validates
    without a problem. For validation, we added `DataAnnotationsValidator`, which
    will validate the supplied data against the annotations we added to the `Tag`
    and `Category` classes.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了`EditForm`，如果表单验证没有问题，它将执行`Save`方法。为了验证，我们添加了`DataAnnotationsValidator`，它将验证提供的数据与我们添加到`Tag`和`Category`类中的注释。
- en: Since we are using Bootstrap, we want our form controls to look the same, so
    we added `CustomCssClassProvider`, which we created earlier in this chapter.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们使用Bootstrap，我们希望我们的表单控件看起来一样，因此我们添加了`CustomCssClassProvider`，这是我们在此章之前创建的。
- en: We added `InputText` and connected it to a `Tag` object called `Item` (which
    we will add in a moment).
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了`InputText`并将其连接到名为`Item`的`Tag`对象（我们将在稍后添加它）。
- en: Below it, we add a `ValidationMessage` instance that will show any errors for
    the `name` property and then a **Submit** button.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在其下方，我们添加了一个`ValidationMessage`实例，它将显示`name`属性的任何错误，然后是一个**提交**按钮。
- en: 'Now, it’s time to add our `ItemList` component. Under the code we added in
    the previous step, add this code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加我们的`ItemList`组件了。在上一步添加的代码下方，添加以下代码：
- en: '[PRE34]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We added our component and bound the `Items` property to a list of items (we
    will create that list in the next step). We bind the `Select` and `Delete` events
    to methods and specify the `List` type in the `ItemType` property.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了我们的组件，并将`Items`属性绑定到项目列表（我们将在下一步创建该列表）。我们将`Select`和`Delete`事件绑定到方法，并在`ItemType`属性中指定`List`类型。
- en: Then we have `ItemTemplate`; since we are using `RenderFragment<T>`, we now
    have access to a variable called `context`. We convert that variable to a tag
    and print out the tag’s name.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后是`ItemTemplate`；由于我们正在使用`RenderFragment<T>`，我们现在可以访问一个名为`context`的变量。我们将该变量转换为标签并打印出标签的名称。
- en: This is the template for each item shown in the list.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是列表中显示的每个项目的模板。
- en: 'Finally, we replace the code section with the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将代码部分替换为以下代码：
- en: '[PRE35]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We added a list to hold all our tags and a variable that holds one item (the
    item currently being edited). We use `OnInitializedAsync` to load all the tags
    from the API.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了一个列表来存储所有标签，以及一个变量来存储一个项目（当前正在编辑的项目）。我们使用`OnInitializedAsync`从API加载所有标签。
- en: The `Delete` and `Save` methods call the API’s corresponding method and the
    `Select` method takes the provided item and puts it into the `Item` variable (ready
    to be edited).
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Delete`和`Save`方法调用API的相应方法，而`Select`方法将提供的项目放入`Item`变量中（准备编辑）。'
- en: We check whether we already have the item in the list before we add it to the
    list.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们将项目添加到列表之前，我们检查列表中是否已经存在该项目。
- en: Run the project and navigate to `/admin/tags`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并导航到`/admin/tags`。
- en: 'Try to add, edit, and delete a tag, as shown in *Figure 6.2*:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试添加、编辑和删除标签，如图*6.2*所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_02.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成描述](img/B21849_06_02.png)'
- en: 'Figure 6.2: The Edit tag view'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：编辑标签视图
- en: Now, we need ways to list and edit blog posts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要列出和编辑博客文章的方法。
- en: Listing and editing blog posts
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和编辑博客文章
- en: 'Let’s start with listing and editing blog posts:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从列出和编辑博客文章开始：
- en: In the `SharedComponents` project, in the `Pages/Admin` folder, add a new Razor
    component called `BlogPostList.razor`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，在`Pages/Admin`文件夹中，添加一个名为`BlogPostList.razor`的新Razor组件。
- en: 'At the top of the `BlogPostList.razor` file, replace `<h3>BlogPostList</h3>`
    with the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlogPostList.razor`文件顶部，将`<h3>BlogPostList</h3>`替换为以下代码：
- en: '[PRE36]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We added a `page` directive, injected our API, and listed the blog posts using
    a `foreach` loop. We also enabled `StreamingRendering`, because this page doesn’t
    have any interactivity, so there is no need to add that. This also means we can’t
    use the `Virtualize` component since it is interactive.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了一个`page`指令，注入我们的API，并使用`foreach`循环列出博客文章。我们还启用了`StreamingRendering`，因为这个页面没有任何交互性，所以没有必要添加。这也意味着我们不能使用`Virtualize`组件，因为它具有交互性。
- en: We also linked the posts to a URL with the `Id` instance of the blog.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还通过博客的`Id`实例将帖子链接到URL。
- en: 'Add the following code in the `code` section:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`code`部分添加以下代码：
- en: '[PRE37]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We added the functionality to load posts from the database and a small delay
    so that we can see **Loading…** for just a brief moment. Now, there is only one
    thing left in the section: adding a page where we can edit the blog post.'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了从数据库加载帖子功能，并添加了小延迟，以便我们可以看到**加载中…**仅短暂的一瞬间。现在，这个部分只剩下最后一件事：添加一个可以编辑博客文章的页面。
- en: A very popular way of writing blog posts is using Markdown; our blog engine
    will support that. Since Blazor supports any .NET standard **dynamic link library**
    (**DLL**), we will add an existing library called `Markdig`.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写博客的一个非常流行的方式是使用 Markdown；我们的博客引擎将支持这一点。由于 Blazor 支持任何 .NET 标准的 **动态链接库**（**DLL**），我们将添加一个名为
    `Markdig` 的现有库。
- en: This is the same engine that Microsoft uses for their `docs` site.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与微软用于他们 `docs` 网站的相同引擎。
- en: We can extend `Markdig` with different extensions (as Microsoft has done), but
    let’s keep this simple and only add support for Markdown without all the fancy
    extensions.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将 `Markdig` 扩展为不同的扩展（就像微软所做的那样），但让我们保持简单，只添加对 Markdown 的支持，而不添加所有花哨的扩展。
- en: Under the `SharedComponents` project, right-click on the **Dependencies** node
    in Solution Explorer and select **Manage NuGet Packages**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，在解决方案资源管理器中的 **依赖项** 节点右键单击，并选择 **管理 NuGet 包**。
- en: Search for `Markdig` and click **Install**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `Markdig` 并点击 **安装**。
- en: Add a new class in the root of the project called `InputTextAreaOnInput.cs`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下添加一个名为 `InputTextAreaOnInput.cs` 的新类。
- en: 'Open the new file and replace its contents with the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新文件，并用以下代码替换其内容：
- en: '[PRE38]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code is taken from Microsoft’s GitHub repository; it is how they
    implement the `InputTextArea` component.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码来自微软的 GitHub 仓库；这是他们实现 `InputTextArea` 组件的方式。
- en: In their build system, they can’t handle `.razor` files, so that’s why they
    implement the code this way. I made one change in Microsoft’s code, and that is
    `oninput`, which used to say `OnChange`.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在他们的构建系统中，他们无法处理 `.razor` 文件，这就是为什么他们以这种方式实现代码。我在微软的代码中做了一处更改，那就是 `oninput`，它以前说的是
    `OnChange`。
- en: For most cases, `OnChange` will be just fine, which means when I leave the textbox,
    the value will be updated (and trigger validations). But in our case, we want
    the preview of the HTML to be updated in real time, which is why we had to implement
    our own.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于大多数情况，`OnChange` 就足够了，这意味着当我离开文本框时，值将被更新（并触发验证）。但在我们的情况下，我们希望 HTML 预览实时更新，这就是为什么我们必须实现自己的。
- en: One option could have been not to use the `InputTextArea` component and instead
    use the `TextArea` tag, but we would lose the validation highlighting. This is
    the way to go if we ever need to customize the behavior on an input control.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个选择可能是不要使用 `InputTextArea` 组件，而是使用 `TextArea` 标签，但我们会失去验证高亮。如果我们需要自定义输入控件的行为，这就是我们采取的方式。
- en: I recommend using `.razor` files over `.cs` files if you make many changes to
    the implementation.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你对实现进行很多更改，我建议使用 `.razor` 文件而不是 `.cs` 文件。
- en: In the `Pages/Admin` folder, add a new Razor component called `BlogPostEdit.razor`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Pages/Admin` 文件夹中，添加一个名为 `BlogPostEdit.razor` 的新 Razor 组件。
- en: 'At the top of the `BlogPostEdit.razor` file, replace `<h3>BlogPostEdit</h3>`
    with the following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlogPostEdit.razor` 文件顶部，将 `<h3>BlogPostEdit</h3>` 替换为以下代码：
- en: '[PRE39]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We add two different `page` directives because we want to be able to create
    a new blog post as well as supply an ID to edit an already existing one. If we
    do not supply an ID, the `Id` parameter will be null (or the default).
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了两个不同的 `page` 指令，因为我们想能够创建一个新的博客文章，同时也提供一个 ID 来编辑已经存在的文章。如果我们不提供 ID，则 `Id`
    参数将为空（或默认值）。
- en: We inject our API and `NavigationManager` as well as adding `using` statements.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们注入我们的 API 和 `NavigationManager`，以及添加 `using` 语句。
- en: 'We also need some variables. Add the following code in the `code` section:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些变量。在 `code` 部分添加以下代码：
- en: '[PRE40]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We added a parameter for the blog post ID (if we want to edit one), a variable
    to hold the post we are editing, one to hold all the categories, and one to hold
    all the tags. We also added a variable to hold the currently selected category
    and one to hold the Markdown converted to HTML.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了一个用于博客文章 ID 的参数（如果我们想编辑一个），一个用于保存我们正在编辑的文章的变量，一个用于保存所有类别，一个用于保存所有标签。我们还添加了一个用于保存当前所选类别和一个用于保存转换为
    HTML 的 Markdown 的变量。
- en: 'Now, we need to add the form; add the following code:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要添加表单；添加以下代码：
- en: '[PRE41]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We add an `EditForm`, and when we submit the form (if it is valid), we execute
    the `SavePost` method. We add `DataAnnotationValidator`, which will validate our
    model against the data annotations in the class.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了一个 `EditForm`，当我们提交表单（如果它是有效的）时，我们执行 `SavePost` 方法。我们添加 `DataAnnotationValidator`，它将验证我们的模型与类中的数据注释。
- en: We add `CustomCssClassProvider` so that we get the correct Bootstrap class names.
    Then, we add components for the title, publish date, category, tags, and, last
    but not least, the text (the blog post’s content).
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加`CustomCssClassProvider`以确保我们获得正确的Bootstrap类名。然后，我们添加标题、发布日期、类别、标签，最后但同样重要的是，文本（博客文章的内容）的组件。
- en: Finally, we add the text using the component we created in *Step 4* (the component
    that updates for each keystroke).
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们使用在*步骤4*中创建的组件（该组件会针对每个按键更新）添加文本。
- en: We also hook up the `@onkeyup` event to update the preview for each keystroke.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还将`@onkeyup`事件连接起来，以便针对每个按键更新预览。
- en: 'We also need to add our `SavePost` method. Add the following code in the `code`
    section:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加我们的`SavePost`方法。在`code`部分添加以下代码：
- en: '[PRE42]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, it’s time to show the preview. Add the following code just below the `EditForm`
    close tag:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候显示预览了。在`EditForm`关闭标签下方添加以下代码：
- en: '[PRE43]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use `MarkupString` to make sure Blazor outputs the HTML code without escaping
    the characters. You might remember that from *Chapter 4*, *Understanding Basic
    Blazor Components*.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`MarkupString`来确保Blazor输出HTML代码而不转义字符。你可能还记得这是从*第4章*，*理解基本Blazor组件*中提到的。
- en: 'Now, it is time to set up `Markdig`. Add the following code somewhere in the
    `code` section:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候设置`Markdig`了。在`code`部分添加以下代码：
- en: '[PRE44]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To configure `Markdig`, we need to create a pipeline. As I mentioned earlier
    in the chapter, this is the engine Microsoft uses for their documentation site.
    It has many extensions available, including source code highlighting and emoticons.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要配置`Markdig`，我们需要创建一个管道。如我之前在本章中提到的，这是微软用于他们文档网站的引擎。它有许多扩展可用，包括源代码高亮和表情符号。
- en: We also added emoticons to the pipeline to make it a little more fun.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还在管道中添加了表情符号，使其更加有趣。
- en: 'We must also add code to load the data (`blog` `posts`, `categories`, and `tags`).
    Add the following methods in the `code` section:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须添加代码来加载数据（`blog` `posts`、`categories`和`tags`）。在`code`部分添加以下方法：
- en: '[PRE45]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, run the site, navigate to `/admin/blogposts`, click on a blog post to
    edit it, and test the new Markdown support. *Figure 6.3* shows the **Edit** page
    with Markdown support:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，运行网站，导航到`/admin/blogposts`，点击一个博客文章进行编辑，并测试新的Markdown支持。*图6.3*显示了带有Markdown支持的**编辑**页面：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_03.png)'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21849_06_03.png)'
- en: 'Figure 6.3: The Edit page with Markdown support'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3：带有Markdown支持的编辑页面
- en: 'We still have one more thing to do: we need to ensure that the blog post page
    shows a converted HTML version of the Markdown.'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还有一件事要做：我们需要确保博客文章页面显示Markdown的转换后的HTML版本。
- en: 'Open `/Pages/Post.razor` and add the following `using` statement at the top
    of the file:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`/Pages/Post.razor`并在文件顶部添加以下`using`语句：
- en: '[PRE46]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following code to the `code` section:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`code`部分：
- en: '[PRE47]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Replace the following row:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换以下行：
- en: '[PRE48]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Replace the preceding row with this:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用以下行替换前面的行：
- en: '[PRE49]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Great job! Now, we have an admin interface up and running so that we can start
    writing blog posts.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在，我们有一个正在运行的行政界面，这样我们就可以开始写博客文章了。
- en: Looking at the code we wrote, no textbox has a label; what we can do is add
    a label in all the places we are using a textbox. Some component vendors have
    a label built into their components. I prefer doing that myself. Add an abstraction
    layer on top of any built-in components or third-party components.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们编写的代码，没有文本框有标签；我们可以做的是在所有使用文本框的地方添加标签。一些组件供应商已经将标签内置到他们的组件中。我更喜欢自己来做这件事。在所有内置组件或第三方组件之上添加一个抽象层。
- en: Adding an abstraction layer
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加抽象层
- en: 'This has saved us more times than I can count. Adding an abstraction layer
    does take some time and effort, but I promise you, you will get that time back.
    So, why should we do this? Well, for several reasons: if we are using Bootstrap,
    for example, and we want to upgrade Bootstrap to the latest version, there might
    be classes that have changed. By using components, it’s easy to only change those
    components. It also makes it easier to change component vendors in the future
    if you have your own components encapsulating the third-party components. But
    the real reason is that if we add a layer, we can set the team’s programming style/language.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经帮我们节省了无数次。添加抽象层确实需要一些时间和精力，但我向你保证，你会得到回报。那么，我们为什么要这样做呢？好吧，有几个原因：如果我们使用Bootstrap，例如，并且我们想要升级到最新版本，可能会有一些类发生了变化。通过使用组件，我们很容易只更改那些组件。如果将来你有自己的组件封装第三方组件，这也使得更改组件供应商变得更容易。但真正的理由是，如果我们添加一层，我们可以设定团队的编程风格/语言。
- en: Everything we build will have the same default values, the same access to properties,
    and the same UX. We can add functionality, but in most cases, it is more important
    to limit the functionality.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的每一项都将具有相同的默认值，相同的属性访问权限，以及相同的用户体验。我们可以添加功能，但在大多数情况下，限制功能更为重要。
- en: A third-party component has a lot of functionality; it should cater to many
    different use cases. But they also mean that your team now has access to many
    different functionalities that can make the UX different for each developer that
    implements the functionality.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方组件有很多功能；它们应该满足许多不同的用例。但这也意味着你的团队现在可以访问许多不同的功能，这些功能可以使每个实现功能的开发者的用户体验不同。
- en: Let’s add a couple of shared components to the project.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中添加一些共享组件。
- en: The first one is a textbox with a label and validation message built in.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个带有内置标签和验证消息的文本框。
- en: 'If we take a look at our `CategoryList` component, the code looks like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看我们的`CategoryList`组件，代码看起来是这样的：
- en: '[PRE50]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A label using Bootstrap looks something like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bootstrap的标签看起来像这样：
- en: '[PRE51]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s see if we can combine these; some features are already built in. Since
    we only add a layer, we don’t have to handle as much functionality. We rather
    need to send the parent component values to the encapsulated component. Let’s
    look at some code to see what’s going on:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否可以将这些功能结合起来；一些功能已经内置了。由于我们只添加了一层，所以我们不需要处理那么多的功能。我们更需要的是将父组件的值发送到封装的组件。让我们看看一些代码，看看发生了什么：
- en: In the `SharedComponent` project, in the `ResusableComponents` folder, add a
    new Razor component and call it `BlogInputText.razor`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponent`项目中，在`ResusableComponents`文件夹中，添加一个新的Razor组件，命名为`BlogInputText.razor`。
- en: 'In the `code` section, add the following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`code`部分，添加以下代码：
- en: '[PRE52]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let’s take a look at what is going on. First, we add a parameter so that we
    have an ID that we can use for the `label` tag in the next step. We add a string
    that can contain text for our label, id we do have some text, we render the label.
    If it is `null`, we don’t render the label. I prefer not to have a “`ShowLabel`"
    property. If there is a text, it should show the label. We also have the current
    edit context, which we will use to send to the next level of components.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看发生了什么。首先，我们添加一个参数，以便我们有一个可以用于下一步中`label`标签的ID。我们添加一个可以包含标签文本的字符串，如果有的话，我们渲染标签。如果是`null`，我们不渲染标签。我更喜欢没有“`ShowLabel`"属性。如果有文本，应该显示标签。我们还有当前的编辑上下文，我们将将其发送到下一级组件。
- en: In our form we have an `EditForm`; the `EditForm` will send the `EditContext`
    to all the child components and will keep track of the state of the form. We want
    to grab that edit context and send that to all the components inside of this component
    as well.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的表单中，我们有一个`EditForm`；`EditForm`将`EditContext`发送到所有子组件，并跟踪表单的状态。我们希望获取这个编辑上下文并将其发送到这个组件内部的所有组件。
- en: Then, we have the trio of value parameters, `Value`, `ValueChanged`, and `ValueExpression`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有三个值参数，`Value`、`ValueChanged`和`ValueExpression`。
- en: 'In the non-code part of the page, add the following (replacing the three tags):'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面的非代码部分，添加以下内容（替换三个标签）：
- en: '[PRE53]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: First, we grab the `CurrentEditContext` and send that to a child component;
    this way, all the children will have the same edit context as the parent `EditForm`.
    If we have any text in the `Label` parameter, we should show the label. Then we
    add the `InputText`, the built-in component. If we would like to do this with
    a third-party library, we would do it in a similar way. Next is where things get
    a bit more complicated; we could have simply said `@bind-Value`, which would notify
    Blazor that a change has happened, but it would notify the `EditContext` that
    the `Value` parameter of our component has been changed, not the model.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们获取`CurrentEditContext`并将其发送给子组件；这样，所有子组件都将具有与父`EditForm`相同的编辑上下文。如果我们有任何文本在`Label`参数中，我们应该显示标签。然后我们添加`InputText`，内置组件。如果我们想用第三方库来做这件事，我们会以类似的方式来做。接下来，事情会变得稍微复杂一些；我们本可以说`@bind-Value`，这将通知Blazor发生了变化，但它将通知`EditContext`我们的组件的`Value`参数已被更改，而不是模型。
- en: So, instead of doing that, we set the `Value` parameter and the `ValueChanged`
    parameter to the parameters that we send to the component. This way, the notification
    of the value changed will directly notify that the model has been changed. The
    `ValueExpression` will make sure that the `EditContext` gets notified of the change
    and will show the corresponding validation message. To be honest, in this example,
    it doesn’t really matter, but if we were using a third-party component with validation
    built in, it might not work (depending on how they build the component). So, using
    this method should always work.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们不是这样做，而是将`Value`参数和`ValueChanged`参数设置为发送给组件的参数。这样，值更改的通知将直接通知模型已被更改。`ValueExpression`将确保`EditContext`被通知更改，并将显示相应的验证消息。说实话，在这个例子中，这并不真的重要，但如果我们使用具有内置验证的第三方组件，它可能不起作用（取决于他们如何构建组件）。因此，使用这种方法应该始终有效。
- en: Then, we have the `ValidationMessage`, which shows any error in the model, and
    we are using the same `ValueExpression` here.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`ValidationMessage`，它显示模型中的任何错误，我们在这里使用相同的`ValueExpression`。
- en: Now, we need to use this component. Let’s change the `Taglist` first. In the
    `BlazorWebApp.Client` project, in the `Pages/Admin` folder, open `Taglist.razor`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用这个组件。让我们首先更改`Taglist`。在`BlazorWebApp.Client`项目中，在`Pages/Admin`文件夹中，打开`Taglist.razor`。
- en: 'Right now, we have the following code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有以下代码：
- en: '[PRE54]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Replace this code with the following:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码替换为：
- en: '[PRE55]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, isn’t that kind of elegant?
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，难道这不是一种优雅的做法吗？
- en: Let’s do the same with the `CategoryList`. In the `SharedComponent` project,
    in the `Pages/Admin` folder, open `CategoryList.razor`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用`CategoryList`做同样的事情。在`SharedComponent`项目中，在`Pages/Admin`文件夹中，打开`CategoryList.razor`。
- en: 'Replace the following code:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换以下代码：
- en: '[PRE56]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Replace the preceding code with the following code:'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下代码：
- en: '[PRE57]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This kind of change makes me genuinely happy – it simplifies usage, makes the
    UI easier to understand, and removes the need for duplicated code. Even though
    we know how to do this now, I want to add one more example that perhaps showcases
    the really nice benefits of working this way. Let’s create a button component
    as well. This component will be a bit more to take in:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变让我真正感到高兴——它简化了使用，使UI更容易理解，并消除了重复代码的需求。尽管我们现在知道如何做到这一点，但我还想添加一个额外的例子，也许可以展示这种工作方式的真正好处。让我们也创建一个按钮组件。这个组件将更加复杂：
- en: In the `SharedComponents` project, in the `ReusableComponents` folder, add a
    new component and name it `BlogButton.razor`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，在`ReusableComponents`文件夹中，添加一个新的组件，并将其命名为`BlogButton.razor`。
- en: 'Replace the content with this code:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容替换为以下代码：
- en: '[PRE58]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are adding a normal HTML button, nothing fancy. We add functionality to change
    the type (`button` or `submit`), whether it is disabled or not, what CSS class
    it should have, a method to run, and the title.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个普通的HTML按钮，没有太多花哨的功能。我们添加了更改类型（`button`或`submit`）、是否禁用、应该具有的CSS类、要运行的方法和标题的功能。
- en: 'Add the following code to the `code` section:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`code`部分：
- en: '[PRE59]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we are doing the same thing as with the `BlogTextbox`, and we bring in
    the `EditContext`, which we will use in just a bit.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在做与`BlogTextbox`相同的事情，并引入了`EditContext`，我们将在稍后使用它。
- en: We also have a `RenderFragment` for the content of the button.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个用于按钮内容的`RenderFragment`。
- en: 'Next, add the following code:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码：
- en: '[PRE60]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: First, we add a couple of `private` fields that we will use in the component,
    then we add a property for whether the button is disabled or not. It will use
    `EditContext` to check whether there are any errors in the form, save those errors
    in a variable, and if the form is OK, enable the button, and if it is not, disable
    the button. There is a downside to this implementation; for the validation to
    trigger, we need to click somewhere else on the page to trigger the change in
    the field. So, now, the button will be disabled if the form is not OK.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加几个 `private` 字段，我们将在组件中使用它们，然后添加一个属性来表示按钮是否被禁用。它将使用 `EditContext` 来检查表单中是否有任何错误，并将这些错误保存到变量中。如果表单正常，则启用按钮；如果不正常，则禁用按钮。这种实现方式有一个缺点；为了触发验证，我们需要在页面的其他地方点击以触发字段的变化。所以，现在，如果表单不正常，按钮将会被禁用。
- en: 'Add the following code:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE61]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This code will get a `Title` for the button and it will be shown when hovering
    your mouse over the button. We can also set a `HelpText` or a disabled help text.
    If the function is disabled for any reason, it might not have anything to do with
    the for we will show a text that explains why the button is disabled. It will
    also add any form errors to the button so it is easy to understand what form element
    is the problem without having to scroll to the element.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码将为按钮获取一个 `Title`，当鼠标悬停在按钮上时将显示。我们还可以设置 `HelpText` 或禁用帮助文本。如果由于任何原因函数被禁用，我们可能不会显示原因，而是显示一个解释为什么按钮被禁用的文本。它还会将任何表单错误添加到按钮上，这样就可以轻松理解哪个表单元素有问题，而无需滚动到该元素。
- en: 'Sometimes, we might want to use the button, but without a form, simply executing
    a method. Add the following code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候，我们可能想使用按钮，但没有表单，只是简单地执行一个方法。添加以下代码：
- en: '[PRE62]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we have a delegate for `OnClick`, we want the button to simply be a button.
    If we don’t have a delegate, we assume the button is used inside of an `EditForm`.
    When the button is clicked, the `OnButtonClick` method will run.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个 `OnClick` 的代理，我们希望按钮仅仅是一个按钮。如果没有代理，我们假设按钮是在 `EditForm` 内部使用的。当按钮被点击时，`OnButtonClick`
    方法将会执行。
- en: 'Now, we get to the really juicy part. Let’s add an `enum`; we can add it in
    the `code` section:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来到了真正有趣的部分。让我们添加一个 `enum`；我们可以在 `code` 部分添加它：
- en: '[PRE63]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that we are not using vocabulary like primary or danger – that’s Bootstrap
    lingo. What we want to know is what the button is used for. When we add a button,
    what is the most likely scenario in which the button will be used?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们没有使用像“主要”或“危险”这样的词汇——那是 Bootstrap 的术语。我们想知道按钮的用途。当我们添加一个按钮时，最可能的使用场景是什么？
- en: 'Then, we add a parameter for `ButtonType` like this:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个 `ButtonType` 的参数，如下所示：
- en: '[PRE64]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We add a parameter for `ButtonType` and an internal property that translates
    the “Save” use case, for example, to a Bootstrap CSS class.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加一个 `ButtonType` 参数和一个内部属性，将“保存”用例等价转换为 Bootstrap CSS 类。
- en: Our team doesn’t have to bother remembering which Bootstrap class they should
    use; they know it’s a button, and they know what the button is used for. The component
    takes care of the rest.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们团队不需要费心去记住应该使用哪个 Bootstrap 类；他们知道这是一个按钮，也知道按钮的用途。组件会处理其余部分。
- en: Let’s test it out!
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们测试一下！
- en: In the `BlazorWebApp` project, in the `Pages/Admin` folder, open `TagList.razor.`
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp` 项目中，在 `Pages/Admin` 文件夹中，打开 `TagList.razor`。
- en: 'Replace the following line:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换以下行：
- en: '[PRE65]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换前面的行为以下行：
- en: '[PRE66]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you run the project now, you will see that the button is disabled if we haven’t
    made any changes to the form, and will become enabled if we add something to the
    textbox.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行项目，你会看到如果我们没有对表单进行任何更改，按钮将会被禁用；如果我们向文本框中添加内容，按钮将会变为启用状态。
- en: Let’s do the same for the `CategoryList`. In the `SharedComponents` project,
    in the folder `Pages/Admin`, open `CategoryList.razor`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对 `CategoryList` 也做同样的处理。在 `SharedComponents` 项目中，在 `Pages/Admin` 文件夹中，打开
    `CategoryList.razor`。
- en: 'Replace the following line:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换以下行：
- en: '[PRE67]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换前面的行为以下行：
- en: '[PRE68]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There are more places we can modify and add this button to, but let’s not spend
    time on that for now. If you want, you can return to this and make sure we are
    using the new button and `InputText` everywhere.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在更多地方修改并添加这个按钮，但我们现在先不花时间在这个上面。如果你想，你可以回到这里并确保我们在每个地方都使用了新的按钮和 `InputText`。
- en: We have one more component to build.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个组件需要构建。
- en: Locking the navigation
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定导航
- en: In .NET 7, we got a new component called `NavigationLock`. Right now, if we
    write a blog post and click somewhere in the menu, our changes will be lost. The
    same thing happens if we change the URL and press *Enter*. With `NavigationLock`,
    we can prevent that from happening.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 中，我们得到了一个新的组件，称为 `NavigationLock`。目前，如果我们写一篇博客文章并在菜单中点击某个地方，我们的更改将会丢失。如果我们更改
    URL 并按 *Enter*，也会发生同样的事情。使用 `NavigationLock`，我们可以防止这种情况发生。
- en: '`NavigationLock` can prevent us from leaving the page and navigating to another
    page in our site. In that case, we can show a custom message using JavaScript.
    If we navigate to another site, it can trigger a warning, but we don’t have control
    over the message shown. This functionality is built into the browser.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigationLock` 可以防止我们从页面离开并导航到我们网站上的另一个页面。在这种情况下，我们可以使用 JavaScript 显示自定义消息。如果我们导航到另一个网站，它可以触发一个警告，但我们无法控制显示的消息。此功能是内置在浏览器中的。'
- en: 'We will implement this in the same way we did with `FieldCssClassProvider`,
    as a reusable component. We want to check whether our `EditContext` has any changes
    made so we can trigger the navigation lock:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与 `FieldCssClassProvider` 相同的方式实现此功能，作为一个可重用组件。我们想检查我们的 `EditContext` 是否有任何更改，以便我们可以触发导航锁定：
- en: In the `SharedComponents` project, in the `ReusableComponents` folder, add a
    new Razor component and name it `BlogNavigationLock.razor`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，在 `ReusableComponents` 文件夹中，添加一个新的 Razor 组件，并将其命名为
    `BlogNavigationLock.razor`。
- en: 'At the top of the component, add the following code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件顶部添加以下代码：
- en: '[PRE69]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We inject an `IJSRuntime` to make JavaScript calls. We will return to JavaScript
    interop in *Chapter 10*, *JavaScript Interop*.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们注入一个 `IJSRuntime` 来调用 JavaScript。我们将在第 10 章，*JavaScript 互操作*中返回 JavaScript
    互操作。
- en: We also implement the `IDisposable` interface.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还实现了 `IDisposable` 接口。
- en: 'In the `code` section, add the following code:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `code` 部分中，添加以下代码：
- en: '[PRE70]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We have a `CascadingParameter`, which gets the current `EditContext`, just as
    we did with `FieldCssClassProvider`.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有一个 `CascadingParameter`，它获取当前的 `EditContext`，就像我们使用 `FieldCssClassProvider`
    一样。
- en: We also added a string that is the message shown when we try to navigate from
    the page.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还添加了一个字符串，这是我们尝试从页面导航时显示的消息。
- en: 'When a change happens in the `EditContext`, we need to update the component
    and make sure it locks the navigation. Add the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `EditContext` 发生更改时，我们需要更新组件并确保它锁定导航。添加以下代码：
- en: '[PRE71]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We start to listen for field changes, and if a field changes, we call the `StateHasChanged`
    method to update the component.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们开始监听字段更改，如果字段发生变化，我们调用 `StateHasChanged` 方法来更新组件。
- en: '`InvokeAsync` is needed since the call comes from another thread.'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于调用来自另一个线程，需要 `InvokeAsync`。
- en: We also override the `Dispose` method and remove the event listener.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还重写了 `Dispose` 方法并移除了事件监听器。
- en: 'In the `code` section, add the following code:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `code` 部分中，添加以下代码：
- en: '[PRE72]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This method will make a JavaScript call if there are changes in the `EditContext`
    (or model), showing a confirm dialog and the message we added. If we do not confirm,
    the navigation will be prevented.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在 `EditContext`（或模型）中发生变化，此方法将调用 JavaScript，显示确认对话框和我们所添加的消息。如果我们不确认，导航将被阻止。
- en: 'Now, we can add the `NavigationLock` component. Just under the directives,
    add the following code:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加 `NavigationLock` 组件。在指令下方添加以下代码：
- en: '[PRE73]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This `NavigationLock` component will prevent external navigation (navigating
    to another site) and internal navigation (navigating to another page in our blog).
    It checks whether the `EditContext` (model) has any changes and prevents external
    navigation. On internal navigation, it will execute the `OnBeforeInternalNavigation`
    method, which checks whether the `EditContext` has been changed.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 `NavigationLock` 组件将阻止外部导航（导航到另一个网站）和内部导航（在我们的博客中导航到另一个页面）。它检查 `EditContext`（模型）是否有任何更改，并阻止外部导航。在内部导航时，它将执行
    `OnBeforeInternalNavigation` 方法，该方法检查 `EditContext` 是否已更改。
- en: Now, we only have one more thing to do.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们只剩下一件事要做。
- en: 'In `Pages/Admin/BlogPostEdit.razor`, add the new Razor component we created
    just below the `CustomCssClassProvider`:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Pages/Admin/BlogPostEdit.razor` 中，在我们创建的新 Razor 组件 `CustomCssClassProvider`
    下方添加：
- en: '[PRE74]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This will get the `EditContext` from the cascading value, and execute the code
    we just wrote.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将从级联值中获取 `EditContext`，并执行我们刚刚编写的代码。
- en: 'Add the following:'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加以下内容：
- en: '[PRE75]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the `code` section, add the following:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `code` 部分中，添加以下内容：
- en: '[PRE76]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the `SavePostAsync` method, just before navigating to `admin/blogposts`,
    add the following:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SavePostAsync` 方法中，在导航到 `admin/blogposts` 之前，添加以下内容：
- en: '[PRE77]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When saving the object, the `EditContext` doesn’t know that, so we are telling
    the `EditContext` that the model is now unmodified, so the navigation should not
    be stopped.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当保存对象时，`EditContext` 并不知道这一点，所以我们正在告诉 `EditContext` 模型现在没有修改，因此导航不应该停止。
- en: Run the site, navigate to `Admin/BlogPosts`, and click a blog post.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行网站，导航到 `Admin/BlogPosts`，然后点击一篇博客文章。
- en: Try to navigate to another site (it should work).
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个网站（应该可以工作）。
- en: Try to navigate to another page (it should work).
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个页面（应该可以工作）。
- en: Change the blog post.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改博客文章。
- en: Try navigating to another site (it should show a message box).
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个网站（应该会显示一个消息框）。
- en: Try navigating to another page. You might notice that, in our case, it doesn’t
    show a message box when we navigate to another page. What is up with that? It
    seems to be a limitation in how this component works. If we were running `InteractiveServer`
    or `InteractiveWebAssembly`, it would work. Navigation using static server rendering
    (which is what happens when we navigate) won’t trigger the navigation change.
    If we want to test this, we can change our project to run as Blazor Server.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个页面。你可能会注意到，在我们的情况下，当我们导航到另一个页面时，它不会显示一个消息框。这是怎么回事？这似乎是这个组件工作方式的一个限制。如果我们运行
    `InteractiveServer` 或 `InteractiveWebAssembly`，它就会工作。使用静态服务器端渲染的导航（这就是我们导航时发生的情况）不会触发导航更改。如果我们想测试这一点，我们可以将我们的项目更改为以
    Blazor 服务器模式运行。
- en: In the `BlazorWebApp` project, in the `Components` folder, open the `App.razor`
    file.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp` 项目中，在 `Components` 文件夹中，打开 `App.razor` 文件。
- en: 'Replace the following line:'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下行替换：
- en: '[PRE78]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将上一行替换为以下行：
- en: '[PRE79]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we can try it again:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以再次尝试：
- en: Run the site, navigate to `Admin/BlogPosts`, and click a blog post.
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行网站，导航到 `Admin/BlogPosts`，然后点击一篇博客文章。
- en: Try to navigate to another site (it should work).
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个网站（应该可以工作）。
- en: Try to navigate to another page (it should work).
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个页面（应该可以工作）。
- en: Change the blog post.
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改博客文章。
- en: Try navigating to another site (it should show a message box).
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个网站（应该会显示一个消息框）。
- en: Try navigating to another page (it should show a message box).
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试导航到另一个页面（应该会显示一个消息框）。
- en: Now, change it back to `<Routes />`.
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，将其改回 `<Routes />`。
- en: The point of this is to show that, in some cases, the built-in components will
    act differently depending on the render mode. I honestly think that this is a
    bug rather than a feature, but there are discussions about this.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是为了展示在某些情况下，内置组件的行为会根据渲染模式的不同而有所不同。我真诚地认为这与其说是一个特性，不如说是一个错误，但关于这一点有一些讨论。
- en: Awesome! We have implemented another reusable component. Next, let’s take a
    look at how we can use a form with a static server-side rendered component using
    enhanced form navigation.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们实现了另一个可重用组件。接下来，让我们看看如何使用增强表单导航来使用静态服务器端渲染组件。
- en: Enhanced Form Navigation
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强表单导航
- en: In .NET 8, we got server-side rendering. Adding interactivity to a component
    is simple, as we have seen. But sometimes we just want a form and a submit button.
    Do we really have to enable WebAssembly or a SignalR connection for this? I’m
    glad you asked! The answer is, no, we don’t.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 中，我们得到了服务器端渲染。正如我们所见，向组件添加交互性很简单。但有时我们只想有一个表单和一个提交按钮。我们真的需要启用 WebAssembly
    或 SignalR 连接来做到这一点吗？我很高兴你问了！答案是，不需要。
- en: 'Let’s add a component to showcase that our blog posts need comments:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个组件来展示我们的博客文章需要评论：
- en: 'In the `SharedComponents` project, in the `Pages` folder, add a new Razor component
    called `Comments.razor`. This component should do two things: list comments and
    create a new comment.'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，在 `Pages` 文件夹中，添加一个名为 `Comments.razor` 的新 Razor 组件。这个组件应该做两件事：列出评论和创建新的评论。
- en: 'In the `comments` file, replace the content with the following:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `comments` 文件中，将内容替换为以下内容：
- en: '[PRE80]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is a list of comments and some bootstrap classes to make it look better.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个评论列表和一些用于使其看起来更好的 Bootstrap 类。
- en: 'Continue by adding the form:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续添加表单：
- en: '[PRE81]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We are still using an `EditForm` just as before and an `OnValidSubmit` property.
    There are some things that are new here, though. We are specifying the method
    we are using to post the form – in this case, a post method. We are also naming
    the form with the `FormName` parameter. These two properties must be there. We
    are using the `DataAnnotationValidator` and the `CustomCssClassProvider` we created
    earlier. We are even using the `BlogInputText`. But since this component isn’t
    interactive, our button will not work as it is disabled by default, and if we
    remove the interactivity, it will stay disabled. So, in this case, we have to
    add a button the old-fashioned way. We can make sure that there is a non-interactive
    button for cases like this as well.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然像之前一样使用 `EditForm` 和 `OnValidSubmit` 属性。尽管如此，这里也有一些新内容。我们指定了用于提交表单的方法——在这种情况下，是一个
    POST 方法。我们还使用 `FormName` 参数命名表单。这两个属性必须存在。我们使用了之前创建的 `DataAnnotationValidator`
    和 `CustomCssClassProvider`。我们还使用了 `BlogInputText`。但由于这个组件不是交互式的，我们的按钮默认是禁用的，如果我们移除交互性，它将保持禁用状态。因此，在这种情况下，我们必须以传统方式添加一个按钮。我们可以确保在这种情况下也有一个非交互式按钮。
- en: 'Now it is time for the code part of the form:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在是时候编写表单的代码部分了：
- en: '[PRE82]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we are using a parameter so that our component knows what blog post to
    show comments for. It has `EditorRequired`, so Visual Studio will warn you if
    it is missing. The `Model` parameter has the `SupplyParameterFromForm` attribute,
    which is required. This is so Blazor knows what property to fill with data when
    the form is posted. The rest of the code is the same as the code we have used
    previously.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个参数，以便我们的组件知道要显示评论的博客文章。它有 `EditorRequired` 属性，因此如果缺少它，Visual Studio
    将会警告你。`Model` 参数具有 `SupplyParameterFromForm` 属性，这是必需的。这样Blazor就知道在表单提交时用数据填充哪个属性。其余的代码与之前我们使用的代码相同。
- en: 'Open `Post.cs` and add the following code just beneath the line @((MarkupString)Markdig.Markdown.ToHtml(BlogPost.Text,
    pipeline)):'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Post.cs` 文件，并在以下代码行下方添加以下代码：@((MarkupString)Markdig.Markdown.ToHtml(BlogPost.Text,
    pipeline))：
- en: '[PRE83]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: So, what is happening?
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么，发生了什么？
- en: When we submit our form, the component will be rerendered, creating a new instance
    of the component and filling the (in our case) `Model` parameter with the data
    from the post. With interactive components, `OnInitialized` and `OnInitializedAsync`
    will only run once (unless we are running prerendering). With these static components,
    it will reload the component. But we also get a “problem” because the scrolling
    positions get lost when the page reloads. We will now find ourselves at the top
    of the page, which is not a great user experience. Luckily, there is a solution;
    this is where the `Enhance` part comes in. By adding `Enhance` to our form, it
    will now keep its scroll position after posting the page. Pretty neat, right?
    We can also use a normal form instead of an `EditForm`.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们提交表单时，组件将被重新渲染，创建组件的新实例，并将（在我们的案例中）`Model` 参数填充为帖子的数据。对于交互式组件，`OnInitialized`
    和 `OnInitializedAsync` 只会运行一次（除非我们在运行预渲染）。对于这些静态组件，它将重新加载组件。但我们也遇到了一个问题，因为当页面重新加载时，滚动位置会丢失。我们现在会发现自己处于页面的顶部，这不是一个好的用户体验。幸运的是，有一个解决方案；这就是
    `Enhance` 部分发挥作用的地方。通过在我们的表单中添加 `Enhance`，它现在在提交页面后会保持其滚动位置。非常酷，对吧？我们也可以使用普通表单而不是
    `EditForm`。
- en: 'It would then look something like this:'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它看起来可能像这样：
- en: '[PRE84]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Instead of `Enhance`, we add `data-enhance`. Personally, I prefer to use an
    `EditForm` where I can, but it might be good to know that there are options.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不是添加 `Enhance`，而是添加 `data-enhance`。我个人更喜欢在可能的情况下使用 `EditForm`，但了解还有其他选项可能是个好主意。
- en: We can also use `data-permanent` to keep the information in the form fields
    for a search parameter, for example. This way, the enhanced navigation will not
    update that data when the response is returned. How many times have we used a
    search field, misspelled something, and then the search field is empty and we
    need to retype everything? This is where `data-permanent` saves us.
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以使用 `data-permanent` 来保持表单字段中的信息，例如用于搜索参数。这样，增强导航在响应返回时不会更新那些数据。我们有多少次使用搜索字段，拼写错误，然后搜索字段为空，我们需要重新输入所有内容？这就是
    `data-permanent` 帮助我们的地方。
- en: Amazing!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: This has been a heavy chapter, but wow, we have done so much – a whole bunch
    of new and reusable components and a complete admin interface.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这章内容很丰富，但哇，我们做了很多——一大堆新的可重用组件和完整的管理员界面。
- en: Summary
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught us how to create forms and make API calls to get and save
    data.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这章教会了我们如何创建表单并调用 API 来获取和保存数据。
- en: We built custom input controls and got Bootstrap styling on our controls. Most
    business apps use forms; we can add logic close to the data by annotating data.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了自定义输入控件，并给我们的控件添加了Bootstrap样式。大多数商业应用程序都使用表单；我们可以通过注释数据来在数据附近添加逻辑。
- en: We also created multiple reusable components and used many of the things we
    discussed in previous chapters. We even touched on JavaScript interop, which we
    will go into more detail about in *Chapter 10*, *JavaScript Interop*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了多个可重用组件，并使用了之前章节中讨论的许多内容。我们甚至触及了JavaScript互操作性的话题，我们将在*第10章*，*JavaScript互操作性*中对其进行更详细的介绍。
- en: The functionality that Blazor offers when it comes to validation and input controls
    will help us build amazing applications and give our users a great experience.
    You may notice that, right now, the admin pages are wide open. We need to secure
    our blog with a login, but we will come to that in *Chapter 8*, *Authentication
    and Authorization*.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor在验证和输入控件方面的功能将帮助我们构建令人惊叹的应用程序，并为我们的用户提供极佳的体验。你可能已经注意到，目前管理页面是开放的。我们需要通过登录来保护我们的博客，但这一点将在*第8章*，*认证和授权*中详细说明。
- en: In the next chapter, we will create a web API to get data when we are running
    components such as `InteractiveAuto` or `InteractiveWebAssembly`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个Web API，以便在运行`InteractiveAuto`或`InteractiveWebAssembly`等组件时获取数据。
