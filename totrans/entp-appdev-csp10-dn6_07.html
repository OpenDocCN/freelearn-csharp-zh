<html><head></head><body>
		<div id="_idContainer062">
			<h1 id="_idParaDest-103"><em class="italic"><a id="_idTextAnchor445"/>Chapter 5</em>: Dependency Injection in .NET 6</h1>
			<p>A big issue that an enterprise application can face is the complexity of wiring different elements together and managing their lifetimes. To address this, we use the <strong class="bold">inversion of control</strong> (<strong class="bold">IoC</strong>) principle, which recommends removing the dependency between objects. By delegating the flow of control, IoC makes the program extensible and increases the modularity. Events, callback delegates, the observer pattern, and <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) are some of the ways to achieve IoC.</p>
			<p>In this chapter, we will learn about the following:</p>
			<ul>
				<li>What is DI?</li>
				<li>DI in ASP.NET Core 6</li>
				<li>Managing application services</li>
				<li>Using third-party containers</li>
			</ul>
			<p>By the end of this chapter, you'll have a good idea about DI and how it's leveraged in .NET 6 applications, the types of scopes provided in ASP.NET Core 6, and how to leverage them in your projects.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor446"/>Technical requirements</h1>
			<p>The code used in this chapter can be found here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor447"/>What is DI?</h1>
			<p>DI is a technique <a id="_idIndexMarker354"/>in which an object receives objects that it depends on. The DI pattern fulfills the DI principle covered as part of the <strong class="bold">single-responsibility principle, open-closed principle, Liskov substitution principle, interface segregation principle, and dependency inversion principle</strong> (<strong class="bold">SOLID</strong>) design <a id="_idIndexMarker355"/>principles in <a href="B18507_01_Epub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing and Architecting the Enterprise Application</em>. With the use of DI, code will be more maintainable, readable, testable, and extensible.</p>
			<p>DI is one of the most well-known methods to help achieve better maintainable code. DI has three entities involved, as shown in the following diagram: </p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_5.1_B18507.jpg" alt="Figure 5.1 – DI relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – DI relationship</p>
			<p>The <strong class="bold">Injector</strong> creates <a id="_idIndexMarker356"/>an instance of <strong class="bold">Service</strong> and injects it into the <strong class="bold">Client</strong> object. The <strong class="bold">Client</strong> depends <a id="_idIndexMarker357"/>on the injected <strong class="bold">Service</strong> to <a id="_idIndexMarker358"/>perform its operations—for example, in the enterprise application that we are going to build, <strong class="source-inline">IOrderRepository</strong> is responsible for <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations <a id="_idIndexMarker359"/>on the <strong class="source-inline">Order</strong> entity. .NET IoC container (<strong class="bold">Injector</strong>) instantiates <strong class="source-inline">IOrderRepository</strong> (<strong class="bold">Service</strong>) and injects it into <strong class="source-inline">OrderController</strong> (client). </p>
			<p><strong class="bold">IoC container</strong> (also <a id="_idIndexMarker360"/>known as <strong class="bold">DI Container</strong>) is a framework for implementing <a id="_idIndexMarker361"/>automatic DI. In <em class="italic">Figure 5.1</em>, this is referred to as <strong class="bold">Injector</strong>. It is responsible for creating or referencing a dependency and injecting it into <strong class="bold">Client</strong>.</p>
			<p>Now that we have learned what DI is, let's learn about the types of DI.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor448"/>Types of DI</h2>
			<p>There are <a id="_idIndexMarker362"/>multiple ways a service can be injected into a dependency. Based on the way a service is injected into the client object, DI is categorized into three types, as outlined here:</p>
			<ul>
				<li><strong class="bold">Constructor injection</strong>: Dependencies are injected through a constructor while <a id="_idIndexMarker363"/>instantiating the <a id="_idIndexMarker364"/>dependent. In the following example, the <strong class="source-inline">IWeatherProvider</strong> dependency is injected through the constructor parameter:<p class="source-code">    public class WeatherService</p><p class="source-code">    {</p><p class="source-code">        private readonly IweatherProvider</p><p class="source-code">            weatherProvider;</p><p class="source-code"><strong class="bold">        public WeatherService(IWeatherProvider</strong></p><p class="source-code"><strong class="bold">            weatherProvider)</strong></p><p class="source-code"><strong class="bold">                =&gt; this.weatherProvider =</strong></p><p class="source-code"><strong class="bold">                    weatherProvider;</strong></p><p class="source-code">        public WeatherForecast GetForecast(string</p><p class="source-code">            location) =&gt;</p><p class="source-code">            this.weatherProvider.</p><p class="source-code">                GetForecastOfLocation (location);   </p><p class="source-code">    }</p></li>
			</ul>
			<p>In the preceding example, <strong class="source-inline">WeatherService</strong> is dependent on <strong class="source-inline">IWeatherProvider</strong>, which is injected via a constructor parameter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For an implementation of the <strong class="source-inline">WeatherProvider</strong> service, refer to the sample code from GitHub, which can be found at the following link: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs</a>.</p>
			<p><strong class="bold">Setter injection</strong>: In the <a id="_idIndexMarker365"/>case of setter injection, the dependent <a id="_idIndexMarker366"/>exposes a setter method or property that the injector uses to inject the dependency. This is also referred to as property injection. In the following example, the <strong class="source-inline">IWeatherProvider</strong> dependency is not set while initializing <strong class="source-inline">WeatherService2</strong>. It is set via the <strong class="source-inline">WeatherProvider</strong> property post object initialization:</p>
			<p class="source-code">    public class WeatherService2</p>
			<p class="source-code">    {</p>
			<p class="source-code">        private IWeatherProvider _weatherProvider;</p>
			<p class="source-code"><strong class="bold">        public IWeatherProvider WeatherProvider</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            get =&gt; _weatherProvider == null ?</strong></p>
			<p class="source-code"><strong class="bold">                        throw new</strong></p>
			<p class="source-code"><strong class="bold">                            InvalidOperationException(</strong></p>
			<p class="source-code"><strong class="bold">                            "WeatherService is not</strong></p>
			<p class="source-code"><strong class="bold">                            initialized")</strong></p>
			<p class="source-code"><strong class="bold">                    : _weatherProvider;</strong></p>
			<p class="source-code"><strong class="bold">            set =&gt; _weatherProvider = value;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">        public WeatherForecast GetForecast(string</p>
			<p class="source-code">            location) =&gt;</p>
			<p class="source-code">            this.WeatherProvider.</p>
			<p class="source-code">                GetForecastOfLocation(location);</p>
			<p class="source-code">    }</p>
			<ul>
				<li><strong class="bold">Method injection</strong>: Another <a id="_idIndexMarker367"/>way to inject a dependency <a id="_idIndexMarker368"/>is by passing it as a method parameter. In this example, the <strong class="source-inline">IWeatherProvider</strong> dependency is injected as a method parameter wherever required.</li>
			</ul>
			<p>In the following code snippet, the <strong class="source-inline">IWeatherProvider</strong> service is injected into <strong class="source-inline">WeatherService</strong> via the <strong class="source-inline">GetForecast</strong> method:</p>
			<p class="source-code">    public class WeatherService</p>
			<p class="source-code">    {</p>
			<p class="source-code">       <strong class="bold">public WeatherForecast GetForecast(</strong></p>
			<p class="source-code"><strong class="bold">           string location, IWeatherProvider</strong></p>
			<p class="source-code"><strong class="bold">           weatherProvider)</strong></p>
			<p class="source-code">        {</p>
			<p class="source-code">            if(weatherProvider == null)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                throw new ArgumentNullException(</p>
			<p class="source-code">                    nameof(weatherProvider));</p>
			<p class="source-code">            }</p>
			<p class="source-code">            return weatherProvider.</p>
			<p class="source-code">                GetForecastOfLocation (location);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>Here are some suggestions to help in choosing the type of DI:</p>
			<ul>
				<li>Use constructor injection when the class has a dependency without which the functionality won't work. </li>
				<li>Use constructor <a id="_idIndexMarker369"/>injection when the dependency is used in multiple functions in the class.</li>
				<li>Use property injection when the dependency can change after the class is instantiated. </li>
				<li>Use method injection when the implementation of the dependency changes with every call.</li>
			</ul>
			<p>In most cases, constructor injection will be used for clean and decoupled code, but depending on the need, we will also leverage method and property injection techniques.</p>
			<p>We have now learned the concepts of DI. Let's dive into what .NET 6 offers to achieve DI.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor449"/>DI in ASP.NET Core 6</h1>
			<p>.NET 6 comes <a id="_idIndexMarker370"/>with a built-in IoC container <a id="_idIndexMarker371"/>framework, which simplifies DI. This comes with the <strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong> NuGet package and the ASP.NET Core 6 framework itself relies heavily on this. To support DI, a container needs to support three basic actions on objects/services, as outlined here:</p>
			<ul>
				<li><strong class="bold">Registering</strong>: The <a id="_idIndexMarker372"/>container should have provisions to register dependencies. This will help to map the correct type to a class so that it can create the right dependency instance.</li>
				<li><strong class="bold">Resolving</strong>: The <a id="_idIndexMarker373"/>container should resolve dependencies by creating a dependency object and injecting it into the dependent instance. IoC container manages the creation of registered objects by passing in all the required dependencies.</li>
				<li><strong class="bold">Disposing</strong>: The <a id="_idIndexMarker374"/>container is responsible for managing the lifetime of dependencies created through it.</li>
			</ul>
			<p>In .NET 6, the following terms are used:</p>
			<ul>
				<li><strong class="bold">Service</strong>: Refers <a id="_idIndexMarker375"/>to a dependency managed by a container</li>
				<li><strong class="bold">Framework services</strong>: Refers <a id="_idIndexMarker376"/>to services provided by .NET 6 Framework—for example, <strong class="source-inline">IConfiguration</strong>, <strong class="source-inline">ILoggerFactory</strong>, <strong class="source-inline">IWebHostEnvironment</strong>, and so on</li>
				<li><strong class="bold">Application services</strong>: Refers <a id="_idIndexMarker377"/>to services that a developer creates to support application functionality—for example, the <strong class="source-inline">IWeatherProvider</strong> service that we used in the previous section</li>
			</ul>
			<p>For the application to start, the ASP.NET Core 6 framework injects a few dependencies, which are <a id="_idIndexMarker378"/>referred to as <strong class="bold">framework services</strong>. When you create an ASP.NET Core 6 web application, <strong class="source-inline">WebApplicationBuilder</strong> is injected with the required framework services such as <strong class="source-inline">IConfiguration</strong> and <strong class="source-inline">IWebHostEnvironment</strong>. When you try printing the registered services, as shown in the following code snippet (refer to the code from <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16</a>), we can list the framework services registered:</p>
			<pre class="source-code">foreach(var i in builder.Services.AsEnumerable())</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    Console.WriteLine($"{i.Lifetime} - {i.ServiceType.ToString()}");</pre>
			<pre class="source-code">}</pre>
			<p>In ASP.NET Core 6.0, the <strong class="source-inline">IWebHostEnvironment</strong> framework service is available from the <strong class="source-inline">builder.Environment</strong> property. Similarly, the configuration is available from the <strong class="source-inline">builder.Configuration</strong> property.</p>
			<p>ASP.NET Core 6 Runtime instantiates all the required framework services and registers them with IoC container. Starting with ASP.NET Core 6, they are available through properties of <strong class="source-inline">WebApplication</strong> and <strong class="source-inline">WebApplicationBuilder</strong> in <strong class="source-inline">Program.cs</strong>. These framework services can be injected into controllers and other services through any of the DI types we discussed in the previous section.</p>
			<p>Application <a id="_idIndexMarker379"/>services are services injected <a id="_idIndexMarker380"/>into the container by the developer. These services will be registered using the <strong class="source-inline">Services</strong> property of <strong class="source-inline">WebApplicationBuilder</strong>. The following code snippet shows how to register the <strong class="source-inline">IWeatherProvider</strong> application service with the container:</p>
			<pre class="source-code">builder.Services.AddScoped&lt;IWeatherProvider, WeatherProvider&gt;();</pre>
			<p>In the next section, we will learn about the lifetime of these services and how they are managed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, to learn about the code present in the <strong class="source-inline">Program.cs</strong> file.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor450"/>Understanding service lifetimes</h2>
			<p>When you register a service with a specified lifetime, the container will automatically dispose of the object according to the lifetime specified. There are three types of lifetimes available to use with Microsoft DI Container, as outlined here:</p>
			<ul>
				<li><strong class="bold">Transient</strong>: With this lifetime, an object is created every time it is requested from the <a id="_idIndexMarker381"/>service container. If the <a id="_idIndexMarker382"/>creation of a service is time-consuming, this may not be the right scope as it will add latency. The <strong class="source-inline">AddTransient</strong> extension method is used to register with this lifetime, as illustrated in the following code snippet: <p class="source-code"><strong class="bold">public static</strong> IServiceCollection AddTransient(<strong class="bold">this</strong></p><p class="source-code"><strong class="bold">   </strong> IServiceCollection services, Type serviceType);</p><p class="callout-heading">Note</p><p class="callout">A transient lifetime is normally used for stateless, lightweight services.</p></li>
				<li><strong class="bold">Singleton</strong>: A singleton lifetime allows the container to create an object only once <a id="_idIndexMarker383"/>per application <a id="_idIndexMarker384"/>life cycle, and we get the same object every time it is requested. An object is created when there is a first request to the service or when providing the implementation instance directly at the time of registration. Services registered as a singleton are disposed of when <strong class="source-inline">ServiceProvider</strong> is disposed of on application shutdown. The <strong class="source-inline">AddSingleton</strong> extension method is used to register with this lifetime, as illustrated in the following code snippet:<p class="source-code"><strong class="bold">public static</strong> IServiceCollection AddSingleton(<strong class="bold">this</strong></p><p class="source-code"><strong class="bold">   </strong> IServiceCollection services, Type serviceType);</p></li>
				<li><strong class="bold">Scoped</strong>: By <a id="_idIndexMarker385"/>using this lifetime, a service will be created only once <a id="_idIndexMarker386"/>in the client request scope. This is particularly used in ASP.NET Core 6 where an object instance is <a id="_idIndexMarker387"/>created once per <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request. Services such as <strong class="bold">Entity Framework Core's</strong> (<strong class="bold">EF Core's</strong>) <strong class="source-inline">DbContext</strong> are registered with a scoped lifetime. The <strong class="source-inline">AddScoped</strong> extension method is used to register with the scoped lifetime <a id="_idIndexMarker388"/>scope, as illustrated in the following code snippet:<p class="source-code"><strong class="bold">public static</strong> IServiceCollection AddScoped(<strong class="bold">this</strong></p><p class="source-code"><strong class="bold">   </strong> IServiceCollection services, Type serviceType);</p></li>
			</ul>
			<p>The lifetime type needs to be chosen wisely in application development. A service should not depend on a service that has a shorter life span than its own; for example, a service registered as a singleton should not depend on a service that is registered as transient. The following table shows which lifetimes can safely depend on which other lifetime scopes:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Table_5.1.jpg" alt="Figure 5.1 – DI relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.1 – Lifetime dependency</p>
			<p>As a <a id="_idIndexMarker389"/>developer, you need not worry about scope validation. Built-in scope validation is done in ASP.NET Core 6 when the environment is set to <strong class="bold">Development</strong>. In the case of misconfiguration, <strong class="source-inline">InvalidOperationException</strong> is thrown while building the application. This can be explicitly turned on by enabling <strong class="source-inline">ValidateScopes</strong> options for all environment configurations while registering <strong class="source-inline">ServiceProvider</strong>, as shown in the following code snippet. Here, while creating a host builder, <strong class="source-inline">ValidateScopes</strong> is set to <strong class="source-inline">true</strong> to turn on the scope validation:</p>
			<pre class="source-code">builder.Host.UseDefaultServiceProvider(opt =&gt; { opt.ValidateScopes = true; }); </pre>
			<p>Let's create an ASP.NET Core 6 web application to understand the service lifetime. We will be creating different services and registering them with the singleton, scoped, and transient lifetime scopes and observing how they behave. Proceed as follows:</p>
			<ol>
				<li>Create a <a id="_idIndexMarker390"/>new ASP.NET Core web application (<strong class="bold">Model-View-Controller</strong>, or <strong class="bold">MVC</strong>) and name it <strong class="source-inline">DISampleWeb</strong>.</li>
				<li>Create a new project folder with the name <strong class="source-inline">Services</strong> and add three classes: <strong class="source-inline">ScopedService</strong>, <strong class="source-inline">SingletonService</strong>, and <strong class="source-inline">TransientService</strong>. Add the following code (all these services will be the same without any real code in them; we just register them with different lifetime scopes as per their name):<p class="callout-heading">Note</p><p class="callout">In the <a id="_idIndexMarker391"/>following sample, the interface and the class are defined in a single file. This is done purely for demonstration purposes. Ideally, the interface and the class are to be defined in two different classes.</p><ul><li><strong class="source-inline">ScopedService.cs</strong>: This <a id="_idIndexMarker392"/>class will be registered with the scoped lifetime scope, as illustrated in the following code snippet:<p class="source-code">public interface IScopedService {     }</p><p class="source-code">public class ScopedService : IScopedService {    }</p></li><li><strong class="source-inline">SingletonService.cs</strong>: This class will be registered with the singleton lifetime <a id="_idIndexMarker393"/>scope, as illustrated in the following code snippet:<p class="source-code">public interface ISingletonService   {    }</p><p class="source-code">public class SingletonService : ISingletonService {  }</p></li><li><strong class="source-inline">TransientService.cs</strong>: This class will be registered with the transient lifetime <a id="_idIndexMarker394"/>scope, as illustrated in the following code snippet:<p class="source-code">public interface ITransientService   {    }</p><p class="source-code">public class TransientService : ITransientService{   }</p></li></ul></li>
				<li>Now, register these services in <strong class="source-inline">Program.cs</strong> with <strong class="source-inline">IServiceCollection</strong>, as shown here:<p class="source-code">//Register as Scoped</p><p class="source-code">builder.Services.AddScoped&lt;IScopedService,ScopedService&gt;();</p><p class="source-code">//Register as Singleton</p><p class="source-code">builder.Services.AddSingleton&lt;ISingletonService,SingletonService&gt;();</p><p class="source-code">//Register as Transient</p><p class="source-code">builder.Services.AddTransient&lt;ITransientService,TransientService&gt;();</p></li>
			</ol>
			<p>The collection of service descriptors, <strong class="source-inline">IServiceCollection</strong>, is exposed via the <strong class="source-inline">Services</strong> property of <strong class="source-inline">WebApplicationBuilder</strong>.</p>
			<ol>
				<li value="4">Now, add the <strong class="source-inline">HomeViewModel</strong> model class under the <strong class="source-inline">Models</strong> folder, which will be <a id="_idIndexMarker395"/>used to show data retrieved from the services registered previously. The following code snippet illustrates how to do this:<p class="source-code">public class HomeViewModel</p><p class="source-code">{</p><p class="source-code">        public int Singleton { get; set; }</p><p class="source-code">        public int Scoped { get; set; }</p><p class="source-code">        public int Scoped2 { get; internal set; }</p><p class="source-code">        public int Transient { get; set; }</p><p class="source-code">        public int Transient2 { get; internal set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>Since we registered <strong class="source-inline">ScopedService</strong>, <strong class="source-inline">SingletonService</strong>, and <strong class="source-inline">TransientService</strong> with ASP.NET Core 6 IoC container, we will get these services via constructor injection.</p>
			<ol>
				<li value="5">Now, we will add code to get these services in <strong class="source-inline">HomeController</strong> and <strong class="source-inline">Views</strong> to show data retrieved from these objects on the home page. Modify the home controller to get two instances of <strong class="source-inline">ScopedService</strong> and <strong class="source-inline">TransientService</strong> and set <strong class="source-inline">ViewModel</strong> with the object hash code of the service object. The solution structure is shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_5.2_B18507.jpg" alt="Figure 5.2 – Solution structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Solution structure</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">GetHashCode</strong> method <a id="_idIndexMarker396"/>returns the hash code of the object. This will change per instance.</p>
			<ol>
				<li value="6">Modify <a id="_idIndexMarker397"/>the constructor of <strong class="source-inline">HomeController</strong> to accept the registered services and define private fields to reference service instances, as follows:<p class="source-code">private readonly ILogger&lt;HomeController&gt; _logger;</p><p class="source-code">private readonly IScopedService scopedService;</p><p class="source-code">private readonly IScopedService scopedService2;</p><p class="source-code">private readonly ISingletonService singletonService;</p><p class="source-code">private readonly ITransientService transientService;</p><p class="source-code">private readonly ITransientService transientService2;</p><p class="source-code">public HomeController(ILogger&lt;HomeController&gt; logger,</p><p class="source-code">IScopedService scopedService,</p><p class="source-code">IScopedService scopedService2,</p><p class="source-code">ISingletonService singletonService,</p><p class="source-code">ITransientService transientService,</p><p class="source-code">ITransientService transientService2)</p><p class="source-code">{</p><p class="source-code">     this._logger = logger;</p><p class="source-code">     this.scopedService = scopedService;</p><p class="source-code">     this.scopedService2 = scopedService2;</p><p class="source-code">     this.singletonService = singletonService;</p><p class="source-code">     this.transientService = transientService;</p><p class="source-code">     this.transientService2 = transientService2;</p><p class="source-code">}</p></li>
				<li>Now, modify <a id="_idIndexMarker398"/>the <strong class="source-inline">Index</strong> method under <strong class="source-inline">HomeController</strong> to set <strong class="source-inline">HomeViewModel</strong>, as follows:<p class="source-code">public IActionResult Index()</p><p class="source-code">{</p><p class="source-code">      var viewModel = new HomeViewModel</p><p class="source-code">     {</p><p class="source-code">         Scoped = scopedService.GetHashCode(),</p><p class="source-code">         Scoped2 = scopedService2.GetHashCode(),</p><p class="source-code">         Singleton = singletonService.GetHashCode(),</p><p class="source-code">         Transient = transientService.GetHashCode(),</p><p class="source-code">         Transient2 = transientService2.GetHashCode(),</p><p class="source-code">      };</p><p class="source-code">      return View(viewModel);</p><p class="source-code">}</p></li>
				<li>Next, modify <strong class="source-inline">Index.cshtml</strong> under the <strong class="source-inline">~/Views/Home</strong> folder to show <strong class="source-inline">HomeViewModel</strong> on <a id="_idIndexMarker399"/>the page, as follows:<p class="source-code">@model HomeViewModel</p><p class="source-code">@{</p><p class="source-code">    ViewData["Title"] = "Home Page";</p><p class="source-code">}</p><p class="source-code">&lt;h2 class="text-success"&gt;Singleton.&lt;/h2&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Singleton</p><p class="source-code">&lt;/code&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;h2 class="text-success"&gt;Scoped instance 1&lt;/h2&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Scoped&lt;/code&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;h2 class="text-success"&gt;Scoped instance 2&lt;/h2&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Scoped2&lt;/code&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;h2 class="text-success"&gt;Transient instance 1&lt;/h2&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Transient&lt;/code&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;h2 class="text-success"&gt;Transient instance 2&lt;/h2&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Transient2&lt;/code&gt;</p><p class="source-code">&lt;/p&gt;</p></li>
				<li>Now, run <a id="_idIndexMarker400"/>the application. You will see an output like this:</li>
			</ol>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_5.3_B18507.jpg" alt="Figure 5.3 – Sample output on the first run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Sample output on the first run</p>
			<p>If we observe the output, the <strong class="bold">identifiers</strong> (<strong class="bold">IDs</strong>) displayed for both instances of <strong class="source-inline">ScopedService</strong> are the same. This is because only one object for <strong class="source-inline">IScopedService</strong> is created per request scope. Please note the IDs may be different when you run the code as they are generated at runtime.</p>
			<p>The IDs of the transient service are different for both services. As we learned, this is because a new instance is created for every request to IoC container.</p>
			<ol>
				<li value="10">Now, refresh <a id="_idIndexMarker401"/>the page again. You'll see an output that looks something like this:</li>
			</ol>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_5.4_B18507.jpg" alt="Figure 5.4 – Sample output on the second run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Sample output on the second run</p>
			<p>If we compare the outputs in both <em class="italic">Figure 5.3</em> and <em class="italic">Figure 5.4</em>, we will notice that the ID of <strong class="source-inline">SingletonService</strong> did not change—this is because only one object is created for a singleton object per lifetime of the application. Up until now, we have seen how the service lifetime is managed based on the registration. It is also important to understand when objects are to be disposed of. In the next section, we will learn about the disposal of services.</p>
			<h3>Disposal of services</h3>
			<p>As we learned earlier in this chapter, the disposal of objects is the responsibility of the IoC container framework. The container calls the <strong class="source-inline">Dispose</strong> method on those services that implement <strong class="source-inline">IDisposable</strong>. Services created by the container should never be disposed of by the developer explicitly. Similarly, developers are responsible for disposing of instances created by them.</p>
			<p>Consider the <a id="_idIndexMarker402"/>following code snippet, where the <strong class="source-inline">SingletonService</strong> instance is registered with the singleton scope:</p>
			<pre class="source-code">var _disposableSingletonService= new DisposableSingletonService();</pre>
			<pre class="source-code">// Registering an instance of a class with singleton lifetime</pre>
			<pre class="source-code">builder.Services.AddSingleton&lt;IDisposableSingletonService&gt;(_disposableSingletonService);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">For a simple implementation of <strong class="source-inline">DisposableSingletonService</strong>, refer to the code at the following link: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs</a>.</p>
			<p>In the preceding code snippet, we created an object of <strong class="source-inline">DisposableSingletonService</strong> and registered it with IoC container. The service instance is not created by the container. In this case, IoC Container does not dispose of the object; it is the developer's responsibility to dispose of it. We can dispose of objects when an <strong class="source-inline">ApplicationStopping</strong> event is fired from <strong class="source-inline">IHostApplicationLifetime</strong>, which is exposed through the <strong class="source-inline">Lifetime</strong> property of <strong class="source-inline">WebApplication</strong>, as shown in the following code snippet:</p>
			<pre class="source-code">app.Lifetime.ApplicationStopping.Register(() =&gt; {</pre>
			<pre class="source-code">    _disposableSingletonService.Dispose();</pre>
			<pre class="source-code">});</pre>
			<p>In the preceding code snippet, <strong class="source-inline">IHostApplicationLifetime</strong> is injected by the runtime into <strong class="source-inline">WebApplication</strong>. This interface allows consumers to be notified of <strong class="source-inline">ApplicationStarted</strong>, <strong class="source-inline">ApplicationStopped</strong>, and <strong class="source-inline">ApplicationStopping</strong> application lifetime events. To dispose of the singleton object, we will call a Dispose() method by registering to the <strong class="source-inline">ApplicationStopping</strong> lifetime event.</p>
			<p>A new addition in .NET 6 to DI is the support of <strong class="source-inline">IAsyncDisposable</strong> for scopes. A new <strong class="source-inline">CreateAsyncScope</strong> extension method is added to <strong class="source-inline">IServiceProvider</strong> to support the <a id="_idIndexMarker403"/>creation of an asynchronous service scope, and an <strong class="source-inline">AsyncServiceScope</strong> wrapper is added, which implements <strong class="source-inline">IAsyncDisposable</strong>. The following code disposes of the scopes asynchronously:</p>
			<pre class="source-code">// Refer AsyncDisposableScope sample code for the implementation</pre>
			<pre class="source-code">await using (var scope = provider.CreateAsyncScope())</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    var foo = scope.ServiceProvider.GetRequiredService&lt;IWeatherProviderAsync&gt;();</pre>
			<pre class="source-code">} </pre>
			<p>Going forward, if the <a id="_idIndexMarker404"/>dependency <strong class="bold">service provider</strong> (<strong class="bold">SP</strong>) supports this, it is recommended to use <strong class="source-inline">CreateAsyncScope</strong> wherever you are creating scopes manually. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to the <a id="_idIndexMarker405"/>following Microsoft documentation to learn more about DI guidelines: </p>
			<p class="callout"><a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines">https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines</a></p>
			<p>Up until now, we have looked at service lifetimes and how they are disposed of in .NET 6. In the next section, we will learn about managing application services.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor451"/>Managing application services</h2>
			<p>In ASP.NET Core 6, when a request is received by <strong class="source-inline">MvcMiddleware</strong>, routing is used to select a <a id="_idIndexMarker406"/>controller and action method. <strong class="source-inline">IControllerActivator</strong> creates an instance of the controller and loads constructor arguments from DI Container.</p>
			<p>In the <em class="italic">Understanding service lifetimes</em> section, we saw how application services are registered and how their lifetimes are managed. In the example, the services were injected through a constructor, which is known as constructor injection. In this section, we will see how to achieve method injection and go through different ways application services can be registered and accessed in ASP.NET Core 6 IoC container.</p>
			<h3>Accessing registered services via method injection</h3>
			<p>In <a id="_idIndexMarker407"/>the previous sections, we saw how the dependency service is injected into the controller constructor <a id="_idIndexMarker408"/>and the reference is stored in a local field that is used to call a method/<strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) of the dependency.</p>
			<p>Sometimes, we don't want the dependency service to be available in all actions of the controller. In such scenarios, the service can be injected via method injection. This is done by making a parameter with the <strong class="source-inline">[FromServices]</strong> attribute, as shown in the following example:</p>
			<pre class="source-code">public IActionResult Index(<strong class="bold">[FromServices]</strong> ISingletonService singletonService2)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">}</pre>
			<p>Minimal APIs introduced in ASP.NET Core 6 allow us to request DI services in route handlers without explicitly marking them with the <strong class="source-inline">[FromServices]</strong> attribute, as illustrated here:</p>
			<pre class="source-code">app.MapGet("/", (ISingletonService service) =&gt; service.DoAction());</pre>
			<p>You might be wondering how the runtime differentiates injected services from other parameters. To achieve that, .NET6 introduced a new <strong class="source-inline">IServiceProviderIsService</strong> interface, which helps to identify that a given service <a id="_idIndexMarker409"/>type is registered in the DI container without creating an instance of it.</p>
			<p>In the next section, we will see the registration of multiple instances for the same service type and how to access them.</p>
			<h3>Registering multiple instances</h3>
			<p>For a given <a id="_idIndexMarker410"/>interface, we can register multiple implementations with the IoC container. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If more than one implementation is registered with the same service type, the last registration will take precedence over all previous registrations.</p>
			<p>Consider the following service registration, where the <strong class="source-inline">IWeatherForecastService</strong> service is registered with two implementations—<strong class="source-inline">WeatherForecastService</strong> and <strong class="source-inline">WeatherForecastServiceV2</strong>:</p>
			<pre class="source-code">services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
			<pre class="source-code">services.AddScoped&lt;IWeatherForecastService, WeatherForecastServiceV2&gt;();</pre>
			<p>Now, when there is a request for an instance of <strong class="source-inline">IWeatherForecastService</strong> from the controller, an instance of <strong class="source-inline">WeatherForecastServiceV2</strong> will be served, as illustrated in the following code snippet:</p>
			<pre class="source-code">private readonly IWeatherForecastService weatherForecastService;</pre>
			<pre class="source-code">public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger, IWeatherForecastService weatherForecastService)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      _logger = logger;</pre>
			<pre class="source-code">      this.weatherForecastService = weatherForecastService;</pre>
			<pre class="source-code">}</pre>
			<p>In the <a id="_idIndexMarker411"/>previous example, it might appear that the registration of <strong class="source-inline">WeatherForecastV2</strong> is overwriting the previous registration of <strong class="source-inline">WeatherForecastService</strong>. However, ASP.NET Core 6 IoC container will have all registrations of <strong class="source-inline">IWeatherForecastService</strong>. To get all registrations, fetch the service as <strong class="source-inline">IEnumerable</strong>, as follows:</p>
			<pre class="source-code">private readonly IEnumerable&lt;IWeatherForecastService&gt; weatherForecastServices;</pre>
			<pre class="source-code">public WeatherForecastController(</pre>
			<pre class="source-code">ILogger&lt;WeatherForecastController&gt; logger, IEnumerable&lt;IWeatherForecastService&gt; weatherForecastServices)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   _logger = logger;</pre>
			<pre class="source-code">   this.weatherForecastServices = weatherForecastServices;</pre>
			<pre class="source-code">}</pre>
			<p>This may be useful in scenarios such as executing a <strong class="bold">rules engine</strong>, where we want to run through all rules before we process a request. A set of rules will be configured through the <strong class="source-inline">Services</strong> property of <strong class="source-inline">WebApplicationBuilder</strong>. So, in the future, when there is an addition of a rule or the removal of an existing rule, the change will only be to inject a new service into the <strong class="source-inline">Services</strong> property.</p>
			<h3>Using TryAdd</h3>
			<p>In this <a id="_idIndexMarker412"/>section, we will learn about how we can avoid accidentally overriding already registered services.</p>
			<p>The <strong class="source-inline">TryAdd</strong> extension method registers services only when no registration exists for the same service. The <strong class="source-inline">TryAdd</strong> extension method is available for all lifetime scopes (<strong class="source-inline">TyrAddScoped</strong>, <strong class="source-inline">TryAddSingleton</strong>, and <strong class="source-inline">TryAddTransient</strong>).</p>
			<p>With the service registration shown in the following code snippet, when there is a request for <strong class="source-inline">IWeatherForecastService</strong>, IoC container serves <strong class="source-inline">WeatherForecastService</strong>, not <strong class="source-inline">WeatherForecastServiceV2</strong>:</p>
			<pre class="source-code">services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
			<pre class="source-code">services.TryAddScoped&lt;IWeatherForecastService, WeatherForecastServiceV2&gt;();</pre>
			<p>To overcome <a id="_idIndexMarker413"/>side effects that might occur with duplicate registrations, it is always recommended to use <strong class="source-inline">TryAdd</strong> extension methods to register a service.</p>
			<p>Now, let's see how to replace an already registered service.</p>
			<h3>Replacing an existing registration</h3>
			<p>ASP.NET <a id="_idIndexMarker414"/>Core 6 IoC container provides a way to replace existing registrations. In the following example, <strong class="source-inline">IWeatherForecastService</strong> is initially registered with <strong class="source-inline">WeatherForecastService</strong>. It is then replaced with <strong class="source-inline">WeatherForecastServiceV2</strong>:</p>
			<pre class="source-code">builder.Services.TryAddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
			<pre class="source-code">builder.Services.Replace(ServiceDescriptor.Scoped&lt;IWeatherForecastService, WeatherForecastServiceV2&gt;());</pre>
			<p>As with the <strong class="source-inline">Replace</strong> instance of <strong class="source-inline">WeatherForecastServiceV2</strong>, an implementation is served to the constructor of <strong class="source-inline">WeatherForecastController</strong>. In the following code snippet, unlike in the <em class="italic">Registering multiple instances</em> section, we will only see one object in the <strong class="source-inline">weatherForecastService</strong> constructor variable:</p>
			<pre class="source-code">public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger, IEnumerable&lt;IWeatherForecastService&gt; weatherForecastService)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      _logger = logger;</pre>
			<pre class="source-code">      this.weatherForecastService = weatherForecastService;</pre>
			<pre class="source-code">}</pre>
			<p>Till now in this section, we have learned about registering and replacing services with the IoC container. There may be times when we need to delete current registrations. Consider <a id="_idIndexMarker415"/>a scenario where you wish to utilize services and registrations from a library but you don't have access to its source code. If you reimplement some of the interfaces from that library and reregister them with the container, you might see some unexpected behavior. In the next section, we will see how to remove a registered service.</p>
			<h3>Removing an existing registration</h3>
			<p>To remove <a id="_idIndexMarker416"/>an existing registration,  ASP.Net Core 6 IoC container provides the <strong class="source-inline">Remove</strong> extension. You can use the <strong class="source-inline">RemoveAll</strong> method to remove all registrations related to a service, as seen in the following code snippet:</p>
			<pre class="source-code">services.RemoveAll&lt;IWeatherForecastService&gt;();</pre>
			<p>In the following code snippet, the <strong class="source-inline">Remove</strong> method removes the registration of the <strong class="source-inline">WeatherForecastService</strong> implementation from the container:</p>
			<pre class="source-code">//Removes the first registration of IWeatherForecastService           </pre>
			<pre class="source-code">Builder.Services.Remove(ServiceDescriptor.Scoped&lt;IWeatherForecastService, WeatherForecastService&gt;());</pre>
			<p>Up until now, we have seen how we work with complex services, but when it comes to generic open types, it will be difficult to register every generic constructed type. In the next section, we will learn how to deal with generic open-type services.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn more about generic types, you can refer to the following website: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types</a>.</p>
			<h3>Registering generics</h3>
			<p>This section will introduce you to dealing with generic-type services with DI.</p>
			<p>In the <a id="_idIndexMarker417"/>case of generic types, it does not make sense to register the service for each type of implementation that is in use. ASP.NET Core 6 IoC container provides a way to simplify the registration of the generic type. One such type that is already provided by the framework itself is <strong class="source-inline">ILogger</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">Builder.Services.TryAdd(ServiceDescriptor.Singleton(typeof(ILogger&lt;&gt;), typeof(Logger&lt;&gt;))); </pre>
			<p class="callout-heading">Note</p>
			<p class="callout">For your reference, you may visit the following link: <a href="https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs">https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs</a>.</p>
			<p>Another use case for generics is with a generic repository pattern used with the data access layer.</p>
			<p>With all the registrations we have, the <strong class="source-inline">ConfigureServices</strong> method can grow big and can no longer be readable. The next section will help you learn how to address that.</p>
			<h3>Extension methods for code readability</h3>
			<p>The pattern that is followed in the ASP.NET Core 6 framework to make code look more readable <a id="_idIndexMarker418"/>is to create an extension method with a logical grouping of service registrations. The following code tries to group and register notification-related services using an extension method. General practice is to use the <strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong> namespace to define service registration extension methods. This will make the developer use all the functionality related to DI just by using the <strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong> namespace.</p>
			<p>In the following code snippet, notification-related services were registered with <strong class="source-inline">AddNotificationServices</strong>:</p>
			<pre class="source-code">namespace Microsoft.Extensions.DependencyInjection</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public static class NotificationServicesServiceCollectionExtension</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   public static IServiceCollection AddNotificationServices(this IServiceCollection services)</pre>
			<pre class="source-code">  {</pre>
			<pre class="source-code">       <strong class="bold">services.TryAddScoped&lt;INotificationService, EmailNotificationService&gt;();</strong></pre>
			<pre class="source-code"><strong class="bold">       services.TryAddScoped&lt;INotificationService, SMSNotificationService&gt;();</strong></pre>
			<pre class="source-code"><strong class="bold">        return services;</strong></pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Now <a id="_idIndexMarker419"/>that the extension method is created, we can use the <strong class="source-inline">AddNotificationServices</strong> method to register notification services under <strong class="source-inline">ConfigureServices</strong>. This will make <strong class="source-inline">ConfigureServices</strong> become more readable. The code is illustrated here:</p>
			<pre class="source-code">builder.Services.AddNotificationServices();</pre>
			<p>We have seen how to inject services into controllers and other classes. In the next section, we will learn how to inject services into views.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor452"/>DI in Razor Pages</h2>
			<p>The purpose of views in MVC is to display data. Most of the time, data displayed in views is <a id="_idIndexMarker420"/>passed from the controller. Passing <a id="_idIndexMarker421"/>all required data from controllers is recommended <a id="_idIndexMarker422"/>considering the <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>) principle, but there may be cases where we want to view specific services from pages such as localization and telemetry services. Using DI supported by Razor views, we can inject such services into views.</p>
			<p>To learn about injecting services into views, let's modify the <strong class="source-inline">DISampleWeb</strong> application that we created in previous chapters. We will be modifying the <strong class="source-inline">DISampleWeb</strong> application to display additional content on the home page if a flight flag is set. Add the <strong class="source-inline">isFlightOn</strong> configuration, as shown in the following code snippet, to <strong class="source-inline">appsettings.json</strong>:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "AllowedHosts": "*",</pre>
			<pre class="source-code"><strong class="bold">  "isFlightOn": "true"</strong></pre>
			<pre class="source-code">}</pre>
			<p>Now, modify the index view under <strong class="source-inline">Home</strong> to display the content under <strong class="source-inline">Flight</strong>, as shown in the following code snippet:</p>
			<pre class="source-code">@using Microsoft.Extensions.Configuration</pre>
			<pre class="source-code">@inject Iconfiguration Configuration</pre>
			<pre class="source-code">@{</pre>
			<pre class="source-code">   string isFlightOn = Configuration["isFlightOn"];</pre>
			<pre class="source-code">   if (string.Equals(isFlightOn, "true", StringComparison.OrdinalIgnoreCase))</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">       &lt;h1&gt;</pre>
			<pre class="source-code">        &lt;strong&gt;Flight content&lt;/strong&gt;</pre>
			<pre class="source-code">       &lt;/h1&gt;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <strong class="source-inline">Iconfiguration</strong> service, which provides the functionality of reading the configuration file, is injected into the Razor view using the <strong class="source-inline">@inject</strong> keyword. The injected <a id="_idIndexMarker423"/>configuration service is used to get the <a id="_idIndexMarker424"/>configuration and display additional content based on the settings. We can inject any service registered with <strong class="source-inline">IserviceCollection</strong> into Razor views using the <strong class="source-inline">@inject</strong> keyword.</p>
			<p>Up until now, we have seen how we can leverage the .NET 6 built-in IoC container. In the next section, we will learn about leveraging third-party containers.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor453"/>Using third-party containers</h1>
			<p>Though the built-in container is sufficient for most of our scenarios, .NET 6 provides a way to <a id="_idIndexMarker425"/>integrate with third-party containers that can be leveraged if need be.</p>
			<p>Let's have a closer look at how the framework wires up the services. When the <strong class="source-inline">Startup</strong> class is registered with <strong class="source-inline">HostBuilder</strong> in <strong class="source-inline">Program.cs</strong>, .NET Framework uses reflection to identify and call the <strong class="source-inline">Configure</strong> and <strong class="source-inline">ConfigureServices</strong> methods.</p>
			<p>Here is a snippet from the <strong class="source-inline">LoadMethods</strong> method of the <strong class="source-inline">StartupLoader</strong> class in ASP.NET Core 6 (refer to the code from <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs">https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs</a>):</p>
			<pre class="source-code">public static StartupMethods LoadMethods(IServiceProvider hostingServiceProvider, [DynamicallyAccessedMembers(StartupLinkerOptions.Accessibility)] Type startupType, string environmentName, object? instance = null)</pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">    var configureMethod = FindConfigureDelegate(startupType, environmentName);</pre>
			<pre class="source-code">    var servicesMethod = FindConfigureServicesDelegate(startupType, environmentName);</pre>
			<pre class="source-code">    var configureContainerMethod = FindConfigureContainerDelegate(startupType, environmentName);</pre>
			<pre class="source-code">     -----------------------</pre>
			<pre class="source-code">}</pre>
			<p>From the <a id="_idIndexMarker426"/>preceding code snippet, we can see that the first two methods, <strong class="source-inline">FindConfigureDelegate</strong> and <strong class="source-inline">FindConfigureServicesDelegate</strong>, are to find the <strong class="source-inline">Configure</strong> and <strong class="source-inline">ConfigureServices</strong> methods.</p>
			<p>The last line is for <strong class="source-inline">ConfigureContainer</strong>. We can define a <strong class="source-inline">ConfigureContainer</strong> method in the <strong class="source-inline">Startup</strong> class to configure the services into a third-party container.</p>
			<p>Here are some of the popular DI frameworks available for ASP.NET Core 6:</p>
			<ul>
				<li><strong class="bold">Unity</strong>: Unity <a id="_idIndexMarker427"/>was initially built by Microsoft <a id="_idIndexMarker428"/>and is currently open sourced. This is one of the oldest <a id="_idIndexMarker429"/>DI containers for .NET. The documentation is available at the following link: <a href="http://unitycontainer.org/">http://unitycontainer.org/</a>.</li>
				<li><strong class="bold">Autofac</strong>: This <a id="_idIndexMarker430"/>is one of the most <a id="_idIndexMarker431"/>popular DI containers. It has comprehensive documentation <a id="_idIndexMarker432"/>available at the following link: <a href="https://autofaccn.readthedocs.io/en/latest/index.html">https://autofaccn.readthedocs.io/en/latest/index.html</a>.</li>
				<li><strong class="bold">Simple Injector</strong>: This <a id="_idIndexMarker433"/>is one <a id="_idIndexMarker434"/>of the late entrants on the list. The documentation <a id="_idIndexMarker435"/>can be found at the following link: <a href="https://simpleinjector.readthedocs.io/en/latest/index.html">https://simpleinjector.readthedocs.io/en/latest/index.html</a>.</li>
				<li><strong class="bold">Castle Windsor</strong>: This <a id="_idIndexMarker436"/>is one <a id="_idIndexMarker437"/>of the oldest DI frameworks available for .NET. See <a id="_idIndexMarker438"/>its documentation at the following link: <a href="http://www.castleproject.org/projects/windsor/">http://www.castleproject.org/projects/windsor/</a>.</li>
			</ul>
			<p>Though there are a few differences between these frameworks, there is generally feature parity. It is mostly the developer's experience that determines the choice of framework.</p>
			<p>In the next section, let's see how to leverage the Autofac third-party IoC container.</p>
			<h3>Autofac IoC container</h3>
			<p>Autofac is one <a id="_idIndexMarker439"/>of the most popular IoC containers among the developer community. As with any other IoC container, it manages dependencies between <a id="_idIndexMarker440"/>classes so that applications remain easy to change as they grow in complexity and size. Let's learn how to use Autofac to register the same <strong class="source-inline">WeatherProvider</strong> service that we used earlier in this chapter. Proceed as follows:</p>
			<ol>
				<li value="1">Create a new project using the ASP.NET Core web API template and name it <strong class="source-inline">AutofacSample</strong>.</li>
				<li>Add the <strong class="source-inline">Autofac.Extensions.DependencyInjection</strong> NuGet package reference to the <strong class="source-inline">AutofacSample</strong> project, as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_5.5_B18507.jpg" alt="Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package</p>
			<ol>
				<li value="3">We need to register <strong class="source-inline">AutofacServiceProviderFactory</strong> with <strong class="source-inline">ConfigureHostBuilder</strong> so that the runtime will use the Autofac IoC container. In <strong class="source-inline">Program.cs</strong>, register the Autofac SP factory, as shown in the following code snippet:<p class="source-code">builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());</p></li>
				<li>Now, let's register the <strong class="source-inline">IWeatherProvider</strong> service that we used in the <em class="italic">Types of DI</em> section with the Autofac container. Call the <strong class="source-inline">ConfigureContainer</strong> method on the <strong class="source-inline">ConfigureHostBuilder</strong> property of <strong class="source-inline">WebApplicationBuilder</strong> in <strong class="source-inline">Program.cs</strong> to register <strong class="source-inline">IWeatherProvider</strong> with the <strong class="source-inline">WeatherProvider</strong> implementation, as follows:<p class="source-code">builder.Host.ConfigureContainer&lt;ContainerBuilder&gt;(builder =&gt;</p><p class="source-code">{</p><p class="source-code">    builder.RegisterType&lt;WeatherProvider&gt;()</p><p class="source-code">                    .As&lt;IWeatherProvider&gt;();</p><p class="source-code">});</p></li>
				<li>Similar to the <a id="_idIndexMarker441"/>default .NET IoC container, we get the <strong class="source-inline">IWeatherForecast</strong> service injected into the <strong class="source-inline">WeatherForecastController</strong> controller, as shown in the following code snippet:<p class="source-code">public class WeatherForecastController : ControllerBase</p><p class="source-code">{</p><p class="source-code">        private readonly ILogger&lt;WeatherForecastController&gt; _logger;</p><p class="source-code">        <strong class="bold">private readonly IWeatherProvider weatherProvider;</strong></p><p class="source-code">        public WeatherForecastController( ILogger&lt;WeatherForecastController&gt; logger,</p><p class="source-code"><strong class="bold">IWeatherProvider weatherProvider</strong>)</p><p class="source-code">        {</p><p class="source-code">            _logger = logger;</p><p class="source-code">            <strong class="bold">this.weatherProvider = weatherProvider;</strong></p><p class="source-code">        }</p><p class="source-code">        [HttpGet]</p><p class="source-code">        public IEnumerable&lt;WeatherForecast&gt; Get()</p><p class="source-code">        {</p><p class="source-code">            <strong class="bold">return weatherProvider.GetForecast();</strong></p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, when <a id="_idIndexMarker442"/>you run the project and navigate to the <strong class="source-inline">https://localhost:7184/WeatherForecast</strong> <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>), you will <a id="_idIndexMarker443"/>see the output in the browser, as follows:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_5.6_B18507.jpg" alt="Figure 5.6 – Final output for the container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Final output for the container</p>
			<p>In the previous example, we have seen the use of the third-party Autofac IoC container in place of the default container provided by .NET 6.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor454"/>Summary</h1>
			<p>This chapter introduced you to the concepts of DI, which helps to write loosely coupled, more testable, and more readable code. This chapter covered the types of DI and how they are supported in ASP.NET Core 6. We have also seen how object lifetime is managed with different types of registrations. This chapter also introduced you to some of the popular third-party IoC containers available to further explore. We will be using the concepts learned in this chapter to build our e-commerce application. In <a href="B18507_15_Epub.xhtml#_idTextAnchor1803"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing</em>, we will also see how DI can help with testability.</p>
			<p>As recommended in <a href="B18507_01_Epub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing and Architecting the Enterprise Application</em>, under the <em class="italic">Separation of concerns/single - responsibility architecture</em> section, we always try to have services registered via interfaces. This will help with changing the concrete implementation at any time without changing the client implementation.</p>
			<p>In the next chapter, we will learn how to configure .NET 6 and understand the different configurations while learning how to build a custom one.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor455"/>Questions</h1>
			<ol>
				<li value="1">Which of the following is not a framework service?</li>
			</ol>
			<p>a. <strong class="source-inline">IConfiguration</strong></p>
			<p>b. <strong class="source-inline">IApplicationBuilder</strong></p>
			<p>c. <strong class="source-inline">IWeatherService</strong></p>
			<p>d. <strong class="source-inline">IWebHostEnvironment</strong></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="2">True or false: DI is one of the mechanisms to achieve IoC.</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="3">True or false: An injected service can depend on a service that has a shorter life span than its own.</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="4">Which of the following is not a valid lifetime scope of ASP.<a id="_idTextAnchor456"/><a id="_idTextAnchor457"/><a id="_idTextAnchor458"/><a id="_idTextAnchor459"/><a id="_idTextAnchor460"/><a id="_idTextAnchor461"/><a id="_idTextAnchor462"/><a id="_idTextAnchor463"/><a id="_idTextAnchor464"/><a id="_idTextAnchor465"/><a id="_idTextAnchor466"/><a id="_idTextAnchor467"/><a id="_idTextAnchor468"/><a id="_idTextAnchor469"/><a id="_idTextAnchor470"/>NET Core 6 IoC container?</li>
			</ol>
			<p>a. Scoped</p>
			<p>b. Singleton</p>
			<p>c. Transient</p>
			<p>d. Dynamic</p>
			<p><strong class="bold">Answer: d</strong></p>
		</div>
	</body></html>