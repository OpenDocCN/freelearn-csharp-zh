<html><head></head><body>
		<div><h1 id="_idParaDest-35" class="chapter-number"><a id="_idTextAnchor035"/>3</h1>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Basic Concepts of Console Applications in .NET</h1>
			<p>Now that our development environment has been set up, it’s time to start our journey through the development of CLI applications using .NET.</p>
			<p>However, first, we will explore console applications!</p>
			<p>You’re probably familiar with console applications, and you may be wondering why we need to discuss console applications in a book dedicated to CLI applications. The reason is that at the core of every CLI application is a console application. That’s why, in this chapter, we’ll take a moment to explore console applications. Plus, you know what they say: a reminder never hurts 😉.</p>
			<p>Console applications can be seen as the simplest CLI applications one can build.</p>
			<p>Hence, by exploring how we create, run, and interact with a console application, we will gain a basic understanding of how to work with CLI applications and how to build them by leveraging the console application template provided with the .NET SDK.</p>
			<p>We will then create a very simple .NET console application, which takes some arguments as input and displays a message as an output. We will then enhance this application so it can perform some basic validations on the inputs and display the appropriate message as an output. This message will be displayed in a given color, depending on its severity.</p>
			<p>Specifically, the chapter covers the following topics:</p>
			<ul>
				<li>Learn how to create and execute console applications</li>
				<li>Leverage the <code>System.Console</code> class for reading user input and outputting responses</li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole</a>.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>Creating (and executing) a simple console application</h1>
			<p>Let’s start by opening Visual Studio Code and displaying the integrated terminal window by going to <strong class="bold">View</strong> | <strong class="bold">Terminal</strong>.</p>
			<p>Next, position<a id="_idIndexMarker065"/> yourself where you want the code folder to be created (I always create a <code>code</code> folder in my <code>C:</code> drive where all my code folders are located; I find it convenient to centralize all my code at the same location).</p>
			<p>After ensuring that you are in the right working directory, type the following command to create a .NET console application:</p>
			<pre class="console">
$ dotnet new console -n helloConsole -o helloConsole --use-program-main</pre>			<p>Let’s break down this command to understand what it does:</p>
			<ul>
				<li><code>dotnet new console</code>: This will ask the .NET CLI tool to create a new console application. This will use C# as a language and .NET 8 as a framework (since these are the default values).</li>
				<li><code>-n helloConsole</code>: Our application will be named <code>helloConsole</code>.</li>
				<li><code>-o helloConsole</code>: A <code>helloConsole</code> folder will be created that will contain all the code files for our application.</li>
				<li> <code>--use-program-main</code>: The <code>Program</code> class containing the <code>Main</code> method will be added to the created <code>Program.cs</code> file. This method is the entry point of our program, and we will use its parameter to pass input values to our console application when we execute it. You can skip using <code>--use-program-main</code>, of course, but I prefer using it since it makes the <code>Program</code> class more explicit and familiar to developers coming from older versions of .NET.</li>
			</ul>
			<p>Once the <a id="_idIndexMarker066"/>command completes, you should see an output that looks like this:</p>
			<pre class="console">
PS C:\code&gt; dotnet new console -n helloConsole -o helloConsole --use-program-main
The template "Console App" was created successfully.
Processing post-creation actions...
Restoring C:\code\helloConsole\helloConsole.csproj:
  Determining projects to restore...
  Restored C:\code\helloConsole\helloConsole.csproj (in 121 ms).
Restore succeeded.</pre>			<p>This confirms that the application has been successfully created.</p>
			<p class="callout-heading">A brief tour of the generated project</p>
			<p class="callout">The generated project contains three files:</p>
			<p class="callout">- <code>Main</code> method). While it may contain all the application’s logic in very simple applications, it usually serves as a starting point, delegating to other classes and methods as needed.</p>
			<p class="callout">- <code>.csproj</code>) file is<a id="_idIndexMarker068"/> essential for .NET development as it centralizes project configuration, making it easier to manage, build, and share projects across different development environments and build systems. It’s particularly important in the modern .NET ecosystem, which emphasizes cross-platform development and flexible project structures. In this file, we typically find information about<a id="_idIndexMarker069"/> the project definition, the build configuration, the dependency management (both project references and references to NuGet packages), the compilation settings, resource inclusion, any build process customization, project-wide properties (such as assembly name and version), cross-platform compatibility, and IDE integration.</p>
			<p class="callout">- <code>.sln</code>) file <a id="_idIndexMarker070"/>is a text-based file that serves as a container for organizing and managing related projects. It plays a crucial role in the development workflow, especially for larger applications that comprise multiple projects. Its purpose is to organize multiple related projects into a single solution, define build configurations and platforms for all projects, store solution-wide settings and metadata, and allow Visual Studio to load all related projects simultaneously.</p>
			<p>Now, let’s load the<a id="_idIndexMarker071"/> project into Visual Studio Code by typing this command:</p>
			<pre class="console">
$ code ./helloConsole</pre>			<p>A new instance of Visual Studio Code will open, and you’ll see the content of the newly created project, which looks like this:</p>
			<div><div><img src="img/B22400_03_01.jpg" alt="Figure 3.1 – The helloConsole project opened in Visual Studio Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The helloConsole project opened in Visual Studio Code</p>
			<p class="callout-heading">Do not confuse code with code!</p>
			<p class="callout">The preceding <code>code</code> command is the executable name for Visual Studio Code. It should not be confused with the <code>code</code> folder 😉.</p>
			<p>The code<a id="_idIndexMarker072"/> contained in the <code>Main</code> method of the <code>Program.cs</code> file doesn’t do much at the moment. In fact, it only displays a <code>"Hello, World!"</code> message when the application is executed:</p>
			<pre class="source-code">
namespace helloConsole;
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello, World!");
    }
}</pre>			<p>Let’s execute<a id="_idIndexMarker073"/> this application and see what it returns. For that matter, we will need to type this command:</p>
			<pre class="console">
$ dotnet run</pre>			<p>It is important to note that this command can be executed in any terminal: the PowerShell terminal, the CMD console, or the Bash terminal (if you are running Linux or macOS). However, since we are using Visual Studio Code, the easiest way to run commands is to use the integrated terminal within Visual Studio Code. That being said, you must ensure that you are in the project folder, which means that the <code>dotnet run</code> command should be executed in the same working directory as the <code>.</code><code>csproj</code> file.</p>
			<p>This will build and then execute the application. The output looks like this:</p>
			<div><div><img src="img/B22400_03_02.jpg" alt="Figure 3.2 – Hello, World! output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Hello, World! output</p>
			<p>This is not very useful at the moment, is it?</p>
			<p>However, we<a id="_idIndexMarker074"/> can notice that the <code>Main</code> method takes an array of strings as an argument (that is, as an input parameter). So, let’s use that to pass some parameters to our program.</p>
			<p>First, we modify our application code to show the value of that parameter, as follows:</p>
			<pre class="source-code">
namespace helloConsole;
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine($"Hello, {args[0]}!");
    }
}</pre>			<p>Now, once executed, our program will display the <code>Hello</code> message, followed by the value we<a id="_idIndexMarker075"/> passed in as a parameter.</p>
			<p>Let’s try it:</p>
			<pre class="console">
$ dotnet run Packt</pre>			<p>The result will be as follows:</p>
			<div><div><img src="img/B22400_03_03.jpg" alt="Figure 3.3 – Passing in one parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Passing in one parameter</p>
			<p>We can, of course, pass in more than one parameter, like <a id="_idTextAnchor039"/>this:</p>
			<pre class="console">
$ dotnet run Packt Publishing</pre>			<p>This time, the result will be as follows:</p>
			<div><div><img src="img/B22400_03_04.jpg" alt="Figure 3.4 – Passing in more than one parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Passing in more than one parameter</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There are three remarks you need to be aware of:</p>
			<p class="callout">1. The parameter to be passed to the <code>Main</code> method<a id="_idIndexMarker076"/> is an array of <strong class="bold">strings</strong>. This means that you’ll need to parse these strings if the program is expecting an input of another data type (such as an integer, for example).</p>
			<p class="callout">2. Since this parameter is an array of strings, you can use the passed-in values by specifying their index, which represents their position from the program execution.</p>
			<p class="callout">3. If you use a parameter value in the code but don’t pass it when executing the program, an exception will be thrown.</p>
			<p>What do these remarks mean from a code perspective? Let’s consider some illustrative examples.</p>
			<p>First, we’ll address the first remark. This example shows that the input parameter is of the <code>string</code> type<a id="_idIndexMarker077"/> despite its value, <code>42</code>, representing an integer. In order to use that value as an integer, we need to parse it.</p>
			<div><div><img src="img/B22400_03_05.jpg" alt="Figure 3.5 – Parsing input parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Parsing input parameters</p>
			<p>Next, let’s consider the second remark. This example shows that by switching the indexes of the parameters, we also switch the display of their values.</p>
			<div><div><img src="img/B22400_03_06.jpg" alt="Figure 3.6 – Switching input parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Switching input parameters</p>
			<p>Finally, regarding<a id="_idIndexMarker078"/> the third remark, this example demonstrates that failing to provide a value for the input parameter when executing the program will cause it to crash and throw an exception.</p>
			<div><div><img src="img/B22400_03_07.jpg" alt="Figure 3.7 – Missing an input parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Missing an input parameter</p>
			<p>We now know<a id="_idIndexMarker079"/> how to create and execute .NET console applications. Let’s see how we can interact with user inputs and better format our outputs.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Working with the System.Console class</h1>
			<p>You may have <a id="_idIndexMarker080"/>noticed that in all our examples up to this point, we have used the <code>Console</code> class. More specifically, we only used one of its methods (namely <code>WriteLine</code>). This method displays the value of the expression passed as a parameter, and then gets to the next line. If we don’t want to get to the next line, we can use the <code>Write</code> method instead.</p>
			<p>However, the <code>Console</code> class provides other useful properties and methods. We won’t go into the details of all of them (for that matter, I’d recommend that you visit <a href="https://learn.microsoft.com/en-us/dotnet/api/system.console">https://learn.microsoft.com/en-us/dotnet/api/system.console</a>). Instead, I’ll highlight the most interesting ones when it comes to console applications.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Useful properties</h2>
			<p>There<a id="_idIndexMarker081"/> are three properties I would like to tell you about in particular: <code>BackgroundColor</code>, <code>ForegroundColor</code>, and <code>Title</code>.</p>
			<p>The first two, as their names suggest, are used to alter the background and foreground color of the terminal.</p>
			<p>The third one, <code>Title</code>, is used to alter the title of the terminal window. Keep in mind that you will need to execute the program in an external terminal (not in the Visual Studio Code integrated terminal) to see the effect of changing the terminal’s title.</p>
			<p>Here is an illustrative example:</p>
			<pre class="source-code">
class Program
{
    static void Main(string[] args)
    {
        // performing a backup of the background and
        //foreground colors
        var originalBackroungColor = Console.BackgroundColor;
        var originalForegroundColor = Console.ForegroundColor;
        // changing the background and foreground colors
        Console.BackgroundColor = ConsoleColor.Blue;
        Console.ForegroundColor = ConsoleColor.Yellow;
     // setting the title of the terminal while the
     //application is running
        Console.Title = "Packt Publishing Console App";
        // displaying a message
        Console.WriteLine($"Hello from Packt Publishing!");
        // restoring the background and foreground colors
        // to their original values
        Console.BackgroundColor = originalBackroungColor;
        Console.ForegroundColor = originalForegroundColor;
        // waiting for the user to press a key to end the program.
        // this is useful to see the altering of the terminal's title
        Console.ReadKey(true);
    }
}</pre>			<p>As you<a id="_idIndexMarker082"/> can see, at the beginning of the program, we performed a backup of both the foreground and the background colors, and we restored them at the end of the program.</p>
			<p>There is no need to do this for the terminal’s title since the set value is only effective during the execution of the program.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>Useful methods</h2>
			<p>There <a id="_idIndexMarker083"/>are also a few interesting (and useful) methods I would like to talk about. These are as follows:</p>
			<ul>
				<li><code>ReadLine</code></li>
				<li><code>ReadKey</code></li>
				<li><code>Clear</code></li>
			</ul>
			<p>Let’s start with <code>ReadLine</code>. This method reads all the characters from the user input until they hit <em class="italic">Enter</em> and returns the user input as a <code>string</code>. So, it is useful to gather user inputs, such<a id="_idIndexMarker084"/> as a name, an age, or an address.</p>
			<p>Here is an example:</p>
			<div><div><img src="img/B22400_03_08.jpg" alt="Figure 3.8 – Reading user input from the console"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Reading user input from the console</p>
			<p>Next, Let’s talk about <code>ReadKey</code>. This method reads the character or function key the user pressed. It returns an object of the <code>ConsoleKeyInfo</code> type, which includes information about the pressed key. It also takes an optional Boolean parameter that, if set to <code>true</code>, will not display the pressed key to the console, and if set to <code>false</code>, will display it.</p>
			<p>Here’s an example with the Boolean parameter set to <code>true</code>:</p>
			<div><div><img src="img/B22400_03_09.jpg" alt="Figure 3.9 – A ReadKey method with the Boolean parameter set to true"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – A ReadKey method with the Boolean parameter set to true</p>
			<p>Now, notice the <a id="_idIndexMarker085"/>output when the Boolean parameter is set to <code>false</code>:</p>
			<div><div><img src="img/B22400_03_10.jpg" alt="Figure 3.10 – A ReadKey method with the Boolean parameter set to false"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – A ReadKey method with the Boolean parameter set to false</p>
			<p>Have you noticed <a id="_idIndexMarker086"/>that the pressed key is displayed twice: once after it is pressed, and a second time with the output message?</p>
			<p>By the way, you can visit <a href="https://learn.microsoft.com/en-us/dotnet/api/system.consolekey">https://learn.microsoft.com/en-us/dotnet/api/system.consolekey</a> to find a list of all of the values of the <code>ConsoleKey</code> enumeration.</p>
			<p>Finally, let’s see the <code>Clear</code> method. As its name suggests, it clears the console:</p>
			<div><div><img src="img/B22400_03_11.jpg" alt="Figure 3.11 – Clearing the console with the Clear method"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Clearing the console with the Clear method</p>
			<p>After the user<a id="_idIndexMarker087"/> presses the <em class="italic">C</em> key, the console is cleared.</p>
			<p>This command is typically used in the following scenarios:</p>
			<ul>
				<li><strong class="bold">At the startup of the program</strong>: It is used here so that your program gets a clean interface by removing all previous outputs from other programs or commands</li>
				<li><strong class="bold">When entering a new section or menu item</strong>: This prevents outputs from previous sections from polluting the current one</li>
			</ul>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Useful event</h2>
			<p>If you’ve<a id="_idIndexMarker088"/> ever run a CLI application, you’re probably aware of the <em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em> key combinations that make you exit the program at any time by terminating it.</p>
			<p>In a .NET console application, these key combinations raise an event called <code>CancelKeyPress</code>. When one of the key combinations is pressed, the event is raised and interrupts the operation being executed. Our code can handle this event to allow for a graceful shutdown of the program, cleaning and freeing up resources before the shutdown.</p>
			<p>Let’s illustrate this <a id="_idIndexMarker089"/>with an example. Consider the following code:</p>
			<pre class="source-code">
using System.Threading.Tasks;
class Program
{
    static void Main(string[] args)
    {
        int counter = 1;
        while(true)
        {
            Console.WriteLine($"Printing line number {counter}");
            counter++;
            Task delayTask = Task.Run(async () =&gt; await Task.
            Delay(1000));
            delayTask.Wait();
        }
    }
}</pre>			<p>As you may notice, this code uses an infinite loop with no exit condition. Hence, the only way to exit from it is by using one of the canceling key combinations (<em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em>). However, when pressed, this will abruptly terminate the program without giving it a chance to perform some actions in order to exit gracefully, such as the following:</p>
			<ul>
				<li>Saving the execution state</li>
				<li>Logging out of services</li>
				<li>Closing database connections</li>
			</ul>
			<p>We will <a id="_idIndexMarker090"/>then modify the previous code to handle that termination event, allowing the program to gracefully terminate:</p>
			<pre class="source-code">
using System.Threading.Tasks;
class Program
{
    static void Main(string[] args)
    {
        Console.CancelKeyPress += (sender, e) =&gt;
        {
            e.Cancel = true; // This will prevent the program from 
                             // terminating immediately
            Console.WriteLine("CancelKeyPress event raised!\
            nPerforming cleanup...");
            // Performing cleanup operations (logging out of services, 
            saving progress state, closing database connections,...)
            Environment.Exit(0); // This will terminate the program 
                                 // when cleanup is done
        };
        int counter = 1;
        while(true)
        {
            Console.WriteLine($"Printing line number {counter}");
            counter++;
            Task delayTask = Task.Run(async () =&gt; await Task.
            Delay(1000));
            delayTask.Wait();
        }
    }
}</pre>			<p>Now, the result <a id="_idIndexMarker091"/>of the execution looks like this:</p>
			<div><div><img src="img/B22400_03_12.jpg" alt="Figure 3.12 – Canceling the current operation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Canceling the current operation</p>
			<p>So, if your CLI application<a id="_idIndexMarker092"/> interacts with external resources or services (as we will do in the upcoming chapters), you should leverage the <code>Console.CancelKeyPress</code> event.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor044"/>One more thing</h1>
			<p>Up to this <a id="_idIndexMarker093"/>point, we have executed the program using the .NET CLI <code>run</code> command.</p>
			<p>However, if you are familiar with CLI applications, you will know that this type of application is usually executed by the name of its executable file.</p>
			<p>The first question that comes to mind is “Why have we executed our program using the .NET CLI <code>run</code> command?”. The answer is “because this is how you will do it when developing and testing your CLI application.”</p>
			<p>The next question that comes to mind is “Well, how do I execute my program using its executable?”. The answer to that question is “by reaching the location of that executable file and running the program from there.”</p>
			<p>Let’s see how we do this.</p>
			<p>When you build the program, use the following command:</p>
			<pre class="console">
$ dotnet build</pre>			<p>This will generate the executable file in the <code>bin\Debug\net8.0</code> folder on your hard drive.</p>
			<p>On a Windows machine, this will look like this:</p>
			<div><div><img src="img/B22400_03_13.jpg" alt="Figure 3.13 – The generated executable file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – The generated executable file</p>
			<p>To run the <a id="_idIndexMarker094"/>program using its executable file name, open a terminal window, navigate to that location, and then type the following command (here, we are passing <code>42</code> as a parameter):</p>
			<pre class="console">
$ .\helloConsole 42</pre>			<p>The result should be similar to this:</p>
			<div><div><img src="img/B22400_03_14.jpg" alt="Figure 3.14 – Running the program from its executable file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Running the program from its executable file</p>
			<p class="callout-heading">Should I use dotnet run or run the executable file?</p>
			<p class="callout">There are some differences between running the program using the <code>dotnet run</code> command and running the program from its executable file. Here are the most significant ones:</p>
			<p class="callout">- <code>dotnet run</code> command <a id="_idIndexMarker095"/>builds the project before running it, which ensures that we are always running the most up-to-date version of the code. The executable file represents the last compiled version of the code.</p>
			<p class="callout">- <code>dotnet run</code> is slower (due to the build step) compared to running the program from its executable file. While the <code>dotnet run</code> command may take a few seconds to build and execute the code, the executable file usually executes in a matter of milliseconds.</p>
			<p>It is important to keep <a id="_idIndexMarker096"/>this in mind since, during the development phase, you’ll likely rely on <code>dotnet run</code> to execute your program. However, in the testing and production phases, you’ll rely on the name of the executable. So, make sure you carefully choose the name for your program (and its executable) 😉.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor045"/>Summary</h1>
			<p>In this chapter, we explored what lies at the core of a CLI application: a console application! This is why it is crucial to learn how to work with console applications, as they are the foundation for building more complex CLI applications.</p>
			<p>We saw how we can execute a console application, providing values as input parameters and parsing these input parameters’ values in order to convert them into the data type expected by our program. We saw how we can gather user inputs through the use of the <code>ReadKey</code> and <code>ReadLine</code> methods of the <code>Console</code> class. Finally, we saw how we can handle exceptions raised as the result of a missing input parameter value.</p>
			<p>However, a CLI application is more than a console one. It contains named parameters, flags, and subcommands.</p>
			<p>In the upcoming chapters, we will see how we can leverage these capabilities into a fully functional CLI application. In the next chapter, we will start by creating the CLI application and learning how to parse its inputs, including commands, flags, and parameters.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to achieve the following task:</p>
			<p>Create a console application that does the following:</p>
			<ul>
				<li>Sets the title of the terminal window to <strong class="bold">GUESSING GAME!</strong></li>
				<li>Generates a random integer value between 1 and 20</li>
				<li>Tells the player that they have three chances to figure out that number</li>
				<li>After each player’s trial, it should then do the following:<ul><li>If the player figured out the number, the program displays, in green text, <strong class="bold">Congratulations, you won!</strong>, along with the number of trials it took the player to figure it out</li><li>If the player was not able to figure out the number within the three granted trials, the program should display, in red text, <strong class="bold">Better luck next time! The number to be guessed was</strong> along with the value to be guessed</li><li>If the player hits <em class="italic">Enter</em> without providing a number, the program should consider that the value is zero and proceed with it</li><li>If the player hits <em class="italic">Ctrl </em>+ <em class="italic">C</em>, the program should exit and display, in yellow text, <strong class="bold">Thank you </strong><strong class="bold">for playing!</strong></li></ul></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-46" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor047"/>Part 2: Foundations of Building CLI Applications</h1>
			<p>In this part, you will delve into the essential components of CLI application development. You'll explore command-line parsing techniques, learning how to effectively handle user input and parse arguments using libraries. Next, you'll learn about input/output operations and file handling, covering methods to read from and write to files, as well as manipulate file streams for efficient data processing. Finally, you'll discover best practices for error handling and logging, including implementing structured logging with different severity levels, gracefully managing exceptions, and providing informative error messages to users while maintaining detailed logs for debugging purposes.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B22400_04.xhtml#_idTextAnchor048"><em class="italic">Chapter 4</em></a><em class="italic">, Command-Line Parsing</em></li>
				<li><a href="B22400_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a><em class="italic">, Input/Output and File Handling</em></li>
				<li><a href="B22400_06.xhtml#_idTextAnchor084"><em class="italic">Chapter 6</em></a><em class="italic">, Error Handling and Logging</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>